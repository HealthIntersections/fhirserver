unit fhir5_turtle;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
}

{$i fhir.inc}
{$i fhir5.inc}

interface

// Generated on Thu, Nov 10, 2022 for FHIR v5.0.0



uses
  SysUtils, Classes, 
  fsl_base, fsl_utilities, fsl_collections, fsl_turtle, 
  fhir_parser, fhir_objects, 
  fhir5_parserBase, fhir5_resources, fhir5_resources_base, fhir5_constants, fhir5_base, fhir5_enums, fhir5_types;

Type

  TFHIRTurtleParser = class (TFHIRTurtleParserBase5)
  protected
    procedure ParseBaseProperties(obj : TTurtleComplex; value : TFhirBase); overload;
    procedure ParseBaseProperties(obj : TTurtleComplex; value : TFhirResource); overload;
  
    procedure ParseElementProperties(obj : TTurtleComplex; value : TFhirElement);
    procedure ParseBackboneElementProperties(obj : TTurtleComplex; value : TFhirBackboneElement);
    procedure ParseDataTypeProperties(obj : TTurtleComplex; value : TFhirDataType);
    procedure ParseBackboneTypeProperties(obj : TTurtleComplex; value : TFhirBackboneType);
    procedure ParsePrimitiveTypeProperties(obj : TTurtleComplex; value : TFhirPrimitiveType);


    function ParseEnum(obj : TTurtleComplex; Const aNames, aSystems : Array Of String) : TFHIREnum; overload;
    function ParseDate(obj : TTurtleComplex) : TFHIRDate; overload;
    function ParseDateTime(obj : TTurtleComplex) : TFHIRDateTime; overload;
    function ParseString(obj : TTurtleComplex) : TFHIRString; overload;
    function ParseInteger(obj : TTurtleComplex) : TFHIRInteger; overload;
    function ParseUri(obj : TTurtleComplex) : TFHIRUri; overload;
    function ParseInstant(obj : TTurtleComplex) : TFHIRInstant; overload;
    function ParseXhtml(obj : TTurtleComplex) : TFHIRXhtml; overload;
    function ParseBoolean(obj : TTurtleComplex) : TFHIRBoolean; overload;
    function ParseBase64Binary(obj : TTurtleComplex) : TFHIRBase64Binary; overload;
    function ParseTime(obj : TTurtleComplex) : TFHIRTime; overload;
    function ParseDecimal(obj : TTurtleComplex) : TFHIRDecimal; overload;
    function ParseCode(obj : TTurtleComplex) : TFHIRCode; overload;
    function ParseCanonical(obj : TTurtleComplex) : TFHIRCanonical; overload;
    function ParseOid(obj : TTurtleComplex) : TFHIROid; overload;
    function ParseUuid(obj : TTurtleComplex) : TFHIRUuid; overload;
    function ParseUrl(obj : TTurtleComplex) : TFHIRUrl; overload;
    function ParseMarkdown(obj : TTurtleComplex) : TFHIRMarkdown; overload;
    function ParseUnsignedInt(obj : TTurtleComplex) : TFHIRUnsignedInt; overload;
    function ParseId(obj : TTurtleComplex) : TFHIRId; overload;
    function ParsePositiveInt(obj : TTurtleComplex) : TFHIRPositiveInt; overload;
    function ParseInteger64(obj : TTurtleComplex) : TFHIRInteger64; overload;

    function ParseAddress(obj : TTurtleComplex) : TFhirAddress; overload; 
    procedure ParseAddressProperties(obj : TTurtleComplex; value : TFhirAddress); overload; 
    function ParseAnnotation(obj : TTurtleComplex) : TFhirAnnotation; overload; 
    procedure ParseAnnotationProperties(obj : TTurtleComplex; value : TFhirAnnotation); overload; 
    function ParseAttachment(obj : TTurtleComplex) : TFhirAttachment; overload; 
    procedure ParseAttachmentProperties(obj : TTurtleComplex; value : TFhirAttachment); overload; 
    function ParseAvailabilityAvailableTime(obj : TTurtleComplex) : TFhirAvailabilityAvailableTime; overload; 
    procedure ParseAvailabilityAvailableTimeProperties(obj : TTurtleComplex; value : TFhirAvailabilityAvailableTime); overload; 
    function ParseAvailabilityNotAvailableTime(obj : TTurtleComplex) : TFhirAvailabilityNotAvailableTime; overload; 
    procedure ParseAvailabilityNotAvailableTimeProperties(obj : TTurtleComplex; value : TFhirAvailabilityNotAvailableTime); overload; 
    function ParseAvailability(obj : TTurtleComplex) : TFhirAvailability; overload; 
    procedure ParseAvailabilityProperties(obj : TTurtleComplex; value : TFhirAvailability); overload; 
    function ParseCodeableConcept(obj : TTurtleComplex) : TFhirCodeableConcept; overload; 
    procedure ParseCodeableConceptProperties(obj : TTurtleComplex; value : TFhirCodeableConcept); overload; 
    function ParseCodeableReference(obj : TTurtleComplex) : TFhirCodeableReference; overload; 
    procedure ParseCodeableReferenceProperties(obj : TTurtleComplex; value : TFhirCodeableReference); overload; 
    function ParseCoding(obj : TTurtleComplex) : TFhirCoding; overload; 
    procedure ParseCodingProperties(obj : TTurtleComplex; value : TFhirCoding); overload; 
    function ParseContactDetail(obj : TTurtleComplex) : TFhirContactDetail; overload; 
    procedure ParseContactDetailProperties(obj : TTurtleComplex; value : TFhirContactDetail); overload; 
    function ParseContactPoint(obj : TTurtleComplex) : TFhirContactPoint; overload; 
    procedure ParseContactPointProperties(obj : TTurtleComplex; value : TFhirContactPoint); overload; 
    function ParseContributor(obj : TTurtleComplex) : TFhirContributor; overload; 
    procedure ParseContributorProperties(obj : TTurtleComplex; value : TFhirContributor); overload; 
    function ParseDataRequirementCodeFilter(obj : TTurtleComplex) : TFhirDataRequirementCodeFilter; overload; 
    procedure ParseDataRequirementCodeFilterProperties(obj : TTurtleComplex; value : TFhirDataRequirementCodeFilter); overload; 
    function ParseDataRequirementDateFilter(obj : TTurtleComplex) : TFhirDataRequirementDateFilter; overload; 
    procedure ParseDataRequirementDateFilterProperties(obj : TTurtleComplex; value : TFhirDataRequirementDateFilter); overload; 
    function ParseDataRequirementValueFilter(obj : TTurtleComplex) : TFhirDataRequirementValueFilter; overload; 
    procedure ParseDataRequirementValueFilterProperties(obj : TTurtleComplex; value : TFhirDataRequirementValueFilter); overload; 
    function ParseDataRequirementSort(obj : TTurtleComplex) : TFhirDataRequirementSort; overload; 
    procedure ParseDataRequirementSortProperties(obj : TTurtleComplex; value : TFhirDataRequirementSort); overload; 
    function ParseDataRequirement(obj : TTurtleComplex) : TFhirDataRequirement; overload; 
    procedure ParseDataRequirementProperties(obj : TTurtleComplex; value : TFhirDataRequirement); overload; 
    function ParseExpression(obj : TTurtleComplex) : TFhirExpression; overload; 
    procedure ParseExpressionProperties(obj : TTurtleComplex; value : TFhirExpression); overload; 
    function ParseExtendedContactDetail(obj : TTurtleComplex) : TFhirExtendedContactDetail; overload; 
    procedure ParseExtendedContactDetailProperties(obj : TTurtleComplex; value : TFhirExtendedContactDetail); overload; 
    function ParseExtension(obj : TTurtleComplex) : TFhirExtension; overload; 
    procedure ParseExtensionProperties(obj : TTurtleComplex; value : TFhirExtension); overload; 
    function ParseHumanName(obj : TTurtleComplex) : TFhirHumanName; overload; 
    procedure ParseHumanNameProperties(obj : TTurtleComplex; value : TFhirHumanName); overload; 
    function ParseIdentifier(obj : TTurtleComplex) : TFhirIdentifier; overload; 
    procedure ParseIdentifierProperties(obj : TTurtleComplex; value : TFhirIdentifier); overload; 
    function ParseMeta(obj : TTurtleComplex) : TFhirMeta; overload; 
    procedure ParseMetaProperties(obj : TTurtleComplex; value : TFhirMeta); overload; 
    function ParseMonetaryComponent(obj : TTurtleComplex) : TFhirMonetaryComponent; overload; 
    procedure ParseMonetaryComponentProperties(obj : TTurtleComplex; value : TFhirMonetaryComponent); overload; 
    function ParseMoney(obj : TTurtleComplex) : TFhirMoney; overload; 
    procedure ParseMoneyProperties(obj : TTurtleComplex; value : TFhirMoney); overload; 
    function ParseNarrative(obj : TTurtleComplex) : TFhirNarrative; overload; 
    procedure ParseNarrativeProperties(obj : TTurtleComplex; value : TFhirNarrative); overload; 
    function ParseParameterDefinition(obj : TTurtleComplex) : TFhirParameterDefinition; overload; 
    procedure ParseParameterDefinitionProperties(obj : TTurtleComplex; value : TFhirParameterDefinition); overload; 
    function ParsePeriod(obj : TTurtleComplex) : TFhirPeriod; overload; 
    procedure ParsePeriodProperties(obj : TTurtleComplex; value : TFhirPeriod); overload; 
    function ParseQuantity(obj : TTurtleComplex) : TFhirQuantity; overload; 
    procedure ParseQuantityProperties(obj : TTurtleComplex; value : TFhirQuantity); overload; 
    function ParseRange(obj : TTurtleComplex) : TFhirRange; overload; 
    procedure ParseRangeProperties(obj : TTurtleComplex; value : TFhirRange); overload; 
    function ParseRatio(obj : TTurtleComplex) : TFhirRatio; overload; 
    procedure ParseRatioProperties(obj : TTurtleComplex; value : TFhirRatio); overload; 
    function ParseRatioRange(obj : TTurtleComplex) : TFhirRatioRange; overload; 
    procedure ParseRatioRangeProperties(obj : TTurtleComplex; value : TFhirRatioRange); overload; 
    function ParseReference(obj : TTurtleComplex) : TFhirReference; overload; 
    procedure ParseReferenceProperties(obj : TTurtleComplex; value : TFhirReference); overload; 
    function ParseRelatedArtifact(obj : TTurtleComplex) : TFhirRelatedArtifact; overload; 
    procedure ParseRelatedArtifactProperties(obj : TTurtleComplex; value : TFhirRelatedArtifact); overload; 
    function ParseSampledData(obj : TTurtleComplex) : TFhirSampledData; overload; 
    procedure ParseSampledDataProperties(obj : TTurtleComplex; value : TFhirSampledData); overload; 
    function ParseSignature(obj : TTurtleComplex) : TFhirSignature; overload; 
    procedure ParseSignatureProperties(obj : TTurtleComplex; value : TFhirSignature); overload; 
    function ParseTriggerDefinition(obj : TTurtleComplex) : TFhirTriggerDefinition; overload; 
    procedure ParseTriggerDefinitionProperties(obj : TTurtleComplex; value : TFhirTriggerDefinition); overload; 
    function ParseUsageContext(obj : TTurtleComplex) : TFhirUsageContext; overload; 
    procedure ParseUsageContextProperties(obj : TTurtleComplex; value : TFhirUsageContext); overload; 
    function ParseVirtualServiceDetail(obj : TTurtleComplex) : TFhirVirtualServiceDetail; overload; 
    procedure ParseVirtualServiceDetailProperties(obj : TTurtleComplex; value : TFhirVirtualServiceDetail); overload; 
    function ParseAge(obj : TTurtleComplex) : TFhirAge; overload; 
    procedure ParseAgeProperties(obj : TTurtleComplex; value : TFhirAge); overload; 
    function ParseCount(obj : TTurtleComplex) : TFhirCount; overload; 
    procedure ParseCountProperties(obj : TTurtleComplex; value : TFhirCount); overload; 
    function ParseDistance(obj : TTurtleComplex) : TFhirDistance; overload; 
    procedure ParseDistanceProperties(obj : TTurtleComplex; value : TFhirDistance); overload; 
    function ParseDosageDoseAndRate(obj : TTurtleComplex) : TFhirDosageDoseAndRate; overload; 
    procedure ParseDosageDoseAndRateProperties(obj : TTurtleComplex; value : TFhirDosageDoseAndRate); overload; 
    function ParseDosage(obj : TTurtleComplex) : TFhirDosage; overload; 
    procedure ParseDosageProperties(obj : TTurtleComplex; value : TFhirDosage); overload; 
    function ParseDuration(obj : TTurtleComplex) : TFhirDuration; overload; 
    procedure ParseDurationProperties(obj : TTurtleComplex; value : TFhirDuration); overload; 
    function ParseElementDefinitionSlicing(obj : TTurtleComplex) : TFhirElementDefinitionSlicing; overload; 
    procedure ParseElementDefinitionSlicingProperties(obj : TTurtleComplex; value : TFhirElementDefinitionSlicing); overload; 
    function ParseElementDefinitionSlicingDiscriminator(obj : TTurtleComplex) : TFhirElementDefinitionSlicingDiscriminator; overload; 
    procedure ParseElementDefinitionSlicingDiscriminatorProperties(obj : TTurtleComplex; value : TFhirElementDefinitionSlicingDiscriminator); overload; 
    function ParseElementDefinitionBase(obj : TTurtleComplex) : TFhirElementDefinitionBase; overload; 
    procedure ParseElementDefinitionBaseProperties(obj : TTurtleComplex; value : TFhirElementDefinitionBase); overload; 
    function ParseElementDefinitionType(obj : TTurtleComplex) : TFhirElementDefinitionType; overload; 
    procedure ParseElementDefinitionTypeProperties(obj : TTurtleComplex; value : TFhirElementDefinitionType); overload; 
    function ParseElementDefinitionExample(obj : TTurtleComplex) : TFhirElementDefinitionExample; overload; 
    procedure ParseElementDefinitionExampleProperties(obj : TTurtleComplex; value : TFhirElementDefinitionExample); overload; 
    function ParseElementDefinitionConstraint(obj : TTurtleComplex) : TFhirElementDefinitionConstraint; overload; 
    procedure ParseElementDefinitionConstraintProperties(obj : TTurtleComplex; value : TFhirElementDefinitionConstraint); overload; 
    function ParseElementDefinitionBinding(obj : TTurtleComplex) : TFhirElementDefinitionBinding; overload; 
    procedure ParseElementDefinitionBindingProperties(obj : TTurtleComplex; value : TFhirElementDefinitionBinding); overload; 
    function ParseElementDefinitionMapping(obj : TTurtleComplex) : TFhirElementDefinitionMapping; overload; 
    procedure ParseElementDefinitionMappingProperties(obj : TTurtleComplex; value : TFhirElementDefinitionMapping); overload; 
    function ParseElementDefinition(obj : TTurtleComplex) : TFhirElementDefinition; overload; 
    procedure ParseElementDefinitionProperties(obj : TTurtleComplex; value : TFhirElementDefinition); overload; 
    function ParseMarketingStatus(obj : TTurtleComplex) : TFhirMarketingStatus; overload; 
    procedure ParseMarketingStatusProperties(obj : TTurtleComplex; value : TFhirMarketingStatus); overload; 
    function ParsePopulation(obj : TTurtleComplex) : TFhirPopulation; overload; 
    procedure ParsePopulationProperties(obj : TTurtleComplex; value : TFhirPopulation); overload; 
    function ParseProductShelfLife(obj : TTurtleComplex) : TFhirProductShelfLife; overload; 
    procedure ParseProductShelfLifeProperties(obj : TTurtleComplex; value : TFhirProductShelfLife); overload; 
    function ParseTimingRepeat(obj : TTurtleComplex) : TFhirTimingRepeat; overload; 
    procedure ParseTimingRepeatProperties(obj : TTurtleComplex; value : TFhirTimingRepeat); overload; 
    function ParseTiming(obj : TTurtleComplex) : TFhirTiming; overload; 
    procedure ParseTimingProperties(obj : TTurtleComplex; value : TFhirTiming); overload; 


    procedure ParseResourceProperties(obj : TTurtleComplex; value : TFhirResource);
    procedure ParseDomainResourceProperties(obj : TTurtleComplex; value : TFhirDomainResource);
    procedure ParseCanonicalResourceProperties(obj : TTurtleComplex; value : TFhirCanonicalResource);
    procedure ParseMetadataResourceProperties(obj : TTurtleComplex; value : TFhirMetadataResource);


{$IFDEF FHIR_ACCOUNT}
    function ParseAccountCoverage(obj : TTurtleComplex) : TFhirAccountCoverage; overload; 
    procedure ParseAccountCoverageProperties(obj : TTurtleComplex; value : TFhirAccountCoverage); overload; 
    function ParseAccountGuarantor(obj : TTurtleComplex) : TFhirAccountGuarantor; overload; 
    procedure ParseAccountGuarantorProperties(obj : TTurtleComplex; value : TFhirAccountGuarantor); overload; 
    function ParseAccountRelatedAccount(obj : TTurtleComplex) : TFhirAccountRelatedAccount; overload; 
    procedure ParseAccountRelatedAccountProperties(obj : TTurtleComplex; value : TFhirAccountRelatedAccount); overload; 
    function ParseAccountBalance(obj : TTurtleComplex) : TFhirAccountBalance; overload; 
    procedure ParseAccountBalanceProperties(obj : TTurtleComplex; value : TFhirAccountBalance); overload; 
    function ParseAccount(obj : TTurtleComplex) : TFhirAccount; overload; 
    procedure ParseAccountProperties(obj : TTurtleComplex; value : TFhirAccount); overload; 
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
    function ParseActivityDefinitionParticipant(obj : TTurtleComplex) : TFhirActivityDefinitionParticipant; overload; 
    procedure ParseActivityDefinitionParticipantProperties(obj : TTurtleComplex; value : TFhirActivityDefinitionParticipant); overload; 
    function ParseActivityDefinitionDynamicValue(obj : TTurtleComplex) : TFhirActivityDefinitionDynamicValue; overload; 
    procedure ParseActivityDefinitionDynamicValueProperties(obj : TTurtleComplex; value : TFhirActivityDefinitionDynamicValue); overload; 
    function ParseActivityDefinition(obj : TTurtleComplex) : TFhirActivityDefinition; overload; 
    procedure ParseActivityDefinitionProperties(obj : TTurtleComplex; value : TFhirActivityDefinition); overload; 
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ACTORDEFINITION}
    function ParseActorDefinition(obj : TTurtleComplex) : TFhirActorDefinition; overload; 
    procedure ParseActorDefinitionProperties(obj : TTurtleComplex; value : TFhirActorDefinition); overload; 
{$ENDIF FHIR_ACTORDEFINITION}
{$IFDEF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
    function ParseAdministrableProductDefinitionProperty(obj : TTurtleComplex) : TFhirAdministrableProductDefinitionProperty; overload; 
    procedure ParseAdministrableProductDefinitionPropertyProperties(obj : TTurtleComplex; value : TFhirAdministrableProductDefinitionProperty); overload; 
    function ParseAdministrableProductDefinitionRouteOfAdministration(obj : TTurtleComplex) : TFhirAdministrableProductDefinitionRouteOfAdministration; overload; 
    procedure ParseAdministrableProductDefinitionRouteOfAdministrationProperties(obj : TTurtleComplex; value : TFhirAdministrableProductDefinitionRouteOfAdministration); overload; 
    function ParseAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(obj : TTurtleComplex) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies; overload; 
    procedure ParseAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesProperties(obj : TTurtleComplex; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies); overload; 
    function ParseAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(obj : TTurtleComplex) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod; overload; 
    procedure ParseAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodProperties(obj : TTurtleComplex; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod); overload; 
    function ParseAdministrableProductDefinition(obj : TTurtleComplex) : TFhirAdministrableProductDefinition; overload; 
    procedure ParseAdministrableProductDefinitionProperties(obj : TTurtleComplex; value : TFhirAdministrableProductDefinition); overload; 
{$ENDIF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
    function ParseAdverseEventParticipant(obj : TTurtleComplex) : TFhirAdverseEventParticipant; overload; 
    procedure ParseAdverseEventParticipantProperties(obj : TTurtleComplex; value : TFhirAdverseEventParticipant); overload; 
    function ParseAdverseEventSuspectEntity(obj : TTurtleComplex) : TFhirAdverseEventSuspectEntity; overload; 
    procedure ParseAdverseEventSuspectEntityProperties(obj : TTurtleComplex; value : TFhirAdverseEventSuspectEntity); overload; 
    function ParseAdverseEventSuspectEntityCausality(obj : TTurtleComplex) : TFhirAdverseEventSuspectEntityCausality; overload; 
    procedure ParseAdverseEventSuspectEntityCausalityProperties(obj : TTurtleComplex; value : TFhirAdverseEventSuspectEntityCausality); overload; 
    function ParseAdverseEventContributingFactor(obj : TTurtleComplex) : TFhirAdverseEventContributingFactor; overload; 
    procedure ParseAdverseEventContributingFactorProperties(obj : TTurtleComplex; value : TFhirAdverseEventContributingFactor); overload; 
    function ParseAdverseEventPreventiveAction(obj : TTurtleComplex) : TFhirAdverseEventPreventiveAction; overload; 
    procedure ParseAdverseEventPreventiveActionProperties(obj : TTurtleComplex; value : TFhirAdverseEventPreventiveAction); overload; 
    function ParseAdverseEventMitigatingAction(obj : TTurtleComplex) : TFhirAdverseEventMitigatingAction; overload; 
    procedure ParseAdverseEventMitigatingActionProperties(obj : TTurtleComplex; value : TFhirAdverseEventMitigatingAction); overload; 
    function ParseAdverseEventSupportingInfo(obj : TTurtleComplex) : TFhirAdverseEventSupportingInfo; overload; 
    procedure ParseAdverseEventSupportingInfoProperties(obj : TTurtleComplex; value : TFhirAdverseEventSupportingInfo); overload; 
    function ParseAdverseEvent(obj : TTurtleComplex) : TFhirAdverseEvent; overload; 
    procedure ParseAdverseEventProperties(obj : TTurtleComplex; value : TFhirAdverseEvent); overload; 
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
    function ParseAllergyIntoleranceParticipant(obj : TTurtleComplex) : TFhirAllergyIntoleranceParticipant; overload; 
    procedure ParseAllergyIntoleranceParticipantProperties(obj : TTurtleComplex; value : TFhirAllergyIntoleranceParticipant); overload; 
    function ParseAllergyIntoleranceReaction(obj : TTurtleComplex) : TFhirAllergyIntoleranceReaction; overload; 
    procedure ParseAllergyIntoleranceReactionProperties(obj : TTurtleComplex; value : TFhirAllergyIntoleranceReaction); overload; 
    function ParseAllergyIntolerance(obj : TTurtleComplex) : TFhirAllergyIntolerance; overload; 
    procedure ParseAllergyIntoleranceProperties(obj : TTurtleComplex; value : TFhirAllergyIntolerance); overload; 
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
    function ParseAppointmentParticipant(obj : TTurtleComplex) : TFhirAppointmentParticipant; overload; 
    procedure ParseAppointmentParticipantProperties(obj : TTurtleComplex; value : TFhirAppointmentParticipant); overload; 
    function ParseAppointmentRecurrenceTemplate(obj : TTurtleComplex) : TFhirAppointmentRecurrenceTemplate; overload; 
    procedure ParseAppointmentRecurrenceTemplateProperties(obj : TTurtleComplex; value : TFhirAppointmentRecurrenceTemplate); overload; 
    function ParseAppointmentRecurrenceTemplateWeeklyTemplate(obj : TTurtleComplex) : TFhirAppointmentRecurrenceTemplateWeeklyTemplate; overload; 
    procedure ParseAppointmentRecurrenceTemplateWeeklyTemplateProperties(obj : TTurtleComplex; value : TFhirAppointmentRecurrenceTemplateWeeklyTemplate); overload; 
    function ParseAppointmentRecurrenceTemplateMonthlyTemplate(obj : TTurtleComplex) : TFhirAppointmentRecurrenceTemplateMonthlyTemplate; overload; 
    procedure ParseAppointmentRecurrenceTemplateMonthlyTemplateProperties(obj : TTurtleComplex; value : TFhirAppointmentRecurrenceTemplateMonthlyTemplate); overload; 
    function ParseAppointmentRecurrenceTemplateYearlyTemplate(obj : TTurtleComplex) : TFhirAppointmentRecurrenceTemplateYearlyTemplate; overload; 
    procedure ParseAppointmentRecurrenceTemplateYearlyTemplateProperties(obj : TTurtleComplex; value : TFhirAppointmentRecurrenceTemplateYearlyTemplate); overload; 
    function ParseAppointment(obj : TTurtleComplex) : TFhirAppointment; overload; 
    procedure ParseAppointmentProperties(obj : TTurtleComplex; value : TFhirAppointment); overload; 
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
    function ParseAppointmentResponse(obj : TTurtleComplex) : TFhirAppointmentResponse; overload; 
    procedure ParseAppointmentResponseProperties(obj : TTurtleComplex; value : TFhirAppointmentResponse); overload; 
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_ARTIFACTASSESSMENT}
    function ParseArtifactAssessmentContent(obj : TTurtleComplex) : TFhirArtifactAssessmentContent; overload; 
    procedure ParseArtifactAssessmentContentProperties(obj : TTurtleComplex; value : TFhirArtifactAssessmentContent); overload; 
    function ParseArtifactAssessment(obj : TTurtleComplex) : TFhirArtifactAssessment; overload; 
    procedure ParseArtifactAssessmentProperties(obj : TTurtleComplex; value : TFhirArtifactAssessment); overload; 
{$ENDIF FHIR_ARTIFACTASSESSMENT}
{$IFDEF FHIR_AUDITEVENT}
    function ParseAuditEventOutcome(obj : TTurtleComplex) : TFhirAuditEventOutcome; overload; 
    procedure ParseAuditEventOutcomeProperties(obj : TTurtleComplex; value : TFhirAuditEventOutcome); overload; 
    function ParseAuditEventAgent(obj : TTurtleComplex) : TFhirAuditEventAgent; overload; 
    procedure ParseAuditEventAgentProperties(obj : TTurtleComplex; value : TFhirAuditEventAgent); overload; 
    function ParseAuditEventSource(obj : TTurtleComplex) : TFhirAuditEventSource; overload; 
    procedure ParseAuditEventSourceProperties(obj : TTurtleComplex; value : TFhirAuditEventSource); overload; 
    function ParseAuditEventEntity(obj : TTurtleComplex) : TFhirAuditEventEntity; overload; 
    procedure ParseAuditEventEntityProperties(obj : TTurtleComplex; value : TFhirAuditEventEntity); overload; 
    function ParseAuditEventEntityDetail(obj : TTurtleComplex) : TFhirAuditEventEntityDetail; overload; 
    procedure ParseAuditEventEntityDetailProperties(obj : TTurtleComplex; value : TFhirAuditEventEntityDetail); overload; 
    function ParseAuditEvent(obj : TTurtleComplex) : TFhirAuditEvent; overload; 
    procedure ParseAuditEventProperties(obj : TTurtleComplex; value : TFhirAuditEvent); overload; 
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
    function ParseBasic(obj : TTurtleComplex) : TFhirBasic; overload; 
    procedure ParseBasicProperties(obj : TTurtleComplex; value : TFhirBasic); overload; 
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
    function ParseBinary(obj : TTurtleComplex) : TFhirBinary; overload; 
    procedure ParseBinaryProperties(obj : TTurtleComplex; value : TFhirBinary); overload; 
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
    function ParseBiologicallyDerivedProductCollection(obj : TTurtleComplex) : TFhirBiologicallyDerivedProductCollection; overload; 
    procedure ParseBiologicallyDerivedProductCollectionProperties(obj : TTurtleComplex; value : TFhirBiologicallyDerivedProductCollection); overload; 
    function ParseBiologicallyDerivedProductProperty(obj : TTurtleComplex) : TFhirBiologicallyDerivedProductProperty; overload; 
    procedure ParseBiologicallyDerivedProductPropertyProperties(obj : TTurtleComplex; value : TFhirBiologicallyDerivedProductProperty); overload; 
    function ParseBiologicallyDerivedProduct(obj : TTurtleComplex) : TFhirBiologicallyDerivedProduct; overload; 
    procedure ParseBiologicallyDerivedProductProperties(obj : TTurtleComplex; value : TFhirBiologicallyDerivedProduct); overload; 
{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
    function ParseBodyStructureIncludedStructure(obj : TTurtleComplex) : TFhirBodyStructureIncludedStructure; overload; 
    procedure ParseBodyStructureIncludedStructureProperties(obj : TTurtleComplex; value : TFhirBodyStructureIncludedStructure); overload; 
    function ParseBodyStructureExcludedStructure(obj : TTurtleComplex) : TFhirBodyStructureExcludedStructure; overload; 
    procedure ParseBodyStructureExcludedStructureProperties(obj : TTurtleComplex; value : TFhirBodyStructureExcludedStructure); overload; 
    function ParseBodyStructure(obj : TTurtleComplex) : TFhirBodyStructure; overload; 
    procedure ParseBodyStructureProperties(obj : TTurtleComplex; value : TFhirBodyStructure); overload; 
{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_BUNDLE}
    function ParseBundleLink(obj : TTurtleComplex) : TFhirBundleLink; overload; 
    procedure ParseBundleLinkProperties(obj : TTurtleComplex; value : TFhirBundleLink); overload; 
    function ParseBundleEntry(obj : TTurtleComplex) : TFhirBundleEntry; overload; 
    procedure ParseBundleEntryProperties(obj : TTurtleComplex; value : TFhirBundleEntry); overload; 
    function ParseBundleEntrySearch(obj : TTurtleComplex) : TFhirBundleEntrySearch; overload; 
    procedure ParseBundleEntrySearchProperties(obj : TTurtleComplex; value : TFhirBundleEntrySearch); overload; 
    function ParseBundleEntryRequest(obj : TTurtleComplex) : TFhirBundleEntryRequest; overload; 
    procedure ParseBundleEntryRequestProperties(obj : TTurtleComplex; value : TFhirBundleEntryRequest); overload; 
    function ParseBundleEntryResponse(obj : TTurtleComplex) : TFhirBundleEntryResponse; overload; 
    procedure ParseBundleEntryResponseProperties(obj : TTurtleComplex; value : TFhirBundleEntryResponse); overload; 
    function ParseBundle(obj : TTurtleComplex) : TFhirBundle; overload; 
    procedure ParseBundleProperties(obj : TTurtleComplex; value : TFhirBundle); overload; 
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
    function ParseCapabilityStatementSoftware(obj : TTurtleComplex) : TFhirCapabilityStatementSoftware; overload; 
    procedure ParseCapabilityStatementSoftwareProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementSoftware); overload; 
    function ParseCapabilityStatementImplementation(obj : TTurtleComplex) : TFhirCapabilityStatementImplementation; overload; 
    procedure ParseCapabilityStatementImplementationProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementImplementation); overload; 
    function ParseCapabilityStatementRest(obj : TTurtleComplex) : TFhirCapabilityStatementRest; overload; 
    procedure ParseCapabilityStatementRestProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementRest); overload; 
    function ParseCapabilityStatementRestSecurity(obj : TTurtleComplex) : TFhirCapabilityStatementRestSecurity; overload; 
    procedure ParseCapabilityStatementRestSecurityProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementRestSecurity); overload; 
    function ParseCapabilityStatementRestResource(obj : TTurtleComplex) : TFhirCapabilityStatementRestResource; overload; 
    procedure ParseCapabilityStatementRestResourceProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementRestResource); overload; 
    function ParseCapabilityStatementRestResourceInteraction(obj : TTurtleComplex) : TFhirCapabilityStatementRestResourceInteraction; overload; 
    procedure ParseCapabilityStatementRestResourceInteractionProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementRestResourceInteraction); overload; 
    function ParseCapabilityStatementRestResourceSearchParam(obj : TTurtleComplex) : TFhirCapabilityStatementRestResourceSearchParam; overload; 
    procedure ParseCapabilityStatementRestResourceSearchParamProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementRestResourceSearchParam); overload; 
    function ParseCapabilityStatementRestResourceOperation(obj : TTurtleComplex) : TFhirCapabilityStatementRestResourceOperation; overload; 
    procedure ParseCapabilityStatementRestResourceOperationProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementRestResourceOperation); overload; 
    function ParseCapabilityStatementRestInteraction(obj : TTurtleComplex) : TFhirCapabilityStatementRestInteraction; overload; 
    procedure ParseCapabilityStatementRestInteractionProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementRestInteraction); overload; 
    function ParseCapabilityStatementMessaging(obj : TTurtleComplex) : TFhirCapabilityStatementMessaging; overload; 
    procedure ParseCapabilityStatementMessagingProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementMessaging); overload; 
    function ParseCapabilityStatementMessagingEndpoint(obj : TTurtleComplex) : TFhirCapabilityStatementMessagingEndpoint; overload; 
    procedure ParseCapabilityStatementMessagingEndpointProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementMessagingEndpoint); overload; 
    function ParseCapabilityStatementMessagingSupportedMessage(obj : TTurtleComplex) : TFhirCapabilityStatementMessagingSupportedMessage; overload; 
    procedure ParseCapabilityStatementMessagingSupportedMessageProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementMessagingSupportedMessage); overload; 
    function ParseCapabilityStatementDocument(obj : TTurtleComplex) : TFhirCapabilityStatementDocument; overload; 
    procedure ParseCapabilityStatementDocumentProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementDocument); overload; 
    function ParseCapabilityStatement(obj : TTurtleComplex) : TFhirCapabilityStatement; overload; 
    procedure ParseCapabilityStatementProperties(obj : TTurtleComplex; value : TFhirCapabilityStatement); overload; 
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
    function ParseCarePlanActivity(obj : TTurtleComplex) : TFhirCarePlanActivity; overload; 
    procedure ParseCarePlanActivityProperties(obj : TTurtleComplex; value : TFhirCarePlanActivity); overload; 
    function ParseCarePlanActivityPlannedActivityDetail(obj : TTurtleComplex) : TFhirCarePlanActivityPlannedActivityDetail; overload; 
    procedure ParseCarePlanActivityPlannedActivityDetailProperties(obj : TTurtleComplex; value : TFhirCarePlanActivityPlannedActivityDetail); overload; 
    function ParseCarePlan(obj : TTurtleComplex) : TFhirCarePlan; overload; 
    procedure ParseCarePlanProperties(obj : TTurtleComplex; value : TFhirCarePlan); overload; 
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
    function ParseCareTeamParticipant(obj : TTurtleComplex) : TFhirCareTeamParticipant; overload; 
    procedure ParseCareTeamParticipantProperties(obj : TTurtleComplex; value : TFhirCareTeamParticipant); overload; 
    function ParseCareTeam(obj : TTurtleComplex) : TFhirCareTeam; overload; 
    procedure ParseCareTeamProperties(obj : TTurtleComplex; value : TFhirCareTeam); overload; 
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CHARGEITEM}
    function ParseChargeItemPerformer(obj : TTurtleComplex) : TFhirChargeItemPerformer; overload; 
    procedure ParseChargeItemPerformerProperties(obj : TTurtleComplex; value : TFhirChargeItemPerformer); overload; 
    function ParseChargeItem(obj : TTurtleComplex) : TFhirChargeItem; overload; 
    procedure ParseChargeItemProperties(obj : TTurtleComplex; value : TFhirChargeItem); overload; 
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
    function ParseChargeItemDefinitionApplicability(obj : TTurtleComplex) : TFhirChargeItemDefinitionApplicability; overload; 
    procedure ParseChargeItemDefinitionApplicabilityProperties(obj : TTurtleComplex; value : TFhirChargeItemDefinitionApplicability); overload; 
    function ParseChargeItemDefinitionPropertyGroup(obj : TTurtleComplex) : TFhirChargeItemDefinitionPropertyGroup; overload; 
    procedure ParseChargeItemDefinitionPropertyGroupProperties(obj : TTurtleComplex; value : TFhirChargeItemDefinitionPropertyGroup); overload; 
    function ParseChargeItemDefinition(obj : TTurtleComplex) : TFhirChargeItemDefinition; overload; 
    procedure ParseChargeItemDefinitionProperties(obj : TTurtleComplex; value : TFhirChargeItemDefinition); overload; 
{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CITATION}
    function ParseCitationSummary(obj : TTurtleComplex) : TFhirCitationSummary; overload; 
    procedure ParseCitationSummaryProperties(obj : TTurtleComplex; value : TFhirCitationSummary); overload; 
    function ParseCitationClassification(obj : TTurtleComplex) : TFhirCitationClassification; overload; 
    procedure ParseCitationClassificationProperties(obj : TTurtleComplex; value : TFhirCitationClassification); overload; 
    function ParseCitationStatusDate(obj : TTurtleComplex) : TFhirCitationStatusDate; overload; 
    procedure ParseCitationStatusDateProperties(obj : TTurtleComplex; value : TFhirCitationStatusDate); overload; 
    function ParseCitationCitedArtifact(obj : TTurtleComplex) : TFhirCitationCitedArtifact; overload; 
    procedure ParseCitationCitedArtifactProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifact); overload; 
    function ParseCitationCitedArtifactVersion(obj : TTurtleComplex) : TFhirCitationCitedArtifactVersion; overload; 
    procedure ParseCitationCitedArtifactVersionProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactVersion); overload; 
    function ParseCitationCitedArtifactStatusDate(obj : TTurtleComplex) : TFhirCitationCitedArtifactStatusDate; overload; 
    procedure ParseCitationCitedArtifactStatusDateProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactStatusDate); overload; 
    function ParseCitationCitedArtifactTitle(obj : TTurtleComplex) : TFhirCitationCitedArtifactTitle; overload; 
    procedure ParseCitationCitedArtifactTitleProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactTitle); overload; 
    function ParseCitationCitedArtifactAbstract(obj : TTurtleComplex) : TFhirCitationCitedArtifactAbstract; overload; 
    procedure ParseCitationCitedArtifactAbstractProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactAbstract); overload; 
    function ParseCitationCitedArtifactPart(obj : TTurtleComplex) : TFhirCitationCitedArtifactPart; overload; 
    procedure ParseCitationCitedArtifactPartProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactPart); overload; 
    function ParseCitationCitedArtifactRelatesTo(obj : TTurtleComplex) : TFhirCitationCitedArtifactRelatesTo; overload; 
    procedure ParseCitationCitedArtifactRelatesToProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactRelatesTo); overload; 
    function ParseCitationCitedArtifactPublicationForm(obj : TTurtleComplex) : TFhirCitationCitedArtifactPublicationForm; overload; 
    procedure ParseCitationCitedArtifactPublicationFormProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactPublicationForm); overload; 
    function ParseCitationCitedArtifactPublicationFormPublishedIn(obj : TTurtleComplex) : TFhirCitationCitedArtifactPublicationFormPublishedIn; overload; 
    procedure ParseCitationCitedArtifactPublicationFormPublishedInProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactPublicationFormPublishedIn); overload; 
    function ParseCitationCitedArtifactWebLocation(obj : TTurtleComplex) : TFhirCitationCitedArtifactWebLocation; overload; 
    procedure ParseCitationCitedArtifactWebLocationProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactWebLocation); overload; 
    function ParseCitationCitedArtifactClassification(obj : TTurtleComplex) : TFhirCitationCitedArtifactClassification; overload; 
    procedure ParseCitationCitedArtifactClassificationProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactClassification); overload; 
    function ParseCitationCitedArtifactContributorship(obj : TTurtleComplex) : TFhirCitationCitedArtifactContributorship; overload; 
    procedure ParseCitationCitedArtifactContributorshipProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactContributorship); overload; 
    function ParseCitationCitedArtifactContributorshipEntry(obj : TTurtleComplex) : TFhirCitationCitedArtifactContributorshipEntry; overload; 
    procedure ParseCitationCitedArtifactContributorshipEntryProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactContributorshipEntry); overload; 
    function ParseCitationCitedArtifactContributorshipEntryContributionInstance(obj : TTurtleComplex) : TFhirCitationCitedArtifactContributorshipEntryContributionInstance; overload; 
    procedure ParseCitationCitedArtifactContributorshipEntryContributionInstanceProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactContributorshipEntryContributionInstance); overload; 
    function ParseCitationCitedArtifactContributorshipSummary(obj : TTurtleComplex) : TFhirCitationCitedArtifactContributorshipSummary; overload; 
    procedure ParseCitationCitedArtifactContributorshipSummaryProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactContributorshipSummary); overload; 
    function ParseCitation(obj : TTurtleComplex) : TFhirCitation; overload; 
    procedure ParseCitationProperties(obj : TTurtleComplex; value : TFhirCitation); overload; 
{$ENDIF FHIR_CITATION}
{$IFDEF FHIR_CLAIM}
    function ParseClaimRelated(obj : TTurtleComplex) : TFhirClaimRelated; overload; 
    procedure ParseClaimRelatedProperties(obj : TTurtleComplex; value : TFhirClaimRelated); overload; 
    function ParseClaimPayee(obj : TTurtleComplex) : TFhirClaimPayee; overload; 
    procedure ParseClaimPayeeProperties(obj : TTurtleComplex; value : TFhirClaimPayee); overload; 
    function ParseClaimCareTeam(obj : TTurtleComplex) : TFhirClaimCareTeam; overload; 
    procedure ParseClaimCareTeamProperties(obj : TTurtleComplex; value : TFhirClaimCareTeam); overload; 
    function ParseClaimSupportingInfo(obj : TTurtleComplex) : TFhirClaimSupportingInfo; overload; 
    procedure ParseClaimSupportingInfoProperties(obj : TTurtleComplex; value : TFhirClaimSupportingInfo); overload; 
    function ParseClaimDiagnosis(obj : TTurtleComplex) : TFhirClaimDiagnosis; overload; 
    procedure ParseClaimDiagnosisProperties(obj : TTurtleComplex; value : TFhirClaimDiagnosis); overload; 
    function ParseClaimProcedure(obj : TTurtleComplex) : TFhirClaimProcedure; overload; 
    procedure ParseClaimProcedureProperties(obj : TTurtleComplex; value : TFhirClaimProcedure); overload; 
    function ParseClaimInsurance(obj : TTurtleComplex) : TFhirClaimInsurance; overload; 
    procedure ParseClaimInsuranceProperties(obj : TTurtleComplex; value : TFhirClaimInsurance); overload; 
    function ParseClaimAccident(obj : TTurtleComplex) : TFhirClaimAccident; overload; 
    procedure ParseClaimAccidentProperties(obj : TTurtleComplex; value : TFhirClaimAccident); overload; 
    function ParseClaimItem(obj : TTurtleComplex) : TFhirClaimItem; overload; 
    procedure ParseClaimItemProperties(obj : TTurtleComplex; value : TFhirClaimItem); overload; 
    function ParseClaimItemBodySite(obj : TTurtleComplex) : TFhirClaimItemBodySite; overload; 
    procedure ParseClaimItemBodySiteProperties(obj : TTurtleComplex; value : TFhirClaimItemBodySite); overload; 
    function ParseClaimItemDetail(obj : TTurtleComplex) : TFhirClaimItemDetail; overload; 
    procedure ParseClaimItemDetailProperties(obj : TTurtleComplex; value : TFhirClaimItemDetail); overload; 
    function ParseClaimItemDetailSubDetail(obj : TTurtleComplex) : TFhirClaimItemDetailSubDetail; overload; 
    procedure ParseClaimItemDetailSubDetailProperties(obj : TTurtleComplex; value : TFhirClaimItemDetailSubDetail); overload; 
    function ParseClaim(obj : TTurtleComplex) : TFhirClaim; overload; 
    procedure ParseClaimProperties(obj : TTurtleComplex; value : TFhirClaim); overload; 
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
    function ParseClaimResponseItem(obj : TTurtleComplex) : TFhirClaimResponseItem; overload; 
    procedure ParseClaimResponseItemProperties(obj : TTurtleComplex; value : TFhirClaimResponseItem); overload; 
    function ParseClaimResponseItemAdjudication(obj : TTurtleComplex) : TFhirClaimResponseItemAdjudication; overload; 
    procedure ParseClaimResponseItemAdjudicationProperties(obj : TTurtleComplex; value : TFhirClaimResponseItemAdjudication); overload; 
    function ParseClaimResponseItemDetail(obj : TTurtleComplex) : TFhirClaimResponseItemDetail; overload; 
    procedure ParseClaimResponseItemDetailProperties(obj : TTurtleComplex; value : TFhirClaimResponseItemDetail); overload; 
    function ParseClaimResponseItemDetailSubDetail(obj : TTurtleComplex) : TFhirClaimResponseItemDetailSubDetail; overload; 
    procedure ParseClaimResponseItemDetailSubDetailProperties(obj : TTurtleComplex; value : TFhirClaimResponseItemDetailSubDetail); overload; 
    function ParseClaimResponseAddItem(obj : TTurtleComplex) : TFhirClaimResponseAddItem; overload; 
    procedure ParseClaimResponseAddItemProperties(obj : TTurtleComplex; value : TFhirClaimResponseAddItem); overload; 
    function ParseClaimResponseAddItemBodySite(obj : TTurtleComplex) : TFhirClaimResponseAddItemBodySite; overload; 
    procedure ParseClaimResponseAddItemBodySiteProperties(obj : TTurtleComplex; value : TFhirClaimResponseAddItemBodySite); overload; 
    function ParseClaimResponseAddItemDetail(obj : TTurtleComplex) : TFhirClaimResponseAddItemDetail; overload; 
    procedure ParseClaimResponseAddItemDetailProperties(obj : TTurtleComplex; value : TFhirClaimResponseAddItemDetail); overload; 
    function ParseClaimResponseAddItemDetailSubDetail(obj : TTurtleComplex) : TFhirClaimResponseAddItemDetailSubDetail; overload; 
    procedure ParseClaimResponseAddItemDetailSubDetailProperties(obj : TTurtleComplex; value : TFhirClaimResponseAddItemDetailSubDetail); overload; 
    function ParseClaimResponseTotal(obj : TTurtleComplex) : TFhirClaimResponseTotal; overload; 
    procedure ParseClaimResponseTotalProperties(obj : TTurtleComplex; value : TFhirClaimResponseTotal); overload; 
    function ParseClaimResponsePayment(obj : TTurtleComplex) : TFhirClaimResponsePayment; overload; 
    procedure ParseClaimResponsePaymentProperties(obj : TTurtleComplex; value : TFhirClaimResponsePayment); overload; 
    function ParseClaimResponseProcessNote(obj : TTurtleComplex) : TFhirClaimResponseProcessNote; overload; 
    procedure ParseClaimResponseProcessNoteProperties(obj : TTurtleComplex; value : TFhirClaimResponseProcessNote); overload; 
    function ParseClaimResponseInsurance(obj : TTurtleComplex) : TFhirClaimResponseInsurance; overload; 
    procedure ParseClaimResponseInsuranceProperties(obj : TTurtleComplex; value : TFhirClaimResponseInsurance); overload; 
    function ParseClaimResponseError(obj : TTurtleComplex) : TFhirClaimResponseError; overload; 
    procedure ParseClaimResponseErrorProperties(obj : TTurtleComplex; value : TFhirClaimResponseError); overload; 
    function ParseClaimResponse(obj : TTurtleComplex) : TFhirClaimResponse; overload; 
    procedure ParseClaimResponseProperties(obj : TTurtleComplex; value : TFhirClaimResponse); overload; 
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
    function ParseClinicalImpressionFinding(obj : TTurtleComplex) : TFhirClinicalImpressionFinding; overload; 
    procedure ParseClinicalImpressionFindingProperties(obj : TTurtleComplex; value : TFhirClinicalImpressionFinding); overload; 
    function ParseClinicalImpression(obj : TTurtleComplex) : TFhirClinicalImpression; overload; 
    procedure ParseClinicalImpressionProperties(obj : TTurtleComplex; value : TFhirClinicalImpression); overload; 
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CLINICALUSEDEFINITION}
    function ParseClinicalUseDefinitionContraindication(obj : TTurtleComplex) : TFhirClinicalUseDefinitionContraindication; overload; 
    procedure ParseClinicalUseDefinitionContraindicationProperties(obj : TTurtleComplex; value : TFhirClinicalUseDefinitionContraindication); overload; 
    function ParseClinicalUseDefinitionContraindicationOtherTherapy(obj : TTurtleComplex) : TFhirClinicalUseDefinitionContraindicationOtherTherapy; overload; 
    procedure ParseClinicalUseDefinitionContraindicationOtherTherapyProperties(obj : TTurtleComplex; value : TFhirClinicalUseDefinitionContraindicationOtherTherapy); overload; 
    function ParseClinicalUseDefinitionIndication(obj : TTurtleComplex) : TFhirClinicalUseDefinitionIndication; overload; 
    procedure ParseClinicalUseDefinitionIndicationProperties(obj : TTurtleComplex; value : TFhirClinicalUseDefinitionIndication); overload; 
    function ParseClinicalUseDefinitionInteraction(obj : TTurtleComplex) : TFhirClinicalUseDefinitionInteraction; overload; 
    procedure ParseClinicalUseDefinitionInteractionProperties(obj : TTurtleComplex; value : TFhirClinicalUseDefinitionInteraction); overload; 
    function ParseClinicalUseDefinitionInteractionInteractant(obj : TTurtleComplex) : TFhirClinicalUseDefinitionInteractionInteractant; overload; 
    procedure ParseClinicalUseDefinitionInteractionInteractantProperties(obj : TTurtleComplex; value : TFhirClinicalUseDefinitionInteractionInteractant); overload; 
    function ParseClinicalUseDefinitionUndesirableEffect(obj : TTurtleComplex) : TFhirClinicalUseDefinitionUndesirableEffect; overload; 
    procedure ParseClinicalUseDefinitionUndesirableEffectProperties(obj : TTurtleComplex; value : TFhirClinicalUseDefinitionUndesirableEffect); overload; 
    function ParseClinicalUseDefinitionWarning(obj : TTurtleComplex) : TFhirClinicalUseDefinitionWarning; overload; 
    procedure ParseClinicalUseDefinitionWarningProperties(obj : TTurtleComplex; value : TFhirClinicalUseDefinitionWarning); overload; 
    function ParseClinicalUseDefinition(obj : TTurtleComplex) : TFhirClinicalUseDefinition; overload; 
    procedure ParseClinicalUseDefinitionProperties(obj : TTurtleComplex; value : TFhirClinicalUseDefinition); overload; 
{$ENDIF FHIR_CLINICALUSEDEFINITION}
{$IFDEF FHIR_CODESYSTEM}
    function ParseCodeSystemFilter(obj : TTurtleComplex) : TFhirCodeSystemFilter; overload; 
    procedure ParseCodeSystemFilterProperties(obj : TTurtleComplex; value : TFhirCodeSystemFilter); overload; 
    function ParseCodeSystemProperty(obj : TTurtleComplex) : TFhirCodeSystemProperty; overload; 
    procedure ParseCodeSystemPropertyProperties(obj : TTurtleComplex; value : TFhirCodeSystemProperty); overload; 
    function ParseCodeSystemConcept(obj : TTurtleComplex) : TFhirCodeSystemConcept; overload; 
    procedure ParseCodeSystemConceptProperties(obj : TTurtleComplex; value : TFhirCodeSystemConcept); overload; 
    function ParseCodeSystemConceptDesignation(obj : TTurtleComplex) : TFhirCodeSystemConceptDesignation; overload; 
    procedure ParseCodeSystemConceptDesignationProperties(obj : TTurtleComplex; value : TFhirCodeSystemConceptDesignation); overload; 
    function ParseCodeSystemConceptProperty(obj : TTurtleComplex) : TFhirCodeSystemConceptProperty; overload; 
    procedure ParseCodeSystemConceptPropertyProperties(obj : TTurtleComplex; value : TFhirCodeSystemConceptProperty); overload; 
    function ParseCodeSystem(obj : TTurtleComplex) : TFhirCodeSystem; overload; 
    procedure ParseCodeSystemProperties(obj : TTurtleComplex; value : TFhirCodeSystem); overload; 
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
    function ParseCommunicationPayload(obj : TTurtleComplex) : TFhirCommunicationPayload; overload; 
    procedure ParseCommunicationPayloadProperties(obj : TTurtleComplex; value : TFhirCommunicationPayload); overload; 
    function ParseCommunication(obj : TTurtleComplex) : TFhirCommunication; overload; 
    procedure ParseCommunicationProperties(obj : TTurtleComplex; value : TFhirCommunication); overload; 
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
    function ParseCommunicationRequestPayload(obj : TTurtleComplex) : TFhirCommunicationRequestPayload; overload; 
    procedure ParseCommunicationRequestPayloadProperties(obj : TTurtleComplex; value : TFhirCommunicationRequestPayload); overload; 
    function ParseCommunicationRequest(obj : TTurtleComplex) : TFhirCommunicationRequest; overload; 
    procedure ParseCommunicationRequestProperties(obj : TTurtleComplex; value : TFhirCommunicationRequest); overload; 
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
    function ParseCompartmentDefinitionResource(obj : TTurtleComplex) : TFhirCompartmentDefinitionResource; overload; 
    procedure ParseCompartmentDefinitionResourceProperties(obj : TTurtleComplex; value : TFhirCompartmentDefinitionResource); overload; 
    function ParseCompartmentDefinition(obj : TTurtleComplex) : TFhirCompartmentDefinition; overload; 
    procedure ParseCompartmentDefinitionProperties(obj : TTurtleComplex; value : TFhirCompartmentDefinition); overload; 
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
    function ParseCompositionAttester(obj : TTurtleComplex) : TFhirCompositionAttester; overload; 
    procedure ParseCompositionAttesterProperties(obj : TTurtleComplex; value : TFhirCompositionAttester); overload; 
    function ParseCompositionEvent(obj : TTurtleComplex) : TFhirCompositionEvent; overload; 
    procedure ParseCompositionEventProperties(obj : TTurtleComplex; value : TFhirCompositionEvent); overload; 
    function ParseCompositionSection(obj : TTurtleComplex) : TFhirCompositionSection; overload; 
    procedure ParseCompositionSectionProperties(obj : TTurtleComplex; value : TFhirCompositionSection); overload; 
    function ParseComposition(obj : TTurtleComplex) : TFhirComposition; overload; 
    procedure ParseCompositionProperties(obj : TTurtleComplex; value : TFhirComposition); overload; 
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
    function ParseConceptMapGroup(obj : TTurtleComplex) : TFhirConceptMapGroup; overload; 
    procedure ParseConceptMapGroupProperties(obj : TTurtleComplex; value : TFhirConceptMapGroup); overload; 
    function ParseConceptMapGroupElement(obj : TTurtleComplex) : TFhirConceptMapGroupElement; overload; 
    procedure ParseConceptMapGroupElementProperties(obj : TTurtleComplex; value : TFhirConceptMapGroupElement); overload; 
    function ParseConceptMapGroupElementTarget(obj : TTurtleComplex) : TFhirConceptMapGroupElementTarget; overload; 
    procedure ParseConceptMapGroupElementTargetProperties(obj : TTurtleComplex; value : TFhirConceptMapGroupElementTarget); overload; 
    function ParseConceptMapGroupElementTargetDependsOn(obj : TTurtleComplex) : TFhirConceptMapGroupElementTargetDependsOn; overload; 
    procedure ParseConceptMapGroupElementTargetDependsOnProperties(obj : TTurtleComplex; value : TFhirConceptMapGroupElementTargetDependsOn); overload; 
    function ParseConceptMapGroupUnmapped(obj : TTurtleComplex) : TFhirConceptMapGroupUnmapped; overload; 
    procedure ParseConceptMapGroupUnmappedProperties(obj : TTurtleComplex; value : TFhirConceptMapGroupUnmapped); overload; 
    function ParseConceptMap(obj : TTurtleComplex) : TFhirConceptMap; overload; 
    procedure ParseConceptMapProperties(obj : TTurtleComplex; value : TFhirConceptMap); overload; 
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
    function ParseConditionParticipant(obj : TTurtleComplex) : TFhirConditionParticipant; overload; 
    procedure ParseConditionParticipantProperties(obj : TTurtleComplex; value : TFhirConditionParticipant); overload; 
    function ParseConditionStage(obj : TTurtleComplex) : TFhirConditionStage; overload; 
    procedure ParseConditionStageProperties(obj : TTurtleComplex; value : TFhirConditionStage); overload; 
    function ParseCondition(obj : TTurtleComplex) : TFhirCondition; overload; 
    procedure ParseConditionProperties(obj : TTurtleComplex; value : TFhirCondition); overload; 
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONDITIONDEFINITION}
    function ParseConditionDefinitionObservation(obj : TTurtleComplex) : TFhirConditionDefinitionObservation; overload; 
    procedure ParseConditionDefinitionObservationProperties(obj : TTurtleComplex; value : TFhirConditionDefinitionObservation); overload; 
    function ParseConditionDefinitionMedication(obj : TTurtleComplex) : TFhirConditionDefinitionMedication; overload; 
    procedure ParseConditionDefinitionMedicationProperties(obj : TTurtleComplex; value : TFhirConditionDefinitionMedication); overload; 
    function ParseConditionDefinitionPrecondition(obj : TTurtleComplex) : TFhirConditionDefinitionPrecondition; overload; 
    procedure ParseConditionDefinitionPreconditionProperties(obj : TTurtleComplex; value : TFhirConditionDefinitionPrecondition); overload; 
    function ParseConditionDefinitionQuestionnaire(obj : TTurtleComplex) : TFhirConditionDefinitionQuestionnaire; overload; 
    procedure ParseConditionDefinitionQuestionnaireProperties(obj : TTurtleComplex; value : TFhirConditionDefinitionQuestionnaire); overload; 
    function ParseConditionDefinitionPlan(obj : TTurtleComplex) : TFhirConditionDefinitionPlan; overload; 
    procedure ParseConditionDefinitionPlanProperties(obj : TTurtleComplex; value : TFhirConditionDefinitionPlan); overload; 
    function ParseConditionDefinition(obj : TTurtleComplex) : TFhirConditionDefinition; overload; 
    procedure ParseConditionDefinitionProperties(obj : TTurtleComplex; value : TFhirConditionDefinition); overload; 
{$ENDIF FHIR_CONDITIONDEFINITION}
{$IFDEF FHIR_CONSENT}
    function ParseConsentPolicyBasis(obj : TTurtleComplex) : TFhirConsentPolicyBasis; overload; 
    procedure ParseConsentPolicyBasisProperties(obj : TTurtleComplex; value : TFhirConsentPolicyBasis); overload; 
    function ParseConsentVerification(obj : TTurtleComplex) : TFhirConsentVerification; overload; 
    procedure ParseConsentVerificationProperties(obj : TTurtleComplex; value : TFhirConsentVerification); overload; 
    function ParseConsentProvision(obj : TTurtleComplex) : TFhirConsentProvision; overload; 
    procedure ParseConsentProvisionProperties(obj : TTurtleComplex; value : TFhirConsentProvision); overload; 
    function ParseConsentProvisionActor(obj : TTurtleComplex) : TFhirConsentProvisionActor; overload; 
    procedure ParseConsentProvisionActorProperties(obj : TTurtleComplex; value : TFhirConsentProvisionActor); overload; 
    function ParseConsentProvisionData(obj : TTurtleComplex) : TFhirConsentProvisionData; overload; 
    procedure ParseConsentProvisionDataProperties(obj : TTurtleComplex; value : TFhirConsentProvisionData); overload; 
    function ParseConsent(obj : TTurtleComplex) : TFhirConsent; overload; 
    procedure ParseConsentProperties(obj : TTurtleComplex; value : TFhirConsent); overload; 
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
    function ParseContractContentDefinition(obj : TTurtleComplex) : TFhirContractContentDefinition; overload; 
    procedure ParseContractContentDefinitionProperties(obj : TTurtleComplex; value : TFhirContractContentDefinition); overload; 
    function ParseContractTerm(obj : TTurtleComplex) : TFhirContractTerm; overload; 
    procedure ParseContractTermProperties(obj : TTurtleComplex; value : TFhirContractTerm); overload; 
    function ParseContractTermSecurityLabel(obj : TTurtleComplex) : TFhirContractTermSecurityLabel; overload; 
    procedure ParseContractTermSecurityLabelProperties(obj : TTurtleComplex; value : TFhirContractTermSecurityLabel); overload; 
    function ParseContractTermOffer(obj : TTurtleComplex) : TFhirContractTermOffer; overload; 
    procedure ParseContractTermOfferProperties(obj : TTurtleComplex; value : TFhirContractTermOffer); overload; 
    function ParseContractTermOfferParty(obj : TTurtleComplex) : TFhirContractTermOfferParty; overload; 
    procedure ParseContractTermOfferPartyProperties(obj : TTurtleComplex; value : TFhirContractTermOfferParty); overload; 
    function ParseContractTermOfferAnswer(obj : TTurtleComplex) : TFhirContractTermOfferAnswer; overload; 
    procedure ParseContractTermOfferAnswerProperties(obj : TTurtleComplex; value : TFhirContractTermOfferAnswer); overload; 
    function ParseContractTermAsset(obj : TTurtleComplex) : TFhirContractTermAsset; overload; 
    procedure ParseContractTermAssetProperties(obj : TTurtleComplex; value : TFhirContractTermAsset); overload; 
    function ParseContractTermAssetContext(obj : TTurtleComplex) : TFhirContractTermAssetContext; overload; 
    procedure ParseContractTermAssetContextProperties(obj : TTurtleComplex; value : TFhirContractTermAssetContext); overload; 
    function ParseContractTermAssetValuedItem(obj : TTurtleComplex) : TFhirContractTermAssetValuedItem; overload; 
    procedure ParseContractTermAssetValuedItemProperties(obj : TTurtleComplex; value : TFhirContractTermAssetValuedItem); overload; 
    function ParseContractTermAction(obj : TTurtleComplex) : TFhirContractTermAction; overload; 
    procedure ParseContractTermActionProperties(obj : TTurtleComplex; value : TFhirContractTermAction); overload; 
    function ParseContractTermActionSubject(obj : TTurtleComplex) : TFhirContractTermActionSubject; overload; 
    procedure ParseContractTermActionSubjectProperties(obj : TTurtleComplex; value : TFhirContractTermActionSubject); overload; 
    function ParseContractSigner(obj : TTurtleComplex) : TFhirContractSigner; overload; 
    procedure ParseContractSignerProperties(obj : TTurtleComplex; value : TFhirContractSigner); overload; 
    function ParseContractFriendly(obj : TTurtleComplex) : TFhirContractFriendly; overload; 
    procedure ParseContractFriendlyProperties(obj : TTurtleComplex; value : TFhirContractFriendly); overload; 
    function ParseContractLegal(obj : TTurtleComplex) : TFhirContractLegal; overload; 
    procedure ParseContractLegalProperties(obj : TTurtleComplex; value : TFhirContractLegal); overload; 
    function ParseContractRule(obj : TTurtleComplex) : TFhirContractRule; overload; 
    procedure ParseContractRuleProperties(obj : TTurtleComplex; value : TFhirContractRule); overload; 
    function ParseContract(obj : TTurtleComplex) : TFhirContract; overload; 
    procedure ParseContractProperties(obj : TTurtleComplex; value : TFhirContract); overload; 
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
    function ParseCoveragePaymentBy(obj : TTurtleComplex) : TFhirCoveragePaymentBy; overload; 
    procedure ParseCoveragePaymentByProperties(obj : TTurtleComplex; value : TFhirCoveragePaymentBy); overload; 
    function ParseCoverageClass(obj : TTurtleComplex) : TFhirCoverageClass; overload; 
    procedure ParseCoverageClassProperties(obj : TTurtleComplex; value : TFhirCoverageClass); overload; 
    function ParseCoverageCostToBeneficiary(obj : TTurtleComplex) : TFhirCoverageCostToBeneficiary; overload; 
    procedure ParseCoverageCostToBeneficiaryProperties(obj : TTurtleComplex; value : TFhirCoverageCostToBeneficiary); overload; 
    function ParseCoverageCostToBeneficiaryException(obj : TTurtleComplex) : TFhirCoverageCostToBeneficiaryException; overload; 
    procedure ParseCoverageCostToBeneficiaryExceptionProperties(obj : TTurtleComplex; value : TFhirCoverageCostToBeneficiaryException); overload; 
    function ParseCoverage(obj : TTurtleComplex) : TFhirCoverage; overload; 
    procedure ParseCoverageProperties(obj : TTurtleComplex; value : TFhirCoverage); overload; 
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
    function ParseCoverageEligibilityRequestSupportingInfo(obj : TTurtleComplex) : TFhirCoverageEligibilityRequestSupportingInfo; overload; 
    procedure ParseCoverageEligibilityRequestSupportingInfoProperties(obj : TTurtleComplex; value : TFhirCoverageEligibilityRequestSupportingInfo); overload; 
    function ParseCoverageEligibilityRequestInsurance(obj : TTurtleComplex) : TFhirCoverageEligibilityRequestInsurance; overload; 
    procedure ParseCoverageEligibilityRequestInsuranceProperties(obj : TTurtleComplex; value : TFhirCoverageEligibilityRequestInsurance); overload; 
    function ParseCoverageEligibilityRequestItem(obj : TTurtleComplex) : TFhirCoverageEligibilityRequestItem; overload; 
    procedure ParseCoverageEligibilityRequestItemProperties(obj : TTurtleComplex; value : TFhirCoverageEligibilityRequestItem); overload; 
    function ParseCoverageEligibilityRequestItemDiagnosis(obj : TTurtleComplex) : TFhirCoverageEligibilityRequestItemDiagnosis; overload; 
    procedure ParseCoverageEligibilityRequestItemDiagnosisProperties(obj : TTurtleComplex; value : TFhirCoverageEligibilityRequestItemDiagnosis); overload; 
    function ParseCoverageEligibilityRequest(obj : TTurtleComplex) : TFhirCoverageEligibilityRequest; overload; 
    procedure ParseCoverageEligibilityRequestProperties(obj : TTurtleComplex; value : TFhirCoverageEligibilityRequest); overload; 
{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
    function ParseCoverageEligibilityResponseInsurance(obj : TTurtleComplex) : TFhirCoverageEligibilityResponseInsurance; overload; 
    procedure ParseCoverageEligibilityResponseInsuranceProperties(obj : TTurtleComplex; value : TFhirCoverageEligibilityResponseInsurance); overload; 
    function ParseCoverageEligibilityResponseInsuranceItem(obj : TTurtleComplex) : TFhirCoverageEligibilityResponseInsuranceItem; overload; 
    procedure ParseCoverageEligibilityResponseInsuranceItemProperties(obj : TTurtleComplex; value : TFhirCoverageEligibilityResponseInsuranceItem); overload; 
    function ParseCoverageEligibilityResponseInsuranceItemBenefit(obj : TTurtleComplex) : TFhirCoverageEligibilityResponseInsuranceItemBenefit; overload; 
    procedure ParseCoverageEligibilityResponseInsuranceItemBenefitProperties(obj : TTurtleComplex; value : TFhirCoverageEligibilityResponseInsuranceItemBenefit); overload; 
    function ParseCoverageEligibilityResponseError(obj : TTurtleComplex) : TFhirCoverageEligibilityResponseError; overload; 
    procedure ParseCoverageEligibilityResponseErrorProperties(obj : TTurtleComplex; value : TFhirCoverageEligibilityResponseError); overload; 
    function ParseCoverageEligibilityResponse(obj : TTurtleComplex) : TFhirCoverageEligibilityResponse; overload; 
    procedure ParseCoverageEligibilityResponseProperties(obj : TTurtleComplex; value : TFhirCoverageEligibilityResponse); overload; 
{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_DETECTEDISSUE}
    function ParseDetectedIssueEvidence(obj : TTurtleComplex) : TFhirDetectedIssueEvidence; overload; 
    procedure ParseDetectedIssueEvidenceProperties(obj : TTurtleComplex; value : TFhirDetectedIssueEvidence); overload; 
    function ParseDetectedIssueMitigation(obj : TTurtleComplex) : TFhirDetectedIssueMitigation; overload; 
    procedure ParseDetectedIssueMitigationProperties(obj : TTurtleComplex; value : TFhirDetectedIssueMitigation); overload; 
    function ParseDetectedIssue(obj : TTurtleComplex) : TFhirDetectedIssue; overload; 
    procedure ParseDetectedIssueProperties(obj : TTurtleComplex; value : TFhirDetectedIssue); overload; 
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
    function ParseDeviceUdiCarrier(obj : TTurtleComplex) : TFhirDeviceUdiCarrier; overload; 
    procedure ParseDeviceUdiCarrierProperties(obj : TTurtleComplex; value : TFhirDeviceUdiCarrier); overload; 
    function ParseDeviceDeviceName(obj : TTurtleComplex) : TFhirDeviceDeviceName; overload; 
    procedure ParseDeviceDeviceNameProperties(obj : TTurtleComplex; value : TFhirDeviceDeviceName); overload; 
    function ParseDeviceVersion(obj : TTurtleComplex) : TFhirDeviceVersion; overload; 
    procedure ParseDeviceVersionProperties(obj : TTurtleComplex; value : TFhirDeviceVersion); overload; 
    function ParseDeviceSpecialization(obj : TTurtleComplex) : TFhirDeviceSpecialization; overload; 
    procedure ParseDeviceSpecializationProperties(obj : TTurtleComplex; value : TFhirDeviceSpecialization); overload; 
    function ParseDeviceProperty(obj : TTurtleComplex) : TFhirDeviceProperty; overload; 
    procedure ParseDevicePropertyProperties(obj : TTurtleComplex; value : TFhirDeviceProperty); overload; 
    function ParseDeviceOperation(obj : TTurtleComplex) : TFhirDeviceOperation; overload; 
    procedure ParseDeviceOperationProperties(obj : TTurtleComplex; value : TFhirDeviceOperation); overload; 
    function ParseDeviceAssociation(obj : TTurtleComplex) : TFhirDeviceAssociation; overload; 
    procedure ParseDeviceAssociationProperties(obj : TTurtleComplex; value : TFhirDeviceAssociation); overload; 
    function ParseDevice(obj : TTurtleComplex) : TFhirDevice; overload; 
    procedure ParseDeviceProperties(obj : TTurtleComplex; value : TFhirDevice); overload; 
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
    function ParseDeviceDefinitionUdiDeviceIdentifier(obj : TTurtleComplex) : TFhirDeviceDefinitionUdiDeviceIdentifier; overload; 
    procedure ParseDeviceDefinitionUdiDeviceIdentifierProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionUdiDeviceIdentifier); overload; 
    function ParseDeviceDefinitionUdiDeviceIdentifierMarketDistribution(obj : TTurtleComplex) : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution; overload; 
    procedure ParseDeviceDefinitionUdiDeviceIdentifierMarketDistributionProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution); overload; 
    function ParseDeviceDefinitionRegulatoryIdentifier(obj : TTurtleComplex) : TFhirDeviceDefinitionRegulatoryIdentifier; overload; 
    procedure ParseDeviceDefinitionRegulatoryIdentifierProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionRegulatoryIdentifier); overload; 
    function ParseDeviceDefinitionDeviceName(obj : TTurtleComplex) : TFhirDeviceDefinitionDeviceName; overload; 
    procedure ParseDeviceDefinitionDeviceNameProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionDeviceName); overload; 
    function ParseDeviceDefinitionClassification(obj : TTurtleComplex) : TFhirDeviceDefinitionClassification; overload; 
    procedure ParseDeviceDefinitionClassificationProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionClassification); overload; 
    function ParseDeviceDefinitionHasPart(obj : TTurtleComplex) : TFhirDeviceDefinitionHasPart; overload; 
    procedure ParseDeviceDefinitionHasPartProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionHasPart); overload; 
    function ParseDeviceDefinitionPackaging(obj : TTurtleComplex) : TFhirDeviceDefinitionPackaging; overload; 
    procedure ParseDeviceDefinitionPackagingProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionPackaging); overload; 
    function ParseDeviceDefinitionPackagingDistributor(obj : TTurtleComplex) : TFhirDeviceDefinitionPackagingDistributor; overload; 
    procedure ParseDeviceDefinitionPackagingDistributorProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionPackagingDistributor); overload; 
    function ParseDeviceDefinitionVersion(obj : TTurtleComplex) : TFhirDeviceDefinitionVersion; overload; 
    procedure ParseDeviceDefinitionVersionProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionVersion); overload; 
    function ParseDeviceDefinitionProperty(obj : TTurtleComplex) : TFhirDeviceDefinitionProperty; overload; 
    procedure ParseDeviceDefinitionPropertyProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionProperty); overload; 
    function ParseDeviceDefinitionLink(obj : TTurtleComplex) : TFhirDeviceDefinitionLink; overload; 
    procedure ParseDeviceDefinitionLinkProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionLink); overload; 
    function ParseDeviceDefinitionMaterial(obj : TTurtleComplex) : TFhirDeviceDefinitionMaterial; overload; 
    procedure ParseDeviceDefinitionMaterialProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionMaterial); overload; 
    function ParseDeviceDefinitionGuideline(obj : TTurtleComplex) : TFhirDeviceDefinitionGuideline; overload; 
    procedure ParseDeviceDefinitionGuidelineProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionGuideline); overload; 
    function ParseDeviceDefinitionCorrectiveAction(obj : TTurtleComplex) : TFhirDeviceDefinitionCorrectiveAction; overload; 
    procedure ParseDeviceDefinitionCorrectiveActionProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionCorrectiveAction); overload; 
    function ParseDeviceDefinitionChargeItem(obj : TTurtleComplex) : TFhirDeviceDefinitionChargeItem; overload; 
    procedure ParseDeviceDefinitionChargeItemProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionChargeItem); overload; 
    function ParseDeviceDefinition(obj : TTurtleComplex) : TFhirDeviceDefinition; overload; 
    procedure ParseDeviceDefinitionProperties(obj : TTurtleComplex; value : TFhirDeviceDefinition); overload; 
{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEDISPENSE}
    function ParseDeviceDispensePerformer(obj : TTurtleComplex) : TFhirDeviceDispensePerformer; overload; 
    procedure ParseDeviceDispensePerformerProperties(obj : TTurtleComplex; value : TFhirDeviceDispensePerformer); overload; 
    function ParseDeviceDispense(obj : TTurtleComplex) : TFhirDeviceDispense; overload; 
    procedure ParseDeviceDispenseProperties(obj : TTurtleComplex; value : TFhirDeviceDispense); overload; 
{$ENDIF FHIR_DEVICEDISPENSE}
{$IFDEF FHIR_DEVICEMETRIC}
    function ParseDeviceMetricCalibration(obj : TTurtleComplex) : TFhirDeviceMetricCalibration; overload; 
    procedure ParseDeviceMetricCalibrationProperties(obj : TTurtleComplex; value : TFhirDeviceMetricCalibration); overload; 
    function ParseDeviceMetric(obj : TTurtleComplex) : TFhirDeviceMetric; overload; 
    procedure ParseDeviceMetricProperties(obj : TTurtleComplex; value : TFhirDeviceMetric); overload; 
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
    function ParseDeviceRequestParameter(obj : TTurtleComplex) : TFhirDeviceRequestParameter; overload; 
    procedure ParseDeviceRequestParameterProperties(obj : TTurtleComplex; value : TFhirDeviceRequestParameter); overload; 
    function ParseDeviceRequest(obj : TTurtleComplex) : TFhirDeviceRequest; overload; 
    procedure ParseDeviceRequestProperties(obj : TTurtleComplex; value : TFhirDeviceRequest); overload; 
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSAGE}
    function ParseDeviceUsageAdherence(obj : TTurtleComplex) : TFhirDeviceUsageAdherence; overload; 
    procedure ParseDeviceUsageAdherenceProperties(obj : TTurtleComplex; value : TFhirDeviceUsageAdherence); overload; 
    function ParseDeviceUsage(obj : TTurtleComplex) : TFhirDeviceUsage; overload; 
    procedure ParseDeviceUsageProperties(obj : TTurtleComplex; value : TFhirDeviceUsage); overload; 
{$ENDIF FHIR_DEVICEUSAGE}
{$IFDEF FHIR_DIAGNOSTICREPORT}
    function ParseDiagnosticReportSupportingInfo(obj : TTurtleComplex) : TFhirDiagnosticReportSupportingInfo; overload; 
    procedure ParseDiagnosticReportSupportingInfoProperties(obj : TTurtleComplex; value : TFhirDiagnosticReportSupportingInfo); overload; 
    function ParseDiagnosticReportMedia(obj : TTurtleComplex) : TFhirDiagnosticReportMedia; overload; 
    procedure ParseDiagnosticReportMediaProperties(obj : TTurtleComplex; value : TFhirDiagnosticReportMedia); overload; 
    function ParseDiagnosticReport(obj : TTurtleComplex) : TFhirDiagnosticReport; overload; 
    procedure ParseDiagnosticReportProperties(obj : TTurtleComplex; value : TFhirDiagnosticReport); overload; 
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
    function ParseDocumentManifestRelated(obj : TTurtleComplex) : TFhirDocumentManifestRelated; overload; 
    procedure ParseDocumentManifestRelatedProperties(obj : TTurtleComplex; value : TFhirDocumentManifestRelated); overload; 
    function ParseDocumentManifest(obj : TTurtleComplex) : TFhirDocumentManifest; overload; 
    procedure ParseDocumentManifestProperties(obj : TTurtleComplex; value : TFhirDocumentManifest); overload; 
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
    function ParseDocumentReferenceAttester(obj : TTurtleComplex) : TFhirDocumentReferenceAttester; overload; 
    procedure ParseDocumentReferenceAttesterProperties(obj : TTurtleComplex; value : TFhirDocumentReferenceAttester); overload; 
    function ParseDocumentReferenceRelatesTo(obj : TTurtleComplex) : TFhirDocumentReferenceRelatesTo; overload; 
    procedure ParseDocumentReferenceRelatesToProperties(obj : TTurtleComplex; value : TFhirDocumentReferenceRelatesTo); overload; 
    function ParseDocumentReferenceContent(obj : TTurtleComplex) : TFhirDocumentReferenceContent; overload; 
    procedure ParseDocumentReferenceContentProperties(obj : TTurtleComplex; value : TFhirDocumentReferenceContent); overload; 
    function ParseDocumentReferenceContentProfile(obj : TTurtleComplex) : TFhirDocumentReferenceContentProfile; overload; 
    procedure ParseDocumentReferenceContentProfileProperties(obj : TTurtleComplex; value : TFhirDocumentReferenceContentProfile); overload; 
    function ParseDocumentReference(obj : TTurtleComplex) : TFhirDocumentReference; overload; 
    procedure ParseDocumentReferenceProperties(obj : TTurtleComplex; value : TFhirDocumentReference); overload; 
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ENCOUNTER}
    function ParseEncounterStatusHistory(obj : TTurtleComplex) : TFhirEncounterStatusHistory; overload; 
    procedure ParseEncounterStatusHistoryProperties(obj : TTurtleComplex; value : TFhirEncounterStatusHistory); overload; 
    function ParseEncounterClassHistory(obj : TTurtleComplex) : TFhirEncounterClassHistory; overload; 
    procedure ParseEncounterClassHistoryProperties(obj : TTurtleComplex; value : TFhirEncounterClassHistory); overload; 
    function ParseEncounterParticipant(obj : TTurtleComplex) : TFhirEncounterParticipant; overload; 
    procedure ParseEncounterParticipantProperties(obj : TTurtleComplex; value : TFhirEncounterParticipant); overload; 
    function ParseEncounterDiagnosis(obj : TTurtleComplex) : TFhirEncounterDiagnosis; overload; 
    procedure ParseEncounterDiagnosisProperties(obj : TTurtleComplex; value : TFhirEncounterDiagnosis); overload; 
    function ParseEncounterAdmission(obj : TTurtleComplex) : TFhirEncounterAdmission; overload; 
    procedure ParseEncounterAdmissionProperties(obj : TTurtleComplex; value : TFhirEncounterAdmission); overload; 
    function ParseEncounterLocation(obj : TTurtleComplex) : TFhirEncounterLocation; overload; 
    procedure ParseEncounterLocationProperties(obj : TTurtleComplex; value : TFhirEncounterLocation); overload; 
    function ParseEncounter(obj : TTurtleComplex) : TFhirEncounter; overload; 
    procedure ParseEncounterProperties(obj : TTurtleComplex; value : TFhirEncounter); overload; 
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
    function ParseEndpoint(obj : TTurtleComplex) : TFhirEndpoint; overload; 
    procedure ParseEndpointProperties(obj : TTurtleComplex; value : TFhirEndpoint); overload; 
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
    function ParseEnrollmentRequest(obj : TTurtleComplex) : TFhirEnrollmentRequest; overload; 
    procedure ParseEnrollmentRequestProperties(obj : TTurtleComplex; value : TFhirEnrollmentRequest); overload; 
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
    function ParseEnrollmentResponse(obj : TTurtleComplex) : TFhirEnrollmentResponse; overload; 
    procedure ParseEnrollmentResponseProperties(obj : TTurtleComplex; value : TFhirEnrollmentResponse); overload; 
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
    function ParseEpisodeOfCareStatusHistory(obj : TTurtleComplex) : TFhirEpisodeOfCareStatusHistory; overload; 
    procedure ParseEpisodeOfCareStatusHistoryProperties(obj : TTurtleComplex; value : TFhirEpisodeOfCareStatusHistory); overload; 
    function ParseEpisodeOfCareDiagnosis(obj : TTurtleComplex) : TFhirEpisodeOfCareDiagnosis; overload; 
    procedure ParseEpisodeOfCareDiagnosisProperties(obj : TTurtleComplex; value : TFhirEpisodeOfCareDiagnosis); overload; 
    function ParseEpisodeOfCare(obj : TTurtleComplex) : TFhirEpisodeOfCare; overload; 
    procedure ParseEpisodeOfCareProperties(obj : TTurtleComplex; value : TFhirEpisodeOfCare); overload; 
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EVENTDEFINITION}
    function ParseEventDefinition(obj : TTurtleComplex) : TFhirEventDefinition; overload; 
    procedure ParseEventDefinitionProperties(obj : TTurtleComplex; value : TFhirEventDefinition); overload; 
{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EVIDENCE}
    function ParseEvidenceVariableDefinition(obj : TTurtleComplex) : TFhirEvidenceVariableDefinition; overload; 
    procedure ParseEvidenceVariableDefinitionProperties(obj : TTurtleComplex; value : TFhirEvidenceVariableDefinition); overload; 
    function ParseEvidenceStatistic(obj : TTurtleComplex) : TFhirEvidenceStatistic; overload; 
    procedure ParseEvidenceStatisticProperties(obj : TTurtleComplex; value : TFhirEvidenceStatistic); overload; 
    function ParseEvidenceStatisticSampleSize(obj : TTurtleComplex) : TFhirEvidenceStatisticSampleSize; overload; 
    procedure ParseEvidenceStatisticSampleSizeProperties(obj : TTurtleComplex; value : TFhirEvidenceStatisticSampleSize); overload; 
    function ParseEvidenceStatisticAttributeEstimate(obj : TTurtleComplex) : TFhirEvidenceStatisticAttributeEstimate; overload; 
    procedure ParseEvidenceStatisticAttributeEstimateProperties(obj : TTurtleComplex; value : TFhirEvidenceStatisticAttributeEstimate); overload; 
    function ParseEvidenceStatisticModelCharacteristic(obj : TTurtleComplex) : TFhirEvidenceStatisticModelCharacteristic; overload; 
    procedure ParseEvidenceStatisticModelCharacteristicProperties(obj : TTurtleComplex; value : TFhirEvidenceStatisticModelCharacteristic); overload; 
    function ParseEvidenceStatisticModelCharacteristicVariable(obj : TTurtleComplex) : TFhirEvidenceStatisticModelCharacteristicVariable; overload; 
    procedure ParseEvidenceStatisticModelCharacteristicVariableProperties(obj : TTurtleComplex; value : TFhirEvidenceStatisticModelCharacteristicVariable); overload; 
    function ParseEvidenceCertainty(obj : TTurtleComplex) : TFhirEvidenceCertainty; overload; 
    procedure ParseEvidenceCertaintyProperties(obj : TTurtleComplex; value : TFhirEvidenceCertainty); overload; 
    function ParseEvidence(obj : TTurtleComplex) : TFhirEvidence; overload; 
    procedure ParseEvidenceProperties(obj : TTurtleComplex; value : TFhirEvidence); overload; 
{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEREPORT}
    function ParseEvidenceReportSubject(obj : TTurtleComplex) : TFhirEvidenceReportSubject; overload; 
    procedure ParseEvidenceReportSubjectProperties(obj : TTurtleComplex; value : TFhirEvidenceReportSubject); overload; 
    function ParseEvidenceReportSubjectCharacteristic(obj : TTurtleComplex) : TFhirEvidenceReportSubjectCharacteristic; overload; 
    procedure ParseEvidenceReportSubjectCharacteristicProperties(obj : TTurtleComplex; value : TFhirEvidenceReportSubjectCharacteristic); overload; 
    function ParseEvidenceReportRelatesTo(obj : TTurtleComplex) : TFhirEvidenceReportRelatesTo; overload; 
    procedure ParseEvidenceReportRelatesToProperties(obj : TTurtleComplex; value : TFhirEvidenceReportRelatesTo); overload; 
    function ParseEvidenceReportRelatesToTarget(obj : TTurtleComplex) : TFhirEvidenceReportRelatesToTarget; overload; 
    procedure ParseEvidenceReportRelatesToTargetProperties(obj : TTurtleComplex; value : TFhirEvidenceReportRelatesToTarget); overload; 
    function ParseEvidenceReportSection(obj : TTurtleComplex) : TFhirEvidenceReportSection; overload; 
    procedure ParseEvidenceReportSectionProperties(obj : TTurtleComplex; value : TFhirEvidenceReportSection); overload; 
    function ParseEvidenceReport(obj : TTurtleComplex) : TFhirEvidenceReport; overload; 
    procedure ParseEvidenceReportProperties(obj : TTurtleComplex; value : TFhirEvidenceReport); overload; 
{$ENDIF FHIR_EVIDENCEREPORT}
{$IFDEF FHIR_EVIDENCEVARIABLE}
    function ParseEvidenceVariableCharacteristic(obj : TTurtleComplex) : TFhirEvidenceVariableCharacteristic; overload; 
    procedure ParseEvidenceVariableCharacteristicProperties(obj : TTurtleComplex; value : TFhirEvidenceVariableCharacteristic); overload; 
    function ParseEvidenceVariableCharacteristicDefinitionByTypeAndValue(obj : TTurtleComplex) : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue; overload; 
    procedure ParseEvidenceVariableCharacteristicDefinitionByTypeAndValueProperties(obj : TTurtleComplex; value : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue); overload; 
    function ParseEvidenceVariableCharacteristicDefinitionByCombination(obj : TTurtleComplex) : TFhirEvidenceVariableCharacteristicDefinitionByCombination; overload; 
    procedure ParseEvidenceVariableCharacteristicDefinitionByCombinationProperties(obj : TTurtleComplex; value : TFhirEvidenceVariableCharacteristicDefinitionByCombination); overload; 
    function ParseEvidenceVariableCharacteristicTimeFromEvent(obj : TTurtleComplex) : TFhirEvidenceVariableCharacteristicTimeFromEvent; overload; 
    procedure ParseEvidenceVariableCharacteristicTimeFromEventProperties(obj : TTurtleComplex; value : TFhirEvidenceVariableCharacteristicTimeFromEvent); overload; 
    function ParseEvidenceVariableCategory(obj : TTurtleComplex) : TFhirEvidenceVariableCategory; overload; 
    procedure ParseEvidenceVariableCategoryProperties(obj : TTurtleComplex; value : TFhirEvidenceVariableCategory); overload; 
    function ParseEvidenceVariable(obj : TTurtleComplex) : TFhirEvidenceVariable; overload; 
    procedure ParseEvidenceVariableProperties(obj : TTurtleComplex; value : TFhirEvidenceVariable); overload; 
{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_EXAMPLESCENARIO}
    function ParseExampleScenarioActor(obj : TTurtleComplex) : TFhirExampleScenarioActor; overload; 
    procedure ParseExampleScenarioActorProperties(obj : TTurtleComplex; value : TFhirExampleScenarioActor); overload; 
    function ParseExampleScenarioInstance(obj : TTurtleComplex) : TFhirExampleScenarioInstance; overload; 
    procedure ParseExampleScenarioInstanceProperties(obj : TTurtleComplex; value : TFhirExampleScenarioInstance); overload; 
    function ParseExampleScenarioInstanceVersion(obj : TTurtleComplex) : TFhirExampleScenarioInstanceVersion; overload; 
    procedure ParseExampleScenarioInstanceVersionProperties(obj : TTurtleComplex; value : TFhirExampleScenarioInstanceVersion); overload; 
    function ParseExampleScenarioInstanceContainedInstance(obj : TTurtleComplex) : TFhirExampleScenarioInstanceContainedInstance; overload; 
    procedure ParseExampleScenarioInstanceContainedInstanceProperties(obj : TTurtleComplex; value : TFhirExampleScenarioInstanceContainedInstance); overload; 
    function ParseExampleScenarioProcess(obj : TTurtleComplex) : TFhirExampleScenarioProcess; overload; 
    procedure ParseExampleScenarioProcessProperties(obj : TTurtleComplex; value : TFhirExampleScenarioProcess); overload; 
    function ParseExampleScenarioProcessStep(obj : TTurtleComplex) : TFhirExampleScenarioProcessStep; overload; 
    procedure ParseExampleScenarioProcessStepProperties(obj : TTurtleComplex; value : TFhirExampleScenarioProcessStep); overload; 
    function ParseExampleScenarioProcessStepOperation(obj : TTurtleComplex) : TFhirExampleScenarioProcessStepOperation; overload; 
    procedure ParseExampleScenarioProcessStepOperationProperties(obj : TTurtleComplex; value : TFhirExampleScenarioProcessStepOperation); overload; 
    function ParseExampleScenarioProcessStepAlternative(obj : TTurtleComplex) : TFhirExampleScenarioProcessStepAlternative; overload; 
    procedure ParseExampleScenarioProcessStepAlternativeProperties(obj : TTurtleComplex; value : TFhirExampleScenarioProcessStepAlternative); overload; 
    function ParseExampleScenario(obj : TTurtleComplex) : TFhirExampleScenario; overload; 
    procedure ParseExampleScenarioProperties(obj : TTurtleComplex; value : TFhirExampleScenario); overload; 
{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
    function ParseExplanationOfBenefitRelated(obj : TTurtleComplex) : TFhirExplanationOfBenefitRelated; overload; 
    procedure ParseExplanationOfBenefitRelatedProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitRelated); overload; 
    function ParseExplanationOfBenefitPayee(obj : TTurtleComplex) : TFhirExplanationOfBenefitPayee; overload; 
    procedure ParseExplanationOfBenefitPayeeProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitPayee); overload; 
    function ParseExplanationOfBenefitCareTeam(obj : TTurtleComplex) : TFhirExplanationOfBenefitCareTeam; overload; 
    procedure ParseExplanationOfBenefitCareTeamProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitCareTeam); overload; 
    function ParseExplanationOfBenefitSupportingInfo(obj : TTurtleComplex) : TFhirExplanationOfBenefitSupportingInfo; overload; 
    procedure ParseExplanationOfBenefitSupportingInfoProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitSupportingInfo); overload; 
    function ParseExplanationOfBenefitDiagnosis(obj : TTurtleComplex) : TFhirExplanationOfBenefitDiagnosis; overload; 
    procedure ParseExplanationOfBenefitDiagnosisProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitDiagnosis); overload; 
    function ParseExplanationOfBenefitProcedure(obj : TTurtleComplex) : TFhirExplanationOfBenefitProcedure; overload; 
    procedure ParseExplanationOfBenefitProcedureProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitProcedure); overload; 
    function ParseExplanationOfBenefitInsurance(obj : TTurtleComplex) : TFhirExplanationOfBenefitInsurance; overload; 
    procedure ParseExplanationOfBenefitInsuranceProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitInsurance); overload; 
    function ParseExplanationOfBenefitAccident(obj : TTurtleComplex) : TFhirExplanationOfBenefitAccident; overload; 
    procedure ParseExplanationOfBenefitAccidentProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitAccident); overload; 
    function ParseExplanationOfBenefitItem(obj : TTurtleComplex) : TFhirExplanationOfBenefitItem; overload; 
    procedure ParseExplanationOfBenefitItemProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitItem); overload; 
    function ParseExplanationOfBenefitItemBodySite(obj : TTurtleComplex) : TFhirExplanationOfBenefitItemBodySite; overload; 
    procedure ParseExplanationOfBenefitItemBodySiteProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitItemBodySite); overload; 
    function ParseExplanationOfBenefitItemAdjudication(obj : TTurtleComplex) : TFhirExplanationOfBenefitItemAdjudication; overload; 
    procedure ParseExplanationOfBenefitItemAdjudicationProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitItemAdjudication); overload; 
    function ParseExplanationOfBenefitItemDetail(obj : TTurtleComplex) : TFhirExplanationOfBenefitItemDetail; overload; 
    procedure ParseExplanationOfBenefitItemDetailProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitItemDetail); overload; 
    function ParseExplanationOfBenefitItemDetailSubDetail(obj : TTurtleComplex) : TFhirExplanationOfBenefitItemDetailSubDetail; overload; 
    procedure ParseExplanationOfBenefitItemDetailSubDetailProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitItemDetailSubDetail); overload; 
    function ParseExplanationOfBenefitAddItem(obj : TTurtleComplex) : TFhirExplanationOfBenefitAddItem; overload; 
    procedure ParseExplanationOfBenefitAddItemProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitAddItem); overload; 
    function ParseExplanationOfBenefitAddItemBodySite(obj : TTurtleComplex) : TFhirExplanationOfBenefitAddItemBodySite; overload; 
    procedure ParseExplanationOfBenefitAddItemBodySiteProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitAddItemBodySite); overload; 
    function ParseExplanationOfBenefitAddItemDetail(obj : TTurtleComplex) : TFhirExplanationOfBenefitAddItemDetail; overload; 
    procedure ParseExplanationOfBenefitAddItemDetailProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitAddItemDetail); overload; 
    function ParseExplanationOfBenefitAddItemDetailSubDetail(obj : TTurtleComplex) : TFhirExplanationOfBenefitAddItemDetailSubDetail; overload; 
    procedure ParseExplanationOfBenefitAddItemDetailSubDetailProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitAddItemDetailSubDetail); overload; 
    function ParseExplanationOfBenefitTotal(obj : TTurtleComplex) : TFhirExplanationOfBenefitTotal; overload; 
    procedure ParseExplanationOfBenefitTotalProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitTotal); overload; 
    function ParseExplanationOfBenefitPayment(obj : TTurtleComplex) : TFhirExplanationOfBenefitPayment; overload; 
    procedure ParseExplanationOfBenefitPaymentProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitPayment); overload; 
    function ParseExplanationOfBenefitProcessNote(obj : TTurtleComplex) : TFhirExplanationOfBenefitProcessNote; overload; 
    procedure ParseExplanationOfBenefitProcessNoteProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitProcessNote); overload; 
    function ParseExplanationOfBenefitBenefitBalance(obj : TTurtleComplex) : TFhirExplanationOfBenefitBenefitBalance; overload; 
    procedure ParseExplanationOfBenefitBenefitBalanceProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitBenefitBalance); overload; 
    function ParseExplanationOfBenefitBenefitBalanceFinancial(obj : TTurtleComplex) : TFhirExplanationOfBenefitBenefitBalanceFinancial; overload; 
    procedure ParseExplanationOfBenefitBenefitBalanceFinancialProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitBenefitBalanceFinancial); overload; 
    function ParseExplanationOfBenefit(obj : TTurtleComplex) : TFhirExplanationOfBenefit; overload; 
    procedure ParseExplanationOfBenefitProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefit); overload; 
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
    function ParseFamilyMemberHistoryCondition(obj : TTurtleComplex) : TFhirFamilyMemberHistoryCondition; overload; 
    procedure ParseFamilyMemberHistoryConditionProperties(obj : TTurtleComplex; value : TFhirFamilyMemberHistoryCondition); overload; 
    function ParseFamilyMemberHistoryProcedure(obj : TTurtleComplex) : TFhirFamilyMemberHistoryProcedure; overload; 
    procedure ParseFamilyMemberHistoryProcedureProperties(obj : TTurtleComplex; value : TFhirFamilyMemberHistoryProcedure); overload; 
    function ParseFamilyMemberHistory(obj : TTurtleComplex) : TFhirFamilyMemberHistory; overload; 
    procedure ParseFamilyMemberHistoryProperties(obj : TTurtleComplex; value : TFhirFamilyMemberHistory); overload; 
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
    function ParseFlag(obj : TTurtleComplex) : TFhirFlag; overload; 
    procedure ParseFlagProperties(obj : TTurtleComplex; value : TFhirFlag); overload; 
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_FORMULARYITEM}
    function ParseFormularyItem(obj : TTurtleComplex) : TFhirFormularyItem; overload; 
    procedure ParseFormularyItemProperties(obj : TTurtleComplex; value : TFhirFormularyItem); overload; 
{$ENDIF FHIR_FORMULARYITEM}
{$IFDEF FHIR_GENOMICSTUDY}
    function ParseGenomicStudyAnalysis(obj : TTurtleComplex) : TFhirGenomicStudyAnalysis; overload; 
    procedure ParseGenomicStudyAnalysisProperties(obj : TTurtleComplex; value : TFhirGenomicStudyAnalysis); overload; 
    function ParseGenomicStudyAnalysisInput(obj : TTurtleComplex) : TFhirGenomicStudyAnalysisInput; overload; 
    procedure ParseGenomicStudyAnalysisInputProperties(obj : TTurtleComplex; value : TFhirGenomicStudyAnalysisInput); overload; 
    function ParseGenomicStudyAnalysisOutput(obj : TTurtleComplex) : TFhirGenomicStudyAnalysisOutput; overload; 
    procedure ParseGenomicStudyAnalysisOutputProperties(obj : TTurtleComplex; value : TFhirGenomicStudyAnalysisOutput); overload; 
    function ParseGenomicStudyAnalysisPerformer(obj : TTurtleComplex) : TFhirGenomicStudyAnalysisPerformer; overload; 
    procedure ParseGenomicStudyAnalysisPerformerProperties(obj : TTurtleComplex; value : TFhirGenomicStudyAnalysisPerformer); overload; 
    function ParseGenomicStudyAnalysisDevice(obj : TTurtleComplex) : TFhirGenomicStudyAnalysisDevice; overload; 
    procedure ParseGenomicStudyAnalysisDeviceProperties(obj : TTurtleComplex; value : TFhirGenomicStudyAnalysisDevice); overload; 
    function ParseGenomicStudy(obj : TTurtleComplex) : TFhirGenomicStudy; overload; 
    procedure ParseGenomicStudyProperties(obj : TTurtleComplex; value : TFhirGenomicStudy); overload; 
{$ENDIF FHIR_GENOMICSTUDY}
{$IFDEF FHIR_GOAL}
    function ParseGoalTarget(obj : TTurtleComplex) : TFhirGoalTarget; overload; 
    procedure ParseGoalTargetProperties(obj : TTurtleComplex; value : TFhirGoalTarget); overload; 
    function ParseGoal(obj : TTurtleComplex) : TFhirGoal; overload; 
    procedure ParseGoalProperties(obj : TTurtleComplex; value : TFhirGoal); overload; 
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
    function ParseGraphDefinitionLink(obj : TTurtleComplex) : TFhirGraphDefinitionLink; overload; 
    procedure ParseGraphDefinitionLinkProperties(obj : TTurtleComplex; value : TFhirGraphDefinitionLink); overload; 
    function ParseGraphDefinitionLinkTarget(obj : TTurtleComplex) : TFhirGraphDefinitionLinkTarget; overload; 
    procedure ParseGraphDefinitionLinkTargetProperties(obj : TTurtleComplex; value : TFhirGraphDefinitionLinkTarget); overload; 
    function ParseGraphDefinitionLinkTargetCompartment(obj : TTurtleComplex) : TFhirGraphDefinitionLinkTargetCompartment; overload; 
    procedure ParseGraphDefinitionLinkTargetCompartmentProperties(obj : TTurtleComplex; value : TFhirGraphDefinitionLinkTargetCompartment); overload; 
    function ParseGraphDefinition(obj : TTurtleComplex) : TFhirGraphDefinition; overload; 
    procedure ParseGraphDefinitionProperties(obj : TTurtleComplex; value : TFhirGraphDefinition); overload; 
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
    function ParseGroupCharacteristic(obj : TTurtleComplex) : TFhirGroupCharacteristic; overload; 
    procedure ParseGroupCharacteristicProperties(obj : TTurtleComplex; value : TFhirGroupCharacteristic); overload; 
    function ParseGroupMember(obj : TTurtleComplex) : TFhirGroupMember; overload; 
    procedure ParseGroupMemberProperties(obj : TTurtleComplex; value : TFhirGroupMember); overload; 
    function ParseGroup(obj : TTurtleComplex) : TFhirGroup; overload; 
    procedure ParseGroupProperties(obj : TTurtleComplex; value : TFhirGroup); overload; 
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
    function ParseGuidanceResponse(obj : TTurtleComplex) : TFhirGuidanceResponse; overload; 
    procedure ParseGuidanceResponseProperties(obj : TTurtleComplex; value : TFhirGuidanceResponse); overload; 
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
    function ParseHealthcareServiceEligibility(obj : TTurtleComplex) : TFhirHealthcareServiceEligibility; overload; 
    procedure ParseHealthcareServiceEligibilityProperties(obj : TTurtleComplex; value : TFhirHealthcareServiceEligibility); overload; 
    function ParseHealthcareService(obj : TTurtleComplex) : TFhirHealthcareService; overload; 
    procedure ParseHealthcareServiceProperties(obj : TTurtleComplex; value : TFhirHealthcareService); overload; 
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGSELECTION}
    function ParseImagingSelectionPerformer(obj : TTurtleComplex) : TFhirImagingSelectionPerformer; overload; 
    procedure ParseImagingSelectionPerformerProperties(obj : TTurtleComplex; value : TFhirImagingSelectionPerformer); overload; 
    function ParseImagingSelectionInstance(obj : TTurtleComplex) : TFhirImagingSelectionInstance; overload; 
    procedure ParseImagingSelectionInstanceProperties(obj : TTurtleComplex; value : TFhirImagingSelectionInstance); overload; 
    function ParseImagingSelectionInstanceImageRegion(obj : TTurtleComplex) : TFhirImagingSelectionInstanceImageRegion; overload; 
    procedure ParseImagingSelectionInstanceImageRegionProperties(obj : TTurtleComplex; value : TFhirImagingSelectionInstanceImageRegion); overload; 
    function ParseImagingSelectionImageRegion(obj : TTurtleComplex) : TFhirImagingSelectionImageRegion; overload; 
    procedure ParseImagingSelectionImageRegionProperties(obj : TTurtleComplex; value : TFhirImagingSelectionImageRegion); overload; 
    function ParseImagingSelection(obj : TTurtleComplex) : TFhirImagingSelection; overload; 
    procedure ParseImagingSelectionProperties(obj : TTurtleComplex; value : TFhirImagingSelection); overload; 
{$ENDIF FHIR_IMAGINGSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
    function ParseImagingStudySeries(obj : TTurtleComplex) : TFhirImagingStudySeries; overload; 
    procedure ParseImagingStudySeriesProperties(obj : TTurtleComplex; value : TFhirImagingStudySeries); overload; 
    function ParseImagingStudySeriesPerformer(obj : TTurtleComplex) : TFhirImagingStudySeriesPerformer; overload; 
    procedure ParseImagingStudySeriesPerformerProperties(obj : TTurtleComplex; value : TFhirImagingStudySeriesPerformer); overload; 
    function ParseImagingStudySeriesInstance(obj : TTurtleComplex) : TFhirImagingStudySeriesInstance; overload; 
    procedure ParseImagingStudySeriesInstanceProperties(obj : TTurtleComplex; value : TFhirImagingStudySeriesInstance); overload; 
    function ParseImagingStudy(obj : TTurtleComplex) : TFhirImagingStudy; overload; 
    procedure ParseImagingStudyProperties(obj : TTurtleComplex; value : TFhirImagingStudy); overload; 
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
    function ParseImmunizationPerformer(obj : TTurtleComplex) : TFhirImmunizationPerformer; overload; 
    procedure ParseImmunizationPerformerProperties(obj : TTurtleComplex; value : TFhirImmunizationPerformer); overload; 
    function ParseImmunizationProgramEligibility(obj : TTurtleComplex) : TFhirImmunizationProgramEligibility; overload; 
    procedure ParseImmunizationProgramEligibilityProperties(obj : TTurtleComplex; value : TFhirImmunizationProgramEligibility); overload; 
    function ParseImmunizationReaction(obj : TTurtleComplex) : TFhirImmunizationReaction; overload; 
    procedure ParseImmunizationReactionProperties(obj : TTurtleComplex; value : TFhirImmunizationReaction); overload; 
    function ParseImmunizationProtocolApplied(obj : TTurtleComplex) : TFhirImmunizationProtocolApplied; overload; 
    procedure ParseImmunizationProtocolAppliedProperties(obj : TTurtleComplex; value : TFhirImmunizationProtocolApplied); overload; 
    function ParseImmunization(obj : TTurtleComplex) : TFhirImmunization; overload; 
    procedure ParseImmunizationProperties(obj : TTurtleComplex; value : TFhirImmunization); overload; 
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
    function ParseImmunizationEvaluation(obj : TTurtleComplex) : TFhirImmunizationEvaluation; overload; 
    procedure ParseImmunizationEvaluationProperties(obj : TTurtleComplex; value : TFhirImmunizationEvaluation); overload; 
{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
    function ParseImmunizationRecommendationRecommendation(obj : TTurtleComplex) : TFhirImmunizationRecommendationRecommendation; overload; 
    procedure ParseImmunizationRecommendationRecommendationProperties(obj : TTurtleComplex; value : TFhirImmunizationRecommendationRecommendation); overload; 
    function ParseImmunizationRecommendationRecommendationDateCriterion(obj : TTurtleComplex) : TFhirImmunizationRecommendationRecommendationDateCriterion; overload; 
    procedure ParseImmunizationRecommendationRecommendationDateCriterionProperties(obj : TTurtleComplex; value : TFhirImmunizationRecommendationRecommendationDateCriterion); overload; 
    function ParseImmunizationRecommendation(obj : TTurtleComplex) : TFhirImmunizationRecommendation; overload; 
    procedure ParseImmunizationRecommendationProperties(obj : TTurtleComplex; value : TFhirImmunizationRecommendation); overload; 
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
    function ParseImplementationGuideDependsOn(obj : TTurtleComplex) : TFhirImplementationGuideDependsOn; overload; 
    procedure ParseImplementationGuideDependsOnProperties(obj : TTurtleComplex; value : TFhirImplementationGuideDependsOn); overload; 
    function ParseImplementationGuideGlobal(obj : TTurtleComplex) : TFhirImplementationGuideGlobal; overload; 
    procedure ParseImplementationGuideGlobalProperties(obj : TTurtleComplex; value : TFhirImplementationGuideGlobal); overload; 
    function ParseImplementationGuideDefinition(obj : TTurtleComplex) : TFhirImplementationGuideDefinition; overload; 
    procedure ParseImplementationGuideDefinitionProperties(obj : TTurtleComplex; value : TFhirImplementationGuideDefinition); overload; 
    function ParseImplementationGuideDefinitionGrouping(obj : TTurtleComplex) : TFhirImplementationGuideDefinitionGrouping; overload; 
    procedure ParseImplementationGuideDefinitionGroupingProperties(obj : TTurtleComplex; value : TFhirImplementationGuideDefinitionGrouping); overload; 
    function ParseImplementationGuideDefinitionResource(obj : TTurtleComplex) : TFhirImplementationGuideDefinitionResource; overload; 
    procedure ParseImplementationGuideDefinitionResourceProperties(obj : TTurtleComplex; value : TFhirImplementationGuideDefinitionResource); overload; 
    function ParseImplementationGuideDefinitionPage(obj : TTurtleComplex) : TFhirImplementationGuideDefinitionPage; overload; 
    procedure ParseImplementationGuideDefinitionPageProperties(obj : TTurtleComplex; value : TFhirImplementationGuideDefinitionPage); overload; 
    function ParseImplementationGuideDefinitionParameter(obj : TTurtleComplex) : TFhirImplementationGuideDefinitionParameter; overload; 
    procedure ParseImplementationGuideDefinitionParameterProperties(obj : TTurtleComplex; value : TFhirImplementationGuideDefinitionParameter); overload; 
    function ParseImplementationGuideDefinitionTemplate(obj : TTurtleComplex) : TFhirImplementationGuideDefinitionTemplate; overload; 
    procedure ParseImplementationGuideDefinitionTemplateProperties(obj : TTurtleComplex; value : TFhirImplementationGuideDefinitionTemplate); overload; 
    function ParseImplementationGuideManifest(obj : TTurtleComplex) : TFhirImplementationGuideManifest; overload; 
    procedure ParseImplementationGuideManifestProperties(obj : TTurtleComplex; value : TFhirImplementationGuideManifest); overload; 
    function ParseImplementationGuideManifestResource(obj : TTurtleComplex) : TFhirImplementationGuideManifestResource; overload; 
    procedure ParseImplementationGuideManifestResourceProperties(obj : TTurtleComplex; value : TFhirImplementationGuideManifestResource); overload; 
    function ParseImplementationGuideManifestPage(obj : TTurtleComplex) : TFhirImplementationGuideManifestPage; overload; 
    procedure ParseImplementationGuideManifestPageProperties(obj : TTurtleComplex; value : TFhirImplementationGuideManifestPage); overload; 
    function ParseImplementationGuide(obj : TTurtleComplex) : TFhirImplementationGuide; overload; 
    procedure ParseImplementationGuideProperties(obj : TTurtleComplex; value : TFhirImplementationGuide); overload; 
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_INGREDIENT}
    function ParseIngredientManufacturer(obj : TTurtleComplex) : TFhirIngredientManufacturer; overload; 
    procedure ParseIngredientManufacturerProperties(obj : TTurtleComplex; value : TFhirIngredientManufacturer); overload; 
    function ParseIngredientSubstance(obj : TTurtleComplex) : TFhirIngredientSubstance; overload; 
    procedure ParseIngredientSubstanceProperties(obj : TTurtleComplex; value : TFhirIngredientSubstance); overload; 
    function ParseIngredientSubstanceStrength(obj : TTurtleComplex) : TFhirIngredientSubstanceStrength; overload; 
    procedure ParseIngredientSubstanceStrengthProperties(obj : TTurtleComplex; value : TFhirIngredientSubstanceStrength); overload; 
    function ParseIngredientSubstanceStrengthReferenceStrength(obj : TTurtleComplex) : TFhirIngredientSubstanceStrengthReferenceStrength; overload; 
    procedure ParseIngredientSubstanceStrengthReferenceStrengthProperties(obj : TTurtleComplex; value : TFhirIngredientSubstanceStrengthReferenceStrength); overload; 
    function ParseIngredient(obj : TTurtleComplex) : TFhirIngredient; overload; 
    procedure ParseIngredientProperties(obj : TTurtleComplex; value : TFhirIngredient); overload; 
{$ENDIF FHIR_INGREDIENT}
{$IFDEF FHIR_INSURANCEPLAN}
    function ParseInsurancePlanCoverage(obj : TTurtleComplex) : TFhirInsurancePlanCoverage; overload; 
    procedure ParseInsurancePlanCoverageProperties(obj : TTurtleComplex; value : TFhirInsurancePlanCoverage); overload; 
    function ParseInsurancePlanCoverageBenefit(obj : TTurtleComplex) : TFhirInsurancePlanCoverageBenefit; overload; 
    procedure ParseInsurancePlanCoverageBenefitProperties(obj : TTurtleComplex; value : TFhirInsurancePlanCoverageBenefit); overload; 
    function ParseInsurancePlanCoverageBenefitLimit(obj : TTurtleComplex) : TFhirInsurancePlanCoverageBenefitLimit; overload; 
    procedure ParseInsurancePlanCoverageBenefitLimitProperties(obj : TTurtleComplex; value : TFhirInsurancePlanCoverageBenefitLimit); overload; 
    function ParseInsurancePlanPlan(obj : TTurtleComplex) : TFhirInsurancePlanPlan; overload; 
    procedure ParseInsurancePlanPlanProperties(obj : TTurtleComplex; value : TFhirInsurancePlanPlan); overload; 
    function ParseInsurancePlanPlanGeneralCost(obj : TTurtleComplex) : TFhirInsurancePlanPlanGeneralCost; overload; 
    procedure ParseInsurancePlanPlanGeneralCostProperties(obj : TTurtleComplex; value : TFhirInsurancePlanPlanGeneralCost); overload; 
    function ParseInsurancePlanPlanSpecificCost(obj : TTurtleComplex) : TFhirInsurancePlanPlanSpecificCost; overload; 
    procedure ParseInsurancePlanPlanSpecificCostProperties(obj : TTurtleComplex; value : TFhirInsurancePlanPlanSpecificCost); overload; 
    function ParseInsurancePlanPlanSpecificCostBenefit(obj : TTurtleComplex) : TFhirInsurancePlanPlanSpecificCostBenefit; overload; 
    procedure ParseInsurancePlanPlanSpecificCostBenefitProperties(obj : TTurtleComplex; value : TFhirInsurancePlanPlanSpecificCostBenefit); overload; 
    function ParseInsurancePlanPlanSpecificCostBenefitCost(obj : TTurtleComplex) : TFhirInsurancePlanPlanSpecificCostBenefitCost; overload; 
    procedure ParseInsurancePlanPlanSpecificCostBenefitCostProperties(obj : TTurtleComplex; value : TFhirInsurancePlanPlanSpecificCostBenefitCost); overload; 
    function ParseInsurancePlan(obj : TTurtleComplex) : TFhirInsurancePlan; overload; 
    procedure ParseInsurancePlanProperties(obj : TTurtleComplex; value : TFhirInsurancePlan); overload; 
{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVENTORYREPORT}
    function ParseInventoryReportInventoryListing(obj : TTurtleComplex) : TFhirInventoryReportInventoryListing; overload; 
    procedure ParseInventoryReportInventoryListingProperties(obj : TTurtleComplex; value : TFhirInventoryReportInventoryListing); overload; 
    function ParseInventoryReportInventoryListingItems(obj : TTurtleComplex) : TFhirInventoryReportInventoryListingItems; overload; 
    procedure ParseInventoryReportInventoryListingItemsProperties(obj : TTurtleComplex; value : TFhirInventoryReportInventoryListingItems); overload; 
    function ParseInventoryReport(obj : TTurtleComplex) : TFhirInventoryReport; overload; 
    procedure ParseInventoryReportProperties(obj : TTurtleComplex; value : TFhirInventoryReport); overload; 
{$ENDIF FHIR_INVENTORYREPORT}
{$IFDEF FHIR_INVOICE}
    function ParseInvoiceParticipant(obj : TTurtleComplex) : TFhirInvoiceParticipant; overload; 
    procedure ParseInvoiceParticipantProperties(obj : TTurtleComplex; value : TFhirInvoiceParticipant); overload; 
    function ParseInvoiceLineItem(obj : TTurtleComplex) : TFhirInvoiceLineItem; overload; 
    procedure ParseInvoiceLineItemProperties(obj : TTurtleComplex; value : TFhirInvoiceLineItem); overload; 
    function ParseInvoice(obj : TTurtleComplex) : TFhirInvoice; overload; 
    procedure ParseInvoiceProperties(obj : TTurtleComplex; value : TFhirInvoice); overload; 
{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_LIBRARY}
    function ParseLibrary(obj : TTurtleComplex) : TFhirLibrary; overload; 
    procedure ParseLibraryProperties(obj : TTurtleComplex; value : TFhirLibrary); overload; 
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
    function ParseLinkageItem(obj : TTurtleComplex) : TFhirLinkageItem; overload; 
    procedure ParseLinkageItemProperties(obj : TTurtleComplex; value : TFhirLinkageItem); overload; 
    function ParseLinkage(obj : TTurtleComplex) : TFhirLinkage; overload; 
    procedure ParseLinkageProperties(obj : TTurtleComplex; value : TFhirLinkage); overload; 
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
    function ParseListEntry(obj : TTurtleComplex) : TFhirListEntry; overload; 
    procedure ParseListEntryProperties(obj : TTurtleComplex; value : TFhirListEntry); overload; 
    function ParseList(obj : TTurtleComplex) : TFhirList; overload; 
    procedure ParseListProperties(obj : TTurtleComplex; value : TFhirList); overload; 
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
    function ParseLocationPosition(obj : TTurtleComplex) : TFhirLocationPosition; overload; 
    procedure ParseLocationPositionProperties(obj : TTurtleComplex; value : TFhirLocationPosition); overload; 
    function ParseLocation(obj : TTurtleComplex) : TFhirLocation; overload; 
    procedure ParseLocationProperties(obj : TTurtleComplex; value : TFhirLocation); overload; 
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MANUFACTUREDITEMDEFINITION}
    function ParseManufacturedItemDefinitionProperty(obj : TTurtleComplex) : TFhirManufacturedItemDefinitionProperty; overload; 
    procedure ParseManufacturedItemDefinitionPropertyProperties(obj : TTurtleComplex; value : TFhirManufacturedItemDefinitionProperty); overload; 
    function ParseManufacturedItemDefinitionComponent(obj : TTurtleComplex) : TFhirManufacturedItemDefinitionComponent; overload; 
    procedure ParseManufacturedItemDefinitionComponentProperties(obj : TTurtleComplex; value : TFhirManufacturedItemDefinitionComponent); overload; 
    function ParseManufacturedItemDefinitionComponentConstituent(obj : TTurtleComplex) : TFhirManufacturedItemDefinitionComponentConstituent; overload; 
    procedure ParseManufacturedItemDefinitionComponentConstituentProperties(obj : TTurtleComplex; value : TFhirManufacturedItemDefinitionComponentConstituent); overload; 
    function ParseManufacturedItemDefinition(obj : TTurtleComplex) : TFhirManufacturedItemDefinition; overload; 
    procedure ParseManufacturedItemDefinitionProperties(obj : TTurtleComplex; value : TFhirManufacturedItemDefinition); overload; 
{$ENDIF FHIR_MANUFACTUREDITEMDEFINITION}
{$IFDEF FHIR_MEASURE}
    function ParseMeasureTerm(obj : TTurtleComplex) : TFhirMeasureTerm; overload; 
    procedure ParseMeasureTermProperties(obj : TTurtleComplex; value : TFhirMeasureTerm); overload; 
    function ParseMeasureGroup(obj : TTurtleComplex) : TFhirMeasureGroup; overload; 
    procedure ParseMeasureGroupProperties(obj : TTurtleComplex; value : TFhirMeasureGroup); overload; 
    function ParseMeasureGroupPopulation(obj : TTurtleComplex) : TFhirMeasureGroupPopulation; overload; 
    procedure ParseMeasureGroupPopulationProperties(obj : TTurtleComplex; value : TFhirMeasureGroupPopulation); overload; 
    function ParseMeasureGroupStratifier(obj : TTurtleComplex) : TFhirMeasureGroupStratifier; overload; 
    procedure ParseMeasureGroupStratifierProperties(obj : TTurtleComplex; value : TFhirMeasureGroupStratifier); overload; 
    function ParseMeasureGroupStratifierComponent(obj : TTurtleComplex) : TFhirMeasureGroupStratifierComponent; overload; 
    procedure ParseMeasureGroupStratifierComponentProperties(obj : TTurtleComplex; value : TFhirMeasureGroupStratifierComponent); overload; 
    function ParseMeasureSupplementalData(obj : TTurtleComplex) : TFhirMeasureSupplementalData; overload; 
    procedure ParseMeasureSupplementalDataProperties(obj : TTurtleComplex; value : TFhirMeasureSupplementalData); overload; 
    function ParseMeasure(obj : TTurtleComplex) : TFhirMeasure; overload; 
    procedure ParseMeasureProperties(obj : TTurtleComplex; value : TFhirMeasure); overload; 
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
    function ParseMeasureReportGroup(obj : TTurtleComplex) : TFhirMeasureReportGroup; overload; 
    procedure ParseMeasureReportGroupProperties(obj : TTurtleComplex; value : TFhirMeasureReportGroup); overload; 
    function ParseMeasureReportGroupPopulation(obj : TTurtleComplex) : TFhirMeasureReportGroupPopulation; overload; 
    procedure ParseMeasureReportGroupPopulationProperties(obj : TTurtleComplex; value : TFhirMeasureReportGroupPopulation); overload; 
    function ParseMeasureReportGroupStratifier(obj : TTurtleComplex) : TFhirMeasureReportGroupStratifier; overload; 
    procedure ParseMeasureReportGroupStratifierProperties(obj : TTurtleComplex; value : TFhirMeasureReportGroupStratifier); overload; 
    function ParseMeasureReportGroupStratifierStratum(obj : TTurtleComplex) : TFhirMeasureReportGroupStratifierStratum; overload; 
    procedure ParseMeasureReportGroupStratifierStratumProperties(obj : TTurtleComplex; value : TFhirMeasureReportGroupStratifierStratum); overload; 
    function ParseMeasureReportGroupStratifierStratumComponent(obj : TTurtleComplex) : TFhirMeasureReportGroupStratifierStratumComponent; overload; 
    procedure ParseMeasureReportGroupStratifierStratumComponentProperties(obj : TTurtleComplex; value : TFhirMeasureReportGroupStratifierStratumComponent); overload; 
    function ParseMeasureReportGroupStratifierStratumPopulation(obj : TTurtleComplex) : TFhirMeasureReportGroupStratifierStratumPopulation; overload; 
    procedure ParseMeasureReportGroupStratifierStratumPopulationProperties(obj : TTurtleComplex; value : TFhirMeasureReportGroupStratifierStratumPopulation); overload; 
    function ParseMeasureReport(obj : TTurtleComplex) : TFhirMeasureReport; overload; 
    procedure ParseMeasureReportProperties(obj : TTurtleComplex; value : TFhirMeasureReport); overload; 
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDICATION}
    function ParseMedicationIngredient(obj : TTurtleComplex) : TFhirMedicationIngredient; overload; 
    procedure ParseMedicationIngredientProperties(obj : TTurtleComplex; value : TFhirMedicationIngredient); overload; 
    function ParseMedicationBatch(obj : TTurtleComplex) : TFhirMedicationBatch; overload; 
    procedure ParseMedicationBatchProperties(obj : TTurtleComplex; value : TFhirMedicationBatch); overload; 
    function ParseMedication(obj : TTurtleComplex) : TFhirMedication; overload; 
    procedure ParseMedicationProperties(obj : TTurtleComplex; value : TFhirMedication); overload; 
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
    function ParseMedicationAdministrationPerformer(obj : TTurtleComplex) : TFhirMedicationAdministrationPerformer; overload; 
    procedure ParseMedicationAdministrationPerformerProperties(obj : TTurtleComplex; value : TFhirMedicationAdministrationPerformer); overload; 
    function ParseMedicationAdministrationDosage(obj : TTurtleComplex) : TFhirMedicationAdministrationDosage; overload; 
    procedure ParseMedicationAdministrationDosageProperties(obj : TTurtleComplex; value : TFhirMedicationAdministrationDosage); overload; 
    function ParseMedicationAdministration(obj : TTurtleComplex) : TFhirMedicationAdministration; overload; 
    procedure ParseMedicationAdministrationProperties(obj : TTurtleComplex; value : TFhirMedicationAdministration); overload; 
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
    function ParseMedicationDispensePerformer(obj : TTurtleComplex) : TFhirMedicationDispensePerformer; overload; 
    procedure ParseMedicationDispensePerformerProperties(obj : TTurtleComplex; value : TFhirMedicationDispensePerformer); overload; 
    function ParseMedicationDispenseSubstitution(obj : TTurtleComplex) : TFhirMedicationDispenseSubstitution; overload; 
    procedure ParseMedicationDispenseSubstitutionProperties(obj : TTurtleComplex; value : TFhirMedicationDispenseSubstitution); overload; 
    function ParseMedicationDispense(obj : TTurtleComplex) : TFhirMedicationDispense; overload; 
    procedure ParseMedicationDispenseProperties(obj : TTurtleComplex; value : TFhirMedicationDispense); overload; 
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
    function ParseMedicationKnowledgeRelatedMedicationKnowledge(obj : TTurtleComplex) : TFhirMedicationKnowledgeRelatedMedicationKnowledge; overload; 
    procedure ParseMedicationKnowledgeRelatedMedicationKnowledgeProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeRelatedMedicationKnowledge); overload; 
    function ParseMedicationKnowledgeMonograph(obj : TTurtleComplex) : TFhirMedicationKnowledgeMonograph; overload; 
    procedure ParseMedicationKnowledgeMonographProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeMonograph); overload; 
    function ParseMedicationKnowledgeCost(obj : TTurtleComplex) : TFhirMedicationKnowledgeCost; overload; 
    procedure ParseMedicationKnowledgeCostProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeCost); overload; 
    function ParseMedicationKnowledgeMonitoringProgram(obj : TTurtleComplex) : TFhirMedicationKnowledgeMonitoringProgram; overload; 
    procedure ParseMedicationKnowledgeMonitoringProgramProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeMonitoringProgram); overload; 
    function ParseMedicationKnowledgeIndicationGuideline(obj : TTurtleComplex) : TFhirMedicationKnowledgeIndicationGuideline; overload; 
    procedure ParseMedicationKnowledgeIndicationGuidelineProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeIndicationGuideline); overload; 
    function ParseMedicationKnowledgeIndicationGuidelineDosingGuideline(obj : TTurtleComplex) : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline; overload; 
    procedure ParseMedicationKnowledgeIndicationGuidelineDosingGuidelineProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline); overload; 
    function ParseMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage(obj : TTurtleComplex) : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage; overload; 
    procedure ParseMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage); overload; 
    function ParseMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic(obj : TTurtleComplex) : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic; overload; 
    procedure ParseMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic); overload; 
    function ParseMedicationKnowledgeMedicineClassification(obj : TTurtleComplex) : TFhirMedicationKnowledgeMedicineClassification; overload; 
    procedure ParseMedicationKnowledgeMedicineClassificationProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeMedicineClassification); overload; 
    function ParseMedicationKnowledgePackaging(obj : TTurtleComplex) : TFhirMedicationKnowledgePackaging; overload; 
    procedure ParseMedicationKnowledgePackagingProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgePackaging); overload; 
    function ParseMedicationKnowledgeStorageGuideline(obj : TTurtleComplex) : TFhirMedicationKnowledgeStorageGuideline; overload; 
    procedure ParseMedicationKnowledgeStorageGuidelineProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeStorageGuideline); overload; 
    function ParseMedicationKnowledgeStorageGuidelineEnvironmentalSetting(obj : TTurtleComplex) : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting; overload; 
    procedure ParseMedicationKnowledgeStorageGuidelineEnvironmentalSettingProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting); overload; 
    function ParseMedicationKnowledgeRegulatory(obj : TTurtleComplex) : TFhirMedicationKnowledgeRegulatory; overload; 
    procedure ParseMedicationKnowledgeRegulatoryProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeRegulatory); overload; 
    function ParseMedicationKnowledgeRegulatorySubstitution(obj : TTurtleComplex) : TFhirMedicationKnowledgeRegulatorySubstitution; overload; 
    procedure ParseMedicationKnowledgeRegulatorySubstitutionProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeRegulatorySubstitution); overload; 
    function ParseMedicationKnowledgeRegulatoryMaxDispense(obj : TTurtleComplex) : TFhirMedicationKnowledgeRegulatoryMaxDispense; overload; 
    procedure ParseMedicationKnowledgeRegulatoryMaxDispenseProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeRegulatoryMaxDispense); overload; 
    function ParseMedicationKnowledgeDefinitional(obj : TTurtleComplex) : TFhirMedicationKnowledgeDefinitional; overload; 
    procedure ParseMedicationKnowledgeDefinitionalProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeDefinitional); overload; 
    function ParseMedicationKnowledgeDefinitionalIngredient(obj : TTurtleComplex) : TFhirMedicationKnowledgeDefinitionalIngredient; overload; 
    procedure ParseMedicationKnowledgeDefinitionalIngredientProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeDefinitionalIngredient); overload; 
    function ParseMedicationKnowledgeDefinitionalDrugCharacteristic(obj : TTurtleComplex) : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic; overload; 
    procedure ParseMedicationKnowledgeDefinitionalDrugCharacteristicProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic); overload; 
    function ParseMedicationKnowledge(obj : TTurtleComplex) : TFhirMedicationKnowledge; overload; 
    procedure ParseMedicationKnowledgeProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledge); overload; 
{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICATIONREQUEST}
    function ParseMedicationRequestDose(obj : TTurtleComplex) : TFhirMedicationRequestDose; overload; 
    procedure ParseMedicationRequestDoseProperties(obj : TTurtleComplex; value : TFhirMedicationRequestDose); overload; 
    function ParseMedicationRequestDispenseRequest(obj : TTurtleComplex) : TFhirMedicationRequestDispenseRequest; overload; 
    procedure ParseMedicationRequestDispenseRequestProperties(obj : TTurtleComplex; value : TFhirMedicationRequestDispenseRequest); overload; 
    function ParseMedicationRequestDispenseRequestInitialFill(obj : TTurtleComplex) : TFhirMedicationRequestDispenseRequestInitialFill; overload; 
    procedure ParseMedicationRequestDispenseRequestInitialFillProperties(obj : TTurtleComplex; value : TFhirMedicationRequestDispenseRequestInitialFill); overload; 
    function ParseMedicationRequestSubstitution(obj : TTurtleComplex) : TFhirMedicationRequestSubstitution; overload; 
    procedure ParseMedicationRequestSubstitutionProperties(obj : TTurtleComplex; value : TFhirMedicationRequestSubstitution); overload; 
    function ParseMedicationRequest(obj : TTurtleComplex) : TFhirMedicationRequest; overload; 
    procedure ParseMedicationRequestProperties(obj : TTurtleComplex; value : TFhirMedicationRequest); overload; 
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONUSAGE}
    function ParseMedicationUsageAdherence(obj : TTurtleComplex) : TFhirMedicationUsageAdherence; overload; 
    procedure ParseMedicationUsageAdherenceProperties(obj : TTurtleComplex; value : TFhirMedicationUsageAdherence); overload; 
    function ParseMedicationUsage(obj : TTurtleComplex) : TFhirMedicationUsage; overload; 
    procedure ParseMedicationUsageProperties(obj : TTurtleComplex; value : TFhirMedicationUsage); overload; 
{$ENDIF FHIR_MEDICATIONUSAGE}
{$IFDEF FHIR_MEDICINALPRODUCTDEFINITION}
    function ParseMedicinalProductDefinitionContact(obj : TTurtleComplex) : TFhirMedicinalProductDefinitionContact; overload; 
    procedure ParseMedicinalProductDefinitionContactProperties(obj : TTurtleComplex; value : TFhirMedicinalProductDefinitionContact); overload; 
    function ParseMedicinalProductDefinitionName(obj : TTurtleComplex) : TFhirMedicinalProductDefinitionName; overload; 
    procedure ParseMedicinalProductDefinitionNameProperties(obj : TTurtleComplex; value : TFhirMedicinalProductDefinitionName); overload; 
    function ParseMedicinalProductDefinitionNamePart(obj : TTurtleComplex) : TFhirMedicinalProductDefinitionNamePart; overload; 
    procedure ParseMedicinalProductDefinitionNamePartProperties(obj : TTurtleComplex; value : TFhirMedicinalProductDefinitionNamePart); overload; 
    function ParseMedicinalProductDefinitionNameUsage(obj : TTurtleComplex) : TFhirMedicinalProductDefinitionNameUsage; overload; 
    procedure ParseMedicinalProductDefinitionNameUsageProperties(obj : TTurtleComplex; value : TFhirMedicinalProductDefinitionNameUsage); overload; 
    function ParseMedicinalProductDefinitionCrossReference(obj : TTurtleComplex) : TFhirMedicinalProductDefinitionCrossReference; overload; 
    procedure ParseMedicinalProductDefinitionCrossReferenceProperties(obj : TTurtleComplex; value : TFhirMedicinalProductDefinitionCrossReference); overload; 
    function ParseMedicinalProductDefinitionOperation(obj : TTurtleComplex) : TFhirMedicinalProductDefinitionOperation; overload; 
    procedure ParseMedicinalProductDefinitionOperationProperties(obj : TTurtleComplex; value : TFhirMedicinalProductDefinitionOperation); overload; 
    function ParseMedicinalProductDefinitionCharacteristic(obj : TTurtleComplex) : TFhirMedicinalProductDefinitionCharacteristic; overload; 
    procedure ParseMedicinalProductDefinitionCharacteristicProperties(obj : TTurtleComplex; value : TFhirMedicinalProductDefinitionCharacteristic); overload; 
    function ParseMedicinalProductDefinition(obj : TTurtleComplex) : TFhirMedicinalProductDefinition; overload; 
    procedure ParseMedicinalProductDefinitionProperties(obj : TTurtleComplex; value : TFhirMedicinalProductDefinition); overload; 
{$ENDIF FHIR_MEDICINALPRODUCTDEFINITION}
{$IFDEF FHIR_MESSAGEDEFINITION}
    function ParseMessageDefinitionFocus(obj : TTurtleComplex) : TFhirMessageDefinitionFocus; overload; 
    procedure ParseMessageDefinitionFocusProperties(obj : TTurtleComplex; value : TFhirMessageDefinitionFocus); overload; 
    function ParseMessageDefinitionAllowedResponse(obj : TTurtleComplex) : TFhirMessageDefinitionAllowedResponse; overload; 
    procedure ParseMessageDefinitionAllowedResponseProperties(obj : TTurtleComplex; value : TFhirMessageDefinitionAllowedResponse); overload; 
    function ParseMessageDefinition(obj : TTurtleComplex) : TFhirMessageDefinition; overload; 
    procedure ParseMessageDefinitionProperties(obj : TTurtleComplex; value : TFhirMessageDefinition); overload; 
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
    function ParseMessageHeaderDestination(obj : TTurtleComplex) : TFhirMessageHeaderDestination; overload; 
    procedure ParseMessageHeaderDestinationProperties(obj : TTurtleComplex; value : TFhirMessageHeaderDestination); overload; 
    function ParseMessageHeaderSource(obj : TTurtleComplex) : TFhirMessageHeaderSource; overload; 
    procedure ParseMessageHeaderSourceProperties(obj : TTurtleComplex; value : TFhirMessageHeaderSource); overload; 
    function ParseMessageHeaderResponse(obj : TTurtleComplex) : TFhirMessageHeaderResponse; overload; 
    procedure ParseMessageHeaderResponseProperties(obj : TTurtleComplex; value : TFhirMessageHeaderResponse); overload; 
    function ParseMessageHeader(obj : TTurtleComplex) : TFhirMessageHeader; overload; 
    procedure ParseMessageHeaderProperties(obj : TTurtleComplex; value : TFhirMessageHeader); overload; 
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_MOLECULARSEQUENCE}
    function ParseMolecularSequenceRelative(obj : TTurtleComplex) : TFhirMolecularSequenceRelative; overload; 
    procedure ParseMolecularSequenceRelativeProperties(obj : TTurtleComplex; value : TFhirMolecularSequenceRelative); overload; 
    function ParseMolecularSequenceRelativeStartingSequence(obj : TTurtleComplex) : TFhirMolecularSequenceRelativeStartingSequence; overload; 
    procedure ParseMolecularSequenceRelativeStartingSequenceProperties(obj : TTurtleComplex; value : TFhirMolecularSequenceRelativeStartingSequence); overload; 
    function ParseMolecularSequenceRelativeEdit(obj : TTurtleComplex) : TFhirMolecularSequenceRelativeEdit; overload; 
    procedure ParseMolecularSequenceRelativeEditProperties(obj : TTurtleComplex; value : TFhirMolecularSequenceRelativeEdit); overload; 
    function ParseMolecularSequence(obj : TTurtleComplex) : TFhirMolecularSequence; overload; 
    procedure ParseMolecularSequenceProperties(obj : TTurtleComplex; value : TFhirMolecularSequence); overload; 
{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NAMINGSYSTEM}
    function ParseNamingSystemUniqueId(obj : TTurtleComplex) : TFhirNamingSystemUniqueId; overload; 
    procedure ParseNamingSystemUniqueIdProperties(obj : TTurtleComplex; value : TFhirNamingSystemUniqueId); overload; 
    function ParseNamingSystem(obj : TTurtleComplex) : TFhirNamingSystem; overload; 
    procedure ParseNamingSystemProperties(obj : TTurtleComplex; value : TFhirNamingSystem); overload; 
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONINTAKE}
    function ParseNutritionIntakeConsumedItem(obj : TTurtleComplex) : TFhirNutritionIntakeConsumedItem; overload; 
    procedure ParseNutritionIntakeConsumedItemProperties(obj : TTurtleComplex; value : TFhirNutritionIntakeConsumedItem); overload; 
    function ParseNutritionIntakeIngredientLabel(obj : TTurtleComplex) : TFhirNutritionIntakeIngredientLabel; overload; 
    procedure ParseNutritionIntakeIngredientLabelProperties(obj : TTurtleComplex; value : TFhirNutritionIntakeIngredientLabel); overload; 
    function ParseNutritionIntakePerformer(obj : TTurtleComplex) : TFhirNutritionIntakePerformer; overload; 
    procedure ParseNutritionIntakePerformerProperties(obj : TTurtleComplex; value : TFhirNutritionIntakePerformer); overload; 
    function ParseNutritionIntake(obj : TTurtleComplex) : TFhirNutritionIntake; overload; 
    procedure ParseNutritionIntakeProperties(obj : TTurtleComplex; value : TFhirNutritionIntake); overload; 
{$ENDIF FHIR_NUTRITIONINTAKE}
{$IFDEF FHIR_NUTRITIONORDER}
    function ParseNutritionOrderOralDiet(obj : TTurtleComplex) : TFhirNutritionOrderOralDiet; overload; 
    procedure ParseNutritionOrderOralDietProperties(obj : TTurtleComplex; value : TFhirNutritionOrderOralDiet); overload; 
    function ParseNutritionOrderOralDietSchedule(obj : TTurtleComplex) : TFhirNutritionOrderOralDietSchedule; overload; 
    procedure ParseNutritionOrderOralDietScheduleProperties(obj : TTurtleComplex; value : TFhirNutritionOrderOralDietSchedule); overload; 
    function ParseNutritionOrderOralDietNutrient(obj : TTurtleComplex) : TFhirNutritionOrderOralDietNutrient; overload; 
    procedure ParseNutritionOrderOralDietNutrientProperties(obj : TTurtleComplex; value : TFhirNutritionOrderOralDietNutrient); overload; 
    function ParseNutritionOrderOralDietTexture(obj : TTurtleComplex) : TFhirNutritionOrderOralDietTexture; overload; 
    procedure ParseNutritionOrderOralDietTextureProperties(obj : TTurtleComplex; value : TFhirNutritionOrderOralDietTexture); overload; 
    function ParseNutritionOrderSupplement(obj : TTurtleComplex) : TFhirNutritionOrderSupplement; overload; 
    procedure ParseNutritionOrderSupplementProperties(obj : TTurtleComplex; value : TFhirNutritionOrderSupplement); overload; 
    function ParseNutritionOrderSupplementSchedule(obj : TTurtleComplex) : TFhirNutritionOrderSupplementSchedule; overload; 
    procedure ParseNutritionOrderSupplementScheduleProperties(obj : TTurtleComplex; value : TFhirNutritionOrderSupplementSchedule); overload; 
    function ParseNutritionOrderEnteralFormula(obj : TTurtleComplex) : TFhirNutritionOrderEnteralFormula; overload; 
    procedure ParseNutritionOrderEnteralFormulaProperties(obj : TTurtleComplex; value : TFhirNutritionOrderEnteralFormula); overload; 
    function ParseNutritionOrderEnteralFormulaAdditive(obj : TTurtleComplex) : TFhirNutritionOrderEnteralFormulaAdditive; overload; 
    procedure ParseNutritionOrderEnteralFormulaAdditiveProperties(obj : TTurtleComplex; value : TFhirNutritionOrderEnteralFormulaAdditive); overload; 
    function ParseNutritionOrderEnteralFormulaAdministration(obj : TTurtleComplex) : TFhirNutritionOrderEnteralFormulaAdministration; overload; 
    procedure ParseNutritionOrderEnteralFormulaAdministrationProperties(obj : TTurtleComplex; value : TFhirNutritionOrderEnteralFormulaAdministration); overload; 
    function ParseNutritionOrderEnteralFormulaAdministrationSchedule(obj : TTurtleComplex) : TFhirNutritionOrderEnteralFormulaAdministrationSchedule; overload; 
    procedure ParseNutritionOrderEnteralFormulaAdministrationScheduleProperties(obj : TTurtleComplex; value : TFhirNutritionOrderEnteralFormulaAdministrationSchedule); overload; 
    function ParseNutritionOrder(obj : TTurtleComplex) : TFhirNutritionOrder; overload; 
    procedure ParseNutritionOrderProperties(obj : TTurtleComplex; value : TFhirNutritionOrder); overload; 
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_NUTRITIONPRODUCT}
    function ParseNutritionProductNutrient(obj : TTurtleComplex) : TFhirNutritionProductNutrient; overload; 
    procedure ParseNutritionProductNutrientProperties(obj : TTurtleComplex; value : TFhirNutritionProductNutrient); overload; 
    function ParseNutritionProductIngredient(obj : TTurtleComplex) : TFhirNutritionProductIngredient; overload; 
    procedure ParseNutritionProductIngredientProperties(obj : TTurtleComplex; value : TFhirNutritionProductIngredient); overload; 
    function ParseNutritionProductCharacteristic(obj : TTurtleComplex) : TFhirNutritionProductCharacteristic; overload; 
    procedure ParseNutritionProductCharacteristicProperties(obj : TTurtleComplex; value : TFhirNutritionProductCharacteristic); overload; 
    function ParseNutritionProductInstance(obj : TTurtleComplex) : TFhirNutritionProductInstance; overload; 
    procedure ParseNutritionProductInstanceProperties(obj : TTurtleComplex; value : TFhirNutritionProductInstance); overload; 
    function ParseNutritionProduct(obj : TTurtleComplex) : TFhirNutritionProduct; overload; 
    procedure ParseNutritionProductProperties(obj : TTurtleComplex; value : TFhirNutritionProduct); overload; 
{$ENDIF FHIR_NUTRITIONPRODUCT}
{$IFDEF FHIR_OBSERVATION}
    function ParseObservationTriggeredBy(obj : TTurtleComplex) : TFhirObservationTriggeredBy; overload; 
    procedure ParseObservationTriggeredByProperties(obj : TTurtleComplex; value : TFhirObservationTriggeredBy); overload; 
    function ParseObservationReferenceRange(obj : TTurtleComplex) : TFhirObservationReferenceRange; overload; 
    procedure ParseObservationReferenceRangeProperties(obj : TTurtleComplex; value : TFhirObservationReferenceRange); overload; 
    function ParseObservationComponent(obj : TTurtleComplex) : TFhirObservationComponent; overload; 
    procedure ParseObservationComponentProperties(obj : TTurtleComplex; value : TFhirObservationComponent); overload; 
    function ParseObservation(obj : TTurtleComplex) : TFhirObservation; overload; 
    procedure ParseObservationProperties(obj : TTurtleComplex; value : TFhirObservation); overload; 
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
    function ParseObservationDefinitionQuantitativeDetails(obj : TTurtleComplex) : TFhirObservationDefinitionQuantitativeDetails; overload; 
    procedure ParseObservationDefinitionQuantitativeDetailsProperties(obj : TTurtleComplex; value : TFhirObservationDefinitionQuantitativeDetails); overload; 
    function ParseObservationDefinitionQualifiedValue(obj : TTurtleComplex) : TFhirObservationDefinitionQualifiedValue; overload; 
    procedure ParseObservationDefinitionQualifiedValueProperties(obj : TTurtleComplex; value : TFhirObservationDefinitionQualifiedValue); overload; 
    function ParseObservationDefinitionComponent(obj : TTurtleComplex) : TFhirObservationDefinitionComponent; overload; 
    procedure ParseObservationDefinitionComponentProperties(obj : TTurtleComplex; value : TFhirObservationDefinitionComponent); overload; 
    function ParseObservationDefinition(obj : TTurtleComplex) : TFhirObservationDefinition; overload; 
    procedure ParseObservationDefinitionProperties(obj : TTurtleComplex; value : TFhirObservationDefinition); overload; 
{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
    function ParseOperationDefinitionParameter(obj : TTurtleComplex) : TFhirOperationDefinitionParameter; overload; 
    procedure ParseOperationDefinitionParameterProperties(obj : TTurtleComplex; value : TFhirOperationDefinitionParameter); overload; 
    function ParseOperationDefinitionParameterBinding(obj : TTurtleComplex) : TFhirOperationDefinitionParameterBinding; overload; 
    procedure ParseOperationDefinitionParameterBindingProperties(obj : TTurtleComplex; value : TFhirOperationDefinitionParameterBinding); overload; 
    function ParseOperationDefinitionParameterReferencedFrom(obj : TTurtleComplex) : TFhirOperationDefinitionParameterReferencedFrom; overload; 
    procedure ParseOperationDefinitionParameterReferencedFromProperties(obj : TTurtleComplex; value : TFhirOperationDefinitionParameterReferencedFrom); overload; 
    function ParseOperationDefinitionOverload(obj : TTurtleComplex) : TFhirOperationDefinitionOverload; overload; 
    procedure ParseOperationDefinitionOverloadProperties(obj : TTurtleComplex; value : TFhirOperationDefinitionOverload); overload; 
    function ParseOperationDefinition(obj : TTurtleComplex) : TFhirOperationDefinition; overload; 
    procedure ParseOperationDefinitionProperties(obj : TTurtleComplex; value : TFhirOperationDefinition); overload; 
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
    function ParseOperationOutcomeIssue(obj : TTurtleComplex) : TFhirOperationOutcomeIssue; overload; 
    procedure ParseOperationOutcomeIssueProperties(obj : TTurtleComplex; value : TFhirOperationOutcomeIssue); overload; 
    function ParseOperationOutcome(obj : TTurtleComplex) : TFhirOperationOutcome; overload; 
    procedure ParseOperationOutcomeProperties(obj : TTurtleComplex; value : TFhirOperationOutcome); overload; 
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
    function ParseOrganizationQualification(obj : TTurtleComplex) : TFhirOrganizationQualification; overload; 
    procedure ParseOrganizationQualificationProperties(obj : TTurtleComplex; value : TFhirOrganizationQualification); overload; 
    function ParseOrganization(obj : TTurtleComplex) : TFhirOrganization; overload; 
    procedure ParseOrganizationProperties(obj : TTurtleComplex; value : TFhirOrganization); overload; 
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
    function ParseOrganizationAffiliation(obj : TTurtleComplex) : TFhirOrganizationAffiliation; overload; 
    procedure ParseOrganizationAffiliationProperties(obj : TTurtleComplex; value : TFhirOrganizationAffiliation); overload; 
{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PACKAGEDPRODUCTDEFINITION}
    function ParsePackagedProductDefinitionLegalStatusOfSupply(obj : TTurtleComplex) : TFhirPackagedProductDefinitionLegalStatusOfSupply; overload; 
    procedure ParsePackagedProductDefinitionLegalStatusOfSupplyProperties(obj : TTurtleComplex; value : TFhirPackagedProductDefinitionLegalStatusOfSupply); overload; 
    function ParsePackagedProductDefinitionPackaging(obj : TTurtleComplex) : TFhirPackagedProductDefinitionPackaging; overload; 
    procedure ParsePackagedProductDefinitionPackagingProperties(obj : TTurtleComplex; value : TFhirPackagedProductDefinitionPackaging); overload; 
    function ParsePackagedProductDefinitionPackagingProperty(obj : TTurtleComplex) : TFhirPackagedProductDefinitionPackagingProperty; overload; 
    procedure ParsePackagedProductDefinitionPackagingPropertyProperties(obj : TTurtleComplex; value : TFhirPackagedProductDefinitionPackagingProperty); overload; 
    function ParsePackagedProductDefinitionPackagingContainedItem(obj : TTurtleComplex) : TFhirPackagedProductDefinitionPackagingContainedItem; overload; 
    procedure ParsePackagedProductDefinitionPackagingContainedItemProperties(obj : TTurtleComplex; value : TFhirPackagedProductDefinitionPackagingContainedItem); overload; 
    function ParsePackagedProductDefinition(obj : TTurtleComplex) : TFhirPackagedProductDefinition; overload; 
    procedure ParsePackagedProductDefinitionProperties(obj : TTurtleComplex; value : TFhirPackagedProductDefinition); overload; 
{$ENDIF FHIR_PACKAGEDPRODUCTDEFINITION}
{$IFDEF FHIR_PARAMETERS}
    function ParseParametersParameter(obj : TTurtleComplex) : TFhirParametersParameter; overload; 
    procedure ParseParametersParameterProperties(obj : TTurtleComplex; value : TFhirParametersParameter); overload; 
    function ParseParameters(obj : TTurtleComplex) : TFhirParameters; overload; 
    procedure ParseParametersProperties(obj : TTurtleComplex; value : TFhirParameters); overload; 
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_PATIENT}
    function ParsePatientContact(obj : TTurtleComplex) : TFhirPatientContact; overload; 
    procedure ParsePatientContactProperties(obj : TTurtleComplex; value : TFhirPatientContact); overload; 
    function ParsePatientCommunication(obj : TTurtleComplex) : TFhirPatientCommunication; overload; 
    procedure ParsePatientCommunicationProperties(obj : TTurtleComplex; value : TFhirPatientCommunication); overload; 
    function ParsePatientLink(obj : TTurtleComplex) : TFhirPatientLink; overload; 
    procedure ParsePatientLinkProperties(obj : TTurtleComplex; value : TFhirPatientLink); overload; 
    function ParsePatient(obj : TTurtleComplex) : TFhirPatient; overload; 
    procedure ParsePatientProperties(obj : TTurtleComplex; value : TFhirPatient); overload; 
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
    function ParsePaymentNotice(obj : TTurtleComplex) : TFhirPaymentNotice; overload; 
    procedure ParsePaymentNoticeProperties(obj : TTurtleComplex; value : TFhirPaymentNotice); overload; 
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
    function ParsePaymentReconciliationAllocation(obj : TTurtleComplex) : TFhirPaymentReconciliationAllocation; overload; 
    procedure ParsePaymentReconciliationAllocationProperties(obj : TTurtleComplex; value : TFhirPaymentReconciliationAllocation); overload; 
    function ParsePaymentReconciliationProcessNote(obj : TTurtleComplex) : TFhirPaymentReconciliationProcessNote; overload; 
    procedure ParsePaymentReconciliationProcessNoteProperties(obj : TTurtleComplex; value : TFhirPaymentReconciliationProcessNote); overload; 
    function ParsePaymentReconciliation(obj : TTurtleComplex) : TFhirPaymentReconciliation; overload; 
    procedure ParsePaymentReconciliationProperties(obj : TTurtleComplex; value : TFhirPaymentReconciliation); overload; 
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERMISSION}
    function ParsePermissionJustification(obj : TTurtleComplex) : TFhirPermissionJustification; overload; 
    procedure ParsePermissionJustificationProperties(obj : TTurtleComplex; value : TFhirPermissionJustification); overload; 
    function ParsePermissionRule(obj : TTurtleComplex) : TFhirPermissionRule; overload; 
    procedure ParsePermissionRuleProperties(obj : TTurtleComplex; value : TFhirPermissionRule); overload; 
    function ParsePermissionRuleData(obj : TTurtleComplex) : TFhirPermissionRuleData; overload; 
    procedure ParsePermissionRuleDataProperties(obj : TTurtleComplex; value : TFhirPermissionRuleData); overload; 
    function ParsePermissionRuleDataResource(obj : TTurtleComplex) : TFhirPermissionRuleDataResource; overload; 
    procedure ParsePermissionRuleDataResourceProperties(obj : TTurtleComplex; value : TFhirPermissionRuleDataResource); overload; 
    function ParsePermissionRuleActivity(obj : TTurtleComplex) : TFhirPermissionRuleActivity; overload; 
    procedure ParsePermissionRuleActivityProperties(obj : TTurtleComplex; value : TFhirPermissionRuleActivity); overload; 
    function ParsePermission(obj : TTurtleComplex) : TFhirPermission; overload; 
    procedure ParsePermissionProperties(obj : TTurtleComplex; value : TFhirPermission); overload; 
{$ENDIF FHIR_PERMISSION}
{$IFDEF FHIR_PERSON}
    function ParsePersonCommunication(obj : TTurtleComplex) : TFhirPersonCommunication; overload; 
    procedure ParsePersonCommunicationProperties(obj : TTurtleComplex; value : TFhirPersonCommunication); overload; 
    function ParsePersonLink(obj : TTurtleComplex) : TFhirPersonLink; overload; 
    procedure ParsePersonLinkProperties(obj : TTurtleComplex; value : TFhirPersonLink); overload; 
    function ParsePerson(obj : TTurtleComplex) : TFhirPerson; overload; 
    procedure ParsePersonProperties(obj : TTurtleComplex; value : TFhirPerson); overload; 
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
    function ParsePlanDefinitionGoal(obj : TTurtleComplex) : TFhirPlanDefinitionGoal; overload; 
    procedure ParsePlanDefinitionGoalProperties(obj : TTurtleComplex; value : TFhirPlanDefinitionGoal); overload; 
    function ParsePlanDefinitionGoalTarget(obj : TTurtleComplex) : TFhirPlanDefinitionGoalTarget; overload; 
    procedure ParsePlanDefinitionGoalTargetProperties(obj : TTurtleComplex; value : TFhirPlanDefinitionGoalTarget); overload; 
    function ParsePlanDefinitionActor(obj : TTurtleComplex) : TFhirPlanDefinitionActor; overload; 
    procedure ParsePlanDefinitionActorProperties(obj : TTurtleComplex; value : TFhirPlanDefinitionActor); overload; 
    function ParsePlanDefinitionActorOption(obj : TTurtleComplex) : TFhirPlanDefinitionActorOption; overload; 
    procedure ParsePlanDefinitionActorOptionProperties(obj : TTurtleComplex; value : TFhirPlanDefinitionActorOption); overload; 
    function ParsePlanDefinitionAction(obj : TTurtleComplex) : TFhirPlanDefinitionAction; overload; 
    procedure ParsePlanDefinitionActionProperties(obj : TTurtleComplex; value : TFhirPlanDefinitionAction); overload; 
    function ParsePlanDefinitionActionCondition(obj : TTurtleComplex) : TFhirPlanDefinitionActionCondition; overload; 
    procedure ParsePlanDefinitionActionConditionProperties(obj : TTurtleComplex; value : TFhirPlanDefinitionActionCondition); overload; 
    function ParsePlanDefinitionActionInput(obj : TTurtleComplex) : TFhirPlanDefinitionActionInput; overload; 
    procedure ParsePlanDefinitionActionInputProperties(obj : TTurtleComplex; value : TFhirPlanDefinitionActionInput); overload; 
    function ParsePlanDefinitionActionOutput(obj : TTurtleComplex) : TFhirPlanDefinitionActionOutput; overload; 
    procedure ParsePlanDefinitionActionOutputProperties(obj : TTurtleComplex; value : TFhirPlanDefinitionActionOutput); overload; 
    function ParsePlanDefinitionActionRelatedAction(obj : TTurtleComplex) : TFhirPlanDefinitionActionRelatedAction; overload; 
    procedure ParsePlanDefinitionActionRelatedActionProperties(obj : TTurtleComplex; value : TFhirPlanDefinitionActionRelatedAction); overload; 
    function ParsePlanDefinitionActionParticipant(obj : TTurtleComplex) : TFhirPlanDefinitionActionParticipant; overload; 
    procedure ParsePlanDefinitionActionParticipantProperties(obj : TTurtleComplex; value : TFhirPlanDefinitionActionParticipant); overload; 
    function ParsePlanDefinitionActionDynamicValue(obj : TTurtleComplex) : TFhirPlanDefinitionActionDynamicValue; overload; 
    procedure ParsePlanDefinitionActionDynamicValueProperties(obj : TTurtleComplex; value : TFhirPlanDefinitionActionDynamicValue); overload; 
    function ParsePlanDefinition(obj : TTurtleComplex) : TFhirPlanDefinition; overload; 
    procedure ParsePlanDefinitionProperties(obj : TTurtleComplex; value : TFhirPlanDefinition); overload; 
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
    function ParsePractitionerQualification(obj : TTurtleComplex) : TFhirPractitionerQualification; overload; 
    procedure ParsePractitionerQualificationProperties(obj : TTurtleComplex; value : TFhirPractitionerQualification); overload; 
    function ParsePractitioner(obj : TTurtleComplex) : TFhirPractitioner; overload; 
    procedure ParsePractitionerProperties(obj : TTurtleComplex; value : TFhirPractitioner); overload; 
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
    function ParsePractitionerRole(obj : TTurtleComplex) : TFhirPractitionerRole; overload; 
    procedure ParsePractitionerRoleProperties(obj : TTurtleComplex; value : TFhirPractitionerRole); overload; 
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
    function ParseProcedurePerformer(obj : TTurtleComplex) : TFhirProcedurePerformer; overload; 
    procedure ParseProcedurePerformerProperties(obj : TTurtleComplex; value : TFhirProcedurePerformer); overload; 
    function ParseProcedureFocalDevice(obj : TTurtleComplex) : TFhirProcedureFocalDevice; overload; 
    procedure ParseProcedureFocalDeviceProperties(obj : TTurtleComplex; value : TFhirProcedureFocalDevice); overload; 
    function ParseProcedure(obj : TTurtleComplex) : TFhirProcedure; overload; 
    procedure ParseProcedureProperties(obj : TTurtleComplex; value : TFhirProcedure); overload; 
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROVENANCE}
    function ParseProvenanceAgent(obj : TTurtleComplex) : TFhirProvenanceAgent; overload; 
    procedure ParseProvenanceAgentProperties(obj : TTurtleComplex; value : TFhirProvenanceAgent); overload; 
    function ParseProvenanceEntity(obj : TTurtleComplex) : TFhirProvenanceEntity; overload; 
    procedure ParseProvenanceEntityProperties(obj : TTurtleComplex; value : TFhirProvenanceEntity); overload; 
    function ParseProvenance(obj : TTurtleComplex) : TFhirProvenance; overload; 
    procedure ParseProvenanceProperties(obj : TTurtleComplex; value : TFhirProvenance); overload; 
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
    function ParseQuestionnaireItem(obj : TTurtleComplex) : TFhirQuestionnaireItem; overload; 
    procedure ParseQuestionnaireItemProperties(obj : TTurtleComplex; value : TFhirQuestionnaireItem); overload; 
    function ParseQuestionnaireItemEnableWhen(obj : TTurtleComplex) : TFhirQuestionnaireItemEnableWhen; overload; 
    procedure ParseQuestionnaireItemEnableWhenProperties(obj : TTurtleComplex; value : TFhirQuestionnaireItemEnableWhen); overload; 
    function ParseQuestionnaireItemAnswerOption(obj : TTurtleComplex) : TFhirQuestionnaireItemAnswerOption; overload; 
    procedure ParseQuestionnaireItemAnswerOptionProperties(obj : TTurtleComplex; value : TFhirQuestionnaireItemAnswerOption); overload; 
    function ParseQuestionnaireItemInitial(obj : TTurtleComplex) : TFhirQuestionnaireItemInitial; overload; 
    procedure ParseQuestionnaireItemInitialProperties(obj : TTurtleComplex; value : TFhirQuestionnaireItemInitial); overload; 
    function ParseQuestionnaire(obj : TTurtleComplex) : TFhirQuestionnaire; overload; 
    procedure ParseQuestionnaireProperties(obj : TTurtleComplex; value : TFhirQuestionnaire); overload; 
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
    function ParseQuestionnaireResponseItem(obj : TTurtleComplex) : TFhirQuestionnaireResponseItem; overload; 
    procedure ParseQuestionnaireResponseItemProperties(obj : TTurtleComplex; value : TFhirQuestionnaireResponseItem); overload; 
    function ParseQuestionnaireResponseItemAnswer(obj : TTurtleComplex) : TFhirQuestionnaireResponseItemAnswer; overload; 
    procedure ParseQuestionnaireResponseItemAnswerProperties(obj : TTurtleComplex; value : TFhirQuestionnaireResponseItemAnswer); overload; 
    function ParseQuestionnaireResponse(obj : TTurtleComplex) : TFhirQuestionnaireResponse; overload; 
    procedure ParseQuestionnaireResponseProperties(obj : TTurtleComplex; value : TFhirQuestionnaireResponse); overload; 
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REGULATEDAUTHORIZATION}
    function ParseRegulatedAuthorizationCase(obj : TTurtleComplex) : TFhirRegulatedAuthorizationCase; overload; 
    procedure ParseRegulatedAuthorizationCaseProperties(obj : TTurtleComplex; value : TFhirRegulatedAuthorizationCase); overload; 
    function ParseRegulatedAuthorization(obj : TTurtleComplex) : TFhirRegulatedAuthorization; overload; 
    procedure ParseRegulatedAuthorizationProperties(obj : TTurtleComplex; value : TFhirRegulatedAuthorization); overload; 
{$ENDIF FHIR_REGULATEDAUTHORIZATION}
{$IFDEF FHIR_RELATEDPERSON}
    function ParseRelatedPersonCommunication(obj : TTurtleComplex) : TFhirRelatedPersonCommunication; overload; 
    procedure ParseRelatedPersonCommunicationProperties(obj : TTurtleComplex; value : TFhirRelatedPersonCommunication); overload; 
    function ParseRelatedPerson(obj : TTurtleComplex) : TFhirRelatedPerson; overload; 
    procedure ParseRelatedPersonProperties(obj : TTurtleComplex; value : TFhirRelatedPerson); overload; 
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
    function ParseRequestGroupAction(obj : TTurtleComplex) : TFhirRequestGroupAction; overload; 
    procedure ParseRequestGroupActionProperties(obj : TTurtleComplex; value : TFhirRequestGroupAction); overload; 
    function ParseRequestGroupActionCondition(obj : TTurtleComplex) : TFhirRequestGroupActionCondition; overload; 
    procedure ParseRequestGroupActionConditionProperties(obj : TTurtleComplex; value : TFhirRequestGroupActionCondition); overload; 
    function ParseRequestGroupActionRelatedAction(obj : TTurtleComplex) : TFhirRequestGroupActionRelatedAction; overload; 
    procedure ParseRequestGroupActionRelatedActionProperties(obj : TTurtleComplex; value : TFhirRequestGroupActionRelatedAction); overload; 
    function ParseRequestGroupActionParticipant(obj : TTurtleComplex) : TFhirRequestGroupActionParticipant; overload; 
    procedure ParseRequestGroupActionParticipantProperties(obj : TTurtleComplex; value : TFhirRequestGroupActionParticipant); overload; 
    function ParseRequestGroup(obj : TTurtleComplex) : TFhirRequestGroup; overload; 
    procedure ParseRequestGroupProperties(obj : TTurtleComplex; value : TFhirRequestGroup); overload; 
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_REQUESTORCHESTRATION}
    function ParseRequestOrchestrationAction(obj : TTurtleComplex) : TFhirRequestOrchestrationAction; overload; 
    procedure ParseRequestOrchestrationActionProperties(obj : TTurtleComplex; value : TFhirRequestOrchestrationAction); overload; 
    function ParseRequestOrchestrationActionCondition(obj : TTurtleComplex) : TFhirRequestOrchestrationActionCondition; overload; 
    procedure ParseRequestOrchestrationActionConditionProperties(obj : TTurtleComplex; value : TFhirRequestOrchestrationActionCondition); overload; 
    function ParseRequestOrchestrationActionInput(obj : TTurtleComplex) : TFhirRequestOrchestrationActionInput; overload; 
    procedure ParseRequestOrchestrationActionInputProperties(obj : TTurtleComplex; value : TFhirRequestOrchestrationActionInput); overload; 
    function ParseRequestOrchestrationActionOutput(obj : TTurtleComplex) : TFhirRequestOrchestrationActionOutput; overload; 
    procedure ParseRequestOrchestrationActionOutputProperties(obj : TTurtleComplex; value : TFhirRequestOrchestrationActionOutput); overload; 
    function ParseRequestOrchestrationActionRelatedAction(obj : TTurtleComplex) : TFhirRequestOrchestrationActionRelatedAction; overload; 
    procedure ParseRequestOrchestrationActionRelatedActionProperties(obj : TTurtleComplex; value : TFhirRequestOrchestrationActionRelatedAction); overload; 
    function ParseRequestOrchestrationActionParticipant(obj : TTurtleComplex) : TFhirRequestOrchestrationActionParticipant; overload; 
    procedure ParseRequestOrchestrationActionParticipantProperties(obj : TTurtleComplex; value : TFhirRequestOrchestrationActionParticipant); overload; 
    function ParseRequestOrchestrationActionDynamicValue(obj : TTurtleComplex) : TFhirRequestOrchestrationActionDynamicValue; overload; 
    procedure ParseRequestOrchestrationActionDynamicValueProperties(obj : TTurtleComplex; value : TFhirRequestOrchestrationActionDynamicValue); overload; 
    function ParseRequestOrchestration(obj : TTurtleComplex) : TFhirRequestOrchestration; overload; 
    procedure ParseRequestOrchestrationProperties(obj : TTurtleComplex; value : TFhirRequestOrchestration); overload; 
{$ENDIF FHIR_REQUESTORCHESTRATION}
{$IFDEF FHIR_REQUIREMENTS}
    function ParseRequirementsStatement(obj : TTurtleComplex) : TFhirRequirementsStatement; overload; 
    procedure ParseRequirementsStatementProperties(obj : TTurtleComplex; value : TFhirRequirementsStatement); overload; 
    function ParseRequirements(obj : TTurtleComplex) : TFhirRequirements; overload; 
    procedure ParseRequirementsProperties(obj : TTurtleComplex; value : TFhirRequirements); overload; 
{$ENDIF FHIR_REQUIREMENTS}
{$IFDEF FHIR_RESEARCHSTUDY}
    function ParseResearchStudyLabel(obj : TTurtleComplex) : TFhirResearchStudyLabel; overload; 
    procedure ParseResearchStudyLabelProperties(obj : TTurtleComplex; value : TFhirResearchStudyLabel); overload; 
    function ParseResearchStudyFocus(obj : TTurtleComplex) : TFhirResearchStudyFocus; overload; 
    procedure ParseResearchStudyFocusProperties(obj : TTurtleComplex; value : TFhirResearchStudyFocus); overload; 
    function ParseResearchStudyAssociatedParty(obj : TTurtleComplex) : TFhirResearchStudyAssociatedParty; overload; 
    procedure ParseResearchStudyAssociatedPartyProperties(obj : TTurtleComplex; value : TFhirResearchStudyAssociatedParty); overload; 
    function ParseResearchStudyProgressStatus(obj : TTurtleComplex) : TFhirResearchStudyProgressStatus; overload; 
    procedure ParseResearchStudyProgressStatusProperties(obj : TTurtleComplex; value : TFhirResearchStudyProgressStatus); overload; 
    function ParseResearchStudyRecruitment(obj : TTurtleComplex) : TFhirResearchStudyRecruitment; overload; 
    procedure ParseResearchStudyRecruitmentProperties(obj : TTurtleComplex; value : TFhirResearchStudyRecruitment); overload; 
    function ParseResearchStudyComparisonGroup(obj : TTurtleComplex) : TFhirResearchStudyComparisonGroup; overload; 
    procedure ParseResearchStudyComparisonGroupProperties(obj : TTurtleComplex; value : TFhirResearchStudyComparisonGroup); overload; 
    function ParseResearchStudyObjective(obj : TTurtleComplex) : TFhirResearchStudyObjective; overload; 
    procedure ParseResearchStudyObjectiveProperties(obj : TTurtleComplex; value : TFhirResearchStudyObjective); overload; 
    function ParseResearchStudyOutcomeMeasure(obj : TTurtleComplex) : TFhirResearchStudyOutcomeMeasure; overload; 
    procedure ParseResearchStudyOutcomeMeasureProperties(obj : TTurtleComplex; value : TFhirResearchStudyOutcomeMeasure); overload; 
    function ParseResearchStudyWebLocation(obj : TTurtleComplex) : TFhirResearchStudyWebLocation; overload; 
    procedure ParseResearchStudyWebLocationProperties(obj : TTurtleComplex; value : TFhirResearchStudyWebLocation); overload; 
    function ParseResearchStudy(obj : TTurtleComplex) : TFhirResearchStudy; overload; 
    procedure ParseResearchStudyProperties(obj : TTurtleComplex; value : TFhirResearchStudy); overload; 
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
    function ParseResearchSubjectProgress(obj : TTurtleComplex) : TFhirResearchSubjectProgress; overload; 
    procedure ParseResearchSubjectProgressProperties(obj : TTurtleComplex; value : TFhirResearchSubjectProgress); overload; 
    function ParseResearchSubject(obj : TTurtleComplex) : TFhirResearchSubject; overload; 
    procedure ParseResearchSubjectProperties(obj : TTurtleComplex; value : TFhirResearchSubject); overload; 
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
    function ParseRiskAssessmentPrediction(obj : TTurtleComplex) : TFhirRiskAssessmentPrediction; overload; 
    procedure ParseRiskAssessmentPredictionProperties(obj : TTurtleComplex; value : TFhirRiskAssessmentPrediction); overload; 
    function ParseRiskAssessment(obj : TTurtleComplex) : TFhirRiskAssessment; overload; 
    procedure ParseRiskAssessmentProperties(obj : TTurtleComplex; value : TFhirRiskAssessment); overload; 
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
    function ParseSchedule(obj : TTurtleComplex) : TFhirSchedule; overload; 
    procedure ParseScheduleProperties(obj : TTurtleComplex; value : TFhirSchedule); overload; 
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
    function ParseSearchParameterComponent(obj : TTurtleComplex) : TFhirSearchParameterComponent; overload; 
    procedure ParseSearchParameterComponentProperties(obj : TTurtleComplex; value : TFhirSearchParameterComponent); overload; 
    function ParseSearchParameter(obj : TTurtleComplex) : TFhirSearchParameter; overload; 
    procedure ParseSearchParameterProperties(obj : TTurtleComplex; value : TFhirSearchParameter); overload; 
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEREQUEST}
    function ParseServiceRequest(obj : TTurtleComplex) : TFhirServiceRequest; overload; 
    procedure ParseServiceRequestProperties(obj : TTurtleComplex; value : TFhirServiceRequest); overload; 
{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SLOT}
    function ParseSlot(obj : TTurtleComplex) : TFhirSlot; overload; 
    procedure ParseSlotProperties(obj : TTurtleComplex; value : TFhirSlot); overload; 
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
    function ParseSpecimenFeature(obj : TTurtleComplex) : TFhirSpecimenFeature; overload; 
    procedure ParseSpecimenFeatureProperties(obj : TTurtleComplex; value : TFhirSpecimenFeature); overload; 
    function ParseSpecimenCollection(obj : TTurtleComplex) : TFhirSpecimenCollection; overload; 
    procedure ParseSpecimenCollectionProperties(obj : TTurtleComplex; value : TFhirSpecimenCollection); overload; 
    function ParseSpecimenProcessing(obj : TTurtleComplex) : TFhirSpecimenProcessing; overload; 
    procedure ParseSpecimenProcessingProperties(obj : TTurtleComplex; value : TFhirSpecimenProcessing); overload; 
    function ParseSpecimenContainer(obj : TTurtleComplex) : TFhirSpecimenContainer; overload; 
    procedure ParseSpecimenContainerProperties(obj : TTurtleComplex; value : TFhirSpecimenContainer); overload; 
    function ParseSpecimen(obj : TTurtleComplex) : TFhirSpecimen; overload; 
    procedure ParseSpecimenProperties(obj : TTurtleComplex; value : TFhirSpecimen); overload; 
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SPECIMENDEFINITION}
    function ParseSpecimenDefinitionTypeTested(obj : TTurtleComplex) : TFhirSpecimenDefinitionTypeTested; overload; 
    procedure ParseSpecimenDefinitionTypeTestedProperties(obj : TTurtleComplex; value : TFhirSpecimenDefinitionTypeTested); overload; 
    function ParseSpecimenDefinitionTypeTestedContainer(obj : TTurtleComplex) : TFhirSpecimenDefinitionTypeTestedContainer; overload; 
    procedure ParseSpecimenDefinitionTypeTestedContainerProperties(obj : TTurtleComplex; value : TFhirSpecimenDefinitionTypeTestedContainer); overload; 
    function ParseSpecimenDefinitionTypeTestedContainerAdditive(obj : TTurtleComplex) : TFhirSpecimenDefinitionTypeTestedContainerAdditive; overload; 
    procedure ParseSpecimenDefinitionTypeTestedContainerAdditiveProperties(obj : TTurtleComplex; value : TFhirSpecimenDefinitionTypeTestedContainerAdditive); overload; 
    function ParseSpecimenDefinitionTypeTestedHandling(obj : TTurtleComplex) : TFhirSpecimenDefinitionTypeTestedHandling; overload; 
    procedure ParseSpecimenDefinitionTypeTestedHandlingProperties(obj : TTurtleComplex; value : TFhirSpecimenDefinitionTypeTestedHandling); overload; 
    function ParseSpecimenDefinition(obj : TTurtleComplex) : TFhirSpecimenDefinition; overload; 
    procedure ParseSpecimenDefinitionProperties(obj : TTurtleComplex; value : TFhirSpecimenDefinition); overload; 
{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
    function ParseStructureDefinitionMapping(obj : TTurtleComplex) : TFhirStructureDefinitionMapping; overload; 
    procedure ParseStructureDefinitionMappingProperties(obj : TTurtleComplex; value : TFhirStructureDefinitionMapping); overload; 
    function ParseStructureDefinitionContext(obj : TTurtleComplex) : TFhirStructureDefinitionContext; overload; 
    procedure ParseStructureDefinitionContextProperties(obj : TTurtleComplex; value : TFhirStructureDefinitionContext); overload; 
    function ParseStructureDefinitionSnapshot(obj : TTurtleComplex) : TFhirStructureDefinitionSnapshot; overload; 
    procedure ParseStructureDefinitionSnapshotProperties(obj : TTurtleComplex; value : TFhirStructureDefinitionSnapshot); overload; 
    function ParseStructureDefinitionDifferential(obj : TTurtleComplex) : TFhirStructureDefinitionDifferential; overload; 
    procedure ParseStructureDefinitionDifferentialProperties(obj : TTurtleComplex; value : TFhirStructureDefinitionDifferential); overload; 
    function ParseStructureDefinition(obj : TTurtleComplex) : TFhirStructureDefinition; overload; 
    procedure ParseStructureDefinitionProperties(obj : TTurtleComplex; value : TFhirStructureDefinition); overload; 
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
    function ParseStructureMapStructure(obj : TTurtleComplex) : TFhirStructureMapStructure; overload; 
    procedure ParseStructureMapStructureProperties(obj : TTurtleComplex; value : TFhirStructureMapStructure); overload; 
    function ParseStructureMapGroup(obj : TTurtleComplex) : TFhirStructureMapGroup; overload; 
    procedure ParseStructureMapGroupProperties(obj : TTurtleComplex; value : TFhirStructureMapGroup); overload; 
    function ParseStructureMapGroupInput(obj : TTurtleComplex) : TFhirStructureMapGroupInput; overload; 
    procedure ParseStructureMapGroupInputProperties(obj : TTurtleComplex; value : TFhirStructureMapGroupInput); overload; 
    function ParseStructureMapGroupRule(obj : TTurtleComplex) : TFhirStructureMapGroupRule; overload; 
    procedure ParseStructureMapGroupRuleProperties(obj : TTurtleComplex; value : TFhirStructureMapGroupRule); overload; 
    function ParseStructureMapGroupRuleSource(obj : TTurtleComplex) : TFhirStructureMapGroupRuleSource; overload; 
    procedure ParseStructureMapGroupRuleSourceProperties(obj : TTurtleComplex; value : TFhirStructureMapGroupRuleSource); overload; 
    function ParseStructureMapGroupRuleTarget(obj : TTurtleComplex) : TFhirStructureMapGroupRuleTarget; overload; 
    procedure ParseStructureMapGroupRuleTargetProperties(obj : TTurtleComplex; value : TFhirStructureMapGroupRuleTarget); overload; 
    function ParseStructureMapGroupRuleTargetParameter(obj : TTurtleComplex) : TFhirStructureMapGroupRuleTargetParameter; overload; 
    procedure ParseStructureMapGroupRuleTargetParameterProperties(obj : TTurtleComplex; value : TFhirStructureMapGroupRuleTargetParameter); overload; 
    function ParseStructureMapGroupRuleDependent(obj : TTurtleComplex) : TFhirStructureMapGroupRuleDependent; overload; 
    procedure ParseStructureMapGroupRuleDependentProperties(obj : TTurtleComplex; value : TFhirStructureMapGroupRuleDependent); overload; 
    function ParseStructureMap(obj : TTurtleComplex) : TFhirStructureMap; overload; 
    procedure ParseStructureMapProperties(obj : TTurtleComplex; value : TFhirStructureMap); overload; 
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
    function ParseSubscriptionFilterBy(obj : TTurtleComplex) : TFhirSubscriptionFilterBy; overload; 
    procedure ParseSubscriptionFilterByProperties(obj : TTurtleComplex; value : TFhirSubscriptionFilterBy); overload; 
    function ParseSubscription(obj : TTurtleComplex) : TFhirSubscription; overload; 
    procedure ParseSubscriptionProperties(obj : TTurtleComplex; value : TFhirSubscription); overload; 
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSCRIPTIONSTATUS}
    function ParseSubscriptionStatusNotificationEvent(obj : TTurtleComplex) : TFhirSubscriptionStatusNotificationEvent; overload; 
    procedure ParseSubscriptionStatusNotificationEventProperties(obj : TTurtleComplex; value : TFhirSubscriptionStatusNotificationEvent); overload; 
    function ParseSubscriptionStatus(obj : TTurtleComplex) : TFhirSubscriptionStatus; overload; 
    procedure ParseSubscriptionStatusProperties(obj : TTurtleComplex; value : TFhirSubscriptionStatus); overload; 
{$ENDIF FHIR_SUBSCRIPTIONSTATUS}
{$IFDEF FHIR_SUBSCRIPTIONTOPIC}
    function ParseSubscriptionTopicResourceTrigger(obj : TTurtleComplex) : TFhirSubscriptionTopicResourceTrigger; overload; 
    procedure ParseSubscriptionTopicResourceTriggerProperties(obj : TTurtleComplex; value : TFhirSubscriptionTopicResourceTrigger); overload; 
    function ParseSubscriptionTopicResourceTriggerQueryCriteria(obj : TTurtleComplex) : TFhirSubscriptionTopicResourceTriggerQueryCriteria; overload; 
    procedure ParseSubscriptionTopicResourceTriggerQueryCriteriaProperties(obj : TTurtleComplex; value : TFhirSubscriptionTopicResourceTriggerQueryCriteria); overload; 
    function ParseSubscriptionTopicEventTrigger(obj : TTurtleComplex) : TFhirSubscriptionTopicEventTrigger; overload; 
    procedure ParseSubscriptionTopicEventTriggerProperties(obj : TTurtleComplex; value : TFhirSubscriptionTopicEventTrigger); overload; 
    function ParseSubscriptionTopicCanFilterBy(obj : TTurtleComplex) : TFhirSubscriptionTopicCanFilterBy; overload; 
    procedure ParseSubscriptionTopicCanFilterByProperties(obj : TTurtleComplex; value : TFhirSubscriptionTopicCanFilterBy); overload; 
    function ParseSubscriptionTopicNotificationShape(obj : TTurtleComplex) : TFhirSubscriptionTopicNotificationShape; overload; 
    procedure ParseSubscriptionTopicNotificationShapeProperties(obj : TTurtleComplex; value : TFhirSubscriptionTopicNotificationShape); overload; 
    function ParseSubscriptionTopic(obj : TTurtleComplex) : TFhirSubscriptionTopic; overload; 
    procedure ParseSubscriptionTopicProperties(obj : TTurtleComplex; value : TFhirSubscriptionTopic); overload; 
{$ENDIF FHIR_SUBSCRIPTIONTOPIC}
{$IFDEF FHIR_SUBSTANCE}
    function ParseSubstanceIngredient(obj : TTurtleComplex) : TFhirSubstanceIngredient; overload; 
    procedure ParseSubstanceIngredientProperties(obj : TTurtleComplex; value : TFhirSubstanceIngredient); overload; 
    function ParseSubstance(obj : TTurtleComplex) : TFhirSubstance; overload; 
    procedure ParseSubstanceProperties(obj : TTurtleComplex; value : TFhirSubstance); overload; 
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCEDEFINITION}
    function ParseSubstanceDefinitionMoiety(obj : TTurtleComplex) : TFhirSubstanceDefinitionMoiety; overload; 
    procedure ParseSubstanceDefinitionMoietyProperties(obj : TTurtleComplex; value : TFhirSubstanceDefinitionMoiety); overload; 
    function ParseSubstanceDefinitionProperty(obj : TTurtleComplex) : TFhirSubstanceDefinitionProperty; overload; 
    procedure ParseSubstanceDefinitionPropertyProperties(obj : TTurtleComplex; value : TFhirSubstanceDefinitionProperty); overload; 
    function ParseSubstanceDefinitionMolecularWeight(obj : TTurtleComplex) : TFhirSubstanceDefinitionMolecularWeight; overload; 
    procedure ParseSubstanceDefinitionMolecularWeightProperties(obj : TTurtleComplex; value : TFhirSubstanceDefinitionMolecularWeight); overload; 
    function ParseSubstanceDefinitionStructure(obj : TTurtleComplex) : TFhirSubstanceDefinitionStructure; overload; 
    procedure ParseSubstanceDefinitionStructureProperties(obj : TTurtleComplex; value : TFhirSubstanceDefinitionStructure); overload; 
    function ParseSubstanceDefinitionStructureRepresentation(obj : TTurtleComplex) : TFhirSubstanceDefinitionStructureRepresentation; overload; 
    procedure ParseSubstanceDefinitionStructureRepresentationProperties(obj : TTurtleComplex; value : TFhirSubstanceDefinitionStructureRepresentation); overload; 
    function ParseSubstanceDefinitionCode(obj : TTurtleComplex) : TFhirSubstanceDefinitionCode; overload; 
    procedure ParseSubstanceDefinitionCodeProperties(obj : TTurtleComplex; value : TFhirSubstanceDefinitionCode); overload; 
    function ParseSubstanceDefinitionName(obj : TTurtleComplex) : TFhirSubstanceDefinitionName; overload; 
    procedure ParseSubstanceDefinitionNameProperties(obj : TTurtleComplex; value : TFhirSubstanceDefinitionName); overload; 
    function ParseSubstanceDefinitionNameOfficial(obj : TTurtleComplex) : TFhirSubstanceDefinitionNameOfficial; overload; 
    procedure ParseSubstanceDefinitionNameOfficialProperties(obj : TTurtleComplex; value : TFhirSubstanceDefinitionNameOfficial); overload; 
    function ParseSubstanceDefinitionRelationship(obj : TTurtleComplex) : TFhirSubstanceDefinitionRelationship; overload; 
    procedure ParseSubstanceDefinitionRelationshipProperties(obj : TTurtleComplex; value : TFhirSubstanceDefinitionRelationship); overload; 
    function ParseSubstanceDefinitionSourceMaterial(obj : TTurtleComplex) : TFhirSubstanceDefinitionSourceMaterial; overload; 
    procedure ParseSubstanceDefinitionSourceMaterialProperties(obj : TTurtleComplex; value : TFhirSubstanceDefinitionSourceMaterial); overload; 
    function ParseSubstanceDefinition(obj : TTurtleComplex) : TFhirSubstanceDefinition; overload; 
    procedure ParseSubstanceDefinitionProperties(obj : TTurtleComplex; value : TFhirSubstanceDefinition); overload; 
{$ENDIF FHIR_SUBSTANCEDEFINITION}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
    function ParseSubstanceNucleicAcidSubunit(obj : TTurtleComplex) : TFhirSubstanceNucleicAcidSubunit; overload; 
    procedure ParseSubstanceNucleicAcidSubunitProperties(obj : TTurtleComplex; value : TFhirSubstanceNucleicAcidSubunit); overload; 
    function ParseSubstanceNucleicAcidSubunitLinkage(obj : TTurtleComplex) : TFhirSubstanceNucleicAcidSubunitLinkage; overload; 
    procedure ParseSubstanceNucleicAcidSubunitLinkageProperties(obj : TTurtleComplex; value : TFhirSubstanceNucleicAcidSubunitLinkage); overload; 
    function ParseSubstanceNucleicAcidSubunitSugar(obj : TTurtleComplex) : TFhirSubstanceNucleicAcidSubunitSugar; overload; 
    procedure ParseSubstanceNucleicAcidSubunitSugarProperties(obj : TTurtleComplex; value : TFhirSubstanceNucleicAcidSubunitSugar); overload; 
    function ParseSubstanceNucleicAcid(obj : TTurtleComplex) : TFhirSubstanceNucleicAcid; overload; 
    procedure ParseSubstanceNucleicAcidProperties(obj : TTurtleComplex; value : TFhirSubstanceNucleicAcid); overload; 
{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
    function ParseSubstancePolymerMonomerSet(obj : TTurtleComplex) : TFhirSubstancePolymerMonomerSet; overload; 
    procedure ParseSubstancePolymerMonomerSetProperties(obj : TTurtleComplex; value : TFhirSubstancePolymerMonomerSet); overload; 
    function ParseSubstancePolymerMonomerSetStartingMaterial(obj : TTurtleComplex) : TFhirSubstancePolymerMonomerSetStartingMaterial; overload; 
    procedure ParseSubstancePolymerMonomerSetStartingMaterialProperties(obj : TTurtleComplex; value : TFhirSubstancePolymerMonomerSetStartingMaterial); overload; 
    function ParseSubstancePolymerRepeat(obj : TTurtleComplex) : TFhirSubstancePolymerRepeat; overload; 
    procedure ParseSubstancePolymerRepeatProperties(obj : TTurtleComplex; value : TFhirSubstancePolymerRepeat); overload; 
    function ParseSubstancePolymerRepeatRepeatUnit(obj : TTurtleComplex) : TFhirSubstancePolymerRepeatRepeatUnit; overload; 
    procedure ParseSubstancePolymerRepeatRepeatUnitProperties(obj : TTurtleComplex; value : TFhirSubstancePolymerRepeatRepeatUnit); overload; 
    function ParseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(obj : TTurtleComplex) : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation; overload; 
    procedure ParseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationProperties(obj : TTurtleComplex; value : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation); overload; 
    function ParseSubstancePolymerRepeatRepeatUnitStructuralRepresentation(obj : TTurtleComplex) : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation; overload; 
    procedure ParseSubstancePolymerRepeatRepeatUnitStructuralRepresentationProperties(obj : TTurtleComplex; value : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation); overload; 
    function ParseSubstancePolymer(obj : TTurtleComplex) : TFhirSubstancePolymer; overload; 
    procedure ParseSubstancePolymerProperties(obj : TTurtleComplex; value : TFhirSubstancePolymer); overload; 
{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
    function ParseSubstanceProteinSubunit(obj : TTurtleComplex) : TFhirSubstanceProteinSubunit; overload; 
    procedure ParseSubstanceProteinSubunitProperties(obj : TTurtleComplex; value : TFhirSubstanceProteinSubunit); overload; 
    function ParseSubstanceProtein(obj : TTurtleComplex) : TFhirSubstanceProtein; overload; 
    procedure ParseSubstanceProteinProperties(obj : TTurtleComplex; value : TFhirSubstanceProtein); overload; 
{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
    function ParseSubstanceReferenceInformationGene(obj : TTurtleComplex) : TFhirSubstanceReferenceInformationGene; overload; 
    procedure ParseSubstanceReferenceInformationGeneProperties(obj : TTurtleComplex; value : TFhirSubstanceReferenceInformationGene); overload; 
    function ParseSubstanceReferenceInformationGeneElement(obj : TTurtleComplex) : TFhirSubstanceReferenceInformationGeneElement; overload; 
    procedure ParseSubstanceReferenceInformationGeneElementProperties(obj : TTurtleComplex; value : TFhirSubstanceReferenceInformationGeneElement); overload; 
    function ParseSubstanceReferenceInformationTarget(obj : TTurtleComplex) : TFhirSubstanceReferenceInformationTarget; overload; 
    procedure ParseSubstanceReferenceInformationTargetProperties(obj : TTurtleComplex; value : TFhirSubstanceReferenceInformationTarget); overload; 
    function ParseSubstanceReferenceInformation(obj : TTurtleComplex) : TFhirSubstanceReferenceInformation; overload; 
    procedure ParseSubstanceReferenceInformationProperties(obj : TTurtleComplex; value : TFhirSubstanceReferenceInformation); overload; 
{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
    function ParseSubstanceSourceMaterialFractionDescription(obj : TTurtleComplex) : TFhirSubstanceSourceMaterialFractionDescription; overload; 
    procedure ParseSubstanceSourceMaterialFractionDescriptionProperties(obj : TTurtleComplex; value : TFhirSubstanceSourceMaterialFractionDescription); overload; 
    function ParseSubstanceSourceMaterialOrganism(obj : TTurtleComplex) : TFhirSubstanceSourceMaterialOrganism; overload; 
    procedure ParseSubstanceSourceMaterialOrganismProperties(obj : TTurtleComplex; value : TFhirSubstanceSourceMaterialOrganism); overload; 
    function ParseSubstanceSourceMaterialOrganismAuthor(obj : TTurtleComplex) : TFhirSubstanceSourceMaterialOrganismAuthor; overload; 
    procedure ParseSubstanceSourceMaterialOrganismAuthorProperties(obj : TTurtleComplex; value : TFhirSubstanceSourceMaterialOrganismAuthor); overload; 
    function ParseSubstanceSourceMaterialOrganismHybrid(obj : TTurtleComplex) : TFhirSubstanceSourceMaterialOrganismHybrid; overload; 
    procedure ParseSubstanceSourceMaterialOrganismHybridProperties(obj : TTurtleComplex; value : TFhirSubstanceSourceMaterialOrganismHybrid); overload; 
    function ParseSubstanceSourceMaterialOrganismOrganismGeneral(obj : TTurtleComplex) : TFhirSubstanceSourceMaterialOrganismOrganismGeneral; overload; 
    procedure ParseSubstanceSourceMaterialOrganismOrganismGeneralProperties(obj : TTurtleComplex; value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral); overload; 
    function ParseSubstanceSourceMaterialPartDescription(obj : TTurtleComplex) : TFhirSubstanceSourceMaterialPartDescription; overload; 
    procedure ParseSubstanceSourceMaterialPartDescriptionProperties(obj : TTurtleComplex; value : TFhirSubstanceSourceMaterialPartDescription); overload; 
    function ParseSubstanceSourceMaterial(obj : TTurtleComplex) : TFhirSubstanceSourceMaterial; overload; 
    procedure ParseSubstanceSourceMaterialProperties(obj : TTurtleComplex; value : TFhirSubstanceSourceMaterial); overload; 
{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUPPLYDELIVERY}
    function ParseSupplyDeliverySuppliedItem(obj : TTurtleComplex) : TFhirSupplyDeliverySuppliedItem; overload; 
    procedure ParseSupplyDeliverySuppliedItemProperties(obj : TTurtleComplex; value : TFhirSupplyDeliverySuppliedItem); overload; 
    function ParseSupplyDelivery(obj : TTurtleComplex) : TFhirSupplyDelivery; overload; 
    procedure ParseSupplyDeliveryProperties(obj : TTurtleComplex; value : TFhirSupplyDelivery); overload; 
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
    function ParseSupplyRequestParameter(obj : TTurtleComplex) : TFhirSupplyRequestParameter; overload; 
    procedure ParseSupplyRequestParameterProperties(obj : TTurtleComplex; value : TFhirSupplyRequestParameter); overload; 
    function ParseSupplyRequest(obj : TTurtleComplex) : TFhirSupplyRequest; overload; 
    procedure ParseSupplyRequestProperties(obj : TTurtleComplex; value : TFhirSupplyRequest); overload; 
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
    function ParseTaskRestriction(obj : TTurtleComplex) : TFhirTaskRestriction; overload; 
    procedure ParseTaskRestrictionProperties(obj : TTurtleComplex; value : TFhirTaskRestriction); overload; 
    function ParseTaskInput(obj : TTurtleComplex) : TFhirTaskInput; overload; 
    procedure ParseTaskInputProperties(obj : TTurtleComplex; value : TFhirTaskInput); overload; 
    function ParseTaskOutput(obj : TTurtleComplex) : TFhirTaskOutput; overload; 
    procedure ParseTaskOutputProperties(obj : TTurtleComplex; value : TFhirTaskOutput); overload; 
    function ParseTask(obj : TTurtleComplex) : TFhirTask; overload; 
    procedure ParseTaskProperties(obj : TTurtleComplex; value : TFhirTask); overload; 
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
    function ParseTerminologyCapabilitiesSoftware(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesSoftware; overload; 
    procedure ParseTerminologyCapabilitiesSoftwareProperties(obj : TTurtleComplex; value : TFhirTerminologyCapabilitiesSoftware); overload; 
    function ParseTerminologyCapabilitiesImplementation(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesImplementation; overload; 
    procedure ParseTerminologyCapabilitiesImplementationProperties(obj : TTurtleComplex; value : TFhirTerminologyCapabilitiesImplementation); overload; 
    function ParseTerminologyCapabilitiesCodeSystem(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesCodeSystem; overload; 
    procedure ParseTerminologyCapabilitiesCodeSystemProperties(obj : TTurtleComplex; value : TFhirTerminologyCapabilitiesCodeSystem); overload; 
    function ParseTerminologyCapabilitiesCodeSystemVersion(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesCodeSystemVersion; overload; 
    procedure ParseTerminologyCapabilitiesCodeSystemVersionProperties(obj : TTurtleComplex; value : TFhirTerminologyCapabilitiesCodeSystemVersion); overload; 
    function ParseTerminologyCapabilitiesCodeSystemVersionFilter(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesCodeSystemVersionFilter; overload; 
    procedure ParseTerminologyCapabilitiesCodeSystemVersionFilterProperties(obj : TTurtleComplex; value : TFhirTerminologyCapabilitiesCodeSystemVersionFilter); overload; 
    function ParseTerminologyCapabilitiesExpansion(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesExpansion; overload; 
    procedure ParseTerminologyCapabilitiesExpansionProperties(obj : TTurtleComplex; value : TFhirTerminologyCapabilitiesExpansion); overload; 
    function ParseTerminologyCapabilitiesExpansionParameter(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesExpansionParameter; overload; 
    procedure ParseTerminologyCapabilitiesExpansionParameterProperties(obj : TTurtleComplex; value : TFhirTerminologyCapabilitiesExpansionParameter); overload; 
    function ParseTerminologyCapabilitiesValidateCode(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesValidateCode; overload; 
    procedure ParseTerminologyCapabilitiesValidateCodeProperties(obj : TTurtleComplex; value : TFhirTerminologyCapabilitiesValidateCode); overload; 
    function ParseTerminologyCapabilitiesTranslation(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesTranslation; overload; 
    procedure ParseTerminologyCapabilitiesTranslationProperties(obj : TTurtleComplex; value : TFhirTerminologyCapabilitiesTranslation); overload; 
    function ParseTerminologyCapabilitiesClosure(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesClosure; overload; 
    procedure ParseTerminologyCapabilitiesClosureProperties(obj : TTurtleComplex; value : TFhirTerminologyCapabilitiesClosure); overload; 
    function ParseTerminologyCapabilities(obj : TTurtleComplex) : TFhirTerminologyCapabilities; overload; 
    procedure ParseTerminologyCapabilitiesProperties(obj : TTurtleComplex; value : TFhirTerminologyCapabilities); overload; 
{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTREPORT}
    function ParseTestReportParticipant(obj : TTurtleComplex) : TFhirTestReportParticipant; overload; 
    procedure ParseTestReportParticipantProperties(obj : TTurtleComplex; value : TFhirTestReportParticipant); overload; 
    function ParseTestReportSetup(obj : TTurtleComplex) : TFhirTestReportSetup; overload; 
    procedure ParseTestReportSetupProperties(obj : TTurtleComplex; value : TFhirTestReportSetup); overload; 
    function ParseTestReportSetupAction(obj : TTurtleComplex) : TFhirTestReportSetupAction; overload; 
    procedure ParseTestReportSetupActionProperties(obj : TTurtleComplex; value : TFhirTestReportSetupAction); overload; 
    function ParseTestReportSetupActionOperation(obj : TTurtleComplex) : TFhirTestReportSetupActionOperation; overload; 
    procedure ParseTestReportSetupActionOperationProperties(obj : TTurtleComplex; value : TFhirTestReportSetupActionOperation); overload; 
    function ParseTestReportSetupActionAssert(obj : TTurtleComplex) : TFhirTestReportSetupActionAssert; overload; 
    procedure ParseTestReportSetupActionAssertProperties(obj : TTurtleComplex; value : TFhirTestReportSetupActionAssert); overload; 
    function ParseTestReportTest(obj : TTurtleComplex) : TFhirTestReportTest; overload; 
    procedure ParseTestReportTestProperties(obj : TTurtleComplex; value : TFhirTestReportTest); overload; 
    function ParseTestReportTestAction(obj : TTurtleComplex) : TFhirTestReportTestAction; overload; 
    procedure ParseTestReportTestActionProperties(obj : TTurtleComplex; value : TFhirTestReportTestAction); overload; 
    function ParseTestReportTeardown(obj : TTurtleComplex) : TFhirTestReportTeardown; overload; 
    procedure ParseTestReportTeardownProperties(obj : TTurtleComplex; value : TFhirTestReportTeardown); overload; 
    function ParseTestReportTeardownAction(obj : TTurtleComplex) : TFhirTestReportTeardownAction; overload; 
    procedure ParseTestReportTeardownActionProperties(obj : TTurtleComplex; value : TFhirTestReportTeardownAction); overload; 
    function ParseTestReport(obj : TTurtleComplex) : TFhirTestReport; overload; 
    procedure ParseTestReportProperties(obj : TTurtleComplex; value : TFhirTestReport); overload; 
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
    function ParseTestScriptOrigin(obj : TTurtleComplex) : TFhirTestScriptOrigin; overload; 
    procedure ParseTestScriptOriginProperties(obj : TTurtleComplex; value : TFhirTestScriptOrigin); overload; 
    function ParseTestScriptDestination(obj : TTurtleComplex) : TFhirTestScriptDestination; overload; 
    procedure ParseTestScriptDestinationProperties(obj : TTurtleComplex; value : TFhirTestScriptDestination); overload; 
    function ParseTestScriptMetadata(obj : TTurtleComplex) : TFhirTestScriptMetadata; overload; 
    procedure ParseTestScriptMetadataProperties(obj : TTurtleComplex; value : TFhirTestScriptMetadata); overload; 
    function ParseTestScriptMetadataLink(obj : TTurtleComplex) : TFhirTestScriptMetadataLink; overload; 
    procedure ParseTestScriptMetadataLinkProperties(obj : TTurtleComplex; value : TFhirTestScriptMetadataLink); overload; 
    function ParseTestScriptMetadataCapability(obj : TTurtleComplex) : TFhirTestScriptMetadataCapability; overload; 
    procedure ParseTestScriptMetadataCapabilityProperties(obj : TTurtleComplex; value : TFhirTestScriptMetadataCapability); overload; 
    function ParseTestScriptScope(obj : TTurtleComplex) : TFhirTestScriptScope; overload; 
    procedure ParseTestScriptScopeProperties(obj : TTurtleComplex; value : TFhirTestScriptScope); overload; 
    function ParseTestScriptFixture(obj : TTurtleComplex) : TFhirTestScriptFixture; overload; 
    procedure ParseTestScriptFixtureProperties(obj : TTurtleComplex; value : TFhirTestScriptFixture); overload; 
    function ParseTestScriptVariable(obj : TTurtleComplex) : TFhirTestScriptVariable; overload; 
    procedure ParseTestScriptVariableProperties(obj : TTurtleComplex; value : TFhirTestScriptVariable); overload; 
    function ParseTestScriptSetup(obj : TTurtleComplex) : TFhirTestScriptSetup; overload; 
    procedure ParseTestScriptSetupProperties(obj : TTurtleComplex; value : TFhirTestScriptSetup); overload; 
    function ParseTestScriptSetupAction(obj : TTurtleComplex) : TFhirTestScriptSetupAction; overload; 
    procedure ParseTestScriptSetupActionProperties(obj : TTurtleComplex; value : TFhirTestScriptSetupAction); overload; 
    function ParseTestScriptSetupActionOperation(obj : TTurtleComplex) : TFhirTestScriptSetupActionOperation; overload; 
    procedure ParseTestScriptSetupActionOperationProperties(obj : TTurtleComplex; value : TFhirTestScriptSetupActionOperation); overload; 
    function ParseTestScriptSetupActionOperationRequestHeader(obj : TTurtleComplex) : TFhirTestScriptSetupActionOperationRequestHeader; overload; 
    procedure ParseTestScriptSetupActionOperationRequestHeaderProperties(obj : TTurtleComplex; value : TFhirTestScriptSetupActionOperationRequestHeader); overload; 
    function ParseTestScriptSetupActionAssert(obj : TTurtleComplex) : TFhirTestScriptSetupActionAssert; overload; 
    procedure ParseTestScriptSetupActionAssertProperties(obj : TTurtleComplex; value : TFhirTestScriptSetupActionAssert); overload; 
    function ParseTestScriptTest(obj : TTurtleComplex) : TFhirTestScriptTest; overload; 
    procedure ParseTestScriptTestProperties(obj : TTurtleComplex; value : TFhirTestScriptTest); overload; 
    function ParseTestScriptTestAction(obj : TTurtleComplex) : TFhirTestScriptTestAction; overload; 
    procedure ParseTestScriptTestActionProperties(obj : TTurtleComplex; value : TFhirTestScriptTestAction); overload; 
    function ParseTestScriptTeardown(obj : TTurtleComplex) : TFhirTestScriptTeardown; overload; 
    procedure ParseTestScriptTeardownProperties(obj : TTurtleComplex; value : TFhirTestScriptTeardown); overload; 
    function ParseTestScriptTeardownAction(obj : TTurtleComplex) : TFhirTestScriptTeardownAction; overload; 
    procedure ParseTestScriptTeardownActionProperties(obj : TTurtleComplex; value : TFhirTestScriptTeardownAction); overload; 
    function ParseTestScript(obj : TTurtleComplex) : TFhirTestScript; overload; 
    procedure ParseTestScriptProperties(obj : TTurtleComplex; value : TFhirTestScript); overload; 
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_TRANSPORT}
    function ParseTransportRestriction(obj : TTurtleComplex) : TFhirTransportRestriction; overload; 
    procedure ParseTransportRestrictionProperties(obj : TTurtleComplex; value : TFhirTransportRestriction); overload; 
    function ParseTransportInput(obj : TTurtleComplex) : TFhirTransportInput; overload; 
    procedure ParseTransportInputProperties(obj : TTurtleComplex; value : TFhirTransportInput); overload; 
    function ParseTransportOutput(obj : TTurtleComplex) : TFhirTransportOutput; overload; 
    procedure ParseTransportOutputProperties(obj : TTurtleComplex; value : TFhirTransportOutput); overload; 
    function ParseTransport(obj : TTurtleComplex) : TFhirTransport; overload; 
    procedure ParseTransportProperties(obj : TTurtleComplex; value : TFhirTransport); overload; 
{$ENDIF FHIR_TRANSPORT}
{$IFDEF FHIR_VALUESET}
    function ParseValueSetCompose(obj : TTurtleComplex) : TFhirValueSetCompose; overload; 
    procedure ParseValueSetComposeProperties(obj : TTurtleComplex; value : TFhirValueSetCompose); overload; 
    function ParseValueSetComposeInclude(obj : TTurtleComplex) : TFhirValueSetComposeInclude; overload; 
    procedure ParseValueSetComposeIncludeProperties(obj : TTurtleComplex; value : TFhirValueSetComposeInclude); overload; 
    function ParseValueSetComposeIncludeConcept(obj : TTurtleComplex) : TFhirValueSetComposeIncludeConcept; overload; 
    procedure ParseValueSetComposeIncludeConceptProperties(obj : TTurtleComplex; value : TFhirValueSetComposeIncludeConcept); overload; 
    function ParseValueSetComposeIncludeConceptDesignation(obj : TTurtleComplex) : TFhirValueSetComposeIncludeConceptDesignation; overload; 
    procedure ParseValueSetComposeIncludeConceptDesignationProperties(obj : TTurtleComplex; value : TFhirValueSetComposeIncludeConceptDesignation); overload; 
    function ParseValueSetComposeIncludeFilter(obj : TTurtleComplex) : TFhirValueSetComposeIncludeFilter; overload; 
    procedure ParseValueSetComposeIncludeFilterProperties(obj : TTurtleComplex; value : TFhirValueSetComposeIncludeFilter); overload; 
    function ParseValueSetExpansion(obj : TTurtleComplex) : TFhirValueSetExpansion; overload; 
    procedure ParseValueSetExpansionProperties(obj : TTurtleComplex; value : TFhirValueSetExpansion); overload; 
    function ParseValueSetExpansionParameter(obj : TTurtleComplex) : TFhirValueSetExpansionParameter; overload; 
    procedure ParseValueSetExpansionParameterProperties(obj : TTurtleComplex; value : TFhirValueSetExpansionParameter); overload; 
    function ParseValueSetExpansionProperty(obj : TTurtleComplex) : TFhirValueSetExpansionProperty; overload; 
    procedure ParseValueSetExpansionPropertyProperties(obj : TTurtleComplex; value : TFhirValueSetExpansionProperty); overload; 
    function ParseValueSetExpansionContains(obj : TTurtleComplex) : TFhirValueSetExpansionContains; overload; 
    procedure ParseValueSetExpansionContainsProperties(obj : TTurtleComplex; value : TFhirValueSetExpansionContains); overload; 
    function ParseValueSetExpansionContainsProperty(obj : TTurtleComplex) : TFhirValueSetExpansionContainsProperty; overload; 
    procedure ParseValueSetExpansionContainsPropertyProperties(obj : TTurtleComplex; value : TFhirValueSetExpansionContainsProperty); overload; 
    function ParseValueSetExpansionContainsPropertySubProperty(obj : TTurtleComplex) : TFhirValueSetExpansionContainsPropertySubProperty; overload; 
    procedure ParseValueSetExpansionContainsPropertySubPropertyProperties(obj : TTurtleComplex; value : TFhirValueSetExpansionContainsPropertySubProperty); overload; 
    function ParseValueSetScope(obj : TTurtleComplex) : TFhirValueSetScope; overload; 
    procedure ParseValueSetScopeProperties(obj : TTurtleComplex; value : TFhirValueSetScope); overload; 
    function ParseValueSet(obj : TTurtleComplex) : TFhirValueSet; overload; 
    procedure ParseValueSetProperties(obj : TTurtleComplex; value : TFhirValueSet); overload; 
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VERIFICATIONRESULT}
    function ParseVerificationResultPrimarySource(obj : TTurtleComplex) : TFhirVerificationResultPrimarySource; overload; 
    procedure ParseVerificationResultPrimarySourceProperties(obj : TTurtleComplex; value : TFhirVerificationResultPrimarySource); overload; 
    function ParseVerificationResultAttestation(obj : TTurtleComplex) : TFhirVerificationResultAttestation; overload; 
    procedure ParseVerificationResultAttestationProperties(obj : TTurtleComplex; value : TFhirVerificationResultAttestation); overload; 
    function ParseVerificationResultValidator(obj : TTurtleComplex) : TFhirVerificationResultValidator; overload; 
    procedure ParseVerificationResultValidatorProperties(obj : TTurtleComplex; value : TFhirVerificationResultValidator); overload; 
    function ParseVerificationResult(obj : TTurtleComplex) : TFhirVerificationResult; overload; 
    procedure ParseVerificationResultProperties(obj : TTurtleComplex; value : TFhirVerificationResult); overload; 
{$ENDIF FHIR_VERIFICATIONRESULT}
{$IFDEF FHIR_VISIONPRESCRIPTION}
    function ParseVisionPrescriptionLensSpecification(obj : TTurtleComplex) : TFhirVisionPrescriptionLensSpecification; overload; 
    procedure ParseVisionPrescriptionLensSpecificationProperties(obj : TTurtleComplex; value : TFhirVisionPrescriptionLensSpecification); overload; 
    function ParseVisionPrescriptionLensSpecificationPrism(obj : TTurtleComplex) : TFhirVisionPrescriptionLensSpecificationPrism; overload; 
    procedure ParseVisionPrescriptionLensSpecificationPrismProperties(obj : TTurtleComplex; value : TFhirVisionPrescriptionLensSpecificationPrism); overload; 
    function ParseVisionPrescription(obj : TTurtleComplex) : TFhirVisionPrescription; overload; 
    procedure ParseVisionPrescriptionProperties(obj : TTurtleComplex; value : TFhirVisionPrescription); overload; 
{$ENDIF FHIR_VISIONPRESCRIPTION}

    function ParseResource(obj : TTurtleComplex) : TFhirResource; override;
    function ParseDataType(obj : TTurtleComplex; name : String; type_ : TFHIRDataTypeClass) : TFHIRDataType; override;
  public
    function ParseFragment(obj : TTurtleComplex; type_ : String) : TFHIRObject;  overload;
  end;
  
  TFHIRTurtleComposer = class (TFHIRTurtleComposerBase5)
  protected
    procedure ComposeBase(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBase; useType : boolean; index : integer); overload;
    procedure ComposeBase(parent :  TTurtleComplex; parentType, name : String; elem : TFhirResource; useType : boolean; index : integer); overload;
    
    Procedure ComposeElement(this : TTurtleComplex; parentType, name : String; value : TFhirElement; useType : boolean; index : integer); overload;
    Procedure ComposeBackboneElement(this : TTurtleComplex; parentType, name : String; value : TFhirBackboneElement; useType : boolean; index : integer); overload;
    Procedure ComposeDataType(this : TTurtleComplex; parentType, name : String; value : TFhirDataType; useType : boolean; index : integer); overload;
    Procedure ComposeBackboneType(this : TTurtleComplex; parentType, name : String; value : TFhirBackboneType; useType : boolean; index : integer); overload;
    Procedure ComposePrimitiveType(this : TTurtleComplex; parentType, name : String; value : TFhirPrimitiveType; useType : boolean; index : integer); overload;

    
    Procedure ComposeEnum(parent :  TTurtleComplex; parentType, name : String; value : TFhirEnum; Const aNames, aSystems : Array Of String; useType : boolean; index : integer);
    Procedure ComposeDate(parent :  TTurtleComplex; parentType, name : String; value : TFhirDate; useType : boolean; index : integer);
    Procedure ComposeDateTime(parent :  TTurtleComplex; parentType, name : String; value : TFhirDateTime; useType : boolean; index : integer);
    Procedure ComposeString(parent :  TTurtleComplex; parentType, name : String; value : TFhirString; useType : boolean; index : integer);
    Procedure ComposeInteger(parent :  TTurtleComplex; parentType, name : String; value : TFhirInteger; useType : boolean; index : integer);
    Procedure ComposeUri(parent :  TTurtleComplex; parentType, name : String; value : TFhirUri; useType : boolean; index : integer);
    Procedure ComposeInstant(parent :  TTurtleComplex; parentType, name : String; value : TFhirInstant; useType : boolean; index : integer);
    Procedure ComposeXhtml(parent :  TTurtleComplex; parentType, name : String; value : TFhirXhtml; useType : boolean; index : integer);
    Procedure ComposeBoolean(parent :  TTurtleComplex; parentType, name : String; value : TFhirBoolean; useType : boolean; index : integer);
    Procedure ComposeBase64Binary(parent :  TTurtleComplex; parentType, name : String; value : TFhirBase64Binary; useType : boolean; index : integer);
    Procedure ComposeTime(parent :  TTurtleComplex; parentType, name : String; value : TFhirTime; useType : boolean; index : integer);
    Procedure ComposeDecimal(parent :  TTurtleComplex; parentType, name : String; value : TFhirDecimal; useType : boolean; index : integer);
    Procedure ComposeCode(parent :  TTurtleComplex; parentType, name : String; value : TFhirCode; useType : boolean; index : integer);
    Procedure ComposeCanonical(parent :  TTurtleComplex; parentType, name : String; value : TFhirCanonical; useType : boolean; index : integer);
    Procedure ComposeOid(parent :  TTurtleComplex; parentType, name : String; value : TFhirOid; useType : boolean; index : integer);
    Procedure ComposeUuid(parent :  TTurtleComplex; parentType, name : String; value : TFhirUuid; useType : boolean; index : integer);
    Procedure ComposeUrl(parent :  TTurtleComplex; parentType, name : String; value : TFhirUrl; useType : boolean; index : integer);
    Procedure ComposeMarkdown(parent :  TTurtleComplex; parentType, name : String; value : TFhirMarkdown; useType : boolean; index : integer);
    Procedure ComposeUnsignedInt(parent :  TTurtleComplex; parentType, name : String; value : TFhirUnsignedInt; useType : boolean; index : integer);
    Procedure ComposeId(parent :  TTurtleComplex; parentType, name : String; value : TFhirId; useType : boolean; index : integer);
    Procedure ComposePositiveInt(parent :  TTurtleComplex; parentType, name : String; value : TFhirPositiveInt; useType : boolean; index : integer);
    Procedure ComposeInteger64(parent :  TTurtleComplex; parentType, name : String; value : TFhirInteger64; useType : boolean; index : integer);

    procedure ComposeAddress(parent :  TTurtleComplex; parentType, name : String; value : TFhirAddress; useType : boolean; index : integer);
    procedure ComposeAnnotation(parent :  TTurtleComplex; parentType, name : String; value : TFhirAnnotation; useType : boolean; index : integer);
    procedure ComposeAttachment(parent :  TTurtleComplex; parentType, name : String; value : TFhirAttachment; useType : boolean; index : integer);
    procedure ComposeAvailabilityAvailableTime(parent :  TTurtleComplex; parentType, name : String; value : TFhirAvailabilityAvailableTime; useType : boolean; index : integer);
    procedure ComposeAvailabilityNotAvailableTime(parent :  TTurtleComplex; parentType, name : String; value : TFhirAvailabilityNotAvailableTime; useType : boolean; index : integer);
    procedure ComposeAvailability(parent :  TTurtleComplex; parentType, name : String; value : TFhirAvailability; useType : boolean; index : integer);
    procedure ComposeCodeableConcept(parent :  TTurtleComplex; parentType, name : String; value : TFhirCodeableConcept; useType : boolean; index : integer);
    procedure ComposeCodeableReference(parent :  TTurtleComplex; parentType, name : String; value : TFhirCodeableReference; useType : boolean; index : integer);
    procedure ComposeCoding(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoding; useType : boolean; index : integer);
    procedure ComposeContactDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirContactDetail; useType : boolean; index : integer);
    procedure ComposeContactPoint(parent :  TTurtleComplex; parentType, name : String; value : TFhirContactPoint; useType : boolean; index : integer);
    procedure ComposeContributor(parent :  TTurtleComplex; parentType, name : String; value : TFhirContributor; useType : boolean; index : integer);
    procedure ComposeDataRequirementCodeFilter(parent :  TTurtleComplex; parentType, name : String; value : TFhirDataRequirementCodeFilter; useType : boolean; index : integer);
    procedure ComposeDataRequirementDateFilter(parent :  TTurtleComplex; parentType, name : String; value : TFhirDataRequirementDateFilter; useType : boolean; index : integer);
    procedure ComposeDataRequirementValueFilter(parent :  TTurtleComplex; parentType, name : String; value : TFhirDataRequirementValueFilter; useType : boolean; index : integer);
    procedure ComposeDataRequirementSort(parent :  TTurtleComplex; parentType, name : String; value : TFhirDataRequirementSort; useType : boolean; index : integer);
    procedure ComposeDataRequirement(parent :  TTurtleComplex; parentType, name : String; value : TFhirDataRequirement; useType : boolean; index : integer);
    procedure ComposeExpression(parent :  TTurtleComplex; parentType, name : String; value : TFhirExpression; useType : boolean; index : integer);
    procedure ComposeExtendedContactDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirExtendedContactDetail; useType : boolean; index : integer);
    procedure ComposeExtension(parent :  TTurtleComplex; parentType, name : String; value : TFhirExtension; useType : boolean; index : integer);
    procedure ComposeHumanName(parent :  TTurtleComplex; parentType, name : String; value : TFhirHumanName; useType : boolean; index : integer);
    procedure ComposeIdentifier(parent :  TTurtleComplex; parentType, name : String; value : TFhirIdentifier; useType : boolean; index : integer);
    procedure ComposeMeta(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeta; useType : boolean; index : integer);
    procedure ComposeMonetaryComponent(parent :  TTurtleComplex; parentType, name : String; value : TFhirMonetaryComponent; useType : boolean; index : integer);
    procedure ComposeMoney(parent :  TTurtleComplex; parentType, name : String; value : TFhirMoney; useType : boolean; index : integer);
    procedure ComposeNarrative(parent :  TTurtleComplex; parentType, name : String; value : TFhirNarrative; useType : boolean; index : integer);
    procedure ComposeParameterDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirParameterDefinition; useType : boolean; index : integer);
    procedure ComposePeriod(parent :  TTurtleComplex; parentType, name : String; value : TFhirPeriod; useType : boolean; index : integer);
    procedure ComposeQuantity(parent :  TTurtleComplex; parentType, name : String; value : TFhirQuantity; useType : boolean; index : integer);
    procedure ComposeRange(parent :  TTurtleComplex; parentType, name : String; value : TFhirRange; useType : boolean; index : integer);
    procedure ComposeRatio(parent :  TTurtleComplex; parentType, name : String; value : TFhirRatio; useType : boolean; index : integer);
    procedure ComposeRatioRange(parent :  TTurtleComplex; parentType, name : String; value : TFhirRatioRange; useType : boolean; index : integer);
    procedure ComposeReference(parent :  TTurtleComplex; parentType, name : String; value : TFhirReference; useType : boolean; index : integer);
    procedure ComposeRelatedArtifact(parent :  TTurtleComplex; parentType, name : String; value : TFhirRelatedArtifact; useType : boolean; index : integer);
    procedure ComposeSampledData(parent :  TTurtleComplex; parentType, name : String; value : TFhirSampledData; useType : boolean; index : integer);
    procedure ComposeSignature(parent :  TTurtleComplex; parentType, name : String; value : TFhirSignature; useType : boolean; index : integer);
    procedure ComposeTriggerDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirTriggerDefinition; useType : boolean; index : integer);
    procedure ComposeUsageContext(parent :  TTurtleComplex; parentType, name : String; value : TFhirUsageContext; useType : boolean; index : integer);
    procedure ComposeVirtualServiceDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirVirtualServiceDetail; useType : boolean; index : integer);
    procedure ComposeAge(parent :  TTurtleComplex; parentType, name : String; value : TFhirAge; useType : boolean; index : integer);
    procedure ComposeCount(parent :  TTurtleComplex; parentType, name : String; value : TFhirCount; useType : boolean; index : integer);
    procedure ComposeDistance(parent :  TTurtleComplex; parentType, name : String; value : TFhirDistance; useType : boolean; index : integer);
    procedure ComposeDosageDoseAndRate(parent :  TTurtleComplex; parentType, name : String; value : TFhirDosageDoseAndRate; useType : boolean; index : integer);
    procedure ComposeDosage(parent :  TTurtleComplex; parentType, name : String; value : TFhirDosage; useType : boolean; index : integer);
    procedure ComposeDuration(parent :  TTurtleComplex; parentType, name : String; value : TFhirDuration; useType : boolean; index : integer);
    procedure ComposeElementDefinitionSlicing(parent :  TTurtleComplex; parentType, name : String; value : TFhirElementDefinitionSlicing; useType : boolean; index : integer);
    procedure ComposeElementDefinitionSlicingDiscriminator(parent :  TTurtleComplex; parentType, name : String; value : TFhirElementDefinitionSlicingDiscriminator; useType : boolean; index : integer);
    procedure ComposeElementDefinitionBase(parent :  TTurtleComplex; parentType, name : String; value : TFhirElementDefinitionBase; useType : boolean; index : integer);
    procedure ComposeElementDefinitionType(parent :  TTurtleComplex; parentType, name : String; value : TFhirElementDefinitionType; useType : boolean; index : integer);
    procedure ComposeElementDefinitionExample(parent :  TTurtleComplex; parentType, name : String; value : TFhirElementDefinitionExample; useType : boolean; index : integer);
    procedure ComposeElementDefinitionConstraint(parent :  TTurtleComplex; parentType, name : String; value : TFhirElementDefinitionConstraint; useType : boolean; index : integer);
    procedure ComposeElementDefinitionBinding(parent :  TTurtleComplex; parentType, name : String; value : TFhirElementDefinitionBinding; useType : boolean; index : integer);
    procedure ComposeElementDefinitionMapping(parent :  TTurtleComplex; parentType, name : String; value : TFhirElementDefinitionMapping; useType : boolean; index : integer);
    procedure ComposeElementDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirElementDefinition; useType : boolean; index : integer);
    procedure ComposeMarketingStatus(parent :  TTurtleComplex; parentType, name : String; value : TFhirMarketingStatus; useType : boolean; index : integer);
    procedure ComposePopulation(parent :  TTurtleComplex; parentType, name : String; value : TFhirPopulation; useType : boolean; index : integer);
    procedure ComposeProductShelfLife(parent :  TTurtleComplex; parentType, name : String; value : TFhirProductShelfLife; useType : boolean; index : integer);
    procedure ComposeTimingRepeat(parent :  TTurtleComplex; parentType, name : String; value : TFhirTimingRepeat; useType : boolean; index : integer);
    procedure ComposeTiming(parent :  TTurtleComplex; parentType, name : String; value : TFhirTiming; useType : boolean; index : integer);


    Procedure ComposeResource(this : TTurtleComplex; parentType, name : String; value : TFhirResource; useType : boolean; index : integer); overload;
    Procedure ComposeDomainResource(this : TTurtleComplex; parentType, name : String; value : TFhirDomainResource; useType : boolean; index : integer); overload;
    Procedure ComposeCanonicalResource(this : TTurtleComplex; parentType, name : String; value : TFhirCanonicalResource; useType : boolean; index : integer); overload;
    Procedure ComposeMetadataResource(this : TTurtleComplex; parentType, name : String; value : TFhirMetadataResource; useType : boolean; index : integer); overload;


{$IFDEF FHIR_ACCOUNT}
    procedure ComposeAccountCoverage(parent :  TTurtleComplex; parentType, name : String; value : TFhirAccountCoverage; useType : boolean; index : integer);
    procedure ComposeAccountGuarantor(parent :  TTurtleComplex; parentType, name : String; value : TFhirAccountGuarantor; useType : boolean; index : integer);
    procedure ComposeAccountRelatedAccount(parent :  TTurtleComplex; parentType, name : String; value : TFhirAccountRelatedAccount; useType : boolean; index : integer);
    procedure ComposeAccountBalance(parent :  TTurtleComplex; parentType, name : String; value : TFhirAccountBalance; useType : boolean; index : integer);
    procedure ComposeAccount(parent :  TTurtleComplex; parentType, name : String; value : TFhirAccount; useType : boolean; index : integer);
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
    procedure ComposeActivityDefinitionParticipant(parent :  TTurtleComplex; parentType, name : String; value : TFhirActivityDefinitionParticipant; useType : boolean; index : integer);
    procedure ComposeActivityDefinitionDynamicValue(parent :  TTurtleComplex; parentType, name : String; value : TFhirActivityDefinitionDynamicValue; useType : boolean; index : integer);
    procedure ComposeActivityDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirActivityDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ACTORDEFINITION}
    procedure ComposeActorDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirActorDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_ACTORDEFINITION}
{$IFDEF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
    procedure ComposeAdministrableProductDefinitionProperty(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdministrableProductDefinitionProperty; useType : boolean; index : integer);
    procedure ComposeAdministrableProductDefinitionRouteOfAdministration(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdministrableProductDefinitionRouteOfAdministration; useType : boolean; index : integer);
    procedure ComposeAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies; useType : boolean; index : integer);
    procedure ComposeAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod; useType : boolean; index : integer);
    procedure ComposeAdministrableProductDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdministrableProductDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
    procedure ComposeAdverseEventParticipant(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdverseEventParticipant; useType : boolean; index : integer);
    procedure ComposeAdverseEventSuspectEntity(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdverseEventSuspectEntity; useType : boolean; index : integer);
    procedure ComposeAdverseEventSuspectEntityCausality(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdverseEventSuspectEntityCausality; useType : boolean; index : integer);
    procedure ComposeAdverseEventContributingFactor(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdverseEventContributingFactor; useType : boolean; index : integer);
    procedure ComposeAdverseEventPreventiveAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdverseEventPreventiveAction; useType : boolean; index : integer);
    procedure ComposeAdverseEventMitigatingAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdverseEventMitigatingAction; useType : boolean; index : integer);
    procedure ComposeAdverseEventSupportingInfo(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdverseEventSupportingInfo; useType : boolean; index : integer);
    procedure ComposeAdverseEvent(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdverseEvent; useType : boolean; index : integer);
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
    procedure ComposeAllergyIntoleranceParticipant(parent :  TTurtleComplex; parentType, name : String; value : TFhirAllergyIntoleranceParticipant; useType : boolean; index : integer);
    procedure ComposeAllergyIntoleranceReaction(parent :  TTurtleComplex; parentType, name : String; value : TFhirAllergyIntoleranceReaction; useType : boolean; index : integer);
    procedure ComposeAllergyIntolerance(parent :  TTurtleComplex; parentType, name : String; value : TFhirAllergyIntolerance; useType : boolean; index : integer);
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
    procedure ComposeAppointmentParticipant(parent :  TTurtleComplex; parentType, name : String; value : TFhirAppointmentParticipant; useType : boolean; index : integer);
    procedure ComposeAppointmentRecurrenceTemplate(parent :  TTurtleComplex; parentType, name : String; value : TFhirAppointmentRecurrenceTemplate; useType : boolean; index : integer);
    procedure ComposeAppointmentRecurrenceTemplateWeeklyTemplate(parent :  TTurtleComplex; parentType, name : String; value : TFhirAppointmentRecurrenceTemplateWeeklyTemplate; useType : boolean; index : integer);
    procedure ComposeAppointmentRecurrenceTemplateMonthlyTemplate(parent :  TTurtleComplex; parentType, name : String; value : TFhirAppointmentRecurrenceTemplateMonthlyTemplate; useType : boolean; index : integer);
    procedure ComposeAppointmentRecurrenceTemplateYearlyTemplate(parent :  TTurtleComplex; parentType, name : String; value : TFhirAppointmentRecurrenceTemplateYearlyTemplate; useType : boolean; index : integer);
    procedure ComposeAppointment(parent :  TTurtleComplex; parentType, name : String; value : TFhirAppointment; useType : boolean; index : integer);
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
    procedure ComposeAppointmentResponse(parent :  TTurtleComplex; parentType, name : String; value : TFhirAppointmentResponse; useType : boolean; index : integer);
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_ARTIFACTASSESSMENT}
    procedure ComposeArtifactAssessmentContent(parent :  TTurtleComplex; parentType, name : String; value : TFhirArtifactAssessmentContent; useType : boolean; index : integer);
    procedure ComposeArtifactAssessment(parent :  TTurtleComplex; parentType, name : String; value : TFhirArtifactAssessment; useType : boolean; index : integer);
{$ENDIF FHIR_ARTIFACTASSESSMENT}
{$IFDEF FHIR_AUDITEVENT}
    procedure ComposeAuditEventOutcome(parent :  TTurtleComplex; parentType, name : String; value : TFhirAuditEventOutcome; useType : boolean; index : integer);
    procedure ComposeAuditEventAgent(parent :  TTurtleComplex; parentType, name : String; value : TFhirAuditEventAgent; useType : boolean; index : integer);
    procedure ComposeAuditEventSource(parent :  TTurtleComplex; parentType, name : String; value : TFhirAuditEventSource; useType : boolean; index : integer);
    procedure ComposeAuditEventEntity(parent :  TTurtleComplex; parentType, name : String; value : TFhirAuditEventEntity; useType : boolean; index : integer);
    procedure ComposeAuditEventEntityDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirAuditEventEntityDetail; useType : boolean; index : integer);
    procedure ComposeAuditEvent(parent :  TTurtleComplex; parentType, name : String; value : TFhirAuditEvent; useType : boolean; index : integer);
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
    procedure ComposeBasic(parent :  TTurtleComplex; parentType, name : String; value : TFhirBasic; useType : boolean; index : integer);
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
    procedure ComposeBinary(parent :  TTurtleComplex; parentType, name : String; value : TFhirBinary; useType : boolean; index : integer);
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
    procedure ComposeBiologicallyDerivedProductCollection(parent :  TTurtleComplex; parentType, name : String; value : TFhirBiologicallyDerivedProductCollection; useType : boolean; index : integer);
    procedure ComposeBiologicallyDerivedProductProperty(parent :  TTurtleComplex; parentType, name : String; value : TFhirBiologicallyDerivedProductProperty; useType : boolean; index : integer);
    procedure ComposeBiologicallyDerivedProduct(parent :  TTurtleComplex; parentType, name : String; value : TFhirBiologicallyDerivedProduct; useType : boolean; index : integer);
{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
    procedure ComposeBodyStructureIncludedStructure(parent :  TTurtleComplex; parentType, name : String; value : TFhirBodyStructureIncludedStructure; useType : boolean; index : integer);
    procedure ComposeBodyStructureExcludedStructure(parent :  TTurtleComplex; parentType, name : String; value : TFhirBodyStructureExcludedStructure; useType : boolean; index : integer);
    procedure ComposeBodyStructure(parent :  TTurtleComplex; parentType, name : String; value : TFhirBodyStructure; useType : boolean; index : integer);
{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_BUNDLE}
    procedure ComposeBundleLink(parent :  TTurtleComplex; parentType, name : String; value : TFhirBundleLink; useType : boolean; index : integer);
    procedure ComposeBundleEntry(parent :  TTurtleComplex; parentType, name : String; value : TFhirBundleEntry; useType : boolean; index : integer);
    procedure ComposeBundleEntrySearch(parent :  TTurtleComplex; parentType, name : String; value : TFhirBundleEntrySearch; useType : boolean; index : integer);
    procedure ComposeBundleEntryRequest(parent :  TTurtleComplex; parentType, name : String; value : TFhirBundleEntryRequest; useType : boolean; index : integer);
    procedure ComposeBundleEntryResponse(parent :  TTurtleComplex; parentType, name : String; value : TFhirBundleEntryResponse; useType : boolean; index : integer);
    procedure ComposeBundle(parent :  TTurtleComplex; parentType, name : String; value : TFhirBundle; useType : boolean; index : integer);
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
    procedure ComposeCapabilityStatementSoftware(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementSoftware; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementImplementation(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementImplementation; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementRest(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementRest; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementRestSecurity(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementRestSecurity; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementRestResource(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementRestResource; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementRestResourceInteraction(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementRestResourceInteraction; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementRestResourceSearchParam(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementRestResourceSearchParam; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementRestResourceOperation(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementRestResourceOperation; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementRestInteraction(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementRestInteraction; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementMessaging(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementMessaging; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementMessagingEndpoint(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementMessagingEndpoint; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementMessagingSupportedMessage(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementMessagingSupportedMessage; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementDocument(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementDocument; useType : boolean; index : integer);
    procedure ComposeCapabilityStatement(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatement; useType : boolean; index : integer);
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
    procedure ComposeCarePlanActivity(parent :  TTurtleComplex; parentType, name : String; value : TFhirCarePlanActivity; useType : boolean; index : integer);
    procedure ComposeCarePlanActivityPlannedActivityDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirCarePlanActivityPlannedActivityDetail; useType : boolean; index : integer);
    procedure ComposeCarePlan(parent :  TTurtleComplex; parentType, name : String; value : TFhirCarePlan; useType : boolean; index : integer);
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
    procedure ComposeCareTeamParticipant(parent :  TTurtleComplex; parentType, name : String; value : TFhirCareTeamParticipant; useType : boolean; index : integer);
    procedure ComposeCareTeam(parent :  TTurtleComplex; parentType, name : String; value : TFhirCareTeam; useType : boolean; index : integer);
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CHARGEITEM}
    procedure ComposeChargeItemPerformer(parent :  TTurtleComplex; parentType, name : String; value : TFhirChargeItemPerformer; useType : boolean; index : integer);
    procedure ComposeChargeItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirChargeItem; useType : boolean; index : integer);
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
    procedure ComposeChargeItemDefinitionApplicability(parent :  TTurtleComplex; parentType, name : String; value : TFhirChargeItemDefinitionApplicability; useType : boolean; index : integer);
    procedure ComposeChargeItemDefinitionPropertyGroup(parent :  TTurtleComplex; parentType, name : String; value : TFhirChargeItemDefinitionPropertyGroup; useType : boolean; index : integer);
    procedure ComposeChargeItemDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirChargeItemDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CITATION}
    procedure ComposeCitationSummary(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationSummary; useType : boolean; index : integer);
    procedure ComposeCitationClassification(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationClassification; useType : boolean; index : integer);
    procedure ComposeCitationStatusDate(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationStatusDate; useType : boolean; index : integer);
    procedure ComposeCitationCitedArtifact(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifact; useType : boolean; index : integer);
    procedure ComposeCitationCitedArtifactVersion(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactVersion; useType : boolean; index : integer);
    procedure ComposeCitationCitedArtifactStatusDate(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactStatusDate; useType : boolean; index : integer);
    procedure ComposeCitationCitedArtifactTitle(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactTitle; useType : boolean; index : integer);
    procedure ComposeCitationCitedArtifactAbstract(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactAbstract; useType : boolean; index : integer);
    procedure ComposeCitationCitedArtifactPart(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactPart; useType : boolean; index : integer);
    procedure ComposeCitationCitedArtifactRelatesTo(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactRelatesTo; useType : boolean; index : integer);
    procedure ComposeCitationCitedArtifactPublicationForm(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactPublicationForm; useType : boolean; index : integer);
    procedure ComposeCitationCitedArtifactPublicationFormPublishedIn(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactPublicationFormPublishedIn; useType : boolean; index : integer);
    procedure ComposeCitationCitedArtifactWebLocation(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactWebLocation; useType : boolean; index : integer);
    procedure ComposeCitationCitedArtifactClassification(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactClassification; useType : boolean; index : integer);
    procedure ComposeCitationCitedArtifactContributorship(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactContributorship; useType : boolean; index : integer);
    procedure ComposeCitationCitedArtifactContributorshipEntry(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactContributorshipEntry; useType : boolean; index : integer);
    procedure ComposeCitationCitedArtifactContributorshipEntryContributionInstance(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactContributorshipEntryContributionInstance; useType : boolean; index : integer);
    procedure ComposeCitationCitedArtifactContributorshipSummary(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactContributorshipSummary; useType : boolean; index : integer);
    procedure ComposeCitation(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitation; useType : boolean; index : integer);
{$ENDIF FHIR_CITATION}
{$IFDEF FHIR_CLAIM}
    procedure ComposeClaimRelated(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimRelated; useType : boolean; index : integer);
    procedure ComposeClaimPayee(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimPayee; useType : boolean; index : integer);
    procedure ComposeClaimCareTeam(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimCareTeam; useType : boolean; index : integer);
    procedure ComposeClaimSupportingInfo(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimSupportingInfo; useType : boolean; index : integer);
    procedure ComposeClaimDiagnosis(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimDiagnosis; useType : boolean; index : integer);
    procedure ComposeClaimProcedure(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimProcedure; useType : boolean; index : integer);
    procedure ComposeClaimInsurance(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimInsurance; useType : boolean; index : integer);
    procedure ComposeClaimAccident(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimAccident; useType : boolean; index : integer);
    procedure ComposeClaimItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimItem; useType : boolean; index : integer);
    procedure ComposeClaimItemBodySite(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimItemBodySite; useType : boolean; index : integer);
    procedure ComposeClaimItemDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimItemDetail; useType : boolean; index : integer);
    procedure ComposeClaimItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimItemDetailSubDetail; useType : boolean; index : integer);
    procedure ComposeClaim(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaim; useType : boolean; index : integer);
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
    procedure ComposeClaimResponseItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponseItem; useType : boolean; index : integer);
    procedure ComposeClaimResponseItemAdjudication(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponseItemAdjudication; useType : boolean; index : integer);
    procedure ComposeClaimResponseItemDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponseItemDetail; useType : boolean; index : integer);
    procedure ComposeClaimResponseItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponseItemDetailSubDetail; useType : boolean; index : integer);
    procedure ComposeClaimResponseAddItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponseAddItem; useType : boolean; index : integer);
    procedure ComposeClaimResponseAddItemBodySite(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponseAddItemBodySite; useType : boolean; index : integer);
    procedure ComposeClaimResponseAddItemDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponseAddItemDetail; useType : boolean; index : integer);
    procedure ComposeClaimResponseAddItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponseAddItemDetailSubDetail; useType : boolean; index : integer);
    procedure ComposeClaimResponseTotal(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponseTotal; useType : boolean; index : integer);
    procedure ComposeClaimResponsePayment(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponsePayment; useType : boolean; index : integer);
    procedure ComposeClaimResponseProcessNote(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponseProcessNote; useType : boolean; index : integer);
    procedure ComposeClaimResponseInsurance(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponseInsurance; useType : boolean; index : integer);
    procedure ComposeClaimResponseError(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponseError; useType : boolean; index : integer);
    procedure ComposeClaimResponse(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponse; useType : boolean; index : integer);
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
    procedure ComposeClinicalImpressionFinding(parent :  TTurtleComplex; parentType, name : String; value : TFhirClinicalImpressionFinding; useType : boolean; index : integer);
    procedure ComposeClinicalImpression(parent :  TTurtleComplex; parentType, name : String; value : TFhirClinicalImpression; useType : boolean; index : integer);
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CLINICALUSEDEFINITION}
    procedure ComposeClinicalUseDefinitionContraindication(parent :  TTurtleComplex; parentType, name : String; value : TFhirClinicalUseDefinitionContraindication; useType : boolean; index : integer);
    procedure ComposeClinicalUseDefinitionContraindicationOtherTherapy(parent :  TTurtleComplex; parentType, name : String; value : TFhirClinicalUseDefinitionContraindicationOtherTherapy; useType : boolean; index : integer);
    procedure ComposeClinicalUseDefinitionIndication(parent :  TTurtleComplex; parentType, name : String; value : TFhirClinicalUseDefinitionIndication; useType : boolean; index : integer);
    procedure ComposeClinicalUseDefinitionInteraction(parent :  TTurtleComplex; parentType, name : String; value : TFhirClinicalUseDefinitionInteraction; useType : boolean; index : integer);
    procedure ComposeClinicalUseDefinitionInteractionInteractant(parent :  TTurtleComplex; parentType, name : String; value : TFhirClinicalUseDefinitionInteractionInteractant; useType : boolean; index : integer);
    procedure ComposeClinicalUseDefinitionUndesirableEffect(parent :  TTurtleComplex; parentType, name : String; value : TFhirClinicalUseDefinitionUndesirableEffect; useType : boolean; index : integer);
    procedure ComposeClinicalUseDefinitionWarning(parent :  TTurtleComplex; parentType, name : String; value : TFhirClinicalUseDefinitionWarning; useType : boolean; index : integer);
    procedure ComposeClinicalUseDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirClinicalUseDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_CLINICALUSEDEFINITION}
{$IFDEF FHIR_CODESYSTEM}
    procedure ComposeCodeSystemFilter(parent :  TTurtleComplex; parentType, name : String; value : TFhirCodeSystemFilter; useType : boolean; index : integer);
    procedure ComposeCodeSystemProperty(parent :  TTurtleComplex; parentType, name : String; value : TFhirCodeSystemProperty; useType : boolean; index : integer);
    procedure ComposeCodeSystemConcept(parent :  TTurtleComplex; parentType, name : String; value : TFhirCodeSystemConcept; useType : boolean; index : integer);
    procedure ComposeCodeSystemConceptDesignation(parent :  TTurtleComplex; parentType, name : String; value : TFhirCodeSystemConceptDesignation; useType : boolean; index : integer);
    procedure ComposeCodeSystemConceptProperty(parent :  TTurtleComplex; parentType, name : String; value : TFhirCodeSystemConceptProperty; useType : boolean; index : integer);
    procedure ComposeCodeSystem(parent :  TTurtleComplex; parentType, name : String; value : TFhirCodeSystem; useType : boolean; index : integer);
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
    procedure ComposeCommunicationPayload(parent :  TTurtleComplex; parentType, name : String; value : TFhirCommunicationPayload; useType : boolean; index : integer);
    procedure ComposeCommunication(parent :  TTurtleComplex; parentType, name : String; value : TFhirCommunication; useType : boolean; index : integer);
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
    procedure ComposeCommunicationRequestPayload(parent :  TTurtleComplex; parentType, name : String; value : TFhirCommunicationRequestPayload; useType : boolean; index : integer);
    procedure ComposeCommunicationRequest(parent :  TTurtleComplex; parentType, name : String; value : TFhirCommunicationRequest; useType : boolean; index : integer);
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
    procedure ComposeCompartmentDefinitionResource(parent :  TTurtleComplex; parentType, name : String; value : TFhirCompartmentDefinitionResource; useType : boolean; index : integer);
    procedure ComposeCompartmentDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirCompartmentDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
    procedure ComposeCompositionAttester(parent :  TTurtleComplex; parentType, name : String; value : TFhirCompositionAttester; useType : boolean; index : integer);
    procedure ComposeCompositionEvent(parent :  TTurtleComplex; parentType, name : String; value : TFhirCompositionEvent; useType : boolean; index : integer);
    procedure ComposeCompositionSection(parent :  TTurtleComplex; parentType, name : String; value : TFhirCompositionSection; useType : boolean; index : integer);
    procedure ComposeComposition(parent :  TTurtleComplex; parentType, name : String; value : TFhirComposition; useType : boolean; index : integer);
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
    procedure ComposeConceptMapGroup(parent :  TTurtleComplex; parentType, name : String; value : TFhirConceptMapGroup; useType : boolean; index : integer);
    procedure ComposeConceptMapGroupElement(parent :  TTurtleComplex; parentType, name : String; value : TFhirConceptMapGroupElement; useType : boolean; index : integer);
    procedure ComposeConceptMapGroupElementTarget(parent :  TTurtleComplex; parentType, name : String; value : TFhirConceptMapGroupElementTarget; useType : boolean; index : integer);
    procedure ComposeConceptMapGroupElementTargetDependsOn(parent :  TTurtleComplex; parentType, name : String; value : TFhirConceptMapGroupElementTargetDependsOn; useType : boolean; index : integer);
    procedure ComposeConceptMapGroupUnmapped(parent :  TTurtleComplex; parentType, name : String; value : TFhirConceptMapGroupUnmapped; useType : boolean; index : integer);
    procedure ComposeConceptMap(parent :  TTurtleComplex; parentType, name : String; value : TFhirConceptMap; useType : boolean; index : integer);
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
    procedure ComposeConditionParticipant(parent :  TTurtleComplex; parentType, name : String; value : TFhirConditionParticipant; useType : boolean; index : integer);
    procedure ComposeConditionStage(parent :  TTurtleComplex; parentType, name : String; value : TFhirConditionStage; useType : boolean; index : integer);
    procedure ComposeCondition(parent :  TTurtleComplex; parentType, name : String; value : TFhirCondition; useType : boolean; index : integer);
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONDITIONDEFINITION}
    procedure ComposeConditionDefinitionObservation(parent :  TTurtleComplex; parentType, name : String; value : TFhirConditionDefinitionObservation; useType : boolean; index : integer);
    procedure ComposeConditionDefinitionMedication(parent :  TTurtleComplex; parentType, name : String; value : TFhirConditionDefinitionMedication; useType : boolean; index : integer);
    procedure ComposeConditionDefinitionPrecondition(parent :  TTurtleComplex; parentType, name : String; value : TFhirConditionDefinitionPrecondition; useType : boolean; index : integer);
    procedure ComposeConditionDefinitionQuestionnaire(parent :  TTurtleComplex; parentType, name : String; value : TFhirConditionDefinitionQuestionnaire; useType : boolean; index : integer);
    procedure ComposeConditionDefinitionPlan(parent :  TTurtleComplex; parentType, name : String; value : TFhirConditionDefinitionPlan; useType : boolean; index : integer);
    procedure ComposeConditionDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirConditionDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_CONDITIONDEFINITION}
{$IFDEF FHIR_CONSENT}
    procedure ComposeConsentPolicyBasis(parent :  TTurtleComplex; parentType, name : String; value : TFhirConsentPolicyBasis; useType : boolean; index : integer);
    procedure ComposeConsentVerification(parent :  TTurtleComplex; parentType, name : String; value : TFhirConsentVerification; useType : boolean; index : integer);
    procedure ComposeConsentProvision(parent :  TTurtleComplex; parentType, name : String; value : TFhirConsentProvision; useType : boolean; index : integer);
    procedure ComposeConsentProvisionActor(parent :  TTurtleComplex; parentType, name : String; value : TFhirConsentProvisionActor; useType : boolean; index : integer);
    procedure ComposeConsentProvisionData(parent :  TTurtleComplex; parentType, name : String; value : TFhirConsentProvisionData; useType : boolean; index : integer);
    procedure ComposeConsent(parent :  TTurtleComplex; parentType, name : String; value : TFhirConsent; useType : boolean; index : integer);
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
    procedure ComposeContractContentDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractContentDefinition; useType : boolean; index : integer);
    procedure ComposeContractTerm(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractTerm; useType : boolean; index : integer);
    procedure ComposeContractTermSecurityLabel(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractTermSecurityLabel; useType : boolean; index : integer);
    procedure ComposeContractTermOffer(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractTermOffer; useType : boolean; index : integer);
    procedure ComposeContractTermOfferParty(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractTermOfferParty; useType : boolean; index : integer);
    procedure ComposeContractTermOfferAnswer(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractTermOfferAnswer; useType : boolean; index : integer);
    procedure ComposeContractTermAsset(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractTermAsset; useType : boolean; index : integer);
    procedure ComposeContractTermAssetContext(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractTermAssetContext; useType : boolean; index : integer);
    procedure ComposeContractTermAssetValuedItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractTermAssetValuedItem; useType : boolean; index : integer);
    procedure ComposeContractTermAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractTermAction; useType : boolean; index : integer);
    procedure ComposeContractTermActionSubject(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractTermActionSubject; useType : boolean; index : integer);
    procedure ComposeContractSigner(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractSigner; useType : boolean; index : integer);
    procedure ComposeContractFriendly(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractFriendly; useType : boolean; index : integer);
    procedure ComposeContractLegal(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractLegal; useType : boolean; index : integer);
    procedure ComposeContractRule(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractRule; useType : boolean; index : integer);
    procedure ComposeContract(parent :  TTurtleComplex; parentType, name : String; value : TFhirContract; useType : boolean; index : integer);
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
    procedure ComposeCoveragePaymentBy(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoveragePaymentBy; useType : boolean; index : integer);
    procedure ComposeCoverageClass(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageClass; useType : boolean; index : integer);
    procedure ComposeCoverageCostToBeneficiary(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageCostToBeneficiary; useType : boolean; index : integer);
    procedure ComposeCoverageCostToBeneficiaryException(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageCostToBeneficiaryException; useType : boolean; index : integer);
    procedure ComposeCoverage(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverage; useType : boolean; index : integer);
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
    procedure ComposeCoverageEligibilityRequestSupportingInfo(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageEligibilityRequestSupportingInfo; useType : boolean; index : integer);
    procedure ComposeCoverageEligibilityRequestInsurance(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageEligibilityRequestInsurance; useType : boolean; index : integer);
    procedure ComposeCoverageEligibilityRequestItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageEligibilityRequestItem; useType : boolean; index : integer);
    procedure ComposeCoverageEligibilityRequestItemDiagnosis(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageEligibilityRequestItemDiagnosis; useType : boolean; index : integer);
    procedure ComposeCoverageEligibilityRequest(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageEligibilityRequest; useType : boolean; index : integer);
{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
    procedure ComposeCoverageEligibilityResponseInsurance(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageEligibilityResponseInsurance; useType : boolean; index : integer);
    procedure ComposeCoverageEligibilityResponseInsuranceItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageEligibilityResponseInsuranceItem; useType : boolean; index : integer);
    procedure ComposeCoverageEligibilityResponseInsuranceItemBenefit(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageEligibilityResponseInsuranceItemBenefit; useType : boolean; index : integer);
    procedure ComposeCoverageEligibilityResponseError(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageEligibilityResponseError; useType : boolean; index : integer);
    procedure ComposeCoverageEligibilityResponse(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageEligibilityResponse; useType : boolean; index : integer);
{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_DETECTEDISSUE}
    procedure ComposeDetectedIssueEvidence(parent :  TTurtleComplex; parentType, name : String; value : TFhirDetectedIssueEvidence; useType : boolean; index : integer);
    procedure ComposeDetectedIssueMitigation(parent :  TTurtleComplex; parentType, name : String; value : TFhirDetectedIssueMitigation; useType : boolean; index : integer);
    procedure ComposeDetectedIssue(parent :  TTurtleComplex; parentType, name : String; value : TFhirDetectedIssue; useType : boolean; index : integer);
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
    procedure ComposeDeviceUdiCarrier(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceUdiCarrier; useType : boolean; index : integer);
    procedure ComposeDeviceDeviceName(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDeviceName; useType : boolean; index : integer);
    procedure ComposeDeviceVersion(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceVersion; useType : boolean; index : integer);
    procedure ComposeDeviceSpecialization(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceSpecialization; useType : boolean; index : integer);
    procedure ComposeDeviceProperty(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceProperty; useType : boolean; index : integer);
    procedure ComposeDeviceOperation(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceOperation; useType : boolean; index : integer);
    procedure ComposeDeviceAssociation(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceAssociation; useType : boolean; index : integer);
    procedure ComposeDevice(parent :  TTurtleComplex; parentType, name : String; value : TFhirDevice; useType : boolean; index : integer);
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
    procedure ComposeDeviceDefinitionUdiDeviceIdentifier(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionUdiDeviceIdentifier; useType : boolean; index : integer);
    procedure ComposeDeviceDefinitionUdiDeviceIdentifierMarketDistribution(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution; useType : boolean; index : integer);
    procedure ComposeDeviceDefinitionRegulatoryIdentifier(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionRegulatoryIdentifier; useType : boolean; index : integer);
    procedure ComposeDeviceDefinitionDeviceName(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionDeviceName; useType : boolean; index : integer);
    procedure ComposeDeviceDefinitionClassification(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionClassification; useType : boolean; index : integer);
    procedure ComposeDeviceDefinitionHasPart(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionHasPart; useType : boolean; index : integer);
    procedure ComposeDeviceDefinitionPackaging(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionPackaging; useType : boolean; index : integer);
    procedure ComposeDeviceDefinitionPackagingDistributor(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionPackagingDistributor; useType : boolean; index : integer);
    procedure ComposeDeviceDefinitionVersion(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionVersion; useType : boolean; index : integer);
    procedure ComposeDeviceDefinitionProperty(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionProperty; useType : boolean; index : integer);
    procedure ComposeDeviceDefinitionLink(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionLink; useType : boolean; index : integer);
    procedure ComposeDeviceDefinitionMaterial(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionMaterial; useType : boolean; index : integer);
    procedure ComposeDeviceDefinitionGuideline(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionGuideline; useType : boolean; index : integer);
    procedure ComposeDeviceDefinitionCorrectiveAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionCorrectiveAction; useType : boolean; index : integer);
    procedure ComposeDeviceDefinitionChargeItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionChargeItem; useType : boolean; index : integer);
    procedure ComposeDeviceDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEDISPENSE}
    procedure ComposeDeviceDispensePerformer(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDispensePerformer; useType : boolean; index : integer);
    procedure ComposeDeviceDispense(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDispense; useType : boolean; index : integer);
{$ENDIF FHIR_DEVICEDISPENSE}
{$IFDEF FHIR_DEVICEMETRIC}
    procedure ComposeDeviceMetricCalibration(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceMetricCalibration; useType : boolean; index : integer);
    procedure ComposeDeviceMetric(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceMetric; useType : boolean; index : integer);
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
    procedure ComposeDeviceRequestParameter(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceRequestParameter; useType : boolean; index : integer);
    procedure ComposeDeviceRequest(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceRequest; useType : boolean; index : integer);
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSAGE}
    procedure ComposeDeviceUsageAdherence(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceUsageAdherence; useType : boolean; index : integer);
    procedure ComposeDeviceUsage(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceUsage; useType : boolean; index : integer);
{$ENDIF FHIR_DEVICEUSAGE}
{$IFDEF FHIR_DIAGNOSTICREPORT}
    procedure ComposeDiagnosticReportSupportingInfo(parent :  TTurtleComplex; parentType, name : String; value : TFhirDiagnosticReportSupportingInfo; useType : boolean; index : integer);
    procedure ComposeDiagnosticReportMedia(parent :  TTurtleComplex; parentType, name : String; value : TFhirDiagnosticReportMedia; useType : boolean; index : integer);
    procedure ComposeDiagnosticReport(parent :  TTurtleComplex; parentType, name : String; value : TFhirDiagnosticReport; useType : boolean; index : integer);
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
    procedure ComposeDocumentManifestRelated(parent :  TTurtleComplex; parentType, name : String; value : TFhirDocumentManifestRelated; useType : boolean; index : integer);
    procedure ComposeDocumentManifest(parent :  TTurtleComplex; parentType, name : String; value : TFhirDocumentManifest; useType : boolean; index : integer);
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
    procedure ComposeDocumentReferenceAttester(parent :  TTurtleComplex; parentType, name : String; value : TFhirDocumentReferenceAttester; useType : boolean; index : integer);
    procedure ComposeDocumentReferenceRelatesTo(parent :  TTurtleComplex; parentType, name : String; value : TFhirDocumentReferenceRelatesTo; useType : boolean; index : integer);
    procedure ComposeDocumentReferenceContent(parent :  TTurtleComplex; parentType, name : String; value : TFhirDocumentReferenceContent; useType : boolean; index : integer);
    procedure ComposeDocumentReferenceContentProfile(parent :  TTurtleComplex; parentType, name : String; value : TFhirDocumentReferenceContentProfile; useType : boolean; index : integer);
    procedure ComposeDocumentReference(parent :  TTurtleComplex; parentType, name : String; value : TFhirDocumentReference; useType : boolean; index : integer);
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ENCOUNTER}
    procedure ComposeEncounterStatusHistory(parent :  TTurtleComplex; parentType, name : String; value : TFhirEncounterStatusHistory; useType : boolean; index : integer);
    procedure ComposeEncounterClassHistory(parent :  TTurtleComplex; parentType, name : String; value : TFhirEncounterClassHistory; useType : boolean; index : integer);
    procedure ComposeEncounterParticipant(parent :  TTurtleComplex; parentType, name : String; value : TFhirEncounterParticipant; useType : boolean; index : integer);
    procedure ComposeEncounterDiagnosis(parent :  TTurtleComplex; parentType, name : String; value : TFhirEncounterDiagnosis; useType : boolean; index : integer);
    procedure ComposeEncounterAdmission(parent :  TTurtleComplex; parentType, name : String; value : TFhirEncounterAdmission; useType : boolean; index : integer);
    procedure ComposeEncounterLocation(parent :  TTurtleComplex; parentType, name : String; value : TFhirEncounterLocation; useType : boolean; index : integer);
    procedure ComposeEncounter(parent :  TTurtleComplex; parentType, name : String; value : TFhirEncounter; useType : boolean; index : integer);
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
    procedure ComposeEndpoint(parent :  TTurtleComplex; parentType, name : String; value : TFhirEndpoint; useType : boolean; index : integer);
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
    procedure ComposeEnrollmentRequest(parent :  TTurtleComplex; parentType, name : String; value : TFhirEnrollmentRequest; useType : boolean; index : integer);
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
    procedure ComposeEnrollmentResponse(parent :  TTurtleComplex; parentType, name : String; value : TFhirEnrollmentResponse; useType : boolean; index : integer);
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
    procedure ComposeEpisodeOfCareStatusHistory(parent :  TTurtleComplex; parentType, name : String; value : TFhirEpisodeOfCareStatusHistory; useType : boolean; index : integer);
    procedure ComposeEpisodeOfCareDiagnosis(parent :  TTurtleComplex; parentType, name : String; value : TFhirEpisodeOfCareDiagnosis; useType : boolean; index : integer);
    procedure ComposeEpisodeOfCare(parent :  TTurtleComplex; parentType, name : String; value : TFhirEpisodeOfCare; useType : boolean; index : integer);
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EVENTDEFINITION}
    procedure ComposeEventDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirEventDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EVIDENCE}
    procedure ComposeEvidenceVariableDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceVariableDefinition; useType : boolean; index : integer);
    procedure ComposeEvidenceStatistic(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceStatistic; useType : boolean; index : integer);
    procedure ComposeEvidenceStatisticSampleSize(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceStatisticSampleSize; useType : boolean; index : integer);
    procedure ComposeEvidenceStatisticAttributeEstimate(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceStatisticAttributeEstimate; useType : boolean; index : integer);
    procedure ComposeEvidenceStatisticModelCharacteristic(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceStatisticModelCharacteristic; useType : boolean; index : integer);
    procedure ComposeEvidenceStatisticModelCharacteristicVariable(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceStatisticModelCharacteristicVariable; useType : boolean; index : integer);
    procedure ComposeEvidenceCertainty(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceCertainty; useType : boolean; index : integer);
    procedure ComposeEvidence(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidence; useType : boolean; index : integer);
{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEREPORT}
    procedure ComposeEvidenceReportSubject(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceReportSubject; useType : boolean; index : integer);
    procedure ComposeEvidenceReportSubjectCharacteristic(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceReportSubjectCharacteristic; useType : boolean; index : integer);
    procedure ComposeEvidenceReportRelatesTo(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceReportRelatesTo; useType : boolean; index : integer);
    procedure ComposeEvidenceReportRelatesToTarget(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceReportRelatesToTarget; useType : boolean; index : integer);
    procedure ComposeEvidenceReportSection(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceReportSection; useType : boolean; index : integer);
    procedure ComposeEvidenceReport(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceReport; useType : boolean; index : integer);
{$ENDIF FHIR_EVIDENCEREPORT}
{$IFDEF FHIR_EVIDENCEVARIABLE}
    procedure ComposeEvidenceVariableCharacteristic(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceVariableCharacteristic; useType : boolean; index : integer);
    procedure ComposeEvidenceVariableCharacteristicDefinitionByTypeAndValue(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue; useType : boolean; index : integer);
    procedure ComposeEvidenceVariableCharacteristicDefinitionByCombination(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceVariableCharacteristicDefinitionByCombination; useType : boolean; index : integer);
    procedure ComposeEvidenceVariableCharacteristicTimeFromEvent(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceVariableCharacteristicTimeFromEvent; useType : boolean; index : integer);
    procedure ComposeEvidenceVariableCategory(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceVariableCategory; useType : boolean; index : integer);
    procedure ComposeEvidenceVariable(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceVariable; useType : boolean; index : integer);
{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_EXAMPLESCENARIO}
    procedure ComposeExampleScenarioActor(parent :  TTurtleComplex; parentType, name : String; value : TFhirExampleScenarioActor; useType : boolean; index : integer);
    procedure ComposeExampleScenarioInstance(parent :  TTurtleComplex; parentType, name : String; value : TFhirExampleScenarioInstance; useType : boolean; index : integer);
    procedure ComposeExampleScenarioInstanceVersion(parent :  TTurtleComplex; parentType, name : String; value : TFhirExampleScenarioInstanceVersion; useType : boolean; index : integer);
    procedure ComposeExampleScenarioInstanceContainedInstance(parent :  TTurtleComplex; parentType, name : String; value : TFhirExampleScenarioInstanceContainedInstance; useType : boolean; index : integer);
    procedure ComposeExampleScenarioProcess(parent :  TTurtleComplex; parentType, name : String; value : TFhirExampleScenarioProcess; useType : boolean; index : integer);
    procedure ComposeExampleScenarioProcessStep(parent :  TTurtleComplex; parentType, name : String; value : TFhirExampleScenarioProcessStep; useType : boolean; index : integer);
    procedure ComposeExampleScenarioProcessStepOperation(parent :  TTurtleComplex; parentType, name : String; value : TFhirExampleScenarioProcessStepOperation; useType : boolean; index : integer);
    procedure ComposeExampleScenarioProcessStepAlternative(parent :  TTurtleComplex; parentType, name : String; value : TFhirExampleScenarioProcessStepAlternative; useType : boolean; index : integer);
    procedure ComposeExampleScenario(parent :  TTurtleComplex; parentType, name : String; value : TFhirExampleScenario; useType : boolean; index : integer);
{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
    procedure ComposeExplanationOfBenefitRelated(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitRelated; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitPayee(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitPayee; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitCareTeam(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitCareTeam; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitSupportingInfo(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitSupportingInfo; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitDiagnosis(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitDiagnosis; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitProcedure(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitProcedure; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitInsurance(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitInsurance; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitAccident(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitAccident; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitItem; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitItemBodySite(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitItemBodySite; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitItemAdjudication(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitItemAdjudication; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitItemDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitItemDetail; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitItemDetailSubDetail; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitAddItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitAddItem; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitAddItemBodySite(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitAddItemBodySite; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitAddItemDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitAddItemDetail; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitAddItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitAddItemDetailSubDetail; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitTotal(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitTotal; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitPayment(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitPayment; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitProcessNote(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitProcessNote; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitBenefitBalance(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitBenefitBalance; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitBenefitBalanceFinancial(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitBenefitBalanceFinancial; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefit(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefit; useType : boolean; index : integer);
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
    procedure ComposeFamilyMemberHistoryCondition(parent :  TTurtleComplex; parentType, name : String; value : TFhirFamilyMemberHistoryCondition; useType : boolean; index : integer);
    procedure ComposeFamilyMemberHistoryProcedure(parent :  TTurtleComplex; parentType, name : String; value : TFhirFamilyMemberHistoryProcedure; useType : boolean; index : integer);
    procedure ComposeFamilyMemberHistory(parent :  TTurtleComplex; parentType, name : String; value : TFhirFamilyMemberHistory; useType : boolean; index : integer);
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
    procedure ComposeFlag(parent :  TTurtleComplex; parentType, name : String; value : TFhirFlag; useType : boolean; index : integer);
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_FORMULARYITEM}
    procedure ComposeFormularyItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirFormularyItem; useType : boolean; index : integer);
{$ENDIF FHIR_FORMULARYITEM}
{$IFDEF FHIR_GENOMICSTUDY}
    procedure ComposeGenomicStudyAnalysis(parent :  TTurtleComplex; parentType, name : String; value : TFhirGenomicStudyAnalysis; useType : boolean; index : integer);
    procedure ComposeGenomicStudyAnalysisInput(parent :  TTurtleComplex; parentType, name : String; value : TFhirGenomicStudyAnalysisInput; useType : boolean; index : integer);
    procedure ComposeGenomicStudyAnalysisOutput(parent :  TTurtleComplex; parentType, name : String; value : TFhirGenomicStudyAnalysisOutput; useType : boolean; index : integer);
    procedure ComposeGenomicStudyAnalysisPerformer(parent :  TTurtleComplex; parentType, name : String; value : TFhirGenomicStudyAnalysisPerformer; useType : boolean; index : integer);
    procedure ComposeGenomicStudyAnalysisDevice(parent :  TTurtleComplex; parentType, name : String; value : TFhirGenomicStudyAnalysisDevice; useType : boolean; index : integer);
    procedure ComposeGenomicStudy(parent :  TTurtleComplex; parentType, name : String; value : TFhirGenomicStudy; useType : boolean; index : integer);
{$ENDIF FHIR_GENOMICSTUDY}
{$IFDEF FHIR_GOAL}
    procedure ComposeGoalTarget(parent :  TTurtleComplex; parentType, name : String; value : TFhirGoalTarget; useType : boolean; index : integer);
    procedure ComposeGoal(parent :  TTurtleComplex; parentType, name : String; value : TFhirGoal; useType : boolean; index : integer);
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
    procedure ComposeGraphDefinitionLink(parent :  TTurtleComplex; parentType, name : String; value : TFhirGraphDefinitionLink; useType : boolean; index : integer);
    procedure ComposeGraphDefinitionLinkTarget(parent :  TTurtleComplex; parentType, name : String; value : TFhirGraphDefinitionLinkTarget; useType : boolean; index : integer);
    procedure ComposeGraphDefinitionLinkTargetCompartment(parent :  TTurtleComplex; parentType, name : String; value : TFhirGraphDefinitionLinkTargetCompartment; useType : boolean; index : integer);
    procedure ComposeGraphDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirGraphDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
    procedure ComposeGroupCharacteristic(parent :  TTurtleComplex; parentType, name : String; value : TFhirGroupCharacteristic; useType : boolean; index : integer);
    procedure ComposeGroupMember(parent :  TTurtleComplex; parentType, name : String; value : TFhirGroupMember; useType : boolean; index : integer);
    procedure ComposeGroup(parent :  TTurtleComplex; parentType, name : String; value : TFhirGroup; useType : boolean; index : integer);
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
    procedure ComposeGuidanceResponse(parent :  TTurtleComplex; parentType, name : String; value : TFhirGuidanceResponse; useType : boolean; index : integer);
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
    procedure ComposeHealthcareServiceEligibility(parent :  TTurtleComplex; parentType, name : String; value : TFhirHealthcareServiceEligibility; useType : boolean; index : integer);
    procedure ComposeHealthcareService(parent :  TTurtleComplex; parentType, name : String; value : TFhirHealthcareService; useType : boolean; index : integer);
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGSELECTION}
    procedure ComposeImagingSelectionPerformer(parent :  TTurtleComplex; parentType, name : String; value : TFhirImagingSelectionPerformer; useType : boolean; index : integer);
    procedure ComposeImagingSelectionInstance(parent :  TTurtleComplex; parentType, name : String; value : TFhirImagingSelectionInstance; useType : boolean; index : integer);
    procedure ComposeImagingSelectionInstanceImageRegion(parent :  TTurtleComplex; parentType, name : String; value : TFhirImagingSelectionInstanceImageRegion; useType : boolean; index : integer);
    procedure ComposeImagingSelectionImageRegion(parent :  TTurtleComplex; parentType, name : String; value : TFhirImagingSelectionImageRegion; useType : boolean; index : integer);
    procedure ComposeImagingSelection(parent :  TTurtleComplex; parentType, name : String; value : TFhirImagingSelection; useType : boolean; index : integer);
{$ENDIF FHIR_IMAGINGSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
    procedure ComposeImagingStudySeries(parent :  TTurtleComplex; parentType, name : String; value : TFhirImagingStudySeries; useType : boolean; index : integer);
    procedure ComposeImagingStudySeriesPerformer(parent :  TTurtleComplex; parentType, name : String; value : TFhirImagingStudySeriesPerformer; useType : boolean; index : integer);
    procedure ComposeImagingStudySeriesInstance(parent :  TTurtleComplex; parentType, name : String; value : TFhirImagingStudySeriesInstance; useType : boolean; index : integer);
    procedure ComposeImagingStudy(parent :  TTurtleComplex; parentType, name : String; value : TFhirImagingStudy; useType : boolean; index : integer);
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
    procedure ComposeImmunizationPerformer(parent :  TTurtleComplex; parentType, name : String; value : TFhirImmunizationPerformer; useType : boolean; index : integer);
    procedure ComposeImmunizationProgramEligibility(parent :  TTurtleComplex; parentType, name : String; value : TFhirImmunizationProgramEligibility; useType : boolean; index : integer);
    procedure ComposeImmunizationReaction(parent :  TTurtleComplex; parentType, name : String; value : TFhirImmunizationReaction; useType : boolean; index : integer);
    procedure ComposeImmunizationProtocolApplied(parent :  TTurtleComplex; parentType, name : String; value : TFhirImmunizationProtocolApplied; useType : boolean; index : integer);
    procedure ComposeImmunization(parent :  TTurtleComplex; parentType, name : String; value : TFhirImmunization; useType : boolean; index : integer);
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
    procedure ComposeImmunizationEvaluation(parent :  TTurtleComplex; parentType, name : String; value : TFhirImmunizationEvaluation; useType : boolean; index : integer);
{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
    procedure ComposeImmunizationRecommendationRecommendation(parent :  TTurtleComplex; parentType, name : String; value : TFhirImmunizationRecommendationRecommendation; useType : boolean; index : integer);
    procedure ComposeImmunizationRecommendationRecommendationDateCriterion(parent :  TTurtleComplex; parentType, name : String; value : TFhirImmunizationRecommendationRecommendationDateCriterion; useType : boolean; index : integer);
    procedure ComposeImmunizationRecommendation(parent :  TTurtleComplex; parentType, name : String; value : TFhirImmunizationRecommendation; useType : boolean; index : integer);
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
    procedure ComposeImplementationGuideDependsOn(parent :  TTurtleComplex; parentType, name : String; value : TFhirImplementationGuideDependsOn; useType : boolean; index : integer);
    procedure ComposeImplementationGuideGlobal(parent :  TTurtleComplex; parentType, name : String; value : TFhirImplementationGuideGlobal; useType : boolean; index : integer);
    procedure ComposeImplementationGuideDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirImplementationGuideDefinition; useType : boolean; index : integer);
    procedure ComposeImplementationGuideDefinitionGrouping(parent :  TTurtleComplex; parentType, name : String; value : TFhirImplementationGuideDefinitionGrouping; useType : boolean; index : integer);
    procedure ComposeImplementationGuideDefinitionResource(parent :  TTurtleComplex; parentType, name : String; value : TFhirImplementationGuideDefinitionResource; useType : boolean; index : integer);
    procedure ComposeImplementationGuideDefinitionPage(parent :  TTurtleComplex; parentType, name : String; value : TFhirImplementationGuideDefinitionPage; useType : boolean; index : integer);
    procedure ComposeImplementationGuideDefinitionParameter(parent :  TTurtleComplex; parentType, name : String; value : TFhirImplementationGuideDefinitionParameter; useType : boolean; index : integer);
    procedure ComposeImplementationGuideDefinitionTemplate(parent :  TTurtleComplex; parentType, name : String; value : TFhirImplementationGuideDefinitionTemplate; useType : boolean; index : integer);
    procedure ComposeImplementationGuideManifest(parent :  TTurtleComplex; parentType, name : String; value : TFhirImplementationGuideManifest; useType : boolean; index : integer);
    procedure ComposeImplementationGuideManifestResource(parent :  TTurtleComplex; parentType, name : String; value : TFhirImplementationGuideManifestResource; useType : boolean; index : integer);
    procedure ComposeImplementationGuideManifestPage(parent :  TTurtleComplex; parentType, name : String; value : TFhirImplementationGuideManifestPage; useType : boolean; index : integer);
    procedure ComposeImplementationGuide(parent :  TTurtleComplex; parentType, name : String; value : TFhirImplementationGuide; useType : boolean; index : integer);
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_INGREDIENT}
    procedure ComposeIngredientManufacturer(parent :  TTurtleComplex; parentType, name : String; value : TFhirIngredientManufacturer; useType : boolean; index : integer);
    procedure ComposeIngredientSubstance(parent :  TTurtleComplex; parentType, name : String; value : TFhirIngredientSubstance; useType : boolean; index : integer);
    procedure ComposeIngredientSubstanceStrength(parent :  TTurtleComplex; parentType, name : String; value : TFhirIngredientSubstanceStrength; useType : boolean; index : integer);
    procedure ComposeIngredientSubstanceStrengthReferenceStrength(parent :  TTurtleComplex; parentType, name : String; value : TFhirIngredientSubstanceStrengthReferenceStrength; useType : boolean; index : integer);
    procedure ComposeIngredient(parent :  TTurtleComplex; parentType, name : String; value : TFhirIngredient; useType : boolean; index : integer);
{$ENDIF FHIR_INGREDIENT}
{$IFDEF FHIR_INSURANCEPLAN}
    procedure ComposeInsurancePlanCoverage(parent :  TTurtleComplex; parentType, name : String; value : TFhirInsurancePlanCoverage; useType : boolean; index : integer);
    procedure ComposeInsurancePlanCoverageBenefit(parent :  TTurtleComplex; parentType, name : String; value : TFhirInsurancePlanCoverageBenefit; useType : boolean; index : integer);
    procedure ComposeInsurancePlanCoverageBenefitLimit(parent :  TTurtleComplex; parentType, name : String; value : TFhirInsurancePlanCoverageBenefitLimit; useType : boolean; index : integer);
    procedure ComposeInsurancePlanPlan(parent :  TTurtleComplex; parentType, name : String; value : TFhirInsurancePlanPlan; useType : boolean; index : integer);
    procedure ComposeInsurancePlanPlanGeneralCost(parent :  TTurtleComplex; parentType, name : String; value : TFhirInsurancePlanPlanGeneralCost; useType : boolean; index : integer);
    procedure ComposeInsurancePlanPlanSpecificCost(parent :  TTurtleComplex; parentType, name : String; value : TFhirInsurancePlanPlanSpecificCost; useType : boolean; index : integer);
    procedure ComposeInsurancePlanPlanSpecificCostBenefit(parent :  TTurtleComplex; parentType, name : String; value : TFhirInsurancePlanPlanSpecificCostBenefit; useType : boolean; index : integer);
    procedure ComposeInsurancePlanPlanSpecificCostBenefitCost(parent :  TTurtleComplex; parentType, name : String; value : TFhirInsurancePlanPlanSpecificCostBenefitCost; useType : boolean; index : integer);
    procedure ComposeInsurancePlan(parent :  TTurtleComplex; parentType, name : String; value : TFhirInsurancePlan; useType : boolean; index : integer);
{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVENTORYREPORT}
    procedure ComposeInventoryReportInventoryListing(parent :  TTurtleComplex; parentType, name : String; value : TFhirInventoryReportInventoryListing; useType : boolean; index : integer);
    procedure ComposeInventoryReportInventoryListingItems(parent :  TTurtleComplex; parentType, name : String; value : TFhirInventoryReportInventoryListingItems; useType : boolean; index : integer);
    procedure ComposeInventoryReport(parent :  TTurtleComplex; parentType, name : String; value : TFhirInventoryReport; useType : boolean; index : integer);
{$ENDIF FHIR_INVENTORYREPORT}
{$IFDEF FHIR_INVOICE}
    procedure ComposeInvoiceParticipant(parent :  TTurtleComplex; parentType, name : String; value : TFhirInvoiceParticipant; useType : boolean; index : integer);
    procedure ComposeInvoiceLineItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirInvoiceLineItem; useType : boolean; index : integer);
    procedure ComposeInvoice(parent :  TTurtleComplex; parentType, name : String; value : TFhirInvoice; useType : boolean; index : integer);
{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_LIBRARY}
    procedure ComposeLibrary(parent :  TTurtleComplex; parentType, name : String; value : TFhirLibrary; useType : boolean; index : integer);
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
    procedure ComposeLinkageItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirLinkageItem; useType : boolean; index : integer);
    procedure ComposeLinkage(parent :  TTurtleComplex; parentType, name : String; value : TFhirLinkage; useType : boolean; index : integer);
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
    procedure ComposeListEntry(parent :  TTurtleComplex; parentType, name : String; value : TFhirListEntry; useType : boolean; index : integer);
    procedure ComposeList(parent :  TTurtleComplex; parentType, name : String; value : TFhirList; useType : boolean; index : integer);
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
    procedure ComposeLocationPosition(parent :  TTurtleComplex; parentType, name : String; value : TFhirLocationPosition; useType : boolean; index : integer);
    procedure ComposeLocation(parent :  TTurtleComplex; parentType, name : String; value : TFhirLocation; useType : boolean; index : integer);
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MANUFACTUREDITEMDEFINITION}
    procedure ComposeManufacturedItemDefinitionProperty(parent :  TTurtleComplex; parentType, name : String; value : TFhirManufacturedItemDefinitionProperty; useType : boolean; index : integer);
    procedure ComposeManufacturedItemDefinitionComponent(parent :  TTurtleComplex; parentType, name : String; value : TFhirManufacturedItemDefinitionComponent; useType : boolean; index : integer);
    procedure ComposeManufacturedItemDefinitionComponentConstituent(parent :  TTurtleComplex; parentType, name : String; value : TFhirManufacturedItemDefinitionComponentConstituent; useType : boolean; index : integer);
    procedure ComposeManufacturedItemDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirManufacturedItemDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_MANUFACTUREDITEMDEFINITION}
{$IFDEF FHIR_MEASURE}
    procedure ComposeMeasureTerm(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureTerm; useType : boolean; index : integer);
    procedure ComposeMeasureGroup(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureGroup; useType : boolean; index : integer);
    procedure ComposeMeasureGroupPopulation(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureGroupPopulation; useType : boolean; index : integer);
    procedure ComposeMeasureGroupStratifier(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureGroupStratifier; useType : boolean; index : integer);
    procedure ComposeMeasureGroupStratifierComponent(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureGroupStratifierComponent; useType : boolean; index : integer);
    procedure ComposeMeasureSupplementalData(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureSupplementalData; useType : boolean; index : integer);
    procedure ComposeMeasure(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasure; useType : boolean; index : integer);
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
    procedure ComposeMeasureReportGroup(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureReportGroup; useType : boolean; index : integer);
    procedure ComposeMeasureReportGroupPopulation(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureReportGroupPopulation; useType : boolean; index : integer);
    procedure ComposeMeasureReportGroupStratifier(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureReportGroupStratifier; useType : boolean; index : integer);
    procedure ComposeMeasureReportGroupStratifierStratum(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureReportGroupStratifierStratum; useType : boolean; index : integer);
    procedure ComposeMeasureReportGroupStratifierStratumComponent(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureReportGroupStratifierStratumComponent; useType : boolean; index : integer);
    procedure ComposeMeasureReportGroupStratifierStratumPopulation(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureReportGroupStratifierStratumPopulation; useType : boolean; index : integer);
    procedure ComposeMeasureReport(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureReport; useType : boolean; index : integer);
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDICATION}
    procedure ComposeMedicationIngredient(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationIngredient; useType : boolean; index : integer);
    procedure ComposeMedicationBatch(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationBatch; useType : boolean; index : integer);
    procedure ComposeMedication(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedication; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
    procedure ComposeMedicationAdministrationPerformer(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationAdministrationPerformer; useType : boolean; index : integer);
    procedure ComposeMedicationAdministrationDosage(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationAdministrationDosage; useType : boolean; index : integer);
    procedure ComposeMedicationAdministration(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationAdministration; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
    procedure ComposeMedicationDispensePerformer(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationDispensePerformer; useType : boolean; index : integer);
    procedure ComposeMedicationDispenseSubstitution(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationDispenseSubstitution; useType : boolean; index : integer);
    procedure ComposeMedicationDispense(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationDispense; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
    procedure ComposeMedicationKnowledgeRelatedMedicationKnowledge(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeRelatedMedicationKnowledge; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeMonograph(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeMonograph; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeCost(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeCost; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeMonitoringProgram(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeMonitoringProgram; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeIndicationGuideline(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeIndicationGuideline; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeIndicationGuidelineDosingGuideline(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeMedicineClassification(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeMedicineClassification; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgePackaging(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgePackaging; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeStorageGuideline(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeStorageGuideline; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeStorageGuidelineEnvironmentalSetting(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeRegulatory(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeRegulatory; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeRegulatorySubstitution(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeRegulatorySubstitution; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeRegulatoryMaxDispense(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeRegulatoryMaxDispense; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeDefinitional(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeDefinitional; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeDefinitionalIngredient(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeDefinitionalIngredient; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeDefinitionalDrugCharacteristic(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledge(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledge; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICATIONREQUEST}
    procedure ComposeMedicationRequestDose(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationRequestDose; useType : boolean; index : integer);
    procedure ComposeMedicationRequestDispenseRequest(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationRequestDispenseRequest; useType : boolean; index : integer);
    procedure ComposeMedicationRequestDispenseRequestInitialFill(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationRequestDispenseRequestInitialFill; useType : boolean; index : integer);
    procedure ComposeMedicationRequestSubstitution(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationRequestSubstitution; useType : boolean; index : integer);
    procedure ComposeMedicationRequest(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationRequest; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONUSAGE}
    procedure ComposeMedicationUsageAdherence(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationUsageAdherence; useType : boolean; index : integer);
    procedure ComposeMedicationUsage(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationUsage; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICATIONUSAGE}
{$IFDEF FHIR_MEDICINALPRODUCTDEFINITION}
    procedure ComposeMedicinalProductDefinitionContact(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicinalProductDefinitionContact; useType : boolean; index : integer);
    procedure ComposeMedicinalProductDefinitionName(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicinalProductDefinitionName; useType : boolean; index : integer);
    procedure ComposeMedicinalProductDefinitionNamePart(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicinalProductDefinitionNamePart; useType : boolean; index : integer);
    procedure ComposeMedicinalProductDefinitionNameUsage(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicinalProductDefinitionNameUsage; useType : boolean; index : integer);
    procedure ComposeMedicinalProductDefinitionCrossReference(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicinalProductDefinitionCrossReference; useType : boolean; index : integer);
    procedure ComposeMedicinalProductDefinitionOperation(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicinalProductDefinitionOperation; useType : boolean; index : integer);
    procedure ComposeMedicinalProductDefinitionCharacteristic(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicinalProductDefinitionCharacteristic; useType : boolean; index : integer);
    procedure ComposeMedicinalProductDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicinalProductDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICINALPRODUCTDEFINITION}
{$IFDEF FHIR_MESSAGEDEFINITION}
    procedure ComposeMessageDefinitionFocus(parent :  TTurtleComplex; parentType, name : String; value : TFhirMessageDefinitionFocus; useType : boolean; index : integer);
    procedure ComposeMessageDefinitionAllowedResponse(parent :  TTurtleComplex; parentType, name : String; value : TFhirMessageDefinitionAllowedResponse; useType : boolean; index : integer);
    procedure ComposeMessageDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirMessageDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
    procedure ComposeMessageHeaderDestination(parent :  TTurtleComplex; parentType, name : String; value : TFhirMessageHeaderDestination; useType : boolean; index : integer);
    procedure ComposeMessageHeaderSource(parent :  TTurtleComplex; parentType, name : String; value : TFhirMessageHeaderSource; useType : boolean; index : integer);
    procedure ComposeMessageHeaderResponse(parent :  TTurtleComplex; parentType, name : String; value : TFhirMessageHeaderResponse; useType : boolean; index : integer);
    procedure ComposeMessageHeader(parent :  TTurtleComplex; parentType, name : String; value : TFhirMessageHeader; useType : boolean; index : integer);
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_MOLECULARSEQUENCE}
    procedure ComposeMolecularSequenceRelative(parent :  TTurtleComplex; parentType, name : String; value : TFhirMolecularSequenceRelative; useType : boolean; index : integer);
    procedure ComposeMolecularSequenceRelativeStartingSequence(parent :  TTurtleComplex; parentType, name : String; value : TFhirMolecularSequenceRelativeStartingSequence; useType : boolean; index : integer);
    procedure ComposeMolecularSequenceRelativeEdit(parent :  TTurtleComplex; parentType, name : String; value : TFhirMolecularSequenceRelativeEdit; useType : boolean; index : integer);
    procedure ComposeMolecularSequence(parent :  TTurtleComplex; parentType, name : String; value : TFhirMolecularSequence; useType : boolean; index : integer);
{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NAMINGSYSTEM}
    procedure ComposeNamingSystemUniqueId(parent :  TTurtleComplex; parentType, name : String; value : TFhirNamingSystemUniqueId; useType : boolean; index : integer);
    procedure ComposeNamingSystem(parent :  TTurtleComplex; parentType, name : String; value : TFhirNamingSystem; useType : boolean; index : integer);
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONINTAKE}
    procedure ComposeNutritionIntakeConsumedItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionIntakeConsumedItem; useType : boolean; index : integer);
    procedure ComposeNutritionIntakeIngredientLabel(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionIntakeIngredientLabel; useType : boolean; index : integer);
    procedure ComposeNutritionIntakePerformer(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionIntakePerformer; useType : boolean; index : integer);
    procedure ComposeNutritionIntake(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionIntake; useType : boolean; index : integer);
{$ENDIF FHIR_NUTRITIONINTAKE}
{$IFDEF FHIR_NUTRITIONORDER}
    procedure ComposeNutritionOrderOralDiet(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionOrderOralDiet; useType : boolean; index : integer);
    procedure ComposeNutritionOrderOralDietSchedule(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionOrderOralDietSchedule; useType : boolean; index : integer);
    procedure ComposeNutritionOrderOralDietNutrient(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionOrderOralDietNutrient; useType : boolean; index : integer);
    procedure ComposeNutritionOrderOralDietTexture(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionOrderOralDietTexture; useType : boolean; index : integer);
    procedure ComposeNutritionOrderSupplement(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionOrderSupplement; useType : boolean; index : integer);
    procedure ComposeNutritionOrderSupplementSchedule(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionOrderSupplementSchedule; useType : boolean; index : integer);
    procedure ComposeNutritionOrderEnteralFormula(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionOrderEnteralFormula; useType : boolean; index : integer);
    procedure ComposeNutritionOrderEnteralFormulaAdditive(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionOrderEnteralFormulaAdditive; useType : boolean; index : integer);
    procedure ComposeNutritionOrderEnteralFormulaAdministration(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionOrderEnteralFormulaAdministration; useType : boolean; index : integer);
    procedure ComposeNutritionOrderEnteralFormulaAdministrationSchedule(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionOrderEnteralFormulaAdministrationSchedule; useType : boolean; index : integer);
    procedure ComposeNutritionOrder(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionOrder; useType : boolean; index : integer);
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_NUTRITIONPRODUCT}
    procedure ComposeNutritionProductNutrient(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionProductNutrient; useType : boolean; index : integer);
    procedure ComposeNutritionProductIngredient(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionProductIngredient; useType : boolean; index : integer);
    procedure ComposeNutritionProductCharacteristic(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionProductCharacteristic; useType : boolean; index : integer);
    procedure ComposeNutritionProductInstance(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionProductInstance; useType : boolean; index : integer);
    procedure ComposeNutritionProduct(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionProduct; useType : boolean; index : integer);
{$ENDIF FHIR_NUTRITIONPRODUCT}
{$IFDEF FHIR_OBSERVATION}
    procedure ComposeObservationTriggeredBy(parent :  TTurtleComplex; parentType, name : String; value : TFhirObservationTriggeredBy; useType : boolean; index : integer);
    procedure ComposeObservationReferenceRange(parent :  TTurtleComplex; parentType, name : String; value : TFhirObservationReferenceRange; useType : boolean; index : integer);
    procedure ComposeObservationComponent(parent :  TTurtleComplex; parentType, name : String; value : TFhirObservationComponent; useType : boolean; index : integer);
    procedure ComposeObservation(parent :  TTurtleComplex; parentType, name : String; value : TFhirObservation; useType : boolean; index : integer);
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
    procedure ComposeObservationDefinitionQuantitativeDetails(parent :  TTurtleComplex; parentType, name : String; value : TFhirObservationDefinitionQuantitativeDetails; useType : boolean; index : integer);
    procedure ComposeObservationDefinitionQualifiedValue(parent :  TTurtleComplex; parentType, name : String; value : TFhirObservationDefinitionQualifiedValue; useType : boolean; index : integer);
    procedure ComposeObservationDefinitionComponent(parent :  TTurtleComplex; parentType, name : String; value : TFhirObservationDefinitionComponent; useType : boolean; index : integer);
    procedure ComposeObservationDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirObservationDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
    procedure ComposeOperationDefinitionParameter(parent :  TTurtleComplex; parentType, name : String; value : TFhirOperationDefinitionParameter; useType : boolean; index : integer);
    procedure ComposeOperationDefinitionParameterBinding(parent :  TTurtleComplex; parentType, name : String; value : TFhirOperationDefinitionParameterBinding; useType : boolean; index : integer);
    procedure ComposeOperationDefinitionParameterReferencedFrom(parent :  TTurtleComplex; parentType, name : String; value : TFhirOperationDefinitionParameterReferencedFrom; useType : boolean; index : integer);
    procedure ComposeOperationDefinitionOverload(parent :  TTurtleComplex; parentType, name : String; value : TFhirOperationDefinitionOverload; useType : boolean; index : integer);
    procedure ComposeOperationDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirOperationDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
    procedure ComposeOperationOutcomeIssue(parent :  TTurtleComplex; parentType, name : String; value : TFhirOperationOutcomeIssue; useType : boolean; index : integer);
    procedure ComposeOperationOutcome(parent :  TTurtleComplex; parentType, name : String; value : TFhirOperationOutcome; useType : boolean; index : integer);
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
    procedure ComposeOrganizationQualification(parent :  TTurtleComplex; parentType, name : String; value : TFhirOrganizationQualification; useType : boolean; index : integer);
    procedure ComposeOrganization(parent :  TTurtleComplex; parentType, name : String; value : TFhirOrganization; useType : boolean; index : integer);
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
    procedure ComposeOrganizationAffiliation(parent :  TTurtleComplex; parentType, name : String; value : TFhirOrganizationAffiliation; useType : boolean; index : integer);
{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PACKAGEDPRODUCTDEFINITION}
    procedure ComposePackagedProductDefinitionLegalStatusOfSupply(parent :  TTurtleComplex; parentType, name : String; value : TFhirPackagedProductDefinitionLegalStatusOfSupply; useType : boolean; index : integer);
    procedure ComposePackagedProductDefinitionPackaging(parent :  TTurtleComplex; parentType, name : String; value : TFhirPackagedProductDefinitionPackaging; useType : boolean; index : integer);
    procedure ComposePackagedProductDefinitionPackagingProperty(parent :  TTurtleComplex; parentType, name : String; value : TFhirPackagedProductDefinitionPackagingProperty; useType : boolean; index : integer);
    procedure ComposePackagedProductDefinitionPackagingContainedItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirPackagedProductDefinitionPackagingContainedItem; useType : boolean; index : integer);
    procedure ComposePackagedProductDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirPackagedProductDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_PACKAGEDPRODUCTDEFINITION}
{$IFDEF FHIR_PARAMETERS}
    procedure ComposeParametersParameter(parent :  TTurtleComplex; parentType, name : String; value : TFhirParametersParameter; useType : boolean; index : integer);
    procedure ComposeParameters(parent :  TTurtleComplex; parentType, name : String; value : TFhirParameters; useType : boolean; index : integer);
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_PATIENT}
    procedure ComposePatientContact(parent :  TTurtleComplex; parentType, name : String; value : TFhirPatientContact; useType : boolean; index : integer);
    procedure ComposePatientCommunication(parent :  TTurtleComplex; parentType, name : String; value : TFhirPatientCommunication; useType : boolean; index : integer);
    procedure ComposePatientLink(parent :  TTurtleComplex; parentType, name : String; value : TFhirPatientLink; useType : boolean; index : integer);
    procedure ComposePatient(parent :  TTurtleComplex; parentType, name : String; value : TFhirPatient; useType : boolean; index : integer);
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
    procedure ComposePaymentNotice(parent :  TTurtleComplex; parentType, name : String; value : TFhirPaymentNotice; useType : boolean; index : integer);
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
    procedure ComposePaymentReconciliationAllocation(parent :  TTurtleComplex; parentType, name : String; value : TFhirPaymentReconciliationAllocation; useType : boolean; index : integer);
    procedure ComposePaymentReconciliationProcessNote(parent :  TTurtleComplex; parentType, name : String; value : TFhirPaymentReconciliationProcessNote; useType : boolean; index : integer);
    procedure ComposePaymentReconciliation(parent :  TTurtleComplex; parentType, name : String; value : TFhirPaymentReconciliation; useType : boolean; index : integer);
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERMISSION}
    procedure ComposePermissionJustification(parent :  TTurtleComplex; parentType, name : String; value : TFhirPermissionJustification; useType : boolean; index : integer);
    procedure ComposePermissionRule(parent :  TTurtleComplex; parentType, name : String; value : TFhirPermissionRule; useType : boolean; index : integer);
    procedure ComposePermissionRuleData(parent :  TTurtleComplex; parentType, name : String; value : TFhirPermissionRuleData; useType : boolean; index : integer);
    procedure ComposePermissionRuleDataResource(parent :  TTurtleComplex; parentType, name : String; value : TFhirPermissionRuleDataResource; useType : boolean; index : integer);
    procedure ComposePermissionRuleActivity(parent :  TTurtleComplex; parentType, name : String; value : TFhirPermissionRuleActivity; useType : boolean; index : integer);
    procedure ComposePermission(parent :  TTurtleComplex; parentType, name : String; value : TFhirPermission; useType : boolean; index : integer);
{$ENDIF FHIR_PERMISSION}
{$IFDEF FHIR_PERSON}
    procedure ComposePersonCommunication(parent :  TTurtleComplex; parentType, name : String; value : TFhirPersonCommunication; useType : boolean; index : integer);
    procedure ComposePersonLink(parent :  TTurtleComplex; parentType, name : String; value : TFhirPersonLink; useType : boolean; index : integer);
    procedure ComposePerson(parent :  TTurtleComplex; parentType, name : String; value : TFhirPerson; useType : boolean; index : integer);
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
    procedure ComposePlanDefinitionGoal(parent :  TTurtleComplex; parentType, name : String; value : TFhirPlanDefinitionGoal; useType : boolean; index : integer);
    procedure ComposePlanDefinitionGoalTarget(parent :  TTurtleComplex; parentType, name : String; value : TFhirPlanDefinitionGoalTarget; useType : boolean; index : integer);
    procedure ComposePlanDefinitionActor(parent :  TTurtleComplex; parentType, name : String; value : TFhirPlanDefinitionActor; useType : boolean; index : integer);
    procedure ComposePlanDefinitionActorOption(parent :  TTurtleComplex; parentType, name : String; value : TFhirPlanDefinitionActorOption; useType : boolean; index : integer);
    procedure ComposePlanDefinitionAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirPlanDefinitionAction; useType : boolean; index : integer);
    procedure ComposePlanDefinitionActionCondition(parent :  TTurtleComplex; parentType, name : String; value : TFhirPlanDefinitionActionCondition; useType : boolean; index : integer);
    procedure ComposePlanDefinitionActionInput(parent :  TTurtleComplex; parentType, name : String; value : TFhirPlanDefinitionActionInput; useType : boolean; index : integer);
    procedure ComposePlanDefinitionActionOutput(parent :  TTurtleComplex; parentType, name : String; value : TFhirPlanDefinitionActionOutput; useType : boolean; index : integer);
    procedure ComposePlanDefinitionActionRelatedAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirPlanDefinitionActionRelatedAction; useType : boolean; index : integer);
    procedure ComposePlanDefinitionActionParticipant(parent :  TTurtleComplex; parentType, name : String; value : TFhirPlanDefinitionActionParticipant; useType : boolean; index : integer);
    procedure ComposePlanDefinitionActionDynamicValue(parent :  TTurtleComplex; parentType, name : String; value : TFhirPlanDefinitionActionDynamicValue; useType : boolean; index : integer);
    procedure ComposePlanDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirPlanDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
    procedure ComposePractitionerQualification(parent :  TTurtleComplex; parentType, name : String; value : TFhirPractitionerQualification; useType : boolean; index : integer);
    procedure ComposePractitioner(parent :  TTurtleComplex; parentType, name : String; value : TFhirPractitioner; useType : boolean; index : integer);
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
    procedure ComposePractitionerRole(parent :  TTurtleComplex; parentType, name : String; value : TFhirPractitionerRole; useType : boolean; index : integer);
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
    procedure ComposeProcedurePerformer(parent :  TTurtleComplex; parentType, name : String; value : TFhirProcedurePerformer; useType : boolean; index : integer);
    procedure ComposeProcedureFocalDevice(parent :  TTurtleComplex; parentType, name : String; value : TFhirProcedureFocalDevice; useType : boolean; index : integer);
    procedure ComposeProcedure(parent :  TTurtleComplex; parentType, name : String; value : TFhirProcedure; useType : boolean; index : integer);
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROVENANCE}
    procedure ComposeProvenanceAgent(parent :  TTurtleComplex; parentType, name : String; value : TFhirProvenanceAgent; useType : boolean; index : integer);
    procedure ComposeProvenanceEntity(parent :  TTurtleComplex; parentType, name : String; value : TFhirProvenanceEntity; useType : boolean; index : integer);
    procedure ComposeProvenance(parent :  TTurtleComplex; parentType, name : String; value : TFhirProvenance; useType : boolean; index : integer);
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
    procedure ComposeQuestionnaireItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirQuestionnaireItem; useType : boolean; index : integer);
    procedure ComposeQuestionnaireItemEnableWhen(parent :  TTurtleComplex; parentType, name : String; value : TFhirQuestionnaireItemEnableWhen; useType : boolean; index : integer);
    procedure ComposeQuestionnaireItemAnswerOption(parent :  TTurtleComplex; parentType, name : String; value : TFhirQuestionnaireItemAnswerOption; useType : boolean; index : integer);
    procedure ComposeQuestionnaireItemInitial(parent :  TTurtleComplex; parentType, name : String; value : TFhirQuestionnaireItemInitial; useType : boolean; index : integer);
    procedure ComposeQuestionnaire(parent :  TTurtleComplex; parentType, name : String; value : TFhirQuestionnaire; useType : boolean; index : integer);
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
    procedure ComposeQuestionnaireResponseItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirQuestionnaireResponseItem; useType : boolean; index : integer);
    procedure ComposeQuestionnaireResponseItemAnswer(parent :  TTurtleComplex; parentType, name : String; value : TFhirQuestionnaireResponseItemAnswer; useType : boolean; index : integer);
    procedure ComposeQuestionnaireResponse(parent :  TTurtleComplex; parentType, name : String; value : TFhirQuestionnaireResponse; useType : boolean; index : integer);
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REGULATEDAUTHORIZATION}
    procedure ComposeRegulatedAuthorizationCase(parent :  TTurtleComplex; parentType, name : String; value : TFhirRegulatedAuthorizationCase; useType : boolean; index : integer);
    procedure ComposeRegulatedAuthorization(parent :  TTurtleComplex; parentType, name : String; value : TFhirRegulatedAuthorization; useType : boolean; index : integer);
{$ENDIF FHIR_REGULATEDAUTHORIZATION}
{$IFDEF FHIR_RELATEDPERSON}
    procedure ComposeRelatedPersonCommunication(parent :  TTurtleComplex; parentType, name : String; value : TFhirRelatedPersonCommunication; useType : boolean; index : integer);
    procedure ComposeRelatedPerson(parent :  TTurtleComplex; parentType, name : String; value : TFhirRelatedPerson; useType : boolean; index : integer);
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
    procedure ComposeRequestGroupAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestGroupAction; useType : boolean; index : integer);
    procedure ComposeRequestGroupActionCondition(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestGroupActionCondition; useType : boolean; index : integer);
    procedure ComposeRequestGroupActionRelatedAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestGroupActionRelatedAction; useType : boolean; index : integer);
    procedure ComposeRequestGroupActionParticipant(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestGroupActionParticipant; useType : boolean; index : integer);
    procedure ComposeRequestGroup(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestGroup; useType : boolean; index : integer);
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_REQUESTORCHESTRATION}
    procedure ComposeRequestOrchestrationAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestOrchestrationAction; useType : boolean; index : integer);
    procedure ComposeRequestOrchestrationActionCondition(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestOrchestrationActionCondition; useType : boolean; index : integer);
    procedure ComposeRequestOrchestrationActionInput(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestOrchestrationActionInput; useType : boolean; index : integer);
    procedure ComposeRequestOrchestrationActionOutput(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestOrchestrationActionOutput; useType : boolean; index : integer);
    procedure ComposeRequestOrchestrationActionRelatedAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestOrchestrationActionRelatedAction; useType : boolean; index : integer);
    procedure ComposeRequestOrchestrationActionParticipant(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestOrchestrationActionParticipant; useType : boolean; index : integer);
    procedure ComposeRequestOrchestrationActionDynamicValue(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestOrchestrationActionDynamicValue; useType : boolean; index : integer);
    procedure ComposeRequestOrchestration(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestOrchestration; useType : boolean; index : integer);
{$ENDIF FHIR_REQUESTORCHESTRATION}
{$IFDEF FHIR_REQUIREMENTS}
    procedure ComposeRequirementsStatement(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequirementsStatement; useType : boolean; index : integer);
    procedure ComposeRequirements(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequirements; useType : boolean; index : integer);
{$ENDIF FHIR_REQUIREMENTS}
{$IFDEF FHIR_RESEARCHSTUDY}
    procedure ComposeResearchStudyLabel(parent :  TTurtleComplex; parentType, name : String; value : TFhirResearchStudyLabel; useType : boolean; index : integer);
    procedure ComposeResearchStudyFocus(parent :  TTurtleComplex; parentType, name : String; value : TFhirResearchStudyFocus; useType : boolean; index : integer);
    procedure ComposeResearchStudyAssociatedParty(parent :  TTurtleComplex; parentType, name : String; value : TFhirResearchStudyAssociatedParty; useType : boolean; index : integer);
    procedure ComposeResearchStudyProgressStatus(parent :  TTurtleComplex; parentType, name : String; value : TFhirResearchStudyProgressStatus; useType : boolean; index : integer);
    procedure ComposeResearchStudyRecruitment(parent :  TTurtleComplex; parentType, name : String; value : TFhirResearchStudyRecruitment; useType : boolean; index : integer);
    procedure ComposeResearchStudyComparisonGroup(parent :  TTurtleComplex; parentType, name : String; value : TFhirResearchStudyComparisonGroup; useType : boolean; index : integer);
    procedure ComposeResearchStudyObjective(parent :  TTurtleComplex; parentType, name : String; value : TFhirResearchStudyObjective; useType : boolean; index : integer);
    procedure ComposeResearchStudyOutcomeMeasure(parent :  TTurtleComplex; parentType, name : String; value : TFhirResearchStudyOutcomeMeasure; useType : boolean; index : integer);
    procedure ComposeResearchStudyWebLocation(parent :  TTurtleComplex; parentType, name : String; value : TFhirResearchStudyWebLocation; useType : boolean; index : integer);
    procedure ComposeResearchStudy(parent :  TTurtleComplex; parentType, name : String; value : TFhirResearchStudy; useType : boolean; index : integer);
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
    procedure ComposeResearchSubjectProgress(parent :  TTurtleComplex; parentType, name : String; value : TFhirResearchSubjectProgress; useType : boolean; index : integer);
    procedure ComposeResearchSubject(parent :  TTurtleComplex; parentType, name : String; value : TFhirResearchSubject; useType : boolean; index : integer);
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
    procedure ComposeRiskAssessmentPrediction(parent :  TTurtleComplex; parentType, name : String; value : TFhirRiskAssessmentPrediction; useType : boolean; index : integer);
    procedure ComposeRiskAssessment(parent :  TTurtleComplex; parentType, name : String; value : TFhirRiskAssessment; useType : boolean; index : integer);
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
    procedure ComposeSchedule(parent :  TTurtleComplex; parentType, name : String; value : TFhirSchedule; useType : boolean; index : integer);
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
    procedure ComposeSearchParameterComponent(parent :  TTurtleComplex; parentType, name : String; value : TFhirSearchParameterComponent; useType : boolean; index : integer);
    procedure ComposeSearchParameter(parent :  TTurtleComplex; parentType, name : String; value : TFhirSearchParameter; useType : boolean; index : integer);
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEREQUEST}
    procedure ComposeServiceRequest(parent :  TTurtleComplex; parentType, name : String; value : TFhirServiceRequest; useType : boolean; index : integer);
{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SLOT}
    procedure ComposeSlot(parent :  TTurtleComplex; parentType, name : String; value : TFhirSlot; useType : boolean; index : integer);
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
    procedure ComposeSpecimenFeature(parent :  TTurtleComplex; parentType, name : String; value : TFhirSpecimenFeature; useType : boolean; index : integer);
    procedure ComposeSpecimenCollection(parent :  TTurtleComplex; parentType, name : String; value : TFhirSpecimenCollection; useType : boolean; index : integer);
    procedure ComposeSpecimenProcessing(parent :  TTurtleComplex; parentType, name : String; value : TFhirSpecimenProcessing; useType : boolean; index : integer);
    procedure ComposeSpecimenContainer(parent :  TTurtleComplex; parentType, name : String; value : TFhirSpecimenContainer; useType : boolean; index : integer);
    procedure ComposeSpecimen(parent :  TTurtleComplex; parentType, name : String; value : TFhirSpecimen; useType : boolean; index : integer);
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SPECIMENDEFINITION}
    procedure ComposeSpecimenDefinitionTypeTested(parent :  TTurtleComplex; parentType, name : String; value : TFhirSpecimenDefinitionTypeTested; useType : boolean; index : integer);
    procedure ComposeSpecimenDefinitionTypeTestedContainer(parent :  TTurtleComplex; parentType, name : String; value : TFhirSpecimenDefinitionTypeTestedContainer; useType : boolean; index : integer);
    procedure ComposeSpecimenDefinitionTypeTestedContainerAdditive(parent :  TTurtleComplex; parentType, name : String; value : TFhirSpecimenDefinitionTypeTestedContainerAdditive; useType : boolean; index : integer);
    procedure ComposeSpecimenDefinitionTypeTestedHandling(parent :  TTurtleComplex; parentType, name : String; value : TFhirSpecimenDefinitionTypeTestedHandling; useType : boolean; index : integer);
    procedure ComposeSpecimenDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirSpecimenDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
    procedure ComposeStructureDefinitionMapping(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureDefinitionMapping; useType : boolean; index : integer);
    procedure ComposeStructureDefinitionContext(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureDefinitionContext; useType : boolean; index : integer);
    procedure ComposeStructureDefinitionSnapshot(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureDefinitionSnapshot; useType : boolean; index : integer);
    procedure ComposeStructureDefinitionDifferential(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureDefinitionDifferential; useType : boolean; index : integer);
    procedure ComposeStructureDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
    procedure ComposeStructureMapStructure(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureMapStructure; useType : boolean; index : integer);
    procedure ComposeStructureMapGroup(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureMapGroup; useType : boolean; index : integer);
    procedure ComposeStructureMapGroupInput(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureMapGroupInput; useType : boolean; index : integer);
    procedure ComposeStructureMapGroupRule(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureMapGroupRule; useType : boolean; index : integer);
    procedure ComposeStructureMapGroupRuleSource(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureMapGroupRuleSource; useType : boolean; index : integer);
    procedure ComposeStructureMapGroupRuleTarget(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureMapGroupRuleTarget; useType : boolean; index : integer);
    procedure ComposeStructureMapGroupRuleTargetParameter(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureMapGroupRuleTargetParameter; useType : boolean; index : integer);
    procedure ComposeStructureMapGroupRuleDependent(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureMapGroupRuleDependent; useType : boolean; index : integer);
    procedure ComposeStructureMap(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureMap; useType : boolean; index : integer);
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
    procedure ComposeSubscriptionFilterBy(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubscriptionFilterBy; useType : boolean; index : integer);
    procedure ComposeSubscription(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubscription; useType : boolean; index : integer);
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSCRIPTIONSTATUS}
    procedure ComposeSubscriptionStatusNotificationEvent(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubscriptionStatusNotificationEvent; useType : boolean; index : integer);
    procedure ComposeSubscriptionStatus(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubscriptionStatus; useType : boolean; index : integer);
{$ENDIF FHIR_SUBSCRIPTIONSTATUS}
{$IFDEF FHIR_SUBSCRIPTIONTOPIC}
    procedure ComposeSubscriptionTopicResourceTrigger(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubscriptionTopicResourceTrigger; useType : boolean; index : integer);
    procedure ComposeSubscriptionTopicResourceTriggerQueryCriteria(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubscriptionTopicResourceTriggerQueryCriteria; useType : boolean; index : integer);
    procedure ComposeSubscriptionTopicEventTrigger(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubscriptionTopicEventTrigger; useType : boolean; index : integer);
    procedure ComposeSubscriptionTopicCanFilterBy(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubscriptionTopicCanFilterBy; useType : boolean; index : integer);
    procedure ComposeSubscriptionTopicNotificationShape(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubscriptionTopicNotificationShape; useType : boolean; index : integer);
    procedure ComposeSubscriptionTopic(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubscriptionTopic; useType : boolean; index : integer);
{$ENDIF FHIR_SUBSCRIPTIONTOPIC}
{$IFDEF FHIR_SUBSTANCE}
    procedure ComposeSubstanceIngredient(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceIngredient; useType : boolean; index : integer);
    procedure ComposeSubstance(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstance; useType : boolean; index : integer);
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCEDEFINITION}
    procedure ComposeSubstanceDefinitionMoiety(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceDefinitionMoiety; useType : boolean; index : integer);
    procedure ComposeSubstanceDefinitionProperty(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceDefinitionProperty; useType : boolean; index : integer);
    procedure ComposeSubstanceDefinitionMolecularWeight(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceDefinitionMolecularWeight; useType : boolean; index : integer);
    procedure ComposeSubstanceDefinitionStructure(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceDefinitionStructure; useType : boolean; index : integer);
    procedure ComposeSubstanceDefinitionStructureRepresentation(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceDefinitionStructureRepresentation; useType : boolean; index : integer);
    procedure ComposeSubstanceDefinitionCode(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceDefinitionCode; useType : boolean; index : integer);
    procedure ComposeSubstanceDefinitionName(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceDefinitionName; useType : boolean; index : integer);
    procedure ComposeSubstanceDefinitionNameOfficial(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceDefinitionNameOfficial; useType : boolean; index : integer);
    procedure ComposeSubstanceDefinitionRelationship(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceDefinitionRelationship; useType : boolean; index : integer);
    procedure ComposeSubstanceDefinitionSourceMaterial(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceDefinitionSourceMaterial; useType : boolean; index : integer);
    procedure ComposeSubstanceDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_SUBSTANCEDEFINITION}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
    procedure ComposeSubstanceNucleicAcidSubunit(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceNucleicAcidSubunit; useType : boolean; index : integer);
    procedure ComposeSubstanceNucleicAcidSubunitLinkage(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceNucleicAcidSubunitLinkage; useType : boolean; index : integer);
    procedure ComposeSubstanceNucleicAcidSubunitSugar(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceNucleicAcidSubunitSugar; useType : boolean; index : integer);
    procedure ComposeSubstanceNucleicAcid(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceNucleicAcid; useType : boolean; index : integer);
{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
    procedure ComposeSubstancePolymerMonomerSet(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstancePolymerMonomerSet; useType : boolean; index : integer);
    procedure ComposeSubstancePolymerMonomerSetStartingMaterial(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstancePolymerMonomerSetStartingMaterial; useType : boolean; index : integer);
    procedure ComposeSubstancePolymerRepeat(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstancePolymerRepeat; useType : boolean; index : integer);
    procedure ComposeSubstancePolymerRepeatRepeatUnit(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstancePolymerRepeatRepeatUnit; useType : boolean; index : integer);
    procedure ComposeSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation; useType : boolean; index : integer);
    procedure ComposeSubstancePolymerRepeatRepeatUnitStructuralRepresentation(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation; useType : boolean; index : integer);
    procedure ComposeSubstancePolymer(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstancePolymer; useType : boolean; index : integer);
{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
    procedure ComposeSubstanceProteinSubunit(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceProteinSubunit; useType : boolean; index : integer);
    procedure ComposeSubstanceProtein(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceProtein; useType : boolean; index : integer);
{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
    procedure ComposeSubstanceReferenceInformationGene(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceReferenceInformationGene; useType : boolean; index : integer);
    procedure ComposeSubstanceReferenceInformationGeneElement(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceReferenceInformationGeneElement; useType : boolean; index : integer);
    procedure ComposeSubstanceReferenceInformationTarget(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceReferenceInformationTarget; useType : boolean; index : integer);
    procedure ComposeSubstanceReferenceInformation(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceReferenceInformation; useType : boolean; index : integer);
{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
    procedure ComposeSubstanceSourceMaterialFractionDescription(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceSourceMaterialFractionDescription; useType : boolean; index : integer);
    procedure ComposeSubstanceSourceMaterialOrganism(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceSourceMaterialOrganism; useType : boolean; index : integer);
    procedure ComposeSubstanceSourceMaterialOrganismAuthor(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceSourceMaterialOrganismAuthor; useType : boolean; index : integer);
    procedure ComposeSubstanceSourceMaterialOrganismHybrid(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceSourceMaterialOrganismHybrid; useType : boolean; index : integer);
    procedure ComposeSubstanceSourceMaterialOrganismOrganismGeneral(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral; useType : boolean; index : integer);
    procedure ComposeSubstanceSourceMaterialPartDescription(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceSourceMaterialPartDescription; useType : boolean; index : integer);
    procedure ComposeSubstanceSourceMaterial(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceSourceMaterial; useType : boolean; index : integer);
{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUPPLYDELIVERY}
    procedure ComposeSupplyDeliverySuppliedItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirSupplyDeliverySuppliedItem; useType : boolean; index : integer);
    procedure ComposeSupplyDelivery(parent :  TTurtleComplex; parentType, name : String; value : TFhirSupplyDelivery; useType : boolean; index : integer);
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
    procedure ComposeSupplyRequestParameter(parent :  TTurtleComplex; parentType, name : String; value : TFhirSupplyRequestParameter; useType : boolean; index : integer);
    procedure ComposeSupplyRequest(parent :  TTurtleComplex; parentType, name : String; value : TFhirSupplyRequest; useType : boolean; index : integer);
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
    procedure ComposeTaskRestriction(parent :  TTurtleComplex; parentType, name : String; value : TFhirTaskRestriction; useType : boolean; index : integer);
    procedure ComposeTaskInput(parent :  TTurtleComplex; parentType, name : String; value : TFhirTaskInput; useType : boolean; index : integer);
    procedure ComposeTaskOutput(parent :  TTurtleComplex; parentType, name : String; value : TFhirTaskOutput; useType : boolean; index : integer);
    procedure ComposeTask(parent :  TTurtleComplex; parentType, name : String; value : TFhirTask; useType : boolean; index : integer);
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
    procedure ComposeTerminologyCapabilitiesSoftware(parent :  TTurtleComplex; parentType, name : String; value : TFhirTerminologyCapabilitiesSoftware; useType : boolean; index : integer);
    procedure ComposeTerminologyCapabilitiesImplementation(parent :  TTurtleComplex; parentType, name : String; value : TFhirTerminologyCapabilitiesImplementation; useType : boolean; index : integer);
    procedure ComposeTerminologyCapabilitiesCodeSystem(parent :  TTurtleComplex; parentType, name : String; value : TFhirTerminologyCapabilitiesCodeSystem; useType : boolean; index : integer);
    procedure ComposeTerminologyCapabilitiesCodeSystemVersion(parent :  TTurtleComplex; parentType, name : String; value : TFhirTerminologyCapabilitiesCodeSystemVersion; useType : boolean; index : integer);
    procedure ComposeTerminologyCapabilitiesCodeSystemVersionFilter(parent :  TTurtleComplex; parentType, name : String; value : TFhirTerminologyCapabilitiesCodeSystemVersionFilter; useType : boolean; index : integer);
    procedure ComposeTerminologyCapabilitiesExpansion(parent :  TTurtleComplex; parentType, name : String; value : TFhirTerminologyCapabilitiesExpansion; useType : boolean; index : integer);
    procedure ComposeTerminologyCapabilitiesExpansionParameter(parent :  TTurtleComplex; parentType, name : String; value : TFhirTerminologyCapabilitiesExpansionParameter; useType : boolean; index : integer);
    procedure ComposeTerminologyCapabilitiesValidateCode(parent :  TTurtleComplex; parentType, name : String; value : TFhirTerminologyCapabilitiesValidateCode; useType : boolean; index : integer);
    procedure ComposeTerminologyCapabilitiesTranslation(parent :  TTurtleComplex; parentType, name : String; value : TFhirTerminologyCapabilitiesTranslation; useType : boolean; index : integer);
    procedure ComposeTerminologyCapabilitiesClosure(parent :  TTurtleComplex; parentType, name : String; value : TFhirTerminologyCapabilitiesClosure; useType : boolean; index : integer);
    procedure ComposeTerminologyCapabilities(parent :  TTurtleComplex; parentType, name : String; value : TFhirTerminologyCapabilities; useType : boolean; index : integer);
{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTREPORT}
    procedure ComposeTestReportParticipant(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestReportParticipant; useType : boolean; index : integer);
    procedure ComposeTestReportSetup(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestReportSetup; useType : boolean; index : integer);
    procedure ComposeTestReportSetupAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestReportSetupAction; useType : boolean; index : integer);
    procedure ComposeTestReportSetupActionOperation(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestReportSetupActionOperation; useType : boolean; index : integer);
    procedure ComposeTestReportSetupActionAssert(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestReportSetupActionAssert; useType : boolean; index : integer);
    procedure ComposeTestReportTest(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestReportTest; useType : boolean; index : integer);
    procedure ComposeTestReportTestAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestReportTestAction; useType : boolean; index : integer);
    procedure ComposeTestReportTeardown(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestReportTeardown; useType : boolean; index : integer);
    procedure ComposeTestReportTeardownAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestReportTeardownAction; useType : boolean; index : integer);
    procedure ComposeTestReport(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestReport; useType : boolean; index : integer);
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
    procedure ComposeTestScriptOrigin(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptOrigin; useType : boolean; index : integer);
    procedure ComposeTestScriptDestination(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptDestination; useType : boolean; index : integer);
    procedure ComposeTestScriptMetadata(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptMetadata; useType : boolean; index : integer);
    procedure ComposeTestScriptMetadataLink(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptMetadataLink; useType : boolean; index : integer);
    procedure ComposeTestScriptMetadataCapability(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptMetadataCapability; useType : boolean; index : integer);
    procedure ComposeTestScriptScope(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptScope; useType : boolean; index : integer);
    procedure ComposeTestScriptFixture(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptFixture; useType : boolean; index : integer);
    procedure ComposeTestScriptVariable(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptVariable; useType : boolean; index : integer);
    procedure ComposeTestScriptSetup(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptSetup; useType : boolean; index : integer);
    procedure ComposeTestScriptSetupAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptSetupAction; useType : boolean; index : integer);
    procedure ComposeTestScriptSetupActionOperation(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptSetupActionOperation; useType : boolean; index : integer);
    procedure ComposeTestScriptSetupActionOperationRequestHeader(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptSetupActionOperationRequestHeader; useType : boolean; index : integer);
    procedure ComposeTestScriptSetupActionAssert(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptSetupActionAssert; useType : boolean; index : integer);
    procedure ComposeTestScriptTest(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptTest; useType : boolean; index : integer);
    procedure ComposeTestScriptTestAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptTestAction; useType : boolean; index : integer);
    procedure ComposeTestScriptTeardown(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptTeardown; useType : boolean; index : integer);
    procedure ComposeTestScriptTeardownAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptTeardownAction; useType : boolean; index : integer);
    procedure ComposeTestScript(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScript; useType : boolean; index : integer);
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_TRANSPORT}
    procedure ComposeTransportRestriction(parent :  TTurtleComplex; parentType, name : String; value : TFhirTransportRestriction; useType : boolean; index : integer);
    procedure ComposeTransportInput(parent :  TTurtleComplex; parentType, name : String; value : TFhirTransportInput; useType : boolean; index : integer);
    procedure ComposeTransportOutput(parent :  TTurtleComplex; parentType, name : String; value : TFhirTransportOutput; useType : boolean; index : integer);
    procedure ComposeTransport(parent :  TTurtleComplex; parentType, name : String; value : TFhirTransport; useType : boolean; index : integer);
{$ENDIF FHIR_TRANSPORT}
{$IFDEF FHIR_VALUESET}
    procedure ComposeValueSetCompose(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSetCompose; useType : boolean; index : integer);
    procedure ComposeValueSetComposeInclude(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSetComposeInclude; useType : boolean; index : integer);
    procedure ComposeValueSetComposeIncludeConcept(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSetComposeIncludeConcept; useType : boolean; index : integer);
    procedure ComposeValueSetComposeIncludeConceptDesignation(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSetComposeIncludeConceptDesignation; useType : boolean; index : integer);
    procedure ComposeValueSetComposeIncludeFilter(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSetComposeIncludeFilter; useType : boolean; index : integer);
    procedure ComposeValueSetExpansion(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSetExpansion; useType : boolean; index : integer);
    procedure ComposeValueSetExpansionParameter(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSetExpansionParameter; useType : boolean; index : integer);
    procedure ComposeValueSetExpansionProperty(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSetExpansionProperty; useType : boolean; index : integer);
    procedure ComposeValueSetExpansionContains(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSetExpansionContains; useType : boolean; index : integer);
    procedure ComposeValueSetExpansionContainsProperty(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSetExpansionContainsProperty; useType : boolean; index : integer);
    procedure ComposeValueSetExpansionContainsPropertySubProperty(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSetExpansionContainsPropertySubProperty; useType : boolean; index : integer);
    procedure ComposeValueSetScope(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSetScope; useType : boolean; index : integer);
    procedure ComposeValueSet(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSet; useType : boolean; index : integer);
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VERIFICATIONRESULT}
    procedure ComposeVerificationResultPrimarySource(parent :  TTurtleComplex; parentType, name : String; value : TFhirVerificationResultPrimarySource; useType : boolean; index : integer);
    procedure ComposeVerificationResultAttestation(parent :  TTurtleComplex; parentType, name : String; value : TFhirVerificationResultAttestation; useType : boolean; index : integer);
    procedure ComposeVerificationResultValidator(parent :  TTurtleComplex; parentType, name : String; value : TFhirVerificationResultValidator; useType : boolean; index : integer);
    procedure ComposeVerificationResult(parent :  TTurtleComplex; parentType, name : String; value : TFhirVerificationResult; useType : boolean; index : integer);
{$ENDIF FHIR_VERIFICATIONRESULT}
{$IFDEF FHIR_VISIONPRESCRIPTION}
    procedure ComposeVisionPrescriptionLensSpecification(parent :  TTurtleComplex; parentType, name : String; value : TFhirVisionPrescriptionLensSpecification; useType : boolean; index : integer);
    procedure ComposeVisionPrescriptionLensSpecificationPrism(parent :  TTurtleComplex; parentType, name : String; value : TFhirVisionPrescriptionLensSpecificationPrism; useType : boolean; index : integer);
    procedure ComposeVisionPrescription(parent :  TTurtleComplex; parentType, name : String; value : TFhirVisionPrescription; useType : boolean; index : integer);
{$ENDIF FHIR_VISIONPRESCRIPTION}


    procedure ComposeResource(parent :  TTurtleComplex; resource : TFhirResource); overload; override;
  end;


implementation

{ TFHIRTurtleParser / TFHIRTurtleComposer }

procedure TFHIRTurtleParser.ParseBaseProperties(obj : TTurtleComplex; value : TFhirBase); 
begin
  value.LocationData.ParseStart := obj.Start;
  value.LocationData.ParseFinish := obj.Stop;
end;

procedure TFHIRTurtleParser.ParseBaseProperties(obj : TTurtleComplex; value : TFhirResource); 
begin
  value.LocationData.ParseStart := obj.Start;
  value.LocationData.ParseFinish := obj.Stop;
end;

procedure TFHIRTurtleComposer.ComposeBase(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBase; useType : boolean; index : integer); 
begin
  // nothing
end;

procedure TFHIRTurtleComposer.ComposeBase(parent :  TTurtleComplex; parentType, name : String; elem : TFhirResource; useType : boolean; index : integer); 
begin
  // nothing
end;


procedure TFHIRTurtleParser.ParseElementProperties(obj : TTurtleComplex; value : TFhirElement);
var
  item : TTurtleComplex;
begin
  ParseBaseProperties(obj, value);
  value.idElement := ParseString(obj.complex('http://hl7.org/fhir/Element.id'));
  for item in obj.complexes('http://hl7.org/fhir/Element.extension') do
    value.extensionList.Add(parseExtension(item));
end;

Procedure TFHIRTurtleComposer.ComposeElement(this : TTurtleComplex; parentType, name : String; value : TFhirElement; useType : boolean; index : integer);
var
  i : integer;
begin
  ComposeBase(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'TFhirElement', 'id', value.idElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.extensionList.Count - 1 do
      ComposeExtension(this, 'TFhirElement', 'extension', value.extensionList[i], false, i);
end;

procedure TFHIRTurtleParser.ParseBackboneElementProperties(obj : TTurtleComplex; value : TFhirBackboneElement);
var
  item : TTurtleComplex;
begin
  ParseElementProperties(obj, value);
  for item in obj.complexes('http://hl7.org/fhir/BackboneElement.modifierExtension') do
    value.modifierExtensionList.Add(parseExtension(item));
end;

Procedure TFHIRTurtleComposer.ComposeBackboneElement(this : TTurtleComplex; parentType, name : String; value : TFhirBackboneElement; useType : boolean; index : integer);
var
  i : integer;
begin
  ComposeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.modifierExtensionList.Count - 1 do
      ComposeExtension(this, 'TFhirBackboneElement', 'modifierExtension', value.modifierExtensionList[i], false, i);
end;

procedure TFHIRTurtleParser.ParseDataTypeProperties(obj : TTurtleComplex; value : TFhirDataType);
begin
  ParseElementProperties(obj, value);
end;

Procedure TFHIRTurtleComposer.ComposeDataType(this : TTurtleComplex; parentType, name : String; value : TFhirDataType; useType : boolean; index : integer);
begin
  ComposeElement(this, '', name, value, false, index);
end;

procedure TFHIRTurtleParser.ParseBackboneTypeProperties(obj : TTurtleComplex; value : TFhirBackboneType);
var
  item : TTurtleComplex;
begin
  ParseDataTypeProperties(obj, value);
  for item in obj.complexes('http://hl7.org/fhir/BackboneType.modifierExtension') do
    value.modifierExtensionList.Add(parseExtension(item));
end;

Procedure TFHIRTurtleComposer.ComposeBackboneType(this : TTurtleComplex; parentType, name : String; value : TFhirBackboneType; useType : boolean; index : integer);
var
  i : integer;
begin
  ComposeDataType(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.modifierExtensionList.Count - 1 do
      ComposeExtension(this, 'TFhirBackboneType', 'modifierExtension', value.modifierExtensionList[i], false, i);
end;

procedure TFHIRTurtleParser.ParsePrimitiveTypeProperties(obj : TTurtleComplex; value : TFhirPrimitiveType);
begin
  ParseDataTypeProperties(obj, value);
end;

Procedure TFHIRTurtleComposer.ComposePrimitiveType(this : TTurtleComplex; parentType, name : String; value : TFhirPrimitiveType; useType : boolean; index : integer);
begin
  ComposeDataType(this, '', name, value, false, index);
end;



function TFHIRTurtleParser.ParseEnum(obj : TTurtleComplex; Const aNames, aSystems : Array Of String) : TFHIREnum;
var
  i : integer;
  value : String;
begin
  if obj = nil then
    exit(nil);

  if (obj.has('http://hl7.org/fhir/value')) then
    value := obj.stringLiteral('http://hl7.org/fhir/value');
  i := StringArrayIndexOfSensitive(aNames, value);
  if (value <> '') and (i < 0) then
    raise ERdfException.create('unknown code: '+value+' from a set of choices of '+StringArrayToCommaString(aNames));
  result := TFHIREnum.create;
  try
    result.value := value;
    result.system := aSystems[i];
    parseElementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeEnum(parent :  TTurtleComplex; parentType, name : String; value : TFhirEnum; Const aNames, aSystems : Array Of String; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:code');
  this.addPredicate('fhir:value', ttlLiteral(value.value));
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseDate(obj : TTurtleComplex) : TFHIRDate;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDate.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := toTFslDateTime(obj.stringLiteral('http://hl7.org/fhir/value'));
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeDate(parent :  TTurtleComplex; parentType, name : String; value : TFhirDate; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:date');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), dateXsdType(value.value));
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseDateTime(obj : TTurtleComplex) : TFHIRDateTime;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDateTime.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := toTFslDateTime(obj.stringLiteral('http://hl7.org/fhir/value'));
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeDateTime(parent :  TTurtleComplex; parentType, name : String; value : TFhirDateTime; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:dateTime');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), dateXsdType(value.value));
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseString(obj : TTurtleComplex) : TFHIRString;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirString.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeString(parent :  TTurtleComplex; parentType, name : String; value : TFhirString; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:string');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:string');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseInteger(obj : TTurtleComplex) : TFHIRInteger;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInteger.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeInteger(parent :  TTurtleComplex; parentType, name : String; value : TFhirInteger; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:integer');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:int');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseUri(obj : TTurtleComplex) : TFHIRUri;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirUri.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeUri(parent :  TTurtleComplex; parentType, name : String; value : TFhirUri; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:uri');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:anyURI');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseInstant(obj : TTurtleComplex) : TFHIRInstant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInstant.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := toTFslDateTime(obj.stringLiteral('http://hl7.org/fhir/value'));
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeInstant(parent :  TTurtleComplex; parentType, name : String; value : TFhirInstant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:instant');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:dateTime');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseXhtml(obj : TTurtleComplex) : TFHIRXhtml;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirXhtml.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeXhtml(parent :  TTurtleComplex; parentType, name : String; value : TFhirXhtml; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:xhtml');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)));
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseBoolean(obj : TTurtleComplex) : TFHIRBoolean;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBoolean.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
     result.value := StringToBoolean(obj.stringLiteral('http://hl7.org/fhir/value'));
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeBoolean(parent :  TTurtleComplex; parentType, name : String; value : TFhirBoolean; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:boolean');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:boolean');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseBase64Binary(obj : TTurtleComplex) : TFHIRBase64Binary;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBase64Binary.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := toTBytes(obj.stringLiteral('http://hl7.org/fhir/value'));
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeBase64Binary(parent :  TTurtleComplex; parentType, name : String; value : TFhirBase64Binary; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:base64Binary');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:base64Binary');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseTime(obj : TTurtleComplex) : TFHIRTime;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTime.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeTime(parent :  TTurtleComplex; parentType, name : String; value : TFhirTime; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:time');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:time');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseDecimal(obj : TTurtleComplex) : TFHIRDecimal;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDecimal.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeDecimal(parent :  TTurtleComplex; parentType, name : String; value : TFhirDecimal; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:decimal');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:decimal');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseCode(obj : TTurtleComplex) : TFHIRCode;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCode.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeCode(parent :  TTurtleComplex; parentType, name : String; value : TFhirCode; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:code');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:token');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseCanonical(obj : TTurtleComplex) : TFHIRCanonical;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCanonical.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeCanonical(parent :  TTurtleComplex; parentType, name : String; value : TFhirCanonical; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:canonical');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:anyURI');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseOid(obj : TTurtleComplex) : TFHIROid;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOid.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeOid(parent :  TTurtleComplex; parentType, name : String; value : TFhirOid; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:oid');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:anyURI');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseUuid(obj : TTurtleComplex) : TFHIRUuid;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirUuid.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeUuid(parent :  TTurtleComplex; parentType, name : String; value : TFhirUuid; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:uuid');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:anyURI');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseUrl(obj : TTurtleComplex) : TFHIRUrl;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirUrl.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeUrl(parent :  TTurtleComplex; parentType, name : String; value : TFhirUrl; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:url');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:anyURI');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseMarkdown(obj : TTurtleComplex) : TFHIRMarkdown;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMarkdown.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeMarkdown(parent :  TTurtleComplex; parentType, name : String; value : TFhirMarkdown; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:markdown');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:string');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseUnsignedInt(obj : TTurtleComplex) : TFHIRUnsignedInt;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirUnsignedInt.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeUnsignedInt(parent :  TTurtleComplex; parentType, name : String; value : TFhirUnsignedInt; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:unsignedInt');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:nonNegativeInteger');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseId(obj : TTurtleComplex) : TFHIRId;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirId.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeId(parent :  TTurtleComplex; parentType, name : String; value : TFhirId; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:id');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:string');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParsePositiveInt(obj : TTurtleComplex) : TFHIRPositiveInt;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPositiveInt.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposePositiveInt(parent :  TTurtleComplex; parentType, name : String; value : TFhirPositiveInt; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:positiveInt');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:positiveInteger');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseInteger64(obj : TTurtleComplex) : TFHIRInteger64;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInteger64.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeInteger64(parent :  TTurtleComplex; parentType, name : String; value : TFhirInteger64; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:Integer64');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:Integer64eger');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseAddress(obj : TTurtleComplex) : TFhirAddress;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAddress.create;
  try
    ParseAddressProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAddressProperties(obj : TTurtleComplex; value : TFhirAddress);
var
  item : TTurtleComplex;
begin
    ParseDataTypeProperties(obj, value);
    value.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/Address.use'), CODES_TFhirAddressUseEnum, SYSTEMS_TFhirAddressUseEnum);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Address.type'), CODES_TFhirAddressTypeEnum, SYSTEMS_TFhirAddressTypeEnum);
    value.textElement := ParseString(obj.complex('http://hl7.org/fhir/Address.text'));
    for item in obj.complexes('http://hl7.org/fhir/Address.line') do
      value.lineList.Add(parseString(item));
    value.cityElement := ParseString(obj.complex('http://hl7.org/fhir/Address.city'));
    value.districtElement := ParseString(obj.complex('http://hl7.org/fhir/Address.district'));
    value.stateElement := ParseString(obj.complex('http://hl7.org/fhir/Address.state'));
    value.postalCodeElement := ParseString(obj.complex('http://hl7.org/fhir/Address.postalCode'));
    value.countryElement := ParseString(obj.complex('http://hl7.org/fhir/Address.country'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Address.period'));
end;

procedure TFHIRTurtleComposer.ComposeAddress(parent :  TTurtleComplex; parentType, name : String; value : TFhirAddress; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Address');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Address', 'use', value.useElement, CODES_TFhirAddressUseEnum, SYSTEMS_TFhirAddressUseEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Address', 'type', value.type_Element, CODES_TFhirAddressTypeEnum, SYSTEMS_TFhirAddressTypeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Address', 'text', value.textElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.lineList.Count - 1 do
      ComposeString(this, 'Address', 'line', value.lineList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Address', 'city', value.cityElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Address', 'district', value.districtElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Address', 'state', value.stateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Address', 'postalCode', value.postalCodeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Address', 'country', value.countryElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Address', 'period', value.periodElement, false, -1);
end;

function TFHIRTurtleParser.ParseAnnotation(obj : TTurtleComplex) : TFhirAnnotation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAnnotation.create;
  try
    ParseAnnotationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAnnotationProperties(obj : TTurtleComplex; value : TFhirAnnotation);
var
  item : TTurtleComplex;
begin
    ParseDataTypeProperties(obj, value);
    if obj.has('authorReference', item) {a3} then
      value.author := ParseReference(item);
    if obj.has('authorString', item) then
      value.author := parseString(item);
    value.timeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Annotation.time'));
    value.textElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Annotation.text'));
end;

procedure TFHIRTurtleComposer.ComposeAnnotation(parent :  TTurtleComplex; parentType, name : String; value : TFhirAnnotation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Annotation');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.author is TFhirReference) {2} then
    ComposeReference(this, 'Annotation', 'authorReference', TFhirReference(value.author), false,-1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.author is TFhirString) {6} then
    ComposeString(this, 'Annotation', 'authorString', TFhirString(value.author), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Annotation', 'time', value.timeElement, false, -1);
  ComposeMarkdown(this, 'Annotation', 'text', value.textElement, false, -1);
end;

function TFHIRTurtleParser.ParseAttachment(obj : TTurtleComplex) : TFhirAttachment;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAttachment.create;
  try
    ParseAttachmentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAttachmentProperties(obj : TTurtleComplex; value : TFhirAttachment);
begin
    ParseDataTypeProperties(obj, value);
    value.contentTypeElement := ParseCode(obj.complex('http://hl7.org/fhir/Attachment.contentType'));
    value.languageElement := ParseCode(obj.complex('http://hl7.org/fhir/Attachment.language'));
    value.dataElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/Attachment.data'));
    value.urlElement := ParseUrl(obj.complex('http://hl7.org/fhir/Attachment.url'));
    value.sizeElement := ParseInteger64(obj.complex('http://hl7.org/fhir/Attachment.size'));
    value.hashElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/Attachment.hash'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Attachment.title'));
    value.creationElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Attachment.creation'));
    value.heightElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Attachment.height'));
    value.widthElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Attachment.width'));
    value.framesElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Attachment.frames'));
    value.durationElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Attachment.duration'));
    value.pagesElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Attachment.pages'));
end;

procedure TFHIRTurtleComposer.ComposeAttachment(parent :  TTurtleComplex; parentType, name : String; value : TFhirAttachment; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Attachment');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(this, 'Attachment', 'contentType', value.contentTypeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(this, 'Attachment', 'language', value.languageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBase64Binary(this, 'Attachment', 'data', value.dataElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrl(this, 'Attachment', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger64(this, 'Attachment', 'size', value.sizeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64Binary(this, 'Attachment', 'hash', value.hashElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Attachment', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Attachment', 'creation', value.creationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'Attachment', 'height', value.heightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'Attachment', 'width', value.widthElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'Attachment', 'frames', value.framesElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Attachment', 'duration', value.durationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'Attachment', 'pages', value.pagesElement, false, -1);
end;

function TFHIRTurtleParser.ParseAvailabilityAvailableTime(obj : TTurtleComplex) : TFhirAvailabilityAvailableTime;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAvailabilityAvailableTime.create;
  try
    ParseAvailabilityAvailableTimeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAvailabilityAvailableTimeProperties(obj : TTurtleComplex; value : TFhirAvailabilityAvailableTime);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Availability.availableTime.daysOfWeek') do
      value.daysOfWeekList.Add(parseEnum(item, CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum));
    value.allDayElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Availability.availableTime.allDay'));
    value.availableStartTimeElement := ParseTime(obj.complex('http://hl7.org/fhir/Availability.availableTime.availableStartTime'));
    value.availableEndTimeElement := ParseTime(obj.complex('http://hl7.org/fhir/Availability.availableTime.availableEndTime'));
end;

procedure TFHIRTurtleComposer.ComposeAvailabilityAvailableTime(parent :  TTurtleComplex; parentType, name : String; value : TFhirAvailabilityAvailableTime; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AvailabilityAvailableTime');
  end;
  composeElement(this, '', name, value, false, index);
  for i := 0 to value.daysOfWeekList.Count - 1 do
      ComposeEnum(this, 'Availability.availableTime', 'daysOfWeek', value.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.daysOfWeekList.Count - 1 do
      ComposeEnum(this, 'Availability.availableTime', 'daysOfWeek', value.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Availability.availableTime', 'allDay', value.allDayElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTime(this, 'Availability.availableTime', 'availableStartTime', value.availableStartTimeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTime(this, 'Availability.availableTime', 'availableEndTime', value.availableEndTimeElement, false, -1);
end;

function TFHIRTurtleParser.ParseAvailabilityNotAvailableTime(obj : TTurtleComplex) : TFhirAvailabilityNotAvailableTime;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAvailabilityNotAvailableTime.create;
  try
    ParseAvailabilityNotAvailableTimeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAvailabilityNotAvailableTimeProperties(obj : TTurtleComplex; value : TFhirAvailabilityNotAvailableTime);
begin
    ParseElementProperties(obj, value);
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Availability.notAvailableTime.description'));
    value.during := ParsePeriod(obj.complex('http://hl7.org/fhir/Availability.notAvailableTime.during'));
end;

procedure TFHIRTurtleComposer.ComposeAvailabilityNotAvailableTime(parent :  TTurtleComplex; parentType, name : String; value : TFhirAvailabilityNotAvailableTime; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AvailabilityNotAvailableTime');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Availability.notAvailableTime', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Availability.notAvailableTime', 'during', value.duringElement, false, -1);
end;

function TFHIRTurtleParser.ParseAvailability(obj : TTurtleComplex) : TFhirAvailability;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAvailability.create;
  try
    ParseAvailabilityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAvailabilityProperties(obj : TTurtleComplex; value : TFhirAvailability);
var
  item : TTurtleComplex;
begin
    ParseDataTypeProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Availability.availableTime') do
      value.availableTimeList.Add(parseAvailabilityAvailableTime(item));
    for item in obj.complexes('http://hl7.org/fhir/Availability.notAvailableTime') do
      value.notAvailableTimeList.Add(parseAvailabilityNotAvailableTime(item));
end;

procedure TFHIRTurtleComposer.ComposeAvailability(parent :  TTurtleComplex; parentType, name : String; value : TFhirAvailability; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Availability');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.availableTimeList.Count - 1 do
      ComposeAvailabilityAvailableTime(this, 'Availability', 'availableTime', value.availableTimeList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.notAvailableTimeList.Count - 1 do
      ComposeAvailabilityNotAvailableTime(this, 'Availability', 'notAvailableTime', value.notAvailableTimeList[i], false, i);
end;

function TFHIRTurtleParser.ParseCodeableConcept(obj : TTurtleComplex) : TFhirCodeableConcept;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCodeableConcept.create;
  try
    ParseCodeableConceptProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodeableConceptProperties(obj : TTurtleComplex; value : TFhirCodeableConcept);
var
  item : TTurtleComplex;
begin
    ParseDataTypeProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/CodeableConcept.coding') do
      value.codingList.Add(parseCoding(item));
    value.textElement := ParseString(obj.complex('http://hl7.org/fhir/CodeableConcept.text'));
end;

procedure TFHIRTurtleComposer.ComposeCodeableConcept(parent :  TTurtleComplex; parentType, name : String; value : TFhirCodeableConcept; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CodeableConcept');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.codingList.Count - 1 do
      ComposeCoding(this, 'CodeableConcept', 'coding', value.codingList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'CodeableConcept', 'text', value.textElement, false, -1);
end;

function TFHIRTurtleParser.ParseCodeableReference(obj : TTurtleComplex) : TFhirCodeableReference;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCodeableReference.create;
  try
    ParseCodeableReferenceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodeableReferenceProperties(obj : TTurtleComplex; value : TFhirCodeableReference);
begin
    ParseDataTypeProperties(obj, value);
    value.concept := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CodeableReference.concept'));
    value.reference := ParseReference(obj.complex('http://hl7.org/fhir/CodeableReference.reference'));
end;

procedure TFHIRTurtleComposer.ComposeCodeableReference(parent :  TTurtleComplex; parentType, name : String; value : TFhirCodeableReference; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CodeableReference');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'CodeableReference', 'concept', value.conceptElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'CodeableReference', 'reference', value.referenceElement, false, -1);
end;

function TFHIRTurtleParser.ParseCoding(obj : TTurtleComplex) : TFhirCoding;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoding.create;
  try
    ParseCodingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodingProperties(obj : TTurtleComplex; value : TFhirCoding);
begin
    ParseDataTypeProperties(obj, value);
    value.systemElement := ParseUri(obj.complex('http://hl7.org/fhir/Coding.system'));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Coding.version'));
    value.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/Coding.code'));
    value.displayElement := ParseString(obj.complex('http://hl7.org/fhir/Coding.display'));
    value.userSelectedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Coding.userSelected'));
end;

procedure TFHIRTurtleComposer.ComposeCoding(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoding; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Coding');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'Coding', 'system', value.systemElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Coding', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(this, 'Coding', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Coding', 'display', value.displayElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Coding', 'userSelected', value.userSelectedElement, false, -1);
end;

function TFHIRTurtleParser.ParseContactDetail(obj : TTurtleComplex) : TFhirContactDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContactDetail.create;
  try
    ParseContactDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContactDetailProperties(obj : TTurtleComplex; value : TFhirContactDetail);
var
  item : TTurtleComplex;
begin
    ParseDataTypeProperties(obj, value);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ContactDetail.name'));
    for item in obj.complexes('http://hl7.org/fhir/ContactDetail.telecom') do
      value.telecomList.Add(parseContactPoint(item));
end;

procedure TFHIRTurtleComposer.ComposeContactDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirContactDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContactDetail');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ContactDetail', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.telecomList.Count - 1 do
      ComposeContactPoint(this, 'ContactDetail', 'telecom', value.telecomList[i], false, i);
end;

function TFHIRTurtleParser.ParseContactPoint(obj : TTurtleComplex) : TFhirContactPoint;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContactPoint.create;
  try
    ParseContactPointProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContactPointProperties(obj : TTurtleComplex; value : TFhirContactPoint);
begin
    ParseDataTypeProperties(obj, value);
    value.systemElement := ParseEnum(obj.complex('http://hl7.org/fhir/ContactPoint.system'), CODES_TFhirContactPointSystemEnum, SYSTEMS_TFhirContactPointSystemEnum);
    value.valueElement := ParseString(obj.complex('http://hl7.org/fhir/ContactPoint.value'));
    value.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/ContactPoint.use'), CODES_TFhirContactPointUseEnum, SYSTEMS_TFhirContactPointUseEnum);
    value.rankElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ContactPoint.rank'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/ContactPoint.period'));
end;

procedure TFHIRTurtleComposer.ComposeContactPoint(parent :  TTurtleComplex; parentType, name : String; value : TFhirContactPoint; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContactPoint');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'ContactPoint', 'system', value.systemElement, CODES_TFhirContactPointSystemEnum, SYSTEMS_TFhirContactPointSystemEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ContactPoint', 'value', value.valueElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'ContactPoint', 'use', value.useElement, CODES_TFhirContactPointUseEnum, SYSTEMS_TFhirContactPointUseEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'ContactPoint', 'rank', value.rankElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'ContactPoint', 'period', value.periodElement, false, -1);
end;

function TFHIRTurtleParser.ParseContributor(obj : TTurtleComplex) : TFhirContributor;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContributor.create;
  try
    ParseContributorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContributorProperties(obj : TTurtleComplex; value : TFhirContributor);
var
  item : TTurtleComplex;
begin
    ParseDataTypeProperties(obj, value);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Contributor.type'), CODES_TFhirContributorTypeEnum, SYSTEMS_TFhirContributorTypeEnum);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Contributor.name'));
    for item in obj.complexes('http://hl7.org/fhir/Contributor.contact') do
      value.contactList.Add(parseContactDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeContributor(parent :  TTurtleComplex; parentType, name : String; value : TFhirContributor; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Contributor');
  end;
  composeElement(this, '', name, value, false, index);
  ComposeEnum(this, 'Contributor', 'type', value.type_Element, CODES_TFhirContributorTypeEnum, SYSTEMS_TFhirContributorTypeEnum, false, -1);
  ComposeString(this, 'Contributor', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'Contributor', 'contact', value.contactList[i], false, i);
end;

function TFHIRTurtleParser.ParseDataRequirementCodeFilter(obj : TTurtleComplex) : TFhirDataRequirementCodeFilter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDataRequirementCodeFilter.create;
  try
    ParseDataRequirementCodeFilterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDataRequirementCodeFilterProperties(obj : TTurtleComplex; value : TFhirDataRequirementCodeFilter);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, value);
    value.pathElement := ParseString(obj.complex('http://hl7.org/fhir/DataRequirement.codeFilter.path'));
    value.searchParamElement := ParseString(obj.complex('http://hl7.org/fhir/DataRequirement.codeFilter.searchParam'));
    value.valueSetElement := ParseCanonical(obj.complex('http://hl7.org/fhir/DataRequirement.codeFilter.valueSet'));
    for item in obj.complexes('http://hl7.org/fhir/DataRequirement.codeFilter.code') do
      value.codeList.Add(parseCoding(item));
end;

procedure TFHIRTurtleComposer.ComposeDataRequirementCodeFilter(parent :  TTurtleComplex; parentType, name : String; value : TFhirDataRequirementCodeFilter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DataRequirementCodeFilter');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'DataRequirement.codeFilter', 'path', value.pathElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'DataRequirement.codeFilter', 'searchParam', value.searchParamElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(this, 'DataRequirement.codeFilter', 'valueSet', value.valueSetElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCoding(this, 'DataRequirement.codeFilter', 'code', value.codeList[i], false, i);
end;

function TFHIRTurtleParser.ParseDataRequirementDateFilter(obj : TTurtleComplex) : TFhirDataRequirementDateFilter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDataRequirementDateFilter.create;
  try
    ParseDataRequirementDateFilterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDataRequirementDateFilterProperties(obj : TTurtleComplex; value : TFhirDataRequirementDateFilter);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, value);
    value.pathElement := ParseString(obj.complex('http://hl7.org/fhir/DataRequirement.dateFilter.path'));
    value.searchParamElement := ParseString(obj.complex('http://hl7.org/fhir/DataRequirement.dateFilter.searchParam'));
    if obj.has('valuePeriod', item) then
      value.value := parsePeriod(item);
    if obj.has('valueDuration', item) then
      value.value := parseDuration(item);
    if obj.has('valueDateTime', item) then
      value.value := parseDateTime(item);
end;

procedure TFHIRTurtleComposer.ComposeDataRequirementDateFilter(parent :  TTurtleComplex; parentType, name : String; value : TFhirDataRequirementDateFilter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DataRequirementDateFilter');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'DataRequirement.dateFilter', 'path', value.pathElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'DataRequirement.dateFilter', 'searchParam', value.searchParamElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'DataRequirement.dateFilter', 'valuePeriod', TFhirPeriod(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirDuration) {6} then
    ComposeDuration(this, 'DataRequirement.dateFilter', 'valueDuration', TFhirDuration(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'DataRequirement.dateFilter', 'valueDateTime', TFhirDateTime(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseDataRequirementValueFilter(obj : TTurtleComplex) : TFhirDataRequirementValueFilter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDataRequirementValueFilter.create;
  try
    ParseDataRequirementValueFilterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDataRequirementValueFilterProperties(obj : TTurtleComplex; value : TFhirDataRequirementValueFilter);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, value);
    value.pathElement := ParseString(obj.complex('http://hl7.org/fhir/DataRequirement.valueFilter.path'));
    value.searchParamElement := ParseString(obj.complex('http://hl7.org/fhir/DataRequirement.valueFilter.searchParam'));
    value.comparatorElement := ParseEnum(obj.complex('http://hl7.org/fhir/DataRequirement.valueFilter.comparator'), CODES_TFhirValueFilterComparatorEnum, SYSTEMS_TFhirValueFilterComparatorEnum);
    if obj.has('valuePeriod', item) then
      value.value := parsePeriod(item);
    if obj.has('valueDuration', item) then
      value.value := parseDuration(item);
    if obj.has('valueDateTime', item) then
      value.value := parseDateTime(item);
end;

procedure TFHIRTurtleComposer.ComposeDataRequirementValueFilter(parent :  TTurtleComplex; parentType, name : String; value : TFhirDataRequirementValueFilter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DataRequirementValueFilter');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'DataRequirement.valueFilter', 'path', value.pathElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'DataRequirement.valueFilter', 'searchParam', value.searchParamElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'DataRequirement.valueFilter', 'comparator', value.comparatorElement, CODES_TFhirValueFilterComparatorEnum, SYSTEMS_TFhirValueFilterComparatorEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'DataRequirement.valueFilter', 'valuePeriod', TFhirPeriod(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirDuration) {6} then
    ComposeDuration(this, 'DataRequirement.valueFilter', 'valueDuration', TFhirDuration(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'DataRequirement.valueFilter', 'valueDateTime', TFhirDateTime(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseDataRequirementSort(obj : TTurtleComplex) : TFhirDataRequirementSort;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDataRequirementSort.create;
  try
    ParseDataRequirementSortProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDataRequirementSortProperties(obj : TTurtleComplex; value : TFhirDataRequirementSort);
begin
    ParseElementProperties(obj, value);
    value.pathElement := ParseString(obj.complex('http://hl7.org/fhir/DataRequirement.sort.path'));
    value.directionElement := ParseEnum(obj.complex('http://hl7.org/fhir/DataRequirement.sort.direction'), CODES_TFhirSortDirectionEnum, SYSTEMS_TFhirSortDirectionEnum);
end;

procedure TFHIRTurtleComposer.ComposeDataRequirementSort(parent :  TTurtleComplex; parentType, name : String; value : TFhirDataRequirementSort; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DataRequirementSort');
  end;
  composeElement(this, '', name, value, false, index);
  ComposeString(this, 'DataRequirement.sort', 'path', value.pathElement, false, -1);
  ComposeEnum(this, 'DataRequirement.sort', 'direction', value.directionElement, CODES_TFhirSortDirectionEnum, SYSTEMS_TFhirSortDirectionEnum, false, -1);
end;

function TFHIRTurtleParser.ParseDataRequirement(obj : TTurtleComplex) : TFhirDataRequirement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDataRequirement.create;
  try
    ParseDataRequirementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDataRequirementProperties(obj : TTurtleComplex; value : TFhirDataRequirement);
var
  item : TTurtleComplex;
begin
    ParseDataTypeProperties(obj, value);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/DataRequirement.type'), CODES_TFhirFHIRTypesEnum, SYSTEMS_TFhirFHIRTypesEnum);
    for item in obj.complexes('http://hl7.org/fhir/DataRequirement.profile') do
      value.profileList.Add(parseCanonical(item));
    if obj.has('subjectCodeableConcept', item) then
      value.subject := parseCodeableConcept(item);
    if obj.has('subjectReference', item) {a3} then
      value.subject := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/DataRequirement.mustSupport') do
      value.mustSupportList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/DataRequirement.codeFilter') do
      value.codeFilterList.Add(parseDataRequirementCodeFilter(item));
    for item in obj.complexes('http://hl7.org/fhir/DataRequirement.dateFilter') do
      value.dateFilterList.Add(parseDataRequirementDateFilter(item));
    for item in obj.complexes('http://hl7.org/fhir/DataRequirement.valueFilter') do
      value.valueFilterList.Add(parseDataRequirementValueFilter(item));
    value.limitElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/DataRequirement.limit'));
    for item in obj.complexes('http://hl7.org/fhir/DataRequirement.sort') do
      value.sortList.Add(parseDataRequirementSort(item));
end;

procedure TFHIRTurtleComposer.ComposeDataRequirement(parent :  TTurtleComplex; parentType, name : String; value : TFhirDataRequirement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DataRequirement');
  end;
  composeElement(this, '', name, value, false, index);
  ComposeEnum(this, 'DataRequirement', 'type', value.type_Element, CODES_TFhirFHIRTypesEnum, SYSTEMS_TFhirFHIRTypesEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.profileList.Count - 1 do
      ComposeCanonical(this, 'DataRequirement', 'profile', value.profileList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.subject is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'DataRequirement', 'subjectCodeableConcept', TFhirCodeableConcept(value.subject), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.subject is TFhirReference) {2} then
    ComposeReference(this, 'DataRequirement', 'subjectReference', TFhirReference(value.subject), false,-1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.mustSupportList.Count - 1 do
      ComposeString(this, 'DataRequirement', 'mustSupport', value.mustSupportList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.codeFilterList.Count - 1 do
      ComposeDataRequirementCodeFilter(this, 'DataRequirement', 'codeFilter', value.codeFilterList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.dateFilterList.Count - 1 do
      ComposeDataRequirementDateFilter(this, 'DataRequirement', 'dateFilter', value.dateFilterList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.valueFilterList.Count - 1 do
      ComposeDataRequirementValueFilter(this, 'DataRequirement', 'valueFilter', value.valueFilterList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'DataRequirement', 'limit', value.limitElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.sortList.Count - 1 do
      ComposeDataRequirementSort(this, 'DataRequirement', 'sort', value.sortList[i], false, i);
end;

function TFHIRTurtleParser.ParseExpression(obj : TTurtleComplex) : TFhirExpression;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExpression.create;
  try
    ParseExpressionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExpressionProperties(obj : TTurtleComplex; value : TFhirExpression);
begin
    ParseDataTypeProperties(obj, value);
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Expression.description'));
    value.nameElement := ParseId(obj.complex('http://hl7.org/fhir/Expression.name'));
    value.languageElement := ParseCode(obj.complex('http://hl7.org/fhir/Expression.language'));
    value.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/Expression.expression'));
    value.referenceElement := ParseUri(obj.complex('http://hl7.org/fhir/Expression.reference'));
end;

procedure TFHIRTurtleComposer.ComposeExpression(parent :  TTurtleComplex; parentType, name : String; value : TFhirExpression; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Expression');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Expression', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'Expression', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(this, 'Expression', 'language', value.languageElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Expression', 'expression', value.expressionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'Expression', 'reference', value.referenceElement, false, -1);
end;

function TFHIRTurtleParser.ParseExtendedContactDetail(obj : TTurtleComplex) : TFhirExtendedContactDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExtendedContactDetail.create;
  try
    ParseExtendedContactDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExtendedContactDetailProperties(obj : TTurtleComplex; value : TFhirExtendedContactDetail);
var
  item : TTurtleComplex;
begin
    ParseDataTypeProperties(obj, value);
    value.purpose := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExtendedContactDetail.purpose'));
    for item in obj.complexes('http://hl7.org/fhir/ExtendedContactDetail.name') do
      value.nameList.Add(parseHumanName(item));
    for item in obj.complexes('http://hl7.org/fhir/ExtendedContactDetail.telecom') do
      value.telecomList.Add(parseContactPoint(item));
    value.address := ParseAddress(obj.complex('http://hl7.org/fhir/ExtendedContactDetail.address'));
    value.organization := ParseReference(obj.complex('http://hl7.org/fhir/ExtendedContactDetail.organization'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/ExtendedContactDetail.period'));
end;

procedure TFHIRTurtleComposer.ComposeExtendedContactDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirExtendedContactDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExtendedContactDetail');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ExtendedContactDetail', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.nameList.Count - 1 do
      ComposeHumanName(this, 'ExtendedContactDetail', 'name', value.nameList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.telecomList.Count - 1 do
      ComposeContactPoint(this, 'ExtendedContactDetail', 'telecom', value.telecomList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAddress(this, 'ExtendedContactDetail', 'address', value.addressElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'ExtendedContactDetail', 'organization', value.organizationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'ExtendedContactDetail', 'period', value.periodElement, false, -1);
end;

function TFHIRTurtleParser.ParseExtension(obj : TTurtleComplex) : TFhirExtension;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExtension.create;
  try
    ParseExtensionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExtensionProperties(obj : TTurtleComplex; value : TFhirExtension);
var
  item : TTurtleComplex;
begin
    ParseDataTypeProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Extension.url'));
    if obj.has('valueCanonical', item) then
      value.value := parseCanonical(item);
    if obj.has('valueCode', item) then
      value.value := parseCode(item);
    if obj.has('valueId', item) then
      value.value := parseId(item);
    if obj.has('valueMarkdown', item) then
      value.value := parseMarkdown(item);
    if obj.has('valueOid', item) then
      value.value := parseOid(item);
    if obj.has('valuePositiveInt', item) then
      value.value := parsePositiveInt(item);
    if obj.has('valueUnsignedInt', item) then
      value.value := parseUnsignedInt(item);
    if obj.has('valueUrl', item) then
      value.value := parseUrl(item);
    if obj.has('valueUuid', item) then
      value.value := parseUuid(item);
    if obj.has('valueAddress', item) then
      value.value := parseAddress(item);
    if obj.has('valueAge', item) then
      value.value := parseAge(item);
    if obj.has('valueAnnotation', item) then
      value.value := parseAnnotation(item);
    if obj.has('valueAttachment', item) then
      value.value := parseAttachment(item);
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueCodeableReference', item) then
      value.value := parseCodeableReference(item);
    if obj.has('valueCoding', item) then
      value.value := parseCoding(item);
    if obj.has('valueContactPoint', item) then
      value.value := parseContactPoint(item);
    if obj.has('valueCount', item) then
      value.value := parseCount(item);
    if obj.has('valueDistance', item) then
      value.value := parseDistance(item);
    if obj.has('valueDuration', item) then
      value.value := parseDuration(item);
    if obj.has('valueHumanName', item) then
      value.value := parseHumanName(item);
    if obj.has('valueIdentifier', item) then
      value.value := parseIdentifier(item);
    if obj.has('valueMoney', item) then
      value.value := parseMoney(item);
    if obj.has('valuePeriod', item) then
      value.value := parsePeriod(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueRange', item) then
      value.value := parseRange(item);
    if obj.has('valueRatio', item) then
      value.value := parseRatio(item);
    if obj.has('valueRatioRange', item) then
      value.value := parseRatioRange(item);
    if obj.has('valueReference', item) then
      value.value := parseReference(item);
    if obj.has('valueSampledData', item) then
      value.value := parseSampledData(item);
    if obj.has('valueSignature', item) then
      value.value := parseSignature(item);
    if obj.has('valueTiming', item) then
      value.value := parseTiming(item);
    if obj.has('valueContactDetail', item) then
      value.value := parseContactDetail(item);
    if obj.has('valueDataRequirement', item) then
      value.value := parseDataRequirement(item);
    if obj.has('valueExpression', item) then
      value.value := parseExpression(item);
    if obj.has('valueParameterDefinition', item) then
      value.value := parseParameterDefinition(item);
    if obj.has('valueRelatedArtifact', item) then
      value.value := parseRelatedArtifact(item);
    if obj.has('valueTriggerDefinition', item) then
      value.value := parseTriggerDefinition(item);
    if obj.has('valueUsageContext', item) then
      value.value := parseUsageContext(item);
    if obj.has('valueAvailability', item) then
      value.value := parseAvailability(item);
    if obj.has('valueExtendedContactDetail', item) then
      value.value := parseExtendedContactDetail(item);
    if obj.has('valueDosage', item) then
      value.value := parseDosage(item);
    if obj.has('valueMeta', item) then
      value.value := parseMeta(item);
    if obj.has('valueBase64Binary', item) then
      value.value := parseBase64Binary(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    if obj.has('valueDate', item) then
      value.value := parseDate(item);
    if obj.has('valueDateTime', item) then
      value.value := parseDateTime(item);
    if obj.has('valueDecimal', item) then
      value.value := parseDecimal(item);
    if obj.has('valueInstant', item) then
      value.value := parseInstant(item);
    if obj.has('valueInteger', item) then
      value.value := parseInteger(item);
    if obj.has('valueInteger64', item) then
      value.value := parseInteger64(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    if obj.has('valueTime', item) then
      value.value := parseTime(item);
    if obj.has('valueUri', item) then
      value.value := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeExtension(parent :  TTurtleComplex; parentType, name : String; value : TFhirExtension; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Extension');
  end;
  composeElement(this, '', name, value, false, index);
  ComposeUri(this, 'Extension', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.value is TFhirCanonical) {6} then
    ComposeCanonical(this, 'Extension', 'valueCanonical', TFhirCanonical(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirCode) {6} then
    ComposeCode(this, 'Extension', 'valueCode', TFhirCode(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirId) {6} then
    ComposeId(this, 'Extension', 'valueId', TFhirId(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'Extension', 'valueMarkdown', TFhirMarkdown(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirOid) {6} then
    ComposeOid(this, 'Extension', 'valueOid', TFhirOid(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'Extension', 'valuePositiveInt', TFhirPositiveInt(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'Extension', 'valueUnsignedInt', TFhirUnsignedInt(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirUrl) {6} then
    ComposeUrl(this, 'Extension', 'valueUrl', TFhirUrl(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirUuid) {6} then
    ComposeUuid(this, 'Extension', 'valueUuid', TFhirUuid(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirAddress) {6} then
    ComposeAddress(this, 'Extension', 'valueAddress', TFhirAddress(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirAge) {6} then
    ComposeAge(this, 'Extension', 'valueAge', TFhirAge(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'Extension', 'valueAnnotation', TFhirAnnotation(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Extension', 'valueAttachment', TFhirAttachment(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Extension', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirCodeableReference) {6} then
    ComposeCodeableReference(this, 'Extension', 'valueCodeableReference', TFhirCodeableReference(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirCoding) {6} then
    ComposeCoding(this, 'Extension', 'valueCoding', TFhirCoding(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'Extension', 'valueContactPoint', TFhirContactPoint(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirCount) {6} then
    ComposeCount(this, 'Extension', 'valueCount', TFhirCount(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirDistance) {6} then
    ComposeDistance(this, 'Extension', 'valueDistance', TFhirDistance(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirDuration) {6} then
    ComposeDuration(this, 'Extension', 'valueDuration', TFhirDuration(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirHumanName) {6} then
    ComposeHumanName(this, 'Extension', 'valueHumanName', TFhirHumanName(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'Extension', 'valueIdentifier', TFhirIdentifier(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirMoney) {6} then
    ComposeMoney(this, 'Extension', 'valueMoney', TFhirMoney(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'Extension', 'valuePeriod', TFhirPeriod(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Extension', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirRange) {6} then
    ComposeRange(this, 'Extension', 'valueRange', TFhirRange(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirRatio) {6} then
    ComposeRatio(this, 'Extension', 'valueRatio', TFhirRatio(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirRatioRange) {6} then
    ComposeRatioRange(this, 'Extension', 'valueRatioRange', TFhirRatioRange(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirReference) {6} then
    ComposeReference(this, 'Extension', 'valueReference', TFhirReference(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'Extension', 'valueSampledData', TFhirSampledData(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirSignature) {6} then
    ComposeSignature(this, 'Extension', 'valueSignature', TFhirSignature(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirTiming) {6} then
    ComposeTiming(this, 'Extension', 'valueTiming', TFhirTiming(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirContactDetail) {6} then
    ComposeContactDetail(this, 'Extension', 'valueContactDetail', TFhirContactDetail(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirDataRequirement) {6} then
    ComposeDataRequirement(this, 'Extension', 'valueDataRequirement', TFhirDataRequirement(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirExpression) {6} then
    ComposeExpression(this, 'Extension', 'valueExpression', TFhirExpression(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(this, 'Extension', 'valueParameterDefinition', TFhirParameterDefinition(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(this, 'Extension', 'valueRelatedArtifact', TFhirRelatedArtifact(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(this, 'Extension', 'valueTriggerDefinition', TFhirTriggerDefinition(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirUsageContext) {6} then
    ComposeUsageContext(this, 'Extension', 'valueUsageContext', TFhirUsageContext(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirAvailability) {6} then
    ComposeAvailability(this, 'Extension', 'valueAvailability', TFhirAvailability(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirExtendedContactDetail) {6} then
    ComposeExtendedContactDetail(this, 'Extension', 'valueExtendedContactDetail', TFhirExtendedContactDetail(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirDosage) {6} then
    ComposeDosage(this, 'Extension', 'valueDosage', TFhirDosage(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirMeta) {6} then
    ComposeMeta(this, 'Extension', 'valueMeta', TFhirMeta(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'Extension', 'valueBase64Binary', TFhirBase64Binary(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Extension', 'valueBoolean', TFhirBoolean(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirDate) {6} then
    ComposeDate(this, 'Extension', 'valueDate', TFhirDate(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Extension', 'valueDateTime', TFhirDateTime(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'Extension', 'valueDecimal', TFhirDecimal(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirInstant) {6} then
    ComposeInstant(this, 'Extension', 'valueInstant', TFhirInstant(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Extension', 'valueInteger', TFhirInteger(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirInteger64) {6} then
    ComposeInteger64(this, 'Extension', 'valueInteger64', TFhirInteger64(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirString) {6} then
    ComposeString(this, 'Extension', 'valueString', TFhirString(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirTime) {6} then
    ComposeTime(this, 'Extension', 'valueTime', TFhirTime(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirUri) {6} then
    ComposeUri(this, 'Extension', 'valueUri', TFhirUri(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseHumanName(obj : TTurtleComplex) : TFhirHumanName;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirHumanName.create;
  try
    ParseHumanNameProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseHumanNameProperties(obj : TTurtleComplex; value : TFhirHumanName);
var
  item : TTurtleComplex;
begin
    ParseDataTypeProperties(obj, value);
    value.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/HumanName.use'), CODES_TFhirNameUseEnum, SYSTEMS_TFhirNameUseEnum);
    value.textElement := ParseString(obj.complex('http://hl7.org/fhir/HumanName.text'));
    value.familyElement := ParseString(obj.complex('http://hl7.org/fhir/HumanName.family'));
    for item in obj.complexes('http://hl7.org/fhir/HumanName.given') do
      value.givenList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/HumanName.prefix') do
      value.prefixList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/HumanName.suffix') do
      value.suffixList.Add(parseString(item));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/HumanName.period'));
end;

procedure TFHIRTurtleComposer.ComposeHumanName(parent :  TTurtleComplex; parentType, name : String; value : TFhirHumanName; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:HumanName');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'HumanName', 'use', value.useElement, CODES_TFhirNameUseEnum, SYSTEMS_TFhirNameUseEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'HumanName', 'text', value.textElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'HumanName', 'family', value.familyElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.givenList.Count - 1 do
      ComposeString(this, 'HumanName', 'given', value.givenList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.prefixList.Count - 1 do
      ComposeString(this, 'HumanName', 'prefix', value.prefixList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.suffixList.Count - 1 do
      ComposeString(this, 'HumanName', 'suffix', value.suffixList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'HumanName', 'period', value.periodElement, false, -1);
end;

function TFHIRTurtleParser.ParseIdentifier(obj : TTurtleComplex) : TFhirIdentifier;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirIdentifier.create;
  try
    ParseIdentifierProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseIdentifierProperties(obj : TTurtleComplex; value : TFhirIdentifier);
begin
    ParseDataTypeProperties(obj, value);
    value.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/Identifier.use'), CODES_TFhirIdentifierUseEnum, SYSTEMS_TFhirIdentifierUseEnum);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Identifier.type'));
    value.systemElement := ParseUri(obj.complex('http://hl7.org/fhir/Identifier.system'));
    value.valueElement := ParseString(obj.complex('http://hl7.org/fhir/Identifier.value'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Identifier.period'));
    value.assigner := ParseReference(obj.complex('http://hl7.org/fhir/Identifier.assigner'));
end;

procedure TFHIRTurtleComposer.ComposeIdentifier(parent :  TTurtleComplex; parentType, name : String; value : TFhirIdentifier; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Identifier');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Identifier', 'use', value.useElement, CODES_TFhirIdentifierUseEnum, SYSTEMS_TFhirIdentifierUseEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Identifier', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'Identifier', 'system', value.systemElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Identifier', 'value', value.valueElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Identifier', 'period', value.periodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Identifier', 'assigner', value.assignerElement, false, -1);
end;

function TFHIRTurtleParser.ParseMeta(obj : TTurtleComplex) : TFhirMeta;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeta.create;
  try
    ParseMetaProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMetaProperties(obj : TTurtleComplex; value : TFhirMeta);
var
  item : TTurtleComplex;
begin
    ParseDataTypeProperties(obj, value);
    value.versionIdElement := ParseId(obj.complex('http://hl7.org/fhir/Meta.versionId'));
    value.lastUpdatedElement := ParseInstant(obj.complex('http://hl7.org/fhir/Meta.lastUpdated'));
    value.sourceElement := ParseUri(obj.complex('http://hl7.org/fhir/Meta.source'));
    for item in obj.complexes('http://hl7.org/fhir/Meta.profile') do
      value.profileList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/Meta.security') do
      value.securityList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Meta.tag') do
      value.tagList.Add(parseCoding(item));
end;

procedure TFHIRTurtleComposer.ComposeMeta(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeta; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Meta');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'Meta', 'versionId', value.versionIdElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'Meta', 'lastUpdated', value.lastUpdatedElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'Meta', 'source', value.sourceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.profileList.Count - 1 do
      ComposeCanonical(this, 'Meta', 'profile', value.profileList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.securityList.Count - 1 do
      ComposeCoding(this, 'Meta', 'security', value.securityList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.tagList.Count - 1 do
      ComposeCoding(this, 'Meta', 'tag', value.tagList[i], false, i);
end;

function TFHIRTurtleParser.ParseMonetaryComponent(obj : TTurtleComplex) : TFhirMonetaryComponent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMonetaryComponent.create;
  try
    ParseMonetaryComponentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMonetaryComponentProperties(obj : TTurtleComplex; value : TFhirMonetaryComponent);
begin
    ParseDataTypeProperties(obj, value);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/MonetaryComponent.type'), CODES_TFhirPriceComponentTypeEnum, SYSTEMS_TFhirPriceComponentTypeEnum);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MonetaryComponent.code'));
    value.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/MonetaryComponent.factor'));
    value.amount := ParseMoney(obj.complex('http://hl7.org/fhir/MonetaryComponent.amount'));
end;

procedure TFHIRTurtleComposer.ComposeMonetaryComponent(parent :  TTurtleComplex; parentType, name : String; value : TFhirMonetaryComponent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MonetaryComponent');
  end;
  composeElement(this, '', name, value, false, index);
  ComposeEnum(this, 'MonetaryComponent', 'type', value.type_Element, CODES_TFhirPriceComponentTypeEnum, SYSTEMS_TFhirPriceComponentTypeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MonetaryComponent', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'MonetaryComponent', 'factor', value.factorElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMoney(this, 'MonetaryComponent', 'amount', value.amountElement, false, -1);
end;

function TFHIRTurtleParser.ParseMoney(obj : TTurtleComplex) : TFhirMoney;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMoney.create;
  try
    ParseMoneyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMoneyProperties(obj : TTurtleComplex; value : TFhirMoney);
begin
    ParseDataTypeProperties(obj, value);
    value.valueElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Money.value'));
    value.currencyElement := ParseCode(obj.complex('http://hl7.org/fhir/Money.currency'));
end;

procedure TFHIRTurtleComposer.ComposeMoney(parent :  TTurtleComplex; parentType, name : String; value : TFhirMoney; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Money');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Money', 'value', value.valueElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(this, 'Money', 'currency', value.currencyElement, false, -1);
end;

function TFHIRTurtleParser.ParseNarrative(obj : TTurtleComplex) : TFhirNarrative;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNarrative.create;
  try
    ParseNarrativeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNarrativeProperties(obj : TTurtleComplex; value : TFhirNarrative);
begin
    ParseDataTypeProperties(obj, value);
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Narrative.status'), CODES_TFhirNarrativeStatusEnum, SYSTEMS_TFhirNarrativeStatusEnum);
    value.div_ := ParseXHtmlNode(obj.stringLiteral('http://hl7.org/fhir/Narrative.div'));
end;

procedure TFHIRTurtleComposer.ComposeNarrative(parent :  TTurtleComplex; parentType, name : String; value : TFhirNarrative; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Narrative');
  end;
  composeElement(this, '', name, value, false, index);
  ComposeEnum(this, 'Narrative', 'status', value.statusElement, CODES_TFhirNarrativeStatusEnum, SYSTEMS_TFhirNarrativeStatusEnum, false, -1);
  ComposeXHtmlNode(this, 'Narrative', 'div', value.div_Element, false, -1);
end;

function TFHIRTurtleParser.ParseParameterDefinition(obj : TTurtleComplex) : TFhirParameterDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirParameterDefinition.create;
  try
    ParseParameterDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseParameterDefinitionProperties(obj : TTurtleComplex; value : TFhirParameterDefinition);
begin
    ParseDataTypeProperties(obj, value);
    value.nameElement := ParseCode(obj.complex('http://hl7.org/fhir/ParameterDefinition.name'));
    value.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/ParameterDefinition.use'), CODES_TFhirOperationParameterUseEnum, SYSTEMS_TFhirOperationParameterUseEnum);
    value.minElement := ParseInteger(obj.complex('http://hl7.org/fhir/ParameterDefinition.min'));
    value.maxElement := ParseString(obj.complex('http://hl7.org/fhir/ParameterDefinition.max'));
    value.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/ParameterDefinition.documentation'));
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ParameterDefinition.type'), CODES_TFhirFHIRTypesEnum, SYSTEMS_TFhirFHIRTypesEnum);
    value.profileElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ParameterDefinition.profile'));
end;

procedure TFHIRTurtleComposer.ComposeParameterDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirParameterDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ParameterDefinition');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(this, 'ParameterDefinition', 'name', value.nameElement, false, -1);
  ComposeEnum(this, 'ParameterDefinition', 'use', value.useElement, CODES_TFhirOperationParameterUseEnum, SYSTEMS_TFhirOperationParameterUseEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'ParameterDefinition', 'min', value.minElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ParameterDefinition', 'max', value.maxElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ParameterDefinition', 'documentation', value.documentationElement, false, -1);
  ComposeEnum(this, 'ParameterDefinition', 'type', value.type_Element, CODES_TFhirFHIRTypesEnum, SYSTEMS_TFhirFHIRTypesEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(this, 'ParameterDefinition', 'profile', value.profileElement, false, -1);
end;

function TFHIRTurtleParser.ParsePeriod(obj : TTurtleComplex) : TFhirPeriod;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPeriod.create;
  try
    ParsePeriodProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePeriodProperties(obj : TTurtleComplex; value : TFhirPeriod);
begin
    ParseDataTypeProperties(obj, value);
    value.startElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Period.start'));
    value.end_Element := ParseDateTime(obj.complex('http://hl7.org/fhir/Period.end'));
end;

procedure TFHIRTurtleComposer.ComposePeriod(parent :  TTurtleComplex; parentType, name : String; value : TFhirPeriod; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Period');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Period', 'start', value.startElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Period', 'end', value.end_Element, false, -1);
end;

function TFHIRTurtleParser.ParseQuantity(obj : TTurtleComplex) : TFhirQuantity;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuantity.create;
  try
    ParseQuantityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuantityProperties(obj : TTurtleComplex; value : TFhirQuantity);
begin
    ParseDataTypeProperties(obj, value);
    value.valueElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Quantity.value'));
    value.comparatorElement := ParseEnum(obj.complex('http://hl7.org/fhir/Quantity.comparator'), CODES_TFhirQuantityComparatorEnum, SYSTEMS_TFhirQuantityComparatorEnum);
    value.unit_Element := ParseString(obj.complex('http://hl7.org/fhir/Quantity.unit'));
    value.systemElement := ParseUri(obj.complex('http://hl7.org/fhir/Quantity.system'));
    value.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/Quantity.code'));
end;

procedure TFHIRTurtleComposer.ComposeQuantity(parent :  TTurtleComplex; parentType, name : String; value : TFhirQuantity; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Quantity');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Quantity', 'value', value.valueElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Quantity', 'comparator', value.comparatorElement, CODES_TFhirQuantityComparatorEnum, SYSTEMS_TFhirQuantityComparatorEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Quantity', 'unit', value.unit_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'Quantity', 'system', value.systemElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(this, 'Quantity', 'code', value.codeElement, false, -1);
end;

function TFHIRTurtleParser.ParseRange(obj : TTurtleComplex) : TFhirRange;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRange.create;
  try
    ParseRangeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRangeProperties(obj : TTurtleComplex; value : TFhirRange);
begin
    ParseDataTypeProperties(obj, value);
    value.low := ParseQuantity(obj.complex('http://hl7.org/fhir/Range.low'));
    value.high := ParseQuantity(obj.complex('http://hl7.org/fhir/Range.high'));
end;

procedure TFHIRTurtleComposer.ComposeRange(parent :  TTurtleComplex; parentType, name : String; value : TFhirRange; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Range');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'Range', 'low', value.lowElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'Range', 'high', value.highElement, false, -1);
end;

function TFHIRTurtleParser.ParseRatio(obj : TTurtleComplex) : TFhirRatio;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRatio.create;
  try
    ParseRatioProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRatioProperties(obj : TTurtleComplex; value : TFhirRatio);
begin
    ParseDataTypeProperties(obj, value);
    value.numerator := ParseQuantity(obj.complex('http://hl7.org/fhir/Ratio.numerator'));
    value.denominator := ParseQuantity(obj.complex('http://hl7.org/fhir/Ratio.denominator'));
end;

procedure TFHIRTurtleComposer.ComposeRatio(parent :  TTurtleComplex; parentType, name : String; value : TFhirRatio; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Ratio');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'Ratio', 'numerator', value.numeratorElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'Ratio', 'denominator', value.denominatorElement, false, -1);
end;

function TFHIRTurtleParser.ParseRatioRange(obj : TTurtleComplex) : TFhirRatioRange;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRatioRange.create;
  try
    ParseRatioRangeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRatioRangeProperties(obj : TTurtleComplex; value : TFhirRatioRange);
begin
    ParseDataTypeProperties(obj, value);
    value.lowNumerator := ParseQuantity(obj.complex('http://hl7.org/fhir/RatioRange.lowNumerator'));
    value.highNumerator := ParseQuantity(obj.complex('http://hl7.org/fhir/RatioRange.highNumerator'));
    value.denominator := ParseQuantity(obj.complex('http://hl7.org/fhir/RatioRange.denominator'));
end;

procedure TFHIRTurtleComposer.ComposeRatioRange(parent :  TTurtleComplex; parentType, name : String; value : TFhirRatioRange; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RatioRange');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'RatioRange', 'lowNumerator', value.lowNumeratorElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'RatioRange', 'highNumerator', value.highNumeratorElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'RatioRange', 'denominator', value.denominatorElement, false, -1);
end;

function TFHIRTurtleParser.ParseReference(obj : TTurtleComplex) : TFhirReference;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirReference.create;
  try
    ParseReferenceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseReferenceProperties(obj : TTurtleComplex; value : TFhirReference);
begin
    ParseDataTypeProperties(obj, value);
    value.referenceElement := ParseString(obj.complex('http://hl7.org/fhir/Reference.reference'));
    value.type_Element := ParseUri(obj.complex('http://hl7.org/fhir/Reference.type'));
    value.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Reference.identifier'));
    value.displayElement := ParseString(obj.complex('http://hl7.org/fhir/Reference.display'));
end;

procedure TFHIRTurtleComposer.ComposeReference(parent :  TTurtleComplex; parentType, name : String; value : TFhirReference; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Reference');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Reference', 'reference', value.referenceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'Reference', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'Reference', 'identifier', value.identifierElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Reference', 'display', value.displayElement, false, -1);
end;

function TFHIRTurtleParser.ParseRelatedArtifact(obj : TTurtleComplex) : TFhirRelatedArtifact;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRelatedArtifact.create;
  try
    ParseRelatedArtifactProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRelatedArtifactProperties(obj : TTurtleComplex; value : TFhirRelatedArtifact);
var
  item : TTurtleComplex;
begin
    ParseDataTypeProperties(obj, value);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/RelatedArtifact.type'), CODES_TFhirRelatedArtifactTypeEnum, SYSTEMS_TFhirRelatedArtifactTypeEnum);
    for item in obj.complexes('http://hl7.org/fhir/RelatedArtifact.classifier') do
      value.classifierList.Add(parseCodeableConcept(item));
    value.label_Element := ParseString(obj.complex('http://hl7.org/fhir/RelatedArtifact.label'));
    value.displayElement := ParseString(obj.complex('http://hl7.org/fhir/RelatedArtifact.display'));
    value.citationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/RelatedArtifact.citation'));
    value.document := ParseAttachment(obj.complex('http://hl7.org/fhir/RelatedArtifact.document'));
    value.resourceElement := ParseCanonical(obj.complex('http://hl7.org/fhir/RelatedArtifact.resource'));
    value.resourceReference := ParseReference(obj.complex('http://hl7.org/fhir/RelatedArtifact.resourceReference'));
    value.publicationStatusElement := ParseEnum(obj.complex('http://hl7.org/fhir/RelatedArtifact.publicationStatus'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.publicationDateElement := ParseDate(obj.complex('http://hl7.org/fhir/RelatedArtifact.publicationDate'));
end;

procedure TFHIRTurtleComposer.ComposeRelatedArtifact(parent :  TTurtleComplex; parentType, name : String; value : TFhirRelatedArtifact; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RelatedArtifact');
  end;
  composeElement(this, '', name, value, false, index);
  ComposeEnum(this, 'RelatedArtifact', 'type', value.type_Element, CODES_TFhirRelatedArtifactTypeEnum, SYSTEMS_TFhirRelatedArtifactTypeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.classifierList.Count - 1 do
      ComposeCodeableConcept(this, 'RelatedArtifact', 'classifier', value.classifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'RelatedArtifact', 'label', value.label_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'RelatedArtifact', 'display', value.displayElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'RelatedArtifact', 'citation', value.citationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAttachment(this, 'RelatedArtifact', 'document', value.documentElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(this, 'RelatedArtifact', 'resource', value.resourceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'RelatedArtifact', 'resourceReference', value.resourceReferenceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'RelatedArtifact', 'publicationStatus', value.publicationStatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'RelatedArtifact', 'publicationDate', value.publicationDateElement, false, -1);
end;

function TFHIRTurtleParser.ParseSampledData(obj : TTurtleComplex) : TFhirSampledData;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSampledData.create;
  try
    ParseSampledDataProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSampledDataProperties(obj : TTurtleComplex; value : TFhirSampledData);
begin
    ParseDataTypeProperties(obj, value);
    value.origin := ParseQuantity(obj.complex('http://hl7.org/fhir/SampledData.origin'));
    value.intervalElement := ParseDecimal(obj.complex('http://hl7.org/fhir/SampledData.interval'));
    value.intervalUnitElement := ParseCode(obj.complex('http://hl7.org/fhir/SampledData.intervalUnit'));
    value.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/SampledData.factor'));
    value.lowerLimitElement := ParseDecimal(obj.complex('http://hl7.org/fhir/SampledData.lowerLimit'));
    value.upperLimitElement := ParseDecimal(obj.complex('http://hl7.org/fhir/SampledData.upperLimit'));
    value.dimensionsElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/SampledData.dimensions'));
    value.dataElement := ParseString(obj.complex('http://hl7.org/fhir/SampledData.data'));
end;

procedure TFHIRTurtleComposer.ComposeSampledData(parent :  TTurtleComplex; parentType, name : String; value : TFhirSampledData; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SampledData');
  end;
  composeElement(this, '', name, value, false, index);
  ComposeQuantity(this, 'SampledData', 'origin', value.originElement, false, -1);
  ComposeDecimal(this, 'SampledData', 'interval', value.intervalElement, false, -1);
  ComposeCode(this, 'SampledData', 'intervalUnit', value.intervalUnitElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'SampledData', 'factor', value.factorElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'SampledData', 'lowerLimit', value.lowerLimitElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'SampledData', 'upperLimit', value.upperLimitElement, false, -1);
  ComposePositiveInt(this, 'SampledData', 'dimensions', value.dimensionsElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'SampledData', 'data', value.dataElement, false, -1);
end;

function TFHIRTurtleParser.ParseSignature(obj : TTurtleComplex) : TFhirSignature;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSignature.create;
  try
    ParseSignatureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSignatureProperties(obj : TTurtleComplex; value : TFhirSignature);
var
  item : TTurtleComplex;
begin
    ParseDataTypeProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Signature.type') do
      value.type_List.Add(parseCoding(item));
    value.whenElement := ParseInstant(obj.complex('http://hl7.org/fhir/Signature.when'));
    value.who := ParseReference(obj.complex('http://hl7.org/fhir/Signature.who'));
    value.onBehalfOf := ParseReference(obj.complex('http://hl7.org/fhir/Signature.onBehalfOf'));
    value.targetFormatElement := ParseCode(obj.complex('http://hl7.org/fhir/Signature.targetFormat'));
    value.sigFormatElement := ParseCode(obj.complex('http://hl7.org/fhir/Signature.sigFormat'));
    value.dataElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/Signature.data'));
end;

procedure TFHIRTurtleComposer.ComposeSignature(parent :  TTurtleComplex; parentType, name : String; value : TFhirSignature; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Signature');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCoding(this, 'Signature', 'type', value.type_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'Signature', 'when', value.whenElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Signature', 'who', value.whoElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Signature', 'onBehalfOf', value.onBehalfOfElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'Signature', 'targetFormat', value.targetFormatElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'Signature', 'sigFormat', value.sigFormatElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBase64Binary(this, 'Signature', 'data', value.dataElement, false, -1);
end;

function TFHIRTurtleParser.ParseTriggerDefinition(obj : TTurtleComplex) : TFhirTriggerDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTriggerDefinition.create;
  try
    ParseTriggerDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTriggerDefinitionProperties(obj : TTurtleComplex; value : TFhirTriggerDefinition);
var
  item : TTurtleComplex;
begin
    ParseDataTypeProperties(obj, value);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/TriggerDefinition.type'), CODES_TFhirTriggerTypeEnum, SYSTEMS_TFhirTriggerTypeEnum);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TriggerDefinition.name'));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/TriggerDefinition.code'));
    value.subscriptionTopicElement := ParseCanonical(obj.complex('http://hl7.org/fhir/TriggerDefinition.subscriptionTopic'));
    if obj.has('timingTiming', item) then
      value.timing := parseTiming(item);
    if obj.has('timingReference', item) {a3} then
      value.timing := ParseReference(item);
    if obj.has('timingDate', item) then
      value.timing := parseDate(item);
    if obj.has('timingDateTime', item) then
      value.timing := parseDateTime(item);
    for item in obj.complexes('http://hl7.org/fhir/TriggerDefinition.data') do
      value.dataList.Add(parseDataRequirement(item));
    value.condition := ParseExpression(obj.complex('http://hl7.org/fhir/TriggerDefinition.condition'));
end;

procedure TFHIRTurtleComposer.ComposeTriggerDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirTriggerDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TriggerDefinition');
  end;
  composeElement(this, '', name, value, false, index);
  ComposeEnum(this, 'TriggerDefinition', 'type', value.type_Element, CODES_TFhirTriggerTypeEnum, SYSTEMS_TFhirTriggerTypeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'TriggerDefinition', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'TriggerDefinition', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(this, 'TriggerDefinition', 'subscriptionTopic', value.subscriptionTopicElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.timing is TFhirTiming) {6} then
    ComposeTiming(this, 'TriggerDefinition', 'timingTiming', TFhirTiming(value.timing), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.timing is TFhirReference) {2} then
    ComposeReference(this, 'TriggerDefinition', 'timingReference', TFhirReference(value.timing), false,-1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.timing is TFhirDate) {6} then
    ComposeDate(this, 'TriggerDefinition', 'timingDate', TFhirDate(value.timing), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.timing is TFhirDateTime) {6} then
    ComposeDateTime(this, 'TriggerDefinition', 'timingDateTime', TFhirDateTime(value.timing), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.dataList.Count - 1 do
      ComposeDataRequirement(this, 'TriggerDefinition', 'data', value.dataList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeExpression(this, 'TriggerDefinition', 'condition', value.conditionElement, false, -1);
end;

function TFHIRTurtleParser.ParseUsageContext(obj : TTurtleComplex) : TFhirUsageContext;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirUsageContext.create;
  try
    ParseUsageContextProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseUsageContextProperties(obj : TTurtleComplex; value : TFhirUsageContext);
var
  item : TTurtleComplex;
begin
    ParseDataTypeProperties(obj, value);
    value.code := ParseCoding(obj.complex('http://hl7.org/fhir/UsageContext.code'));
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueRange', item) then
      value.value := parseRange(item);
    if obj.has('valueReference', item) {a3} then
      value.value := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeUsageContext(parent :  TTurtleComplex; parentType, name : String; value : TFhirUsageContext; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:UsageContext');
  end;
  composeElement(this, '', name, value, false, index);
  ComposeCoding(this, 'UsageContext', 'code', value.codeElement, false, -1);
  if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'UsageContext', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'UsageContext', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (value.value is TFhirRange) {6} then
    ComposeRange(this, 'UsageContext', 'valueRange', TFhirRange(value.value), false, -1)
  else if (value.value is TFhirReference) {2} then
    ComposeReference(this, 'UsageContext', 'valueReference', TFhirReference(value.value), false,-1);
end;

function TFHIRTurtleParser.ParseVirtualServiceDetail(obj : TTurtleComplex) : TFhirVirtualServiceDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirVirtualServiceDetail.create;
  try
    ParseVirtualServiceDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseVirtualServiceDetailProperties(obj : TTurtleComplex; value : TFhirVirtualServiceDetail);
var
  item : TTurtleComplex;
begin
    ParseDataTypeProperties(obj, value);
    value.channelType := ParseCoding(obj.complex('http://hl7.org/fhir/VirtualServiceDetail.channelType'));
    if obj.has('addressUrl', item) then
      value.address := parseUrl(item);
    if obj.has('addressContactPoint', item) then
      value.address := parseContactPoint(item);
    if obj.has('addressExtendedContactDetail', item) then
      value.address := parseExtendedContactDetail(item);
    if obj.has('addressString', item) then
      value.address := parseString(item);
    for item in obj.complexes('http://hl7.org/fhir/VirtualServiceDetail.additionalInfo') do
      value.additionalInfoList.Add(parseUrl(item));
    value.maxParticipantsElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/VirtualServiceDetail.maxParticipants'));
    value.sessionKeyElement := ParseString(obj.complex('http://hl7.org/fhir/VirtualServiceDetail.sessionKey'));
end;

procedure TFHIRTurtleComposer.ComposeVirtualServiceDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirVirtualServiceDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:VirtualServiceDetail');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(this, 'VirtualServiceDetail', 'channelType', value.channelTypeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.address is TFhirUrl) {6} then
    ComposeUrl(this, 'VirtualServiceDetail', 'addressUrl', TFhirUrl(value.address), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.address is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'VirtualServiceDetail', 'addressContactPoint', TFhirContactPoint(value.address), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.address is TFhirExtendedContactDetail) {6} then
    ComposeExtendedContactDetail(this, 'VirtualServiceDetail', 'addressExtendedContactDetail', TFhirExtendedContactDetail(value.address), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.address is TFhirString) {6} then
    ComposeString(this, 'VirtualServiceDetail', 'addressString', TFhirString(value.address), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.additionalInfoList.Count - 1 do
      ComposeUrl(this, 'VirtualServiceDetail', 'additionalInfo', value.additionalInfoList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'VirtualServiceDetail', 'maxParticipants', value.maxParticipantsElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'VirtualServiceDetail', 'sessionKey', value.sessionKeyElement, false, -1);
end;

function TFHIRTurtleParser.ParseAge(obj : TTurtleComplex) : TFhirAge;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAge.create;
  try
    ParseAgeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAgeProperties(obj : TTurtleComplex; value : TFhirAge);
begin
    ParseQuantityProperties(obj, value);
end;

procedure TFHIRTurtleComposer.ComposeAge(parent :  TTurtleComplex; parentType, name : String; value : TFhirAge; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Age');
  end;
  composeElement(this, '', name, value, false, index);
end;

function TFHIRTurtleParser.ParseCount(obj : TTurtleComplex) : TFhirCount;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCount.create;
  try
    ParseCountProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCountProperties(obj : TTurtleComplex; value : TFhirCount);
begin
    ParseQuantityProperties(obj, value);
end;

procedure TFHIRTurtleComposer.ComposeCount(parent :  TTurtleComplex; parentType, name : String; value : TFhirCount; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Count');
  end;
  composeElement(this, '', name, value, false, index);
end;

function TFHIRTurtleParser.ParseDistance(obj : TTurtleComplex) : TFhirDistance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDistance.create;
  try
    ParseDistanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDistanceProperties(obj : TTurtleComplex; value : TFhirDistance);
begin
    ParseQuantityProperties(obj, value);
end;

procedure TFHIRTurtleComposer.ComposeDistance(parent :  TTurtleComplex; parentType, name : String; value : TFhirDistance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Distance');
  end;
  composeElement(this, '', name, value, false, index);
end;

function TFHIRTurtleParser.ParseDosageDoseAndRate(obj : TTurtleComplex) : TFhirDosageDoseAndRate;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDosageDoseAndRate.create;
  try
    ParseDosageDoseAndRateProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDosageDoseAndRateProperties(obj : TTurtleComplex; value : TFhirDosageDoseAndRate);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Dosage.doseAndRate.type'));
    if obj.has('doseRange', item) then
      value.dose := parseRange(item);
    if obj.has('doseQuantity', item) then
      value.dose := parseQuantity(item);
    if obj.has('rateRatio', item) then
      value.rate := parseRatio(item);
    if obj.has('rateRange', item) then
      value.rate := parseRange(item);
    if obj.has('rateQuantity', item) then
      value.rate := parseQuantity(item);
end;

procedure TFHIRTurtleComposer.ComposeDosageDoseAndRate(parent :  TTurtleComplex; parentType, name : String; value : TFhirDosageDoseAndRate; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DosageDoseAndRate');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Dosage.doseAndRate', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.dose is TFhirRange) {6} then
    ComposeRange(this, 'Dosage.doseAndRate', 'doseRange', TFhirRange(value.dose), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.dose is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Dosage.doseAndRate', 'doseQuantity', TFhirQuantity(value.dose), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.rate is TFhirRatio) {6} then
    ComposeRatio(this, 'Dosage.doseAndRate', 'rateRatio', TFhirRatio(value.rate), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.rate is TFhirRange) {6} then
    ComposeRange(this, 'Dosage.doseAndRate', 'rateRange', TFhirRange(value.rate), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.rate is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Dosage.doseAndRate', 'rateQuantity', TFhirQuantity(value.rate), false, -1);
end;

function TFHIRTurtleParser.ParseDosage(obj : TTurtleComplex) : TFhirDosage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDosage.create;
  try
    ParseDosageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDosageProperties(obj : TTurtleComplex; value : TFhirDosage);
var
  item : TTurtleComplex;
begin
    ParseBackboneTypeProperties(obj, value);
    value.sequenceElement := ParseInteger(obj.complex('http://hl7.org/fhir/Dosage.sequence'));
    value.textElement := ParseString(obj.complex('http://hl7.org/fhir/Dosage.text'));
    for item in obj.complexes('http://hl7.org/fhir/Dosage.additionalInstruction') do
      value.additionalInstructionList.Add(parseCodeableConcept(item));
    value.patientInstructionElement := ParseString(obj.complex('http://hl7.org/fhir/Dosage.patientInstruction'));
    value.timing := ParseTiming(obj.complex('http://hl7.org/fhir/Dosage.timing'));
    value.asNeededElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Dosage.asNeeded'));
    for item in obj.complexes('http://hl7.org/fhir/Dosage.asNeededFor') do
      value.asNeededForList.Add(parseCodeableConcept(item));
    value.site := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Dosage.site'));
    value.route := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Dosage.route'));
    value.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Dosage.method'));
    for item in obj.complexes('http://hl7.org/fhir/Dosage.doseAndRate') do
      value.doseAndRateList.Add(parseDosageDoseAndRate(item));
    for item in obj.complexes('http://hl7.org/fhir/Dosage.maxDosePerPeriod') do
      value.maxDosePerPeriodList.Add(parseRatio(item));
    value.maxDosePerAdministration := ParseQuantity(obj.complex('http://hl7.org/fhir/Dosage.maxDosePerAdministration'));
    value.maxDosePerLifetime := ParseQuantity(obj.complex('http://hl7.org/fhir/Dosage.maxDosePerLifetime'));
end;

procedure TFHIRTurtleComposer.ComposeDosage(parent :  TTurtleComplex; parentType, name : String; value : TFhirDosage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Dosage');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'Dosage', 'sequence', value.sequenceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Dosage', 'text', value.textElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.additionalInstructionList.Count - 1 do
      ComposeCodeableConcept(this, 'Dosage', 'additionalInstruction', value.additionalInstructionList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Dosage', 'patientInstruction', value.patientInstructionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(this, 'Dosage', 'timing', value.timingElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Dosage', 'asNeeded', value.asNeededElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.asNeededForList.Count - 1 do
      ComposeCodeableConcept(this, 'Dosage', 'asNeededFor', value.asNeededForList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Dosage', 'site', value.siteElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Dosage', 'route', value.routeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Dosage', 'method', value.methodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.doseAndRateList.Count - 1 do
      ComposeDosageDoseAndRate(this, 'Dosage', 'doseAndRate', value.doseAndRateList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.maxDosePerPeriodList.Count - 1 do
      ComposeRatio(this, 'Dosage', 'maxDosePerPeriod', value.maxDosePerPeriodList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'Dosage', 'maxDosePerAdministration', value.maxDosePerAdministrationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'Dosage', 'maxDosePerLifetime', value.maxDosePerLifetimeElement, false, -1);
end;

function TFHIRTurtleParser.ParseDuration(obj : TTurtleComplex) : TFhirDuration;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDuration.create;
  try
    ParseDurationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDurationProperties(obj : TTurtleComplex; value : TFhirDuration);
begin
    ParseQuantityProperties(obj, value);
end;

procedure TFHIRTurtleComposer.ComposeDuration(parent :  TTurtleComplex; parentType, name : String; value : TFhirDuration; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Duration');
  end;
  composeElement(this, '', name, value, false, index);
end;

function TFHIRTurtleParser.ParseElementDefinitionSlicing(obj : TTurtleComplex) : TFhirElementDefinitionSlicing;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionSlicing.create;
  try
    ParseElementDefinitionSlicingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionSlicingProperties(obj : TTurtleComplex; value : TFhirElementDefinitionSlicing);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.slicing.discriminator') do
      value.discriminatorList.Add(parseElementDefinitionSlicingDiscriminator(item));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.slicing.description'));
    value.orderedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ElementDefinition.slicing.ordered'));
    value.rulesElement := ParseEnum(obj.complex('http://hl7.org/fhir/ElementDefinition.slicing.rules'), CODES_TFhirSlicingRulesEnum, SYSTEMS_TFhirSlicingRulesEnum);
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionSlicing(parent :  TTurtleComplex; parentType, name : String; value : TFhirElementDefinitionSlicing; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionSlicing');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.discriminatorList.Count - 1 do
      ComposeElementDefinitionSlicingDiscriminator(this, 'ElementDefinition.slicing', 'discriminator', value.discriminatorList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinition.slicing', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ElementDefinition.slicing', 'ordered', value.orderedElement, false, -1);
  ComposeEnum(this, 'ElementDefinition.slicing', 'rules', value.rulesElement, CODES_TFhirSlicingRulesEnum, SYSTEMS_TFhirSlicingRulesEnum, false, -1);
end;

function TFHIRTurtleParser.ParseElementDefinitionSlicingDiscriminator(obj : TTurtleComplex) : TFhirElementDefinitionSlicingDiscriminator;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionSlicingDiscriminator.create;
  try
    ParseElementDefinitionSlicingDiscriminatorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionSlicingDiscriminatorProperties(obj : TTurtleComplex; value : TFhirElementDefinitionSlicingDiscriminator);
begin
    ParseElementProperties(obj, value);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ElementDefinition.slicing.discriminator.type'), CODES_TFhirDiscriminatorTypeEnum, SYSTEMS_TFhirDiscriminatorTypeEnum);
    value.pathElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.slicing.discriminator.path'));
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionSlicingDiscriminator(parent :  TTurtleComplex; parentType, name : String; value : TFhirElementDefinitionSlicingDiscriminator; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionSlicingDiscriminator');
  end;
  composeElement(this, '', name, value, false, index);
  ComposeEnum(this, 'ElementDefinition.slicing.discriminator', 'type', value.type_Element, CODES_TFhirDiscriminatorTypeEnum, SYSTEMS_TFhirDiscriminatorTypeEnum, false, -1);
  ComposeString(this, 'ElementDefinition.slicing.discriminator', 'path', value.pathElement, false, -1);
end;

function TFHIRTurtleParser.ParseElementDefinitionBase(obj : TTurtleComplex) : TFhirElementDefinitionBase;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionBase.create;
  try
    ParseElementDefinitionBaseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionBaseProperties(obj : TTurtleComplex; value : TFhirElementDefinitionBase);
begin
    ParseElementProperties(obj, value);
    value.pathElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.base.path'));
    value.minElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ElementDefinition.base.min'));
    value.maxElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.base.max'));
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionBase(parent :  TTurtleComplex; parentType, name : String; value : TFhirElementDefinitionBase; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionBase');
  end;
  composeElement(this, '', name, value, false, index);
  ComposeString(this, 'ElementDefinition.base', 'path', value.pathElement, false, -1);
  ComposeUnsignedInt(this, 'ElementDefinition.base', 'min', value.minElement, false, -1);
  ComposeString(this, 'ElementDefinition.base', 'max', value.maxElement, false, -1);
end;

function TFHIRTurtleParser.ParseElementDefinitionType(obj : TTurtleComplex) : TFhirElementDefinitionType;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionType.create;
  try
    ParseElementDefinitionTypeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionTypeProperties(obj : TTurtleComplex; value : TFhirElementDefinitionType);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, value);
    value.codeElement := ParseUri(obj.complex('http://hl7.org/fhir/ElementDefinition.type.code'));
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.type.profile') do
      value.profileList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.type.targetProfile') do
      value.targetProfileList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.type.aggregation') do
      value.aggregationList.Add(parseEnum(item, CODES_TFhirAggregationModeEnum, SYSTEMS_TFhirAggregationModeEnum));
    value.versioningElement := ParseEnum(obj.complex('http://hl7.org/fhir/ElementDefinition.type.versioning'), CODES_TFhirReferenceVersionRulesEnum, SYSTEMS_TFhirReferenceVersionRulesEnum);
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionType(parent :  TTurtleComplex; parentType, name : String; value : TFhirElementDefinitionType; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionType');
  end;
  composeElement(this, '', name, value, false, index);
  ComposeUri(this, 'ElementDefinition.type', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.profileList.Count - 1 do
      ComposeCanonical(this, 'ElementDefinition.type', 'profile', value.profileList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.targetProfileList.Count - 1 do
      ComposeCanonical(this, 'ElementDefinition.type', 'targetProfile', value.targetProfileList[i], false, i);
  for i := 0 to value.aggregationList.Count - 1 do
      ComposeEnum(this, 'ElementDefinition.type', 'aggregation', value.aggregationList[i], CODES_TFhirAggregationModeEnum, SYSTEMS_TFhirAggregationModeEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.aggregationList.Count - 1 do
      ComposeEnum(this, 'ElementDefinition.type', 'aggregation', value.aggregationList[i], CODES_TFhirAggregationModeEnum, SYSTEMS_TFhirAggregationModeEnum, false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'ElementDefinition.type', 'versioning', value.versioningElement, CODES_TFhirReferenceVersionRulesEnum, SYSTEMS_TFhirReferenceVersionRulesEnum, false, -1);
end;

function TFHIRTurtleParser.ParseElementDefinitionExample(obj : TTurtleComplex) : TFhirElementDefinitionExample;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionExample.create;
  try
    ParseElementDefinitionExampleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionExampleProperties(obj : TTurtleComplex; value : TFhirElementDefinitionExample);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, value);
    value.label_Element := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.example.label'));
    if obj.has('valueCanonical', item) then
      value.value := parseCanonical(item);
    if obj.has('valueCode', item) then
      value.value := parseCode(item);
    if obj.has('valueId', item) then
      value.value := parseId(item);
    if obj.has('valueMarkdown', item) then
      value.value := parseMarkdown(item);
    if obj.has('valueOid', item) then
      value.value := parseOid(item);
    if obj.has('valuePositiveInt', item) then
      value.value := parsePositiveInt(item);
    if obj.has('valueUnsignedInt', item) then
      value.value := parseUnsignedInt(item);
    if obj.has('valueUrl', item) then
      value.value := parseUrl(item);
    if obj.has('valueUuid', item) then
      value.value := parseUuid(item);
    if obj.has('valueAddress', item) then
      value.value := parseAddress(item);
    if obj.has('valueAge', item) then
      value.value := parseAge(item);
    if obj.has('valueAnnotation', item) then
      value.value := parseAnnotation(item);
    if obj.has('valueAttachment', item) then
      value.value := parseAttachment(item);
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueCodeableReference', item) then
      value.value := parseCodeableReference(item);
    if obj.has('valueCoding', item) then
      value.value := parseCoding(item);
    if obj.has('valueContactPoint', item) then
      value.value := parseContactPoint(item);
    if obj.has('valueCount', item) then
      value.value := parseCount(item);
    if obj.has('valueDistance', item) then
      value.value := parseDistance(item);
    if obj.has('valueDuration', item) then
      value.value := parseDuration(item);
    if obj.has('valueHumanName', item) then
      value.value := parseHumanName(item);
    if obj.has('valueIdentifier', item) then
      value.value := parseIdentifier(item);
    if obj.has('valueMoney', item) then
      value.value := parseMoney(item);
    if obj.has('valuePeriod', item) then
      value.value := parsePeriod(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueRange', item) then
      value.value := parseRange(item);
    if obj.has('valueRatio', item) then
      value.value := parseRatio(item);
    if obj.has('valueRatioRange', item) then
      value.value := parseRatioRange(item);
    if obj.has('valueReference', item) then
      value.value := parseReference(item);
    if obj.has('valueSampledData', item) then
      value.value := parseSampledData(item);
    if obj.has('valueSignature', item) then
      value.value := parseSignature(item);
    if obj.has('valueTiming', item) then
      value.value := parseTiming(item);
    if obj.has('valueContactDetail', item) then
      value.value := parseContactDetail(item);
    if obj.has('valueDataRequirement', item) then
      value.value := parseDataRequirement(item);
    if obj.has('valueExpression', item) then
      value.value := parseExpression(item);
    if obj.has('valueParameterDefinition', item) then
      value.value := parseParameterDefinition(item);
    if obj.has('valueRelatedArtifact', item) then
      value.value := parseRelatedArtifact(item);
    if obj.has('valueTriggerDefinition', item) then
      value.value := parseTriggerDefinition(item);
    if obj.has('valueUsageContext', item) then
      value.value := parseUsageContext(item);
    if obj.has('valueAvailability', item) then
      value.value := parseAvailability(item);
    if obj.has('valueExtendedContactDetail', item) then
      value.value := parseExtendedContactDetail(item);
    if obj.has('valueDosage', item) then
      value.value := parseDosage(item);
    if obj.has('valueMeta', item) then
      value.value := parseMeta(item);
    if obj.has('valueBase64Binary', item) then
      value.value := parseBase64Binary(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    if obj.has('valueDate', item) then
      value.value := parseDate(item);
    if obj.has('valueDateTime', item) then
      value.value := parseDateTime(item);
    if obj.has('valueDecimal', item) then
      value.value := parseDecimal(item);
    if obj.has('valueInstant', item) then
      value.value := parseInstant(item);
    if obj.has('valueInteger', item) then
      value.value := parseInteger(item);
    if obj.has('valueInteger64', item) then
      value.value := parseInteger64(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    if obj.has('valueTime', item) then
      value.value := parseTime(item);
    if obj.has('valueUri', item) then
      value.value := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionExample(parent :  TTurtleComplex; parentType, name : String; value : TFhirElementDefinitionExample; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionExample');
  end;
  composeElement(this, '', name, value, false, index);
  ComposeString(this, 'ElementDefinition.example', 'label', value.label_Element, false, -1);
  if (value.value is TFhirCanonical) {6} then
    ComposeCanonical(this, 'ElementDefinition.example', 'valueCanonical', TFhirCanonical(value.value), false, -1)
  else if (value.value is TFhirCode) {6} then
    ComposeCode(this, 'ElementDefinition.example', 'valueCode', TFhirCode(value.value), false, -1)
  else if (value.value is TFhirId) {6} then
    ComposeId(this, 'ElementDefinition.example', 'valueId', TFhirId(value.value), false, -1)
  else if (value.value is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'ElementDefinition.example', 'valueMarkdown', TFhirMarkdown(value.value), false, -1)
  else if (value.value is TFhirOid) {6} then
    ComposeOid(this, 'ElementDefinition.example', 'valueOid', TFhirOid(value.value), false, -1)
  else if (value.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'ElementDefinition.example', 'valuePositiveInt', TFhirPositiveInt(value.value), false, -1)
  else if (value.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'ElementDefinition.example', 'valueUnsignedInt', TFhirUnsignedInt(value.value), false, -1)
  else if (value.value is TFhirUrl) {6} then
    ComposeUrl(this, 'ElementDefinition.example', 'valueUrl', TFhirUrl(value.value), false, -1)
  else if (value.value is TFhirUuid) {6} then
    ComposeUuid(this, 'ElementDefinition.example', 'valueUuid', TFhirUuid(value.value), false, -1)
  else if (value.value is TFhirAddress) {6} then
    ComposeAddress(this, 'ElementDefinition.example', 'valueAddress', TFhirAddress(value.value), false, -1)
  else if (value.value is TFhirAge) {6} then
    ComposeAge(this, 'ElementDefinition.example', 'valueAge', TFhirAge(value.value), false, -1)
  else if (value.value is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'ElementDefinition.example', 'valueAnnotation', TFhirAnnotation(value.value), false, -1)
  else if (value.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'ElementDefinition.example', 'valueAttachment', TFhirAttachment(value.value), false, -1)
  else if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ElementDefinition.example', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (value.value is TFhirCodeableReference) {6} then
    ComposeCodeableReference(this, 'ElementDefinition.example', 'valueCodeableReference', TFhirCodeableReference(value.value), false, -1)
  else if (value.value is TFhirCoding) {6} then
    ComposeCoding(this, 'ElementDefinition.example', 'valueCoding', TFhirCoding(value.value), false, -1)
  else if (value.value is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'ElementDefinition.example', 'valueContactPoint', TFhirContactPoint(value.value), false, -1)
  else if (value.value is TFhirCount) {6} then
    ComposeCount(this, 'ElementDefinition.example', 'valueCount', TFhirCount(value.value), false, -1)
  else if (value.value is TFhirDistance) {6} then
    ComposeDistance(this, 'ElementDefinition.example', 'valueDistance', TFhirDistance(value.value), false, -1)
  else if (value.value is TFhirDuration) {6} then
    ComposeDuration(this, 'ElementDefinition.example', 'valueDuration', TFhirDuration(value.value), false, -1)
  else if (value.value is TFhirHumanName) {6} then
    ComposeHumanName(this, 'ElementDefinition.example', 'valueHumanName', TFhirHumanName(value.value), false, -1)
  else if (value.value is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'ElementDefinition.example', 'valueIdentifier', TFhirIdentifier(value.value), false, -1)
  else if (value.value is TFhirMoney) {6} then
    ComposeMoney(this, 'ElementDefinition.example', 'valueMoney', TFhirMoney(value.value), false, -1)
  else if (value.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'ElementDefinition.example', 'valuePeriod', TFhirPeriod(value.value), false, -1)
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ElementDefinition.example', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (value.value is TFhirRange) {6} then
    ComposeRange(this, 'ElementDefinition.example', 'valueRange', TFhirRange(value.value), false, -1)
  else if (value.value is TFhirRatio) {6} then
    ComposeRatio(this, 'ElementDefinition.example', 'valueRatio', TFhirRatio(value.value), false, -1)
  else if (value.value is TFhirRatioRange) {6} then
    ComposeRatioRange(this, 'ElementDefinition.example', 'valueRatioRange', TFhirRatioRange(value.value), false, -1)
  else if (value.value is TFhirReference) {6} then
    ComposeReference(this, 'ElementDefinition.example', 'valueReference', TFhirReference(value.value), false, -1)
  else if (value.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'ElementDefinition.example', 'valueSampledData', TFhirSampledData(value.value), false, -1)
  else if (value.value is TFhirSignature) {6} then
    ComposeSignature(this, 'ElementDefinition.example', 'valueSignature', TFhirSignature(value.value), false, -1)
  else if (value.value is TFhirTiming) {6} then
    ComposeTiming(this, 'ElementDefinition.example', 'valueTiming', TFhirTiming(value.value), false, -1)
  else if (value.value is TFhirContactDetail) {6} then
    ComposeContactDetail(this, 'ElementDefinition.example', 'valueContactDetail', TFhirContactDetail(value.value), false, -1)
  else if (value.value is TFhirDataRequirement) {6} then
    ComposeDataRequirement(this, 'ElementDefinition.example', 'valueDataRequirement', TFhirDataRequirement(value.value), false, -1)
  else if (value.value is TFhirExpression) {6} then
    ComposeExpression(this, 'ElementDefinition.example', 'valueExpression', TFhirExpression(value.value), false, -1)
  else if (value.value is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(this, 'ElementDefinition.example', 'valueParameterDefinition', TFhirParameterDefinition(value.value), false, -1)
  else if (value.value is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(this, 'ElementDefinition.example', 'valueRelatedArtifact', TFhirRelatedArtifact(value.value), false, -1)
  else if (value.value is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(this, 'ElementDefinition.example', 'valueTriggerDefinition', TFhirTriggerDefinition(value.value), false, -1)
  else if (value.value is TFhirUsageContext) {6} then
    ComposeUsageContext(this, 'ElementDefinition.example', 'valueUsageContext', TFhirUsageContext(value.value), false, -1)
  else if (value.value is TFhirAvailability) {6} then
    ComposeAvailability(this, 'ElementDefinition.example', 'valueAvailability', TFhirAvailability(value.value), false, -1)
  else if (value.value is TFhirExtendedContactDetail) {6} then
    ComposeExtendedContactDetail(this, 'ElementDefinition.example', 'valueExtendedContactDetail', TFhirExtendedContactDetail(value.value), false, -1)
  else if (value.value is TFhirDosage) {6} then
    ComposeDosage(this, 'ElementDefinition.example', 'valueDosage', TFhirDosage(value.value), false, -1)
  else if (value.value is TFhirMeta) {6} then
    ComposeMeta(this, 'ElementDefinition.example', 'valueMeta', TFhirMeta(value.value), false, -1)
  else if (value.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'ElementDefinition.example', 'valueBase64Binary', TFhirBase64Binary(value.value), false, -1)
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ElementDefinition.example', 'valueBoolean', TFhirBoolean(value.value), false, -1)
  else if (value.value is TFhirDate) {6} then
    ComposeDate(this, 'ElementDefinition.example', 'valueDate', TFhirDate(value.value), false, -1)
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ElementDefinition.example', 'valueDateTime', TFhirDateTime(value.value), false, -1)
  else if (value.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ElementDefinition.example', 'valueDecimal', TFhirDecimal(value.value), false, -1)
  else if (value.value is TFhirInstant) {6} then
    ComposeInstant(this, 'ElementDefinition.example', 'valueInstant', TFhirInstant(value.value), false, -1)
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(this, 'ElementDefinition.example', 'valueInteger', TFhirInteger(value.value), false, -1)
  else if (value.value is TFhirInteger64) {6} then
    ComposeInteger64(this, 'ElementDefinition.example', 'valueInteger64', TFhirInteger64(value.value), false, -1)
  else if (value.value is TFhirString) {6} then
    ComposeString(this, 'ElementDefinition.example', 'valueString', TFhirString(value.value), false, -1)
  else if (value.value is TFhirTime) {6} then
    ComposeTime(this, 'ElementDefinition.example', 'valueTime', TFhirTime(value.value), false, -1)
  else if (value.value is TFhirUri) {6} then
    ComposeUri(this, 'ElementDefinition.example', 'valueUri', TFhirUri(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseElementDefinitionConstraint(obj : TTurtleComplex) : TFhirElementDefinitionConstraint;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionConstraint.create;
  try
    ParseElementDefinitionConstraintProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionConstraintProperties(obj : TTurtleComplex; value : TFhirElementDefinitionConstraint);
begin
    ParseElementProperties(obj, value);
    value.keyElement := ParseId(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.key'));
    value.requirementsElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.requirements'));
    value.severityElement := ParseEnum(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.severity'), CODES_TFhirConstraintSeverityEnum, SYSTEMS_TFhirConstraintSeverityEnum);
    value.suppressElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.suppress'));
    value.humanElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.human'));
    value.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.expression'));
    value.xpathElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.xpath'));
    value.sourceElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.source'));
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionConstraint(parent :  TTurtleComplex; parentType, name : String; value : TFhirElementDefinitionConstraint; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionConstraint');
  end;
  composeElement(this, '', name, value, false, index);
  ComposeId(this, 'ElementDefinition.constraint', 'key', value.keyElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'ElementDefinition.constraint', 'requirements', value.requirementsElement, false, -1);
  ComposeEnum(this, 'ElementDefinition.constraint', 'severity', value.severityElement, CODES_TFhirConstraintSeverityEnum, SYSTEMS_TFhirConstraintSeverityEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ElementDefinition.constraint', 'suppress', value.suppressElement, false, -1);
  ComposeString(this, 'ElementDefinition.constraint', 'human', value.humanElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinition.constraint', 'expression', value.expressionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinition.constraint', 'xpath', value.xpathElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(this, 'ElementDefinition.constraint', 'source', value.sourceElement, false, -1);
end;

function TFHIRTurtleParser.ParseElementDefinitionBinding(obj : TTurtleComplex) : TFhirElementDefinitionBinding;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionBinding.create;
  try
    ParseElementDefinitionBindingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionBindingProperties(obj : TTurtleComplex; value : TFhirElementDefinitionBinding);
begin
    ParseElementProperties(obj, value);
    value.strengthElement := ParseEnum(obj.complex('http://hl7.org/fhir/ElementDefinition.binding.strength'), CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum);
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ElementDefinition.binding.description'));
    value.valueSetElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ElementDefinition.binding.valueSet'));
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionBinding(parent :  TTurtleComplex; parentType, name : String; value : TFhirElementDefinitionBinding; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionBinding');
  end;
  composeElement(this, '', name, value, false, index);
  ComposeEnum(this, 'ElementDefinition.binding', 'strength', value.strengthElement, CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'ElementDefinition.binding', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(this, 'ElementDefinition.binding', 'valueSet', value.valueSetElement, false, -1);
end;

function TFHIRTurtleParser.ParseElementDefinitionMapping(obj : TTurtleComplex) : TFhirElementDefinitionMapping;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionMapping.create;
  try
    ParseElementDefinitionMappingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionMappingProperties(obj : TTurtleComplex; value : TFhirElementDefinitionMapping);
begin
    ParseElementProperties(obj, value);
    value.identityElement := ParseId(obj.complex('http://hl7.org/fhir/ElementDefinition.mapping.identity'));
    value.languageElement := ParseCode(obj.complex('http://hl7.org/fhir/ElementDefinition.mapping.language'));
    value.mapElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.mapping.map'));
    value.commentElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ElementDefinition.mapping.comment'));
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionMapping(parent :  TTurtleComplex; parentType, name : String; value : TFhirElementDefinitionMapping; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionMapping');
  end;
  composeElement(this, '', name, value, false, index);
  ComposeId(this, 'ElementDefinition.mapping', 'identity', value.identityElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(this, 'ElementDefinition.mapping', 'language', value.languageElement, false, -1);
  ComposeString(this, 'ElementDefinition.mapping', 'map', value.mapElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'ElementDefinition.mapping', 'comment', value.commentElement, false, -1);
end;

function TFHIRTurtleParser.ParseElementDefinition(obj : TTurtleComplex) : TFhirElementDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinition.create;
  try
    ParseElementDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionProperties(obj : TTurtleComplex; value : TFhirElementDefinition);
var
  item : TTurtleComplex;
begin
    ParseBackboneTypeProperties(obj, value);
    value.pathElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.path'));
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.representation') do
      value.representationList.Add(parseEnum(item, CODES_TFhirPropertyRepresentationEnum, SYSTEMS_TFhirPropertyRepresentationEnum));
    value.sliceNameElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.sliceName'));
    value.sliceIsConstrainingElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ElementDefinition.sliceIsConstraining'));
    value.label_Element := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.label'));
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.code') do
      value.codeList.Add(parseCoding(item));
    value.slicing := ParseElementDefinitionSlicing(obj.complex('http://hl7.org/fhir/ElementDefinition.slicing'));
    value.shortElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.short'));
    value.definitionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ElementDefinition.definition'));
    value.commentElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ElementDefinition.comment'));
    value.requirementsElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ElementDefinition.requirements'));
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.alias') do
      value.aliasList.Add(parseString(item));
    value.minElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ElementDefinition.min'));
    value.maxElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.max'));
    value.base := ParseElementDefinitionBase(obj.complex('http://hl7.org/fhir/ElementDefinition.base'));
    value.contentReferenceElement := ParseUri(obj.complex('http://hl7.org/fhir/ElementDefinition.contentReference'));
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.type') do
      value.type_List.Add(parseElementDefinitionType(item));
    if obj.has('defaultValueCanonical', item) then
      value.defaultValue := parseCanonical(item);
    if obj.has('defaultValueCode', item) then
      value.defaultValue := parseCode(item);
    if obj.has('defaultValueId', item) then
      value.defaultValue := parseId(item);
    if obj.has('defaultValueMarkdown', item) then
      value.defaultValue := parseMarkdown(item);
    if obj.has('defaultValueOid', item) then
      value.defaultValue := parseOid(item);
    if obj.has('defaultValuePositiveInt', item) then
      value.defaultValue := parsePositiveInt(item);
    if obj.has('defaultValueUnsignedInt', item) then
      value.defaultValue := parseUnsignedInt(item);
    if obj.has('defaultValueUrl', item) then
      value.defaultValue := parseUrl(item);
    if obj.has('defaultValueUuid', item) then
      value.defaultValue := parseUuid(item);
    if obj.has('defaultValueAddress', item) then
      value.defaultValue := parseAddress(item);
    if obj.has('defaultValueAge', item) then
      value.defaultValue := parseAge(item);
    if obj.has('defaultValueAnnotation', item) then
      value.defaultValue := parseAnnotation(item);
    if obj.has('defaultValueAttachment', item) then
      value.defaultValue := parseAttachment(item);
    if obj.has('defaultValueCodeableConcept', item) then
      value.defaultValue := parseCodeableConcept(item);
    if obj.has('defaultValueCodeableReference', item) then
      value.defaultValue := parseCodeableReference(item);
    if obj.has('defaultValueCoding', item) then
      value.defaultValue := parseCoding(item);
    if obj.has('defaultValueContactPoint', item) then
      value.defaultValue := parseContactPoint(item);
    if obj.has('defaultValueCount', item) then
      value.defaultValue := parseCount(item);
    if obj.has('defaultValueDistance', item) then
      value.defaultValue := parseDistance(item);
    if obj.has('defaultValueDuration', item) then
      value.defaultValue := parseDuration(item);
    if obj.has('defaultValueHumanName', item) then
      value.defaultValue := parseHumanName(item);
    if obj.has('defaultValueIdentifier', item) then
      value.defaultValue := parseIdentifier(item);
    if obj.has('defaultValueMoney', item) then
      value.defaultValue := parseMoney(item);
    if obj.has('defaultValuePeriod', item) then
      value.defaultValue := parsePeriod(item);
    if obj.has('defaultValueQuantity', item) then
      value.defaultValue := parseQuantity(item);
    if obj.has('defaultValueRange', item) then
      value.defaultValue := parseRange(item);
    if obj.has('defaultValueRatio', item) then
      value.defaultValue := parseRatio(item);
    if obj.has('defaultValueRatioRange', item) then
      value.defaultValue := parseRatioRange(item);
    if obj.has('defaultValueReference', item) then
      value.defaultValue := parseReference(item);
    if obj.has('defaultValueSampledData', item) then
      value.defaultValue := parseSampledData(item);
    if obj.has('defaultValueSignature', item) then
      value.defaultValue := parseSignature(item);
    if obj.has('defaultValueTiming', item) then
      value.defaultValue := parseTiming(item);
    if obj.has('defaultValueContactDetail', item) then
      value.defaultValue := parseContactDetail(item);
    if obj.has('defaultValueDataRequirement', item) then
      value.defaultValue := parseDataRequirement(item);
    if obj.has('defaultValueExpression', item) then
      value.defaultValue := parseExpression(item);
    if obj.has('defaultValueParameterDefinition', item) then
      value.defaultValue := parseParameterDefinition(item);
    if obj.has('defaultValueRelatedArtifact', item) then
      value.defaultValue := parseRelatedArtifact(item);
    if obj.has('defaultValueTriggerDefinition', item) then
      value.defaultValue := parseTriggerDefinition(item);
    if obj.has('defaultValueUsageContext', item) then
      value.defaultValue := parseUsageContext(item);
    if obj.has('defaultValueAvailability', item) then
      value.defaultValue := parseAvailability(item);
    if obj.has('defaultValueExtendedContactDetail', item) then
      value.defaultValue := parseExtendedContactDetail(item);
    if obj.has('defaultValueDosage', item) then
      value.defaultValue := parseDosage(item);
    if obj.has('defaultValueMeta', item) then
      value.defaultValue := parseMeta(item);
    if obj.has('defaultValueBase64Binary', item) then
      value.defaultValue := parseBase64Binary(item);
    if obj.has('defaultValueBoolean', item) then
      value.defaultValue := parseBoolean(item);
    if obj.has('defaultValueDate', item) then
      value.defaultValue := parseDate(item);
    if obj.has('defaultValueDateTime', item) then
      value.defaultValue := parseDateTime(item);
    if obj.has('defaultValueDecimal', item) then
      value.defaultValue := parseDecimal(item);
    if obj.has('defaultValueInstant', item) then
      value.defaultValue := parseInstant(item);
    if obj.has('defaultValueInteger', item) then
      value.defaultValue := parseInteger(item);
    if obj.has('defaultValueInteger64', item) then
      value.defaultValue := parseInteger64(item);
    if obj.has('defaultValueString', item) then
      value.defaultValue := parseString(item);
    if obj.has('defaultValueTime', item) then
      value.defaultValue := parseTime(item);
    if obj.has('defaultValueUri', item) then
      value.defaultValue := parseUri(item);
    value.meaningWhenMissingElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ElementDefinition.meaningWhenMissing'));
    value.orderMeaningElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.orderMeaning'));
    if obj.has('fixedCanonical', item) then
      value.fixed := parseCanonical(item);
    if obj.has('fixedCode', item) then
      value.fixed := parseCode(item);
    if obj.has('fixedId', item) then
      value.fixed := parseId(item);
    if obj.has('fixedMarkdown', item) then
      value.fixed := parseMarkdown(item);
    if obj.has('fixedOid', item) then
      value.fixed := parseOid(item);
    if obj.has('fixedPositiveInt', item) then
      value.fixed := parsePositiveInt(item);
    if obj.has('fixedUnsignedInt', item) then
      value.fixed := parseUnsignedInt(item);
    if obj.has('fixedUrl', item) then
      value.fixed := parseUrl(item);
    if obj.has('fixedUuid', item) then
      value.fixed := parseUuid(item);
    if obj.has('fixedAddress', item) then
      value.fixed := parseAddress(item);
    if obj.has('fixedAge', item) then
      value.fixed := parseAge(item);
    if obj.has('fixedAnnotation', item) then
      value.fixed := parseAnnotation(item);
    if obj.has('fixedAttachment', item) then
      value.fixed := parseAttachment(item);
    if obj.has('fixedCodeableConcept', item) then
      value.fixed := parseCodeableConcept(item);
    if obj.has('fixedCodeableReference', item) then
      value.fixed := parseCodeableReference(item);
    if obj.has('fixedCoding', item) then
      value.fixed := parseCoding(item);
    if obj.has('fixedContactPoint', item) then
      value.fixed := parseContactPoint(item);
    if obj.has('fixedCount', item) then
      value.fixed := parseCount(item);
    if obj.has('fixedDistance', item) then
      value.fixed := parseDistance(item);
    if obj.has('fixedDuration', item) then
      value.fixed := parseDuration(item);
    if obj.has('fixedHumanName', item) then
      value.fixed := parseHumanName(item);
    if obj.has('fixedIdentifier', item) then
      value.fixed := parseIdentifier(item);
    if obj.has('fixedMoney', item) then
      value.fixed := parseMoney(item);
    if obj.has('fixedPeriod', item) then
      value.fixed := parsePeriod(item);
    if obj.has('fixedQuantity', item) then
      value.fixed := parseQuantity(item);
    if obj.has('fixedRange', item) then
      value.fixed := parseRange(item);
    if obj.has('fixedRatio', item) then
      value.fixed := parseRatio(item);
    if obj.has('fixedRatioRange', item) then
      value.fixed := parseRatioRange(item);
    if obj.has('fixedReference', item) then
      value.fixed := parseReference(item);
    if obj.has('fixedSampledData', item) then
      value.fixed := parseSampledData(item);
    if obj.has('fixedSignature', item) then
      value.fixed := parseSignature(item);
    if obj.has('fixedTiming', item) then
      value.fixed := parseTiming(item);
    if obj.has('fixedContactDetail', item) then
      value.fixed := parseContactDetail(item);
    if obj.has('fixedDataRequirement', item) then
      value.fixed := parseDataRequirement(item);
    if obj.has('fixedExpression', item) then
      value.fixed := parseExpression(item);
    if obj.has('fixedParameterDefinition', item) then
      value.fixed := parseParameterDefinition(item);
    if obj.has('fixedRelatedArtifact', item) then
      value.fixed := parseRelatedArtifact(item);
    if obj.has('fixedTriggerDefinition', item) then
      value.fixed := parseTriggerDefinition(item);
    if obj.has('fixedUsageContext', item) then
      value.fixed := parseUsageContext(item);
    if obj.has('fixedAvailability', item) then
      value.fixed := parseAvailability(item);
    if obj.has('fixedExtendedContactDetail', item) then
      value.fixed := parseExtendedContactDetail(item);
    if obj.has('fixedDosage', item) then
      value.fixed := parseDosage(item);
    if obj.has('fixedMeta', item) then
      value.fixed := parseMeta(item);
    if obj.has('fixedBase64Binary', item) then
      value.fixed := parseBase64Binary(item);
    if obj.has('fixedBoolean', item) then
      value.fixed := parseBoolean(item);
    if obj.has('fixedDate', item) then
      value.fixed := parseDate(item);
    if obj.has('fixedDateTime', item) then
      value.fixed := parseDateTime(item);
    if obj.has('fixedDecimal', item) then
      value.fixed := parseDecimal(item);
    if obj.has('fixedInstant', item) then
      value.fixed := parseInstant(item);
    if obj.has('fixedInteger', item) then
      value.fixed := parseInteger(item);
    if obj.has('fixedInteger64', item) then
      value.fixed := parseInteger64(item);
    if obj.has('fixedString', item) then
      value.fixed := parseString(item);
    if obj.has('fixedTime', item) then
      value.fixed := parseTime(item);
    if obj.has('fixedUri', item) then
      value.fixed := parseUri(item);
    if obj.has('patternCanonical', item) then
      value.pattern := parseCanonical(item);
    if obj.has('patternCode', item) then
      value.pattern := parseCode(item);
    if obj.has('patternId', item) then
      value.pattern := parseId(item);
    if obj.has('patternMarkdown', item) then
      value.pattern := parseMarkdown(item);
    if obj.has('patternOid', item) then
      value.pattern := parseOid(item);
    if obj.has('patternPositiveInt', item) then
      value.pattern := parsePositiveInt(item);
    if obj.has('patternUnsignedInt', item) then
      value.pattern := parseUnsignedInt(item);
    if obj.has('patternUrl', item) then
      value.pattern := parseUrl(item);
    if obj.has('patternUuid', item) then
      value.pattern := parseUuid(item);
    if obj.has('patternAddress', item) then
      value.pattern := parseAddress(item);
    if obj.has('patternAge', item) then
      value.pattern := parseAge(item);
    if obj.has('patternAnnotation', item) then
      value.pattern := parseAnnotation(item);
    if obj.has('patternAttachment', item) then
      value.pattern := parseAttachment(item);
    if obj.has('patternCodeableConcept', item) then
      value.pattern := parseCodeableConcept(item);
    if obj.has('patternCodeableReference', item) then
      value.pattern := parseCodeableReference(item);
    if obj.has('patternCoding', item) then
      value.pattern := parseCoding(item);
    if obj.has('patternContactPoint', item) then
      value.pattern := parseContactPoint(item);
    if obj.has('patternCount', item) then
      value.pattern := parseCount(item);
    if obj.has('patternDistance', item) then
      value.pattern := parseDistance(item);
    if obj.has('patternDuration', item) then
      value.pattern := parseDuration(item);
    if obj.has('patternHumanName', item) then
      value.pattern := parseHumanName(item);
    if obj.has('patternIdentifier', item) then
      value.pattern := parseIdentifier(item);
    if obj.has('patternMoney', item) then
      value.pattern := parseMoney(item);
    if obj.has('patternPeriod', item) then
      value.pattern := parsePeriod(item);
    if obj.has('patternQuantity', item) then
      value.pattern := parseQuantity(item);
    if obj.has('patternRange', item) then
      value.pattern := parseRange(item);
    if obj.has('patternRatio', item) then
      value.pattern := parseRatio(item);
    if obj.has('patternRatioRange', item) then
      value.pattern := parseRatioRange(item);
    if obj.has('patternReference', item) then
      value.pattern := parseReference(item);
    if obj.has('patternSampledData', item) then
      value.pattern := parseSampledData(item);
    if obj.has('patternSignature', item) then
      value.pattern := parseSignature(item);
    if obj.has('patternTiming', item) then
      value.pattern := parseTiming(item);
    if obj.has('patternContactDetail', item) then
      value.pattern := parseContactDetail(item);
    if obj.has('patternDataRequirement', item) then
      value.pattern := parseDataRequirement(item);
    if obj.has('patternExpression', item) then
      value.pattern := parseExpression(item);
    if obj.has('patternParameterDefinition', item) then
      value.pattern := parseParameterDefinition(item);
    if obj.has('patternRelatedArtifact', item) then
      value.pattern := parseRelatedArtifact(item);
    if obj.has('patternTriggerDefinition', item) then
      value.pattern := parseTriggerDefinition(item);
    if obj.has('patternUsageContext', item) then
      value.pattern := parseUsageContext(item);
    if obj.has('patternAvailability', item) then
      value.pattern := parseAvailability(item);
    if obj.has('patternExtendedContactDetail', item) then
      value.pattern := parseExtendedContactDetail(item);
    if obj.has('patternDosage', item) then
      value.pattern := parseDosage(item);
    if obj.has('patternMeta', item) then
      value.pattern := parseMeta(item);
    if obj.has('patternBase64Binary', item) then
      value.pattern := parseBase64Binary(item);
    if obj.has('patternBoolean', item) then
      value.pattern := parseBoolean(item);
    if obj.has('patternDate', item) then
      value.pattern := parseDate(item);
    if obj.has('patternDateTime', item) then
      value.pattern := parseDateTime(item);
    if obj.has('patternDecimal', item) then
      value.pattern := parseDecimal(item);
    if obj.has('patternInstant', item) then
      value.pattern := parseInstant(item);
    if obj.has('patternInteger', item) then
      value.pattern := parseInteger(item);
    if obj.has('patternInteger64', item) then
      value.pattern := parseInteger64(item);
    if obj.has('patternString', item) then
      value.pattern := parseString(item);
    if obj.has('patternTime', item) then
      value.pattern := parseTime(item);
    if obj.has('patternUri', item) then
      value.pattern := parseUri(item);
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.example') do
      value.exampleList.Add(parseElementDefinitionExample(item));
    if obj.has('minValuePositiveInt', item) then
      value.minValue := parsePositiveInt(item);
    if obj.has('minValueUnsignedInt', item) then
      value.minValue := parseUnsignedInt(item);
    if obj.has('minValueQuantity', item) then
      value.minValue := parseQuantity(item);
    if obj.has('minValueDate', item) then
      value.minValue := parseDate(item);
    if obj.has('minValueDateTime', item) then
      value.minValue := parseDateTime(item);
    if obj.has('minValueInstant', item) then
      value.minValue := parseInstant(item);
    if obj.has('minValueTime', item) then
      value.minValue := parseTime(item);
    if obj.has('minValueDecimal', item) then
      value.minValue := parseDecimal(item);
    if obj.has('minValueInteger', item) then
      value.minValue := parseInteger(item);
    if obj.has('minValueInteger64', item) then
      value.minValue := parseInteger64(item);
    if obj.has('maxValuePositiveInt', item) then
      value.maxValue := parsePositiveInt(item);
    if obj.has('maxValueUnsignedInt', item) then
      value.maxValue := parseUnsignedInt(item);
    if obj.has('maxValueQuantity', item) then
      value.maxValue := parseQuantity(item);
    if obj.has('maxValueDate', item) then
      value.maxValue := parseDate(item);
    if obj.has('maxValueDateTime', item) then
      value.maxValue := parseDateTime(item);
    if obj.has('maxValueInstant', item) then
      value.maxValue := parseInstant(item);
    if obj.has('maxValueTime', item) then
      value.maxValue := parseTime(item);
    if obj.has('maxValueDecimal', item) then
      value.maxValue := parseDecimal(item);
    if obj.has('maxValueInteger', item) then
      value.maxValue := parseInteger(item);
    if obj.has('maxValueInteger64', item) then
      value.maxValue := parseInteger64(item);
    value.maxLengthElement := ParseInteger(obj.complex('http://hl7.org/fhir/ElementDefinition.maxLength'));
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.condition') do
      value.conditionList.Add(parseId(item));
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.constraint') do
      value.constraintList.Add(parseElementDefinitionConstraint(item));
    value.mustSupportElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ElementDefinition.mustSupport'));
    value.isModifierElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ElementDefinition.isModifier'));
    value.isModifierReasonElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.isModifierReason'));
    value.isSummaryElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ElementDefinition.isSummary'));
    value.binding := ParseElementDefinitionBinding(obj.complex('http://hl7.org/fhir/ElementDefinition.binding'));
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.mapping') do
      value.mappingList.Add(parseElementDefinitionMapping(item));
end;

procedure TFHIRTurtleComposer.ComposeElementDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirElementDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinition');
  end;
  composeElement(this, '', name, value, false, index);
  ComposeString(this, 'ElementDefinition', 'path', value.pathElement, false, -1);
  for i := 0 to value.representationList.Count - 1 do
      ComposeEnum(this, 'ElementDefinition', 'representation', value.representationList[i], CODES_TFhirPropertyRepresentationEnum, SYSTEMS_TFhirPropertyRepresentationEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.representationList.Count - 1 do
      ComposeEnum(this, 'ElementDefinition', 'representation', value.representationList[i], CODES_TFhirPropertyRepresentationEnum, SYSTEMS_TFhirPropertyRepresentationEnum, false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinition', 'sliceName', value.sliceNameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ElementDefinition', 'sliceIsConstraining', value.sliceIsConstrainingElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinition', 'label', value.label_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCoding(this, 'ElementDefinition', 'code', value.codeList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeElementDefinitionSlicing(this, 'ElementDefinition', 'slicing', value.slicingElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinition', 'short', value.shortElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'ElementDefinition', 'definition', value.definitionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'ElementDefinition', 'comment', value.commentElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'ElementDefinition', 'requirements', value.requirementsElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.aliasList.Count - 1 do
      ComposeString(this, 'ElementDefinition', 'alias', value.aliasList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'ElementDefinition', 'min', value.minElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinition', 'max', value.maxElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeElementDefinitionBase(this, 'ElementDefinition', 'base', value.baseElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ElementDefinition', 'contentReference', value.contentReferenceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeElementDefinitionType(this, 'ElementDefinition', 'type', value.type_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirCanonical) {6} then
    ComposeCanonical(this, 'ElementDefinition', 'defaultValueCanonical', TFhirCanonical(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirCode) {6} then
    ComposeCode(this, 'ElementDefinition', 'defaultValueCode', TFhirCode(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirId) {6} then
    ComposeId(this, 'ElementDefinition', 'defaultValueId', TFhirId(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'ElementDefinition', 'defaultValueMarkdown', TFhirMarkdown(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirOid) {6} then
    ComposeOid(this, 'ElementDefinition', 'defaultValueOid', TFhirOid(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'ElementDefinition', 'defaultValuePositiveInt', TFhirPositiveInt(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'defaultValueUnsignedInt', TFhirUnsignedInt(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirUrl) {6} then
    ComposeUrl(this, 'ElementDefinition', 'defaultValueUrl', TFhirUrl(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirUuid) {6} then
    ComposeUuid(this, 'ElementDefinition', 'defaultValueUuid', TFhirUuid(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirAddress) {6} then
    ComposeAddress(this, 'ElementDefinition', 'defaultValueAddress', TFhirAddress(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirAge) {6} then
    ComposeAge(this, 'ElementDefinition', 'defaultValueAge', TFhirAge(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'ElementDefinition', 'defaultValueAnnotation', TFhirAnnotation(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirAttachment) {6} then
    ComposeAttachment(this, 'ElementDefinition', 'defaultValueAttachment', TFhirAttachment(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ElementDefinition', 'defaultValueCodeableConcept', TFhirCodeableConcept(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirCodeableReference) {6} then
    ComposeCodeableReference(this, 'ElementDefinition', 'defaultValueCodeableReference', TFhirCodeableReference(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirCoding) {6} then
    ComposeCoding(this, 'ElementDefinition', 'defaultValueCoding', TFhirCoding(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'ElementDefinition', 'defaultValueContactPoint', TFhirContactPoint(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirCount) {6} then
    ComposeCount(this, 'ElementDefinition', 'defaultValueCount', TFhirCount(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirDistance) {6} then
    ComposeDistance(this, 'ElementDefinition', 'defaultValueDistance', TFhirDistance(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirDuration) {6} then
    ComposeDuration(this, 'ElementDefinition', 'defaultValueDuration', TFhirDuration(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirHumanName) {6} then
    ComposeHumanName(this, 'ElementDefinition', 'defaultValueHumanName', TFhirHumanName(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'ElementDefinition', 'defaultValueIdentifier', TFhirIdentifier(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirMoney) {6} then
    ComposeMoney(this, 'ElementDefinition', 'defaultValueMoney', TFhirMoney(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirPeriod) {6} then
    ComposePeriod(this, 'ElementDefinition', 'defaultValuePeriod', TFhirPeriod(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ElementDefinition', 'defaultValueQuantity', TFhirQuantity(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirRange) {6} then
    ComposeRange(this, 'ElementDefinition', 'defaultValueRange', TFhirRange(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirRatio) {6} then
    ComposeRatio(this, 'ElementDefinition', 'defaultValueRatio', TFhirRatio(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirRatioRange) {6} then
    ComposeRatioRange(this, 'ElementDefinition', 'defaultValueRatioRange', TFhirRatioRange(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirReference) {6} then
    ComposeReference(this, 'ElementDefinition', 'defaultValueReference', TFhirReference(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirSampledData) {6} then
    ComposeSampledData(this, 'ElementDefinition', 'defaultValueSampledData', TFhirSampledData(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirSignature) {6} then
    ComposeSignature(this, 'ElementDefinition', 'defaultValueSignature', TFhirSignature(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirTiming) {6} then
    ComposeTiming(this, 'ElementDefinition', 'defaultValueTiming', TFhirTiming(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirContactDetail) {6} then
    ComposeContactDetail(this, 'ElementDefinition', 'defaultValueContactDetail', TFhirContactDetail(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirDataRequirement) {6} then
    ComposeDataRequirement(this, 'ElementDefinition', 'defaultValueDataRequirement', TFhirDataRequirement(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirExpression) {6} then
    ComposeExpression(this, 'ElementDefinition', 'defaultValueExpression', TFhirExpression(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(this, 'ElementDefinition', 'defaultValueParameterDefinition', TFhirParameterDefinition(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(this, 'ElementDefinition', 'defaultValueRelatedArtifact', TFhirRelatedArtifact(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(this, 'ElementDefinition', 'defaultValueTriggerDefinition', TFhirTriggerDefinition(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirUsageContext) {6} then
    ComposeUsageContext(this, 'ElementDefinition', 'defaultValueUsageContext', TFhirUsageContext(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirAvailability) {6} then
    ComposeAvailability(this, 'ElementDefinition', 'defaultValueAvailability', TFhirAvailability(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirExtendedContactDetail) {6} then
    ComposeExtendedContactDetail(this, 'ElementDefinition', 'defaultValueExtendedContactDetail', TFhirExtendedContactDetail(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirDosage) {6} then
    ComposeDosage(this, 'ElementDefinition', 'defaultValueDosage', TFhirDosage(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirMeta) {6} then
    ComposeMeta(this, 'ElementDefinition', 'defaultValueMeta', TFhirMeta(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'ElementDefinition', 'defaultValueBase64Binary', TFhirBase64Binary(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ElementDefinition', 'defaultValueBoolean', TFhirBoolean(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirDate) {6} then
    ComposeDate(this, 'ElementDefinition', 'defaultValueDate', TFhirDate(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ElementDefinition', 'defaultValueDateTime', TFhirDateTime(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ElementDefinition', 'defaultValueDecimal', TFhirDecimal(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirInstant) {6} then
    ComposeInstant(this, 'ElementDefinition', 'defaultValueInstant', TFhirInstant(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirInteger) {6} then
    ComposeInteger(this, 'ElementDefinition', 'defaultValueInteger', TFhirInteger(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirInteger64) {6} then
    ComposeInteger64(this, 'ElementDefinition', 'defaultValueInteger64', TFhirInteger64(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirString) {6} then
    ComposeString(this, 'ElementDefinition', 'defaultValueString', TFhirString(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirTime) {6} then
    ComposeTime(this, 'ElementDefinition', 'defaultValueTime', TFhirTime(value.defaultValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.defaultValue is TFhirUri) {6} then
    ComposeUri(this, 'ElementDefinition', 'defaultValueUri', TFhirUri(value.defaultValue), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'ElementDefinition', 'meaningWhenMissing', value.meaningWhenMissingElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinition', 'orderMeaning', value.orderMeaningElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirCanonical) {6} then
    ComposeCanonical(this, 'ElementDefinition', 'fixedCanonical', TFhirCanonical(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirCode) {6} then
    ComposeCode(this, 'ElementDefinition', 'fixedCode', TFhirCode(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirId) {6} then
    ComposeId(this, 'ElementDefinition', 'fixedId', TFhirId(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'ElementDefinition', 'fixedMarkdown', TFhirMarkdown(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirOid) {6} then
    ComposeOid(this, 'ElementDefinition', 'fixedOid', TFhirOid(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'ElementDefinition', 'fixedPositiveInt', TFhirPositiveInt(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'fixedUnsignedInt', TFhirUnsignedInt(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirUrl) {6} then
    ComposeUrl(this, 'ElementDefinition', 'fixedUrl', TFhirUrl(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirUuid) {6} then
    ComposeUuid(this, 'ElementDefinition', 'fixedUuid', TFhirUuid(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirAddress) {6} then
    ComposeAddress(this, 'ElementDefinition', 'fixedAddress', TFhirAddress(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirAge) {6} then
    ComposeAge(this, 'ElementDefinition', 'fixedAge', TFhirAge(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'ElementDefinition', 'fixedAnnotation', TFhirAnnotation(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirAttachment) {6} then
    ComposeAttachment(this, 'ElementDefinition', 'fixedAttachment', TFhirAttachment(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ElementDefinition', 'fixedCodeableConcept', TFhirCodeableConcept(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirCodeableReference) {6} then
    ComposeCodeableReference(this, 'ElementDefinition', 'fixedCodeableReference', TFhirCodeableReference(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirCoding) {6} then
    ComposeCoding(this, 'ElementDefinition', 'fixedCoding', TFhirCoding(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'ElementDefinition', 'fixedContactPoint', TFhirContactPoint(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirCount) {6} then
    ComposeCount(this, 'ElementDefinition', 'fixedCount', TFhirCount(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirDistance) {6} then
    ComposeDistance(this, 'ElementDefinition', 'fixedDistance', TFhirDistance(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirDuration) {6} then
    ComposeDuration(this, 'ElementDefinition', 'fixedDuration', TFhirDuration(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirHumanName) {6} then
    ComposeHumanName(this, 'ElementDefinition', 'fixedHumanName', TFhirHumanName(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'ElementDefinition', 'fixedIdentifier', TFhirIdentifier(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirMoney) {6} then
    ComposeMoney(this, 'ElementDefinition', 'fixedMoney', TFhirMoney(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirPeriod) {6} then
    ComposePeriod(this, 'ElementDefinition', 'fixedPeriod', TFhirPeriod(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ElementDefinition', 'fixedQuantity', TFhirQuantity(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirRange) {6} then
    ComposeRange(this, 'ElementDefinition', 'fixedRange', TFhirRange(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirRatio) {6} then
    ComposeRatio(this, 'ElementDefinition', 'fixedRatio', TFhirRatio(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirRatioRange) {6} then
    ComposeRatioRange(this, 'ElementDefinition', 'fixedRatioRange', TFhirRatioRange(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirReference) {6} then
    ComposeReference(this, 'ElementDefinition', 'fixedReference', TFhirReference(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirSampledData) {6} then
    ComposeSampledData(this, 'ElementDefinition', 'fixedSampledData', TFhirSampledData(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirSignature) {6} then
    ComposeSignature(this, 'ElementDefinition', 'fixedSignature', TFhirSignature(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirTiming) {6} then
    ComposeTiming(this, 'ElementDefinition', 'fixedTiming', TFhirTiming(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirContactDetail) {6} then
    ComposeContactDetail(this, 'ElementDefinition', 'fixedContactDetail', TFhirContactDetail(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirDataRequirement) {6} then
    ComposeDataRequirement(this, 'ElementDefinition', 'fixedDataRequirement', TFhirDataRequirement(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirExpression) {6} then
    ComposeExpression(this, 'ElementDefinition', 'fixedExpression', TFhirExpression(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(this, 'ElementDefinition', 'fixedParameterDefinition', TFhirParameterDefinition(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(this, 'ElementDefinition', 'fixedRelatedArtifact', TFhirRelatedArtifact(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(this, 'ElementDefinition', 'fixedTriggerDefinition', TFhirTriggerDefinition(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirUsageContext) {6} then
    ComposeUsageContext(this, 'ElementDefinition', 'fixedUsageContext', TFhirUsageContext(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirAvailability) {6} then
    ComposeAvailability(this, 'ElementDefinition', 'fixedAvailability', TFhirAvailability(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirExtendedContactDetail) {6} then
    ComposeExtendedContactDetail(this, 'ElementDefinition', 'fixedExtendedContactDetail', TFhirExtendedContactDetail(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirDosage) {6} then
    ComposeDosage(this, 'ElementDefinition', 'fixedDosage', TFhirDosage(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirMeta) {6} then
    ComposeMeta(this, 'ElementDefinition', 'fixedMeta', TFhirMeta(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'ElementDefinition', 'fixedBase64Binary', TFhirBase64Binary(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ElementDefinition', 'fixedBoolean', TFhirBoolean(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirDate) {6} then
    ComposeDate(this, 'ElementDefinition', 'fixedDate', TFhirDate(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ElementDefinition', 'fixedDateTime', TFhirDateTime(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ElementDefinition', 'fixedDecimal', TFhirDecimal(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirInstant) {6} then
    ComposeInstant(this, 'ElementDefinition', 'fixedInstant', TFhirInstant(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirInteger) {6} then
    ComposeInteger(this, 'ElementDefinition', 'fixedInteger', TFhirInteger(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirInteger64) {6} then
    ComposeInteger64(this, 'ElementDefinition', 'fixedInteger64', TFhirInteger64(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirString) {6} then
    ComposeString(this, 'ElementDefinition', 'fixedString', TFhirString(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirTime) {6} then
    ComposeTime(this, 'ElementDefinition', 'fixedTime', TFhirTime(value.fixed), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fixed is TFhirUri) {6} then
    ComposeUri(this, 'ElementDefinition', 'fixedUri', TFhirUri(value.fixed), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirCanonical) {6} then
    ComposeCanonical(this, 'ElementDefinition', 'patternCanonical', TFhirCanonical(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirCode) {6} then
    ComposeCode(this, 'ElementDefinition', 'patternCode', TFhirCode(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirId) {6} then
    ComposeId(this, 'ElementDefinition', 'patternId', TFhirId(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'ElementDefinition', 'patternMarkdown', TFhirMarkdown(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirOid) {6} then
    ComposeOid(this, 'ElementDefinition', 'patternOid', TFhirOid(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'ElementDefinition', 'patternPositiveInt', TFhirPositiveInt(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'patternUnsignedInt', TFhirUnsignedInt(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirUrl) {6} then
    ComposeUrl(this, 'ElementDefinition', 'patternUrl', TFhirUrl(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirUuid) {6} then
    ComposeUuid(this, 'ElementDefinition', 'patternUuid', TFhirUuid(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirAddress) {6} then
    ComposeAddress(this, 'ElementDefinition', 'patternAddress', TFhirAddress(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirAge) {6} then
    ComposeAge(this, 'ElementDefinition', 'patternAge', TFhirAge(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'ElementDefinition', 'patternAnnotation', TFhirAnnotation(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirAttachment) {6} then
    ComposeAttachment(this, 'ElementDefinition', 'patternAttachment', TFhirAttachment(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ElementDefinition', 'patternCodeableConcept', TFhirCodeableConcept(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirCodeableReference) {6} then
    ComposeCodeableReference(this, 'ElementDefinition', 'patternCodeableReference', TFhirCodeableReference(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirCoding) {6} then
    ComposeCoding(this, 'ElementDefinition', 'patternCoding', TFhirCoding(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'ElementDefinition', 'patternContactPoint', TFhirContactPoint(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirCount) {6} then
    ComposeCount(this, 'ElementDefinition', 'patternCount', TFhirCount(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirDistance) {6} then
    ComposeDistance(this, 'ElementDefinition', 'patternDistance', TFhirDistance(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirDuration) {6} then
    ComposeDuration(this, 'ElementDefinition', 'patternDuration', TFhirDuration(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirHumanName) {6} then
    ComposeHumanName(this, 'ElementDefinition', 'patternHumanName', TFhirHumanName(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'ElementDefinition', 'patternIdentifier', TFhirIdentifier(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirMoney) {6} then
    ComposeMoney(this, 'ElementDefinition', 'patternMoney', TFhirMoney(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirPeriod) {6} then
    ComposePeriod(this, 'ElementDefinition', 'patternPeriod', TFhirPeriod(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ElementDefinition', 'patternQuantity', TFhirQuantity(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirRange) {6} then
    ComposeRange(this, 'ElementDefinition', 'patternRange', TFhirRange(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirRatio) {6} then
    ComposeRatio(this, 'ElementDefinition', 'patternRatio', TFhirRatio(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirRatioRange) {6} then
    ComposeRatioRange(this, 'ElementDefinition', 'patternRatioRange', TFhirRatioRange(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirReference) {6} then
    ComposeReference(this, 'ElementDefinition', 'patternReference', TFhirReference(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirSampledData) {6} then
    ComposeSampledData(this, 'ElementDefinition', 'patternSampledData', TFhirSampledData(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirSignature) {6} then
    ComposeSignature(this, 'ElementDefinition', 'patternSignature', TFhirSignature(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirTiming) {6} then
    ComposeTiming(this, 'ElementDefinition', 'patternTiming', TFhirTiming(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirContactDetail) {6} then
    ComposeContactDetail(this, 'ElementDefinition', 'patternContactDetail', TFhirContactDetail(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirDataRequirement) {6} then
    ComposeDataRequirement(this, 'ElementDefinition', 'patternDataRequirement', TFhirDataRequirement(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirExpression) {6} then
    ComposeExpression(this, 'ElementDefinition', 'patternExpression', TFhirExpression(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(this, 'ElementDefinition', 'patternParameterDefinition', TFhirParameterDefinition(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(this, 'ElementDefinition', 'patternRelatedArtifact', TFhirRelatedArtifact(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(this, 'ElementDefinition', 'patternTriggerDefinition', TFhirTriggerDefinition(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirUsageContext) {6} then
    ComposeUsageContext(this, 'ElementDefinition', 'patternUsageContext', TFhirUsageContext(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirAvailability) {6} then
    ComposeAvailability(this, 'ElementDefinition', 'patternAvailability', TFhirAvailability(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirExtendedContactDetail) {6} then
    ComposeExtendedContactDetail(this, 'ElementDefinition', 'patternExtendedContactDetail', TFhirExtendedContactDetail(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirDosage) {6} then
    ComposeDosage(this, 'ElementDefinition', 'patternDosage', TFhirDosage(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirMeta) {6} then
    ComposeMeta(this, 'ElementDefinition', 'patternMeta', TFhirMeta(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'ElementDefinition', 'patternBase64Binary', TFhirBase64Binary(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ElementDefinition', 'patternBoolean', TFhirBoolean(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirDate) {6} then
    ComposeDate(this, 'ElementDefinition', 'patternDate', TFhirDate(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ElementDefinition', 'patternDateTime', TFhirDateTime(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ElementDefinition', 'patternDecimal', TFhirDecimal(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirInstant) {6} then
    ComposeInstant(this, 'ElementDefinition', 'patternInstant', TFhirInstant(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirInteger) {6} then
    ComposeInteger(this, 'ElementDefinition', 'patternInteger', TFhirInteger(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirInteger64) {6} then
    ComposeInteger64(this, 'ElementDefinition', 'patternInteger64', TFhirInteger64(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirString) {6} then
    ComposeString(this, 'ElementDefinition', 'patternString', TFhirString(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirTime) {6} then
    ComposeTime(this, 'ElementDefinition', 'patternTime', TFhirTime(value.pattern), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.pattern is TFhirUri) {6} then
    ComposeUri(this, 'ElementDefinition', 'patternUri', TFhirUri(value.pattern), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.exampleList.Count - 1 do
      ComposeElementDefinitionExample(this, 'ElementDefinition', 'example', value.exampleList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.minValue is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'ElementDefinition', 'minValuePositiveInt', TFhirPositiveInt(value.minValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.minValue is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'minValueUnsignedInt', TFhirUnsignedInt(value.minValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.minValue is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ElementDefinition', 'minValueQuantity', TFhirQuantity(value.minValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.minValue is TFhirDate) {6} then
    ComposeDate(this, 'ElementDefinition', 'minValueDate', TFhirDate(value.minValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.minValue is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ElementDefinition', 'minValueDateTime', TFhirDateTime(value.minValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.minValue is TFhirInstant) {6} then
    ComposeInstant(this, 'ElementDefinition', 'minValueInstant', TFhirInstant(value.minValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.minValue is TFhirTime) {6} then
    ComposeTime(this, 'ElementDefinition', 'minValueTime', TFhirTime(value.minValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.minValue is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ElementDefinition', 'minValueDecimal', TFhirDecimal(value.minValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.minValue is TFhirInteger) {6} then
    ComposeInteger(this, 'ElementDefinition', 'minValueInteger', TFhirInteger(value.minValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.minValue is TFhirInteger64) {6} then
    ComposeInteger64(this, 'ElementDefinition', 'minValueInteger64', TFhirInteger64(value.minValue), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.maxValue is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'ElementDefinition', 'maxValuePositiveInt', TFhirPositiveInt(value.maxValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.maxValue is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'maxValueUnsignedInt', TFhirUnsignedInt(value.maxValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.maxValue is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ElementDefinition', 'maxValueQuantity', TFhirQuantity(value.maxValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.maxValue is TFhirDate) {6} then
    ComposeDate(this, 'ElementDefinition', 'maxValueDate', TFhirDate(value.maxValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.maxValue is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ElementDefinition', 'maxValueDateTime', TFhirDateTime(value.maxValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.maxValue is TFhirInstant) {6} then
    ComposeInstant(this, 'ElementDefinition', 'maxValueInstant', TFhirInstant(value.maxValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.maxValue is TFhirTime) {6} then
    ComposeTime(this, 'ElementDefinition', 'maxValueTime', TFhirTime(value.maxValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.maxValue is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ElementDefinition', 'maxValueDecimal', TFhirDecimal(value.maxValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.maxValue is TFhirInteger) {6} then
    ComposeInteger(this, 'ElementDefinition', 'maxValueInteger', TFhirInteger(value.maxValue), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.maxValue is TFhirInteger64) {6} then
    ComposeInteger64(this, 'ElementDefinition', 'maxValueInteger64', TFhirInteger64(value.maxValue), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'ElementDefinition', 'maxLength', value.maxLengthElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.conditionList.Count - 1 do
      ComposeId(this, 'ElementDefinition', 'condition', value.conditionList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.constraintList.Count - 1 do
      ComposeElementDefinitionConstraint(this, 'ElementDefinition', 'constraint', value.constraintList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ElementDefinition', 'mustSupport', value.mustSupportElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ElementDefinition', 'isModifier', value.isModifierElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinition', 'isModifierReason', value.isModifierReasonElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ElementDefinition', 'isSummary', value.isSummaryElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeElementDefinitionBinding(this, 'ElementDefinition', 'binding', value.bindingElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.mappingList.Count - 1 do
      ComposeElementDefinitionMapping(this, 'ElementDefinition', 'mapping', value.mappingList[i], false, i);
end;

function TFHIRTurtleParser.ParseMarketingStatus(obj : TTurtleComplex) : TFhirMarketingStatus;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMarketingStatus.create;
  try
    ParseMarketingStatusProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMarketingStatusProperties(obj : TTurtleComplex; value : TFhirMarketingStatus);
begin
    ParseBackboneTypeProperties(obj, value);
    value.country := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MarketingStatus.country'));
    value.jurisdiction := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MarketingStatus.jurisdiction'));
    value.status := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MarketingStatus.status'));
    value.dateRange := ParsePeriod(obj.complex('http://hl7.org/fhir/MarketingStatus.dateRange'));
    value.restoreDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MarketingStatus.restoreDate'));
end;

procedure TFHIRTurtleComposer.ComposeMarketingStatus(parent :  TTurtleComplex; parentType, name : String; value : TFhirMarketingStatus; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MarketingStatus');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MarketingStatus', 'country', value.countryElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MarketingStatus', 'jurisdiction', value.jurisdictionElement, false, -1);
  ComposeCodeableConcept(this, 'MarketingStatus', 'status', value.statusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'MarketingStatus', 'dateRange', value.dateRangeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'MarketingStatus', 'restoreDate', value.restoreDateElement, false, -1);
end;

function TFHIRTurtleParser.ParsePopulation(obj : TTurtleComplex) : TFhirPopulation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPopulation.create;
  try
    ParsePopulationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePopulationProperties(obj : TTurtleComplex; value : TFhirPopulation);
var
  item : TTurtleComplex;
begin
    ParseBackboneTypeProperties(obj, value);
    if obj.has('ageRange', item) then
      value.age := parseRange(item);
    if obj.has('ageCodeableConcept', item) then
      value.age := parseCodeableConcept(item);
    value.gender := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Population.gender'));
    value.race := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Population.race'));
    value.physiologicalCondition := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Population.physiologicalCondition'));
end;

procedure TFHIRTurtleComposer.ComposePopulation(parent :  TTurtleComplex; parentType, name : String; value : TFhirPopulation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Population');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.age is TFhirRange) {6} then
    ComposeRange(this, 'Population', 'ageRange', TFhirRange(value.age), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.age is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Population', 'ageCodeableConcept', TFhirCodeableConcept(value.age), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Population', 'gender', value.genderElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Population', 'race', value.raceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Population', 'physiologicalCondition', value.physiologicalConditionElement, false, -1);
end;

function TFHIRTurtleParser.ParseProductShelfLife(obj : TTurtleComplex) : TFhirProductShelfLife;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProductShelfLife.create;
  try
    ParseProductShelfLifeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProductShelfLifeProperties(obj : TTurtleComplex; value : TFhirProductShelfLife);
var
  item : TTurtleComplex;
begin
    ParseBackboneTypeProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ProductShelfLife.type'));
    if obj.has('periodDuration', item) then
      value.period := parseDuration(item);
    if obj.has('periodString', item) then
      value.period := parseString(item);
    for item in obj.complexes('http://hl7.org/fhir/ProductShelfLife.specialPrecautionsForStorage') do
      value.specialPrecautionsForStorageList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeProductShelfLife(parent :  TTurtleComplex; parentType, name : String; value : TFhirProductShelfLife; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProductShelfLife');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ProductShelfLife', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.period is TFhirDuration) {6} then
    ComposeDuration(this, 'ProductShelfLife', 'periodDuration', TFhirDuration(value.period), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.period is TFhirString) {6} then
    ComposeString(this, 'ProductShelfLife', 'periodString', TFhirString(value.period), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.specialPrecautionsForStorageList.Count - 1 do
      ComposeCodeableConcept(this, 'ProductShelfLife', 'specialPrecautionsForStorage', value.specialPrecautionsForStorageList[i], false, i);
end;

function TFHIRTurtleParser.ParseTimingRepeat(obj : TTurtleComplex) : TFhirTimingRepeat;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTimingRepeat.create;
  try
    ParseTimingRepeatProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTimingRepeatProperties(obj : TTurtleComplex; value : TFhirTimingRepeat);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, value);
    if obj.has('boundsDuration', item) then
      value.bounds := parseDuration(item);
    if obj.has('boundsRange', item) then
      value.bounds := parseRange(item);
    if obj.has('boundsPeriod', item) then
      value.bounds := parsePeriod(item);
    value.countElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Timing.repeat.count'));
    value.countMaxElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Timing.repeat.countMax'));
    value.durationElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Timing.repeat.duration'));
    value.durationMaxElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Timing.repeat.durationMax'));
    value.durationUnitElement := ParseEnum(obj.complex('http://hl7.org/fhir/Timing.repeat.durationUnit'), CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum);
    value.frequencyElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Timing.repeat.frequency'));
    value.frequencyMaxElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Timing.repeat.frequencyMax'));
    value.periodElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Timing.repeat.period'));
    value.periodMaxElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Timing.repeat.periodMax'));
    value.periodUnitElement := ParseEnum(obj.complex('http://hl7.org/fhir/Timing.repeat.periodUnit'), CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum);
    for item in obj.complexes('http://hl7.org/fhir/Timing.repeat.dayOfWeek') do
      value.dayOfWeekList.Add(parseEnum(item, CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum));
    for item in obj.complexes('http://hl7.org/fhir/Timing.repeat.timeOfDay') do
      value.timeOfDayList.Add(parseTime(item));
    for item in obj.complexes('http://hl7.org/fhir/Timing.repeat.when') do
      value.whenList.Add(parseEnum(item, CODES_TFhirEventTimingEnum, SYSTEMS_TFhirEventTimingEnum));
    value.offsetElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Timing.repeat.offset'));
end;

procedure TFHIRTurtleComposer.ComposeTimingRepeat(parent :  TTurtleComplex; parentType, name : String; value : TFhirTimingRepeat; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TimingRepeat');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.bounds is TFhirDuration) {6} then
    ComposeDuration(this, 'Timing.repeat', 'boundsDuration', TFhirDuration(value.bounds), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.bounds is TFhirRange) {6} then
    ComposeRange(this, 'Timing.repeat', 'boundsRange', TFhirRange(value.bounds), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.bounds is TFhirPeriod) {6} then
    ComposePeriod(this, 'Timing.repeat', 'boundsPeriod', TFhirPeriod(value.bounds), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'Timing.repeat', 'count', value.countElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'Timing.repeat', 'countMax', value.countMaxElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Timing.repeat', 'duration', value.durationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Timing.repeat', 'durationMax', value.durationMaxElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Timing.repeat', 'durationUnit', value.durationUnitElement, CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'Timing.repeat', 'frequency', value.frequencyElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'Timing.repeat', 'frequencyMax', value.frequencyMaxElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Timing.repeat', 'period', value.periodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Timing.repeat', 'periodMax', value.periodMaxElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Timing.repeat', 'periodUnit', value.periodUnitElement, CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum, false, -1);
  for i := 0 to value.dayOfWeekList.Count - 1 do
      ComposeEnum(this, 'Timing.repeat', 'dayOfWeek', value.dayOfWeekList[i], CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.dayOfWeekList.Count - 1 do
      ComposeEnum(this, 'Timing.repeat', 'dayOfWeek', value.dayOfWeekList[i], CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.timeOfDayList.Count - 1 do
      ComposeTime(this, 'Timing.repeat', 'timeOfDay', value.timeOfDayList[i], false, i);
  for i := 0 to value.whenList.Count - 1 do
      ComposeEnum(this, 'Timing.repeat', 'when', value.whenList[i], CODES_TFhirEventTimingEnum, SYSTEMS_TFhirEventTimingEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.whenList.Count - 1 do
      ComposeEnum(this, 'Timing.repeat', 'when', value.whenList[i], CODES_TFhirEventTimingEnum, SYSTEMS_TFhirEventTimingEnum, false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'Timing.repeat', 'offset', value.offsetElement, false, -1);
end;

function TFHIRTurtleParser.ParseTiming(obj : TTurtleComplex) : TFhirTiming;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTiming.create;
  try
    ParseTimingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTimingProperties(obj : TTurtleComplex; value : TFhirTiming);
var
  item : TTurtleComplex;
begin
    ParseBackboneTypeProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Timing.event') do
      value.eventList.Add(parseDateTime(item));
    value.repeat_ := ParseTimingRepeat(obj.complex('http://hl7.org/fhir/Timing.repeat'));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Timing.code'));
end;

procedure TFHIRTurtleComposer.ComposeTiming(parent :  TTurtleComplex; parentType, name : String; value : TFhirTiming; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Timing');
  end;
  composeElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.eventList.Count - 1 do
      ComposeDateTime(this, 'Timing', 'event', value.eventList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTimingRepeat(this, 'Timing', 'repeat', value.repeat_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Timing', 'code', value.codeElement, false, -1);
end;



procedure TFHIRTurtleParser.ParseResourceProperties(obj : TTurtleComplex; value : TFhirResource);
begin
  ParseBaseProperties(obj, value);
  value.idElement := ParseId(obj.complex('http://hl7.org/fhir/Resource.id'));
  value.meta := ParseMeta(obj.complex('http://hl7.org/fhir/Resource.meta'));
  value.implicitRulesElement := ParseUri(obj.complex('http://hl7.org/fhir/Resource.implicitRules'));
  value.languageElement := ParseCode(obj.complex('http://hl7.org/fhir/Resource.language'));
end;

Procedure TFHIRTurtleComposer.ComposeResource(this : TTurtleComplex; parentType, name : String; value : TFhirResource; useType : boolean; index : integer);
begin
  ComposeBase(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeId(this, 'TFhirResource', 'id', value.idElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMeta(this, 'TFhirResource', 'meta', value.metaElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'TFhirResource', 'implicitRules', value.implicitRulesElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'TFhirResource', 'language', value.languageElement, false, -1);
end;

procedure TFHIRTurtleParser.ParseDomainResourceProperties(obj : TTurtleComplex; value : TFhirDomainResource);
var
  item : TTurtleComplex;
begin
  ParseResourceProperties(obj, value);
  value.text := ParseNarrative(obj.complex('http://hl7.org/fhir/DomainResource.text'));
  for item in obj.complexes('http://hl7.org/fhir/DomainResource.contained') do
    value.containedList.Add(parseInnerResource(item));
  for item in obj.complexes('http://hl7.org/fhir/DomainResource.extension') do
    value.extensionList.Add(parseExtension(item));
  for item in obj.complexes('http://hl7.org/fhir/DomainResource.modifierExtension') do
    value.modifierExtensionList.Add(parseExtension(item));
end;

Procedure TFHIRTurtleComposer.ComposeDomainResource(this : TTurtleComplex; parentType, name : String; value : TFhirDomainResource; useType : boolean; index : integer);
var
  i : integer;
begin
  ComposeResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeNarrative(this, 'TFhirDomainResource', 'text', value.textElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.containedList.Count - 1 do
      ComposeInnerResource(this, 'TFhirDomainResource', 'contained', value.containedList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.extensionList.Count - 1 do
      ComposeExtension(this, 'TFhirDomainResource', 'extension', value.extensionList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.modifierExtensionList.Count - 1 do
      ComposeExtension(this, 'TFhirDomainResource', 'modifierExtension', value.modifierExtensionList[i], false, i);
end;

procedure TFHIRTurtleParser.ParseCanonicalResourceProperties(obj : TTurtleComplex; value : TFhirCanonicalResource);
begin
  ParseDomainResourceProperties(obj, value);
end;

Procedure TFHIRTurtleComposer.ComposeCanonicalResource(this : TTurtleComplex; parentType, name : String; value : TFhirCanonicalResource; useType : boolean; index : integer);
begin
  ComposeDomainResource(this, '', name, value, false, index);
end;

procedure TFHIRTurtleParser.ParseMetadataResourceProperties(obj : TTurtleComplex; value : TFhirMetadataResource);
begin
  ParseCanonicalResourceProperties(obj, value);
end;

Procedure TFHIRTurtleComposer.ComposeMetadataResource(this : TTurtleComplex; parentType, name : String; value : TFhirMetadataResource; useType : boolean; index : integer);
begin
  ComposeCanonicalResource(this, '', name, value, false, index);
end;



{$IFDEF FHIR_ACCOUNT}
function TFHIRTurtleParser.ParseAccountCoverage(obj : TTurtleComplex) : TFhirAccountCoverage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAccountCoverage.create;
  try
    ParseAccountCoverageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAccountCoverageProperties(obj : TTurtleComplex; value : TFhirAccountCoverage);
begin
    ParseBackboneElementProperties(obj, value);
    value.coverage := ParseReference(obj.complex('http://hl7.org/fhir/Account.coverage.coverage'));
    value.priorityElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Account.coverage.priority'));
end;

procedure TFHIRTurtleComposer.ComposeAccountCoverage(parent :  TTurtleComplex; parentType, name : String; value : TFhirAccountCoverage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AccountCoverage');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeReference(this, 'Account.coverage', 'coverage', value.coverageElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'Account.coverage', 'priority', value.priorityElement, false, -1);
end;

function TFHIRTurtleParser.ParseAccountGuarantor(obj : TTurtleComplex) : TFhirAccountGuarantor;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAccountGuarantor.create;
  try
    ParseAccountGuarantorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAccountGuarantorProperties(obj : TTurtleComplex; value : TFhirAccountGuarantor);
begin
    ParseBackboneElementProperties(obj, value);
    value.party := ParseReference(obj.complex('http://hl7.org/fhir/Account.guarantor.party'));
    value.onHoldElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Account.guarantor.onHold'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Account.guarantor.period'));
end;

procedure TFHIRTurtleComposer.ComposeAccountGuarantor(parent :  TTurtleComplex; parentType, name : String; value : TFhirAccountGuarantor; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AccountGuarantor');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeReference(this, 'Account.guarantor', 'party', value.partyElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Account.guarantor', 'onHold', value.onHoldElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Account.guarantor', 'period', value.periodElement, false, -1);
end;

function TFHIRTurtleParser.ParseAccountRelatedAccount(obj : TTurtleComplex) : TFhirAccountRelatedAccount;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAccountRelatedAccount.create;
  try
    ParseAccountRelatedAccountProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAccountRelatedAccountProperties(obj : TTurtleComplex; value : TFhirAccountRelatedAccount);
begin
    ParseBackboneElementProperties(obj, value);
    value.relationship := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Account.relatedAccount.relationship'));
    value.account := ParseReference(obj.complex('http://hl7.org/fhir/Account.relatedAccount.account'));
end;

procedure TFHIRTurtleComposer.ComposeAccountRelatedAccount(parent :  TTurtleComplex; parentType, name : String; value : TFhirAccountRelatedAccount; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AccountRelatedAccount');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Account.relatedAccount', 'relationship', value.relationshipElement, false, -1);
  ComposeReference(this, 'Account.relatedAccount', 'account', value.accountElement, false, -1);
end;

function TFHIRTurtleParser.ParseAccountBalance(obj : TTurtleComplex) : TFhirAccountBalance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAccountBalance.create;
  try
    ParseAccountBalanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAccountBalanceProperties(obj : TTurtleComplex; value : TFhirAccountBalance);
begin
    ParseBackboneElementProperties(obj, value);
    value.aggregate := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Account.balance.aggregate'));
    value.term := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Account.balance.term'));
    value.estimateElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Account.balance.estimate'));
    value.amount := ParseMoney(obj.complex('http://hl7.org/fhir/Account.balance.amount'));
end;

procedure TFHIRTurtleComposer.ComposeAccountBalance(parent :  TTurtleComplex; parentType, name : String; value : TFhirAccountBalance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AccountBalance');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Account.balance', 'aggregate', value.aggregateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Account.balance', 'term', value.termElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Account.balance', 'estimate', value.estimateElement, false, -1);
  ComposeMoney(this, 'Account.balance', 'amount', value.amountElement, false, -1);
end;

function TFHIRTurtleParser.ParseAccount(obj : TTurtleComplex) : TFhirAccount;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAccount.create;
  try
    ParseAccountProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAccountProperties(obj : TTurtleComplex; value : TFhirAccount);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Account.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Account.status'), CODES_TFhirAccountStatusEnum, SYSTEMS_TFhirAccountStatusEnum);
    value.billingStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Account.billingStatus'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Account.type'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Account.name'));
    for item in obj.complexes('http://hl7.org/fhir/Account.subject') do
      value.subjectList.Add(parseReference(item));
    value.servicePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Account.servicePeriod'));
    for item in obj.complexes('http://hl7.org/fhir/Account.coverage') do
      value.coverageList.Add(parseAccountCoverage(item));
    value.owner := ParseReference(obj.complex('http://hl7.org/fhir/Account.owner'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Account.description'));
    for item in obj.complexes('http://hl7.org/fhir/Account.guarantor') do
      value.guarantorList.Add(parseAccountGuarantor(item));
    for item in obj.complexes('http://hl7.org/fhir/Account.relatedAccount') do
      value.relatedAccountList.Add(parseAccountRelatedAccount(item));
    value.currency := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Account.currency'));
    for item in obj.complexes('http://hl7.org/fhir/Account.balance') do
      value.balanceList.Add(parseAccountBalance(item));
    value.calculatedAtElement := ParseInstant(obj.complex('http://hl7.org/fhir/Account.calculatedAt'));
end;

procedure TFHIRTurtleComposer.ComposeAccount(parent :  TTurtleComplex; parentType, name : String; value : TFhirAccount; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Account');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Account', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'Account', 'status', value.statusElement, CODES_TFhirAccountStatusEnum, SYSTEMS_TFhirAccountStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Account', 'billingStatus', value.billingStatusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Account', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Account', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.subjectList.Count - 1 do
      ComposeReference(this, 'Account', 'subject', value.subjectList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Account', 'servicePeriod', value.servicePeriodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.coverageList.Count - 1 do
      ComposeAccountCoverage(this, 'Account', 'coverage', value.coverageList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Account', 'owner', value.ownerElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Account', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.guarantorList.Count - 1 do
      ComposeAccountGuarantor(this, 'Account', 'guarantor', value.guarantorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedAccountList.Count - 1 do
      ComposeAccountRelatedAccount(this, 'Account', 'relatedAccount', value.relatedAccountList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Account', 'currency', value.currencyElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.balanceList.Count - 1 do
      ComposeAccountBalance(this, 'Account', 'balance', value.balanceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeInstant(this, 'Account', 'calculatedAt', value.calculatedAtElement, false, -1);
end;

{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
function TFHIRTurtleParser.ParseActivityDefinitionParticipant(obj : TTurtleComplex) : TFhirActivityDefinitionParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirActivityDefinitionParticipant.create;
  try
    ParseActivityDefinitionParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseActivityDefinitionParticipantProperties(obj : TTurtleComplex; value : TFhirActivityDefinitionParticipant);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ActivityDefinition.participant.type'), CODES_TFhirActionParticipantTypeEnum, SYSTEMS_TFhirActionParticipantTypeEnum);
    value.typeCanonicalElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ActivityDefinition.participant.typeCanonical'));
    value.typeReference := ParseReference(obj.complex('http://hl7.org/fhir/ActivityDefinition.participant.typeReference'));
    value.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ActivityDefinition.participant.role'));
    value.function_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ActivityDefinition.participant.function'));
end;

procedure TFHIRTurtleComposer.ComposeActivityDefinitionParticipant(parent :  TTurtleComplex; parentType, name : String; value : TFhirActivityDefinitionParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ActivityDefinitionParticipant');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'ActivityDefinition.participant', 'type', value.type_Element, CODES_TFhirActionParticipantTypeEnum, SYSTEMS_TFhirActionParticipantTypeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'ActivityDefinition.participant', 'typeCanonical', value.typeCanonicalElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ActivityDefinition.participant', 'typeReference', value.typeReferenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ActivityDefinition.participant', 'role', value.roleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ActivityDefinition.participant', 'function', value.function_Element, false, -1);
end;

function TFHIRTurtleParser.ParseActivityDefinitionDynamicValue(obj : TTurtleComplex) : TFhirActivityDefinitionDynamicValue;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirActivityDefinitionDynamicValue.create;
  try
    ParseActivityDefinitionDynamicValueProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseActivityDefinitionDynamicValueProperties(obj : TTurtleComplex; value : TFhirActivityDefinitionDynamicValue);
begin
    ParseBackboneElementProperties(obj, value);
    value.pathElement := ParseString(obj.complex('http://hl7.org/fhir/ActivityDefinition.dynamicValue.path'));
    value.expression := ParseExpression(obj.complex('http://hl7.org/fhir/ActivityDefinition.dynamicValue.expression'));
end;

procedure TFHIRTurtleComposer.ComposeActivityDefinitionDynamicValue(parent :  TTurtleComplex; parentType, name : String; value : TFhirActivityDefinitionDynamicValue; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ActivityDefinitionDynamicValue');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'ActivityDefinition.dynamicValue', 'path', value.pathElement, false, -1);
  ComposeExpression(this, 'ActivityDefinition.dynamicValue', 'expression', value.expressionElement, false, -1);
end;

function TFHIRTurtleParser.ParseActivityDefinition(obj : TTurtleComplex) : TFhirActivityDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirActivityDefinition.create;
  try
    ParseActivityDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseActivityDefinitionProperties(obj : TTurtleComplex; value : TFhirActivityDefinition);
var
  item : TTurtleComplex;
begin
    ParseMetadataResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ActivityDefinition.url'));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ActivityDefinition.version'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ActivityDefinition.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ActivityDefinition.title'));
    value.subtitleElement := ParseString(obj.complex('http://hl7.org/fhir/ActivityDefinition.subtitle'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ActivityDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ActivityDefinition.experimental'));
    if obj.has('subjectCodeableConcept', item) then
      value.subject := parseCodeableConcept(item);
    if obj.has('subjectReference', item) {a3} then
      value.subject := ParseReference(item);
    if obj.has('subjectCanonical', item) then
      value.subject := parseCanonical(item);
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ActivityDefinition.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/ActivityDefinition.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ActivityDefinition.description'));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ActivityDefinition.purpose'));
    value.usageElement := ParseString(obj.complex('http://hl7.org/fhir/ActivityDefinition.usage'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ActivityDefinition.copyright'));
    value.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ActivityDefinition.approvalDate'));
    value.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ActivityDefinition.lastReviewDate'));
    value.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/ActivityDefinition.effectivePeriod'));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.topic') do
      value.topicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.author') do
      value.authorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.editor') do
      value.editorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.reviewer') do
      value.reviewerList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.endorser') do
      value.endorserList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.relatedArtifact') do
      value.relatedArtifactList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.library') do
      value.library_List.Add(parseCanonical(item));
    value.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/ActivityDefinition.kind'), CODES_TFhirRequestResourceTypesEnum, SYSTEMS_TFhirRequestResourceTypesEnum);
    value.profileElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ActivityDefinition.profile'));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ActivityDefinition.code'));
    value.intentElement := ParseEnum(obj.complex('http://hl7.org/fhir/ActivityDefinition.intent'), CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum);
    value.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/ActivityDefinition.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    value.doNotPerformElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ActivityDefinition.doNotPerform'));
    if obj.has('timingTiming', item) then
      value.timing := parseTiming(item);
    if obj.has('timingAge', item) then
      value.timing := parseAge(item);
    if obj.has('timingRange', item) then
      value.timing := parseRange(item);
    if obj.has('timingDuration', item) then
      value.timing := parseDuration(item);
    if obj.has('asNeededCodeableConcept', item) then
      value.asNeeded := parseCodeableConcept(item);
    if obj.has('asNeededBoolean', item) then
      value.asNeeded := parseBoolean(item);
    value.location := ParseCodeableReference(obj.complex('http://hl7.org/fhir/ActivityDefinition.location'));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.participant') do
      value.participantList.Add(parseActivityDefinitionParticipant(item));
    if obj.has('productReference', item) {a3} then
      value.product := ParseReference(item);
    if obj.has('productCodeableConcept', item) then
      value.product := parseCodeableConcept(item);
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ActivityDefinition.quantity'));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.dosage') do
      value.dosageList.Add(parseDosage(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.bodySite') do
      value.bodySiteList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.specimenRequirement') do
      value.specimenRequirementList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.observationRequirement') do
      value.observationRequirementList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.observationResultRequirement') do
      value.observationResultRequirementList.Add(parseCanonical(item));
    value.transformElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ActivityDefinition.transform'));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.dynamicValue') do
      value.dynamicValueList.Add(parseActivityDefinitionDynamicValue(item));
end;

procedure TFHIRTurtleComposer.ComposeActivityDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirActivityDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ActivityDefinition');
  end;
  composeMetadataResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ActivityDefinition', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ActivityDefinition', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ActivityDefinition', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ActivityDefinition', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ActivityDefinition', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ActivityDefinition', 'subtitle', value.subtitleElement, false, -1);
  ComposeEnum(this, 'ActivityDefinition', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ActivityDefinition', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.subject is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ActivityDefinition', 'subjectCodeableConcept', TFhirCodeableConcept(value.subject), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.subject is TFhirReference) {2} then
    ComposeReference(this, 'ActivityDefinition', 'subjectReference', TFhirReference(value.subject), false,-1)
  else if (SummaryOption in [soFull, soData]) and (value.subject is TFhirCanonical) {6} then
    ComposeCanonical(this, 'ActivityDefinition', 'subjectCanonical', TFhirCanonical(value.subject), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ActivityDefinition', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ActivityDefinition', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'ActivityDefinition', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'ActivityDefinition', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'ActivityDefinition', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'ActivityDefinition', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ActivityDefinition', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ActivityDefinition', 'usage', value.usageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ActivityDefinition', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'ActivityDefinition', 'approvalDate', value.approvalDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'ActivityDefinition', 'lastReviewDate', value.lastReviewDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'ActivityDefinition', 'effectivePeriod', value.effectivePeriodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.topicList.Count - 1 do
      ComposeCodeableConcept(this, 'ActivityDefinition', 'topic', value.topicList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(this, 'ActivityDefinition', 'author', value.authorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(this, 'ActivityDefinition', 'editor', value.editorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(this, 'ActivityDefinition', 'reviewer', value.reviewerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(this, 'ActivityDefinition', 'endorser', value.endorserList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'ActivityDefinition', 'relatedArtifact', value.relatedArtifactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.library_List.Count - 1 do
      ComposeCanonical(this, 'ActivityDefinition', 'library', value.library_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'ActivityDefinition', 'kind', value.kindElement, CODES_TFhirRequestResourceTypesEnum, SYSTEMS_TFhirRequestResourceTypesEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'ActivityDefinition', 'profile', value.profileElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ActivityDefinition', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'ActivityDefinition', 'intent', value.intentElement, CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'ActivityDefinition', 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ActivityDefinition', 'doNotPerform', value.doNotPerformElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.timing is TFhirTiming) {6} then
    ComposeTiming(this, 'ActivityDefinition', 'timingTiming', TFhirTiming(value.timing), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirAge) {6} then
    ComposeAge(this, 'ActivityDefinition', 'timingAge', TFhirAge(value.timing), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirRange) {6} then
    ComposeRange(this, 'ActivityDefinition', 'timingRange', TFhirRange(value.timing), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirDuration) {6} then
    ComposeDuration(this, 'ActivityDefinition', 'timingDuration', TFhirDuration(value.timing), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ActivityDefinition', 'asNeededCodeableConcept', TFhirCodeableConcept(value.asNeeded), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ActivityDefinition', 'asNeededBoolean', TFhirBoolean(value.asNeeded), false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(this, 'ActivityDefinition', 'location', value.locationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.participantList.Count - 1 do
      ComposeActivityDefinitionParticipant(this, 'ActivityDefinition', 'participant', value.participantList[i], false, i);
  if (SummaryOption in [soFull, soData]) and (value.product is TFhirReference) {2} then
    ComposeReference(this, 'ActivityDefinition', 'productReference', TFhirReference(value.product), false,-1)
  else if (SummaryOption in [soFull, soData]) and (value.product is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ActivityDefinition', 'productCodeableConcept', TFhirCodeableConcept(value.product), false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ActivityDefinition', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dosageList.Count - 1 do
      ComposeDosage(this, 'ActivityDefinition', 'dosage', value.dosageList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.bodySiteList.Count - 1 do
      ComposeCodeableConcept(this, 'ActivityDefinition', 'bodySite', value.bodySiteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.specimenRequirementList.Count - 1 do
      ComposeCanonical(this, 'ActivityDefinition', 'specimenRequirement', value.specimenRequirementList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.observationRequirementList.Count - 1 do
      ComposeCanonical(this, 'ActivityDefinition', 'observationRequirement', value.observationRequirementList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.observationResultRequirementList.Count - 1 do
      ComposeCanonical(this, 'ActivityDefinition', 'observationResultRequirement', value.observationResultRequirementList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'ActivityDefinition', 'transform', value.transformElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dynamicValueList.Count - 1 do
      ComposeActivityDefinitionDynamicValue(this, 'ActivityDefinition', 'dynamicValue', value.dynamicValueList[i], false, i);
end;

{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ACTORDEFINITION}
function TFHIRTurtleParser.ParseActorDefinition(obj : TTurtleComplex) : TFhirActorDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirActorDefinition.create;
  try
    ParseActorDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseActorDefinitionProperties(obj : TTurtleComplex; value : TFhirActorDefinition);
var
  item : TTurtleComplex;
begin
    ParseCanonicalResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ActorDefinition.url'));
    for item in obj.complexes('http://hl7.org/fhir/ActorDefinition.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ActorDefinition.version'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ActorDefinition.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ActorDefinition.title'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ActorDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ActorDefinition.experimental'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ActorDefinition.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/ActorDefinition.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/ActorDefinition.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ActorDefinition.description'));
    for item in obj.complexes('http://hl7.org/fhir/ActorDefinition.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/ActorDefinition.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ActorDefinition.purpose'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ActorDefinition.copyright'));
    value.copyrightLabelElement := ParseString(obj.complex('http://hl7.org/fhir/ActorDefinition.copyrightLabel'));
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ActorDefinition.type'), CODES_TFhirExampleScenarioActorTypeEnum, SYSTEMS_TFhirExampleScenarioActorTypeEnum);
    value.documentationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ActorDefinition.documentation'));
    for item in obj.complexes('http://hl7.org/fhir/ActorDefinition.reference') do
      value.referenceList.Add(parseUrl(item));
    value.capabilitiesElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ActorDefinition.capabilities'));
    for item in obj.complexes('http://hl7.org/fhir/ActorDefinition.derivedFrom') do
      value.derivedFromList.Add(parseCanonical(item));
end;

procedure TFHIRTurtleComposer.ComposeActorDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirActorDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ActorDefinition');
  end;
  composeCanonicalResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ActorDefinition', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ActorDefinition', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ActorDefinition', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ActorDefinition', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ActorDefinition', 'title', value.titleElement, false, -1);
  ComposeEnum(this, 'ActorDefinition', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ActorDefinition', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ActorDefinition', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ActorDefinition', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'ActorDefinition', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ActorDefinition', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'ActorDefinition', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'ActorDefinition', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ActorDefinition', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ActorDefinition', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ActorDefinition', 'copyrightLabel', value.copyrightLabelElement, false, -1);
  ComposeEnum(this, 'ActorDefinition', 'type', value.type_Element, CODES_TFhirExampleScenarioActorTypeEnum, SYSTEMS_TFhirExampleScenarioActorTypeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ActorDefinition', 'documentation', value.documentationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.referenceList.Count - 1 do
      ComposeUrl(this, 'ActorDefinition', 'reference', value.referenceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'ActorDefinition', 'capabilities', value.capabilitiesElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.derivedFromList.Count - 1 do
      ComposeCanonical(this, 'ActorDefinition', 'derivedFrom', value.derivedFromList[i], false, i);
end;

{$ENDIF FHIR_ACTORDEFINITION}
{$IFDEF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
function TFHIRTurtleParser.ParseAdministrableProductDefinitionProperty(obj : TTurtleComplex) : TFhirAdministrableProductDefinitionProperty;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAdministrableProductDefinitionProperty.create;
  try
    ParseAdministrableProductDefinitionPropertyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAdministrableProductDefinitionPropertyProperties(obj : TTurtleComplex; value : TFhirAdministrableProductDefinitionProperty);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AdministrableProductDefinition.property.type'));
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueAttachment', item) then
      value.value := parseAttachment(item);
    if obj.has('valueDate', item) then
      value.value := parseDate(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    value.status := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AdministrableProductDefinition.property.status'));
end;

procedure TFHIRTurtleComposer.ComposeAdministrableProductDefinitionProperty(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdministrableProductDefinitionProperty; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AdministrableProductDefinitionProperty');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'AdministrableProductDefinition.property', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'AdministrableProductDefinition.property', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'AdministrableProductDefinition.property', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'AdministrableProductDefinition.property', 'valueAttachment', TFhirAttachment(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirDate) {6} then
    ComposeDate(this, 'AdministrableProductDefinition.property', 'valueDate', TFhirDate(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'AdministrableProductDefinition.property', 'valueBoolean', TFhirBoolean(value.value), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'AdministrableProductDefinition.property', 'status', value.statusElement, false, -1);
end;

function TFHIRTurtleParser.ParseAdministrableProductDefinitionRouteOfAdministration(obj : TTurtleComplex) : TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAdministrableProductDefinitionRouteOfAdministration.create;
  try
    ParseAdministrableProductDefinitionRouteOfAdministrationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAdministrableProductDefinitionRouteOfAdministrationProperties(obj : TTurtleComplex; value : TFhirAdministrableProductDefinitionRouteOfAdministration);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AdministrableProductDefinition.routeOfAdministration.code'));
    value.firstDose := ParseQuantity(obj.complex('http://hl7.org/fhir/AdministrableProductDefinition.routeOfAdministration.firstDose'));
    value.maxSingleDose := ParseQuantity(obj.complex('http://hl7.org/fhir/AdministrableProductDefinition.routeOfAdministration.maxSingleDose'));
    value.maxDosePerDay := ParseQuantity(obj.complex('http://hl7.org/fhir/AdministrableProductDefinition.routeOfAdministration.maxDosePerDay'));
    value.maxDosePerTreatmentPeriod := ParseRatio(obj.complex('http://hl7.org/fhir/AdministrableProductDefinition.routeOfAdministration.maxDosePerTreatmentPeriod'));
    value.maxTreatmentPeriod := ParseDuration(obj.complex('http://hl7.org/fhir/AdministrableProductDefinition.routeOfAdministration.maxTreatmentPeriod'));
    for item in obj.complexes('http://hl7.org/fhir/AdministrableProductDefinition.routeOfAdministration.targetSpecies') do
      value.targetSpeciesList.Add(parseAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(item));
end;

procedure TFHIRTurtleComposer.ComposeAdministrableProductDefinitionRouteOfAdministration(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdministrableProductDefinitionRouteOfAdministration; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AdministrableProductDefinitionRouteOfAdministration');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'AdministrableProductDefinition.routeOfAdministration', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'AdministrableProductDefinition.routeOfAdministration', 'firstDose', value.firstDoseElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'AdministrableProductDefinition.routeOfAdministration', 'maxSingleDose', value.maxSingleDoseElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'AdministrableProductDefinition.routeOfAdministration', 'maxDosePerDay', value.maxDosePerDayElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(this, 'AdministrableProductDefinition.routeOfAdministration', 'maxDosePerTreatmentPeriod', value.maxDosePerTreatmentPeriodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDuration(this, 'AdministrableProductDefinition.routeOfAdministration', 'maxTreatmentPeriod', value.maxTreatmentPeriodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.targetSpeciesList.Count - 1 do
      ComposeAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(this, 'AdministrableProductDefinition.routeOfAdministration', 'targetSpecies', value.targetSpeciesList[i], false, i);
end;

function TFHIRTurtleParser.ParseAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(obj : TTurtleComplex) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.create;
  try
    ParseAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesProperties(obj : TTurtleComplex; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AdministrableProductDefinition.routeOfAdministration.targetSpecies.code'));
    for item in obj.complexes('http://hl7.org/fhir/AdministrableProductDefinition.routeOfAdministration.targetSpecies.withdrawalPeriod') do
      value.withdrawalPeriodList.Add(parseAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(item));
end;

procedure TFHIRTurtleComposer.ComposeAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AdministrableProductDefinitionRouteOfAdministrationTargetSpecies');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'AdministrableProductDefinition.routeOfAdministration.targetSpecies', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.withdrawalPeriodList.Count - 1 do
      ComposeAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(this, 'AdministrableProductDefinition.routeOfAdministration.targetSpecies', 'withdrawalPeriod', value.withdrawalPeriodList[i], false, i);
end;

function TFHIRTurtleParser.ParseAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(obj : TTurtleComplex) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.create;
  try
    ParseAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodProperties(obj : TTurtleComplex; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
begin
    ParseBackboneElementProperties(obj, value);
    value.tissue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AdministrableProductDefinition.routeOfAdministration.targetSpecies.withdrawalPeriod.tissue'));
    value.value := ParseQuantity(obj.complex('http://hl7.org/fhir/AdministrableProductDefinition.routeOfAdministration.targetSpecies.withdrawalPeriod.value'));
    value.supportingInformationElement := ParseString(obj.complex('http://hl7.org/fhir/AdministrableProductDefinition.routeOfAdministration.targetSpecies.withdrawalPeriod.supportingInformation'));
end;

procedure TFHIRTurtleComposer.ComposeAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'AdministrableProductDefinition.routeOfAdministration.targetSpecies.withdrawalPeriod', 'tissue', value.tissueElement, false, -1);
  ComposeQuantity(this, 'AdministrableProductDefinition.routeOfAdministration.targetSpecies.withdrawalPeriod', 'value', value.valueElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'AdministrableProductDefinition.routeOfAdministration.targetSpecies.withdrawalPeriod', 'supportingInformation', value.supportingInformationElement, false, -1);
end;

function TFHIRTurtleParser.ParseAdministrableProductDefinition(obj : TTurtleComplex) : TFhirAdministrableProductDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAdministrableProductDefinition.create;
  try
    ParseAdministrableProductDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAdministrableProductDefinitionProperties(obj : TTurtleComplex; value : TFhirAdministrableProductDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/AdministrableProductDefinition.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/AdministrableProductDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/AdministrableProductDefinition.formOf') do
      value.formOfList.Add(parseReference(item));
    value.administrableDoseForm := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AdministrableProductDefinition.administrableDoseForm'));
    value.unitOfPresentation := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AdministrableProductDefinition.unitOfPresentation'));
    for item in obj.complexes('http://hl7.org/fhir/AdministrableProductDefinition.producedFrom') do
      value.producedFromList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/AdministrableProductDefinition.ingredient') do
      value.ingredientList.Add(parseCodeableConcept(item));
    value.device := ParseReference(obj.complex('http://hl7.org/fhir/AdministrableProductDefinition.device'));
    for item in obj.complexes('http://hl7.org/fhir/AdministrableProductDefinition.property') do
      value.property_List.Add(parseAdministrableProductDefinitionProperty(item));
    for item in obj.complexes('http://hl7.org/fhir/AdministrableProductDefinition.routeOfAdministration') do
      value.routeOfAdministrationList.Add(parseAdministrableProductDefinitionRouteOfAdministration(item));
end;

procedure TFHIRTurtleComposer.ComposeAdministrableProductDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdministrableProductDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AdministrableProductDefinition');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'AdministrableProductDefinition', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'AdministrableProductDefinition', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.formOfList.Count - 1 do
      ComposeReference(this, 'AdministrableProductDefinition', 'formOf', value.formOfList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'AdministrableProductDefinition', 'administrableDoseForm', value.administrableDoseFormElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'AdministrableProductDefinition', 'unitOfPresentation', value.unitOfPresentationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.producedFromList.Count - 1 do
      ComposeReference(this, 'AdministrableProductDefinition', 'producedFrom', value.producedFromList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.ingredientList.Count - 1 do
      ComposeCodeableConcept(this, 'AdministrableProductDefinition', 'ingredient', value.ingredientList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'AdministrableProductDefinition', 'device', value.deviceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeAdministrableProductDefinitionProperty(this, 'AdministrableProductDefinition', 'property', value.property_List[i], false, i);
  for i := 0 to value.routeOfAdministrationList.Count - 1 do
      ComposeAdministrableProductDefinitionRouteOfAdministration(this, 'AdministrableProductDefinition', 'routeOfAdministration', value.routeOfAdministrationList[i], false, i);
end;

{$ENDIF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
function TFHIRTurtleParser.ParseAdverseEventParticipant(obj : TTurtleComplex) : TFhirAdverseEventParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAdverseEventParticipant.create;
  try
    ParseAdverseEventParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAdverseEventParticipantProperties(obj : TTurtleComplex; value : TFhirAdverseEventParticipant);
begin
    ParseBackboneElementProperties(obj, value);
    value.function_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AdverseEvent.participant.function'));
    value.actor := ParseReference(obj.complex('http://hl7.org/fhir/AdverseEvent.participant.actor'));
end;

procedure TFHIRTurtleComposer.ComposeAdverseEventParticipant(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdverseEventParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AdverseEventParticipant');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'AdverseEvent.participant', 'function', value.function_Element, false, -1);
  ComposeReference(this, 'AdverseEvent.participant', 'actor', value.actorElement, false, -1);
end;

function TFHIRTurtleParser.ParseAdverseEventSuspectEntity(obj : TTurtleComplex) : TFhirAdverseEventSuspectEntity;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAdverseEventSuspectEntity.create;
  try
    ParseAdverseEventSuspectEntityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAdverseEventSuspectEntityProperties(obj : TTurtleComplex; value : TFhirAdverseEventSuspectEntity);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('instanceCodeableConcept', item) then
      value.instance := parseCodeableConcept(item);
    if obj.has('instanceReference', item) {a3} then
      value.instance := ParseReference(item);
    value.causality := ParseAdverseEventSuspectEntityCausality(obj.complex('http://hl7.org/fhir/AdverseEvent.suspectEntity.causality'));
end;

procedure TFHIRTurtleComposer.ComposeAdverseEventSuspectEntity(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdverseEventSuspectEntity; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AdverseEventSuspectEntity');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (value.instance is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'AdverseEvent.suspectEntity', 'instanceCodeableConcept', TFhirCodeableConcept(value.instance), false, -1)
  else if (value.instance is TFhirReference) {2} then
    ComposeReference(this, 'AdverseEvent.suspectEntity', 'instanceReference', TFhirReference(value.instance), false,-1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAdverseEventSuspectEntityCausality(this, 'AdverseEvent.suspectEntity', 'causality', value.causalityElement, false, -1);
end;

function TFHIRTurtleParser.ParseAdverseEventSuspectEntityCausality(obj : TTurtleComplex) : TFhirAdverseEventSuspectEntityCausality;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAdverseEventSuspectEntityCausality.create;
  try
    ParseAdverseEventSuspectEntityCausalityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAdverseEventSuspectEntityCausalityProperties(obj : TTurtleComplex; value : TFhirAdverseEventSuspectEntityCausality);
begin
    ParseBackboneElementProperties(obj, value);
    value.assessmentMethod := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AdverseEvent.suspectEntity.causality.assessmentMethod'));
    value.entityRelatedness := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AdverseEvent.suspectEntity.causality.entityRelatedness'));
    value.author := ParseReference(obj.complex('http://hl7.org/fhir/AdverseEvent.suspectEntity.causality.author'));
end;

procedure TFHIRTurtleComposer.ComposeAdverseEventSuspectEntityCausality(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdverseEventSuspectEntityCausality; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AdverseEventSuspectEntityCausality');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'AdverseEvent.suspectEntity.causality', 'assessmentMethod', value.assessmentMethodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'AdverseEvent.suspectEntity.causality', 'entityRelatedness', value.entityRelatednessElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'AdverseEvent.suspectEntity.causality', 'author', value.authorElement, false, -1);
end;

function TFHIRTurtleParser.ParseAdverseEventContributingFactor(obj : TTurtleComplex) : TFhirAdverseEventContributingFactor;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAdverseEventContributingFactor.create;
  try
    ParseAdverseEventContributingFactorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAdverseEventContributingFactorProperties(obj : TTurtleComplex; value : TFhirAdverseEventContributingFactor);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('itemReference', item) {a3} then
      value.item := ParseReference(item);
    if obj.has('itemCodeableConcept', item) then
      value.item := parseCodeableConcept(item);
end;

procedure TFHIRTurtleComposer.ComposeAdverseEventContributingFactor(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdverseEventContributingFactor; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AdverseEventContributingFactor');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (value.item is TFhirReference) {2} then
    ComposeReference(this, 'AdverseEvent.contributingFactor', 'itemReference', TFhirReference(value.item), false,-1)
  else if (value.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'AdverseEvent.contributingFactor', 'itemCodeableConcept', TFhirCodeableConcept(value.item), false, -1);
end;

function TFHIRTurtleParser.ParseAdverseEventPreventiveAction(obj : TTurtleComplex) : TFhirAdverseEventPreventiveAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAdverseEventPreventiveAction.create;
  try
    ParseAdverseEventPreventiveActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAdverseEventPreventiveActionProperties(obj : TTurtleComplex; value : TFhirAdverseEventPreventiveAction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('itemReference', item) {a3} then
      value.item := ParseReference(item);
    if obj.has('itemCodeableConcept', item) then
      value.item := parseCodeableConcept(item);
end;

procedure TFHIRTurtleComposer.ComposeAdverseEventPreventiveAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdverseEventPreventiveAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AdverseEventPreventiveAction');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (value.item is TFhirReference) {2} then
    ComposeReference(this, 'AdverseEvent.preventiveAction', 'itemReference', TFhirReference(value.item), false,-1)
  else if (value.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'AdverseEvent.preventiveAction', 'itemCodeableConcept', TFhirCodeableConcept(value.item), false, -1);
end;

function TFHIRTurtleParser.ParseAdverseEventMitigatingAction(obj : TTurtleComplex) : TFhirAdverseEventMitigatingAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAdverseEventMitigatingAction.create;
  try
    ParseAdverseEventMitigatingActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAdverseEventMitigatingActionProperties(obj : TTurtleComplex; value : TFhirAdverseEventMitigatingAction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('itemReference', item) {a3} then
      value.item := ParseReference(item);
    if obj.has('itemCodeableConcept', item) then
      value.item := parseCodeableConcept(item);
end;

procedure TFHIRTurtleComposer.ComposeAdverseEventMitigatingAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdverseEventMitigatingAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AdverseEventMitigatingAction');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (value.item is TFhirReference) {2} then
    ComposeReference(this, 'AdverseEvent.mitigatingAction', 'itemReference', TFhirReference(value.item), false,-1)
  else if (value.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'AdverseEvent.mitigatingAction', 'itemCodeableConcept', TFhirCodeableConcept(value.item), false, -1);
end;

function TFHIRTurtleParser.ParseAdverseEventSupportingInfo(obj : TTurtleComplex) : TFhirAdverseEventSupportingInfo;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAdverseEventSupportingInfo.create;
  try
    ParseAdverseEventSupportingInfoProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAdverseEventSupportingInfoProperties(obj : TTurtleComplex; value : TFhirAdverseEventSupportingInfo);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('itemReference', item) {a3} then
      value.item := ParseReference(item);
    if obj.has('itemCodeableConcept', item) then
      value.item := parseCodeableConcept(item);
end;

procedure TFHIRTurtleComposer.ComposeAdverseEventSupportingInfo(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdverseEventSupportingInfo; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AdverseEventSupportingInfo');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (value.item is TFhirReference) {2} then
    ComposeReference(this, 'AdverseEvent.supportingInfo', 'itemReference', TFhirReference(value.item), false,-1)
  else if (value.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'AdverseEvent.supportingInfo', 'itemCodeableConcept', TFhirCodeableConcept(value.item), false, -1);
end;

function TFHIRTurtleParser.ParseAdverseEvent(obj : TTurtleComplex) : TFhirAdverseEvent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAdverseEvent.create;
  try
    ParseAdverseEventProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAdverseEventProperties(obj : TTurtleComplex; value : TFhirAdverseEvent);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/AdverseEvent.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/AdverseEvent.status'), CODES_TFhirAdverseEventStatusEnum, SYSTEMS_TFhirAdverseEventStatusEnum);
    value.actualityElement := ParseEnum(obj.complex('http://hl7.org/fhir/AdverseEvent.actuality'), CODES_TFhirAdverseEventActualityEnum, SYSTEMS_TFhirAdverseEventActualityEnum);
    for item in obj.complexes('http://hl7.org/fhir/AdverseEvent.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AdverseEvent.code'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/AdverseEvent.subject'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/AdverseEvent.encounter'));
    if obj.has('occurrencePeriod', item) then
      value.occurrence := parsePeriod(item);
    if obj.has('occurrenceTiming', item) then
      value.occurrence := parseTiming(item);
    if obj.has('occurrenceDateTime', item) then
      value.occurrence := parseDateTime(item);
    value.detectedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/AdverseEvent.detected'));
    value.recordedDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/AdverseEvent.recordedDate'));
    for item in obj.complexes('http://hl7.org/fhir/AdverseEvent.resultingCondition') do
      value.resultingConditionList.Add(parseReference(item));
    value.location := ParseReference(obj.complex('http://hl7.org/fhir/AdverseEvent.location'));
    value.seriousness := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AdverseEvent.seriousness'));
    for item in obj.complexes('http://hl7.org/fhir/AdverseEvent.outcome') do
      value.outcomeList.Add(parseCodeableConcept(item));
    value.recorder := ParseReference(obj.complex('http://hl7.org/fhir/AdverseEvent.recorder'));
    for item in obj.complexes('http://hl7.org/fhir/AdverseEvent.participant') do
      value.participantList.Add(parseAdverseEventParticipant(item));
    for item in obj.complexes('http://hl7.org/fhir/AdverseEvent.study') do
      value.studyList.Add(parseReference(item));
    value.expectedInResearchStudyElement := ParseBoolean(obj.complex('http://hl7.org/fhir/AdverseEvent.expectedInResearchStudy'));
    for item in obj.complexes('http://hl7.org/fhir/AdverseEvent.suspectEntity') do
      value.suspectEntityList.Add(parseAdverseEventSuspectEntity(item));
    for item in obj.complexes('http://hl7.org/fhir/AdverseEvent.contributingFactor') do
      value.contributingFactorList.Add(parseAdverseEventContributingFactor(item));
    for item in obj.complexes('http://hl7.org/fhir/AdverseEvent.preventiveAction') do
      value.preventiveActionList.Add(parseAdverseEventPreventiveAction(item));
    for item in obj.complexes('http://hl7.org/fhir/AdverseEvent.mitigatingAction') do
      value.mitigatingActionList.Add(parseAdverseEventMitigatingAction(item));
    for item in obj.complexes('http://hl7.org/fhir/AdverseEvent.supportingInfo') do
      value.supportingInfoList.Add(parseAdverseEventSupportingInfo(item));
    for item in obj.complexes('http://hl7.org/fhir/AdverseEvent.note') do
      value.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeAdverseEvent(parent :  TTurtleComplex; parentType, name : String; value : TFhirAdverseEvent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AdverseEvent');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'AdverseEvent', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'AdverseEvent', 'status', value.statusElement, CODES_TFhirAdverseEventStatusEnum, SYSTEMS_TFhirAdverseEventStatusEnum, false, -1);
  ComposeEnum(this, 'AdverseEvent', 'actuality', value.actualityElement, CODES_TFhirAdverseEventActualityEnum, SYSTEMS_TFhirAdverseEventActualityEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'AdverseEvent', 'category', value.categoryList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'AdverseEvent', 'code', value.codeElement, false, -1);
  ComposeReference(this, 'AdverseEvent', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'AdverseEvent', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'AdverseEvent', 'occurrencePeriod', TFhirPeriod(value.occurrence), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirTiming) {6} then
    ComposeTiming(this, 'AdverseEvent', 'occurrenceTiming', TFhirTiming(value.occurrence), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'AdverseEvent', 'occurrenceDateTime', TFhirDateTime(value.occurrence), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'AdverseEvent', 'detected', value.detectedElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'AdverseEvent', 'recordedDate', value.recordedDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.resultingConditionList.Count - 1 do
      ComposeReference(this, 'AdverseEvent', 'resultingCondition', value.resultingConditionList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'AdverseEvent', 'location', value.locationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'AdverseEvent', 'seriousness', value.seriousnessElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.outcomeList.Count - 1 do
      ComposeCodeableConcept(this, 'AdverseEvent', 'outcome', value.outcomeList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'AdverseEvent', 'recorder', value.recorderElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.participantList.Count - 1 do
      ComposeAdverseEventParticipant(this, 'AdverseEvent', 'participant', value.participantList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.studyList.Count - 1 do
      ComposeReference(this, 'AdverseEvent', 'study', value.studyList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'AdverseEvent', 'expectedInResearchStudy', value.expectedInResearchStudyElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.suspectEntityList.Count - 1 do
      ComposeAdverseEventSuspectEntity(this, 'AdverseEvent', 'suspectEntity', value.suspectEntityList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contributingFactorList.Count - 1 do
      ComposeAdverseEventContributingFactor(this, 'AdverseEvent', 'contributingFactor', value.contributingFactorList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.preventiveActionList.Count - 1 do
      ComposeAdverseEventPreventiveAction(this, 'AdverseEvent', 'preventiveAction', value.preventiveActionList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.mitigatingActionList.Count - 1 do
      ComposeAdverseEventMitigatingAction(this, 'AdverseEvent', 'mitigatingAction', value.mitigatingActionList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.supportingInfoList.Count - 1 do
      ComposeAdverseEventSupportingInfo(this, 'AdverseEvent', 'supportingInfo', value.supportingInfoList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'AdverseEvent', 'note', value.noteList[i], false, i);
end;

{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
function TFHIRTurtleParser.ParseAllergyIntoleranceParticipant(obj : TTurtleComplex) : TFhirAllergyIntoleranceParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAllergyIntoleranceParticipant.create;
  try
    ParseAllergyIntoleranceParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAllergyIntoleranceParticipantProperties(obj : TTurtleComplex; value : TFhirAllergyIntoleranceParticipant);
begin
    ParseBackboneElementProperties(obj, value);
    value.function_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AllergyIntolerance.participant.function'));
    value.actor := ParseReference(obj.complex('http://hl7.org/fhir/AllergyIntolerance.participant.actor'));
end;

procedure TFHIRTurtleComposer.ComposeAllergyIntoleranceParticipant(parent :  TTurtleComplex; parentType, name : String; value : TFhirAllergyIntoleranceParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AllergyIntoleranceParticipant');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'AllergyIntolerance.participant', 'function', value.function_Element, false, -1);
  ComposeReference(this, 'AllergyIntolerance.participant', 'actor', value.actorElement, false, -1);
end;

function TFHIRTurtleParser.ParseAllergyIntoleranceReaction(obj : TTurtleComplex) : TFhirAllergyIntoleranceReaction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAllergyIntoleranceReaction.create;
  try
    ParseAllergyIntoleranceReactionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAllergyIntoleranceReactionProperties(obj : TTurtleComplex; value : TFhirAllergyIntoleranceReaction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.substance := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AllergyIntolerance.reaction.substance'));
    for item in obj.complexes('http://hl7.org/fhir/AllergyIntolerance.reaction.manifestation') do
      value.manifestationList.Add(parseCodeableReference(item));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/AllergyIntolerance.reaction.description'));
    value.onsetElement := ParseDateTime(obj.complex('http://hl7.org/fhir/AllergyIntolerance.reaction.onset'));
    value.severityElement := ParseEnum(obj.complex('http://hl7.org/fhir/AllergyIntolerance.reaction.severity'), CODES_TFhirAllergyIntoleranceSeverityEnum, SYSTEMS_TFhirAllergyIntoleranceSeverityEnum);
    value.exposureRoute := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AllergyIntolerance.reaction.exposureRoute'));
    for item in obj.complexes('http://hl7.org/fhir/AllergyIntolerance.reaction.note') do
      value.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeAllergyIntoleranceReaction(parent :  TTurtleComplex; parentType, name : String; value : TFhirAllergyIntoleranceReaction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AllergyIntoleranceReaction');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'AllergyIntolerance.reaction', 'substance', value.substanceElement, false, -1);
  for i := 0 to value.manifestationList.Count - 1 do
      ComposeCodeableReference(this, 'AllergyIntolerance.reaction', 'manifestation', value.manifestationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AllergyIntolerance.reaction', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'AllergyIntolerance.reaction', 'onset', value.onsetElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'AllergyIntolerance.reaction', 'severity', value.severityElement, CODES_TFhirAllergyIntoleranceSeverityEnum, SYSTEMS_TFhirAllergyIntoleranceSeverityEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'AllergyIntolerance.reaction', 'exposureRoute', value.exposureRouteElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'AllergyIntolerance.reaction', 'note', value.noteList[i], false, i);
end;

function TFHIRTurtleParser.ParseAllergyIntolerance(obj : TTurtleComplex) : TFhirAllergyIntolerance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAllergyIntolerance.create;
  try
    ParseAllergyIntoleranceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAllergyIntoleranceProperties(obj : TTurtleComplex; value : TFhirAllergyIntolerance);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/AllergyIntolerance.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.clinicalStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AllergyIntolerance.clinicalStatus'));
    value.verificationStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AllergyIntolerance.verificationStatus'));
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/AllergyIntolerance.type'), CODES_TFhirAllergyIntoleranceTypeEnum, SYSTEMS_TFhirAllergyIntoleranceTypeEnum);
    for item in obj.complexes('http://hl7.org/fhir/AllergyIntolerance.category') do
      value.categoryList.Add(parseEnum(item, CODES_TFhirAllergyIntoleranceCategoryEnum, SYSTEMS_TFhirAllergyIntoleranceCategoryEnum));
    value.criticalityElement := ParseEnum(obj.complex('http://hl7.org/fhir/AllergyIntolerance.criticality'), CODES_TFhirAllergyIntoleranceCriticalityEnum, SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AllergyIntolerance.code'));
    value.patient := ParseReference(obj.complex('http://hl7.org/fhir/AllergyIntolerance.patient'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/AllergyIntolerance.encounter'));
    if obj.has('onsetAge', item) then
      value.onset := parseAge(item);
    if obj.has('onsetPeriod', item) then
      value.onset := parsePeriod(item);
    if obj.has('onsetRange', item) then
      value.onset := parseRange(item);
    if obj.has('onsetDateTime', item) then
      value.onset := parseDateTime(item);
    if obj.has('onsetString', item) then
      value.onset := parseString(item);
    value.recordedDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/AllergyIntolerance.recordedDate'));
    for item in obj.complexes('http://hl7.org/fhir/AllergyIntolerance.participant') do
      value.participantList.Add(parseAllergyIntoleranceParticipant(item));
    value.lastOccurrenceElement := ParseDateTime(obj.complex('http://hl7.org/fhir/AllergyIntolerance.lastOccurrence'));
    for item in obj.complexes('http://hl7.org/fhir/AllergyIntolerance.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/AllergyIntolerance.reaction') do
      value.reactionList.Add(parseAllergyIntoleranceReaction(item));
end;

procedure TFHIRTurtleComposer.ComposeAllergyIntolerance(parent :  TTurtleComplex; parentType, name : String; value : TFhirAllergyIntolerance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AllergyIntolerance');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'AllergyIntolerance', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'AllergyIntolerance', 'clinicalStatus', value.clinicalStatusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'AllergyIntolerance', 'verificationStatus', value.verificationStatusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'AllergyIntolerance', 'type', value.type_Element, CODES_TFhirAllergyIntoleranceTypeEnum, SYSTEMS_TFhirAllergyIntoleranceTypeEnum, false, -1);
  for i := 0 to value.categoryList.Count - 1 do
      ComposeEnum(this, 'AllergyIntolerance', 'category', value.categoryList[i], CODES_TFhirAllergyIntoleranceCategoryEnum, SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeEnum(this, 'AllergyIntolerance', 'category', value.categoryList[i], CODES_TFhirAllergyIntoleranceCategoryEnum, SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'AllergyIntolerance', 'criticality', value.criticalityElement, CODES_TFhirAllergyIntoleranceCriticalityEnum, SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'AllergyIntolerance', 'code', value.codeElement, false, -1);
  ComposeReference(this, 'AllergyIntolerance', 'patient', value.patientElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'AllergyIntolerance', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.onset is TFhirAge) {6} then
    ComposeAge(this, 'AllergyIntolerance', 'onsetAge', TFhirAge(value.onset), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.onset is TFhirPeriod) {6} then
    ComposePeriod(this, 'AllergyIntolerance', 'onsetPeriod', TFhirPeriod(value.onset), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.onset is TFhirRange) {6} then
    ComposeRange(this, 'AllergyIntolerance', 'onsetRange', TFhirRange(value.onset), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.onset is TFhirDateTime) {6} then
    ComposeDateTime(this, 'AllergyIntolerance', 'onsetDateTime', TFhirDateTime(value.onset), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.onset is TFhirString) {6} then
    ComposeString(this, 'AllergyIntolerance', 'onsetString', TFhirString(value.onset), false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'AllergyIntolerance', 'recordedDate', value.recordedDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.participantList.Count - 1 do
      ComposeAllergyIntoleranceParticipant(this, 'AllergyIntolerance', 'participant', value.participantList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'AllergyIntolerance', 'lastOccurrence', value.lastOccurrenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'AllergyIntolerance', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reactionList.Count - 1 do
      ComposeAllergyIntoleranceReaction(this, 'AllergyIntolerance', 'reaction', value.reactionList[i], false, i);
end;

{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
function TFHIRTurtleParser.ParseAppointmentParticipant(obj : TTurtleComplex) : TFhirAppointmentParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAppointmentParticipant.create;
  try
    ParseAppointmentParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAppointmentParticipantProperties(obj : TTurtleComplex; value : TFhirAppointmentParticipant);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Appointment.participant.type') do
      value.type_List.Add(parseCodeableConcept(item));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Appointment.participant.period'));
    value.actor := ParseReference(obj.complex('http://hl7.org/fhir/Appointment.participant.actor'));
    value.requiredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Appointment.participant.required'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Appointment.participant.status'), CODES_TFhirParticipationStatusEnum, SYSTEMS_TFhirParticipationStatusEnum);
end;

procedure TFHIRTurtleComposer.ComposeAppointmentParticipant(parent :  TTurtleComplex; parentType, name : String; value : TFhirAppointmentParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AppointmentParticipant');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Appointment.participant', 'type', value.type_List[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Appointment.participant', 'period', value.periodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Appointment.participant', 'actor', value.actorElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Appointment.participant', 'required', value.requiredElement, false, -1);
  ComposeEnum(this, 'Appointment.participant', 'status', value.statusElement, CODES_TFhirParticipationStatusEnum, SYSTEMS_TFhirParticipationStatusEnum, false, -1);
end;

function TFHIRTurtleParser.ParseAppointmentRecurrenceTemplate(obj : TTurtleComplex) : TFhirAppointmentRecurrenceTemplate;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAppointmentRecurrenceTemplate.create;
  try
    ParseAppointmentRecurrenceTemplateProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAppointmentRecurrenceTemplateProperties(obj : TTurtleComplex; value : TFhirAppointmentRecurrenceTemplate);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.timezone := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Appointment.recurrenceTemplate.timezone'));
    value.recurrenceType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Appointment.recurrenceTemplate.recurrenceType'));
    value.lastOccurrenceDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Appointment.recurrenceTemplate.lastOccurrenceDate'));
    value.occurrenceCountElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Appointment.recurrenceTemplate.occurrenceCount'));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.recurrenceTemplate.occurrenceDate') do
      value.occurrenceDateList.Add(parseDate(item));
    value.weeklyTemplate := ParseAppointmentRecurrenceTemplateWeeklyTemplate(obj.complex('http://hl7.org/fhir/Appointment.recurrenceTemplate.weeklyTemplate'));
    value.monthlyTemplate := ParseAppointmentRecurrenceTemplateMonthlyTemplate(obj.complex('http://hl7.org/fhir/Appointment.recurrenceTemplate.monthlyTemplate'));
    value.yearlyTemplate := ParseAppointmentRecurrenceTemplateYearlyTemplate(obj.complex('http://hl7.org/fhir/Appointment.recurrenceTemplate.yearlyTemplate'));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.recurrenceTemplate.excludingDate') do
      value.excludingDateList.Add(parseDate(item));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.recurrenceTemplate.excludingRecurrenceId') do
      value.excludingRecurrenceIdList.Add(parsePositiveInt(item));
end;

procedure TFHIRTurtleComposer.ComposeAppointmentRecurrenceTemplate(parent :  TTurtleComplex; parentType, name : String; value : TFhirAppointmentRecurrenceTemplate; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AppointmentRecurrenceTemplate');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Appointment.recurrenceTemplate', 'timezone', value.timezoneElement, false, -1);
  ComposeCodeableConcept(this, 'Appointment.recurrenceTemplate', 'recurrenceType', value.recurrenceTypeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'Appointment.recurrenceTemplate', 'lastOccurrenceDate', value.lastOccurrenceDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'Appointment.recurrenceTemplate', 'occurrenceCount', value.occurrenceCountElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.occurrenceDateList.Count - 1 do
      ComposeDate(this, 'Appointment.recurrenceTemplate', 'occurrenceDate', value.occurrenceDateList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeAppointmentRecurrenceTemplateWeeklyTemplate(this, 'Appointment.recurrenceTemplate', 'weeklyTemplate', value.weeklyTemplateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeAppointmentRecurrenceTemplateMonthlyTemplate(this, 'Appointment.recurrenceTemplate', 'monthlyTemplate', value.monthlyTemplateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeAppointmentRecurrenceTemplateYearlyTemplate(this, 'Appointment.recurrenceTemplate', 'yearlyTemplate', value.yearlyTemplateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.excludingDateList.Count - 1 do
      ComposeDate(this, 'Appointment.recurrenceTemplate', 'excludingDate', value.excludingDateList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.excludingRecurrenceIdList.Count - 1 do
      ComposePositiveInt(this, 'Appointment.recurrenceTemplate', 'excludingRecurrenceId', value.excludingRecurrenceIdList[i], false, i);
end;

function TFHIRTurtleParser.ParseAppointmentRecurrenceTemplateWeeklyTemplate(obj : TTurtleComplex) : TFhirAppointmentRecurrenceTemplateWeeklyTemplate;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAppointmentRecurrenceTemplateWeeklyTemplate.create;
  try
    ParseAppointmentRecurrenceTemplateWeeklyTemplateProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAppointmentRecurrenceTemplateWeeklyTemplateProperties(obj : TTurtleComplex; value : TFhirAppointmentRecurrenceTemplateWeeklyTemplate);
begin
    ParseBackboneElementProperties(obj, value);
    value.mondayElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Appointment.recurrenceTemplate.weeklyTemplate.monday'));
    value.tuesdayElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Appointment.recurrenceTemplate.weeklyTemplate.tuesday'));
    value.wednesdayElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Appointment.recurrenceTemplate.weeklyTemplate.wednesday'));
    value.thursdayElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Appointment.recurrenceTemplate.weeklyTemplate.thursday'));
    value.fridayElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Appointment.recurrenceTemplate.weeklyTemplate.friday'));
    value.saturdayElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Appointment.recurrenceTemplate.weeklyTemplate.saturday'));
    value.sundayElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Appointment.recurrenceTemplate.weeklyTemplate.sunday'));
    value.weekIntervalElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Appointment.recurrenceTemplate.weeklyTemplate.weekInterval'));
end;

procedure TFHIRTurtleComposer.ComposeAppointmentRecurrenceTemplateWeeklyTemplate(parent :  TTurtleComplex; parentType, name : String; value : TFhirAppointmentRecurrenceTemplateWeeklyTemplate; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AppointmentRecurrenceTemplateWeeklyTemplate');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Appointment.recurrenceTemplate.weeklyTemplate', 'monday', value.mondayElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Appointment.recurrenceTemplate.weeklyTemplate', 'tuesday', value.tuesdayElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Appointment.recurrenceTemplate.weeklyTemplate', 'wednesday', value.wednesdayElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Appointment.recurrenceTemplate.weeklyTemplate', 'thursday', value.thursdayElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Appointment.recurrenceTemplate.weeklyTemplate', 'friday', value.fridayElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Appointment.recurrenceTemplate.weeklyTemplate', 'saturday', value.saturdayElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Appointment.recurrenceTemplate.weeklyTemplate', 'sunday', value.sundayElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'Appointment.recurrenceTemplate.weeklyTemplate', 'weekInterval', value.weekIntervalElement, false, -1);
end;

function TFHIRTurtleParser.ParseAppointmentRecurrenceTemplateMonthlyTemplate(obj : TTurtleComplex) : TFhirAppointmentRecurrenceTemplateMonthlyTemplate;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAppointmentRecurrenceTemplateMonthlyTemplate.create;
  try
    ParseAppointmentRecurrenceTemplateMonthlyTemplateProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAppointmentRecurrenceTemplateMonthlyTemplateProperties(obj : TTurtleComplex; value : TFhirAppointmentRecurrenceTemplateMonthlyTemplate);
begin
    ParseBackboneElementProperties(obj, value);
    value.dayOfMonthElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Appointment.recurrenceTemplate.monthlyTemplate.dayOfMonth'));
    value.nthWeekOfMonth := ParseCoding(obj.complex('http://hl7.org/fhir/Appointment.recurrenceTemplate.monthlyTemplate.nthWeekOfMonth'));
    value.dayOfWeek := ParseCoding(obj.complex('http://hl7.org/fhir/Appointment.recurrenceTemplate.monthlyTemplate.dayOfWeek'));
    value.monthIntervalElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Appointment.recurrenceTemplate.monthlyTemplate.monthInterval'));
end;

procedure TFHIRTurtleComposer.ComposeAppointmentRecurrenceTemplateMonthlyTemplate(parent :  TTurtleComplex; parentType, name : String; value : TFhirAppointmentRecurrenceTemplateMonthlyTemplate; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AppointmentRecurrenceTemplateMonthlyTemplate');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'Appointment.recurrenceTemplate.monthlyTemplate', 'dayOfMonth', value.dayOfMonthElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'Appointment.recurrenceTemplate.monthlyTemplate', 'nthWeekOfMonth', value.nthWeekOfMonthElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'Appointment.recurrenceTemplate.monthlyTemplate', 'dayOfWeek', value.dayOfWeekElement, false, -1);
  ComposePositiveInt(this, 'Appointment.recurrenceTemplate.monthlyTemplate', 'monthInterval', value.monthIntervalElement, false, -1);
end;

function TFHIRTurtleParser.ParseAppointmentRecurrenceTemplateYearlyTemplate(obj : TTurtleComplex) : TFhirAppointmentRecurrenceTemplateYearlyTemplate;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAppointmentRecurrenceTemplateYearlyTemplate.create;
  try
    ParseAppointmentRecurrenceTemplateYearlyTemplateProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAppointmentRecurrenceTemplateYearlyTemplateProperties(obj : TTurtleComplex; value : TFhirAppointmentRecurrenceTemplateYearlyTemplate);
begin
    ParseBackboneElementProperties(obj, value);
    value.yearIntervalElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Appointment.recurrenceTemplate.yearlyTemplate.yearInterval'));
end;

procedure TFHIRTurtleComposer.ComposeAppointmentRecurrenceTemplateYearlyTemplate(parent :  TTurtleComplex; parentType, name : String; value : TFhirAppointmentRecurrenceTemplateYearlyTemplate; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AppointmentRecurrenceTemplateYearlyTemplate');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposePositiveInt(this, 'Appointment.recurrenceTemplate.yearlyTemplate', 'yearInterval', value.yearIntervalElement, false, -1);
end;

function TFHIRTurtleParser.ParseAppointment(obj : TTurtleComplex) : TFhirAppointment;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAppointment.create;
  try
    ParseAppointmentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAppointmentProperties(obj : TTurtleComplex; value : TFhirAppointment);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Appointment.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Appointment.status'), CODES_TFhirAppointmentStatusEnum, SYSTEMS_TFhirAppointmentStatusEnum);
    value.cancellationReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Appointment.cancellationReason'));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.class') do
      value.class_List.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.serviceCategory') do
      value.serviceCategoryList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.serviceType') do
      value.serviceTypeList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.specialty') do
      value.specialtyList.Add(parseCodeableConcept(item));
    value.appointmentType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Appointment.appointmentType'));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.reason') do
      value.reasonList.Add(parseCodeableReference(item));
    value.priority := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Appointment.priority'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Appointment.description'));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.replaces') do
      value.replacesList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.virtualService') do
      value.virtualServiceList.Add(parseVirtualServiceDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.supportingInformation') do
      value.supportingInformationList.Add(parseReference(item));
    value.previousAppointment := ParseReference(obj.complex('http://hl7.org/fhir/Appointment.previousAppointment'));
    value.originatingAppointment := ParseReference(obj.complex('http://hl7.org/fhir/Appointment.originatingAppointment'));
    value.startElement := ParseInstant(obj.complex('http://hl7.org/fhir/Appointment.start'));
    value.end_Element := ParseInstant(obj.complex('http://hl7.org/fhir/Appointment.end'));
    value.minutesDurationElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Appointment.minutesDuration'));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.slot') do
      value.slotList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.account') do
      value.accountList.Add(parseReference(item));
    value.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Appointment.created'));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.patientInstruction') do
      value.patientInstructionList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.basedOn') do
      value.basedOnList.Add(parseReference(item));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/Appointment.subject'));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.participant') do
      value.participantList.Add(parseAppointmentParticipant(item));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.requestedPeriod') do
      value.requestedPeriodList.Add(parsePeriod(item));
    value.recurrenceIdElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Appointment.recurrenceId'));
    value.occurrenceChangedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Appointment.occurrenceChanged'));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.recurrenceTemplate') do
      value.recurrenceTemplateList.Add(parseAppointmentRecurrenceTemplate(item));
end;

procedure TFHIRTurtleComposer.ComposeAppointment(parent :  TTurtleComplex; parentType, name : String; value : TFhirAppointment; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Appointment');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Appointment', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'Appointment', 'status', value.statusElement, CODES_TFhirAppointmentStatusEnum, SYSTEMS_TFhirAppointmentStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Appointment', 'cancellationReason', value.cancellationReasonElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.class_List.Count - 1 do
      ComposeCodeableConcept(this, 'Appointment', 'class', value.class_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.serviceCategoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Appointment', 'serviceCategory', value.serviceCategoryList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.serviceTypeList.Count - 1 do
      ComposeCodeableReference(this, 'Appointment', 'serviceType', value.serviceTypeList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.specialtyList.Count - 1 do
      ComposeCodeableConcept(this, 'Appointment', 'specialty', value.specialtyList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Appointment', 'appointmentType', value.appointmentTypeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(this, 'Appointment', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Appointment', 'priority', value.priorityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Appointment', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.replacesList.Count - 1 do
      ComposeReference(this, 'Appointment', 'replaces', value.replacesList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.virtualServiceList.Count - 1 do
      ComposeVirtualServiceDetail(this, 'Appointment', 'virtualService', value.virtualServiceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInformationList.Count - 1 do
      ComposeReference(this, 'Appointment', 'supportingInformation', value.supportingInformationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Appointment', 'previousAppointment', value.previousAppointmentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Appointment', 'originatingAppointment', value.originatingAppointmentElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'Appointment', 'start', value.startElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'Appointment', 'end', value.end_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'Appointment', 'minutesDuration', value.minutesDurationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.slotList.Count - 1 do
      ComposeReference(this, 'Appointment', 'slot', value.slotList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.accountList.Count - 1 do
      ComposeReference(this, 'Appointment', 'account', value.accountList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Appointment', 'created', value.createdElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'Appointment', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.patientInstructionList.Count - 1 do
      ComposeCodeableReference(this, 'Appointment', 'patientInstruction', value.patientInstructionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'Appointment', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Appointment', 'subject', value.subjectElement, false, -1);
  for i := 0 to value.participantList.Count - 1 do
      ComposeAppointmentParticipant(this, 'Appointment', 'participant', value.participantList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.requestedPeriodList.Count - 1 do
      ComposePeriod(this, 'Appointment', 'requestedPeriod', value.requestedPeriodList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'Appointment', 'recurrenceId', value.recurrenceIdElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Appointment', 'occurrenceChanged', value.occurrenceChangedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.recurrenceTemplateList.Count - 1 do
      ComposeAppointmentRecurrenceTemplate(this, 'Appointment', 'recurrenceTemplate', value.recurrenceTemplateList[i], false, i);
end;

{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
function TFHIRTurtleParser.ParseAppointmentResponse(obj : TTurtleComplex) : TFhirAppointmentResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAppointmentResponse.create;
  try
    ParseAppointmentResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAppointmentResponseProperties(obj : TTurtleComplex; value : TFhirAppointmentResponse);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/AppointmentResponse.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.appointment := ParseReference(obj.complex('http://hl7.org/fhir/AppointmentResponse.appointment'));
    value.proposedNewTimeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/AppointmentResponse.proposedNewTime'));
    value.startElement := ParseInstant(obj.complex('http://hl7.org/fhir/AppointmentResponse.start'));
    value.end_Element := ParseInstant(obj.complex('http://hl7.org/fhir/AppointmentResponse.end'));
    for item in obj.complexes('http://hl7.org/fhir/AppointmentResponse.participantType') do
      value.participantTypeList.Add(parseCodeableConcept(item));
    value.actor := ParseReference(obj.complex('http://hl7.org/fhir/AppointmentResponse.actor'));
    value.participantStatusElement := ParseEnum(obj.complex('http://hl7.org/fhir/AppointmentResponse.participantStatus'), CODES_TFhirParticipationStatusEnum, SYSTEMS_TFhirParticipationStatusEnum);
    value.commentElement := ParseString(obj.complex('http://hl7.org/fhir/AppointmentResponse.comment'));
    value.recurringElement := ParseBoolean(obj.complex('http://hl7.org/fhir/AppointmentResponse.recurring'));
    value.occurrenceDateElement := ParseDate(obj.complex('http://hl7.org/fhir/AppointmentResponse.occurrenceDate'));
    value.recurrenceIdElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/AppointmentResponse.recurrenceId'));
end;

procedure TFHIRTurtleComposer.ComposeAppointmentResponse(parent :  TTurtleComplex; parentType, name : String; value : TFhirAppointmentResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AppointmentResponse');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'AppointmentResponse', 'identifier', value.identifierList[i], false, i);
  ComposeReference(this, 'AppointmentResponse', 'appointment', value.appointmentElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'AppointmentResponse', 'proposedNewTime', value.proposedNewTimeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeInstant(this, 'AppointmentResponse', 'start', value.startElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeInstant(this, 'AppointmentResponse', 'end', value.end_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.participantTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'AppointmentResponse', 'participantType', value.participantTypeList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'AppointmentResponse', 'actor', value.actorElement, false, -1);
  ComposeEnum(this, 'AppointmentResponse', 'participantStatus', value.participantStatusElement, CODES_TFhirParticipationStatusEnum, SYSTEMS_TFhirParticipationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AppointmentResponse', 'comment', value.commentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'AppointmentResponse', 'recurring', value.recurringElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'AppointmentResponse', 'occurrenceDate', value.occurrenceDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'AppointmentResponse', 'recurrenceId', value.recurrenceIdElement, false, -1);
end;

{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_ARTIFACTASSESSMENT}
function TFHIRTurtleParser.ParseArtifactAssessmentContent(obj : TTurtleComplex) : TFhirArtifactAssessmentContent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirArtifactAssessmentContent.create;
  try
    ParseArtifactAssessmentContentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseArtifactAssessmentContentProperties(obj : TTurtleComplex; value : TFhirArtifactAssessmentContent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.informationTypeElement := ParseEnum(obj.complex('http://hl7.org/fhir/ArtifactAssessment.content.informationType'), CODES_TFhirArtifactAssessmentInformationTypeEnum, SYSTEMS_TFhirArtifactAssessmentInformationTypeEnum);
    value.summaryElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ArtifactAssessment.content.summary'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ArtifactAssessment.content.type'));
    for item in obj.complexes('http://hl7.org/fhir/ArtifactAssessment.content.classifier') do
      value.classifierList.Add(parseCodeableConcept(item));
    value.author := ParseReference(obj.complex('http://hl7.org/fhir/ArtifactAssessment.content.author'));
    for item in obj.complexes('http://hl7.org/fhir/ArtifactAssessment.content.path') do
      value.pathList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/ArtifactAssessment.content.relatedArtifact') do
      value.relatedArtifactList.Add(parseRelatedArtifact(item));
    value.freeToShareElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ArtifactAssessment.content.freeToShare'));
    for item in obj.complexes('http://hl7.org/fhir/ArtifactAssessment.content.component') do
      value.componentList.Add(parseArtifactAssessmentContent(item));
end;

procedure TFHIRTurtleComposer.ComposeArtifactAssessmentContent(parent :  TTurtleComplex; parentType, name : String; value : TFhirArtifactAssessmentContent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ArtifactAssessmentContent');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'ArtifactAssessment.content', 'informationType', value.informationTypeElement, CODES_TFhirArtifactAssessmentInformationTypeEnum, SYSTEMS_TFhirArtifactAssessmentInformationTypeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ArtifactAssessment.content', 'summary', value.summaryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ArtifactAssessment.content', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.classifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ArtifactAssessment.content', 'classifier', value.classifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ArtifactAssessment.content', 'author', value.authorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.pathList.Count - 1 do
      ComposeUri(this, 'ArtifactAssessment.content', 'path', value.pathList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'ArtifactAssessment.content', 'relatedArtifact', value.relatedArtifactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ArtifactAssessment.content', 'freeToShare', value.freeToShareElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.componentList.Count - 1 do
      ComposeArtifactAssessmentContent(this, 'ArtifactAssessment.content', 'component', value.componentList[i], false, i);
end;

function TFHIRTurtleParser.ParseArtifactAssessment(obj : TTurtleComplex) : TFhirArtifactAssessment;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirArtifactAssessment.create;
  try
    ParseArtifactAssessmentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseArtifactAssessmentProperties(obj : TTurtleComplex; value : TFhirArtifactAssessment);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/ArtifactAssessment.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    if obj.has('citeAsReference', item) {a3} then
      value.citeAs := ParseReference(item);
    if obj.has('citeAsMarkdown', item) then
      value.citeAs := parseMarkdown(item);
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ArtifactAssessment.date'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ArtifactAssessment.copyright'));
    value.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ArtifactAssessment.approvalDate'));
    value.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ArtifactAssessment.lastReviewDate'));
    if obj.has('artifactReference', item) {a3} then
      value.artifact := ParseReference(item);
    if obj.has('artifactCanonical', item) then
      value.artifact := parseCanonical(item);
    if obj.has('artifactUri', item) then
      value.artifact := parseUri(item);
    for item in obj.complexes('http://hl7.org/fhir/ArtifactAssessment.content') do
      value.contentList.Add(parseArtifactAssessmentContent(item));
    value.workflowStatusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ArtifactAssessment.workflowStatus'), CODES_TFhirArtifactAssessmentWorkflowStatusEnum, SYSTEMS_TFhirArtifactAssessmentWorkflowStatusEnum);
    value.dispositionElement := ParseEnum(obj.complex('http://hl7.org/fhir/ArtifactAssessment.disposition'), CODES_TFhirArtifactAssessmentDispositionEnum, SYSTEMS_TFhirArtifactAssessmentDispositionEnum);
end;

procedure TFHIRTurtleComposer.ComposeArtifactAssessment(parent :  TTurtleComplex; parentType, name : String; value : TFhirArtifactAssessment; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ArtifactAssessment');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ArtifactAssessment', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) and (value.citeAs is TFhirReference) {2} then
    ComposeReference(this, 'ArtifactAssessment', 'citeAsReference', TFhirReference(value.citeAs), false,-1)
  else if (SummaryOption in [soFull, soData]) and (value.citeAs is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'ArtifactAssessment', 'citeAsMarkdown', TFhirMarkdown(value.citeAs), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ArtifactAssessment', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ArtifactAssessment', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'ArtifactAssessment', 'approvalDate', value.approvalDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'ArtifactAssessment', 'lastReviewDate', value.lastReviewDateElement, false, -1);
  if (value.artifact is TFhirReference) {2} then
    ComposeReference(this, 'ArtifactAssessment', 'artifactReference', TFhirReference(value.artifact), false,-1)
  else if (value.artifact is TFhirCanonical) {6} then
    ComposeCanonical(this, 'ArtifactAssessment', 'artifactCanonical', TFhirCanonical(value.artifact), false, -1)
  else if (value.artifact is TFhirUri) {6} then
    ComposeUri(this, 'ArtifactAssessment', 'artifactUri', TFhirUri(value.artifact), false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contentList.Count - 1 do
      ComposeArtifactAssessmentContent(this, 'ArtifactAssessment', 'content', value.contentList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'ArtifactAssessment', 'workflowStatus', value.workflowStatusElement, CODES_TFhirArtifactAssessmentWorkflowStatusEnum, SYSTEMS_TFhirArtifactAssessmentWorkflowStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'ArtifactAssessment', 'disposition', value.dispositionElement, CODES_TFhirArtifactAssessmentDispositionEnum, SYSTEMS_TFhirArtifactAssessmentDispositionEnum, false, -1);
end;

{$ENDIF FHIR_ARTIFACTASSESSMENT}
{$IFDEF FHIR_AUDITEVENT}
function TFHIRTurtleParser.ParseAuditEventOutcome(obj : TTurtleComplex) : TFhirAuditEventOutcome;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAuditEventOutcome.create;
  try
    ParseAuditEventOutcomeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAuditEventOutcomeProperties(obj : TTurtleComplex; value : TFhirAuditEventOutcome);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCoding(obj.complex('http://hl7.org/fhir/AuditEvent.outcome.code'));
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.outcome.detail') do
      value.detailList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeAuditEventOutcome(parent :  TTurtleComplex; parentType, name : String; value : TFhirAuditEventOutcome; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AuditEventOutcome');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCoding(this, 'AuditEvent.outcome', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.detailList.Count - 1 do
      ComposeCodeableConcept(this, 'AuditEvent.outcome', 'detail', value.detailList[i], false, i);
end;

function TFHIRTurtleParser.ParseAuditEventAgent(obj : TTurtleComplex) : TFhirAuditEventAgent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAuditEventAgent.create;
  try
    ParseAuditEventAgentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAuditEventAgentProperties(obj : TTurtleComplex; value : TFhirAuditEventAgent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AuditEvent.agent.type'));
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.agent.role') do
      value.roleList.Add(parseCodeableConcept(item));
    value.who := ParseReference(obj.complex('http://hl7.org/fhir/AuditEvent.agent.who'));
    value.requestorElement := ParseBoolean(obj.complex('http://hl7.org/fhir/AuditEvent.agent.requestor'));
    value.location := ParseReference(obj.complex('http://hl7.org/fhir/AuditEvent.agent.location'));
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.agent.policy') do
      value.policyList.Add(parseUri(item));
    if obj.has('networkReference', item) {a3} then
      value.network := ParseReference(item);
    if obj.has('networkUri', item) then
      value.network := parseUri(item);
    if obj.has('networkString', item) then
      value.network := parseString(item);
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.agent.authorization') do
      value.authorizationList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeAuditEventAgent(parent :  TTurtleComplex; parentType, name : String; value : TFhirAuditEventAgent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AuditEventAgent');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'AuditEvent.agent', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.roleList.Count - 1 do
      ComposeCodeableConcept(this, 'AuditEvent.agent', 'role', value.roleList[i], false, i);
  ComposeReference(this, 'AuditEvent.agent', 'who', value.whoElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'AuditEvent.agent', 'requestor', value.requestorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'AuditEvent.agent', 'location', value.locationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.policyList.Count - 1 do
      ComposeUri(this, 'AuditEvent.agent', 'policy', value.policyList[i], false, i);
  if (SummaryOption in [soFull, soData]) and (value.network is TFhirReference) {2} then
    ComposeReference(this, 'AuditEvent.agent', 'networkReference', TFhirReference(value.network), false,-1)
  else if (SummaryOption in [soFull, soData]) and (value.network is TFhirUri) {6} then
    ComposeUri(this, 'AuditEvent.agent', 'networkUri', TFhirUri(value.network), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.network is TFhirString) {6} then
    ComposeString(this, 'AuditEvent.agent', 'networkString', TFhirString(value.network), false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorizationList.Count - 1 do
      ComposeCodeableConcept(this, 'AuditEvent.agent', 'authorization', value.authorizationList[i], false, i);
end;

function TFHIRTurtleParser.ParseAuditEventSource(obj : TTurtleComplex) : TFhirAuditEventSource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAuditEventSource.create;
  try
    ParseAuditEventSourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAuditEventSourceProperties(obj : TTurtleComplex; value : TFhirAuditEventSource);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.site := ParseReference(obj.complex('http://hl7.org/fhir/AuditEvent.source.site'));
    value.observer := ParseReference(obj.complex('http://hl7.org/fhir/AuditEvent.source.observer'));
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.source.type') do
      value.type_List.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeAuditEventSource(parent :  TTurtleComplex; parentType, name : String; value : TFhirAuditEventSource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AuditEventSource');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'AuditEvent.source', 'site', value.siteElement, false, -1);
  ComposeReference(this, 'AuditEvent.source', 'observer', value.observerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'AuditEvent.source', 'type', value.type_List[i], false, i);
end;

function TFHIRTurtleParser.ParseAuditEventEntity(obj : TTurtleComplex) : TFhirAuditEventEntity;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAuditEventEntity.create;
  try
    ParseAuditEventEntityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAuditEventEntityProperties(obj : TTurtleComplex; value : TFhirAuditEventEntity);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.what := ParseReference(obj.complex('http://hl7.org/fhir/AuditEvent.entity.what'));
    value.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AuditEvent.entity.role'));
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.entity.securityLabel') do
      value.securityLabelList.Add(parseCodeableConcept(item));
    value.queryElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/AuditEvent.entity.query'));
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.entity.detail') do
      value.detailList.Add(parseAuditEventEntityDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.entity.agent') do
      value.agentList.Add(parseAuditEventAgent(item));
end;

procedure TFHIRTurtleComposer.ComposeAuditEventEntity(parent :  TTurtleComplex; parentType, name : String; value : TFhirAuditEventEntity; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AuditEventEntity');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'AuditEvent.entity', 'what', value.whatElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'AuditEvent.entity', 'role', value.roleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.securityLabelList.Count - 1 do
      ComposeCodeableConcept(this, 'AuditEvent.entity', 'securityLabel', value.securityLabelList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64Binary(this, 'AuditEvent.entity', 'query', value.queryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.detailList.Count - 1 do
      ComposeAuditEventEntityDetail(this, 'AuditEvent.entity', 'detail', value.detailList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.agentList.Count - 1 do
      ComposeAuditEventAgent(this, 'AuditEvent.entity', 'agent', value.agentList[i], false, i);
end;

function TFHIRTurtleParser.ParseAuditEventEntityDetail(obj : TTurtleComplex) : TFhirAuditEventEntityDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAuditEventEntityDetail.create;
  try
    ParseAuditEventEntityDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAuditEventEntityDetailProperties(obj : TTurtleComplex; value : TFhirAuditEventEntityDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AuditEvent.entity.detail.type'));
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueRange', item) then
      value.value := parseRange(item);
    if obj.has('valueRatio', item) then
      value.value := parseRatio(item);
    if obj.has('valuePeriod', item) then
      value.value := parsePeriod(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    if obj.has('valueInteger', item) then
      value.value := parseInteger(item);
    if obj.has('valueTime', item) then
      value.value := parseTime(item);
    if obj.has('valueDateTime', item) then
      value.value := parseDateTime(item);
    if obj.has('valueBase64Binary', item) then
      value.value := parseBase64Binary(item);
end;

procedure TFHIRTurtleComposer.ComposeAuditEventEntityDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirAuditEventEntityDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AuditEventEntityDetail');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'AuditEvent.entity.detail', 'type', value.type_Element, false, -1);
  if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'AuditEvent.entity.detail', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'AuditEvent.entity.detail', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (value.value is TFhirRange) {6} then
    ComposeRange(this, 'AuditEvent.entity.detail', 'valueRange', TFhirRange(value.value), false, -1)
  else if (value.value is TFhirRatio) {6} then
    ComposeRatio(this, 'AuditEvent.entity.detail', 'valueRatio', TFhirRatio(value.value), false, -1)
  else if (value.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'AuditEvent.entity.detail', 'valuePeriod', TFhirPeriod(value.value), false, -1)
  else if (value.value is TFhirString) {6} then
    ComposeString(this, 'AuditEvent.entity.detail', 'valueString', TFhirString(value.value), false, -1)
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'AuditEvent.entity.detail', 'valueBoolean', TFhirBoolean(value.value), false, -1)
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(this, 'AuditEvent.entity.detail', 'valueInteger', TFhirInteger(value.value), false, -1)
  else if (value.value is TFhirTime) {6} then
    ComposeTime(this, 'AuditEvent.entity.detail', 'valueTime', TFhirTime(value.value), false, -1)
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'AuditEvent.entity.detail', 'valueDateTime', TFhirDateTime(value.value), false, -1)
  else if (value.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'AuditEvent.entity.detail', 'valueBase64Binary', TFhirBase64Binary(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseAuditEvent(obj : TTurtleComplex) : TFhirAuditEvent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAuditEvent.create;
  try
    ParseAuditEventProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAuditEventProperties(obj : TTurtleComplex; value : TFhirAuditEvent);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AuditEvent.code'));
    value.actionElement := ParseEnum(obj.complex('http://hl7.org/fhir/AuditEvent.action'), CODES_TFhirAuditEventActionEnum, SYSTEMS_TFhirAuditEventActionEnum);
    value.severityElement := ParseEnum(obj.complex('http://hl7.org/fhir/AuditEvent.severity'), CODES_TFhirAuditEventSeverityEnum, SYSTEMS_TFhirAuditEventSeverityEnum);
    if obj.has('occurredPeriod', item) then
      value.occurred := parsePeriod(item);
    if obj.has('occurredDateTime', item) then
      value.occurred := parseDateTime(item);
    value.recordedElement := ParseInstant(obj.complex('http://hl7.org/fhir/AuditEvent.recorded'));
    value.outcome := ParseAuditEventOutcome(obj.complex('http://hl7.org/fhir/AuditEvent.outcome'));
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.authorization') do
      value.authorizationList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.basedOn') do
      value.basedOnList.Add(parseReference(item));
    value.patient := ParseReference(obj.complex('http://hl7.org/fhir/AuditEvent.patient'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/AuditEvent.encounter'));
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.agent') do
      value.agentList.Add(parseAuditEventAgent(item));
    value.source := ParseAuditEventSource(obj.complex('http://hl7.org/fhir/AuditEvent.source'));
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.entity') do
      value.entityList.Add(parseAuditEventEntity(item));
end;

procedure TFHIRTurtleComposer.ComposeAuditEvent(parent :  TTurtleComplex; parentType, name : String; value : TFhirAuditEvent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AuditEvent');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'AuditEvent', 'category', value.categoryList[i], false, i);
  ComposeCodeableConcept(this, 'AuditEvent', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'AuditEvent', 'action', value.actionElement, CODES_TFhirAuditEventActionEnum, SYSTEMS_TFhirAuditEventActionEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'AuditEvent', 'severity', value.severityElement, CODES_TFhirAuditEventSeverityEnum, SYSTEMS_TFhirAuditEventSeverityEnum, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.occurred is TFhirPeriod) {6} then
    ComposePeriod(this, 'AuditEvent', 'occurredPeriod', TFhirPeriod(value.occurred), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.occurred is TFhirDateTime) {6} then
    ComposeDateTime(this, 'AuditEvent', 'occurredDateTime', TFhirDateTime(value.occurred), false, -1);
  ComposeInstant(this, 'AuditEvent', 'recorded', value.recordedElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAuditEventOutcome(this, 'AuditEvent', 'outcome', value.outcomeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.authorizationList.Count - 1 do
      ComposeCodeableConcept(this, 'AuditEvent', 'authorization', value.authorizationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'AuditEvent', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'AuditEvent', 'patient', value.patientElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'AuditEvent', 'encounter', value.encounterElement, false, -1);
  for i := 0 to value.agentList.Count - 1 do
      ComposeAuditEventAgent(this, 'AuditEvent', 'agent', value.agentList[i], false, i);
  ComposeAuditEventSource(this, 'AuditEvent', 'source', value.sourceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.entityList.Count - 1 do
      ComposeAuditEventEntity(this, 'AuditEvent', 'entity', value.entityList[i], false, i);
end;

{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
function TFHIRTurtleParser.ParseBasic(obj : TTurtleComplex) : TFhirBasic;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBasic.create;
  try
    ParseBasicProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBasicProperties(obj : TTurtleComplex; value : TFhirBasic);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Basic.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Basic.code'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/Basic.subject'));
    value.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Basic.created'));
    value.author := ParseReference(obj.complex('http://hl7.org/fhir/Basic.author'));
end;

procedure TFHIRTurtleComposer.ComposeBasic(parent :  TTurtleComplex; parentType, name : String; value : TFhirBasic; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Basic');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Basic', 'identifier', value.identifierList[i], false, i);
  ComposeCodeableConcept(this, 'Basic', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Basic', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Basic', 'created', value.createdElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Basic', 'author', value.authorElement, false, -1);
end;

{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
function TFHIRTurtleParser.ParseBinary(obj : TTurtleComplex) : TFhirBinary;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBinary.create;
  try
    ParseBinaryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBinaryProperties(obj : TTurtleComplex; value : TFhirBinary);
begin
    ParseResourceProperties(obj, value);
    value.contentTypeElement := ParseCode(obj.complex('http://hl7.org/fhir/Binary.contentType'));
    value.securityContext := ParseReference(obj.complex('http://hl7.org/fhir/Binary.securityContext'));
    value.dataElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/Binary.data'));
end;

procedure TFHIRTurtleComposer.ComposeBinary(parent :  TTurtleComplex; parentType, name : String; value : TFhirBinary; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Binary');
  end;
  composeResource(this, '', name, value, false, index);
  ComposeCode(this, 'Binary', 'contentType', value.contentTypeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Binary', 'securityContext', value.securityContextElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBase64Binary(this, 'Binary', 'data', value.dataElement, false, -1);
end;

{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
function TFHIRTurtleParser.ParseBiologicallyDerivedProductCollection(obj : TTurtleComplex) : TFhirBiologicallyDerivedProductCollection;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBiologicallyDerivedProductCollection.create;
  try
    ParseBiologicallyDerivedProductCollectionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBiologicallyDerivedProductCollectionProperties(obj : TTurtleComplex; value : TFhirBiologicallyDerivedProductCollection);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.collector := ParseReference(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.collection.collector'));
    value.source := ParseReference(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.collection.source'));
    if obj.has('collectedPeriod', item) then
      value.collected := parsePeriod(item);
    if obj.has('collectedDateTime', item) then
      value.collected := parseDateTime(item);
end;

procedure TFHIRTurtleComposer.ComposeBiologicallyDerivedProductCollection(parent :  TTurtleComplex; parentType, name : String; value : TFhirBiologicallyDerivedProductCollection; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BiologicallyDerivedProductCollection');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'BiologicallyDerivedProduct.collection', 'collector', value.collectorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'BiologicallyDerivedProduct.collection', 'source', value.sourceElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.collected is TFhirPeriod) {6} then
    ComposePeriod(this, 'BiologicallyDerivedProduct.collection', 'collectedPeriod', TFhirPeriod(value.collected), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.collected is TFhirDateTime) {6} then
    ComposeDateTime(this, 'BiologicallyDerivedProduct.collection', 'collectedDateTime', TFhirDateTime(value.collected), false, -1);
end;

function TFHIRTurtleParser.ParseBiologicallyDerivedProductProperty(obj : TTurtleComplex) : TFhirBiologicallyDerivedProductProperty;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBiologicallyDerivedProductProperty.create;
  try
    ParseBiologicallyDerivedProductPropertyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBiologicallyDerivedProductPropertyProperties(obj : TTurtleComplex; value : TFhirBiologicallyDerivedProductProperty);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.property.type'));
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valuePeriod', item) then
      value.value := parsePeriod(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueRange', item) then
      value.value := parseRange(item);
    if obj.has('valueRatio', item) then
      value.value := parseRatio(item);
    if obj.has('valueAttachment', item) then
      value.value := parseAttachment(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    if obj.has('valueInteger', item) then
      value.value := parseInteger(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
end;

procedure TFHIRTurtleComposer.ComposeBiologicallyDerivedProductProperty(parent :  TTurtleComplex; parentType, name : String; value : TFhirBiologicallyDerivedProductProperty; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BiologicallyDerivedProductProperty');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCoding(this, 'BiologicallyDerivedProduct.property', 'type', value.type_Element, false, -1);
  if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'BiologicallyDerivedProduct.property', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (value.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'BiologicallyDerivedProduct.property', 'valuePeriod', TFhirPeriod(value.value), false, -1)
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'BiologicallyDerivedProduct.property', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (value.value is TFhirRange) {6} then
    ComposeRange(this, 'BiologicallyDerivedProduct.property', 'valueRange', TFhirRange(value.value), false, -1)
  else if (value.value is TFhirRatio) {6} then
    ComposeRatio(this, 'BiologicallyDerivedProduct.property', 'valueRatio', TFhirRatio(value.value), false, -1)
  else if (value.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'BiologicallyDerivedProduct.property', 'valueAttachment', TFhirAttachment(value.value), false, -1)
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'BiologicallyDerivedProduct.property', 'valueBoolean', TFhirBoolean(value.value), false, -1)
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(this, 'BiologicallyDerivedProduct.property', 'valueInteger', TFhirInteger(value.value), false, -1)
  else if (value.value is TFhirString) {6} then
    ComposeString(this, 'BiologicallyDerivedProduct.property', 'valueString', TFhirString(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseBiologicallyDerivedProduct(obj : TTurtleComplex) : TFhirBiologicallyDerivedProduct;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBiologicallyDerivedProduct.create;
  try
    ParseBiologicallyDerivedProductProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBiologicallyDerivedProductProperties(obj : TTurtleComplex; value : TFhirBiologicallyDerivedProduct);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    value.productCategory := ParseCoding(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.productCategory'));
    value.productCode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.productCode'));
    for item in obj.complexes('http://hl7.org/fhir/BiologicallyDerivedProduct.parent') do
      value.parentList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/BiologicallyDerivedProduct.request') do
      value.requestList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/BiologicallyDerivedProduct.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.biologicalSourceEvent := ParseIdentifier(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.biologicalSourceEvent'));
    for item in obj.complexes('http://hl7.org/fhir/BiologicallyDerivedProduct.processingFacility') do
      value.processingFacilityList.Add(parseReference(item));
    value.divisionElement := ParseString(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.division'));
    value.productStatus := ParseCoding(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.productStatus'));
    value.expirationDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.expirationDate'));
    value.collection := ParseBiologicallyDerivedProductCollection(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.collection'));
    value.storageTempRequirements := ParseRange(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.storageTempRequirements'));
    for item in obj.complexes('http://hl7.org/fhir/BiologicallyDerivedProduct.property') do
      value.property_List.Add(parseBiologicallyDerivedProductProperty(item));
end;

procedure TFHIRTurtleComposer.ComposeBiologicallyDerivedProduct(parent :  TTurtleComplex; parentType, name : String; value : TFhirBiologicallyDerivedProduct; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BiologicallyDerivedProduct');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'BiologicallyDerivedProduct', 'productCategory', value.productCategoryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'BiologicallyDerivedProduct', 'productCode', value.productCodeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.parentList.Count - 1 do
      ComposeReference(this, 'BiologicallyDerivedProduct', 'parent', value.parentList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.requestList.Count - 1 do
      ComposeReference(this, 'BiologicallyDerivedProduct', 'request', value.requestList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'BiologicallyDerivedProduct', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'BiologicallyDerivedProduct', 'biologicalSourceEvent', value.biologicalSourceEventElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.processingFacilityList.Count - 1 do
      ComposeReference(this, 'BiologicallyDerivedProduct', 'processingFacility', value.processingFacilityList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'BiologicallyDerivedProduct', 'division', value.divisionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'BiologicallyDerivedProduct', 'productStatus', value.productStatusElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'BiologicallyDerivedProduct', 'expirationDate', value.expirationDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBiologicallyDerivedProductCollection(this, 'BiologicallyDerivedProduct', 'collection', value.collectionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(this, 'BiologicallyDerivedProduct', 'storageTempRequirements', value.storageTempRequirementsElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeBiologicallyDerivedProductProperty(this, 'BiologicallyDerivedProduct', 'property', value.property_List[i], false, i);
end;

{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
function TFHIRTurtleParser.ParseBodyStructureIncludedStructure(obj : TTurtleComplex) : TFhirBodyStructureIncludedStructure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBodyStructureIncludedStructure.create;
  try
    ParseBodyStructureIncludedStructureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBodyStructureIncludedStructureProperties(obj : TTurtleComplex; value : TFhirBodyStructureIncludedStructure);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.structure := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/BodyStructure.includedStructure.structure'));
    value.laterality := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/BodyStructure.includedStructure.laterality'));
    for item in obj.complexes('http://hl7.org/fhir/BodyStructure.includedStructure.qualifier') do
      value.qualifierList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeBodyStructureIncludedStructure(parent :  TTurtleComplex; parentType, name : String; value : TFhirBodyStructureIncludedStructure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BodyStructureIncludedStructure');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'BodyStructure.includedStructure', 'structure', value.structureElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'BodyStructure.includedStructure', 'laterality', value.lateralityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.qualifierList.Count - 1 do
      ComposeCodeableConcept(this, 'BodyStructure.includedStructure', 'qualifier', value.qualifierList[i], false, i);
end;

function TFHIRTurtleParser.ParseBodyStructureExcludedStructure(obj : TTurtleComplex) : TFhirBodyStructureExcludedStructure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBodyStructureExcludedStructure.create;
  try
    ParseBodyStructureExcludedStructureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBodyStructureExcludedStructureProperties(obj : TTurtleComplex; value : TFhirBodyStructureExcludedStructure);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.structure := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/BodyStructure.excludedStructure.structure'));
    value.laterality := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/BodyStructure.excludedStructure.laterality'));
    for item in obj.complexes('http://hl7.org/fhir/BodyStructure.excludedStructure.qualifier') do
      value.qualifierList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeBodyStructureExcludedStructure(parent :  TTurtleComplex; parentType, name : String; value : TFhirBodyStructureExcludedStructure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BodyStructureExcludedStructure');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'BodyStructure.excludedStructure', 'structure', value.structureElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'BodyStructure.excludedStructure', 'laterality', value.lateralityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.qualifierList.Count - 1 do
      ComposeCodeableConcept(this, 'BodyStructure.excludedStructure', 'qualifier', value.qualifierList[i], false, i);
end;

function TFHIRTurtleParser.ParseBodyStructure(obj : TTurtleComplex) : TFhirBodyStructure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBodyStructure.create;
  try
    ParseBodyStructureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBodyStructureProperties(obj : TTurtleComplex; value : TFhirBodyStructure);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/BodyStructure.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/BodyStructure.active'));
    value.morphology := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/BodyStructure.morphology'));
    for item in obj.complexes('http://hl7.org/fhir/BodyStructure.includedStructure') do
      value.includedStructureList.Add(parseBodyStructureIncludedStructure(item));
    for item in obj.complexes('http://hl7.org/fhir/BodyStructure.excludedStructure') do
      value.excludedStructureList.Add(parseBodyStructureExcludedStructure(item));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/BodyStructure.description'));
    for item in obj.complexes('http://hl7.org/fhir/BodyStructure.image') do
      value.imageList.Add(parseAttachment(item));
    value.patient := ParseReference(obj.complex('http://hl7.org/fhir/BodyStructure.patient'));
end;

procedure TFHIRTurtleComposer.ComposeBodyStructure(parent :  TTurtleComplex; parentType, name : String; value : TFhirBodyStructure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BodyStructure');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'BodyStructure', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'BodyStructure', 'active', value.activeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'BodyStructure', 'morphology', value.morphologyElement, false, -1);
  for i := 0 to value.includedStructureList.Count - 1 do
      ComposeBodyStructureIncludedStructure(this, 'BodyStructure', 'includedStructure', value.includedStructureList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.excludedStructureList.Count - 1 do
      ComposeBodyStructureExcludedStructure(this, 'BodyStructure', 'excludedStructure', value.excludedStructureList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'BodyStructure', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.imageList.Count - 1 do
      ComposeAttachment(this, 'BodyStructure', 'image', value.imageList[i], false, i);
  ComposeReference(this, 'BodyStructure', 'patient', value.patientElement, false, -1);
end;

{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_BUNDLE}
function TFHIRTurtleParser.ParseBundleLink(obj : TTurtleComplex) : TFhirBundleLink;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBundleLink.create;
  try
    ParseBundleLinkProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBundleLinkProperties(obj : TTurtleComplex; value : TFhirBundleLink);
begin
    ParseBackboneElementProperties(obj, value);
    value.relationElement := ParseEnum(obj.complex('http://hl7.org/fhir/Bundle.link.relation'), CODES_TFhirLinkRelationTypesEnum, SYSTEMS_TFhirLinkRelationTypesEnum);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Bundle.link.url'));
end;

procedure TFHIRTurtleComposer.ComposeBundleLink(parent :  TTurtleComplex; parentType, name : String; value : TFhirBundleLink; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BundleLink');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'Bundle.link', 'relation', value.relationElement, CODES_TFhirLinkRelationTypesEnum, SYSTEMS_TFhirLinkRelationTypesEnum, false, -1);
  ComposeUri(this, 'Bundle.link', 'url', value.urlElement, false, -1);
end;

function TFHIRTurtleParser.ParseBundleEntry(obj : TTurtleComplex) : TFhirBundleEntry;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBundleEntry.create;
  try
    ParseBundleEntryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBundleEntryProperties(obj : TTurtleComplex; value : TFhirBundleEntry);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Bundle.entry.link') do
      value.link_List.Add(parseBundleLink(item));
    value.fullUrlElement := ParseUri(obj.complex('http://hl7.org/fhir/Bundle.entry.fullUrl'));
    value.resource := ParseInnerResource(obj.predicate('http://hl7.org/fhir/Bundle.entry.resource'));
    value.search := ParseBundleEntrySearch(obj.complex('http://hl7.org/fhir/Bundle.entry.search'));
    value.request := ParseBundleEntryRequest(obj.complex('http://hl7.org/fhir/Bundle.entry.request'));
    value.response := ParseBundleEntryResponse(obj.complex('http://hl7.org/fhir/Bundle.entry.response'));
end;

procedure TFHIRTurtleComposer.ComposeBundleEntry(parent :  TTurtleComplex; parentType, name : String; value : TFhirBundleEntry; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BundleEntry');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to value.link_List.Count - 1 do
      ComposeBundleLink(this, 'Bundle.entry', 'link', value.link_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'Bundle.entry', 'fullUrl', value.fullUrlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(this, 'Bundle.entry', 'resource', value.resourceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntrySearch(this, 'Bundle.entry', 'search', value.searchElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntryRequest(this, 'Bundle.entry', 'request', value.requestElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntryResponse(this, 'Bundle.entry', 'response', value.responseElement, false, -1);
end;

function TFHIRTurtleParser.ParseBundleEntrySearch(obj : TTurtleComplex) : TFhirBundleEntrySearch;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBundleEntrySearch.create;
  try
    ParseBundleEntrySearchProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBundleEntrySearchProperties(obj : TTurtleComplex; value : TFhirBundleEntrySearch);
begin
    ParseBackboneElementProperties(obj, value);
    value.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/Bundle.entry.search.mode'), CODES_TFhirSearchEntryModeEnum, SYSTEMS_TFhirSearchEntryModeEnum);
    value.scoreElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Bundle.entry.search.score'));
end;

procedure TFHIRTurtleComposer.ComposeBundleEntrySearch(parent :  TTurtleComplex; parentType, name : String; value : TFhirBundleEntrySearch; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BundleEntrySearch');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(this, 'Bundle.entry.search', 'mode', value.modeElement, CODES_TFhirSearchEntryModeEnum, SYSTEMS_TFhirSearchEntryModeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(this, 'Bundle.entry.search', 'score', value.scoreElement, false, -1);
end;

function TFHIRTurtleParser.ParseBundleEntryRequest(obj : TTurtleComplex) : TFhirBundleEntryRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBundleEntryRequest.create;
  try
    ParseBundleEntryRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBundleEntryRequestProperties(obj : TTurtleComplex; value : TFhirBundleEntryRequest);
begin
    ParseBackboneElementProperties(obj, value);
    value.methodElement := ParseEnum(obj.complex('http://hl7.org/fhir/Bundle.entry.request.method'), CODES_TFhirHTTPVerbEnum, SYSTEMS_TFhirHTTPVerbEnum);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Bundle.entry.request.url'));
    value.ifNoneMatchElement := ParseString(obj.complex('http://hl7.org/fhir/Bundle.entry.request.ifNoneMatch'));
    value.ifModifiedSinceElement := ParseInstant(obj.complex('http://hl7.org/fhir/Bundle.entry.request.ifModifiedSince'));
    value.ifMatchElement := ParseString(obj.complex('http://hl7.org/fhir/Bundle.entry.request.ifMatch'));
    value.ifNoneExistElement := ParseString(obj.complex('http://hl7.org/fhir/Bundle.entry.request.ifNoneExist'));
end;

procedure TFHIRTurtleComposer.ComposeBundleEntryRequest(parent :  TTurtleComplex; parentType, name : String; value : TFhirBundleEntryRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BundleEntryRequest');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'Bundle.entry.request', 'method', value.methodElement, CODES_TFhirHTTPVerbEnum, SYSTEMS_TFhirHTTPVerbEnum, false, -1);
  ComposeUri(this, 'Bundle.entry.request', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Bundle.entry.request', 'ifNoneMatch', value.ifNoneMatchElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(this, 'Bundle.entry.request', 'ifModifiedSince', value.ifModifiedSinceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Bundle.entry.request', 'ifMatch', value.ifMatchElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Bundle.entry.request', 'ifNoneExist', value.ifNoneExistElement, false, -1);
end;

function TFHIRTurtleParser.ParseBundleEntryResponse(obj : TTurtleComplex) : TFhirBundleEntryResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBundleEntryResponse.create;
  try
    ParseBundleEntryResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBundleEntryResponseProperties(obj : TTurtleComplex; value : TFhirBundleEntryResponse);
begin
    ParseBackboneElementProperties(obj, value);
    value.statusElement := ParseString(obj.complex('http://hl7.org/fhir/Bundle.entry.response.status'));
    value.locationElement := ParseUri(obj.complex('http://hl7.org/fhir/Bundle.entry.response.location'));
    value.etagElement := ParseString(obj.complex('http://hl7.org/fhir/Bundle.entry.response.etag'));
    value.lastModifiedElement := ParseInstant(obj.complex('http://hl7.org/fhir/Bundle.entry.response.lastModified'));
    value.outcome := ParseInnerResource(obj.predicate('http://hl7.org/fhir/Bundle.entry.response.outcome'));
end;

procedure TFHIRTurtleComposer.ComposeBundleEntryResponse(parent :  TTurtleComplex; parentType, name : String; value : TFhirBundleEntryResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BundleEntryResponse');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'Bundle.entry.response', 'status', value.statusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'Bundle.entry.response', 'location', value.locationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Bundle.entry.response', 'etag', value.etagElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(this, 'Bundle.entry.response', 'lastModified', value.lastModifiedElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(this, 'Bundle.entry.response', 'outcome', value.outcomeElement, false, -1);
end;

function TFHIRTurtleParser.ParseBundle(obj : TTurtleComplex) : TFhirBundle;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBundle.create;
  try
    ParseBundleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBundleProperties(obj : TTurtleComplex; value : TFhirBundle);
var
  item : TTurtleComplex;
begin
    ParseResourceProperties(obj, value);
    value.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Bundle.identifier'));
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Bundle.type'), CODES_TFhirBundleTypeEnum, SYSTEMS_TFhirBundleTypeEnum);
    value.timestampElement := ParseInstant(obj.complex('http://hl7.org/fhir/Bundle.timestamp'));
    value.totalElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Bundle.total'));
    for item in obj.complexes('http://hl7.org/fhir/Bundle.link') do
      value.link_List.Add(parseBundleLink(item));
    for item in obj.complexes('http://hl7.org/fhir/Bundle.entry') do
      value.entryList.Add(parseBundleEntry(item));
    value.signature := ParseSignature(obj.complex('http://hl7.org/fhir/Bundle.signature'));
    value.issues := ParseInnerResource(obj.predicate('http://hl7.org/fhir/Bundle.issues'));
end;

procedure TFHIRTurtleComposer.ComposeBundle(parent :  TTurtleComplex; parentType, name : String; value : TFhirBundle; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Bundle');
  end;
  composeResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdentifier(this, 'Bundle', 'identifier', value.identifierElement, false, -1);
  ComposeEnum(this, 'Bundle', 'type', value.type_Element, CODES_TFhirBundleTypeEnum, SYSTEMS_TFhirBundleTypeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(this, 'Bundle', 'timestamp', value.timestampElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData, soCount]) then
    ComposeUnsignedInt(this, 'Bundle', 'total', value.totalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to value.link_List.Count - 1 do
      ComposeBundleLink(this, 'Bundle', 'link', value.link_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to value.entryList.Count - 1 do
      ComposeBundleEntry(this, 'Bundle', 'entry', value.entryList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeSignature(this, 'Bundle', 'signature', value.signatureElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(this, 'Bundle', 'issues', value.issuesElement, false, -1);
end;

{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
function TFHIRTurtleParser.ParseCapabilityStatementSoftware(obj : TTurtleComplex) : TFhirCapabilityStatementSoftware;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementSoftware.create;
  try
    ParseCapabilityStatementSoftwareProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementSoftwareProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementSoftware);
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.software.name'));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.software.version'));
    value.releaseDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/CapabilityStatement.software.releaseDate'));
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementSoftware(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementSoftware; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementSoftware');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'CapabilityStatement.software', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'CapabilityStatement.software', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'CapabilityStatement.software', 'releaseDate', value.releaseDateElement, false, -1);
end;

function TFHIRTurtleParser.ParseCapabilityStatementImplementation(obj : TTurtleComplex) : TFhirCapabilityStatementImplementation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementImplementation.create;
  try
    ParseCapabilityStatementImplementationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementImplementationProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementImplementation);
begin
    ParseBackboneElementProperties(obj, value);
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.implementation.description'));
    value.urlElement := ParseUrl(obj.complex('http://hl7.org/fhir/CapabilityStatement.implementation.url'));
    value.custodian := ParseReference(obj.complex('http://hl7.org/fhir/CapabilityStatement.implementation.custodian'));
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementImplementation(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementImplementation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementImplementation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'CapabilityStatement.implementation', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrl(this, 'CapabilityStatement.implementation', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'CapabilityStatement.implementation', 'custodian', value.custodianElement, false, -1);
end;

function TFHIRTurtleParser.ParseCapabilityStatementRest(obj : TTurtleComplex) : TFhirCapabilityStatementRest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementRest.create;
  try
    ParseCapabilityStatementRestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementRestProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementRest);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.mode'), CODES_TFhirRestfulCapabilityModeEnum, SYSTEMS_TFhirRestfulCapabilityModeEnum);
    value.documentationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.documentation'));
    value.security := ParseCapabilityStatementRestSecurity(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.security'));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.resource') do
      value.resourceList.Add(parseCapabilityStatementRestResource(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.interaction') do
      value.interactionList.Add(parseCapabilityStatementRestInteraction(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.searchParam') do
      value.searchParamList.Add(parseCapabilityStatementRestResourceSearchParam(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.operation') do
      value.operationList.Add(parseCapabilityStatementRestResourceOperation(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.compartment') do
      value.compartmentList.Add(parseCanonical(item));
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementRest(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementRest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementRest');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'CapabilityStatement.rest', 'mode', value.modeElement, CODES_TFhirRestfulCapabilityModeEnum, SYSTEMS_TFhirRestfulCapabilityModeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CapabilityStatement.rest', 'documentation', value.documentationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCapabilityStatementRestSecurity(this, 'CapabilityStatement.rest', 'security', value.securityElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.resourceList.Count - 1 do
      ComposeCapabilityStatementRestResource(this, 'CapabilityStatement.rest', 'resource', value.resourceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.interactionList.Count - 1 do
      ComposeCapabilityStatementRestInteraction(this, 'CapabilityStatement.rest', 'interaction', value.interactionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.searchParamList.Count - 1 do
      ComposeCapabilityStatementRestResourceSearchParam(this, 'CapabilityStatement.rest', 'searchParam', value.searchParamList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.operationList.Count - 1 do
      ComposeCapabilityStatementRestResourceOperation(this, 'CapabilityStatement.rest', 'operation', value.operationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.compartmentList.Count - 1 do
      ComposeCanonical(this, 'CapabilityStatement.rest', 'compartment', value.compartmentList[i], false, i);
end;

function TFHIRTurtleParser.ParseCapabilityStatementRestSecurity(obj : TTurtleComplex) : TFhirCapabilityStatementRestSecurity;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementRestSecurity.create;
  try
    ParseCapabilityStatementRestSecurityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementRestSecurityProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementRestSecurity);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.corsElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.security.cors'));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.security.service') do
      value.serviceList.Add(parseCodeableConcept(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.security.description'));
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementRestSecurity(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementRestSecurity; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementRestSecurity');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'CapabilityStatement.rest.security', 'cors', value.corsElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.serviceList.Count - 1 do
      ComposeCodeableConcept(this, 'CapabilityStatement.rest.security', 'service', value.serviceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CapabilityStatement.rest.security', 'description', value.descriptionElement, false, -1);
end;

function TFHIRTurtleParser.ParseCapabilityStatementRestResource(obj : TTurtleComplex) : TFhirCapabilityStatementRestResource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementRestResource.create;
  try
    ParseCapabilityStatementRestResourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementRestResourceProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementRestResource);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.type'), CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    value.profileElement := ParseCanonical(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.profile'));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.resource.supportedProfile') do
      value.supportedProfileList.Add(parseCanonical(item));
    value.documentationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.documentation'));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.resource.interaction') do
      value.interactionList.Add(parseCapabilityStatementRestResourceInteraction(item));
    value.versioningElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.versioning'), CODES_TFhirResourceVersionPolicyEnum, SYSTEMS_TFhirResourceVersionPolicyEnum);
    value.readHistoryElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.readHistory'));
    value.updateCreateElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.updateCreate'));
    value.conditionalCreateElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.conditionalCreate'));
    value.conditionalReadElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.conditionalRead'), CODES_TFhirConditionalReadStatusEnum, SYSTEMS_TFhirConditionalReadStatusEnum);
    value.conditionalUpdateElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.conditionalUpdate'));
    value.conditionalPatchElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.conditionalPatch'));
    value.conditionalDeleteElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.conditionalDelete'), CODES_TFhirConditionalDeleteStatusEnum, SYSTEMS_TFhirConditionalDeleteStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.resource.referencePolicy') do
      value.referencePolicyList.Add(parseEnum(item, CODES_TFhirReferenceHandlingPolicyEnum, SYSTEMS_TFhirReferenceHandlingPolicyEnum));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.resource.searchInclude') do
      value.searchIncludeList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.resource.searchRevInclude') do
      value.searchRevIncludeList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.resource.searchParam') do
      value.searchParamList.Add(parseCapabilityStatementRestResourceSearchParam(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.resource.operation') do
      value.operationList.Add(parseCapabilityStatementRestResourceOperation(item));
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementRestResource(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementRestResource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementRestResource');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'CapabilityStatement.rest.resource', 'type', value.type_Element, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(this, 'CapabilityStatement.rest.resource', 'profile', value.profileElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.supportedProfileList.Count - 1 do
      ComposeCanonical(this, 'CapabilityStatement.rest.resource', 'supportedProfile', value.supportedProfileList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CapabilityStatement.rest.resource', 'documentation', value.documentationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.interactionList.Count - 1 do
      ComposeCapabilityStatementRestResourceInteraction(this, 'CapabilityStatement.rest.resource', 'interaction', value.interactionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'CapabilityStatement.rest.resource', 'versioning', value.versioningElement, CODES_TFhirResourceVersionPolicyEnum, SYSTEMS_TFhirResourceVersionPolicyEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CapabilityStatement.rest.resource', 'readHistory', value.readHistoryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CapabilityStatement.rest.resource', 'updateCreate', value.updateCreateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CapabilityStatement.rest.resource', 'conditionalCreate', value.conditionalCreateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'CapabilityStatement.rest.resource', 'conditionalRead', value.conditionalReadElement, CODES_TFhirConditionalReadStatusEnum, SYSTEMS_TFhirConditionalReadStatusEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CapabilityStatement.rest.resource', 'conditionalUpdate', value.conditionalUpdateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CapabilityStatement.rest.resource', 'conditionalPatch', value.conditionalPatchElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'CapabilityStatement.rest.resource', 'conditionalDelete', value.conditionalDeleteElement, CODES_TFhirConditionalDeleteStatusEnum, SYSTEMS_TFhirConditionalDeleteStatusEnum, false, -1);
  for i := 0 to value.referencePolicyList.Count - 1 do
      ComposeEnum(this, 'CapabilityStatement.rest.resource', 'referencePolicy', value.referencePolicyList[i], CODES_TFhirReferenceHandlingPolicyEnum, SYSTEMS_TFhirReferenceHandlingPolicyEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.referencePolicyList.Count - 1 do
      ComposeEnum(this, 'CapabilityStatement.rest.resource', 'referencePolicy', value.referencePolicyList[i], CODES_TFhirReferenceHandlingPolicyEnum, SYSTEMS_TFhirReferenceHandlingPolicyEnum, false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.searchIncludeList.Count - 1 do
      ComposeString(this, 'CapabilityStatement.rest.resource', 'searchInclude', value.searchIncludeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.searchRevIncludeList.Count - 1 do
      ComposeString(this, 'CapabilityStatement.rest.resource', 'searchRevInclude', value.searchRevIncludeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.searchParamList.Count - 1 do
      ComposeCapabilityStatementRestResourceSearchParam(this, 'CapabilityStatement.rest.resource', 'searchParam', value.searchParamList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.operationList.Count - 1 do
      ComposeCapabilityStatementRestResourceOperation(this, 'CapabilityStatement.rest.resource', 'operation', value.operationList[i], false, i);
end;

function TFHIRTurtleParser.ParseCapabilityStatementRestResourceInteraction(obj : TTurtleComplex) : TFhirCapabilityStatementRestResourceInteraction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementRestResourceInteraction.create;
  try
    ParseCapabilityStatementRestResourceInteractionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementRestResourceInteractionProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementRestResourceInteraction);
begin
    ParseBackboneElementProperties(obj, value);
    value.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.interaction.code'), CODES_TFhirTypeRestfulInteractionEnum, SYSTEMS_TFhirTypeRestfulInteractionEnum);
    value.documentationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.interaction.documentation'));
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementRestResourceInteraction(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementRestResourceInteraction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementRestResourceInteraction');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'CapabilityStatement.rest.resource.interaction', 'code', value.codeElement, CODES_TFhirTypeRestfulInteractionEnum, SYSTEMS_TFhirTypeRestfulInteractionEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CapabilityStatement.rest.resource.interaction', 'documentation', value.documentationElement, false, -1);
end;

function TFHIRTurtleParser.ParseCapabilityStatementRestResourceSearchParam(obj : TTurtleComplex) : TFhirCapabilityStatementRestResourceSearchParam;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementRestResourceSearchParam.create;
  try
    ParseCapabilityStatementRestResourceSearchParamProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementRestResourceSearchParamProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementRestResourceSearchParam);
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.searchParam.name'));
    value.definitionElement := ParseCanonical(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.searchParam.definition'));
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.searchParam.type'), CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum);
    value.documentationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.searchParam.documentation'));
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementRestResourceSearchParam(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementRestResourceSearchParam; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementRestResourceSearchParam');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'CapabilityStatement.rest.resource.searchParam', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'CapabilityStatement.rest.resource.searchParam', 'definition', value.definitionElement, false, -1);
  ComposeEnum(this, 'CapabilityStatement.rest.resource.searchParam', 'type', value.type_Element, CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CapabilityStatement.rest.resource.searchParam', 'documentation', value.documentationElement, false, -1);
end;

function TFHIRTurtleParser.ParseCapabilityStatementRestResourceOperation(obj : TTurtleComplex) : TFhirCapabilityStatementRestResourceOperation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementRestResourceOperation.create;
  try
    ParseCapabilityStatementRestResourceOperationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementRestResourceOperationProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementRestResourceOperation);
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.operation.name'));
    value.definitionElement := ParseCanonical(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.operation.definition'));
    value.documentationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.operation.documentation'));
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementRestResourceOperation(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementRestResourceOperation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementRestResourceOperation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'CapabilityStatement.rest.resource.operation', 'name', value.nameElement, false, -1);
  ComposeCanonical(this, 'CapabilityStatement.rest.resource.operation', 'definition', value.definitionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CapabilityStatement.rest.resource.operation', 'documentation', value.documentationElement, false, -1);
end;

function TFHIRTurtleParser.ParseCapabilityStatementRestInteraction(obj : TTurtleComplex) : TFhirCapabilityStatementRestInteraction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementRestInteraction.create;
  try
    ParseCapabilityStatementRestInteractionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementRestInteractionProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementRestInteraction);
begin
    ParseBackboneElementProperties(obj, value);
    value.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.interaction.code'), CODES_TFhirSystemRestfulInteractionEnum, SYSTEMS_TFhirSystemRestfulInteractionEnum);
    value.documentationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.interaction.documentation'));
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementRestInteraction(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementRestInteraction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementRestInteraction');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'CapabilityStatement.rest.interaction', 'code', value.codeElement, CODES_TFhirSystemRestfulInteractionEnum, SYSTEMS_TFhirSystemRestfulInteractionEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CapabilityStatement.rest.interaction', 'documentation', value.documentationElement, false, -1);
end;

function TFHIRTurtleParser.ParseCapabilityStatementMessaging(obj : TTurtleComplex) : TFhirCapabilityStatementMessaging;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementMessaging.create;
  try
    ParseCapabilityStatementMessagingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementMessagingProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementMessaging);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.messaging.endpoint') do
      value.endpointList.Add(parseCapabilityStatementMessagingEndpoint(item));
    value.reliableCacheElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/CapabilityStatement.messaging.reliableCache'));
    value.documentationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.messaging.documentation'));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.messaging.supportedMessage') do
      value.supportedMessageList.Add(parseCapabilityStatementMessagingSupportedMessage(item));
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementMessaging(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementMessaging; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementMessaging');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endpointList.Count - 1 do
      ComposeCapabilityStatementMessagingEndpoint(this, 'CapabilityStatement.messaging', 'endpoint', value.endpointList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(this, 'CapabilityStatement.messaging', 'reliableCache', value.reliableCacheElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CapabilityStatement.messaging', 'documentation', value.documentationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.supportedMessageList.Count - 1 do
      ComposeCapabilityStatementMessagingSupportedMessage(this, 'CapabilityStatement.messaging', 'supportedMessage', value.supportedMessageList[i], false, i);
end;

function TFHIRTurtleParser.ParseCapabilityStatementMessagingEndpoint(obj : TTurtleComplex) : TFhirCapabilityStatementMessagingEndpoint;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementMessagingEndpoint.create;
  try
    ParseCapabilityStatementMessagingEndpointProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementMessagingEndpointProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementMessagingEndpoint);
begin
    ParseBackboneElementProperties(obj, value);
    value.protocol := ParseCoding(obj.complex('http://hl7.org/fhir/CapabilityStatement.messaging.endpoint.protocol'));
    value.addressElement := ParseUrl(obj.complex('http://hl7.org/fhir/CapabilityStatement.messaging.endpoint.address'));
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementMessagingEndpoint(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementMessagingEndpoint; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementMessagingEndpoint');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCoding(this, 'CapabilityStatement.messaging.endpoint', 'protocol', value.protocolElement, false, -1);
  ComposeUrl(this, 'CapabilityStatement.messaging.endpoint', 'address', value.addressElement, false, -1);
end;

function TFHIRTurtleParser.ParseCapabilityStatementMessagingSupportedMessage(obj : TTurtleComplex) : TFhirCapabilityStatementMessagingSupportedMessage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementMessagingSupportedMessage.create;
  try
    ParseCapabilityStatementMessagingSupportedMessageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementMessagingSupportedMessageProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementMessagingSupportedMessage);
begin
    ParseBackboneElementProperties(obj, value);
    value.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.messaging.supportedMessage.mode'), CODES_TFhirEventCapabilityModeEnum, SYSTEMS_TFhirEventCapabilityModeEnum);
    value.definitionElement := ParseCanonical(obj.complex('http://hl7.org/fhir/CapabilityStatement.messaging.supportedMessage.definition'));
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementMessagingSupportedMessage(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementMessagingSupportedMessage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementMessagingSupportedMessage');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'CapabilityStatement.messaging.supportedMessage', 'mode', value.modeElement, CODES_TFhirEventCapabilityModeEnum, SYSTEMS_TFhirEventCapabilityModeEnum, false, -1);
  ComposeCanonical(this, 'CapabilityStatement.messaging.supportedMessage', 'definition', value.definitionElement, false, -1);
end;

function TFHIRTurtleParser.ParseCapabilityStatementDocument(obj : TTurtleComplex) : TFhirCapabilityStatementDocument;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementDocument.create;
  try
    ParseCapabilityStatementDocumentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementDocumentProperties(obj : TTurtleComplex; value : TFhirCapabilityStatementDocument);
begin
    ParseBackboneElementProperties(obj, value);
    value.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.document.mode'), CODES_TFhirDocumentModeEnum, SYSTEMS_TFhirDocumentModeEnum);
    value.documentationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.document.documentation'));
    value.profileElement := ParseCanonical(obj.complex('http://hl7.org/fhir/CapabilityStatement.document.profile'));
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementDocument(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatementDocument; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementDocument');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'CapabilityStatement.document', 'mode', value.modeElement, CODES_TFhirDocumentModeEnum, SYSTEMS_TFhirDocumentModeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CapabilityStatement.document', 'documentation', value.documentationElement, false, -1);
  ComposeCanonical(this, 'CapabilityStatement.document', 'profile', value.profileElement, false, -1);
end;

function TFHIRTurtleParser.ParseCapabilityStatement(obj : TTurtleComplex) : TFhirCapabilityStatement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatement.create;
  try
    ParseCapabilityStatementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementProperties(obj : TTurtleComplex; value : TFhirCapabilityStatement);
var
  item : TTurtleComplex;
begin
    ParseCanonicalResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/CapabilityStatement.url'));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.version'));
    if obj.has('versionAlgorithmCoding', item) then
      value.versionAlgorithm := parseCoding(item);
    if obj.has('versionAlgorithmString', item) then
      value.versionAlgorithm := parseString(item);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.title'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CapabilityStatement.experimental'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/CapabilityStatement.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.description'));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.purpose'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.copyright'));
    value.copyrightLabelElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.copyrightLabel'));
    value.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.kind'), CODES_TFhirCapabilityStatementKindEnum, SYSTEMS_TFhirCapabilityStatementKindEnum);
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.instantiates') do
      value.instantiatesList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.imports') do
      value.importsList.Add(parseCanonical(item));
    value.software := ParseCapabilityStatementSoftware(obj.complex('http://hl7.org/fhir/CapabilityStatement.software'));
    value.implementation_ := ParseCapabilityStatementImplementation(obj.complex('http://hl7.org/fhir/CapabilityStatement.implementation'));
    value.fhirVersionElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.fhirVersion'), CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum);
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.format') do
      value.formatList.Add(parseCode(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.patchFormat') do
      value.patchFormatList.Add(parseCode(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.acceptLanguage') do
      value.acceptLanguageList.Add(parseCode(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.implementationGuide') do
      value.implementationGuideList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest') do
      value.restList.Add(parseCapabilityStatementRest(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.messaging') do
      value.messagingList.Add(parseCapabilityStatementMessaging(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.document') do
      value.documentList.Add(parseCapabilityStatementDocument(item));
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatement(parent :  TTurtleComplex; parentType, name : String; value : TFhirCapabilityStatement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatement');
  end;
  composeCanonicalResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'CapabilityStatement', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'CapabilityStatement', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirCoding) {6} then
    ComposeCoding(this, 'CapabilityStatement', 'versionAlgorithmCoding', TFhirCoding(value.versionAlgorithm), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirString) {6} then
    ComposeString(this, 'CapabilityStatement', 'versionAlgorithmString', TFhirString(value.versionAlgorithm), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'CapabilityStatement', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'CapabilityStatement', 'title', value.titleElement, false, -1);
  ComposeEnum(this, 'CapabilityStatement', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'CapabilityStatement', 'experimental', value.experimentalElement, false, -1);
  ComposeDateTime(this, 'CapabilityStatement', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'CapabilityStatement', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'CapabilityStatement', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CapabilityStatement', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'CapabilityStatement', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'CapabilityStatement', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CapabilityStatement', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CapabilityStatement', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CapabilityStatement', 'copyrightLabel', value.copyrightLabelElement, false, -1);
  ComposeEnum(this, 'CapabilityStatement', 'kind', value.kindElement, CODES_TFhirCapabilityStatementKindEnum, SYSTEMS_TFhirCapabilityStatementKindEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesList.Count - 1 do
      ComposeCanonical(this, 'CapabilityStatement', 'instantiates', value.instantiatesList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.importsList.Count - 1 do
      ComposeCanonical(this, 'CapabilityStatement', 'imports', value.importsList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCapabilityStatementSoftware(this, 'CapabilityStatement', 'software', value.softwareElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCapabilityStatementImplementation(this, 'CapabilityStatement', 'implementation', value.implementation_Element, false, -1);
  ComposeEnum(this, 'CapabilityStatement', 'fhirVersion', value.fhirVersionElement, CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum, false, -1);
  for i := 0 to value.formatList.Count - 1 do
      ComposeCode(this, 'CapabilityStatement', 'format', value.formatList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.patchFormatList.Count - 1 do
      ComposeCode(this, 'CapabilityStatement', 'patchFormat', value.patchFormatList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.acceptLanguageList.Count - 1 do
      ComposeCode(this, 'CapabilityStatement', 'acceptLanguage', value.acceptLanguageList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.implementationGuideList.Count - 1 do
      ComposeCanonical(this, 'CapabilityStatement', 'implementationGuide', value.implementationGuideList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.restList.Count - 1 do
      ComposeCapabilityStatementRest(this, 'CapabilityStatement', 'rest', value.restList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.messagingList.Count - 1 do
      ComposeCapabilityStatementMessaging(this, 'CapabilityStatement', 'messaging', value.messagingList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.documentList.Count - 1 do
      ComposeCapabilityStatementDocument(this, 'CapabilityStatement', 'document', value.documentList[i], false, i);
end;

{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
function TFHIRTurtleParser.ParseCarePlanActivity(obj : TTurtleComplex) : TFhirCarePlanActivity;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCarePlanActivity.create;
  try
    ParseCarePlanActivityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCarePlanActivityProperties(obj : TTurtleComplex; value : TFhirCarePlanActivity);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.performedActivity') do
      value.performedActivityList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.progress') do
      value.progressList.Add(parseAnnotation(item));
    value.plannedActivityReference := ParseReference(obj.complex('http://hl7.org/fhir/CarePlan.activity.plannedActivityReference'));
    value.plannedActivityDetail := ParseCarePlanActivityPlannedActivityDetail(obj.complex('http://hl7.org/fhir/CarePlan.activity.plannedActivityDetail'));
end;

procedure TFHIRTurtleComposer.ComposeCarePlanActivity(parent :  TTurtleComplex; parentType, name : String; value : TFhirCarePlanActivity; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CarePlanActivity');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.performedActivityList.Count - 1 do
      ComposeCodeableReference(this, 'CarePlan.activity', 'performedActivity', value.performedActivityList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.progressList.Count - 1 do
      ComposeAnnotation(this, 'CarePlan.activity', 'progress', value.progressList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'CarePlan.activity', 'plannedActivityReference', value.plannedActivityReferenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCarePlanActivityPlannedActivityDetail(this, 'CarePlan.activity', 'plannedActivityDetail', value.plannedActivityDetailElement, false, -1);
end;

function TFHIRTurtleParser.ParseCarePlanActivityPlannedActivityDetail(obj : TTurtleComplex) : TFhirCarePlanActivityPlannedActivityDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCarePlanActivityPlannedActivityDetail.create;
  try
    ParseCarePlanActivityPlannedActivityDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCarePlanActivityPlannedActivityDetailProperties(obj : TTurtleComplex; value : TFhirCarePlanActivityPlannedActivityDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/CarePlan.activity.plannedActivityDetail.kind'), CODES_TFhirCarePlanActivityKindEnum, SYSTEMS_TFhirCarePlanActivityKindEnum);
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.plannedActivityDetail.instantiatesCanonical') do
      value.instantiatesCanonicalList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.plannedActivityDetail.instantiatesUri') do
      value.instantiatesUriList.Add(parseUri(item));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CarePlan.activity.plannedActivityDetail.code'));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.plannedActivityDetail.reason') do
      value.reasonList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.plannedActivityDetail.goal') do
      value.goalList.Add(parseReference(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CarePlan.activity.plannedActivityDetail.status'), CODES_TFhirCarePlanActivityStatusEnum, SYSTEMS_TFhirCarePlanActivityStatusEnum);
    value.statusReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CarePlan.activity.plannedActivityDetail.statusReason'));
    value.doNotPerformElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CarePlan.activity.plannedActivityDetail.doNotPerform'));
    if obj.has('scheduledTiming', item) then
      value.scheduled := parseTiming(item);
    if obj.has('scheduledPeriod', item) then
      value.scheduled := parsePeriod(item);
    if obj.has('scheduledString', item) then
      value.scheduled := parseString(item);
    value.location := ParseCodeableReference(obj.complex('http://hl7.org/fhir/CarePlan.activity.plannedActivityDetail.location'));
    if obj.has('reportedReference', item) {a3} then
      value.reported := ParseReference(item);
    if obj.has('reportedBoolean', item) then
      value.reported := parseBoolean(item);
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.plannedActivityDetail.performer') do
      value.performerList.Add(parseReference(item));
    if obj.has('productCodeableConcept', item) then
      value.product := parseCodeableConcept(item);
    if obj.has('productReference', item) {a3} then
      value.product := ParseReference(item);
    value.dailyAmount := ParseQuantity(obj.complex('http://hl7.org/fhir/CarePlan.activity.plannedActivityDetail.dailyAmount'));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/CarePlan.activity.plannedActivityDetail.quantity'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/CarePlan.activity.plannedActivityDetail.description'));
end;

procedure TFHIRTurtleComposer.ComposeCarePlanActivityPlannedActivityDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirCarePlanActivityPlannedActivityDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CarePlanActivityPlannedActivityDetail');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'CarePlan.activity.plannedActivityDetail', 'kind', value.kindElement, CODES_TFhirCarePlanActivityKindEnum, SYSTEMS_TFhirCarePlanActivityKindEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(this, 'CarePlan.activity.plannedActivityDetail', 'instantiatesCanonical', value.instantiatesCanonicalList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.instantiatesUriList.Count - 1 do
      ComposeUri(this, 'CarePlan.activity.plannedActivityDetail', 'instantiatesUri', value.instantiatesUriList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CarePlan.activity.plannedActivityDetail', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(this, 'CarePlan.activity.plannedActivityDetail', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.goalList.Count - 1 do
      ComposeReference(this, 'CarePlan.activity.plannedActivityDetail', 'goal', value.goalList[i], false, i);
  ComposeEnum(this, 'CarePlan.activity.plannedActivityDetail', 'status', value.statusElement, CODES_TFhirCarePlanActivityStatusEnum, SYSTEMS_TFhirCarePlanActivityStatusEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CarePlan.activity.plannedActivityDetail', 'statusReason', value.statusReasonElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CarePlan.activity.plannedActivityDetail', 'doNotPerform', value.doNotPerformElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.scheduled is TFhirTiming) {6} then
    ComposeTiming(this, 'CarePlan.activity.plannedActivityDetail', 'scheduledTiming', TFhirTiming(value.scheduled), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.scheduled is TFhirPeriod) {6} then
    ComposePeriod(this, 'CarePlan.activity.plannedActivityDetail', 'scheduledPeriod', TFhirPeriod(value.scheduled), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.scheduled is TFhirString) {6} then
    ComposeString(this, 'CarePlan.activity.plannedActivityDetail', 'scheduledString', TFhirString(value.scheduled), false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(this, 'CarePlan.activity.plannedActivityDetail', 'location', value.locationElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.reported is TFhirReference) {2} then
    ComposeReference(this, 'CarePlan.activity.plannedActivityDetail', 'reportedReference', TFhirReference(value.reported), false,-1)
  else if (SummaryOption in [soFull, soData]) and (value.reported is TFhirBoolean) {6} then
    ComposeBoolean(this, 'CarePlan.activity.plannedActivityDetail', 'reportedBoolean', TFhirBoolean(value.reported), false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeReference(this, 'CarePlan.activity.plannedActivityDetail', 'performer', value.performerList[i], false, i);
  if (SummaryOption in [soFull, soData]) and (value.product is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'CarePlan.activity.plannedActivityDetail', 'productCodeableConcept', TFhirCodeableConcept(value.product), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.product is TFhirReference) {2} then
    ComposeReference(this, 'CarePlan.activity.plannedActivityDetail', 'productReference', TFhirReference(value.product), false,-1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'CarePlan.activity.plannedActivityDetail', 'dailyAmount', value.dailyAmountElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'CarePlan.activity.plannedActivityDetail', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CarePlan.activity.plannedActivityDetail', 'description', value.descriptionElement, false, -1);
end;

function TFHIRTurtleParser.ParseCarePlan(obj : TTurtleComplex) : TFhirCarePlan;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCarePlan.create;
  try
    ParseCarePlanProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCarePlanProperties(obj : TTurtleComplex; value : TFhirCarePlan);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.instantiatesCanonical') do
      value.instantiatesCanonicalList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.instantiatesUri') do
      value.instantiatesUriList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.basedOn') do
      value.basedOnList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.replaces') do
      value.replacesList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.partOf') do
      value.partOfList.Add(parseReference(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CarePlan.status'), CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum);
    value.intentElement := ParseEnum(obj.complex('http://hl7.org/fhir/CarePlan.intent'), CODES_TFhirCarePlanIntentEnum, SYSTEMS_TFhirCarePlanIntentEnum);
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/CarePlan.title'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/CarePlan.description'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/CarePlan.subject'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/CarePlan.encounter'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/CarePlan.period'));
    value.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/CarePlan.created'));
    value.custodian := ParseReference(obj.complex('http://hl7.org/fhir/CarePlan.custodian'));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.contributor') do
      value.contributorList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.careTeam') do
      value.careTeamList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.addresses') do
      value.addressesList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.supportingInfo') do
      value.supportingInfoList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.goal') do
      value.goalList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity') do
      value.activityList.Add(parseCarePlanActivity(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.note') do
      value.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeCarePlan(parent :  TTurtleComplex; parentType, name : String; value : TFhirCarePlan; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CarePlan');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'CarePlan', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(this, 'CarePlan', 'instantiatesCanonical', value.instantiatesCanonicalList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesUriList.Count - 1 do
      ComposeUri(this, 'CarePlan', 'instantiatesUri', value.instantiatesUriList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'CarePlan', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.replacesList.Count - 1 do
      ComposeReference(this, 'CarePlan', 'replaces', value.replacesList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(this, 'CarePlan', 'partOf', value.partOfList[i], false, i);
  ComposeEnum(this, 'CarePlan', 'status', value.statusElement, CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, false, -1);
  ComposeEnum(this, 'CarePlan', 'intent', value.intentElement, CODES_TFhirCarePlanIntentEnum, SYSTEMS_TFhirCarePlanIntentEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'CarePlan', 'category', value.categoryList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'CarePlan', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'CarePlan', 'description', value.descriptionElement, false, -1);
  ComposeReference(this, 'CarePlan', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'CarePlan', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'CarePlan', 'period', value.periodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'CarePlan', 'created', value.createdElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'CarePlan', 'custodian', value.custodianElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contributorList.Count - 1 do
      ComposeReference(this, 'CarePlan', 'contributor', value.contributorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.careTeamList.Count - 1 do
      ComposeReference(this, 'CarePlan', 'careTeam', value.careTeamList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.addressesList.Count - 1 do
      ComposeCodeableReference(this, 'CarePlan', 'addresses', value.addressesList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInfoList.Count - 1 do
      ComposeReference(this, 'CarePlan', 'supportingInfo', value.supportingInfoList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.goalList.Count - 1 do
      ComposeReference(this, 'CarePlan', 'goal', value.goalList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.activityList.Count - 1 do
      ComposeCarePlanActivity(this, 'CarePlan', 'activity', value.activityList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'CarePlan', 'note', value.noteList[i], false, i);
end;

{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
function TFHIRTurtleParser.ParseCareTeamParticipant(obj : TTurtleComplex) : TFhirCareTeamParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCareTeamParticipant.create;
  try
    ParseCareTeamParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCareTeamParticipantProperties(obj : TTurtleComplex; value : TFhirCareTeamParticipant);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CareTeam.participant.role'));
    value.member := ParseReference(obj.complex('http://hl7.org/fhir/CareTeam.participant.member'));
    value.onBehalfOf := ParseReference(obj.complex('http://hl7.org/fhir/CareTeam.participant.onBehalfOf'));
    if obj.has('coveragePeriod', item) then
      value.coverage := parsePeriod(item);
    if obj.has('coverageTiming', item) then
      value.coverage := parseTiming(item);
end;

procedure TFHIRTurtleComposer.ComposeCareTeamParticipant(parent :  TTurtleComplex; parentType, name : String; value : TFhirCareTeamParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CareTeamParticipant');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'CareTeam.participant', 'role', value.roleElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'CareTeam.participant', 'member', value.memberElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'CareTeam.participant', 'onBehalfOf', value.onBehalfOfElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.coverage is TFhirPeriod) {6} then
    ComposePeriod(this, 'CareTeam.participant', 'coveragePeriod', TFhirPeriod(value.coverage), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.coverage is TFhirTiming) {6} then
    ComposeTiming(this, 'CareTeam.participant', 'coverageTiming', TFhirTiming(value.coverage), false, -1);
end;

function TFHIRTurtleParser.ParseCareTeam(obj : TTurtleComplex) : TFhirCareTeam;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCareTeam.create;
  try
    ParseCareTeamProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCareTeamProperties(obj : TTurtleComplex; value : TFhirCareTeam);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/CareTeam.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CareTeam.status'), CODES_TFhirCareTeamStatusEnum, SYSTEMS_TFhirCareTeamStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/CareTeam.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/CareTeam.name'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/CareTeam.subject'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/CareTeam.period'));
    for item in obj.complexes('http://hl7.org/fhir/CareTeam.participant') do
      value.participantList.Add(parseCareTeamParticipant(item));
    for item in obj.complexes('http://hl7.org/fhir/CareTeam.reason') do
      value.reasonList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/CareTeam.managingOrganization') do
      value.managingOrganizationList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/CareTeam.telecom') do
      value.telecomList.Add(parseContactPoint(item));
    for item in obj.complexes('http://hl7.org/fhir/CareTeam.note') do
      value.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeCareTeam(parent :  TTurtleComplex; parentType, name : String; value : TFhirCareTeam; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CareTeam');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'CareTeam', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'CareTeam', 'status', value.statusElement, CODES_TFhirCareTeamStatusEnum, SYSTEMS_TFhirCareTeamStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'CareTeam', 'category', value.categoryList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'CareTeam', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'CareTeam', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'CareTeam', 'period', value.periodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.participantList.Count - 1 do
      ComposeCareTeamParticipant(this, 'CareTeam', 'participant', value.participantList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(this, 'CareTeam', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.managingOrganizationList.Count - 1 do
      ComposeReference(this, 'CareTeam', 'managingOrganization', value.managingOrganizationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.telecomList.Count - 1 do
      ComposeContactPoint(this, 'CareTeam', 'telecom', value.telecomList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'CareTeam', 'note', value.noteList[i], false, i);
end;

{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CHARGEITEM}
function TFHIRTurtleParser.ParseChargeItemPerformer(obj : TTurtleComplex) : TFhirChargeItemPerformer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirChargeItemPerformer.create;
  try
    ParseChargeItemPerformerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseChargeItemPerformerProperties(obj : TTurtleComplex; value : TFhirChargeItemPerformer);
begin
    ParseBackboneElementProperties(obj, value);
    value.function_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ChargeItem.performer.function'));
    value.actor := ParseReference(obj.complex('http://hl7.org/fhir/ChargeItem.performer.actor'));
end;

procedure TFHIRTurtleComposer.ComposeChargeItemPerformer(parent :  TTurtleComplex; parentType, name : String; value : TFhirChargeItemPerformer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ChargeItemPerformer');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ChargeItem.performer', 'function', value.function_Element, false, -1);
  ComposeReference(this, 'ChargeItem.performer', 'actor', value.actorElement, false, -1);
end;

function TFHIRTurtleParser.ParseChargeItem(obj : TTurtleComplex) : TFhirChargeItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirChargeItem.create;
  try
    ParseChargeItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseChargeItemProperties(obj : TTurtleComplex; value : TFhirChargeItem);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.definitionUri') do
      value.definitionUriList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.definitionCanonical') do
      value.definitionCanonicalList.Add(parseCanonical(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ChargeItem.status'), CODES_TFhirChargeItemStatusEnum, SYSTEMS_TFhirChargeItemStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.partOf') do
      value.partOfList.Add(parseReference(item));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ChargeItem.code'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/ChargeItem.subject'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/ChargeItem.encounter'));
    if obj.has('occurrencePeriod', item) then
      value.occurrence := parsePeriod(item);
    if obj.has('occurrenceTiming', item) then
      value.occurrence := parseTiming(item);
    if obj.has('occurrenceDateTime', item) then
      value.occurrence := parseDateTime(item);
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.performer') do
      value.performerList.Add(parseChargeItemPerformer(item));
    value.performingOrganization := ParseReference(obj.complex('http://hl7.org/fhir/ChargeItem.performingOrganization'));
    value.requestingOrganization := ParseReference(obj.complex('http://hl7.org/fhir/ChargeItem.requestingOrganization'));
    value.costCenter := ParseReference(obj.complex('http://hl7.org/fhir/ChargeItem.costCenter'));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ChargeItem.quantity'));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.bodysite') do
      value.bodysiteList.Add(parseCodeableConcept(item));
    value.unitPriceComponent := ParseMonetaryComponent(obj.complex('http://hl7.org/fhir/ChargeItem.unitPriceComponent'));
    value.totalPriceComponent := ParseMonetaryComponent(obj.complex('http://hl7.org/fhir/ChargeItem.totalPriceComponent'));
    value.overrideReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ChargeItem.overrideReason'));
    value.enterer := ParseReference(obj.complex('http://hl7.org/fhir/ChargeItem.enterer'));
    value.enteredDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ChargeItem.enteredDate'));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.reason') do
      value.reasonList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.service') do
      value.serviceList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.product') do
      value.productList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.account') do
      value.accountList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.supportingInformation') do
      value.supportingInformationList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeChargeItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirChargeItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ChargeItem');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ChargeItem', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.definitionUriList.Count - 1 do
      ComposeUri(this, 'ChargeItem', 'definitionUri', value.definitionUriList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.definitionCanonicalList.Count - 1 do
      ComposeCanonical(this, 'ChargeItem', 'definitionCanonical', value.definitionCanonicalList[i], false, i);
  ComposeEnum(this, 'ChargeItem', 'status', value.statusElement, CODES_TFhirChargeItemStatusEnum, SYSTEMS_TFhirChargeItemStatusEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(this, 'ChargeItem', 'partOf', value.partOfList[i], false, i);
  ComposeCodeableConcept(this, 'ChargeItem', 'code', value.codeElement, false, -1);
  ComposeReference(this, 'ChargeItem', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'ChargeItem', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'ChargeItem', 'occurrencePeriod', TFhirPeriod(value.occurrence), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirTiming) {6} then
    ComposeTiming(this, 'ChargeItem', 'occurrenceTiming', TFhirTiming(value.occurrence), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ChargeItem', 'occurrenceDateTime', TFhirDateTime(value.occurrence), false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeChargeItemPerformer(this, 'ChargeItem', 'performer', value.performerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ChargeItem', 'performingOrganization', value.performingOrganizationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ChargeItem', 'requestingOrganization', value.requestingOrganizationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ChargeItem', 'costCenter', value.costCenterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'ChargeItem', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.bodysiteList.Count - 1 do
      ComposeCodeableConcept(this, 'ChargeItem', 'bodysite', value.bodysiteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMonetaryComponent(this, 'ChargeItem', 'unitPriceComponent', value.unitPriceComponentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMonetaryComponent(this, 'ChargeItem', 'totalPriceComponent', value.totalPriceComponentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ChargeItem', 'overrideReason', value.overrideReasonElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'ChargeItem', 'enterer', value.entererElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ChargeItem', 'enteredDate', value.enteredDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'ChargeItem', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.serviceList.Count - 1 do
      ComposeCodeableReference(this, 'ChargeItem', 'service', value.serviceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.productList.Count - 1 do
      ComposeCodeableReference(this, 'ChargeItem', 'product', value.productList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.accountList.Count - 1 do
      ComposeReference(this, 'ChargeItem', 'account', value.accountList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'ChargeItem', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInformationList.Count - 1 do
      ComposeReference(this, 'ChargeItem', 'supportingInformation', value.supportingInformationList[i], false, i);
end;

{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
function TFHIRTurtleParser.ParseChargeItemDefinitionApplicability(obj : TTurtleComplex) : TFhirChargeItemDefinitionApplicability;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirChargeItemDefinitionApplicability.create;
  try
    ParseChargeItemDefinitionApplicabilityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseChargeItemDefinitionApplicabilityProperties(obj : TTurtleComplex; value : TFhirChargeItemDefinitionApplicability);
begin
    ParseBackboneElementProperties(obj, value);
    value.condition := ParseExpression(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.applicability.condition'));
    value.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.applicability.effectivePeriod'));
    value.relatedArtifact := ParseRelatedArtifact(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.applicability.relatedArtifact'));
end;

procedure TFHIRTurtleComposer.ComposeChargeItemDefinitionApplicability(parent :  TTurtleComplex; parentType, name : String; value : TFhirChargeItemDefinitionApplicability; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ChargeItemDefinitionApplicability');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeExpression(this, 'ChargeItemDefinition.applicability', 'condition', value.conditionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'ChargeItemDefinition.applicability', 'effectivePeriod', value.effectivePeriodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeRelatedArtifact(this, 'ChargeItemDefinition.applicability', 'relatedArtifact', value.relatedArtifactElement, false, -1);
end;

function TFHIRTurtleParser.ParseChargeItemDefinitionPropertyGroup(obj : TTurtleComplex) : TFhirChargeItemDefinitionPropertyGroup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirChargeItemDefinitionPropertyGroup.create;
  try
    ParseChargeItemDefinitionPropertyGroupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseChargeItemDefinitionPropertyGroupProperties(obj : TTurtleComplex; value : TFhirChargeItemDefinitionPropertyGroup);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/ChargeItemDefinition.propertyGroup.applicability') do
      value.applicabilityList.Add(parseChargeItemDefinitionApplicability(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItemDefinition.propertyGroup.priceComponent') do
      value.priceComponentList.Add(parseMonetaryComponent(item));
end;

procedure TFHIRTurtleComposer.ComposeChargeItemDefinitionPropertyGroup(parent :  TTurtleComplex; parentType, name : String; value : TFhirChargeItemDefinitionPropertyGroup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ChargeItemDefinitionPropertyGroup');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.applicabilityList.Count - 1 do
      ComposeChargeItemDefinitionApplicability(this, 'ChargeItemDefinition.propertyGroup', 'applicability', value.applicabilityList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.priceComponentList.Count - 1 do
      ComposeMonetaryComponent(this, 'ChargeItemDefinition.propertyGroup', 'priceComponent', value.priceComponentList[i], false, i);
end;

function TFHIRTurtleParser.ParseChargeItemDefinition(obj : TTurtleComplex) : TFhirChargeItemDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirChargeItemDefinition.create;
  try
    ParseChargeItemDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseChargeItemDefinitionProperties(obj : TTurtleComplex; value : TFhirChargeItemDefinition);
var
  item : TTurtleComplex;
begin
    ParseMetadataResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.url'));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItemDefinition.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.version'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.title'));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItemDefinition.derivedFromUri') do
      value.derivedFromUriList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItemDefinition.partOf') do
      value.partOfList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItemDefinition.replaces') do
      value.replacesList.Add(parseCanonical(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.experimental'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItemDefinition.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.description'));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItemDefinition.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItemDefinition.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.purpose'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.copyright'));
    value.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.approvalDate'));
    value.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.lastReviewDate'));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.code'));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItemDefinition.instance') do
      value.instanceList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItemDefinition.applicability') do
      value.applicabilityList.Add(parseChargeItemDefinitionApplicability(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItemDefinition.propertyGroup') do
      value.propertyGroupList.Add(parseChargeItemDefinitionPropertyGroup(item));
end;

procedure TFHIRTurtleComposer.ComposeChargeItemDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirChargeItemDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ChargeItemDefinition');
  end;
  composeMetadataResource(this, '', name, value, false, index);
  ComposeUri(this, 'ChargeItemDefinition', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ChargeItemDefinition', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ChargeItemDefinition', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ChargeItemDefinition', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ChargeItemDefinition', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.derivedFromUriList.Count - 1 do
      ComposeUri(this, 'ChargeItemDefinition', 'derivedFromUri', value.derivedFromUriList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeCanonical(this, 'ChargeItemDefinition', 'partOf', value.partOfList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.replacesList.Count - 1 do
      ComposeCanonical(this, 'ChargeItemDefinition', 'replaces', value.replacesList[i], false, i);
  ComposeEnum(this, 'ChargeItemDefinition', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ChargeItemDefinition', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ChargeItemDefinition', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ChargeItemDefinition', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'ChargeItemDefinition', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'ChargeItemDefinition', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'ChargeItemDefinition', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'ChargeItemDefinition', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ChargeItemDefinition', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ChargeItemDefinition', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'ChargeItemDefinition', 'approvalDate', value.approvalDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'ChargeItemDefinition', 'lastReviewDate', value.lastReviewDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ChargeItemDefinition', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.instanceList.Count - 1 do
      ComposeReference(this, 'ChargeItemDefinition', 'instance', value.instanceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.applicabilityList.Count - 1 do
      ComposeChargeItemDefinitionApplicability(this, 'ChargeItemDefinition', 'applicability', value.applicabilityList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.propertyGroupList.Count - 1 do
      ComposeChargeItemDefinitionPropertyGroup(this, 'ChargeItemDefinition', 'propertyGroup', value.propertyGroupList[i], false, i);
end;

{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CITATION}
function TFHIRTurtleParser.ParseCitationSummary(obj : TTurtleComplex) : TFhirCitationSummary;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCitationSummary.create;
  try
    ParseCitationSummaryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCitationSummaryProperties(obj : TTurtleComplex; value : TFhirCitationSummary);
begin
    ParseBackboneElementProperties(obj, value);
    value.style := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Citation.summary.style'));
    value.textElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Citation.summary.text'));
end;

procedure TFHIRTurtleComposer.ComposeCitationSummary(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationSummary; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CitationSummary');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Citation.summary', 'style', value.styleElement, false, -1);
  ComposeMarkdown(this, 'Citation.summary', 'text', value.textElement, false, -1);
end;

function TFHIRTurtleParser.ParseCitationClassification(obj : TTurtleComplex) : TFhirCitationClassification;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCitationClassification.create;
  try
    ParseCitationClassificationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCitationClassificationProperties(obj : TTurtleComplex; value : TFhirCitationClassification);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Citation.classification.type'));
    for item in obj.complexes('http://hl7.org/fhir/Citation.classification.classifier') do
      value.classifierList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeCitationClassification(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationClassification; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CitationClassification');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Citation.classification', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.classifierList.Count - 1 do
      ComposeCodeableConcept(this, 'Citation.classification', 'classifier', value.classifierList[i], false, i);
end;

function TFHIRTurtleParser.ParseCitationStatusDate(obj : TTurtleComplex) : TFhirCitationStatusDate;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCitationStatusDate.create;
  try
    ParseCitationStatusDateProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCitationStatusDateProperties(obj : TTurtleComplex; value : TFhirCitationStatusDate);
begin
    ParseBackboneElementProperties(obj, value);
    value.activity := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Citation.statusDate.activity'));
    value.actualElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Citation.statusDate.actual'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Citation.statusDate.period'));
end;

procedure TFHIRTurtleComposer.ComposeCitationStatusDate(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationStatusDate; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CitationStatusDate');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'Citation.statusDate', 'activity', value.activityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Citation.statusDate', 'actual', value.actualElement, false, -1);
  ComposePeriod(this, 'Citation.statusDate', 'period', value.periodElement, false, -1);
end;

function TFHIRTurtleParser.ParseCitationCitedArtifact(obj : TTurtleComplex) : TFhirCitationCitedArtifact;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCitationCitedArtifact.create;
  try
    ParseCitationCitedArtifactProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCitationCitedArtifactProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifact);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Citation.citedArtifact.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/Citation.citedArtifact.relatedIdentifier') do
      value.relatedIdentifierList.Add(parseIdentifier(item));
    value.dateAccessedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.dateAccessed'));
    value.version := ParseCitationCitedArtifactVersion(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.version'));
    for item in obj.complexes('http://hl7.org/fhir/Citation.citedArtifact.currentState') do
      value.currentStateList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Citation.citedArtifact.statusDate') do
      value.statusDateList.Add(parseCitationCitedArtifactStatusDate(item));
    for item in obj.complexes('http://hl7.org/fhir/Citation.citedArtifact.title') do
      value.titleList.Add(parseCitationCitedArtifactTitle(item));
    for item in obj.complexes('http://hl7.org/fhir/Citation.citedArtifact.abstract') do
      value.abstractList.Add(parseCitationCitedArtifactAbstract(item));
    value.part := ParseCitationCitedArtifactPart(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.part'));
    for item in obj.complexes('http://hl7.org/fhir/Citation.citedArtifact.relatesTo') do
      value.relatesToList.Add(parseCitationCitedArtifactRelatesTo(item));
    for item in obj.complexes('http://hl7.org/fhir/Citation.citedArtifact.publicationForm') do
      value.publicationFormList.Add(parseCitationCitedArtifactPublicationForm(item));
    for item in obj.complexes('http://hl7.org/fhir/Citation.citedArtifact.webLocation') do
      value.webLocationList.Add(parseCitationCitedArtifactWebLocation(item));
    for item in obj.complexes('http://hl7.org/fhir/Citation.citedArtifact.classification') do
      value.classificationList.Add(parseCitationCitedArtifactClassification(item));
    value.contributorship := ParseCitationCitedArtifactContributorship(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.contributorship'));
    for item in obj.complexes('http://hl7.org/fhir/Citation.citedArtifact.note') do
      value.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeCitationCitedArtifact(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifact; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CitationCitedArtifact');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Citation.citedArtifact', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.relatedIdentifierList.Count - 1 do
      ComposeIdentifier(this, 'Citation.citedArtifact', 'relatedIdentifier', value.relatedIdentifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Citation.citedArtifact', 'dateAccessed', value.dateAccessedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCitationCitedArtifactVersion(this, 'Citation.citedArtifact', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.currentStateList.Count - 1 do
      ComposeCodeableConcept(this, 'Citation.citedArtifact', 'currentState', value.currentStateList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.statusDateList.Count - 1 do
      ComposeCitationCitedArtifactStatusDate(this, 'Citation.citedArtifact', 'statusDate', value.statusDateList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.titleList.Count - 1 do
      ComposeCitationCitedArtifactTitle(this, 'Citation.citedArtifact', 'title', value.titleList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.abstractList.Count - 1 do
      ComposeCitationCitedArtifactAbstract(this, 'Citation.citedArtifact', 'abstract', value.abstractList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCitationCitedArtifactPart(this, 'Citation.citedArtifact', 'part', value.partElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatesToList.Count - 1 do
      ComposeCitationCitedArtifactRelatesTo(this, 'Citation.citedArtifact', 'relatesTo', value.relatesToList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.publicationFormList.Count - 1 do
      ComposeCitationCitedArtifactPublicationForm(this, 'Citation.citedArtifact', 'publicationForm', value.publicationFormList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.webLocationList.Count - 1 do
      ComposeCitationCitedArtifactWebLocation(this, 'Citation.citedArtifact', 'webLocation', value.webLocationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.classificationList.Count - 1 do
      ComposeCitationCitedArtifactClassification(this, 'Citation.citedArtifact', 'classification', value.classificationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCitationCitedArtifactContributorship(this, 'Citation.citedArtifact', 'contributorship', value.contributorshipElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'Citation.citedArtifact', 'note', value.noteList[i], false, i);
end;

function TFHIRTurtleParser.ParseCitationCitedArtifactVersion(obj : TTurtleComplex) : TFhirCitationCitedArtifactVersion;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCitationCitedArtifactVersion.create;
  try
    ParseCitationCitedArtifactVersionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCitationCitedArtifactVersionProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactVersion);
begin
    ParseBackboneElementProperties(obj, value);
    value.valueElement := ParseString(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.version.value'));
    value.baseCitation := ParseReference(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.version.baseCitation'));
end;

procedure TFHIRTurtleComposer.ComposeCitationCitedArtifactVersion(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactVersion; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CitationCitedArtifactVersion');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'Citation.citedArtifact.version', 'value', value.valueElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Citation.citedArtifact.version', 'baseCitation', value.baseCitationElement, false, -1);
end;

function TFHIRTurtleParser.ParseCitationCitedArtifactStatusDate(obj : TTurtleComplex) : TFhirCitationCitedArtifactStatusDate;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCitationCitedArtifactStatusDate.create;
  try
    ParseCitationCitedArtifactStatusDateProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCitationCitedArtifactStatusDateProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactStatusDate);
begin
    ParseBackboneElementProperties(obj, value);
    value.activity := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.statusDate.activity'));
    value.actualElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.statusDate.actual'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.statusDate.period'));
end;

procedure TFHIRTurtleComposer.ComposeCitationCitedArtifactStatusDate(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactStatusDate; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CitationCitedArtifactStatusDate');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'Citation.citedArtifact.statusDate', 'activity', value.activityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Citation.citedArtifact.statusDate', 'actual', value.actualElement, false, -1);
  ComposePeriod(this, 'Citation.citedArtifact.statusDate', 'period', value.periodElement, false, -1);
end;

function TFHIRTurtleParser.ParseCitationCitedArtifactTitle(obj : TTurtleComplex) : TFhirCitationCitedArtifactTitle;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCitationCitedArtifactTitle.create;
  try
    ParseCitationCitedArtifactTitleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCitationCitedArtifactTitleProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactTitle);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Citation.citedArtifact.title.type') do
      value.type_List.Add(parseCodeableConcept(item));
    value.language := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.title.language'));
    value.textElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.title.text'));
end;

procedure TFHIRTurtleComposer.ComposeCitationCitedArtifactTitle(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactTitle; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CitationCitedArtifactTitle');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Citation.citedArtifact.title', 'type', value.type_List[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Citation.citedArtifact.title', 'language', value.languageElement, false, -1);
  ComposeMarkdown(this, 'Citation.citedArtifact.title', 'text', value.textElement, false, -1);
end;

function TFHIRTurtleParser.ParseCitationCitedArtifactAbstract(obj : TTurtleComplex) : TFhirCitationCitedArtifactAbstract;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCitationCitedArtifactAbstract.create;
  try
    ParseCitationCitedArtifactAbstractProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCitationCitedArtifactAbstractProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactAbstract);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.abstract.type'));
    value.language := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.abstract.language'));
    value.textElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.abstract.text'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.abstract.copyright'));
end;

procedure TFHIRTurtleComposer.ComposeCitationCitedArtifactAbstract(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactAbstract; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CitationCitedArtifactAbstract');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Citation.citedArtifact.abstract', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Citation.citedArtifact.abstract', 'language', value.languageElement, false, -1);
  ComposeMarkdown(this, 'Citation.citedArtifact.abstract', 'text', value.textElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'Citation.citedArtifact.abstract', 'copyright', value.copyrightElement, false, -1);
end;

function TFHIRTurtleParser.ParseCitationCitedArtifactPart(obj : TTurtleComplex) : TFhirCitationCitedArtifactPart;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCitationCitedArtifactPart.create;
  try
    ParseCitationCitedArtifactPartProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCitationCitedArtifactPartProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactPart);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.part.type'));
    value.valueElement := ParseString(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.part.value'));
    value.baseCitation := ParseReference(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.part.baseCitation'));
end;

procedure TFHIRTurtleComposer.ComposeCitationCitedArtifactPart(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactPart; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CitationCitedArtifactPart');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Citation.citedArtifact.part', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Citation.citedArtifact.part', 'value', value.valueElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Citation.citedArtifact.part', 'baseCitation', value.baseCitationElement, false, -1);
end;

function TFHIRTurtleParser.ParseCitationCitedArtifactRelatesTo(obj : TTurtleComplex) : TFhirCitationCitedArtifactRelatesTo;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCitationCitedArtifactRelatesTo.create;
  try
    ParseCitationCitedArtifactRelatesToProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCitationCitedArtifactRelatesToProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactRelatesTo);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.relatesTo.type'), CODES_TFhirRelatedArtifactTypeExpandedEnum, SYSTEMS_TFhirRelatedArtifactTypeExpandedEnum);
    for item in obj.complexes('http://hl7.org/fhir/Citation.citedArtifact.relatesTo.classifier') do
      value.classifierList.Add(parseCodeableConcept(item));
    value.label_Element := ParseString(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.relatesTo.label'));
    value.displayElement := ParseString(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.relatesTo.display'));
    value.citationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.relatesTo.citation'));
    value.document := ParseAttachment(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.relatesTo.document'));
    value.resourceElement := ParseCanonical(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.relatesTo.resource'));
    value.resourceReference := ParseReference(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.relatesTo.resourceReference'));
end;

procedure TFHIRTurtleComposer.ComposeCitationCitedArtifactRelatesTo(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactRelatesTo; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CitationCitedArtifactRelatesTo');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'Citation.citedArtifact.relatesTo', 'type', value.type_Element, CODES_TFhirRelatedArtifactTypeExpandedEnum, SYSTEMS_TFhirRelatedArtifactTypeExpandedEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.classifierList.Count - 1 do
      ComposeCodeableConcept(this, 'Citation.citedArtifact.relatesTo', 'classifier', value.classifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Citation.citedArtifact.relatesTo', 'label', value.label_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Citation.citedArtifact.relatesTo', 'display', value.displayElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'Citation.citedArtifact.relatesTo', 'citation', value.citationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeAttachment(this, 'Citation.citedArtifact.relatesTo', 'document', value.documentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'Citation.citedArtifact.relatesTo', 'resource', value.resourceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Citation.citedArtifact.relatesTo', 'resourceReference', value.resourceReferenceElement, false, -1);
end;

function TFHIRTurtleParser.ParseCitationCitedArtifactPublicationForm(obj : TTurtleComplex) : TFhirCitationCitedArtifactPublicationForm;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCitationCitedArtifactPublicationForm.create;
  try
    ParseCitationCitedArtifactPublicationFormProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCitationCitedArtifactPublicationFormProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactPublicationForm);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.publishedIn := ParseCitationCitedArtifactPublicationFormPublishedIn(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.publicationForm.publishedIn'));
    value.citedMedium := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.publicationForm.citedMedium'));
    value.volumeElement := ParseString(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.publicationForm.volume'));
    value.issueElement := ParseString(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.publicationForm.issue'));
    value.publicationDateYearElement := ParseString(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.publicationForm.publicationDateYear'));
    value.publicationDateMonthElement := ParseString(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.publicationForm.publicationDateMonth'));
    value.publicationDateDayElement := ParseString(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.publicationForm.publicationDateDay'));
    value.publicationDateSeasonElement := ParseString(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.publicationForm.publicationDateSeason'));
    value.publicationDateTextElement := ParseString(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.publicationForm.publicationDateText'));
    value.articleDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.publicationForm.articleDate'));
    value.lastRevisionDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.publicationForm.lastRevisionDate'));
    for item in obj.complexes('http://hl7.org/fhir/Citation.citedArtifact.publicationForm.language') do
      value.languageList.Add(parseCodeableConcept(item));
    value.accessionNumberElement := ParseString(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.publicationForm.accessionNumber'));
    value.pageStringElement := ParseString(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.publicationForm.pageString'));
    value.firstPageElement := ParseString(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.publicationForm.firstPage'));
    value.lastPageElement := ParseString(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.publicationForm.lastPage'));
    value.pageCountElement := ParseString(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.publicationForm.pageCount'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.publicationForm.copyright'));
end;

procedure TFHIRTurtleComposer.ComposeCitationCitedArtifactPublicationForm(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactPublicationForm; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CitationCitedArtifactPublicationForm');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCitationCitedArtifactPublicationFormPublishedIn(this, 'Citation.citedArtifact.publicationForm', 'publishedIn', value.publishedInElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Citation.citedArtifact.publicationForm', 'citedMedium', value.citedMediumElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Citation.citedArtifact.publicationForm', 'volume', value.volumeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Citation.citedArtifact.publicationForm', 'issue', value.issueElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Citation.citedArtifact.publicationForm', 'publicationDateYear', value.publicationDateYearElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Citation.citedArtifact.publicationForm', 'publicationDateMonth', value.publicationDateMonthElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Citation.citedArtifact.publicationForm', 'publicationDateDay', value.publicationDateDayElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Citation.citedArtifact.publicationForm', 'publicationDateSeason', value.publicationDateSeasonElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Citation.citedArtifact.publicationForm', 'publicationDateText', value.publicationDateTextElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Citation.citedArtifact.publicationForm', 'articleDate', value.articleDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Citation.citedArtifact.publicationForm', 'lastRevisionDate', value.lastRevisionDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.languageList.Count - 1 do
      ComposeCodeableConcept(this, 'Citation.citedArtifact.publicationForm', 'language', value.languageList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Citation.citedArtifact.publicationForm', 'accessionNumber', value.accessionNumberElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Citation.citedArtifact.publicationForm', 'pageString', value.pageStringElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Citation.citedArtifact.publicationForm', 'firstPage', value.firstPageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Citation.citedArtifact.publicationForm', 'lastPage', value.lastPageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Citation.citedArtifact.publicationForm', 'pageCount', value.pageCountElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'Citation.citedArtifact.publicationForm', 'copyright', value.copyrightElement, false, -1);
end;

function TFHIRTurtleParser.ParseCitationCitedArtifactPublicationFormPublishedIn(obj : TTurtleComplex) : TFhirCitationCitedArtifactPublicationFormPublishedIn;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCitationCitedArtifactPublicationFormPublishedIn.create;
  try
    ParseCitationCitedArtifactPublicationFormPublishedInProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCitationCitedArtifactPublicationFormPublishedInProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactPublicationFormPublishedIn);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.publicationForm.publishedIn.type'));
    for item in obj.complexes('http://hl7.org/fhir/Citation.citedArtifact.publicationForm.publishedIn.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.publicationForm.publishedIn.title'));
    value.publisher := ParseReference(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.publicationForm.publishedIn.publisher'));
    value.publisherLocationElement := ParseString(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.publicationForm.publishedIn.publisherLocation'));
end;

procedure TFHIRTurtleComposer.ComposeCitationCitedArtifactPublicationFormPublishedIn(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactPublicationFormPublishedIn; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CitationCitedArtifactPublicationFormPublishedIn');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Citation.citedArtifact.publicationForm.publishedIn', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Citation.citedArtifact.publicationForm.publishedIn', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Citation.citedArtifact.publicationForm.publishedIn', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Citation.citedArtifact.publicationForm.publishedIn', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Citation.citedArtifact.publicationForm.publishedIn', 'publisherLocation', value.publisherLocationElement, false, -1);
end;

function TFHIRTurtleParser.ParseCitationCitedArtifactWebLocation(obj : TTurtleComplex) : TFhirCitationCitedArtifactWebLocation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCitationCitedArtifactWebLocation.create;
  try
    ParseCitationCitedArtifactWebLocationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCitationCitedArtifactWebLocationProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactWebLocation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Citation.citedArtifact.webLocation.classifier') do
      value.classifierList.Add(parseCodeableConcept(item));
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.webLocation.url'));
end;

procedure TFHIRTurtleComposer.ComposeCitationCitedArtifactWebLocation(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactWebLocation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CitationCitedArtifactWebLocation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.classifierList.Count - 1 do
      ComposeCodeableConcept(this, 'Citation.citedArtifact.webLocation', 'classifier', value.classifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'Citation.citedArtifact.webLocation', 'url', value.urlElement, false, -1);
end;

function TFHIRTurtleParser.ParseCitationCitedArtifactClassification(obj : TTurtleComplex) : TFhirCitationCitedArtifactClassification;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCitationCitedArtifactClassification.create;
  try
    ParseCitationCitedArtifactClassificationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCitationCitedArtifactClassificationProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactClassification);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.classification.type'));
    for item in obj.complexes('http://hl7.org/fhir/Citation.citedArtifact.classification.classifier') do
      value.classifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Citation.citedArtifact.classification.artifactAssessment') do
      value.artifactAssessmentList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeCitationCitedArtifactClassification(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactClassification; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CitationCitedArtifactClassification');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Citation.citedArtifact.classification', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.classifierList.Count - 1 do
      ComposeCodeableConcept(this, 'Citation.citedArtifact.classification', 'classifier', value.classifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.artifactAssessmentList.Count - 1 do
      ComposeReference(this, 'Citation.citedArtifact.classification', 'artifactAssessment', value.artifactAssessmentList[i], false, i);
end;

function TFHIRTurtleParser.ParseCitationCitedArtifactContributorship(obj : TTurtleComplex) : TFhirCitationCitedArtifactContributorship;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCitationCitedArtifactContributorship.create;
  try
    ParseCitationCitedArtifactContributorshipProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCitationCitedArtifactContributorshipProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactContributorship);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.completeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.contributorship.complete'));
    for item in obj.complexes('http://hl7.org/fhir/Citation.citedArtifact.contributorship.entry') do
      value.entryList.Add(parseCitationCitedArtifactContributorshipEntry(item));
    for item in obj.complexes('http://hl7.org/fhir/Citation.citedArtifact.contributorship.summary') do
      value.summaryList.Add(parseCitationCitedArtifactContributorshipSummary(item));
end;

procedure TFHIRTurtleComposer.ComposeCitationCitedArtifactContributorship(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactContributorship; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CitationCitedArtifactContributorship');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Citation.citedArtifact.contributorship', 'complete', value.completeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.entryList.Count - 1 do
      ComposeCitationCitedArtifactContributorshipEntry(this, 'Citation.citedArtifact.contributorship', 'entry', value.entryList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.summaryList.Count - 1 do
      ComposeCitationCitedArtifactContributorshipSummary(this, 'Citation.citedArtifact.contributorship', 'summary', value.summaryList[i], false, i);
end;

function TFHIRTurtleParser.ParseCitationCitedArtifactContributorshipEntry(obj : TTurtleComplex) : TFhirCitationCitedArtifactContributorshipEntry;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCitationCitedArtifactContributorshipEntry.create;
  try
    ParseCitationCitedArtifactContributorshipEntryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCitationCitedArtifactContributorshipEntryProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactContributorshipEntry);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.contributor := ParseReference(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.contributorship.entry.contributor'));
    value.forenameInitialsElement := ParseString(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.contributorship.entry.forenameInitials'));
    for item in obj.complexes('http://hl7.org/fhir/Citation.citedArtifact.contributorship.entry.affiliation') do
      value.affiliationList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Citation.citedArtifact.contributorship.entry.contributionType') do
      value.contributionTypeList.Add(parseCodeableConcept(item));
    value.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.contributorship.entry.role'));
    for item in obj.complexes('http://hl7.org/fhir/Citation.citedArtifact.contributorship.entry.contributionInstance') do
      value.contributionInstanceList.Add(parseCitationCitedArtifactContributorshipEntryContributionInstance(item));
    value.correspondingContactElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.contributorship.entry.correspondingContact'));
    value.rankingOrderElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.contributorship.entry.rankingOrder'));
end;

procedure TFHIRTurtleComposer.ComposeCitationCitedArtifactContributorshipEntry(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactContributorshipEntry; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CitationCitedArtifactContributorshipEntry');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeReference(this, 'Citation.citedArtifact.contributorship.entry', 'contributor', value.contributorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Citation.citedArtifact.contributorship.entry', 'forenameInitials', value.forenameInitialsElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.affiliationList.Count - 1 do
      ComposeReference(this, 'Citation.citedArtifact.contributorship.entry', 'affiliation', value.affiliationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contributionTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Citation.citedArtifact.contributorship.entry', 'contributionType', value.contributionTypeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Citation.citedArtifact.contributorship.entry', 'role', value.roleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contributionInstanceList.Count - 1 do
      ComposeCitationCitedArtifactContributorshipEntryContributionInstance(this, 'Citation.citedArtifact.contributorship.entry', 'contributionInstance', value.contributionInstanceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Citation.citedArtifact.contributorship.entry', 'correspondingContact', value.correspondingContactElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'Citation.citedArtifact.contributorship.entry', 'rankingOrder', value.rankingOrderElement, false, -1);
end;

function TFHIRTurtleParser.ParseCitationCitedArtifactContributorshipEntryContributionInstance(obj : TTurtleComplex) : TFhirCitationCitedArtifactContributorshipEntryContributionInstance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCitationCitedArtifactContributorshipEntryContributionInstance.create;
  try
    ParseCitationCitedArtifactContributorshipEntryContributionInstanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCitationCitedArtifactContributorshipEntryContributionInstanceProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactContributorshipEntryContributionInstance);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.contributorship.entry.contributionInstance.type'));
    value.timeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.contributorship.entry.contributionInstance.time'));
end;

procedure TFHIRTurtleComposer.ComposeCitationCitedArtifactContributorshipEntryContributionInstance(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactContributorshipEntryContributionInstance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CitationCitedArtifactContributorshipEntryContributionInstance');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'Citation.citedArtifact.contributorship.entry.contributionInstance', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Citation.citedArtifact.contributorship.entry.contributionInstance', 'time', value.timeElement, false, -1);
end;

function TFHIRTurtleParser.ParseCitationCitedArtifactContributorshipSummary(obj : TTurtleComplex) : TFhirCitationCitedArtifactContributorshipSummary;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCitationCitedArtifactContributorshipSummary.create;
  try
    ParseCitationCitedArtifactContributorshipSummaryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCitationCitedArtifactContributorshipSummaryProperties(obj : TTurtleComplex; value : TFhirCitationCitedArtifactContributorshipSummary);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.contributorship.summary.type'));
    value.style := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.contributorship.summary.style'));
    value.source := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.contributorship.summary.source'));
    value.valueElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Citation.citedArtifact.contributorship.summary.value'));
end;

procedure TFHIRTurtleComposer.ComposeCitationCitedArtifactContributorshipSummary(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitationCitedArtifactContributorshipSummary; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CitationCitedArtifactContributorshipSummary');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Citation.citedArtifact.contributorship.summary', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Citation.citedArtifact.contributorship.summary', 'style', value.styleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Citation.citedArtifact.contributorship.summary', 'source', value.sourceElement, false, -1);
  ComposeMarkdown(this, 'Citation.citedArtifact.contributorship.summary', 'value', value.valueElement, false, -1);
end;

function TFHIRTurtleParser.ParseCitation(obj : TTurtleComplex) : TFhirCitation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCitation.create;
  try
    ParseCitationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCitationProperties(obj : TTurtleComplex; value : TFhirCitation);
var
  item : TTurtleComplex;
begin
    ParseMetadataResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Citation.url'));
    for item in obj.complexes('http://hl7.org/fhir/Citation.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Citation.version'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Citation.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Citation.title'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Citation.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Citation.experimental'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Citation.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/Citation.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/Citation.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Citation.description'));
    for item in obj.complexes('http://hl7.org/fhir/Citation.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/Citation.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Citation.purpose'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Citation.copyright'));
    value.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Citation.approvalDate'));
    value.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Citation.lastReviewDate'));
    value.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Citation.effectivePeriod'));
    for item in obj.complexes('http://hl7.org/fhir/Citation.author') do
      value.authorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Citation.editor') do
      value.editorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Citation.reviewer') do
      value.reviewerList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Citation.endorser') do
      value.endorserList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Citation.summary') do
      value.summaryList.Add(parseCitationSummary(item));
    for item in obj.complexes('http://hl7.org/fhir/Citation.classification') do
      value.classificationList.Add(parseCitationClassification(item));
    for item in obj.complexes('http://hl7.org/fhir/Citation.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/Citation.currentState') do
      value.currentStateList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Citation.statusDate') do
      value.statusDateList.Add(parseCitationStatusDate(item));
    for item in obj.complexes('http://hl7.org/fhir/Citation.relatedArtifact') do
      value.relatedArtifactList.Add(parseRelatedArtifact(item));
    value.citedArtifact := ParseCitationCitedArtifact(obj.complex('http://hl7.org/fhir/Citation.citedArtifact'));
end;

procedure TFHIRTurtleComposer.ComposeCitation(parent :  TTurtleComplex; parentType, name : String; value : TFhirCitation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Citation');
  end;
  composeMetadataResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'Citation', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Citation', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Citation', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Citation', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Citation', 'title', value.titleElement, false, -1);
  ComposeEnum(this, 'Citation', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Citation', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Citation', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Citation', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'Citation', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'Citation', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'Citation', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'Citation', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'Citation', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'Citation', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'Citation', 'approvalDate', value.approvalDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'Citation', 'lastReviewDate', value.lastReviewDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Citation', 'effectivePeriod', value.effectivePeriodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(this, 'Citation', 'author', value.authorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(this, 'Citation', 'editor', value.editorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(this, 'Citation', 'reviewer', value.reviewerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(this, 'Citation', 'endorser', value.endorserList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.summaryList.Count - 1 do
      ComposeCitationSummary(this, 'Citation', 'summary', value.summaryList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.classificationList.Count - 1 do
      ComposeCitationClassification(this, 'Citation', 'classification', value.classificationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'Citation', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.currentStateList.Count - 1 do
      ComposeCodeableConcept(this, 'Citation', 'currentState', value.currentStateList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.statusDateList.Count - 1 do
      ComposeCitationStatusDate(this, 'Citation', 'statusDate', value.statusDateList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'Citation', 'relatedArtifact', value.relatedArtifactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCitationCitedArtifact(this, 'Citation', 'citedArtifact', value.citedArtifactElement, false, -1);
end;

{$ENDIF FHIR_CITATION}
{$IFDEF FHIR_CLAIM}
function TFHIRTurtleParser.ParseClaimRelated(obj : TTurtleComplex) : TFhirClaimRelated;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimRelated.create;
  try
    ParseClaimRelatedProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimRelatedProperties(obj : TTurtleComplex; value : TFhirClaimRelated);
begin
    ParseBackboneElementProperties(obj, value);
    value.claim := ParseReference(obj.complex('http://hl7.org/fhir/Claim.related.claim'));
    value.relationship := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.related.relationship'));
    value.reference := ParseIdentifier(obj.complex('http://hl7.org/fhir/Claim.related.reference'));
end;

procedure TFHIRTurtleComposer.ComposeClaimRelated(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimRelated; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimRelated');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Claim.related', 'claim', value.claimElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.related', 'relationship', value.relationshipElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'Claim.related', 'reference', value.referenceElement, false, -1);
end;

function TFHIRTurtleParser.ParseClaimPayee(obj : TTurtleComplex) : TFhirClaimPayee;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimPayee.create;
  try
    ParseClaimPayeeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimPayeeProperties(obj : TTurtleComplex; value : TFhirClaimPayee);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.payee.type'));
    value.party := ParseReference(obj.complex('http://hl7.org/fhir/Claim.payee.party'));
end;

procedure TFHIRTurtleComposer.ComposeClaimPayee(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimPayee; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimPayee');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'Claim.payee', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Claim.payee', 'party', value.partyElement, false, -1);
end;

function TFHIRTurtleParser.ParseClaimCareTeam(obj : TTurtleComplex) : TFhirClaimCareTeam;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimCareTeam.create;
  try
    ParseClaimCareTeamProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimCareTeamProperties(obj : TTurtleComplex; value : TFhirClaimCareTeam);
begin
    ParseBackboneElementProperties(obj, value);
    value.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.careTeam.sequence'));
    value.provider := ParseReference(obj.complex('http://hl7.org/fhir/Claim.careTeam.provider'));
    value.responsibleElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Claim.careTeam.responsible'));
    value.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.careTeam.role'));
    value.specialty := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.careTeam.specialty'));
end;

procedure TFHIRTurtleComposer.ComposeClaimCareTeam(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimCareTeam; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimCareTeam');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposePositiveInt(this, 'Claim.careTeam', 'sequence', value.sequenceElement, false, -1);
  ComposeReference(this, 'Claim.careTeam', 'provider', value.providerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Claim.careTeam', 'responsible', value.responsibleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.careTeam', 'role', value.roleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.careTeam', 'specialty', value.specialtyElement, false, -1);
end;

function TFHIRTurtleParser.ParseClaimSupportingInfo(obj : TTurtleComplex) : TFhirClaimSupportingInfo;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimSupportingInfo.create;
  try
    ParseClaimSupportingInfoProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimSupportingInfoProperties(obj : TTurtleComplex; value : TFhirClaimSupportingInfo);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.supportingInfo.sequence'));
    value.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.supportingInfo.category'));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.supportingInfo.code'));
    if obj.has('timingPeriod', item) then
      value.timing := parsePeriod(item);
    if obj.has('timingDate', item) then
      value.timing := parseDate(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueAttachment', item) then
      value.value := parseAttachment(item);
    if obj.has('valueReference', item) {a3} then
      value.value := ParseReference(item);
    if obj.has('valueIdentifier', item) then
      value.value := parseIdentifier(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    value.reason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.supportingInfo.reason'));
end;

procedure TFHIRTurtleComposer.ComposeClaimSupportingInfo(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimSupportingInfo; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimSupportingInfo');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposePositiveInt(this, 'Claim.supportingInfo', 'sequence', value.sequenceElement, false, -1);
  ComposeCodeableConcept(this, 'Claim.supportingInfo', 'category', value.categoryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.supportingInfo', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.timing is TFhirPeriod) {6} then
    ComposePeriod(this, 'Claim.supportingInfo', 'timingPeriod', TFhirPeriod(value.timing), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirDate) {6} then
    ComposeDate(this, 'Claim.supportingInfo', 'timingDate', TFhirDate(value.timing), false, -1);
  if (SummaryOption in [soFull, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Claim.supportingInfo', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Claim.supportingInfo', 'valueAttachment', TFhirAttachment(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirReference) {2} then
    ComposeReference(this, 'Claim.supportingInfo', 'valueReference', TFhirReference(value.value), false,-1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'Claim.supportingInfo', 'valueIdentifier', TFhirIdentifier(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Claim.supportingInfo', 'valueBoolean', TFhirBoolean(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirString) {6} then
    ComposeString(this, 'Claim.supportingInfo', 'valueString', TFhirString(value.value), false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.supportingInfo', 'reason', value.reasonElement, false, -1);
end;

function TFHIRTurtleParser.ParseClaimDiagnosis(obj : TTurtleComplex) : TFhirClaimDiagnosis;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimDiagnosis.create;
  try
    ParseClaimDiagnosisProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimDiagnosisProperties(obj : TTurtleComplex; value : TFhirClaimDiagnosis);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.diagnosis.sequence'));
    if obj.has('diagnosisCodeableConcept', item) then
      value.diagnosis := parseCodeableConcept(item);
    if obj.has('diagnosisReference', item) {a3} then
      value.diagnosis := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/Claim.diagnosis.type') do
      value.type_List.Add(parseCodeableConcept(item));
    value.onAdmission := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.diagnosis.onAdmission'));
end;

procedure TFHIRTurtleComposer.ComposeClaimDiagnosis(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimDiagnosis; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimDiagnosis');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposePositiveInt(this, 'Claim.diagnosis', 'sequence', value.sequenceElement, false, -1);
  if (value.diagnosis is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Claim.diagnosis', 'diagnosisCodeableConcept', TFhirCodeableConcept(value.diagnosis), false, -1)
  else if (value.diagnosis is TFhirReference) {2} then
    ComposeReference(this, 'Claim.diagnosis', 'diagnosisReference', TFhirReference(value.diagnosis), false,-1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.diagnosis', 'type', value.type_List[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.diagnosis', 'onAdmission', value.onAdmissionElement, false, -1);
end;

function TFHIRTurtleParser.ParseClaimProcedure(obj : TTurtleComplex) : TFhirClaimProcedure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimProcedure.create;
  try
    ParseClaimProcedureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimProcedureProperties(obj : TTurtleComplex; value : TFhirClaimProcedure);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.procedure.sequence'));
    for item in obj.complexes('http://hl7.org/fhir/Claim.procedure.type') do
      value.type_List.Add(parseCodeableConcept(item));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Claim.procedure.date'));
    if obj.has('procedureCodeableConcept', item) then
      value.procedure_ := parseCodeableConcept(item);
    if obj.has('procedureReference', item) {a3} then
      value.procedure_ := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/Claim.procedure.udi') do
      value.udiList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimProcedure(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimProcedure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimProcedure');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposePositiveInt(this, 'Claim.procedure', 'sequence', value.sequenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.procedure', 'type', value.type_List[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Claim.procedure', 'date', value.dateElement, false, -1);
  if (value.procedure_ is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Claim.procedure', 'procedureCodeableConcept', TFhirCodeableConcept(value.procedure_), false, -1)
  else if (value.procedure_ is TFhirReference) {2} then
    ComposeReference(this, 'Claim.procedure', 'procedureReference', TFhirReference(value.procedure_), false,-1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.udiList.Count - 1 do
      ComposeReference(this, 'Claim.procedure', 'udi', value.udiList[i], false, i);
end;

function TFHIRTurtleParser.ParseClaimInsurance(obj : TTurtleComplex) : TFhirClaimInsurance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimInsurance.create;
  try
    ParseClaimInsuranceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimInsuranceProperties(obj : TTurtleComplex; value : TFhirClaimInsurance);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.insurance.sequence'));
    value.focalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Claim.insurance.focal'));
    value.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Claim.insurance.identifier'));
    value.coverage := ParseReference(obj.complex('http://hl7.org/fhir/Claim.insurance.coverage'));
    value.businessArrangementElement := ParseString(obj.complex('http://hl7.org/fhir/Claim.insurance.businessArrangement'));
    for item in obj.complexes('http://hl7.org/fhir/Claim.insurance.preAuthRef') do
      value.preAuthRefList.Add(parseString(item));
    value.claimResponse := ParseReference(obj.complex('http://hl7.org/fhir/Claim.insurance.claimResponse'));
end;

procedure TFHIRTurtleComposer.ComposeClaimInsurance(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimInsurance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimInsurance');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposePositiveInt(this, 'Claim.insurance', 'sequence', value.sequenceElement, false, -1);
  ComposeBoolean(this, 'Claim.insurance', 'focal', value.focalElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'Claim.insurance', 'identifier', value.identifierElement, false, -1);
  ComposeReference(this, 'Claim.insurance', 'coverage', value.coverageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Claim.insurance', 'businessArrangement', value.businessArrangementElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.preAuthRefList.Count - 1 do
      ComposeString(this, 'Claim.insurance', 'preAuthRef', value.preAuthRefList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Claim.insurance', 'claimResponse', value.claimResponseElement, false, -1);
end;

function TFHIRTurtleParser.ParseClaimAccident(obj : TTurtleComplex) : TFhirClaimAccident;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimAccident.create;
  try
    ParseClaimAccidentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimAccidentProperties(obj : TTurtleComplex; value : TFhirClaimAccident);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.dateElement := ParseDate(obj.complex('http://hl7.org/fhir/Claim.accident.date'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.accident.type'));
    if obj.has('locationAddress', item) then
      value.location := parseAddress(item);
    if obj.has('locationReference', item) {a3} then
      value.location := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeClaimAccident(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimAccident; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimAccident');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeDate(this, 'Claim.accident', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.accident', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.location is TFhirAddress) {6} then
    ComposeAddress(this, 'Claim.accident', 'locationAddress', TFhirAddress(value.location), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.location is TFhirReference) {2} then
    ComposeReference(this, 'Claim.accident', 'locationReference', TFhirReference(value.location), false,-1);
end;

function TFHIRTurtleParser.ParseClaimItem(obj : TTurtleComplex) : TFhirClaimItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimItem.create;
  try
    ParseClaimItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimItemProperties(obj : TTurtleComplex; value : TFhirClaimItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.item.sequence'));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.careTeamSequence') do
      value.careTeamSequenceList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.diagnosisSequence') do
      value.diagnosisSequenceList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.procedureSequence') do
      value.procedureSequenceList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.informationSequence') do
      value.informationSequenceList.Add(parsePositiveInt(item));
    value.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.revenue'));
    value.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.category'));
    value.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.productOrService'));
    value.productOrServiceEnd := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.productOrServiceEnd'));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.modifier') do
      value.modifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.programCode') do
      value.programCodeList.Add(parseCodeableConcept(item));
    if obj.has('servicedPeriod', item) then
      value.serviced := parsePeriod(item);
    if obj.has('servicedDate', item) then
      value.serviced := parseDate(item);
    if obj.has('locationCodeableConcept', item) then
      value.location := parseCodeableConcept(item);
    if obj.has('locationAddress', item) then
      value.location := parseAddress(item);
    if obj.has('locationReference', item) {a3} then
      value.location := ParseReference(item);
    value.patientPaid := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.item.patientPaid'));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Claim.item.quantity'));
    value.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.item.unitPrice'));
    value.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Claim.item.factor'));
    value.tax := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.item.tax'));
    value.net := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.item.net'));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.udi') do
      value.udiList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.bodySite') do
      value.bodySiteList.Add(parseClaimItemBodySite(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.encounter') do
      value.encounterList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail') do
      value.detailList.Add(parseClaimItemDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimItem');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposePositiveInt(this, 'Claim.item', 'sequence', value.sequenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.careTeamSequenceList.Count - 1 do
      ComposePositiveInt(this, 'Claim.item', 'careTeamSequence', value.careTeamSequenceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.diagnosisSequenceList.Count - 1 do
      ComposePositiveInt(this, 'Claim.item', 'diagnosisSequence', value.diagnosisSequenceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.procedureSequenceList.Count - 1 do
      ComposePositiveInt(this, 'Claim.item', 'procedureSequence', value.procedureSequenceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.informationSequenceList.Count - 1 do
      ComposePositiveInt(this, 'Claim.item', 'informationSequence', value.informationSequenceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item', 'revenue', value.revenueElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item', 'category', value.categoryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item', 'productOrService', value.productOrServiceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item', 'productOrServiceEnd', value.productOrServiceEndElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.item', 'modifier', value.modifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.programCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.item', 'programCode', value.programCodeList[i], false, i);
  if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirPeriod) {6} then
    ComposePeriod(this, 'Claim.item', 'servicedPeriod', TFhirPeriod(value.serviced), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirDate) {6} then
    ComposeDate(this, 'Claim.item', 'servicedDate', TFhirDate(value.serviced), false, -1);
  if (SummaryOption in [soFull, soData]) and (value.location is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Claim.item', 'locationCodeableConcept', TFhirCodeableConcept(value.location), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.location is TFhirAddress) {6} then
    ComposeAddress(this, 'Claim.item', 'locationAddress', TFhirAddress(value.location), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.location is TFhirReference) {2} then
    ComposeReference(this, 'Claim.item', 'locationReference', TFhirReference(value.location), false,-1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim.item', 'patientPaid', value.patientPaidElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Claim.item', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim.item', 'unitPrice', value.unitPriceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Claim.item', 'factor', value.factorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim.item', 'tax', value.taxElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim.item', 'net', value.netElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.udiList.Count - 1 do
      ComposeReference(this, 'Claim.item', 'udi', value.udiList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.bodySiteList.Count - 1 do
      ComposeClaimItemBodySite(this, 'Claim.item', 'bodySite', value.bodySiteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.encounterList.Count - 1 do
      ComposeReference(this, 'Claim.item', 'encounter', value.encounterList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.detailList.Count - 1 do
      ComposeClaimItemDetail(this, 'Claim.item', 'detail', value.detailList[i], false, i);
end;

function TFHIRTurtleParser.ParseClaimItemBodySite(obj : TTurtleComplex) : TFhirClaimItemBodySite;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimItemBodySite.create;
  try
    ParseClaimItemBodySiteProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimItemBodySiteProperties(obj : TTurtleComplex; value : TFhirClaimItemBodySite);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.bodySite.site') do
      value.siteList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.bodySite.subSite') do
      value.subSiteList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimItemBodySite(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimItemBodySite; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimItemBodySite');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  for i := 0 to value.siteList.Count - 1 do
      ComposeCodeableReference(this, 'Claim.item.bodySite', 'site', value.siteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subSiteList.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.item.bodySite', 'subSite', value.subSiteList[i], false, i);
end;

function TFHIRTurtleParser.ParseClaimItemDetail(obj : TTurtleComplex) : TFhirClaimItemDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimItemDetail.create;
  try
    ParseClaimItemDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimItemDetailProperties(obj : TTurtleComplex; value : TFhirClaimItemDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.item.detail.sequence'));
    value.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.detail.revenue'));
    value.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.detail.category'));
    value.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.detail.productOrService'));
    value.productOrServiceEnd := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.detail.productOrServiceEnd'));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail.modifier') do
      value.modifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail.programCode') do
      value.programCodeList.Add(parseCodeableConcept(item));
    value.patientPaid := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.item.detail.patientPaid'));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Claim.item.detail.quantity'));
    value.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.item.detail.unitPrice'));
    value.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Claim.item.detail.factor'));
    value.tax := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.item.detail.tax'));
    value.net := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.item.detail.net'));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail.udi') do
      value.udiList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail.subDetail') do
      value.subDetailList.Add(parseClaimItemDetailSubDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimItemDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimItemDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimItemDetail');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposePositiveInt(this, 'Claim.item.detail', 'sequence', value.sequenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item.detail', 'revenue', value.revenueElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item.detail', 'category', value.categoryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item.detail', 'productOrService', value.productOrServiceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item.detail', 'productOrServiceEnd', value.productOrServiceEndElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.item.detail', 'modifier', value.modifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.programCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.item.detail', 'programCode', value.programCodeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim.item.detail', 'patientPaid', value.patientPaidElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Claim.item.detail', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim.item.detail', 'unitPrice', value.unitPriceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Claim.item.detail', 'factor', value.factorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim.item.detail', 'tax', value.taxElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim.item.detail', 'net', value.netElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.udiList.Count - 1 do
      ComposeReference(this, 'Claim.item.detail', 'udi', value.udiList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subDetailList.Count - 1 do
      ComposeClaimItemDetailSubDetail(this, 'Claim.item.detail', 'subDetail', value.subDetailList[i], false, i);
end;

function TFHIRTurtleParser.ParseClaimItemDetailSubDetail(obj : TTurtleComplex) : TFhirClaimItemDetailSubDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimItemDetailSubDetail.create;
  try
    ParseClaimItemDetailSubDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimItemDetailSubDetailProperties(obj : TTurtleComplex; value : TFhirClaimItemDetailSubDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.sequence'));
    value.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.revenue'));
    value.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.category'));
    value.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.productOrService'));
    value.productOrServiceEnd := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.productOrServiceEnd'));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail.subDetail.modifier') do
      value.modifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail.subDetail.programCode') do
      value.programCodeList.Add(parseCodeableConcept(item));
    value.patientPaid := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.patientPaid'));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.quantity'));
    value.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.unitPrice'));
    value.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.factor'));
    value.tax := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.tax'));
    value.net := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.net'));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail.subDetail.udi') do
      value.udiList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimItemDetailSubDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimItemDetailSubDetail');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposePositiveInt(this, 'Claim.item.detail.subDetail', 'sequence', value.sequenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item.detail.subDetail', 'revenue', value.revenueElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item.detail.subDetail', 'category', value.categoryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item.detail.subDetail', 'productOrService', value.productOrServiceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item.detail.subDetail', 'productOrServiceEnd', value.productOrServiceEndElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.item.detail.subDetail', 'modifier', value.modifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.programCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.item.detail.subDetail', 'programCode', value.programCodeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim.item.detail.subDetail', 'patientPaid', value.patientPaidElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Claim.item.detail.subDetail', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim.item.detail.subDetail', 'unitPrice', value.unitPriceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Claim.item.detail.subDetail', 'factor', value.factorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim.item.detail.subDetail', 'tax', value.taxElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim.item.detail.subDetail', 'net', value.netElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.udiList.Count - 1 do
      ComposeReference(this, 'Claim.item.detail.subDetail', 'udi', value.udiList[i], false, i);
end;

function TFHIRTurtleParser.ParseClaim(obj : TTurtleComplex) : TFhirClaim;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaim.create;
  try
    ParseClaimProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimProperties(obj : TTurtleComplex; value : TFhirClaim);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Claim.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Claim.status'), CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.type'));
    value.subType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.subType'));
    value.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/Claim.use'), CODES_TFhirUseEnum, SYSTEMS_TFhirUseEnum);
    value.patient := ParseReference(obj.complex('http://hl7.org/fhir/Claim.patient'));
    value.billablePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Claim.billablePeriod'));
    value.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Claim.created'));
    value.enterer := ParseReference(obj.complex('http://hl7.org/fhir/Claim.enterer'));
    value.insurer := ParseReference(obj.complex('http://hl7.org/fhir/Claim.insurer'));
    value.provider := ParseReference(obj.complex('http://hl7.org/fhir/Claim.provider'));
    value.priority := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.priority'));
    value.fundsReserve := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.fundsReserve'));
    for item in obj.complexes('http://hl7.org/fhir/Claim.related') do
      value.relatedList.Add(parseClaimRelated(item));
    value.prescription := ParseReference(obj.complex('http://hl7.org/fhir/Claim.prescription'));
    value.originalPrescription := ParseReference(obj.complex('http://hl7.org/fhir/Claim.originalPrescription'));
    value.payee := ParseClaimPayee(obj.complex('http://hl7.org/fhir/Claim.payee'));
    value.referral := ParseReference(obj.complex('http://hl7.org/fhir/Claim.referral'));
    for item in obj.complexes('http://hl7.org/fhir/Claim.encounter') do
      value.encounterList.Add(parseReference(item));
    value.facility := ParseReference(obj.complex('http://hl7.org/fhir/Claim.facility'));
    value.diagnosisRelatedGroup := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.diagnosisRelatedGroup'));
    for item in obj.complexes('http://hl7.org/fhir/Claim.careTeam') do
      value.careTeamList.Add(parseClaimCareTeam(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.supportingInfo') do
      value.supportingInfoList.Add(parseClaimSupportingInfo(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.diagnosis') do
      value.diagnosisList.Add(parseClaimDiagnosis(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.procedure') do
      value.procedure_List.Add(parseClaimProcedure(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.insurance') do
      value.insuranceList.Add(parseClaimInsurance(item));
    value.accident := ParseClaimAccident(obj.complex('http://hl7.org/fhir/Claim.accident'));
    value.patientPaid := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.patientPaid'));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item') do
      value.itemList.Add(parseClaimItem(item));
    value.total := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.total'));
end;

procedure TFHIRTurtleComposer.ComposeClaim(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaim; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Claim');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Claim', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'Claim', 'status', value.statusElement, CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum, false, -1);
  ComposeCodeableConcept(this, 'Claim', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim', 'subType', value.subTypeElement, false, -1);
  ComposeEnum(this, 'Claim', 'use', value.useElement, CODES_TFhirUseEnum, SYSTEMS_TFhirUseEnum, false, -1);
  ComposeReference(this, 'Claim', 'patient', value.patientElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Claim', 'billablePeriod', value.billablePeriodElement, false, -1);
  ComposeDateTime(this, 'Claim', 'created', value.createdElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Claim', 'enterer', value.entererElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Claim', 'insurer', value.insurerElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Claim', 'provider', value.providerElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Claim', 'priority', value.priorityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim', 'fundsReserve', value.fundsReserveElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedList.Count - 1 do
      ComposeClaimRelated(this, 'Claim', 'related', value.relatedList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Claim', 'prescription', value.prescriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Claim', 'originalPrescription', value.originalPrescriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeClaimPayee(this, 'Claim', 'payee', value.payeeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Claim', 'referral', value.referralElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.encounterList.Count - 1 do
      ComposeReference(this, 'Claim', 'encounter', value.encounterList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Claim', 'facility', value.facilityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim', 'diagnosisRelatedGroup', value.diagnosisRelatedGroupElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.careTeamList.Count - 1 do
      ComposeClaimCareTeam(this, 'Claim', 'careTeam', value.careTeamList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInfoList.Count - 1 do
      ComposeClaimSupportingInfo(this, 'Claim', 'supportingInfo', value.supportingInfoList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.diagnosisList.Count - 1 do
      ComposeClaimDiagnosis(this, 'Claim', 'diagnosis', value.diagnosisList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.procedure_List.Count - 1 do
      ComposeClaimProcedure(this, 'Claim', 'procedure', value.procedure_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.insuranceList.Count - 1 do
      ComposeClaimInsurance(this, 'Claim', 'insurance', value.insuranceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeClaimAccident(this, 'Claim', 'accident', value.accidentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim', 'patientPaid', value.patientPaidElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.itemList.Count - 1 do
      ComposeClaimItem(this, 'Claim', 'item', value.itemList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim', 'total', value.totalElement, false, -1);
end;

{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
function TFHIRTurtleParser.ParseClaimResponseItem(obj : TTurtleComplex) : TFhirClaimResponseItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseItem.create;
  try
    ParseClaimResponseItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseItemProperties(obj : TTurtleComplex; value : TFhirClaimResponseItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.itemSequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.item.itemSequence'));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.noteNumber') do
      value.noteNumberList.Add(parsePositiveInt(item));
    value.decision := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.item.decision'));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.adjudication') do
      value.adjudicationList.Add(parseClaimResponseItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.detail') do
      value.detailList.Add(parseClaimResponseItemDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponseItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseItem');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposePositiveInt(this, 'ClaimResponse.item', 'itemSequence', value.itemSequenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.item', 'noteNumber', value.noteNumberList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.item', 'decision', value.decisionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(this, 'ClaimResponse.item', 'adjudication', value.adjudicationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.detailList.Count - 1 do
      ComposeClaimResponseItemDetail(this, 'ClaimResponse.item', 'detail', value.detailList[i], false, i);
end;

function TFHIRTurtleParser.ParseClaimResponseItemAdjudication(obj : TTurtleComplex) : TFhirClaimResponseItemAdjudication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseItemAdjudication.create;
  try
    ParseClaimResponseItemAdjudicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseItemAdjudicationProperties(obj : TTurtleComplex; value : TFhirClaimResponseItemAdjudication);
begin
    ParseBackboneElementProperties(obj, value);
    value.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.item.adjudication.category'));
    value.reason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.item.adjudication.reason'));
    value.amount := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.item.adjudication.amount'));
    value.valueElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ClaimResponse.item.adjudication.value'));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseItemAdjudication(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponseItemAdjudication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseItemAdjudication');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'ClaimResponse.item.adjudication', 'category', value.categoryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.item.adjudication', 'reason', value.reasonElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ClaimResponse.item.adjudication', 'amount', value.amountElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ClaimResponse.item.adjudication', 'value', value.valueElement, false, -1);
end;

function TFHIRTurtleParser.ParseClaimResponseItemDetail(obj : TTurtleComplex) : TFhirClaimResponseItemDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseItemDetail.create;
  try
    ParseClaimResponseItemDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseItemDetailProperties(obj : TTurtleComplex; value : TFhirClaimResponseItemDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.detailSequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.item.detail.detailSequence'));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.detail.noteNumber') do
      value.noteNumberList.Add(parsePositiveInt(item));
    value.decision := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.item.detail.decision'));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.detail.adjudication') do
      value.adjudicationList.Add(parseClaimResponseItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.detail.subDetail') do
      value.subDetailList.Add(parseClaimResponseItemDetailSubDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseItemDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponseItemDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseItemDetail');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposePositiveInt(this, 'ClaimResponse.item.detail', 'detailSequence', value.detailSequenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.item.detail', 'noteNumber', value.noteNumberList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.item.detail', 'decision', value.decisionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(this, 'ClaimResponse.item.detail', 'adjudication', value.adjudicationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subDetailList.Count - 1 do
      ComposeClaimResponseItemDetailSubDetail(this, 'ClaimResponse.item.detail', 'subDetail', value.subDetailList[i], false, i);
end;

function TFHIRTurtleParser.ParseClaimResponseItemDetailSubDetail(obj : TTurtleComplex) : TFhirClaimResponseItemDetailSubDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseItemDetailSubDetail.create;
  try
    ParseClaimResponseItemDetailSubDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseItemDetailSubDetailProperties(obj : TTurtleComplex; value : TFhirClaimResponseItemDetailSubDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.subDetailSequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.item.detail.subDetail.subDetailSequence'));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.detail.subDetail.noteNumber') do
      value.noteNumberList.Add(parsePositiveInt(item));
    value.decision := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.item.detail.subDetail.decision'));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.detail.subDetail.adjudication') do
      value.adjudicationList.Add(parseClaimResponseItemAdjudication(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponseItemDetailSubDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseItemDetailSubDetail');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposePositiveInt(this, 'ClaimResponse.item.detail.subDetail', 'subDetailSequence', value.subDetailSequenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.item.detail.subDetail', 'noteNumber', value.noteNumberList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.item.detail.subDetail', 'decision', value.decisionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(this, 'ClaimResponse.item.detail.subDetail', 'adjudication', value.adjudicationList[i], false, i);
end;

function TFHIRTurtleParser.ParseClaimResponseAddItem(obj : TTurtleComplex) : TFhirClaimResponseAddItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseAddItem.create;
  try
    ParseClaimResponseAddItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseAddItemProperties(obj : TTurtleComplex; value : TFhirClaimResponseAddItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.itemSequence') do
      value.itemSequenceList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.detailSequence') do
      value.detailSequenceList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.subdetailSequence') do
      value.subdetailSequenceList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.provider') do
      value.providerList.Add(parseReference(item));
    value.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.revenue'));
    value.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.productOrService'));
    value.productOrServiceEnd := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.productOrServiceEnd'));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.modifier') do
      value.modifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.programCode') do
      value.programCodeList.Add(parseCodeableConcept(item));
    if obj.has('servicedPeriod', item) then
      value.serviced := parsePeriod(item);
    if obj.has('servicedDate', item) then
      value.serviced := parseDate(item);
    if obj.has('locationCodeableConcept', item) then
      value.location := parseCodeableConcept(item);
    if obj.has('locationAddress', item) then
      value.location := parseAddress(item);
    if obj.has('locationReference', item) {a3} then
      value.location := ParseReference(item);
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.quantity'));
    value.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.unitPrice'));
    value.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.factor'));
    value.tax := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.tax'));
    value.net := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.net'));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.bodySite') do
      value.bodySiteList.Add(parseClaimResponseAddItemBodySite(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.noteNumber') do
      value.noteNumberList.Add(parsePositiveInt(item));
    value.decision := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.decision'));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.adjudication') do
      value.adjudicationList.Add(parseClaimResponseItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.detail') do
      value.detailList.Add(parseClaimResponseAddItemDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseAddItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponseAddItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseAddItem');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.itemSequenceList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.addItem', 'itemSequence', value.itemSequenceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.detailSequenceList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.addItem', 'detailSequence', value.detailSequenceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subdetailSequenceList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.addItem', 'subdetailSequence', value.subdetailSequenceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.providerList.Count - 1 do
      ComposeReference(this, 'ClaimResponse.addItem', 'provider', value.providerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.addItem', 'revenue', value.revenueElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.addItem', 'productOrService', value.productOrServiceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.addItem', 'productOrServiceEnd', value.productOrServiceEndElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ClaimResponse.addItem', 'modifier', value.modifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.programCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'ClaimResponse.addItem', 'programCode', value.programCodeList[i], false, i);
  if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirPeriod) {6} then
    ComposePeriod(this, 'ClaimResponse.addItem', 'servicedPeriod', TFhirPeriod(value.serviced), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirDate) {6} then
    ComposeDate(this, 'ClaimResponse.addItem', 'servicedDate', TFhirDate(value.serviced), false, -1);
  if (SummaryOption in [soFull, soData]) and (value.location is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ClaimResponse.addItem', 'locationCodeableConcept', TFhirCodeableConcept(value.location), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.location is TFhirAddress) {6} then
    ComposeAddress(this, 'ClaimResponse.addItem', 'locationAddress', TFhirAddress(value.location), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.location is TFhirReference) {2} then
    ComposeReference(this, 'ClaimResponse.addItem', 'locationReference', TFhirReference(value.location), false,-1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ClaimResponse.addItem', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ClaimResponse.addItem', 'unitPrice', value.unitPriceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ClaimResponse.addItem', 'factor', value.factorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ClaimResponse.addItem', 'tax', value.taxElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ClaimResponse.addItem', 'net', value.netElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.bodySiteList.Count - 1 do
      ComposeClaimResponseAddItemBodySite(this, 'ClaimResponse.addItem', 'bodySite', value.bodySiteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.addItem', 'noteNumber', value.noteNumberList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.addItem', 'decision', value.decisionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(this, 'ClaimResponse.addItem', 'adjudication', value.adjudicationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.detailList.Count - 1 do
      ComposeClaimResponseAddItemDetail(this, 'ClaimResponse.addItem', 'detail', value.detailList[i], false, i);
end;

function TFHIRTurtleParser.ParseClaimResponseAddItemBodySite(obj : TTurtleComplex) : TFhirClaimResponseAddItemBodySite;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseAddItemBodySite.create;
  try
    ParseClaimResponseAddItemBodySiteProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseAddItemBodySiteProperties(obj : TTurtleComplex; value : TFhirClaimResponseAddItemBodySite);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.bodySite.site') do
      value.siteList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.bodySite.subSite') do
      value.subSiteList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseAddItemBodySite(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponseAddItemBodySite; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseAddItemBodySite');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  for i := 0 to value.siteList.Count - 1 do
      ComposeCodeableReference(this, 'ClaimResponse.addItem.bodySite', 'site', value.siteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subSiteList.Count - 1 do
      ComposeCodeableConcept(this, 'ClaimResponse.addItem.bodySite', 'subSite', value.subSiteList[i], false, i);
end;

function TFHIRTurtleParser.ParseClaimResponseAddItemDetail(obj : TTurtleComplex) : TFhirClaimResponseAddItemDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseAddItemDetail.create;
  try
    ParseClaimResponseAddItemDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseAddItemDetailProperties(obj : TTurtleComplex; value : TFhirClaimResponseAddItemDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.revenue'));
    value.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.productOrService'));
    value.productOrServiceEnd := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.productOrServiceEnd'));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.detail.modifier') do
      value.modifierList.Add(parseCodeableConcept(item));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.quantity'));
    value.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.unitPrice'));
    value.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.factor'));
    value.tax := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.tax'));
    value.net := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.net'));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.detail.noteNumber') do
      value.noteNumberList.Add(parsePositiveInt(item));
    value.decision := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.decision'));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.detail.adjudication') do
      value.adjudicationList.Add(parseClaimResponseItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.detail.subDetail') do
      value.subDetailList.Add(parseClaimResponseAddItemDetailSubDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseAddItemDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponseAddItemDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseAddItemDetail');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.addItem.detail', 'revenue', value.revenueElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.addItem.detail', 'productOrService', value.productOrServiceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.addItem.detail', 'productOrServiceEnd', value.productOrServiceEndElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ClaimResponse.addItem.detail', 'modifier', value.modifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ClaimResponse.addItem.detail', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ClaimResponse.addItem.detail', 'unitPrice', value.unitPriceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ClaimResponse.addItem.detail', 'factor', value.factorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ClaimResponse.addItem.detail', 'tax', value.taxElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ClaimResponse.addItem.detail', 'net', value.netElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.addItem.detail', 'noteNumber', value.noteNumberList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.addItem.detail', 'decision', value.decisionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(this, 'ClaimResponse.addItem.detail', 'adjudication', value.adjudicationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subDetailList.Count - 1 do
      ComposeClaimResponseAddItemDetailSubDetail(this, 'ClaimResponse.addItem.detail', 'subDetail', value.subDetailList[i], false, i);
end;

function TFHIRTurtleParser.ParseClaimResponseAddItemDetailSubDetail(obj : TTurtleComplex) : TFhirClaimResponseAddItemDetailSubDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseAddItemDetailSubDetail.create;
  try
    ParseClaimResponseAddItemDetailSubDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseAddItemDetailSubDetailProperties(obj : TTurtleComplex; value : TFhirClaimResponseAddItemDetailSubDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.subDetail.revenue'));
    value.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.subDetail.productOrService'));
    value.productOrServiceEnd := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.subDetail.productOrServiceEnd'));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.detail.subDetail.modifier') do
      value.modifierList.Add(parseCodeableConcept(item));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.subDetail.quantity'));
    value.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.subDetail.unitPrice'));
    value.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.subDetail.factor'));
    value.tax := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.subDetail.tax'));
    value.net := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.subDetail.net'));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.detail.subDetail.noteNumber') do
      value.noteNumberList.Add(parsePositiveInt(item));
    value.decision := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.subDetail.decision'));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.detail.subDetail.adjudication') do
      value.adjudicationList.Add(parseClaimResponseItemAdjudication(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseAddItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponseAddItemDetailSubDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseAddItemDetailSubDetail');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.addItem.detail.subDetail', 'revenue', value.revenueElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.addItem.detail.subDetail', 'productOrService', value.productOrServiceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.addItem.detail.subDetail', 'productOrServiceEnd', value.productOrServiceEndElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ClaimResponse.addItem.detail.subDetail', 'modifier', value.modifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ClaimResponse.addItem.detail.subDetail', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ClaimResponse.addItem.detail.subDetail', 'unitPrice', value.unitPriceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ClaimResponse.addItem.detail.subDetail', 'factor', value.factorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ClaimResponse.addItem.detail.subDetail', 'tax', value.taxElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ClaimResponse.addItem.detail.subDetail', 'net', value.netElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.addItem.detail.subDetail', 'noteNumber', value.noteNumberList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.addItem.detail.subDetail', 'decision', value.decisionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(this, 'ClaimResponse.addItem.detail.subDetail', 'adjudication', value.adjudicationList[i], false, i);
end;

function TFHIRTurtleParser.ParseClaimResponseTotal(obj : TTurtleComplex) : TFhirClaimResponseTotal;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseTotal.create;
  try
    ParseClaimResponseTotalProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseTotalProperties(obj : TTurtleComplex; value : TFhirClaimResponseTotal);
begin
    ParseBackboneElementProperties(obj, value);
    value.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.total.category'));
    value.amount := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.total.amount'));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseTotal(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponseTotal; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseTotal');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'ClaimResponse.total', 'category', value.categoryElement, false, -1);
  ComposeMoney(this, 'ClaimResponse.total', 'amount', value.amountElement, false, -1);
end;

function TFHIRTurtleParser.ParseClaimResponsePayment(obj : TTurtleComplex) : TFhirClaimResponsePayment;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponsePayment.create;
  try
    ParseClaimResponsePaymentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponsePaymentProperties(obj : TTurtleComplex; value : TFhirClaimResponsePayment);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.payment.type'));
    value.adjustment := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.payment.adjustment'));
    value.adjustmentReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.payment.adjustmentReason'));
    value.dateElement := ParseDate(obj.complex('http://hl7.org/fhir/ClaimResponse.payment.date'));
    value.amount := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.payment.amount'));
    value.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/ClaimResponse.payment.identifier'));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponsePayment(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponsePayment; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponsePayment');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'ClaimResponse.payment', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ClaimResponse.payment', 'adjustment', value.adjustmentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.payment', 'adjustmentReason', value.adjustmentReasonElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'ClaimResponse.payment', 'date', value.dateElement, false, -1);
  ComposeMoney(this, 'ClaimResponse.payment', 'amount', value.amountElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'ClaimResponse.payment', 'identifier', value.identifierElement, false, -1);
end;

function TFHIRTurtleParser.ParseClaimResponseProcessNote(obj : TTurtleComplex) : TFhirClaimResponseProcessNote;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseProcessNote.create;
  try
    ParseClaimResponseProcessNoteProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseProcessNoteProperties(obj : TTurtleComplex; value : TFhirClaimResponseProcessNote);
begin
    ParseBackboneElementProperties(obj, value);
    value.numberElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.processNote.number'));
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ClaimResponse.processNote.type'), CODES_TFhirNoteTypeEnum, SYSTEMS_TFhirNoteTypeEnum);
    value.textElement := ParseString(obj.complex('http://hl7.org/fhir/ClaimResponse.processNote.text'));
    value.language := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.processNote.language'));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseProcessNote(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponseProcessNote; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseProcessNote');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'ClaimResponse.processNote', 'number', value.numberElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'ClaimResponse.processNote', 'type', value.type_Element, CODES_TFhirNoteTypeEnum, SYSTEMS_TFhirNoteTypeEnum, false, -1);
  ComposeString(this, 'ClaimResponse.processNote', 'text', value.textElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.processNote', 'language', value.languageElement, false, -1);
end;

function TFHIRTurtleParser.ParseClaimResponseInsurance(obj : TTurtleComplex) : TFhirClaimResponseInsurance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseInsurance.create;
  try
    ParseClaimResponseInsuranceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseInsuranceProperties(obj : TTurtleComplex; value : TFhirClaimResponseInsurance);
begin
    ParseBackboneElementProperties(obj, value);
    value.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.insurance.sequence'));
    value.focalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ClaimResponse.insurance.focal'));
    value.coverage := ParseReference(obj.complex('http://hl7.org/fhir/ClaimResponse.insurance.coverage'));
    value.businessArrangementElement := ParseString(obj.complex('http://hl7.org/fhir/ClaimResponse.insurance.businessArrangement'));
    value.claimResponse := ParseReference(obj.complex('http://hl7.org/fhir/ClaimResponse.insurance.claimResponse'));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseInsurance(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponseInsurance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseInsurance');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposePositiveInt(this, 'ClaimResponse.insurance', 'sequence', value.sequenceElement, false, -1);
  ComposeBoolean(this, 'ClaimResponse.insurance', 'focal', value.focalElement, false, -1);
  ComposeReference(this, 'ClaimResponse.insurance', 'coverage', value.coverageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ClaimResponse.insurance', 'businessArrangement', value.businessArrangementElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ClaimResponse.insurance', 'claimResponse', value.claimResponseElement, false, -1);
end;

function TFHIRTurtleParser.ParseClaimResponseError(obj : TTurtleComplex) : TFhirClaimResponseError;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseError.create;
  try
    ParseClaimResponseErrorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseErrorProperties(obj : TTurtleComplex; value : TFhirClaimResponseError);
begin
    ParseBackboneElementProperties(obj, value);
    value.itemSequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.error.itemSequence'));
    value.detailSequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.error.detailSequence'));
    value.subDetailSequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.error.subDetailSequence'));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.error.code'));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseError(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponseError; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseError');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'ClaimResponse.error', 'itemSequence', value.itemSequenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'ClaimResponse.error', 'detailSequence', value.detailSequenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'ClaimResponse.error', 'subDetailSequence', value.subDetailSequenceElement, false, -1);
  ComposeCodeableConcept(this, 'ClaimResponse.error', 'code', value.codeElement, false, -1);
end;

function TFHIRTurtleParser.ParseClaimResponse(obj : TTurtleComplex) : TFhirClaimResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponse.create;
  try
    ParseClaimResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseProperties(obj : TTurtleComplex; value : TFhirClaimResponse);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ClaimResponse.status'), CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.type'));
    value.subType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.subType'));
    value.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/ClaimResponse.use'), CODES_TFhirUseEnum, SYSTEMS_TFhirUseEnum);
    value.patient := ParseReference(obj.complex('http://hl7.org/fhir/ClaimResponse.patient'));
    value.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ClaimResponse.created'));
    value.insurer := ParseReference(obj.complex('http://hl7.org/fhir/ClaimResponse.insurer'));
    value.requestor := ParseReference(obj.complex('http://hl7.org/fhir/ClaimResponse.requestor'));
    value.request := ParseReference(obj.complex('http://hl7.org/fhir/ClaimResponse.request'));
    value.outcomeElement := ParseEnum(obj.complex('http://hl7.org/fhir/ClaimResponse.outcome'), CODES_TFhirClaimProcessingCodesEnum, SYSTEMS_TFhirClaimProcessingCodesEnum);
    value.decision := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.decision'));
    value.dispositionElement := ParseString(obj.complex('http://hl7.org/fhir/ClaimResponse.disposition'));
    value.preAuthRefElement := ParseString(obj.complex('http://hl7.org/fhir/ClaimResponse.preAuthRef'));
    value.preAuthPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/ClaimResponse.preAuthPeriod'));
    value.payeeType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.payeeType'));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.encounter') do
      value.encounterList.Add(parseReference(item));
    value.diagnosisRelatedGroup := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.diagnosisRelatedGroup'));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item') do
      value.itemList.Add(parseClaimResponseItem(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem') do
      value.addItemList.Add(parseClaimResponseAddItem(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.adjudication') do
      value.adjudicationList.Add(parseClaimResponseItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.total') do
      value.totalList.Add(parseClaimResponseTotal(item));
    value.payment := ParseClaimResponsePayment(obj.complex('http://hl7.org/fhir/ClaimResponse.payment'));
    value.fundsReserve := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.fundsReserve'));
    value.formCode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.formCode'));
    value.form := ParseAttachment(obj.complex('http://hl7.org/fhir/ClaimResponse.form'));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.processNote') do
      value.processNoteList.Add(parseClaimResponseProcessNote(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.communicationRequest') do
      value.communicationRequestList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.insurance') do
      value.insuranceList.Add(parseClaimResponseInsurance(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.error') do
      value.errorList.Add(parseClaimResponseError(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponse(parent :  TTurtleComplex; parentType, name : String; value : TFhirClaimResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponse');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ClaimResponse', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'ClaimResponse', 'status', value.statusElement, CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum, false, -1);
  ComposeCodeableConcept(this, 'ClaimResponse', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse', 'subType', value.subTypeElement, false, -1);
  ComposeEnum(this, 'ClaimResponse', 'use', value.useElement, CODES_TFhirUseEnum, SYSTEMS_TFhirUseEnum, false, -1);
  ComposeReference(this, 'ClaimResponse', 'patient', value.patientElement, false, -1);
  ComposeDateTime(this, 'ClaimResponse', 'created', value.createdElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'ClaimResponse', 'insurer', value.insurerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ClaimResponse', 'requestor', value.requestorElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'ClaimResponse', 'request', value.requestElement, false, -1);
  ComposeEnum(this, 'ClaimResponse', 'outcome', value.outcomeElement, CODES_TFhirClaimProcessingCodesEnum, SYSTEMS_TFhirClaimProcessingCodesEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse', 'decision', value.decisionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ClaimResponse', 'disposition', value.dispositionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ClaimResponse', 'preAuthRef', value.preAuthRefElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'ClaimResponse', 'preAuthPeriod', value.preAuthPeriodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse', 'payeeType', value.payeeTypeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.encounterList.Count - 1 do
      ComposeReference(this, 'ClaimResponse', 'encounter', value.encounterList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse', 'diagnosisRelatedGroup', value.diagnosisRelatedGroupElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.itemList.Count - 1 do
      ComposeClaimResponseItem(this, 'ClaimResponse', 'item', value.itemList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.addItemList.Count - 1 do
      ComposeClaimResponseAddItem(this, 'ClaimResponse', 'addItem', value.addItemList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(this, 'ClaimResponse', 'adjudication', value.adjudicationList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.totalList.Count - 1 do
      ComposeClaimResponseTotal(this, 'ClaimResponse', 'total', value.totalList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeClaimResponsePayment(this, 'ClaimResponse', 'payment', value.paymentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse', 'fundsReserve', value.fundsReserveElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse', 'formCode', value.formCodeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeAttachment(this, 'ClaimResponse', 'form', value.formElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.processNoteList.Count - 1 do
      ComposeClaimResponseProcessNote(this, 'ClaimResponse', 'processNote', value.processNoteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.communicationRequestList.Count - 1 do
      ComposeReference(this, 'ClaimResponse', 'communicationRequest', value.communicationRequestList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.insuranceList.Count - 1 do
      ComposeClaimResponseInsurance(this, 'ClaimResponse', 'insurance', value.insuranceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.errorList.Count - 1 do
      ComposeClaimResponseError(this, 'ClaimResponse', 'error', value.errorList[i], false, i);
end;

{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
function TFHIRTurtleParser.ParseClinicalImpressionFinding(obj : TTurtleComplex) : TFhirClinicalImpressionFinding;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClinicalImpressionFinding.create;
  try
    ParseClinicalImpressionFindingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClinicalImpressionFindingProperties(obj : TTurtleComplex; value : TFhirClinicalImpressionFinding);
begin
    ParseBackboneElementProperties(obj, value);
    value.item := ParseCodeableReference(obj.complex('http://hl7.org/fhir/ClinicalImpression.finding.item'));
    value.basisElement := ParseString(obj.complex('http://hl7.org/fhir/ClinicalImpression.finding.basis'));
end;

procedure TFHIRTurtleComposer.ComposeClinicalImpressionFinding(parent :  TTurtleComplex; parentType, name : String; value : TFhirClinicalImpressionFinding; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClinicalImpressionFinding');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(this, 'ClinicalImpression.finding', 'item', value.itemElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ClinicalImpression.finding', 'basis', value.basisElement, false, -1);
end;

function TFHIRTurtleParser.ParseClinicalImpression(obj : TTurtleComplex) : TFhirClinicalImpression;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClinicalImpression.create;
  try
    ParseClinicalImpressionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClinicalImpressionProperties(obj : TTurtleComplex; value : TFhirClinicalImpression);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ClinicalImpression.status'), CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum);
    value.statusReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClinicalImpression.statusReason'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ClinicalImpression.description'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/ClinicalImpression.subject'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/ClinicalImpression.encounter'));
    if obj.has('effectivePeriod', item) then
      value.effective := parsePeriod(item);
    if obj.has('effectiveDateTime', item) then
      value.effective := parseDateTime(item);
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ClinicalImpression.date'));
    value.performer := ParseReference(obj.complex('http://hl7.org/fhir/ClinicalImpression.performer'));
    value.previous := ParseReference(obj.complex('http://hl7.org/fhir/ClinicalImpression.previous'));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.problem') do
      value.problemList.Add(parseReference(item));
    value.changePattern := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClinicalImpression.changePattern'));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.protocol') do
      value.protocolList.Add(parseUri(item));
    value.summaryElement := ParseString(obj.complex('http://hl7.org/fhir/ClinicalImpression.summary'));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.finding') do
      value.findingList.Add(parseClinicalImpressionFinding(item));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.prognosisCodeableConcept') do
      value.prognosisCodeableConceptList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.prognosisReference') do
      value.prognosisReferenceList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.supportingInfo') do
      value.supportingInfoList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.note') do
      value.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeClinicalImpression(parent :  TTurtleComplex; parentType, name : String; value : TFhirClinicalImpression; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClinicalImpression');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ClinicalImpression', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'ClinicalImpression', 'status', value.statusElement, CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClinicalImpression', 'statusReason', value.statusReasonElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ClinicalImpression', 'description', value.descriptionElement, false, -1);
  ComposeReference(this, 'ClinicalImpression', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'ClinicalImpression', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.effective is TFhirPeriod) {6} then
    ComposePeriod(this, 'ClinicalImpression', 'effectivePeriod', TFhirPeriod(value.effective), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.effective is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ClinicalImpression', 'effectiveDateTime', TFhirDateTime(value.effective), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ClinicalImpression', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'ClinicalImpression', 'performer', value.performerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ClinicalImpression', 'previous', value.previousElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.problemList.Count - 1 do
      ComposeReference(this, 'ClinicalImpression', 'problem', value.problemList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClinicalImpression', 'changePattern', value.changePatternElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.protocolList.Count - 1 do
      ComposeUri(this, 'ClinicalImpression', 'protocol', value.protocolList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ClinicalImpression', 'summary', value.summaryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.findingList.Count - 1 do
      ComposeClinicalImpressionFinding(this, 'ClinicalImpression', 'finding', value.findingList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.prognosisCodeableConceptList.Count - 1 do
      ComposeCodeableConcept(this, 'ClinicalImpression', 'prognosisCodeableConcept', value.prognosisCodeableConceptList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.prognosisReferenceList.Count - 1 do
      ComposeReference(this, 'ClinicalImpression', 'prognosisReference', value.prognosisReferenceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInfoList.Count - 1 do
      ComposeReference(this, 'ClinicalImpression', 'supportingInfo', value.supportingInfoList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'ClinicalImpression', 'note', value.noteList[i], false, i);
end;

{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CLINICALUSEDEFINITION}
function TFHIRTurtleParser.ParseClinicalUseDefinitionContraindication(obj : TTurtleComplex) : TFhirClinicalUseDefinitionContraindication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClinicalUseDefinitionContraindication.create;
  try
    ParseClinicalUseDefinitionContraindicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClinicalUseDefinitionContraindicationProperties(obj : TTurtleComplex; value : TFhirClinicalUseDefinitionContraindication);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.diseaseSymptomProcedure := ParseCodeableReference(obj.complex('http://hl7.org/fhir/ClinicalUseDefinition.contraindication.diseaseSymptomProcedure'));
    value.diseaseStatus := ParseCodeableReference(obj.complex('http://hl7.org/fhir/ClinicalUseDefinition.contraindication.diseaseStatus'));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalUseDefinition.contraindication.comorbidity') do
      value.comorbidityList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalUseDefinition.contraindication.indication') do
      value.indicationList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalUseDefinition.contraindication.otherTherapy') do
      value.otherTherapyList.Add(parseClinicalUseDefinitionContraindicationOtherTherapy(item));
end;

procedure TFHIRTurtleComposer.ComposeClinicalUseDefinitionContraindication(parent :  TTurtleComplex; parentType, name : String; value : TFhirClinicalUseDefinitionContraindication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClinicalUseDefinitionContraindication');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(this, 'ClinicalUseDefinition.contraindication', 'diseaseSymptomProcedure', value.diseaseSymptomProcedureElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(this, 'ClinicalUseDefinition.contraindication', 'diseaseStatus', value.diseaseStatusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.comorbidityList.Count - 1 do
      ComposeCodeableReference(this, 'ClinicalUseDefinition.contraindication', 'comorbidity', value.comorbidityList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.indicationList.Count - 1 do
      ComposeReference(this, 'ClinicalUseDefinition.contraindication', 'indication', value.indicationList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.otherTherapyList.Count - 1 do
      ComposeClinicalUseDefinitionContraindicationOtherTherapy(this, 'ClinicalUseDefinition.contraindication', 'otherTherapy', value.otherTherapyList[i], false, i);
end;

function TFHIRTurtleParser.ParseClinicalUseDefinitionContraindicationOtherTherapy(obj : TTurtleComplex) : TFhirClinicalUseDefinitionContraindicationOtherTherapy;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClinicalUseDefinitionContraindicationOtherTherapy.create;
  try
    ParseClinicalUseDefinitionContraindicationOtherTherapyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClinicalUseDefinitionContraindicationOtherTherapyProperties(obj : TTurtleComplex; value : TFhirClinicalUseDefinitionContraindicationOtherTherapy);
begin
    ParseBackboneElementProperties(obj, value);
    value.relationshipType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClinicalUseDefinition.contraindication.otherTherapy.relationshipType'));
    value.treatment := ParseCodeableReference(obj.complex('http://hl7.org/fhir/ClinicalUseDefinition.contraindication.otherTherapy.treatment'));
end;

procedure TFHIRTurtleComposer.ComposeClinicalUseDefinitionContraindicationOtherTherapy(parent :  TTurtleComplex; parentType, name : String; value : TFhirClinicalUseDefinitionContraindicationOtherTherapy; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClinicalUseDefinitionContraindicationOtherTherapy');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'ClinicalUseDefinition.contraindication.otherTherapy', 'relationshipType', value.relationshipTypeElement, false, -1);
  ComposeCodeableReference(this, 'ClinicalUseDefinition.contraindication.otherTherapy', 'treatment', value.treatmentElement, false, -1);
end;

function TFHIRTurtleParser.ParseClinicalUseDefinitionIndication(obj : TTurtleComplex) : TFhirClinicalUseDefinitionIndication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClinicalUseDefinitionIndication.create;
  try
    ParseClinicalUseDefinitionIndicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClinicalUseDefinitionIndicationProperties(obj : TTurtleComplex; value : TFhirClinicalUseDefinitionIndication);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.diseaseSymptomProcedure := ParseCodeableReference(obj.complex('http://hl7.org/fhir/ClinicalUseDefinition.indication.diseaseSymptomProcedure'));
    value.diseaseStatus := ParseCodeableReference(obj.complex('http://hl7.org/fhir/ClinicalUseDefinition.indication.diseaseStatus'));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalUseDefinition.indication.comorbidity') do
      value.comorbidityList.Add(parseCodeableReference(item));
    value.intendedEffect := ParseCodeableReference(obj.complex('http://hl7.org/fhir/ClinicalUseDefinition.indication.intendedEffect'));
    if obj.has('durationRange', item) then
      value.duration := parseRange(item);
    if obj.has('durationString', item) then
      value.duration := parseString(item);
    for item in obj.complexes('http://hl7.org/fhir/ClinicalUseDefinition.indication.undesirableEffect') do
      value.undesirableEffectList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalUseDefinition.indication.otherTherapy') do
      value.otherTherapyList.Add(parseClinicalUseDefinitionContraindicationOtherTherapy(item));
end;

procedure TFHIRTurtleComposer.ComposeClinicalUseDefinitionIndication(parent :  TTurtleComplex; parentType, name : String; value : TFhirClinicalUseDefinitionIndication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClinicalUseDefinitionIndication');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(this, 'ClinicalUseDefinition.indication', 'diseaseSymptomProcedure', value.diseaseSymptomProcedureElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(this, 'ClinicalUseDefinition.indication', 'diseaseStatus', value.diseaseStatusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.comorbidityList.Count - 1 do
      ComposeCodeableReference(this, 'ClinicalUseDefinition.indication', 'comorbidity', value.comorbidityList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(this, 'ClinicalUseDefinition.indication', 'intendedEffect', value.intendedEffectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.duration is TFhirRange) {6} then
    ComposeRange(this, 'ClinicalUseDefinition.indication', 'durationRange', TFhirRange(value.duration), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.duration is TFhirString) {6} then
    ComposeString(this, 'ClinicalUseDefinition.indication', 'durationString', TFhirString(value.duration), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.undesirableEffectList.Count - 1 do
      ComposeReference(this, 'ClinicalUseDefinition.indication', 'undesirableEffect', value.undesirableEffectList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.otherTherapyList.Count - 1 do
      ComposeClinicalUseDefinitionContraindicationOtherTherapy(this, 'ClinicalUseDefinition.indication', 'otherTherapy', value.otherTherapyList[i], false, i);
end;

function TFHIRTurtleParser.ParseClinicalUseDefinitionInteraction(obj : TTurtleComplex) : TFhirClinicalUseDefinitionInteraction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClinicalUseDefinitionInteraction.create;
  try
    ParseClinicalUseDefinitionInteractionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClinicalUseDefinitionInteractionProperties(obj : TTurtleComplex; value : TFhirClinicalUseDefinitionInteraction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/ClinicalUseDefinition.interaction.interactant') do
      value.interactantList.Add(parseClinicalUseDefinitionInteractionInteractant(item));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClinicalUseDefinition.interaction.type'));
    value.effect := ParseCodeableReference(obj.complex('http://hl7.org/fhir/ClinicalUseDefinition.interaction.effect'));
    value.incidence := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClinicalUseDefinition.interaction.incidence'));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalUseDefinition.interaction.management') do
      value.managementList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeClinicalUseDefinitionInteraction(parent :  TTurtleComplex; parentType, name : String; value : TFhirClinicalUseDefinitionInteraction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClinicalUseDefinitionInteraction');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.interactantList.Count - 1 do
      ComposeClinicalUseDefinitionInteractionInteractant(this, 'ClinicalUseDefinition.interaction', 'interactant', value.interactantList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ClinicalUseDefinition.interaction', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(this, 'ClinicalUseDefinition.interaction', 'effect', value.effectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ClinicalUseDefinition.interaction', 'incidence', value.incidenceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.managementList.Count - 1 do
      ComposeCodeableConcept(this, 'ClinicalUseDefinition.interaction', 'management', value.managementList[i], false, i);
end;

function TFHIRTurtleParser.ParseClinicalUseDefinitionInteractionInteractant(obj : TTurtleComplex) : TFhirClinicalUseDefinitionInteractionInteractant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClinicalUseDefinitionInteractionInteractant.create;
  try
    ParseClinicalUseDefinitionInteractionInteractantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClinicalUseDefinitionInteractionInteractantProperties(obj : TTurtleComplex; value : TFhirClinicalUseDefinitionInteractionInteractant);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('itemReference', item) {a3} then
      value.item := ParseReference(item);
    if obj.has('itemCodeableConcept', item) then
      value.item := parseCodeableConcept(item);
end;

procedure TFHIRTurtleComposer.ComposeClinicalUseDefinitionInteractionInteractant(parent :  TTurtleComplex; parentType, name : String; value : TFhirClinicalUseDefinitionInteractionInteractant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClinicalUseDefinitionInteractionInteractant');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (value.item is TFhirReference) {2} then
    ComposeReference(this, 'ClinicalUseDefinition.interaction.interactant', 'itemReference', TFhirReference(value.item), false,-1)
  else if (value.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ClinicalUseDefinition.interaction.interactant', 'itemCodeableConcept', TFhirCodeableConcept(value.item), false, -1);
end;

function TFHIRTurtleParser.ParseClinicalUseDefinitionUndesirableEffect(obj : TTurtleComplex) : TFhirClinicalUseDefinitionUndesirableEffect;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClinicalUseDefinitionUndesirableEffect.create;
  try
    ParseClinicalUseDefinitionUndesirableEffectProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClinicalUseDefinitionUndesirableEffectProperties(obj : TTurtleComplex; value : TFhirClinicalUseDefinitionUndesirableEffect);
begin
    ParseBackboneElementProperties(obj, value);
    value.symptomConditionEffect := ParseCodeableReference(obj.complex('http://hl7.org/fhir/ClinicalUseDefinition.undesirableEffect.symptomConditionEffect'));
    value.classification := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClinicalUseDefinition.undesirableEffect.classification'));
    value.frequencyOfOccurrence := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClinicalUseDefinition.undesirableEffect.frequencyOfOccurrence'));
end;

procedure TFHIRTurtleComposer.ComposeClinicalUseDefinitionUndesirableEffect(parent :  TTurtleComplex; parentType, name : String; value : TFhirClinicalUseDefinitionUndesirableEffect; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClinicalUseDefinitionUndesirableEffect');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(this, 'ClinicalUseDefinition.undesirableEffect', 'symptomConditionEffect', value.symptomConditionEffectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ClinicalUseDefinition.undesirableEffect', 'classification', value.classificationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ClinicalUseDefinition.undesirableEffect', 'frequencyOfOccurrence', value.frequencyOfOccurrenceElement, false, -1);
end;

function TFHIRTurtleParser.ParseClinicalUseDefinitionWarning(obj : TTurtleComplex) : TFhirClinicalUseDefinitionWarning;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClinicalUseDefinitionWarning.create;
  try
    ParseClinicalUseDefinitionWarningProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClinicalUseDefinitionWarningProperties(obj : TTurtleComplex; value : TFhirClinicalUseDefinitionWarning);
begin
    ParseBackboneElementProperties(obj, value);
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ClinicalUseDefinition.warning.description'));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClinicalUseDefinition.warning.code'));
end;

procedure TFHIRTurtleComposer.ComposeClinicalUseDefinitionWarning(parent :  TTurtleComplex; parentType, name : String; value : TFhirClinicalUseDefinitionWarning; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClinicalUseDefinitionWarning');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'ClinicalUseDefinition.warning', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ClinicalUseDefinition.warning', 'code', value.codeElement, false, -1);
end;

function TFHIRTurtleParser.ParseClinicalUseDefinition(obj : TTurtleComplex) : TFhirClinicalUseDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClinicalUseDefinition.create;
  try
    ParseClinicalUseDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClinicalUseDefinitionProperties(obj : TTurtleComplex; value : TFhirClinicalUseDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/ClinicalUseDefinition.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ClinicalUseDefinition.type'), CODES_TFhirClinicalUseDefinitionTypeEnum, SYSTEMS_TFhirClinicalUseDefinitionTypeEnum);
    for item in obj.complexes('http://hl7.org/fhir/ClinicalUseDefinition.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalUseDefinition.subject') do
      value.subjectList.Add(parseReference(item));
    value.status := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClinicalUseDefinition.status'));
    value.contraindication := ParseClinicalUseDefinitionContraindication(obj.complex('http://hl7.org/fhir/ClinicalUseDefinition.contraindication'));
    value.indication := ParseClinicalUseDefinitionIndication(obj.complex('http://hl7.org/fhir/ClinicalUseDefinition.indication'));
    value.interaction := ParseClinicalUseDefinitionInteraction(obj.complex('http://hl7.org/fhir/ClinicalUseDefinition.interaction'));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalUseDefinition.population') do
      value.populationList.Add(parseReference(item));
    value.undesirableEffect := ParseClinicalUseDefinitionUndesirableEffect(obj.complex('http://hl7.org/fhir/ClinicalUseDefinition.undesirableEffect'));
    value.warning := ParseClinicalUseDefinitionWarning(obj.complex('http://hl7.org/fhir/ClinicalUseDefinition.warning'));
end;

procedure TFHIRTurtleComposer.ComposeClinicalUseDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirClinicalUseDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClinicalUseDefinition');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ClinicalUseDefinition', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'ClinicalUseDefinition', 'type', value.type_Element, CODES_TFhirClinicalUseDefinitionTypeEnum, SYSTEMS_TFhirClinicalUseDefinitionTypeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'ClinicalUseDefinition', 'category', value.categoryList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.subjectList.Count - 1 do
      ComposeReference(this, 'ClinicalUseDefinition', 'subject', value.subjectList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ClinicalUseDefinition', 'status', value.statusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeClinicalUseDefinitionContraindication(this, 'ClinicalUseDefinition', 'contraindication', value.contraindicationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeClinicalUseDefinitionIndication(this, 'ClinicalUseDefinition', 'indication', value.indicationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeClinicalUseDefinitionInteraction(this, 'ClinicalUseDefinition', 'interaction', value.interactionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.populationList.Count - 1 do
      ComposeReference(this, 'ClinicalUseDefinition', 'population', value.populationList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeClinicalUseDefinitionUndesirableEffect(this, 'ClinicalUseDefinition', 'undesirableEffect', value.undesirableEffectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeClinicalUseDefinitionWarning(this, 'ClinicalUseDefinition', 'warning', value.warningElement, false, -1);
end;

{$ENDIF FHIR_CLINICALUSEDEFINITION}
{$IFDEF FHIR_CODESYSTEM}
function TFHIRTurtleParser.ParseCodeSystemFilter(obj : TTurtleComplex) : TFhirCodeSystemFilter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCodeSystemFilter.create;
  try
    ParseCodeSystemFilterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodeSystemFilterProperties(obj : TTurtleComplex; value : TFhirCodeSystemFilter);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/CodeSystem.filter.code'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.filter.description'));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.filter.operator') do
      value.operatorList.Add(parseEnum(item, CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum));
    value.valueElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.filter.value'));
end;

procedure TFHIRTurtleComposer.ComposeCodeSystemFilter(parent :  TTurtleComplex; parentType, name : String; value : TFhirCodeSystemFilter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CodeSystemFilter');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCode(this, 'CodeSystem.filter', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'CodeSystem.filter', 'description', value.descriptionElement, false, -1);
  for i := 0 to value.operatorList.Count - 1 do
      ComposeEnum(this, 'CodeSystem.filter', 'operator', value.operatorList[i], CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum, false, i); {x.d1}
  for i := 0 to value.operatorList.Count - 1 do
      ComposeEnum(this, 'CodeSystem.filter', 'operator', value.operatorList[i], CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum, false, i);
  ComposeString(this, 'CodeSystem.filter', 'value', value.valueElement, false, -1);
end;

function TFHIRTurtleParser.ParseCodeSystemProperty(obj : TTurtleComplex) : TFhirCodeSystemProperty;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCodeSystemProperty.create;
  try
    ParseCodeSystemPropertyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodeSystemPropertyProperties(obj : TTurtleComplex; value : TFhirCodeSystemProperty);
begin
    ParseBackboneElementProperties(obj, value);
    value.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/CodeSystem.property.code'));
    value.uriElement := ParseUri(obj.complex('http://hl7.org/fhir/CodeSystem.property.uri'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.property.description'));
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/CodeSystem.property.type'), CODES_TFhirConceptPropertyTypeEnum, SYSTEMS_TFhirConceptPropertyTypeEnum);
end;

procedure TFHIRTurtleComposer.ComposeCodeSystemProperty(parent :  TTurtleComplex; parentType, name : String; value : TFhirCodeSystemProperty; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CodeSystemProperty');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCode(this, 'CodeSystem.property', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'CodeSystem.property', 'uri', value.uriElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'CodeSystem.property', 'description', value.descriptionElement, false, -1);
  ComposeEnum(this, 'CodeSystem.property', 'type', value.type_Element, CODES_TFhirConceptPropertyTypeEnum, SYSTEMS_TFhirConceptPropertyTypeEnum, false, -1);
end;

function TFHIRTurtleParser.ParseCodeSystemConcept(obj : TTurtleComplex) : TFhirCodeSystemConcept;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCodeSystemConcept.create;
  try
    ParseCodeSystemConceptProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodeSystemConceptProperties(obj : TTurtleComplex; value : TFhirCodeSystemConcept);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/CodeSystem.concept.code'));
    value.displayElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.concept.display'));
    value.definitionElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.concept.definition'));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.concept.designation') do
      value.designationList.Add(parseCodeSystemConceptDesignation(item));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.concept.property') do
      value.property_List.Add(parseCodeSystemConceptProperty(item));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.concept.concept') do
      value.conceptList.Add(parseCodeSystemConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeCodeSystemConcept(parent :  TTurtleComplex; parentType, name : String; value : TFhirCodeSystemConcept; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CodeSystemConcept');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCode(this, 'CodeSystem.concept', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CodeSystem.concept', 'display', value.displayElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CodeSystem.concept', 'definition', value.definitionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.designationList.Count - 1 do
      ComposeCodeSystemConceptDesignation(this, 'CodeSystem.concept', 'designation', value.designationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeCodeSystemConceptProperty(this, 'CodeSystem.concept', 'property', value.property_List[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.conceptList.Count - 1 do
      ComposeCodeSystemConcept(this, 'CodeSystem.concept', 'concept', value.conceptList[i], false, i);
end;

function TFHIRTurtleParser.ParseCodeSystemConceptDesignation(obj : TTurtleComplex) : TFhirCodeSystemConceptDesignation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCodeSystemConceptDesignation.create;
  try
    ParseCodeSystemConceptDesignationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodeSystemConceptDesignationProperties(obj : TTurtleComplex; value : TFhirCodeSystemConceptDesignation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.languageElement := ParseCode(obj.complex('http://hl7.org/fhir/CodeSystem.concept.designation.language'));
    value.use := ParseCoding(obj.complex('http://hl7.org/fhir/CodeSystem.concept.designation.use'));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.concept.designation.additionalUse') do
      value.additionalUseList.Add(parseCoding(item));
    value.valueElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.concept.designation.value'));
end;

procedure TFHIRTurtleComposer.ComposeCodeSystemConceptDesignation(parent :  TTurtleComplex; parentType, name : String; value : TFhirCodeSystemConceptDesignation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CodeSystemConceptDesignation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'CodeSystem.concept.designation', 'language', value.languageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'CodeSystem.concept.designation', 'use', value.useElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.additionalUseList.Count - 1 do
      ComposeCoding(this, 'CodeSystem.concept.designation', 'additionalUse', value.additionalUseList[i], false, i);
  ComposeString(this, 'CodeSystem.concept.designation', 'value', value.valueElement, false, -1);
end;

function TFHIRTurtleParser.ParseCodeSystemConceptProperty(obj : TTurtleComplex) : TFhirCodeSystemConceptProperty;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCodeSystemConceptProperty.create;
  try
    ParseCodeSystemConceptPropertyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodeSystemConceptPropertyProperties(obj : TTurtleComplex; value : TFhirCodeSystemConceptProperty);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/CodeSystem.concept.property.code'));
    if obj.has('valueCode', item) then
      value.value := parseCode(item);
    if obj.has('valueCoding', item) then
      value.value := parseCoding(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    if obj.has('valueInteger', item) then
      value.value := parseInteger(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    if obj.has('valueDateTime', item) then
      value.value := parseDateTime(item);
    if obj.has('valueDecimal', item) then
      value.value := parseDecimal(item);
end;

procedure TFHIRTurtleComposer.ComposeCodeSystemConceptProperty(parent :  TTurtleComplex; parentType, name : String; value : TFhirCodeSystemConceptProperty; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CodeSystemConceptProperty');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCode(this, 'CodeSystem.concept.property', 'code', value.codeElement, false, -1);
  if (value.value is TFhirCode) {6} then
    ComposeCode(this, 'CodeSystem.concept.property', 'valueCode', TFhirCode(value.value), false, -1)
  else if (value.value is TFhirCoding) {6} then
    ComposeCoding(this, 'CodeSystem.concept.property', 'valueCoding', TFhirCoding(value.value), false, -1)
  else if (value.value is TFhirString) {6} then
    ComposeString(this, 'CodeSystem.concept.property', 'valueString', TFhirString(value.value), false, -1)
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(this, 'CodeSystem.concept.property', 'valueInteger', TFhirInteger(value.value), false, -1)
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'CodeSystem.concept.property', 'valueBoolean', TFhirBoolean(value.value), false, -1)
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'CodeSystem.concept.property', 'valueDateTime', TFhirDateTime(value.value), false, -1)
  else if (value.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'CodeSystem.concept.property', 'valueDecimal', TFhirDecimal(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseCodeSystem(obj : TTurtleComplex) : TFhirCodeSystem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCodeSystem.create;
  try
    ParseCodeSystemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodeSystemProperties(obj : TTurtleComplex; value : TFhirCodeSystem);
var
  item : TTurtleComplex;
begin
    ParseMetadataResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/CodeSystem.url'));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.version'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.title'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CodeSystem.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CodeSystem.experimental'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/CodeSystem.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CodeSystem.description'));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CodeSystem.purpose'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CodeSystem.copyright'));
    value.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/CodeSystem.approvalDate'));
    value.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/CodeSystem.lastReviewDate'));
    value.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/CodeSystem.effectivePeriod'));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.topic') do
      value.topicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.author') do
      value.authorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.editor') do
      value.editorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.reviewer') do
      value.reviewerList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.endorser') do
      value.endorserList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.relatedArtifact') do
      value.relatedArtifactList.Add(parseRelatedArtifact(item));
    value.caseSensitiveElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CodeSystem.caseSensitive'));
    value.valueSetElement := ParseCanonical(obj.complex('http://hl7.org/fhir/CodeSystem.valueSet'));
    value.hierarchyMeaningElement := ParseEnum(obj.complex('http://hl7.org/fhir/CodeSystem.hierarchyMeaning'), CODES_TFhirCodeSystemHierarchyMeaningEnum, SYSTEMS_TFhirCodeSystemHierarchyMeaningEnum);
    value.compositionalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CodeSystem.compositional'));
    value.versionNeededElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CodeSystem.versionNeeded'));
    value.contentElement := ParseEnum(obj.complex('http://hl7.org/fhir/CodeSystem.content'), CODES_TFhirCodeSystemContentModeEnum, SYSTEMS_TFhirCodeSystemContentModeEnum);
    value.supplementsElement := ParseCanonical(obj.complex('http://hl7.org/fhir/CodeSystem.supplements'));
    value.countElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/CodeSystem.count'));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.filter') do
      value.filterList.Add(parseCodeSystemFilter(item));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.property') do
      value.property_List.Add(parseCodeSystemProperty(item));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.concept') do
      value.conceptList.Add(parseCodeSystemConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeCodeSystem(parent :  TTurtleComplex; parentType, name : String; value : TFhirCodeSystem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CodeSystem');
  end;
  composeMetadataResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'CodeSystem', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'CodeSystem', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'CodeSystem', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'CodeSystem', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'CodeSystem', 'title', value.titleElement, false, -1);
  ComposeEnum(this, 'CodeSystem', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'CodeSystem', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'CodeSystem', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'CodeSystem', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'CodeSystem', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CodeSystem', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'CodeSystem', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'CodeSystem', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CodeSystem', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CodeSystem', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'CodeSystem', 'approvalDate', value.approvalDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'CodeSystem', 'lastReviewDate', value.lastReviewDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'CodeSystem', 'effectivePeriod', value.effectivePeriodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.topicList.Count - 1 do
      ComposeCodeableConcept(this, 'CodeSystem', 'topic', value.topicList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(this, 'CodeSystem', 'author', value.authorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(this, 'CodeSystem', 'editor', value.editorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(this, 'CodeSystem', 'reviewer', value.reviewerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(this, 'CodeSystem', 'endorser', value.endorserList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'CodeSystem', 'relatedArtifact', value.relatedArtifactList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'CodeSystem', 'caseSensitive', value.caseSensitiveElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(this, 'CodeSystem', 'valueSet', value.valueSetElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'CodeSystem', 'hierarchyMeaning', value.hierarchyMeaningElement, CODES_TFhirCodeSystemHierarchyMeaningEnum, SYSTEMS_TFhirCodeSystemHierarchyMeaningEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'CodeSystem', 'compositional', value.compositionalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'CodeSystem', 'versionNeeded', value.versionNeededElement, false, -1);
  ComposeEnum(this, 'CodeSystem', 'content', value.contentElement, CODES_TFhirCodeSystemContentModeEnum, SYSTEMS_TFhirCodeSystemContentModeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(this, 'CodeSystem', 'supplements', value.supplementsElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'CodeSystem', 'count', value.countElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.filterList.Count - 1 do
      ComposeCodeSystemFilter(this, 'CodeSystem', 'filter', value.filterList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeCodeSystemProperty(this, 'CodeSystem', 'property', value.property_List[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.conceptList.Count - 1 do
      ComposeCodeSystemConcept(this, 'CodeSystem', 'concept', value.conceptList[i], false, i);
end;

{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
function TFHIRTurtleParser.ParseCommunicationPayload(obj : TTurtleComplex) : TFhirCommunicationPayload;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCommunicationPayload.create;
  try
    ParseCommunicationPayloadProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCommunicationPayloadProperties(obj : TTurtleComplex; value : TFhirCommunicationPayload);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('contentAttachment', item) then
      value.content := parseAttachment(item);
    if obj.has('contentReference', item) {a3} then
      value.content := ParseReference(item);
    if obj.has('contentCodeableConcept', item) then
      value.content := parseCodeableConcept(item);
end;

procedure TFHIRTurtleComposer.ComposeCommunicationPayload(parent :  TTurtleComplex; parentType, name : String; value : TFhirCommunicationPayload; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CommunicationPayload');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (value.content is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Communication.payload', 'contentAttachment', TFhirAttachment(value.content), false, -1)
  else if (value.content is TFhirReference) {2} then
    ComposeReference(this, 'Communication.payload', 'contentReference', TFhirReference(value.content), false,-1)
  else if (value.content is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Communication.payload', 'contentCodeableConcept', TFhirCodeableConcept(value.content), false, -1);
end;

function TFHIRTurtleParser.ParseCommunication(obj : TTurtleComplex) : TFhirCommunication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCommunication.create;
  try
    ParseCommunicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCommunicationProperties(obj : TTurtleComplex; value : TFhirCommunication);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Communication.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/Communication.instantiatesCanonical') do
      value.instantiatesCanonicalList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/Communication.instantiatesUri') do
      value.instantiatesUriList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/Communication.basedOn') do
      value.basedOnList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Communication.partOf') do
      value.partOfList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Communication.inResponseTo') do
      value.inResponseToList.Add(parseReference(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Communication.status'), CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum);
    value.statusReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Communication.statusReason'));
    for item in obj.complexes('http://hl7.org/fhir/Communication.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    value.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/Communication.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    for item in obj.complexes('http://hl7.org/fhir/Communication.medium') do
      value.mediumList.Add(parseCodeableConcept(item));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/Communication.subject'));
    value.topic := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Communication.topic'));
    for item in obj.complexes('http://hl7.org/fhir/Communication.about') do
      value.aboutList.Add(parseReference(item));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/Communication.encounter'));
    value.sentElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Communication.sent'));
    value.receivedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Communication.received'));
    for item in obj.complexes('http://hl7.org/fhir/Communication.recipient') do
      value.recipientList.Add(parseReference(item));
    value.sender := ParseReference(obj.complex('http://hl7.org/fhir/Communication.sender'));
    for item in obj.complexes('http://hl7.org/fhir/Communication.reason') do
      value.reasonList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Communication.payload') do
      value.payloadList.Add(parseCommunicationPayload(item));
    for item in obj.complexes('http://hl7.org/fhir/Communication.note') do
      value.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeCommunication(parent :  TTurtleComplex; parentType, name : String; value : TFhirCommunication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Communication');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Communication', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(this, 'Communication', 'instantiatesCanonical', value.instantiatesCanonicalList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesUriList.Count - 1 do
      ComposeUri(this, 'Communication', 'instantiatesUri', value.instantiatesUriList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'Communication', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(this, 'Communication', 'partOf', value.partOfList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.inResponseToList.Count - 1 do
      ComposeReference(this, 'Communication', 'inResponseTo', value.inResponseToList[i], false, i);
  ComposeEnum(this, 'Communication', 'status', value.statusElement, CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Communication', 'statusReason', value.statusReasonElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Communication', 'category', value.categoryList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Communication', 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.mediumList.Count - 1 do
      ComposeCodeableConcept(this, 'Communication', 'medium', value.mediumList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Communication', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Communication', 'topic', value.topicElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.aboutList.Count - 1 do
      ComposeReference(this, 'Communication', 'about', value.aboutList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Communication', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Communication', 'sent', value.sentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Communication', 'received', value.receivedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.recipientList.Count - 1 do
      ComposeReference(this, 'Communication', 'recipient', value.recipientList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Communication', 'sender', value.senderElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(this, 'Communication', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.payloadList.Count - 1 do
      ComposeCommunicationPayload(this, 'Communication', 'payload', value.payloadList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'Communication', 'note', value.noteList[i], false, i);
end;

{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
function TFHIRTurtleParser.ParseCommunicationRequestPayload(obj : TTurtleComplex) : TFhirCommunicationRequestPayload;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCommunicationRequestPayload.create;
  try
    ParseCommunicationRequestPayloadProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCommunicationRequestPayloadProperties(obj : TTurtleComplex; value : TFhirCommunicationRequestPayload);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('contentAttachment', item) then
      value.content := parseAttachment(item);
    if obj.has('contentReference', item) {a3} then
      value.content := ParseReference(item);
    if obj.has('contentCodeableConcept', item) then
      value.content := parseCodeableConcept(item);
end;

procedure TFHIRTurtleComposer.ComposeCommunicationRequestPayload(parent :  TTurtleComplex; parentType, name : String; value : TFhirCommunicationRequestPayload; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CommunicationRequestPayload');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (value.content is TFhirAttachment) {6} then
    ComposeAttachment(this, 'CommunicationRequest.payload', 'contentAttachment', TFhirAttachment(value.content), false, -1)
  else if (value.content is TFhirReference) {2} then
    ComposeReference(this, 'CommunicationRequest.payload', 'contentReference', TFhirReference(value.content), false,-1)
  else if (value.content is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'CommunicationRequest.payload', 'contentCodeableConcept', TFhirCodeableConcept(value.content), false, -1);
end;

function TFHIRTurtleParser.ParseCommunicationRequest(obj : TTurtleComplex) : TFhirCommunicationRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCommunicationRequest.create;
  try
    ParseCommunicationRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCommunicationRequestProperties(obj : TTurtleComplex; value : TFhirCommunicationRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.basedOn') do
      value.basedOnList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.replaces') do
      value.replacesList.Add(parseReference(item));
    value.groupIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/CommunicationRequest.groupIdentifier'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CommunicationRequest.status'), CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum);
    value.statusReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CommunicationRequest.statusReason'));
    value.intentElement := ParseEnum(obj.complex('http://hl7.org/fhir/CommunicationRequest.intent'), CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum);
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    value.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/CommunicationRequest.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    value.doNotPerformElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CommunicationRequest.doNotPerform'));
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.medium') do
      value.mediumList.Add(parseCodeableConcept(item));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/CommunicationRequest.subject'));
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.about') do
      value.aboutList.Add(parseReference(item));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/CommunicationRequest.encounter'));
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.payload') do
      value.payloadList.Add(parseCommunicationRequestPayload(item));
    if obj.has('occurrencePeriod', item) then
      value.occurrence := parsePeriod(item);
    if obj.has('occurrenceDateTime', item) then
      value.occurrence := parseDateTime(item);
    value.authoredOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/CommunicationRequest.authoredOn'));
    value.requester := ParseReference(obj.complex('http://hl7.org/fhir/CommunicationRequest.requester'));
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.recipient') do
      value.recipientList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.informationProvider') do
      value.informationProviderList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.reason') do
      value.reasonList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.note') do
      value.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeCommunicationRequest(parent :  TTurtleComplex; parentType, name : String; value : TFhirCommunicationRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CommunicationRequest');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'CommunicationRequest', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'CommunicationRequest', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.replacesList.Count - 1 do
      ComposeReference(this, 'CommunicationRequest', 'replaces', value.replacesList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'CommunicationRequest', 'groupIdentifier', value.groupIdentifierElement, false, -1);
  ComposeEnum(this, 'CommunicationRequest', 'status', value.statusElement, CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CommunicationRequest', 'statusReason', value.statusReasonElement, false, -1);
  ComposeEnum(this, 'CommunicationRequest', 'intent', value.intentElement, CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'CommunicationRequest', 'category', value.categoryList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'CommunicationRequest', 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'CommunicationRequest', 'doNotPerform', value.doNotPerformElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.mediumList.Count - 1 do
      ComposeCodeableConcept(this, 'CommunicationRequest', 'medium', value.mediumList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'CommunicationRequest', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.aboutList.Count - 1 do
      ComposeReference(this, 'CommunicationRequest', 'about', value.aboutList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'CommunicationRequest', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.payloadList.Count - 1 do
      ComposeCommunicationRequestPayload(this, 'CommunicationRequest', 'payload', value.payloadList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'CommunicationRequest', 'occurrencePeriod', TFhirPeriod(value.occurrence), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'CommunicationRequest', 'occurrenceDateTime', TFhirDateTime(value.occurrence), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'CommunicationRequest', 'authoredOn', value.authoredOnElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'CommunicationRequest', 'requester', value.requesterElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.recipientList.Count - 1 do
      ComposeReference(this, 'CommunicationRequest', 'recipient', value.recipientList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.informationProviderList.Count - 1 do
      ComposeReference(this, 'CommunicationRequest', 'informationProvider', value.informationProviderList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(this, 'CommunicationRequest', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'CommunicationRequest', 'note', value.noteList[i], false, i);
end;

{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
function TFHIRTurtleParser.ParseCompartmentDefinitionResource(obj : TTurtleComplex) : TFhirCompartmentDefinitionResource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCompartmentDefinitionResource.create;
  try
    ParseCompartmentDefinitionResourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCompartmentDefinitionResourceProperties(obj : TTurtleComplex; value : TFhirCompartmentDefinitionResource);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CompartmentDefinition.resource.code'), CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    for item in obj.complexes('http://hl7.org/fhir/CompartmentDefinition.resource.param') do
      value.paramList.Add(parseString(item));
    value.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/CompartmentDefinition.resource.documentation'));
    value.startParamElement := ParseUri(obj.complex('http://hl7.org/fhir/CompartmentDefinition.resource.startParam'));
    value.endParamElement := ParseUri(obj.complex('http://hl7.org/fhir/CompartmentDefinition.resource.endParam'));
end;

procedure TFHIRTurtleComposer.ComposeCompartmentDefinitionResource(parent :  TTurtleComplex; parentType, name : String; value : TFhirCompartmentDefinitionResource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CompartmentDefinitionResource');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'CompartmentDefinition.resource', 'code', value.codeElement, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.paramList.Count - 1 do
      ComposeString(this, 'CompartmentDefinition.resource', 'param', value.paramList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CompartmentDefinition.resource', 'documentation', value.documentationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'CompartmentDefinition.resource', 'startParam', value.startParamElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'CompartmentDefinition.resource', 'endParam', value.endParamElement, false, -1);
end;

function TFHIRTurtleParser.ParseCompartmentDefinition(obj : TTurtleComplex) : TFhirCompartmentDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCompartmentDefinition.create;
  try
    ParseCompartmentDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCompartmentDefinitionProperties(obj : TTurtleComplex; value : TFhirCompartmentDefinition);
var
  item : TTurtleComplex;
begin
    ParseCanonicalResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/CompartmentDefinition.url'));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/CompartmentDefinition.version'));
    if obj.has('versionAlgorithmCoding', item) then
      value.versionAlgorithm := parseCoding(item);
    if obj.has('versionAlgorithmString', item) then
      value.versionAlgorithm := parseString(item);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/CompartmentDefinition.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/CompartmentDefinition.title'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CompartmentDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CompartmentDefinition.experimental'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/CompartmentDefinition.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/CompartmentDefinition.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/CompartmentDefinition.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CompartmentDefinition.description'));
    for item in obj.complexes('http://hl7.org/fhir/CompartmentDefinition.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CompartmentDefinition.purpose'));
    value.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CompartmentDefinition.code'), CODES_TFhirCompartmentTypeEnum, SYSTEMS_TFhirCompartmentTypeEnum);
    value.searchElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CompartmentDefinition.search'));
    for item in obj.complexes('http://hl7.org/fhir/CompartmentDefinition.resource') do
      value.resourceList.Add(parseCompartmentDefinitionResource(item));
end;

procedure TFHIRTurtleComposer.ComposeCompartmentDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirCompartmentDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CompartmentDefinition');
  end;
  composeCanonicalResource(this, '', name, value, false, index);
  ComposeUri(this, 'CompartmentDefinition', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'CompartmentDefinition', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirCoding) {6} then
    ComposeCoding(this, 'CompartmentDefinition', 'versionAlgorithmCoding', TFhirCoding(value.versionAlgorithm), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirString) {6} then
    ComposeString(this, 'CompartmentDefinition', 'versionAlgorithmString', TFhirString(value.versionAlgorithm), false, -1);
  ComposeString(this, 'CompartmentDefinition', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'CompartmentDefinition', 'title', value.titleElement, false, -1);
  ComposeEnum(this, 'CompartmentDefinition', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'CompartmentDefinition', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'CompartmentDefinition', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'CompartmentDefinition', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'CompartmentDefinition', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CompartmentDefinition', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'CompartmentDefinition', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CompartmentDefinition', 'purpose', value.purposeElement, false, -1);
  ComposeEnum(this, 'CompartmentDefinition', 'code', value.codeElement, CODES_TFhirCompartmentTypeEnum, SYSTEMS_TFhirCompartmentTypeEnum, false, -1);
  ComposeBoolean(this, 'CompartmentDefinition', 'search', value.searchElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.resourceList.Count - 1 do
      ComposeCompartmentDefinitionResource(this, 'CompartmentDefinition', 'resource', value.resourceList[i], false, i);
end;

{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
function TFHIRTurtleParser.ParseCompositionAttester(obj : TTurtleComplex) : TFhirCompositionAttester;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCompositionAttester.create;
  try
    ParseCompositionAttesterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCompositionAttesterProperties(obj : TTurtleComplex; value : TFhirCompositionAttester);
begin
    ParseBackboneElementProperties(obj, value);
    value.mode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Composition.attester.mode'));
    value.timeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Composition.attester.time'));
    value.party := ParseReference(obj.complex('http://hl7.org/fhir/Composition.attester.party'));
end;

procedure TFHIRTurtleComposer.ComposeCompositionAttester(parent :  TTurtleComplex; parentType, name : String; value : TFhirCompositionAttester; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CompositionAttester');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'Composition.attester', 'mode', value.modeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Composition.attester', 'time', value.timeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Composition.attester', 'party', value.partyElement, false, -1);
end;

function TFHIRTurtleParser.ParseCompositionEvent(obj : TTurtleComplex) : TFhirCompositionEvent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCompositionEvent.create;
  try
    ParseCompositionEventProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCompositionEventProperties(obj : TTurtleComplex; value : TFhirCompositionEvent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Composition.event.code') do
      value.codeList.Add(parseCodeableConcept(item));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Composition.event.period'));
    for item in obj.complexes('http://hl7.org/fhir/Composition.event.detail') do
      value.detailList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeCompositionEvent(parent :  TTurtleComplex; parentType, name : String; value : TFhirCompositionEvent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CompositionEvent');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCodeableConcept(this, 'Composition.event', 'code', value.codeList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Composition.event', 'period', value.periodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.detailList.Count - 1 do
      ComposeReference(this, 'Composition.event', 'detail', value.detailList[i], false, i);
end;

function TFHIRTurtleParser.ParseCompositionSection(obj : TTurtleComplex) : TFhirCompositionSection;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCompositionSection.create;
  try
    ParseCompositionSectionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCompositionSectionProperties(obj : TTurtleComplex; value : TFhirCompositionSection);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Composition.section.title'));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Composition.section.code'));
    for item in obj.complexes('http://hl7.org/fhir/Composition.section.author') do
      value.authorList.Add(parseReference(item));
    value.focus := ParseReference(obj.complex('http://hl7.org/fhir/Composition.section.focus'));
    value.text := ParseNarrative(obj.complex('http://hl7.org/fhir/Composition.section.text'));
    value.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/Composition.section.mode'), CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum);
    value.orderedBy := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Composition.section.orderedBy'));
    for item in obj.complexes('http://hl7.org/fhir/Composition.section.entry') do
      value.entryList.Add(parseReference(item));
    value.emptyReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Composition.section.emptyReason'));
    for item in obj.complexes('http://hl7.org/fhir/Composition.section.section') do
      value.sectionList.Add(parseCompositionSection(item));
end;

procedure TFHIRTurtleComposer.ComposeCompositionSection(parent :  TTurtleComplex; parentType, name : String; value : TFhirCompositionSection; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CompositionSection');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Composition.section', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Composition.section', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeReference(this, 'Composition.section', 'author', value.authorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Composition.section', 'focus', value.focusElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeNarrative(this, 'Composition.section', 'text', value.textElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Composition.section', 'mode', value.modeElement, CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Composition.section', 'orderedBy', value.orderedByElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.entryList.Count - 1 do
      ComposeReference(this, 'Composition.section', 'entry', value.entryList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Composition.section', 'emptyReason', value.emptyReasonElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.sectionList.Count - 1 do
      ComposeCompositionSection(this, 'Composition.section', 'section', value.sectionList[i], false, i);
end;

function TFHIRTurtleParser.ParseComposition(obj : TTurtleComplex) : TFhirComposition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirComposition.create;
  try
    ParseCompositionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCompositionProperties(obj : TTurtleComplex; value : TFhirComposition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Composition.url'));
    for item in obj.complexes('http://hl7.org/fhir/Composition.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Composition.version'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Composition.status'), CODES_TFhirCompositionStatusEnum, SYSTEMS_TFhirCompositionStatusEnum);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Composition.type'));
    for item in obj.complexes('http://hl7.org/fhir/Composition.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Composition.subject') do
      value.subjectList.Add(parseReference(item));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/Composition.encounter'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Composition.date'));
    for item in obj.complexes('http://hl7.org/fhir/Composition.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/Composition.author') do
      value.authorList.Add(parseReference(item));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Composition.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Composition.title'));
    for item in obj.complexes('http://hl7.org/fhir/Composition.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/Composition.attester') do
      value.attesterList.Add(parseCompositionAttester(item));
    value.custodian := ParseReference(obj.complex('http://hl7.org/fhir/Composition.custodian'));
    for item in obj.complexes('http://hl7.org/fhir/Composition.relatesTo') do
      value.relatesToList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/Composition.event') do
      value.eventList.Add(parseCompositionEvent(item));
    for item in obj.complexes('http://hl7.org/fhir/Composition.section') do
      value.sectionList.Add(parseCompositionSection(item));
end;

procedure TFHIRTurtleComposer.ComposeComposition(parent :  TTurtleComplex; parentType, name : String; value : TFhirComposition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Composition');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'Composition', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Composition', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Composition', 'version', value.versionElement, false, -1);
  ComposeEnum(this, 'Composition', 'status', value.statusElement, CODES_TFhirCompositionStatusEnum, SYSTEMS_TFhirCompositionStatusEnum, false, -1);
  ComposeCodeableConcept(this, 'Composition', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Composition', 'category', value.categoryList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.subjectList.Count - 1 do
      ComposeReference(this, 'Composition', 'subject', value.subjectList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Composition', 'encounter', value.encounterElement, false, -1);
  ComposeDateTime(this, 'Composition', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'Composition', 'useContext', value.useContextList[i], false, i);
  for i := 0 to value.authorList.Count - 1 do
      ComposeReference(this, 'Composition', 'author', value.authorList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Composition', 'name', value.nameElement, false, -1);
  ComposeString(this, 'Composition', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'Composition', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.attesterList.Count - 1 do
      ComposeCompositionAttester(this, 'Composition', 'attester', value.attesterList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Composition', 'custodian', value.custodianElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatesToList.Count - 1 do
      ComposeRelatedArtifact(this, 'Composition', 'relatesTo', value.relatesToList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.eventList.Count - 1 do
      ComposeCompositionEvent(this, 'Composition', 'event', value.eventList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.sectionList.Count - 1 do
      ComposeCompositionSection(this, 'Composition', 'section', value.sectionList[i], false, i);
end;

{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
function TFHIRTurtleParser.ParseConceptMapGroup(obj : TTurtleComplex) : TFhirConceptMapGroup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConceptMapGroup.create;
  try
    ParseConceptMapGroupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConceptMapGroupProperties(obj : TTurtleComplex; value : TFhirConceptMapGroup);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.sourceElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ConceptMap.group.source'));
    value.targetElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ConceptMap.group.target'));
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.group.element') do
      value.elementList.Add(parseConceptMapGroupElement(item));
    value.unmapped := ParseConceptMapGroupUnmapped(obj.complex('http://hl7.org/fhir/ConceptMap.group.unmapped'));
end;

procedure TFHIRTurtleComposer.ComposeConceptMapGroup(parent :  TTurtleComplex; parentType, name : String; value : TFhirConceptMapGroup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConceptMapGroup');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'ConceptMap.group', 'source', value.sourceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'ConceptMap.group', 'target', value.targetElement, false, -1);
  for i := 0 to value.elementList.Count - 1 do
      ComposeConceptMapGroupElement(this, 'ConceptMap.group', 'element', value.elementList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeConceptMapGroupUnmapped(this, 'ConceptMap.group', 'unmapped', value.unmappedElement, false, -1);
end;

function TFHIRTurtleParser.ParseConceptMapGroupElement(obj : TTurtleComplex) : TFhirConceptMapGroupElement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConceptMapGroupElement.create;
  try
    ParseConceptMapGroupElementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConceptMapGroupElementProperties(obj : TTurtleComplex; value : TFhirConceptMapGroupElement);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.code'));
    value.displayElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.display'));
    value.valueSetElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.valueSet'));
    value.noMapElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.noMap'));
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.group.element.target') do
      value.targetList.Add(parseConceptMapGroupElementTarget(item));
end;

procedure TFHIRTurtleComposer.ComposeConceptMapGroupElement(parent :  TTurtleComplex; parentType, name : String; value : TFhirConceptMapGroupElement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConceptMapGroupElement');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ConceptMap.group.element', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConceptMap.group.element', 'display', value.displayElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'ConceptMap.group.element', 'valueSet', value.valueSetElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ConceptMap.group.element', 'noMap', value.noMapElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.targetList.Count - 1 do
      ComposeConceptMapGroupElementTarget(this, 'ConceptMap.group.element', 'target', value.targetList[i], false, i);
end;

function TFHIRTurtleParser.ParseConceptMapGroupElementTarget(obj : TTurtleComplex) : TFhirConceptMapGroupElementTarget;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConceptMapGroupElementTarget.create;
  try
    ParseConceptMapGroupElementTargetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConceptMapGroupElementTargetProperties(obj : TTurtleComplex; value : TFhirConceptMapGroupElementTarget);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.target.code'));
    value.displayElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.target.display'));
    value.valueSetElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.target.valueSet'));
    value.relationshipElement := ParseEnum(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.target.relationship'), CODES_TFhirConceptMapRelationshipEnum, SYSTEMS_TFhirConceptMapRelationshipEnum);
    value.commentElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.target.comment'));
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.group.element.target.dependsOn') do
      value.dependsOnList.Add(parseConceptMapGroupElementTargetDependsOn(item));
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.group.element.target.product') do
      value.productList.Add(parseConceptMapGroupElementTargetDependsOn(item));
end;

procedure TFHIRTurtleComposer.ComposeConceptMapGroupElementTarget(parent :  TTurtleComplex; parentType, name : String; value : TFhirConceptMapGroupElementTarget; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConceptMapGroupElementTarget');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ConceptMap.group.element.target', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConceptMap.group.element.target', 'display', value.displayElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'ConceptMap.group.element.target', 'valueSet', value.valueSetElement, false, -1);
  ComposeEnum(this, 'ConceptMap.group.element.target', 'relationship', value.relationshipElement, CODES_TFhirConceptMapRelationshipEnum, SYSTEMS_TFhirConceptMapRelationshipEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConceptMap.group.element.target', 'comment', value.commentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dependsOnList.Count - 1 do
      ComposeConceptMapGroupElementTargetDependsOn(this, 'ConceptMap.group.element.target', 'dependsOn', value.dependsOnList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.productList.Count - 1 do
      ComposeConceptMapGroupElementTargetDependsOn(this, 'ConceptMap.group.element.target', 'product', value.productList[i], false, i);
end;

function TFHIRTurtleParser.ParseConceptMapGroupElementTargetDependsOn(obj : TTurtleComplex) : TFhirConceptMapGroupElementTargetDependsOn;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConceptMapGroupElementTargetDependsOn.create;
  try
    ParseConceptMapGroupElementTargetDependsOnProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConceptMapGroupElementTargetDependsOnProperties(obj : TTurtleComplex; value : TFhirConceptMapGroupElementTargetDependsOn);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.property_Element := ParseUri(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.target.dependsOn.property'));
    if obj.has('valueCode', item) then
      value.value := parseCode(item);
    if obj.has('valueCoding', item) then
      value.value := parseCoding(item);
    if obj.has('valueId', item) then
      value.value := parseId(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    if obj.has('valueInteger', item) then
      value.value := parseInteger(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    if obj.has('valueDateTime', item) then
      value.value := parseDateTime(item);
    if obj.has('valueDecimal', item) then
      value.value := parseDecimal(item);
    if obj.has('valueUri', item) then
      value.value := parseUri(item);
    value.valueSetElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.target.dependsOn.valueSet'));
end;

procedure TFHIRTurtleComposer.ComposeConceptMapGroupElementTargetDependsOn(parent :  TTurtleComplex; parentType, name : String; value : TFhirConceptMapGroupElementTargetDependsOn; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConceptMapGroupElementTargetDependsOn');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeUri(this, 'ConceptMap.group.element.target.dependsOn', 'property', value.property_Element, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.value is TFhirCode) {6} then
    ComposeCode(this, 'ConceptMap.group.element.target.dependsOn', 'valueCode', TFhirCode(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirCoding) {6} then
    ComposeCoding(this, 'ConceptMap.group.element.target.dependsOn', 'valueCoding', TFhirCoding(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirId) {6} then
    ComposeId(this, 'ConceptMap.group.element.target.dependsOn', 'valueId', TFhirId(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirString) {6} then
    ComposeString(this, 'ConceptMap.group.element.target.dependsOn', 'valueString', TFhirString(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirInteger) {6} then
    ComposeInteger(this, 'ConceptMap.group.element.target.dependsOn', 'valueInteger', TFhirInteger(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ConceptMap.group.element.target.dependsOn', 'valueBoolean', TFhirBoolean(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ConceptMap.group.element.target.dependsOn', 'valueDateTime', TFhirDateTime(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ConceptMap.group.element.target.dependsOn', 'valueDecimal', TFhirDecimal(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirUri) {6} then
    ComposeUri(this, 'ConceptMap.group.element.target.dependsOn', 'valueUri', TFhirUri(value.value), false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'ConceptMap.group.element.target.dependsOn', 'valueSet', value.valueSetElement, false, -1);
end;

function TFHIRTurtleParser.ParseConceptMapGroupUnmapped(obj : TTurtleComplex) : TFhirConceptMapGroupUnmapped;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConceptMapGroupUnmapped.create;
  try
    ParseConceptMapGroupUnmappedProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConceptMapGroupUnmappedProperties(obj : TTurtleComplex; value : TFhirConceptMapGroupUnmapped);
begin
    ParseBackboneElementProperties(obj, value);
    value.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/ConceptMap.group.unmapped.mode'), CODES_TFhirConceptMapGroupUnmappedModeEnum, SYSTEMS_TFhirConceptMapGroupUnmappedModeEnum);
    value.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ConceptMap.group.unmapped.code'));
    value.displayElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.group.unmapped.display'));
    value.valueSetElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ConceptMap.group.unmapped.valueSet'));
    value.relationshipElement := ParseEnum(obj.complex('http://hl7.org/fhir/ConceptMap.group.unmapped.relationship'), CODES_TFhirConceptMapRelationshipEnum, SYSTEMS_TFhirConceptMapRelationshipEnum);
    value.otherMapElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ConceptMap.group.unmapped.otherMap'));
end;

procedure TFHIRTurtleComposer.ComposeConceptMapGroupUnmapped(parent :  TTurtleComplex; parentType, name : String; value : TFhirConceptMapGroupUnmapped; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConceptMapGroupUnmapped');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'ConceptMap.group.unmapped', 'mode', value.modeElement, CODES_TFhirConceptMapGroupUnmappedModeEnum, SYSTEMS_TFhirConceptMapGroupUnmappedModeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ConceptMap.group.unmapped', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConceptMap.group.unmapped', 'display', value.displayElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'ConceptMap.group.unmapped', 'valueSet', value.valueSetElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'ConceptMap.group.unmapped', 'relationship', value.relationshipElement, CODES_TFhirConceptMapRelationshipEnum, SYSTEMS_TFhirConceptMapRelationshipEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'ConceptMap.group.unmapped', 'otherMap', value.otherMapElement, false, -1);
end;

function TFHIRTurtleParser.ParseConceptMap(obj : TTurtleComplex) : TFhirConceptMap;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConceptMap.create;
  try
    ParseConceptMapProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConceptMapProperties(obj : TTurtleComplex; value : TFhirConceptMap);
var
  item : TTurtleComplex;
begin
    ParseMetadataResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ConceptMap.url'));
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.version'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.title'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ConceptMap.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ConceptMap.experimental'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ConceptMap.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ConceptMap.description'));
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ConceptMap.purpose'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ConceptMap.copyright'));
    value.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ConceptMap.approvalDate'));
    value.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ConceptMap.lastReviewDate'));
    value.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/ConceptMap.effectivePeriod'));
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.topic') do
      value.topicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.author') do
      value.authorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.editor') do
      value.editorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.reviewer') do
      value.reviewerList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.endorser') do
      value.endorserList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.relatedArtifact') do
      value.relatedArtifactList.Add(parseRelatedArtifact(item));
    if obj.has('sourceScopeCanonical', item) then
      value.sourceScope := parseCanonical(item);
    if obj.has('sourceScopeUri', item) then
      value.sourceScope := parseUri(item);
    if obj.has('targetScopeCanonical', item) then
      value.targetScope := parseCanonical(item);
    if obj.has('targetScopeUri', item) then
      value.targetScope := parseUri(item);
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.group') do
      value.groupList.Add(parseConceptMapGroup(item));
end;

procedure TFHIRTurtleComposer.ComposeConceptMap(parent :  TTurtleComplex; parentType, name : String; value : TFhirConceptMap; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConceptMap');
  end;
  composeMetadataResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ConceptMap', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ConceptMap', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ConceptMap', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ConceptMap', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ConceptMap', 'title', value.titleElement, false, -1);
  ComposeEnum(this, 'ConceptMap', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ConceptMap', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ConceptMap', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ConceptMap', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'ConceptMap', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ConceptMap', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'ConceptMap', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'ConceptMap', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ConceptMap', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ConceptMap', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'ConceptMap', 'approvalDate', value.approvalDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'ConceptMap', 'lastReviewDate', value.lastReviewDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'ConceptMap', 'effectivePeriod', value.effectivePeriodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.topicList.Count - 1 do
      ComposeCodeableConcept(this, 'ConceptMap', 'topic', value.topicList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(this, 'ConceptMap', 'author', value.authorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(this, 'ConceptMap', 'editor', value.editorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(this, 'ConceptMap', 'reviewer', value.reviewerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(this, 'ConceptMap', 'endorser', value.endorserList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'ConceptMap', 'relatedArtifact', value.relatedArtifactList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.sourceScope is TFhirCanonical) {6} then
    ComposeCanonical(this, 'ConceptMap', 'sourceScopeCanonical', TFhirCanonical(value.sourceScope), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.sourceScope is TFhirUri) {6} then
    ComposeUri(this, 'ConceptMap', 'sourceScopeUri', TFhirUri(value.sourceScope), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.targetScope is TFhirCanonical) {6} then
    ComposeCanonical(this, 'ConceptMap', 'targetScopeCanonical', TFhirCanonical(value.targetScope), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.targetScope is TFhirUri) {6} then
    ComposeUri(this, 'ConceptMap', 'targetScopeUri', TFhirUri(value.targetScope), false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.groupList.Count - 1 do
      ComposeConceptMapGroup(this, 'ConceptMap', 'group', value.groupList[i], false, i);
end;

{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
function TFHIRTurtleParser.ParseConditionParticipant(obj : TTurtleComplex) : TFhirConditionParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConditionParticipant.create;
  try
    ParseConditionParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConditionParticipantProperties(obj : TTurtleComplex; value : TFhirConditionParticipant);
begin
    ParseBackboneElementProperties(obj, value);
    value.function_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Condition.participant.function'));
    value.actor := ParseReference(obj.complex('http://hl7.org/fhir/Condition.participant.actor'));
end;

procedure TFHIRTurtleComposer.ComposeConditionParticipant(parent :  TTurtleComplex; parentType, name : String; value : TFhirConditionParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConditionParticipant');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Condition.participant', 'function', value.function_Element, false, -1);
  ComposeReference(this, 'Condition.participant', 'actor', value.actorElement, false, -1);
end;

function TFHIRTurtleParser.ParseConditionStage(obj : TTurtleComplex) : TFhirConditionStage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConditionStage.create;
  try
    ParseConditionStageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConditionStageProperties(obj : TTurtleComplex; value : TFhirConditionStage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.summary := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Condition.stage.summary'));
    for item in obj.complexes('http://hl7.org/fhir/Condition.stage.assessment') do
      value.assessmentList.Add(parseReference(item));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Condition.stage.type'));
end;

procedure TFHIRTurtleComposer.ComposeConditionStage(parent :  TTurtleComplex; parentType, name : String; value : TFhirConditionStage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConditionStage');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Condition.stage', 'summary', value.summaryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.assessmentList.Count - 1 do
      ComposeReference(this, 'Condition.stage', 'assessment', value.assessmentList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Condition.stage', 'type', value.type_Element, false, -1);
end;

function TFHIRTurtleParser.ParseCondition(obj : TTurtleComplex) : TFhirCondition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCondition.create;
  try
    ParseConditionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConditionProperties(obj : TTurtleComplex; value : TFhirCondition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Condition.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.clinicalStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Condition.clinicalStatus'));
    value.verificationStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Condition.verificationStatus'));
    for item in obj.complexes('http://hl7.org/fhir/Condition.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    value.severity := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Condition.severity'));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Condition.code'));
    for item in obj.complexes('http://hl7.org/fhir/Condition.bodySite') do
      value.bodySiteList.Add(parseCodeableConcept(item));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/Condition.subject'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/Condition.encounter'));
    if obj.has('onsetAge', item) then
      value.onset := parseAge(item);
    if obj.has('onsetPeriod', item) then
      value.onset := parsePeriod(item);
    if obj.has('onsetRange', item) then
      value.onset := parseRange(item);
    if obj.has('onsetDateTime', item) then
      value.onset := parseDateTime(item);
    if obj.has('onsetString', item) then
      value.onset := parseString(item);
    if obj.has('abatementAge', item) then
      value.abatement := parseAge(item);
    if obj.has('abatementPeriod', item) then
      value.abatement := parsePeriod(item);
    if obj.has('abatementRange', item) then
      value.abatement := parseRange(item);
    if obj.has('abatementDateTime', item) then
      value.abatement := parseDateTime(item);
    if obj.has('abatementString', item) then
      value.abatement := parseString(item);
    value.recordedDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Condition.recordedDate'));
    for item in obj.complexes('http://hl7.org/fhir/Condition.participant') do
      value.participantList.Add(parseConditionParticipant(item));
    for item in obj.complexes('http://hl7.org/fhir/Condition.stage') do
      value.stageList.Add(parseConditionStage(item));
    for item in obj.complexes('http://hl7.org/fhir/Condition.evidence') do
      value.evidenceList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Condition.note') do
      value.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeCondition(parent :  TTurtleComplex; parentType, name : String; value : TFhirCondition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Condition');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Condition', 'identifier', value.identifierList[i], false, i);
  ComposeCodeableConcept(this, 'Condition', 'clinicalStatus', value.clinicalStatusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Condition', 'verificationStatus', value.verificationStatusElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Condition', 'category', value.categoryList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Condition', 'severity', value.severityElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Condition', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.bodySiteList.Count - 1 do
      ComposeCodeableConcept(this, 'Condition', 'bodySite', value.bodySiteList[i], false, i);
  ComposeReference(this, 'Condition', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Condition', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.onset is TFhirAge) {6} then
    ComposeAge(this, 'Condition', 'onsetAge', TFhirAge(value.onset), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.onset is TFhirPeriod) {6} then
    ComposePeriod(this, 'Condition', 'onsetPeriod', TFhirPeriod(value.onset), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.onset is TFhirRange) {6} then
    ComposeRange(this, 'Condition', 'onsetRange', TFhirRange(value.onset), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.onset is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Condition', 'onsetDateTime', TFhirDateTime(value.onset), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.onset is TFhirString) {6} then
    ComposeString(this, 'Condition', 'onsetString', TFhirString(value.onset), false, -1);
  if (SummaryOption in [soFull, soData]) and (value.abatement is TFhirAge) {6} then
    ComposeAge(this, 'Condition', 'abatementAge', TFhirAge(value.abatement), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.abatement is TFhirPeriod) {6} then
    ComposePeriod(this, 'Condition', 'abatementPeriod', TFhirPeriod(value.abatement), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.abatement is TFhirRange) {6} then
    ComposeRange(this, 'Condition', 'abatementRange', TFhirRange(value.abatement), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.abatement is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Condition', 'abatementDateTime', TFhirDateTime(value.abatement), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.abatement is TFhirString) {6} then
    ComposeString(this, 'Condition', 'abatementString', TFhirString(value.abatement), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Condition', 'recordedDate', value.recordedDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.participantList.Count - 1 do
      ComposeConditionParticipant(this, 'Condition', 'participant', value.participantList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.stageList.Count - 1 do
      ComposeConditionStage(this, 'Condition', 'stage', value.stageList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.evidenceList.Count - 1 do
      ComposeCodeableReference(this, 'Condition', 'evidence', value.evidenceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'Condition', 'note', value.noteList[i], false, i);
end;

{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONDITIONDEFINITION}
function TFHIRTurtleParser.ParseConditionDefinitionObservation(obj : TTurtleComplex) : TFhirConditionDefinitionObservation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConditionDefinitionObservation.create;
  try
    ParseConditionDefinitionObservationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConditionDefinitionObservationProperties(obj : TTurtleComplex; value : TFhirConditionDefinitionObservation);
begin
    ParseBackboneElementProperties(obj, value);
    value.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ConditionDefinition.observation.category'));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ConditionDefinition.observation.code'));
end;

procedure TFHIRTurtleComposer.ComposeConditionDefinitionObservation(parent :  TTurtleComplex; parentType, name : String; value : TFhirConditionDefinitionObservation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConditionDefinitionObservation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ConditionDefinition.observation', 'category', value.categoryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ConditionDefinition.observation', 'code', value.codeElement, false, -1);
end;

function TFHIRTurtleParser.ParseConditionDefinitionMedication(obj : TTurtleComplex) : TFhirConditionDefinitionMedication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConditionDefinitionMedication.create;
  try
    ParseConditionDefinitionMedicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConditionDefinitionMedicationProperties(obj : TTurtleComplex; value : TFhirConditionDefinitionMedication);
begin
    ParseBackboneElementProperties(obj, value);
    value.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ConditionDefinition.medication.category'));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ConditionDefinition.medication.code'));
end;

procedure TFHIRTurtleComposer.ComposeConditionDefinitionMedication(parent :  TTurtleComplex; parentType, name : String; value : TFhirConditionDefinitionMedication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConditionDefinitionMedication');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ConditionDefinition.medication', 'category', value.categoryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ConditionDefinition.medication', 'code', value.codeElement, false, -1);
end;

function TFHIRTurtleParser.ParseConditionDefinitionPrecondition(obj : TTurtleComplex) : TFhirConditionDefinitionPrecondition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConditionDefinitionPrecondition.create;
  try
    ParseConditionDefinitionPreconditionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConditionDefinitionPreconditionProperties(obj : TTurtleComplex; value : TFhirConditionDefinitionPrecondition);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ConditionDefinition.precondition.type'), CODES_TFhirConditionPreconditionTypeEnum, SYSTEMS_TFhirConditionPreconditionTypeEnum);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ConditionDefinition.precondition.code'));
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
end;

procedure TFHIRTurtleComposer.ComposeConditionDefinitionPrecondition(parent :  TTurtleComplex; parentType, name : String; value : TFhirConditionDefinitionPrecondition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConditionDefinitionPrecondition');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'ConditionDefinition.precondition', 'type', value.type_Element, CODES_TFhirConditionPreconditionTypeEnum, SYSTEMS_TFhirConditionPreconditionTypeEnum, false, -1);
  ComposeCodeableConcept(this, 'ConditionDefinition.precondition', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ConditionDefinition.precondition', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ConditionDefinition.precondition', 'valueQuantity', TFhirQuantity(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseConditionDefinitionQuestionnaire(obj : TTurtleComplex) : TFhirConditionDefinitionQuestionnaire;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConditionDefinitionQuestionnaire.create;
  try
    ParseConditionDefinitionQuestionnaireProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConditionDefinitionQuestionnaireProperties(obj : TTurtleComplex; value : TFhirConditionDefinitionQuestionnaire);
begin
    ParseBackboneElementProperties(obj, value);
    value.purposeElement := ParseEnum(obj.complex('http://hl7.org/fhir/ConditionDefinition.questionnaire.purpose'), CODES_TFhirConditionQuestionnairePurposeEnum, SYSTEMS_TFhirConditionQuestionnairePurposeEnum);
    value.reference := ParseReference(obj.complex('http://hl7.org/fhir/ConditionDefinition.questionnaire.reference'));
end;

procedure TFHIRTurtleComposer.ComposeConditionDefinitionQuestionnaire(parent :  TTurtleComplex; parentType, name : String; value : TFhirConditionDefinitionQuestionnaire; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConditionDefinitionQuestionnaire');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'ConditionDefinition.questionnaire', 'purpose', value.purposeElement, CODES_TFhirConditionQuestionnairePurposeEnum, SYSTEMS_TFhirConditionQuestionnairePurposeEnum, false, -1);
  ComposeReference(this, 'ConditionDefinition.questionnaire', 'reference', value.referenceElement, false, -1);
end;

function TFHIRTurtleParser.ParseConditionDefinitionPlan(obj : TTurtleComplex) : TFhirConditionDefinitionPlan;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConditionDefinitionPlan.create;
  try
    ParseConditionDefinitionPlanProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConditionDefinitionPlanProperties(obj : TTurtleComplex; value : TFhirConditionDefinitionPlan);
begin
    ParseBackboneElementProperties(obj, value);
    value.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ConditionDefinition.plan.role'));
    value.reference := ParseReference(obj.complex('http://hl7.org/fhir/ConditionDefinition.plan.reference'));
end;

procedure TFHIRTurtleComposer.ComposeConditionDefinitionPlan(parent :  TTurtleComplex; parentType, name : String; value : TFhirConditionDefinitionPlan; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConditionDefinitionPlan');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ConditionDefinition.plan', 'role', value.roleElement, false, -1);
  ComposeReference(this, 'ConditionDefinition.plan', 'reference', value.referenceElement, false, -1);
end;

function TFHIRTurtleParser.ParseConditionDefinition(obj : TTurtleComplex) : TFhirConditionDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConditionDefinition.create;
  try
    ParseConditionDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConditionDefinitionProperties(obj : TTurtleComplex; value : TFhirConditionDefinition);
var
  item : TTurtleComplex;
begin
    ParseMetadataResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ConditionDefinition.url'));
    for item in obj.complexes('http://hl7.org/fhir/ConditionDefinition.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ConditionDefinition.version'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ConditionDefinition.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ConditionDefinition.title'));
    value.subtitleElement := ParseString(obj.complex('http://hl7.org/fhir/ConditionDefinition.subtitle'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ConditionDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ConditionDefinition.experimental'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ConditionDefinition.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/ConditionDefinition.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/ConditionDefinition.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ConditionDefinition.description'));
    for item in obj.complexes('http://hl7.org/fhir/ConditionDefinition.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/ConditionDefinition.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ConditionDefinition.code'));
    value.severity := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ConditionDefinition.severity'));
    value.bodySite := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ConditionDefinition.bodySite'));
    value.stage := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ConditionDefinition.stage'));
    value.hasSeverityElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ConditionDefinition.hasSeverity'));
    value.hasBodySiteElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ConditionDefinition.hasBodySite'));
    value.hasStageElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ConditionDefinition.hasStage'));
    for item in obj.complexes('http://hl7.org/fhir/ConditionDefinition.definition') do
      value.definitionList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/ConditionDefinition.observation') do
      value.observationList.Add(parseConditionDefinitionObservation(item));
    for item in obj.complexes('http://hl7.org/fhir/ConditionDefinition.medication') do
      value.medicationList.Add(parseConditionDefinitionMedication(item));
    for item in obj.complexes('http://hl7.org/fhir/ConditionDefinition.precondition') do
      value.preconditionList.Add(parseConditionDefinitionPrecondition(item));
    for item in obj.complexes('http://hl7.org/fhir/ConditionDefinition.team') do
      value.teamList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ConditionDefinition.questionnaire') do
      value.questionnaireList.Add(parseConditionDefinitionQuestionnaire(item));
    for item in obj.complexes('http://hl7.org/fhir/ConditionDefinition.plan') do
      value.planList.Add(parseConditionDefinitionPlan(item));
end;

procedure TFHIRTurtleComposer.ComposeConditionDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirConditionDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConditionDefinition');
  end;
  composeMetadataResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ConditionDefinition', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ConditionDefinition', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ConditionDefinition', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ConditionDefinition', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ConditionDefinition', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConditionDefinition', 'subtitle', value.subtitleElement, false, -1);
  ComposeEnum(this, 'ConditionDefinition', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ConditionDefinition', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ConditionDefinition', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ConditionDefinition', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'ConditionDefinition', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ConditionDefinition', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'ConditionDefinition', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'ConditionDefinition', 'jurisdiction', value.jurisdictionList[i], false, i);
  ComposeCodeableConcept(this, 'ConditionDefinition', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ConditionDefinition', 'severity', value.severityElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ConditionDefinition', 'bodySite', value.bodySiteElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ConditionDefinition', 'stage', value.stageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ConditionDefinition', 'hasSeverity', value.hasSeverityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ConditionDefinition', 'hasBodySite', value.hasBodySiteElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ConditionDefinition', 'hasStage', value.hasStageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.definitionList.Count - 1 do
      ComposeUri(this, 'ConditionDefinition', 'definition', value.definitionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.observationList.Count - 1 do
      ComposeConditionDefinitionObservation(this, 'ConditionDefinition', 'observation', value.observationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.medicationList.Count - 1 do
      ComposeConditionDefinitionMedication(this, 'ConditionDefinition', 'medication', value.medicationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.preconditionList.Count - 1 do
      ComposeConditionDefinitionPrecondition(this, 'ConditionDefinition', 'precondition', value.preconditionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.teamList.Count - 1 do
      ComposeReference(this, 'ConditionDefinition', 'team', value.teamList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.questionnaireList.Count - 1 do
      ComposeConditionDefinitionQuestionnaire(this, 'ConditionDefinition', 'questionnaire', value.questionnaireList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.planList.Count - 1 do
      ComposeConditionDefinitionPlan(this, 'ConditionDefinition', 'plan', value.planList[i], false, i);
end;

{$ENDIF FHIR_CONDITIONDEFINITION}
{$IFDEF FHIR_CONSENT}
function TFHIRTurtleParser.ParseConsentPolicyBasis(obj : TTurtleComplex) : TFhirConsentPolicyBasis;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConsentPolicyBasis.create;
  try
    ParseConsentPolicyBasisProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConsentPolicyBasisProperties(obj : TTurtleComplex; value : TFhirConsentPolicyBasis);
begin
    ParseBackboneElementProperties(obj, value);
    value.reference := ParseReference(obj.complex('http://hl7.org/fhir/Consent.policyBasis.reference'));
    value.urlElement := ParseUrl(obj.complex('http://hl7.org/fhir/Consent.policyBasis.url'));
end;

procedure TFHIRTurtleComposer.ComposeConsentPolicyBasis(parent :  TTurtleComplex; parentType, name : String; value : TFhirConsentPolicyBasis; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConsentPolicyBasis');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Consent.policyBasis', 'reference', value.referenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeUrl(this, 'Consent.policyBasis', 'url', value.urlElement, false, -1);
end;

function TFHIRTurtleParser.ParseConsentVerification(obj : TTurtleComplex) : TFhirConsentVerification;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConsentVerification.create;
  try
    ParseConsentVerificationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConsentVerificationProperties(obj : TTurtleComplex; value : TFhirConsentVerification);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.verifiedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Consent.verification.verified'));
    value.verificationType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Consent.verification.verificationType'));
    value.verifiedBy := ParseReference(obj.complex('http://hl7.org/fhir/Consent.verification.verifiedBy'));
    value.verifiedWith := ParseReference(obj.complex('http://hl7.org/fhir/Consent.verification.verifiedWith'));
    for item in obj.complexes('http://hl7.org/fhir/Consent.verification.verificationDate') do
      value.verificationDateList.Add(parseDateTime(item));
end;

procedure TFHIRTurtleComposer.ComposeConsentVerification(parent :  TTurtleComplex; parentType, name : String; value : TFhirConsentVerification; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConsentVerification');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeBoolean(this, 'Consent.verification', 'verified', value.verifiedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Consent.verification', 'verificationType', value.verificationTypeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Consent.verification', 'verifiedBy', value.verifiedByElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Consent.verification', 'verifiedWith', value.verifiedWithElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.verificationDateList.Count - 1 do
      ComposeDateTime(this, 'Consent.verification', 'verificationDate', value.verificationDateList[i], false, i);
end;

function TFHIRTurtleParser.ParseConsentProvision(obj : TTurtleComplex) : TFhirConsentProvision;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConsentProvision.create;
  try
    ParseConsentProvisionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConsentProvisionProperties(obj : TTurtleComplex; value : TFhirConsentProvision);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Consent.provision.type'), CODES_TFhirConsentProvisionTypeEnum, SYSTEMS_TFhirConsentProvisionTypeEnum);
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Consent.provision.period'));
    for item in obj.complexes('http://hl7.org/fhir/Consent.provision.actor') do
      value.actorList.Add(parseConsentProvisionActor(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.provision.action') do
      value.actionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.provision.securityLabel') do
      value.securityLabelList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.provision.purpose') do
      value.purposeList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.provision.class') do
      value.class_List.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.provision.code') do
      value.codeList.Add(parseCodeableConcept(item));
    value.dataPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Consent.provision.dataPeriod'));
    for item in obj.complexes('http://hl7.org/fhir/Consent.provision.data') do
      value.dataList.Add(parseConsentProvisionData(item));
    value.expression := ParseExpression(obj.complex('http://hl7.org/fhir/Consent.provision.expression'));
    for item in obj.complexes('http://hl7.org/fhir/Consent.provision.provision') do
      value.provisionList.Add(parseConsentProvision(item));
end;

procedure TFHIRTurtleComposer.ComposeConsentProvision(parent :  TTurtleComplex; parentType, name : String; value : TFhirConsentProvision; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConsentProvision');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Consent.provision', 'type', value.type_Element, CODES_TFhirConsentProvisionTypeEnum, SYSTEMS_TFhirConsentProvisionTypeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Consent.provision', 'period', value.periodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.actorList.Count - 1 do
      ComposeConsentProvisionActor(this, 'Consent.provision', 'actor', value.actorList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.actionList.Count - 1 do
      ComposeCodeableConcept(this, 'Consent.provision', 'action', value.actionList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.securityLabelList.Count - 1 do
      ComposeCoding(this, 'Consent.provision', 'securityLabel', value.securityLabelList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.purposeList.Count - 1 do
      ComposeCoding(this, 'Consent.provision', 'purpose', value.purposeList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.class_List.Count - 1 do
      ComposeCoding(this, 'Consent.provision', 'class', value.class_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCodeableConcept(this, 'Consent.provision', 'code', value.codeList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Consent.provision', 'dataPeriod', value.dataPeriodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.dataList.Count - 1 do
      ComposeConsentProvisionData(this, 'Consent.provision', 'data', value.dataList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeExpression(this, 'Consent.provision', 'expression', value.expressionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.provisionList.Count - 1 do
      ComposeConsentProvision(this, 'Consent.provision', 'provision', value.provisionList[i], false, i);
end;

function TFHIRTurtleParser.ParseConsentProvisionActor(obj : TTurtleComplex) : TFhirConsentProvisionActor;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConsentProvisionActor.create;
  try
    ParseConsentProvisionActorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConsentProvisionActorProperties(obj : TTurtleComplex; value : TFhirConsentProvisionActor);
begin
    ParseBackboneElementProperties(obj, value);
    value.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Consent.provision.actor.role'));
    value.reference := ParseReference(obj.complex('http://hl7.org/fhir/Consent.provision.actor.reference'));
end;

procedure TFHIRTurtleComposer.ComposeConsentProvisionActor(parent :  TTurtleComplex; parentType, name : String; value : TFhirConsentProvisionActor; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConsentProvisionActor');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Consent.provision.actor', 'role', value.roleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Consent.provision.actor', 'reference', value.referenceElement, false, -1);
end;

function TFHIRTurtleParser.ParseConsentProvisionData(obj : TTurtleComplex) : TFhirConsentProvisionData;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConsentProvisionData.create;
  try
    ParseConsentProvisionDataProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConsentProvisionDataProperties(obj : TTurtleComplex; value : TFhirConsentProvisionData);
begin
    ParseBackboneElementProperties(obj, value);
    value.meaningElement := ParseEnum(obj.complex('http://hl7.org/fhir/Consent.provision.data.meaning'), CODES_TFhirConsentDataMeaningEnum, SYSTEMS_TFhirConsentDataMeaningEnum);
    value.reference := ParseReference(obj.complex('http://hl7.org/fhir/Consent.provision.data.reference'));
end;

procedure TFHIRTurtleComposer.ComposeConsentProvisionData(parent :  TTurtleComplex; parentType, name : String; value : TFhirConsentProvisionData; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConsentProvisionData');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'Consent.provision.data', 'meaning', value.meaningElement, CODES_TFhirConsentDataMeaningEnum, SYSTEMS_TFhirConsentDataMeaningEnum, false, -1);
  ComposeReference(this, 'Consent.provision.data', 'reference', value.referenceElement, false, -1);
end;

function TFHIRTurtleParser.ParseConsent(obj : TTurtleComplex) : TFhirConsent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConsent.create;
  try
    ParseConsentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConsentProperties(obj : TTurtleComplex; value : TFhirConsent);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Consent.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Consent.status'), CODES_TFhirConsentStateEnum, SYSTEMS_TFhirConsentStateEnum);
    for item in obj.complexes('http://hl7.org/fhir/Consent.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/Consent.subject'));
    value.dateTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Consent.dateTime'));
    for item in obj.complexes('http://hl7.org/fhir/Consent.grantor') do
      value.grantorList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.grantee') do
      value.granteeList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.manager') do
      value.managerList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.controller') do
      value.controllerList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.sourceAttachment') do
      value.sourceAttachmentList.Add(parseAttachment(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.sourceReference') do
      value.sourceReferenceList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.regulatoryBasis') do
      value.regulatoryBasisList.Add(parseCodeableConcept(item));
    value.policyBasis := ParseConsentPolicyBasis(obj.complex('http://hl7.org/fhir/Consent.policyBasis'));
    for item in obj.complexes('http://hl7.org/fhir/Consent.policyText') do
      value.policyTextList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.verification') do
      value.verificationList.Add(parseConsentVerification(item));
    value.provision := ParseConsentProvision(obj.complex('http://hl7.org/fhir/Consent.provision'));
end;

procedure TFHIRTurtleComposer.ComposeConsent(parent :  TTurtleComplex; parentType, name : String; value : TFhirConsent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Consent');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Consent', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'Consent', 'status', value.statusElement, CODES_TFhirConsentStateEnum, SYSTEMS_TFhirConsentStateEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Consent', 'category', value.categoryList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Consent', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Consent', 'dateTime', value.dateTimeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.grantorList.Count - 1 do
      ComposeReference(this, 'Consent', 'grantor', value.grantorList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.granteeList.Count - 1 do
      ComposeReference(this, 'Consent', 'grantee', value.granteeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.managerList.Count - 1 do
      ComposeReference(this, 'Consent', 'manager', value.managerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.controllerList.Count - 1 do
      ComposeReference(this, 'Consent', 'controller', value.controllerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.sourceAttachmentList.Count - 1 do
      ComposeAttachment(this, 'Consent', 'sourceAttachment', value.sourceAttachmentList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.sourceReferenceList.Count - 1 do
      ComposeReference(this, 'Consent', 'sourceReference', value.sourceReferenceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.regulatoryBasisList.Count - 1 do
      ComposeCodeableConcept(this, 'Consent', 'regulatoryBasis', value.regulatoryBasisList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeConsentPolicyBasis(this, 'Consent', 'policyBasis', value.policyBasisElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.policyTextList.Count - 1 do
      ComposeReference(this, 'Consent', 'policyText', value.policyTextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.verificationList.Count - 1 do
      ComposeConsentVerification(this, 'Consent', 'verification', value.verificationList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeConsentProvision(this, 'Consent', 'provision', value.provisionElement, false, -1);
end;

{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
function TFHIRTurtleParser.ParseContractContentDefinition(obj : TTurtleComplex) : TFhirContractContentDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractContentDefinition.create;
  try
    ParseContractContentDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractContentDefinitionProperties(obj : TTurtleComplex; value : TFhirContractContentDefinition);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.contentDefinition.type'));
    value.subType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.contentDefinition.subType'));
    value.publisher := ParseReference(obj.complex('http://hl7.org/fhir/Contract.contentDefinition.publisher'));
    value.publicationDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Contract.contentDefinition.publicationDate'));
    value.publicationStatusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Contract.contentDefinition.publicationStatus'), CODES_TFhirContractResourcePublicationStatusCodesEnum, SYSTEMS_TFhirContractResourcePublicationStatusCodesEnum);
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Contract.contentDefinition.copyright'));
end;

procedure TFHIRTurtleComposer.ComposeContractContentDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractContentDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractContentDefinition');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'Contract.contentDefinition', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Contract.contentDefinition', 'subType', value.subTypeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Contract.contentDefinition', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Contract.contentDefinition', 'publicationDate', value.publicationDateElement, false, -1);
  ComposeEnum(this, 'Contract.contentDefinition', 'publicationStatus', value.publicationStatusElement, CODES_TFhirContractResourcePublicationStatusCodesEnum, SYSTEMS_TFhirContractResourcePublicationStatusCodesEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'Contract.contentDefinition', 'copyright', value.copyrightElement, false, -1);
end;

function TFHIRTurtleParser.ParseContractTerm(obj : TTurtleComplex) : TFhirContractTerm;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTerm.create;
  try
    ParseContractTermProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermProperties(obj : TTurtleComplex; value : TFhirContractTerm);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Contract.term.identifier'));
    value.issuedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Contract.term.issued'));
    value.applies := ParsePeriod(obj.complex('http://hl7.org/fhir/Contract.term.applies'));
    if obj.has('topicCodeableConcept', item) then
      value.topic := parseCodeableConcept(item);
    if obj.has('topicReference', item) {a3} then
      value.topic := ParseReference(item);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.type'));
    value.subType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.subType'));
    value.textElement := ParseString(obj.complex('http://hl7.org/fhir/Contract.term.text'));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.securityLabel') do
      value.securityLabelList.Add(parseContractTermSecurityLabel(item));
    value.offer := ParseContractTermOffer(obj.complex('http://hl7.org/fhir/Contract.term.offer'));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset') do
      value.assetList.Add(parseContractTermAsset(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action') do
      value.actionList.Add(parseContractTermAction(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.group') do
      value.groupList.Add(parseContractTerm(item));
end;

procedure TFHIRTurtleComposer.ComposeContractTerm(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractTerm; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTerm');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'Contract.term', 'identifier', value.identifierElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Contract.term', 'issued', value.issuedElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Contract.term', 'applies', value.appliesElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.topic is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Contract.term', 'topicCodeableConcept', TFhirCodeableConcept(value.topic), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.topic is TFhirReference) {2} then
    ComposeReference(this, 'Contract.term', 'topicReference', TFhirReference(value.topic), false,-1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Contract.term', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Contract.term', 'subType', value.subTypeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Contract.term', 'text', value.textElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.securityLabelList.Count - 1 do
      ComposeContractTermSecurityLabel(this, 'Contract.term', 'securityLabel', value.securityLabelList[i], false, i);
  ComposeContractTermOffer(this, 'Contract.term', 'offer', value.offerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.assetList.Count - 1 do
      ComposeContractTermAsset(this, 'Contract.term', 'asset', value.assetList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.actionList.Count - 1 do
      ComposeContractTermAction(this, 'Contract.term', 'action', value.actionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.groupList.Count - 1 do
      ComposeContractTerm(this, 'Contract.term', 'group', value.groupList[i], false, i);
end;

function TFHIRTurtleParser.ParseContractTermSecurityLabel(obj : TTurtleComplex) : TFhirContractTermSecurityLabel;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTermSecurityLabel.create;
  try
    ParseContractTermSecurityLabelProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermSecurityLabelProperties(obj : TTurtleComplex; value : TFhirContractTermSecurityLabel);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.securityLabel.number') do
      value.numberList.Add(parseUnsignedInt(item));
    value.classification := ParseCoding(obj.complex('http://hl7.org/fhir/Contract.term.securityLabel.classification'));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.securityLabel.category') do
      value.categoryList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.securityLabel.control') do
      value.controlList.Add(parseCoding(item));
end;

procedure TFHIRTurtleComposer.ComposeContractTermSecurityLabel(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractTermSecurityLabel; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTermSecurityLabel');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.numberList.Count - 1 do
      ComposeUnsignedInt(this, 'Contract.term.securityLabel', 'number', value.numberList[i], false, i);
  ComposeCoding(this, 'Contract.term.securityLabel', 'classification', value.classificationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCoding(this, 'Contract.term.securityLabel', 'category', value.categoryList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.controlList.Count - 1 do
      ComposeCoding(this, 'Contract.term.securityLabel', 'control', value.controlList[i], false, i);
end;

function TFHIRTurtleParser.ParseContractTermOffer(obj : TTurtleComplex) : TFhirContractTermOffer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTermOffer.create;
  try
    ParseContractTermOfferProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermOfferProperties(obj : TTurtleComplex; value : TFhirContractTermOffer);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.offer.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.offer.party') do
      value.partyList.Add(parseContractTermOfferParty(item));
    value.topic := ParseReference(obj.complex('http://hl7.org/fhir/Contract.term.offer.topic'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.offer.type'));
    value.decision := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.offer.decision'));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.offer.decisionMode') do
      value.decisionModeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.offer.answer') do
      value.answerList.Add(parseContractTermOfferAnswer(item));
    value.textElement := ParseString(obj.complex('http://hl7.org/fhir/Contract.term.offer.text'));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.offer.linkId') do
      value.linkIdList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.offer.securityLabelNumber') do
      value.securityLabelNumberList.Add(parseUnsignedInt(item));
end;

procedure TFHIRTurtleComposer.ComposeContractTermOffer(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractTermOffer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTermOffer');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Contract.term.offer', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.partyList.Count - 1 do
      ComposeContractTermOfferParty(this, 'Contract.term.offer', 'party', value.partyList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Contract.term.offer', 'topic', value.topicElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Contract.term.offer', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Contract.term.offer', 'decision', value.decisionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.decisionModeList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract.term.offer', 'decisionMode', value.decisionModeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.answerList.Count - 1 do
      ComposeContractTermOfferAnswer(this, 'Contract.term.offer', 'answer', value.answerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Contract.term.offer', 'text', value.textElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.linkIdList.Count - 1 do
      ComposeString(this, 'Contract.term.offer', 'linkId', value.linkIdList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.securityLabelNumberList.Count - 1 do
      ComposeUnsignedInt(this, 'Contract.term.offer', 'securityLabelNumber', value.securityLabelNumberList[i], false, i);
end;

function TFHIRTurtleParser.ParseContractTermOfferParty(obj : TTurtleComplex) : TFhirContractTermOfferParty;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTermOfferParty.create;
  try
    ParseContractTermOfferPartyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermOfferPartyProperties(obj : TTurtleComplex; value : TFhirContractTermOfferParty);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.offer.party.reference') do
      value.referenceList.Add(parseReference(item));
    value.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.offer.party.role'));
end;

procedure TFHIRTurtleComposer.ComposeContractTermOfferParty(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractTermOfferParty; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTermOfferParty');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  for i := 0 to value.referenceList.Count - 1 do
      ComposeReference(this, 'Contract.term.offer.party', 'reference', value.referenceList[i], false, i);
  ComposeCodeableConcept(this, 'Contract.term.offer.party', 'role', value.roleElement, false, -1);
end;

function TFHIRTurtleParser.ParseContractTermOfferAnswer(obj : TTurtleComplex) : TFhirContractTermOfferAnswer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTermOfferAnswer.create;
  try
    ParseContractTermOfferAnswerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermOfferAnswerProperties(obj : TTurtleComplex; value : TFhirContractTermOfferAnswer);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('valueAttachment', item) then
      value.value := parseAttachment(item);
    if obj.has('valueCoding', item) then
      value.value := parseCoding(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueReference', item) {a3} then
      value.value := ParseReference(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    if obj.has('valueDecimal', item) then
      value.value := parseDecimal(item);
    if obj.has('valueInteger', item) then
      value.value := parseInteger(item);
    if obj.has('valueDate', item) then
      value.value := parseDate(item);
    if obj.has('valueDateTime', item) then
      value.value := parseDateTime(item);
    if obj.has('valueTime', item) then
      value.value := parseTime(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    if obj.has('valueUri', item) then
      value.value := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeContractTermOfferAnswer(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractTermOfferAnswer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTermOfferAnswer');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (value.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Contract.term.offer.answer', 'valueAttachment', TFhirAttachment(value.value), false, -1)
  else if (value.value is TFhirCoding) {6} then
    ComposeCoding(this, 'Contract.term.offer.answer', 'valueCoding', TFhirCoding(value.value), false, -1)
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Contract.term.offer.answer', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (value.value is TFhirReference) {2} then
    ComposeReference(this, 'Contract.term.offer.answer', 'valueReference', TFhirReference(value.value), false,-1)
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Contract.term.offer.answer', 'valueBoolean', TFhirBoolean(value.value), false, -1)
  else if (value.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'Contract.term.offer.answer', 'valueDecimal', TFhirDecimal(value.value), false, -1)
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Contract.term.offer.answer', 'valueInteger', TFhirInteger(value.value), false, -1)
  else if (value.value is TFhirDate) {6} then
    ComposeDate(this, 'Contract.term.offer.answer', 'valueDate', TFhirDate(value.value), false, -1)
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Contract.term.offer.answer', 'valueDateTime', TFhirDateTime(value.value), false, -1)
  else if (value.value is TFhirTime) {6} then
    ComposeTime(this, 'Contract.term.offer.answer', 'valueTime', TFhirTime(value.value), false, -1)
  else if (value.value is TFhirString) {6} then
    ComposeString(this, 'Contract.term.offer.answer', 'valueString', TFhirString(value.value), false, -1)
  else if (value.value is TFhirUri) {6} then
    ComposeUri(this, 'Contract.term.offer.answer', 'valueUri', TFhirUri(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseContractTermAsset(obj : TTurtleComplex) : TFhirContractTermAsset;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTermAsset.create;
  try
    ParseContractTermAssetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermAssetProperties(obj : TTurtleComplex; value : TFhirContractTermAsset);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.scope := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.asset.scope'));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.type') do
      value.type_List.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.typeReference') do
      value.typeReferenceList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.subtype') do
      value.subtypeList.Add(parseCodeableConcept(item));
    value.relationship := ParseCoding(obj.complex('http://hl7.org/fhir/Contract.term.asset.relationship'));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.context') do
      value.contextList.Add(parseContractTermAssetContext(item));
    value.conditionElement := ParseString(obj.complex('http://hl7.org/fhir/Contract.term.asset.condition'));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.periodType') do
      value.periodTypeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.period') do
      value.periodList.Add(parsePeriod(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.usePeriod') do
      value.usePeriodList.Add(parsePeriod(item));
    value.textElement := ParseString(obj.complex('http://hl7.org/fhir/Contract.term.asset.text'));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.linkId') do
      value.linkIdList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.answer') do
      value.answerList.Add(parseContractTermOfferAnswer(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.securityLabelNumber') do
      value.securityLabelNumberList.Add(parseUnsignedInt(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.valuedItem') do
      value.valuedItemList.Add(parseContractTermAssetValuedItem(item));
end;

procedure TFHIRTurtleComposer.ComposeContractTermAsset(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractTermAsset; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTermAsset');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Contract.term.asset', 'scope', value.scopeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Contract.term.asset', 'type', value.type_List[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.typeReferenceList.Count - 1 do
      ComposeReference(this, 'Contract.term.asset', 'typeReference', value.typeReferenceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subtypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract.term.asset', 'subtype', value.subtypeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'Contract.term.asset', 'relationship', value.relationshipElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contextList.Count - 1 do
      ComposeContractTermAssetContext(this, 'Contract.term.asset', 'context', value.contextList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Contract.term.asset', 'condition', value.conditionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.periodTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract.term.asset', 'periodType', value.periodTypeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.periodList.Count - 1 do
      ComposePeriod(this, 'Contract.term.asset', 'period', value.periodList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.usePeriodList.Count - 1 do
      ComposePeriod(this, 'Contract.term.asset', 'usePeriod', value.usePeriodList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Contract.term.asset', 'text', value.textElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.linkIdList.Count - 1 do
      ComposeString(this, 'Contract.term.asset', 'linkId', value.linkIdList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.answerList.Count - 1 do
      ComposeContractTermOfferAnswer(this, 'Contract.term.asset', 'answer', value.answerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.securityLabelNumberList.Count - 1 do
      ComposeUnsignedInt(this, 'Contract.term.asset', 'securityLabelNumber', value.securityLabelNumberList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.valuedItemList.Count - 1 do
      ComposeContractTermAssetValuedItem(this, 'Contract.term.asset', 'valuedItem', value.valuedItemList[i], false, i);
end;

function TFHIRTurtleParser.ParseContractTermAssetContext(obj : TTurtleComplex) : TFhirContractTermAssetContext;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTermAssetContext.create;
  try
    ParseContractTermAssetContextProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermAssetContextProperties(obj : TTurtleComplex; value : TFhirContractTermAssetContext);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.reference := ParseReference(obj.complex('http://hl7.org/fhir/Contract.term.asset.context.reference'));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.context.code') do
      value.codeList.Add(parseCodeableConcept(item));
    value.textElement := ParseString(obj.complex('http://hl7.org/fhir/Contract.term.asset.context.text'));
end;

procedure TFHIRTurtleComposer.ComposeContractTermAssetContext(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractTermAssetContext; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTermAssetContext');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Contract.term.asset.context', 'reference', value.referenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract.term.asset.context', 'code', value.codeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Contract.term.asset.context', 'text', value.textElement, false, -1);
end;

function TFHIRTurtleParser.ParseContractTermAssetValuedItem(obj : TTurtleComplex) : TFhirContractTermAssetValuedItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTermAssetValuedItem.create;
  try
    ParseContractTermAssetValuedItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermAssetValuedItemProperties(obj : TTurtleComplex; value : TFhirContractTermAssetValuedItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('entityCodeableConcept', item) then
      value.entity := parseCodeableConcept(item);
    if obj.has('entityReference', item) {a3} then
      value.entity := ParseReference(item);
    value.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Contract.term.asset.valuedItem.identifier'));
    value.effectiveTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Contract.term.asset.valuedItem.effectiveTime'));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Contract.term.asset.valuedItem.quantity'));
    value.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/Contract.term.asset.valuedItem.unitPrice'));
    value.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Contract.term.asset.valuedItem.factor'));
    value.pointsElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Contract.term.asset.valuedItem.points'));
    value.net := ParseMoney(obj.complex('http://hl7.org/fhir/Contract.term.asset.valuedItem.net'));
    value.paymentElement := ParseString(obj.complex('http://hl7.org/fhir/Contract.term.asset.valuedItem.payment'));
    value.paymentDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Contract.term.asset.valuedItem.paymentDate'));
    value.responsible := ParseReference(obj.complex('http://hl7.org/fhir/Contract.term.asset.valuedItem.responsible'));
    value.recipient := ParseReference(obj.complex('http://hl7.org/fhir/Contract.term.asset.valuedItem.recipient'));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.valuedItem.linkId') do
      value.linkIdList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.valuedItem.securityLabelNumber') do
      value.securityLabelNumberList.Add(parseUnsignedInt(item));
end;

procedure TFHIRTurtleComposer.ComposeContractTermAssetValuedItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractTermAssetValuedItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTermAssetValuedItem');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) and (value.entity is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Contract.term.asset.valuedItem', 'entityCodeableConcept', TFhirCodeableConcept(value.entity), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.entity is TFhirReference) {2} then
    ComposeReference(this, 'Contract.term.asset.valuedItem', 'entityReference', TFhirReference(value.entity), false,-1);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'Contract.term.asset.valuedItem', 'identifier', value.identifierElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Contract.term.asset.valuedItem', 'effectiveTime', value.effectiveTimeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Contract.term.asset.valuedItem', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Contract.term.asset.valuedItem', 'unitPrice', value.unitPriceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Contract.term.asset.valuedItem', 'factor', value.factorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Contract.term.asset.valuedItem', 'points', value.pointsElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Contract.term.asset.valuedItem', 'net', value.netElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Contract.term.asset.valuedItem', 'payment', value.paymentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Contract.term.asset.valuedItem', 'paymentDate', value.paymentDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Contract.term.asset.valuedItem', 'responsible', value.responsibleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Contract.term.asset.valuedItem', 'recipient', value.recipientElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.linkIdList.Count - 1 do
      ComposeString(this, 'Contract.term.asset.valuedItem', 'linkId', value.linkIdList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.securityLabelNumberList.Count - 1 do
      ComposeUnsignedInt(this, 'Contract.term.asset.valuedItem', 'securityLabelNumber', value.securityLabelNumberList[i], false, i);
end;

function TFHIRTurtleParser.ParseContractTermAction(obj : TTurtleComplex) : TFhirContractTermAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTermAction.create;
  try
    ParseContractTermActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermActionProperties(obj : TTurtleComplex; value : TFhirContractTermAction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.doNotPerformElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Contract.term.action.doNotPerform'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.action.type'));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.subject') do
      value.subjectList.Add(parseContractTermActionSubject(item));
    value.intent := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.action.intent'));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.linkId') do
      value.linkIdList.Add(parseString(item));
    value.status := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.action.status'));
    value.context := ParseReference(obj.complex('http://hl7.org/fhir/Contract.term.action.context'));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.contextLinkId') do
      value.contextLinkIdList.Add(parseString(item));
    if obj.has('occurrencePeriod', item) then
      value.occurrence := parsePeriod(item);
    if obj.has('occurrenceTiming', item) then
      value.occurrence := parseTiming(item);
    if obj.has('occurrenceDateTime', item) then
      value.occurrence := parseDateTime(item);
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.requester') do
      value.requesterList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.requesterLinkId') do
      value.requesterLinkIdList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.performerType') do
      value.performerTypeList.Add(parseCodeableConcept(item));
    value.performerRole := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.action.performerRole'));
    value.performer := ParseReference(obj.complex('http://hl7.org/fhir/Contract.term.action.performer'));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.performerLinkId') do
      value.performerLinkIdList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.reason') do
      value.reasonList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.reasonLinkId') do
      value.reasonLinkIdList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.securityLabelNumber') do
      value.securityLabelNumberList.Add(parseUnsignedInt(item));
end;

procedure TFHIRTurtleComposer.ComposeContractTermAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractTermAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTermAction');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Contract.term.action', 'doNotPerform', value.doNotPerformElement, false, -1);
  ComposeCodeableConcept(this, 'Contract.term.action', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subjectList.Count - 1 do
      ComposeContractTermActionSubject(this, 'Contract.term.action', 'subject', value.subjectList[i], false, i);
  ComposeCodeableConcept(this, 'Contract.term.action', 'intent', value.intentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.linkIdList.Count - 1 do
      ComposeString(this, 'Contract.term.action', 'linkId', value.linkIdList[i], false, i);
  ComposeCodeableConcept(this, 'Contract.term.action', 'status', value.statusElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Contract.term.action', 'context', value.contextElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contextLinkIdList.Count - 1 do
      ComposeString(this, 'Contract.term.action', 'contextLinkId', value.contextLinkIdList[i], false, i);
  if (SummaryOption in [soFull, soData]) and (value.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'Contract.term.action', 'occurrencePeriod', TFhirPeriod(value.occurrence), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.occurrence is TFhirTiming) {6} then
    ComposeTiming(this, 'Contract.term.action', 'occurrenceTiming', TFhirTiming(value.occurrence), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Contract.term.action', 'occurrenceDateTime', TFhirDateTime(value.occurrence), false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.requesterList.Count - 1 do
      ComposeReference(this, 'Contract.term.action', 'requester', value.requesterList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.requesterLinkIdList.Count - 1 do
      ComposeString(this, 'Contract.term.action', 'requesterLinkId', value.requesterLinkIdList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.performerTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract.term.action', 'performerType', value.performerTypeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Contract.term.action', 'performerRole', value.performerRoleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Contract.term.action', 'performer', value.performerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.performerLinkIdList.Count - 1 do
      ComposeString(this, 'Contract.term.action', 'performerLinkId', value.performerLinkIdList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(this, 'Contract.term.action', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonLinkIdList.Count - 1 do
      ComposeString(this, 'Contract.term.action', 'reasonLinkId', value.reasonLinkIdList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'Contract.term.action', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.securityLabelNumberList.Count - 1 do
      ComposeUnsignedInt(this, 'Contract.term.action', 'securityLabelNumber', value.securityLabelNumberList[i], false, i);
end;

function TFHIRTurtleParser.ParseContractTermActionSubject(obj : TTurtleComplex) : TFhirContractTermActionSubject;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTermActionSubject.create;
  try
    ParseContractTermActionSubjectProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermActionSubjectProperties(obj : TTurtleComplex; value : TFhirContractTermActionSubject);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.subject.reference') do
      value.referenceList.Add(parseReference(item));
    value.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.action.subject.role'));
end;

procedure TFHIRTurtleComposer.ComposeContractTermActionSubject(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractTermActionSubject; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTermActionSubject');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  for i := 0 to value.referenceList.Count - 1 do
      ComposeReference(this, 'Contract.term.action.subject', 'reference', value.referenceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Contract.term.action.subject', 'role', value.roleElement, false, -1);
end;

function TFHIRTurtleParser.ParseContractSigner(obj : TTurtleComplex) : TFhirContractSigner;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractSigner.create;
  try
    ParseContractSignerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractSignerProperties(obj : TTurtleComplex; value : TFhirContractSigner);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/Contract.signer.type'));
    value.party := ParseReference(obj.complex('http://hl7.org/fhir/Contract.signer.party'));
    for item in obj.complexes('http://hl7.org/fhir/Contract.signer.signature') do
      value.signatureList.Add(parseSignature(item));
end;

procedure TFHIRTurtleComposer.ComposeContractSigner(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractSigner; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractSigner');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCoding(this, 'Contract.signer', 'type', value.type_Element, false, -1);
  ComposeReference(this, 'Contract.signer', 'party', value.partyElement, false, -1);
  for i := 0 to value.signatureList.Count - 1 do
      ComposeSignature(this, 'Contract.signer', 'signature', value.signatureList[i], false, i);
end;

function TFHIRTurtleParser.ParseContractFriendly(obj : TTurtleComplex) : TFhirContractFriendly;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractFriendly.create;
  try
    ParseContractFriendlyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractFriendlyProperties(obj : TTurtleComplex; value : TFhirContractFriendly);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('contentAttachment', item) then
      value.content := parseAttachment(item);
    if obj.has('contentReference', item) {a3} then
      value.content := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeContractFriendly(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractFriendly; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractFriendly');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (value.content is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Contract.friendly', 'contentAttachment', TFhirAttachment(value.content), false, -1)
  else if (value.content is TFhirReference) {2} then
    ComposeReference(this, 'Contract.friendly', 'contentReference', TFhirReference(value.content), false,-1);
end;

function TFHIRTurtleParser.ParseContractLegal(obj : TTurtleComplex) : TFhirContractLegal;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractLegal.create;
  try
    ParseContractLegalProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractLegalProperties(obj : TTurtleComplex; value : TFhirContractLegal);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('contentAttachment', item) then
      value.content := parseAttachment(item);
    if obj.has('contentReference', item) {a3} then
      value.content := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeContractLegal(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractLegal; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractLegal');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (value.content is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Contract.legal', 'contentAttachment', TFhirAttachment(value.content), false, -1)
  else if (value.content is TFhirReference) {2} then
    ComposeReference(this, 'Contract.legal', 'contentReference', TFhirReference(value.content), false,-1);
end;

function TFHIRTurtleParser.ParseContractRule(obj : TTurtleComplex) : TFhirContractRule;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractRule.create;
  try
    ParseContractRuleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractRuleProperties(obj : TTurtleComplex; value : TFhirContractRule);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('contentAttachment', item) then
      value.content := parseAttachment(item);
    if obj.has('contentReference', item) {a3} then
      value.content := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeContractRule(parent :  TTurtleComplex; parentType, name : String; value : TFhirContractRule; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractRule');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (value.content is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Contract.rule', 'contentAttachment', TFhirAttachment(value.content), false, -1)
  else if (value.content is TFhirReference) {2} then
    ComposeReference(this, 'Contract.rule', 'contentReference', TFhirReference(value.content), false,-1);
end;

function TFHIRTurtleParser.ParseContract(obj : TTurtleComplex) : TFhirContract;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContract.create;
  try
    ParseContractProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractProperties(obj : TTurtleComplex; value : TFhirContract);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Contract.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Contract.url'));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Contract.version'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Contract.status'), CODES_TFhirContractResourceStatusCodesEnum, SYSTEMS_TFhirContractResourceStatusCodesEnum);
    value.legalState := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.legalState'));
    value.instantiatesCanonical := ParseReference(obj.complex('http://hl7.org/fhir/Contract.instantiatesCanonical'));
    value.instantiatesUriElement := ParseUri(obj.complex('http://hl7.org/fhir/Contract.instantiatesUri'));
    value.contentDerivative := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.contentDerivative'));
    value.issuedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Contract.issued'));
    value.applies := ParsePeriod(obj.complex('http://hl7.org/fhir/Contract.applies'));
    value.expirationType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.expirationType'));
    for item in obj.complexes('http://hl7.org/fhir/Contract.subject') do
      value.subjectList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.authority') do
      value.authorityList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.domain') do
      value.domainList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.site') do
      value.siteList.Add(parseReference(item));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Contract.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Contract.title'));
    value.subtitleElement := ParseString(obj.complex('http://hl7.org/fhir/Contract.subtitle'));
    for item in obj.complexes('http://hl7.org/fhir/Contract.alias') do
      value.aliasList.Add(parseString(item));
    value.author := ParseReference(obj.complex('http://hl7.org/fhir/Contract.author'));
    value.scope := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.scope'));
    if obj.has('topicCodeableConcept', item) then
      value.topic := parseCodeableConcept(item);
    if obj.has('topicReference', item) {a3} then
      value.topic := ParseReference(item);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.type'));
    for item in obj.complexes('http://hl7.org/fhir/Contract.subType') do
      value.subTypeList.Add(parseCodeableConcept(item));
    value.contentDefinition := ParseContractContentDefinition(obj.complex('http://hl7.org/fhir/Contract.contentDefinition'));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term') do
      value.termList.Add(parseContractTerm(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.supportingInfo') do
      value.supportingInfoList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.relevantHistory') do
      value.relevantHistoryList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.signer') do
      value.signerList.Add(parseContractSigner(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.friendly') do
      value.friendlyList.Add(parseContractFriendly(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.legal') do
      value.legalList.Add(parseContractLegal(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.rule') do
      value.ruleList.Add(parseContractRule(item));
    if obj.has('legallyBindingAttachment', item) then
      value.legallyBinding := parseAttachment(item);
    if obj.has('legallyBindingReference', item) {a3} then
      value.legallyBinding := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeContract(parent :  TTurtleComplex; parentType, name : String; value : TFhirContract; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Contract');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Contract', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'Contract', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Contract', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Contract', 'status', value.statusElement, CODES_TFhirContractResourceStatusCodesEnum, SYSTEMS_TFhirContractResourceStatusCodesEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Contract', 'legalState', value.legalStateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Contract', 'instantiatesCanonical', value.instantiatesCanonicalElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'Contract', 'instantiatesUri', value.instantiatesUriElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Contract', 'contentDerivative', value.contentDerivativeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Contract', 'issued', value.issuedElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Contract', 'applies', value.appliesElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Contract', 'expirationType', value.expirationTypeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.subjectList.Count - 1 do
      ComposeReference(this, 'Contract', 'subject', value.subjectList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorityList.Count - 1 do
      ComposeReference(this, 'Contract', 'authority', value.authorityList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.domainList.Count - 1 do
      ComposeReference(this, 'Contract', 'domain', value.domainList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.siteList.Count - 1 do
      ComposeReference(this, 'Contract', 'site', value.siteList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Contract', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Contract', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Contract', 'subtitle', value.subtitleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.aliasList.Count - 1 do
      ComposeString(this, 'Contract', 'alias', value.aliasList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Contract', 'author', value.authorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Contract', 'scope', value.scopeElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.topic is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Contract', 'topicCodeableConcept', TFhirCodeableConcept(value.topic), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.topic is TFhirReference) {2} then
    ComposeReference(this, 'Contract', 'topicReference', TFhirReference(value.topic), false,-1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Contract', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.subTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract', 'subType', value.subTypeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeContractContentDefinition(this, 'Contract', 'contentDefinition', value.contentDefinitionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.termList.Count - 1 do
      ComposeContractTerm(this, 'Contract', 'term', value.termList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInfoList.Count - 1 do
      ComposeReference(this, 'Contract', 'supportingInfo', value.supportingInfoList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relevantHistoryList.Count - 1 do
      ComposeReference(this, 'Contract', 'relevantHistory', value.relevantHistoryList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.signerList.Count - 1 do
      ComposeContractSigner(this, 'Contract', 'signer', value.signerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.friendlyList.Count - 1 do
      ComposeContractFriendly(this, 'Contract', 'friendly', value.friendlyList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.legalList.Count - 1 do
      ComposeContractLegal(this, 'Contract', 'legal', value.legalList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.ruleList.Count - 1 do
      ComposeContractRule(this, 'Contract', 'rule', value.ruleList[i], false, i);
  if (SummaryOption in [soFull, soData]) and (value.legallyBinding is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Contract', 'legallyBindingAttachment', TFhirAttachment(value.legallyBinding), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.legallyBinding is TFhirReference) {2} then
    ComposeReference(this, 'Contract', 'legallyBindingReference', TFhirReference(value.legallyBinding), false,-1);
end;

{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
function TFHIRTurtleParser.ParseCoveragePaymentBy(obj : TTurtleComplex) : TFhirCoveragePaymentBy;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoveragePaymentBy.create;
  try
    ParseCoveragePaymentByProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoveragePaymentByProperties(obj : TTurtleComplex; value : TFhirCoveragePaymentBy);
begin
    ParseBackboneElementProperties(obj, value);
    value.party := ParseReference(obj.complex('http://hl7.org/fhir/Coverage.paymentBy.party'));
    value.responsibilityElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.paymentBy.responsibility'));
end;

procedure TFHIRTurtleComposer.ComposeCoveragePaymentBy(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoveragePaymentBy; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoveragePaymentBy');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeReference(this, 'Coverage.paymentBy', 'party', value.partyElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Coverage.paymentBy', 'responsibility', value.responsibilityElement, false, -1);
end;

function TFHIRTurtleParser.ParseCoverageClass(obj : TTurtleComplex) : TFhirCoverageClass;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageClass.create;
  try
    ParseCoverageClassProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageClassProperties(obj : TTurtleComplex; value : TFhirCoverageClass);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Coverage.class.type'));
    value.value := ParseIdentifier(obj.complex('http://hl7.org/fhir/Coverage.class.value'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.class.name'));
end;

procedure TFHIRTurtleComposer.ComposeCoverageClass(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageClass; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageClass');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'Coverage.class', 'type', value.type_Element, false, -1);
  ComposeIdentifier(this, 'Coverage.class', 'value', value.valueElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Coverage.class', 'name', value.nameElement, false, -1);
end;

function TFHIRTurtleParser.ParseCoverageCostToBeneficiary(obj : TTurtleComplex) : TFhirCoverageCostToBeneficiary;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageCostToBeneficiary.create;
  try
    ParseCoverageCostToBeneficiaryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageCostToBeneficiaryProperties(obj : TTurtleComplex; value : TFhirCoverageCostToBeneficiary);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Coverage.costToBeneficiary.type'));
    value.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Coverage.costToBeneficiary.category'));
    value.network := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Coverage.costToBeneficiary.network'));
    value.unit_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Coverage.costToBeneficiary.unit'));
    value.term := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Coverage.costToBeneficiary.term'));
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueMoney', item) then
      value.value := parseMoney(item);
    for item in obj.complexes('http://hl7.org/fhir/Coverage.costToBeneficiary.exception') do
      value.exceptionList.Add(parseCoverageCostToBeneficiaryException(item));
end;

procedure TFHIRTurtleComposer.ComposeCoverageCostToBeneficiary(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageCostToBeneficiary; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageCostToBeneficiary');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Coverage.costToBeneficiary', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Coverage.costToBeneficiary', 'category', value.categoryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Coverage.costToBeneficiary', 'network', value.networkElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Coverage.costToBeneficiary', 'unit', value.unit_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Coverage.costToBeneficiary', 'term', value.termElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Coverage.costToBeneficiary', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirMoney) {6} then
    ComposeMoney(this, 'Coverage.costToBeneficiary', 'valueMoney', TFhirMoney(value.value), false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.exceptionList.Count - 1 do
      ComposeCoverageCostToBeneficiaryException(this, 'Coverage.costToBeneficiary', 'exception', value.exceptionList[i], false, i);
end;

function TFHIRTurtleParser.ParseCoverageCostToBeneficiaryException(obj : TTurtleComplex) : TFhirCoverageCostToBeneficiaryException;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageCostToBeneficiaryException.create;
  try
    ParseCoverageCostToBeneficiaryExceptionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageCostToBeneficiaryExceptionProperties(obj : TTurtleComplex; value : TFhirCoverageCostToBeneficiaryException);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Coverage.costToBeneficiary.exception.type'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Coverage.costToBeneficiary.exception.period'));
end;

procedure TFHIRTurtleComposer.ComposeCoverageCostToBeneficiaryException(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageCostToBeneficiaryException; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageCostToBeneficiaryException');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'Coverage.costToBeneficiary.exception', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Coverage.costToBeneficiary.exception', 'period', value.periodElement, false, -1);
end;

function TFHIRTurtleParser.ParseCoverage(obj : TTurtleComplex) : TFhirCoverage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverage.create;
  try
    ParseCoverageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageProperties(obj : TTurtleComplex; value : TFhirCoverage);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Coverage.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Coverage.status'), CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum);
    value.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/Coverage.kind'), CODES_TFhirKindEnum, SYSTEMS_TFhirKindEnum);
    for item in obj.complexes('http://hl7.org/fhir/Coverage.paymentBy') do
      value.paymentByList.Add(parseCoveragePaymentBy(item));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Coverage.type'));
    value.policyHolder := ParseReference(obj.complex('http://hl7.org/fhir/Coverage.policyHolder'));
    value.subscriber := ParseReference(obj.complex('http://hl7.org/fhir/Coverage.subscriber'));
    for item in obj.complexes('http://hl7.org/fhir/Coverage.subscriberId') do
      value.subscriberIdList.Add(parseIdentifier(item));
    value.beneficiary := ParseReference(obj.complex('http://hl7.org/fhir/Coverage.beneficiary'));
    value.dependentElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.dependent'));
    value.relationship := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Coverage.relationship'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Coverage.period'));
    value.insurer := ParseReference(obj.complex('http://hl7.org/fhir/Coverage.insurer'));
    for item in obj.complexes('http://hl7.org/fhir/Coverage.class') do
      value.class_List.Add(parseCoverageClass(item));
    value.orderElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Coverage.order'));
    value.networkElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.network'));
    for item in obj.complexes('http://hl7.org/fhir/Coverage.costToBeneficiary') do
      value.costToBeneficiaryList.Add(parseCoverageCostToBeneficiary(item));
    value.subrogationElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Coverage.subrogation'));
    for item in obj.complexes('http://hl7.org/fhir/Coverage.contract') do
      value.contractList.Add(parseReference(item));
    value.insurancePlan := ParseReference(obj.complex('http://hl7.org/fhir/Coverage.insurancePlan'));
end;

procedure TFHIRTurtleComposer.ComposeCoverage(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Coverage');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Coverage', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'Coverage', 'status', value.statusElement, CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum, false, -1);
  ComposeEnum(this, 'Coverage', 'kind', value.kindElement, CODES_TFhirKindEnum, SYSTEMS_TFhirKindEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.paymentByList.Count - 1 do
      ComposeCoveragePaymentBy(this, 'Coverage', 'paymentBy', value.paymentByList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Coverage', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Coverage', 'policyHolder', value.policyHolderElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Coverage', 'subscriber', value.subscriberElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.subscriberIdList.Count - 1 do
      ComposeIdentifier(this, 'Coverage', 'subscriberId', value.subscriberIdList[i], false, i);
  ComposeReference(this, 'Coverage', 'beneficiary', value.beneficiaryElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Coverage', 'dependent', value.dependentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Coverage', 'relationship', value.relationshipElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Coverage', 'period', value.periodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Coverage', 'insurer', value.insurerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.class_List.Count - 1 do
      ComposeCoverageClass(this, 'Coverage', 'class', value.class_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'Coverage', 'order', value.orderElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Coverage', 'network', value.networkElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.costToBeneficiaryList.Count - 1 do
      ComposeCoverageCostToBeneficiary(this, 'Coverage', 'costToBeneficiary', value.costToBeneficiaryList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Coverage', 'subrogation', value.subrogationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contractList.Count - 1 do
      ComposeReference(this, 'Coverage', 'contract', value.contractList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Coverage', 'insurancePlan', value.insurancePlanElement, false, -1);
end;

{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
function TFHIRTurtleParser.ParseCoverageEligibilityRequestSupportingInfo(obj : TTurtleComplex) : TFhirCoverageEligibilityRequestSupportingInfo;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageEligibilityRequestSupportingInfo.create;
  try
    ParseCoverageEligibilityRequestSupportingInfoProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageEligibilityRequestSupportingInfoProperties(obj : TTurtleComplex; value : TFhirCoverageEligibilityRequestSupportingInfo);
begin
    ParseBackboneElementProperties(obj, value);
    value.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.supportingInfo.sequence'));
    value.information := ParseReference(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.supportingInfo.information'));
    value.appliesToAllElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.supportingInfo.appliesToAll'));
end;

procedure TFHIRTurtleComposer.ComposeCoverageEligibilityRequestSupportingInfo(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageEligibilityRequestSupportingInfo; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageEligibilityRequestSupportingInfo');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposePositiveInt(this, 'CoverageEligibilityRequest.supportingInfo', 'sequence', value.sequenceElement, false, -1);
  ComposeReference(this, 'CoverageEligibilityRequest.supportingInfo', 'information', value.informationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CoverageEligibilityRequest.supportingInfo', 'appliesToAll', value.appliesToAllElement, false, -1);
end;

function TFHIRTurtleParser.ParseCoverageEligibilityRequestInsurance(obj : TTurtleComplex) : TFhirCoverageEligibilityRequestInsurance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageEligibilityRequestInsurance.create;
  try
    ParseCoverageEligibilityRequestInsuranceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageEligibilityRequestInsuranceProperties(obj : TTurtleComplex; value : TFhirCoverageEligibilityRequestInsurance);
begin
    ParseBackboneElementProperties(obj, value);
    value.focalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.insurance.focal'));
    value.coverage := ParseReference(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.insurance.coverage'));
    value.businessArrangementElement := ParseString(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.insurance.businessArrangement'));
end;

procedure TFHIRTurtleComposer.ComposeCoverageEligibilityRequestInsurance(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageEligibilityRequestInsurance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageEligibilityRequestInsurance');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CoverageEligibilityRequest.insurance', 'focal', value.focalElement, false, -1);
  ComposeReference(this, 'CoverageEligibilityRequest.insurance', 'coverage', value.coverageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CoverageEligibilityRequest.insurance', 'businessArrangement', value.businessArrangementElement, false, -1);
end;

function TFHIRTurtleParser.ParseCoverageEligibilityRequestItem(obj : TTurtleComplex) : TFhirCoverageEligibilityRequestItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageEligibilityRequestItem.create;
  try
    ParseCoverageEligibilityRequestItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageEligibilityRequestItemProperties(obj : TTurtleComplex; value : TFhirCoverageEligibilityRequestItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityRequest.item.supportingInfoSequence') do
      value.supportingInfoSequenceList.Add(parsePositiveInt(item));
    value.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.item.category'));
    value.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.item.productOrService'));
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityRequest.item.modifier') do
      value.modifierList.Add(parseCodeableConcept(item));
    value.provider := ParseReference(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.item.provider'));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.item.quantity'));
    value.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.item.unitPrice'));
    value.facility := ParseReference(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.item.facility'));
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityRequest.item.diagnosis') do
      value.diagnosisList.Add(parseCoverageEligibilityRequestItemDiagnosis(item));
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityRequest.item.detail') do
      value.detailList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeCoverageEligibilityRequestItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageEligibilityRequestItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageEligibilityRequestItem');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInfoSequenceList.Count - 1 do
      ComposePositiveInt(this, 'CoverageEligibilityRequest.item', 'supportingInfoSequence', value.supportingInfoSequenceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CoverageEligibilityRequest.item', 'category', value.categoryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CoverageEligibilityRequest.item', 'productOrService', value.productOrServiceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'CoverageEligibilityRequest.item', 'modifier', value.modifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'CoverageEligibilityRequest.item', 'provider', value.providerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'CoverageEligibilityRequest.item', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'CoverageEligibilityRequest.item', 'unitPrice', value.unitPriceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'CoverageEligibilityRequest.item', 'facility', value.facilityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.diagnosisList.Count - 1 do
      ComposeCoverageEligibilityRequestItemDiagnosis(this, 'CoverageEligibilityRequest.item', 'diagnosis', value.diagnosisList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.detailList.Count - 1 do
      ComposeReference(this, 'CoverageEligibilityRequest.item', 'detail', value.detailList[i], false, i);
end;

function TFHIRTurtleParser.ParseCoverageEligibilityRequestItemDiagnosis(obj : TTurtleComplex) : TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageEligibilityRequestItemDiagnosis.create;
  try
    ParseCoverageEligibilityRequestItemDiagnosisProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageEligibilityRequestItemDiagnosisProperties(obj : TTurtleComplex; value : TFhirCoverageEligibilityRequestItemDiagnosis);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('diagnosisCodeableConcept', item) then
      value.diagnosis := parseCodeableConcept(item);
    if obj.has('diagnosisReference', item) {a3} then
      value.diagnosis := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeCoverageEligibilityRequestItemDiagnosis(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageEligibilityRequestItemDiagnosis; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageEligibilityRequestItemDiagnosis');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) and (value.diagnosis is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'CoverageEligibilityRequest.item.diagnosis', 'diagnosisCodeableConcept', TFhirCodeableConcept(value.diagnosis), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.diagnosis is TFhirReference) {2} then
    ComposeReference(this, 'CoverageEligibilityRequest.item.diagnosis', 'diagnosisReference', TFhirReference(value.diagnosis), false,-1);
end;

function TFHIRTurtleParser.ParseCoverageEligibilityRequest(obj : TTurtleComplex) : TFhirCoverageEligibilityRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageEligibilityRequest.create;
  try
    ParseCoverageEligibilityRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageEligibilityRequestProperties(obj : TTurtleComplex; value : TFhirCoverageEligibilityRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityRequest.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.status'), CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum);
    value.priority := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.priority'));
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityRequest.purpose') do
      value.purposeList.Add(parseEnum(item, CODES_TFhirEligibilityRequestPurposeEnum, SYSTEMS_TFhirEligibilityRequestPurposeEnum));
    value.patient := ParseReference(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.patient'));
    if obj.has('servicedPeriod', item) then
      value.serviced := parsePeriod(item);
    if obj.has('servicedDate', item) then
      value.serviced := parseDate(item);
    value.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.created'));
    value.enterer := ParseReference(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.enterer'));
    value.provider := ParseReference(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.provider'));
    value.insurer := ParseReference(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.insurer'));
    value.facility := ParseReference(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.facility'));
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityRequest.supportingInfo') do
      value.supportingInfoList.Add(parseCoverageEligibilityRequestSupportingInfo(item));
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityRequest.insurance') do
      value.insuranceList.Add(parseCoverageEligibilityRequestInsurance(item));
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityRequest.item') do
      value.itemList.Add(parseCoverageEligibilityRequestItem(item));
end;

procedure TFHIRTurtleComposer.ComposeCoverageEligibilityRequest(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageEligibilityRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageEligibilityRequest');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'CoverageEligibilityRequest', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'CoverageEligibilityRequest', 'status', value.statusElement, CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CoverageEligibilityRequest', 'priority', value.priorityElement, false, -1);
  for i := 0 to value.purposeList.Count - 1 do
      ComposeEnum(this, 'CoverageEligibilityRequest', 'purpose', value.purposeList[i], CODES_TFhirEligibilityRequestPurposeEnum, SYSTEMS_TFhirEligibilityRequestPurposeEnum, false, i); {x.d1}
  for i := 0 to value.purposeList.Count - 1 do
      ComposeEnum(this, 'CoverageEligibilityRequest', 'purpose', value.purposeList[i], CODES_TFhirEligibilityRequestPurposeEnum, SYSTEMS_TFhirEligibilityRequestPurposeEnum, false, i);
  ComposeReference(this, 'CoverageEligibilityRequest', 'patient', value.patientElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirPeriod) {6} then
    ComposePeriod(this, 'CoverageEligibilityRequest', 'servicedPeriod', TFhirPeriod(value.serviced), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirDate) {6} then
    ComposeDate(this, 'CoverageEligibilityRequest', 'servicedDate', TFhirDate(value.serviced), false, -1);
  ComposeDateTime(this, 'CoverageEligibilityRequest', 'created', value.createdElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'CoverageEligibilityRequest', 'enterer', value.entererElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'CoverageEligibilityRequest', 'provider', value.providerElement, false, -1);
  ComposeReference(this, 'CoverageEligibilityRequest', 'insurer', value.insurerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'CoverageEligibilityRequest', 'facility', value.facilityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInfoList.Count - 1 do
      ComposeCoverageEligibilityRequestSupportingInfo(this, 'CoverageEligibilityRequest', 'supportingInfo', value.supportingInfoList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.insuranceList.Count - 1 do
      ComposeCoverageEligibilityRequestInsurance(this, 'CoverageEligibilityRequest', 'insurance', value.insuranceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.itemList.Count - 1 do
      ComposeCoverageEligibilityRequestItem(this, 'CoverageEligibilityRequest', 'item', value.itemList[i], false, i);
end;

{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
function TFHIRTurtleParser.ParseCoverageEligibilityResponseInsurance(obj : TTurtleComplex) : TFhirCoverageEligibilityResponseInsurance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageEligibilityResponseInsurance.create;
  try
    ParseCoverageEligibilityResponseInsuranceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageEligibilityResponseInsuranceProperties(obj : TTurtleComplex; value : TFhirCoverageEligibilityResponseInsurance);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.coverage := ParseReference(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.coverage'));
    value.inforceElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.inforce'));
    value.benefitPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.benefitPeriod'));
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item') do
      value.itemList.Add(parseCoverageEligibilityResponseInsuranceItem(item));
end;

procedure TFHIRTurtleComposer.ComposeCoverageEligibilityResponseInsurance(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageEligibilityResponseInsurance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageEligibilityResponseInsurance');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeReference(this, 'CoverageEligibilityResponse.insurance', 'coverage', value.coverageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CoverageEligibilityResponse.insurance', 'inforce', value.inforceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'CoverageEligibilityResponse.insurance', 'benefitPeriod', value.benefitPeriodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.itemList.Count - 1 do
      ComposeCoverageEligibilityResponseInsuranceItem(this, 'CoverageEligibilityResponse.insurance', 'item', value.itemList[i], false, i);
end;

function TFHIRTurtleParser.ParseCoverageEligibilityResponseInsuranceItem(obj : TTurtleComplex) : TFhirCoverageEligibilityResponseInsuranceItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageEligibilityResponseInsuranceItem.create;
  try
    ParseCoverageEligibilityResponseInsuranceItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageEligibilityResponseInsuranceItemProperties(obj : TTurtleComplex; value : TFhirCoverageEligibilityResponseInsuranceItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.category'));
    value.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.productOrService'));
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.modifier') do
      value.modifierList.Add(parseCodeableConcept(item));
    value.provider := ParseReference(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.provider'));
    value.excludedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.excluded'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.name'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.description'));
    value.network := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.network'));
    value.unit_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.unit'));
    value.term := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.term'));
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.benefit') do
      value.benefitList.Add(parseCoverageEligibilityResponseInsuranceItemBenefit(item));
    value.authorizationRequiredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.authorizationRequired'));
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.authorizationSupporting') do
      value.authorizationSupportingList.Add(parseCodeableConcept(item));
    value.authorizationUrlElement := ParseUri(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.authorizationUrl'));
end;

procedure TFHIRTurtleComposer.ComposeCoverageEligibilityResponseInsuranceItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageEligibilityResponseInsuranceItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageEligibilityResponseInsuranceItem');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CoverageEligibilityResponse.insurance.item', 'category', value.categoryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CoverageEligibilityResponse.insurance.item', 'productOrService', value.productOrServiceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'CoverageEligibilityResponse.insurance.item', 'modifier', value.modifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'CoverageEligibilityResponse.insurance.item', 'provider', value.providerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CoverageEligibilityResponse.insurance.item', 'excluded', value.excludedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CoverageEligibilityResponse.insurance.item', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CoverageEligibilityResponse.insurance.item', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CoverageEligibilityResponse.insurance.item', 'network', value.networkElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CoverageEligibilityResponse.insurance.item', 'unit', value.unit_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CoverageEligibilityResponse.insurance.item', 'term', value.termElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.benefitList.Count - 1 do
      ComposeCoverageEligibilityResponseInsuranceItemBenefit(this, 'CoverageEligibilityResponse.insurance.item', 'benefit', value.benefitList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CoverageEligibilityResponse.insurance.item', 'authorizationRequired', value.authorizationRequiredElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorizationSupportingList.Count - 1 do
      ComposeCodeableConcept(this, 'CoverageEligibilityResponse.insurance.item', 'authorizationSupporting', value.authorizationSupportingList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'CoverageEligibilityResponse.insurance.item', 'authorizationUrl', value.authorizationUrlElement, false, -1);
end;

function TFHIRTurtleParser.ParseCoverageEligibilityResponseInsuranceItemBenefit(obj : TTurtleComplex) : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefit.create;
  try
    ParseCoverageEligibilityResponseInsuranceItemBenefitProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageEligibilityResponseInsuranceItemBenefitProperties(obj : TTurtleComplex; value : TFhirCoverageEligibilityResponseInsuranceItemBenefit);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.benefit.type'));
    if obj.has('allowedUnsignedInt', item) then
      value.allowed := parseUnsignedInt(item);
    if obj.has('allowedMoney', item) then
      value.allowed := parseMoney(item);
    if obj.has('allowedString', item) then
      value.allowed := parseString(item);
    if obj.has('usedUnsignedInt', item) then
      value.used := parseUnsignedInt(item);
    if obj.has('usedMoney', item) then
      value.used := parseMoney(item);
    if obj.has('usedString', item) then
      value.used := parseString(item);
end;

procedure TFHIRTurtleComposer.ComposeCoverageEligibilityResponseInsuranceItemBenefit(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageEligibilityResponseInsuranceItemBenefit; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageEligibilityResponseInsuranceItemBenefit');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'CoverageEligibilityResponse.insurance.item.benefit', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.allowed is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'CoverageEligibilityResponse.insurance.item.benefit', 'allowedUnsignedInt', TFhirUnsignedInt(value.allowed), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.allowed is TFhirMoney) {6} then
    ComposeMoney(this, 'CoverageEligibilityResponse.insurance.item.benefit', 'allowedMoney', TFhirMoney(value.allowed), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.allowed is TFhirString) {6} then
    ComposeString(this, 'CoverageEligibilityResponse.insurance.item.benefit', 'allowedString', TFhirString(value.allowed), false, -1);
  if (SummaryOption in [soFull, soData]) and (value.used is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'CoverageEligibilityResponse.insurance.item.benefit', 'usedUnsignedInt', TFhirUnsignedInt(value.used), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.used is TFhirMoney) {6} then
    ComposeMoney(this, 'CoverageEligibilityResponse.insurance.item.benefit', 'usedMoney', TFhirMoney(value.used), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.used is TFhirString) {6} then
    ComposeString(this, 'CoverageEligibilityResponse.insurance.item.benefit', 'usedString', TFhirString(value.used), false, -1);
end;

function TFHIRTurtleParser.ParseCoverageEligibilityResponseError(obj : TTurtleComplex) : TFhirCoverageEligibilityResponseError;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageEligibilityResponseError.create;
  try
    ParseCoverageEligibilityResponseErrorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageEligibilityResponseErrorProperties(obj : TTurtleComplex; value : TFhirCoverageEligibilityResponseError);
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.error.code'));
end;

procedure TFHIRTurtleComposer.ComposeCoverageEligibilityResponseError(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageEligibilityResponseError; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageEligibilityResponseError');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'CoverageEligibilityResponse.error', 'code', value.codeElement, false, -1);
end;

function TFHIRTurtleParser.ParseCoverageEligibilityResponse(obj : TTurtleComplex) : TFhirCoverageEligibilityResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageEligibilityResponse.create;
  try
    ParseCoverageEligibilityResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageEligibilityResponseProperties(obj : TTurtleComplex; value : TFhirCoverageEligibilityResponse);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityResponse.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.status'), CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum);
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityResponse.purpose') do
      value.purposeList.Add(parseEnum(item, CODES_TFhirEligibilityResponsePurposeEnum, SYSTEMS_TFhirEligibilityResponsePurposeEnum));
    value.patient := ParseReference(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.patient'));
    if obj.has('servicedPeriod', item) then
      value.serviced := parsePeriod(item);
    if obj.has('servicedDate', item) then
      value.serviced := parseDate(item);
    value.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.created'));
    value.requestor := ParseReference(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.requestor'));
    value.request := ParseReference(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.request'));
    value.outcomeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.outcome'), CODES_TFhirEligibilityOutcomeEnum, SYSTEMS_TFhirEligibilityOutcomeEnum);
    value.dispositionElement := ParseString(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.disposition'));
    value.insurer := ParseReference(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurer'));
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityResponse.insurance') do
      value.insuranceList.Add(parseCoverageEligibilityResponseInsurance(item));
    value.preAuthRefElement := ParseString(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.preAuthRef'));
    value.form := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.form'));
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityResponse.error') do
      value.errorList.Add(parseCoverageEligibilityResponseError(item));
end;

procedure TFHIRTurtleComposer.ComposeCoverageEligibilityResponse(parent :  TTurtleComplex; parentType, name : String; value : TFhirCoverageEligibilityResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageEligibilityResponse');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'CoverageEligibilityResponse', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'CoverageEligibilityResponse', 'status', value.statusElement, CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum, false, -1);
  for i := 0 to value.purposeList.Count - 1 do
      ComposeEnum(this, 'CoverageEligibilityResponse', 'purpose', value.purposeList[i], CODES_TFhirEligibilityResponsePurposeEnum, SYSTEMS_TFhirEligibilityResponsePurposeEnum, false, i); {x.d1}
  for i := 0 to value.purposeList.Count - 1 do
      ComposeEnum(this, 'CoverageEligibilityResponse', 'purpose', value.purposeList[i], CODES_TFhirEligibilityResponsePurposeEnum, SYSTEMS_TFhirEligibilityResponsePurposeEnum, false, i);
  ComposeReference(this, 'CoverageEligibilityResponse', 'patient', value.patientElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirPeriod) {6} then
    ComposePeriod(this, 'CoverageEligibilityResponse', 'servicedPeriod', TFhirPeriod(value.serviced), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirDate) {6} then
    ComposeDate(this, 'CoverageEligibilityResponse', 'servicedDate', TFhirDate(value.serviced), false, -1);
  ComposeDateTime(this, 'CoverageEligibilityResponse', 'created', value.createdElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'CoverageEligibilityResponse', 'requestor', value.requestorElement, false, -1);
  ComposeReference(this, 'CoverageEligibilityResponse', 'request', value.requestElement, false, -1);
  ComposeEnum(this, 'CoverageEligibilityResponse', 'outcome', value.outcomeElement, CODES_TFhirEligibilityOutcomeEnum, SYSTEMS_TFhirEligibilityOutcomeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CoverageEligibilityResponse', 'disposition', value.dispositionElement, false, -1);
  ComposeReference(this, 'CoverageEligibilityResponse', 'insurer', value.insurerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.insuranceList.Count - 1 do
      ComposeCoverageEligibilityResponseInsurance(this, 'CoverageEligibilityResponse', 'insurance', value.insuranceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CoverageEligibilityResponse', 'preAuthRef', value.preAuthRefElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CoverageEligibilityResponse', 'form', value.formElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.errorList.Count - 1 do
      ComposeCoverageEligibilityResponseError(this, 'CoverageEligibilityResponse', 'error', value.errorList[i], false, i);
end;

{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_DETECTEDISSUE}
function TFHIRTurtleParser.ParseDetectedIssueEvidence(obj : TTurtleComplex) : TFhirDetectedIssueEvidence;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDetectedIssueEvidence.create;
  try
    ParseDetectedIssueEvidenceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDetectedIssueEvidenceProperties(obj : TTurtleComplex; value : TFhirDetectedIssueEvidence);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/DetectedIssue.evidence.code') do
      value.codeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/DetectedIssue.evidence.detail') do
      value.detailList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeDetectedIssueEvidence(parent :  TTurtleComplex; parentType, name : String; value : TFhirDetectedIssueEvidence; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DetectedIssueEvidence');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCodeableConcept(this, 'DetectedIssue.evidence', 'code', value.codeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.detailList.Count - 1 do
      ComposeReference(this, 'DetectedIssue.evidence', 'detail', value.detailList[i], false, i);
end;

function TFHIRTurtleParser.ParseDetectedIssueMitigation(obj : TTurtleComplex) : TFhirDetectedIssueMitigation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDetectedIssueMitigation.create;
  try
    ParseDetectedIssueMitigationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDetectedIssueMitigationProperties(obj : TTurtleComplex; value : TFhirDetectedIssueMitigation);
begin
    ParseBackboneElementProperties(obj, value);
    value.action := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DetectedIssue.mitigation.action'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DetectedIssue.mitigation.date'));
    value.author := ParseReference(obj.complex('http://hl7.org/fhir/DetectedIssue.mitigation.author'));
end;

procedure TFHIRTurtleComposer.ComposeDetectedIssueMitigation(parent :  TTurtleComplex; parentType, name : String; value : TFhirDetectedIssueMitigation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DetectedIssueMitigation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'DetectedIssue.mitigation', 'action', value.actionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'DetectedIssue.mitigation', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'DetectedIssue.mitigation', 'author', value.authorElement, false, -1);
end;

function TFHIRTurtleParser.ParseDetectedIssue(obj : TTurtleComplex) : TFhirDetectedIssue;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDetectedIssue.create;
  try
    ParseDetectedIssueProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDetectedIssueProperties(obj : TTurtleComplex; value : TFhirDetectedIssue);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/DetectedIssue.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DetectedIssue.status'), CODES_TFhirDetectedIssueStatusEnum, SYSTEMS_TFhirDetectedIssueStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/DetectedIssue.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DetectedIssue.code'));
    value.severityElement := ParseEnum(obj.complex('http://hl7.org/fhir/DetectedIssue.severity'), CODES_TFhirDetectedIssueSeverityEnum, SYSTEMS_TFhirDetectedIssueSeverityEnum);
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/DetectedIssue.subject'));
    if obj.has('identifiedPeriod', item) then
      value.identified := parsePeriod(item);
    if obj.has('identifiedDateTime', item) then
      value.identified := parseDateTime(item);
    value.author := ParseReference(obj.complex('http://hl7.org/fhir/DetectedIssue.author'));
    for item in obj.complexes('http://hl7.org/fhir/DetectedIssue.implicated') do
      value.implicatedList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/DetectedIssue.evidence') do
      value.evidenceList.Add(parseDetectedIssueEvidence(item));
    value.detailElement := ParseString(obj.complex('http://hl7.org/fhir/DetectedIssue.detail'));
    value.referenceElement := ParseUri(obj.complex('http://hl7.org/fhir/DetectedIssue.reference'));
    for item in obj.complexes('http://hl7.org/fhir/DetectedIssue.mitigation') do
      value.mitigationList.Add(parseDetectedIssueMitigation(item));
end;

procedure TFHIRTurtleComposer.ComposeDetectedIssue(parent :  TTurtleComplex; parentType, name : String; value : TFhirDetectedIssue; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DetectedIssue');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DetectedIssue', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'DetectedIssue', 'status', value.statusElement, CODES_TFhirDetectedIssueStatusEnum, SYSTEMS_TFhirDetectedIssueStatusEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'DetectedIssue', 'category', value.categoryList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DetectedIssue', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'DetectedIssue', 'severity', value.severityElement, CODES_TFhirDetectedIssueSeverityEnum, SYSTEMS_TFhirDetectedIssueSeverityEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'DetectedIssue', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.identified is TFhirPeriod) {6} then
    ComposePeriod(this, 'DetectedIssue', 'identifiedPeriod', TFhirPeriod(value.identified), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.identified is TFhirDateTime) {6} then
    ComposeDateTime(this, 'DetectedIssue', 'identifiedDateTime', TFhirDateTime(value.identified), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'DetectedIssue', 'author', value.authorElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.implicatedList.Count - 1 do
      ComposeReference(this, 'DetectedIssue', 'implicated', value.implicatedList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.evidenceList.Count - 1 do
      ComposeDetectedIssueEvidence(this, 'DetectedIssue', 'evidence', value.evidenceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'DetectedIssue', 'detail', value.detailElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'DetectedIssue', 'reference', value.referenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.mitigationList.Count - 1 do
      ComposeDetectedIssueMitigation(this, 'DetectedIssue', 'mitigation', value.mitigationList[i], false, i);
end;

{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
function TFHIRTurtleParser.ParseDeviceUdiCarrier(obj : TTurtleComplex) : TFhirDeviceUdiCarrier;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceUdiCarrier.create;
  try
    ParseDeviceUdiCarrierProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceUdiCarrierProperties(obj : TTurtleComplex; value : TFhirDeviceUdiCarrier);
begin
    ParseBackboneElementProperties(obj, value);
    value.deviceIdentifierElement := ParseString(obj.complex('http://hl7.org/fhir/Device.udiCarrier.deviceIdentifier'));
    value.issuerElement := ParseUri(obj.complex('http://hl7.org/fhir/Device.udiCarrier.issuer'));
    value.jurisdictionElement := ParseUri(obj.complex('http://hl7.org/fhir/Device.udiCarrier.jurisdiction'));
    value.carrierAIDCElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/Device.udiCarrier.carrierAIDC'));
    value.carrierHRFElement := ParseString(obj.complex('http://hl7.org/fhir/Device.udiCarrier.carrierHRF'));
    value.entryTypeElement := ParseEnum(obj.complex('http://hl7.org/fhir/Device.udiCarrier.entryType'), CODES_TFhirUDIEntryTypeEnum, SYSTEMS_TFhirUDIEntryTypeEnum);
end;

procedure TFHIRTurtleComposer.ComposeDeviceUdiCarrier(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceUdiCarrier; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceUdiCarrier');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'Device.udiCarrier', 'deviceIdentifier', value.deviceIdentifierElement, false, -1);
  ComposeUri(this, 'Device.udiCarrier', 'issuer', value.issuerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'Device.udiCarrier', 'jurisdiction', value.jurisdictionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64Binary(this, 'Device.udiCarrier', 'carrierAIDC', value.carrierAIDCElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Device.udiCarrier', 'carrierHRF', value.carrierHRFElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Device.udiCarrier', 'entryType', value.entryTypeElement, CODES_TFhirUDIEntryTypeEnum, SYSTEMS_TFhirUDIEntryTypeEnum, false, -1);
end;

function TFHIRTurtleParser.ParseDeviceDeviceName(obj : TTurtleComplex) : TFhirDeviceDeviceName;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDeviceName.create;
  try
    ParseDeviceDeviceNameProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDeviceNameProperties(obj : TTurtleComplex; value : TFhirDeviceDeviceName);
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Device.deviceName.name'));
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Device.deviceName.type'), CODES_TFhirDeviceNameTypeEnum, SYSTEMS_TFhirDeviceNameTypeEnum);
end;

procedure TFHIRTurtleComposer.ComposeDeviceDeviceName(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDeviceName; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDeviceName');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'Device.deviceName', 'name', value.nameElement, false, -1);
  ComposeEnum(this, 'Device.deviceName', 'type', value.type_Element, CODES_TFhirDeviceNameTypeEnum, SYSTEMS_TFhirDeviceNameTypeEnum, false, -1);
end;

function TFHIRTurtleParser.ParseDeviceVersion(obj : TTurtleComplex) : TFhirDeviceVersion;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceVersion.create;
  try
    ParseDeviceVersionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceVersionProperties(obj : TTurtleComplex; value : TFhirDeviceVersion);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Device.version.type'));
    value.component := ParseIdentifier(obj.complex('http://hl7.org/fhir/Device.version.component'));
    value.installDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Device.version.installDate'));
    value.valueElement := ParseString(obj.complex('http://hl7.org/fhir/Device.version.value'));
end;

procedure TFHIRTurtleComposer.ComposeDeviceVersion(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceVersion; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceVersion');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Device.version', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'Device.version', 'component', value.componentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Device.version', 'installDate', value.installDateElement, false, -1);
  ComposeString(this, 'Device.version', 'value', value.valueElement, false, -1);
end;

function TFHIRTurtleParser.ParseDeviceSpecialization(obj : TTurtleComplex) : TFhirDeviceSpecialization;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceSpecialization.create;
  try
    ParseDeviceSpecializationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceSpecializationProperties(obj : TTurtleComplex; value : TFhirDeviceSpecialization);
begin
    ParseBackboneElementProperties(obj, value);
    value.systemType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Device.specialization.systemType'));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Device.specialization.version'));
    value.category := ParseCoding(obj.complex('http://hl7.org/fhir/Device.specialization.category'));
end;

procedure TFHIRTurtleComposer.ComposeDeviceSpecialization(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceSpecialization; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceSpecialization');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'Device.specialization', 'systemType', value.systemTypeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Device.specialization', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'Device.specialization', 'category', value.categoryElement, false, -1);
end;

function TFHIRTurtleParser.ParseDeviceProperty(obj : TTurtleComplex) : TFhirDeviceProperty;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceProperty.create;
  try
    ParseDevicePropertyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDevicePropertyProperties(obj : TTurtleComplex; value : TFhirDeviceProperty);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Device.property.type'));
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueRange', item) then
      value.value := parseRange(item);
    if obj.has('valueAttachment', item) then
      value.value := parseAttachment(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    if obj.has('valueInteger', item) then
      value.value := parseInteger(item);
end;

procedure TFHIRTurtleComposer.ComposeDeviceProperty(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceProperty; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceProperty');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'Device.property', 'type', value.type_Element, false, -1);
  if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Device.property', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Device.property', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (value.value is TFhirRange) {6} then
    ComposeRange(this, 'Device.property', 'valueRange', TFhirRange(value.value), false, -1)
  else if (value.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Device.property', 'valueAttachment', TFhirAttachment(value.value), false, -1)
  else if (value.value is TFhirString) {6} then
    ComposeString(this, 'Device.property', 'valueString', TFhirString(value.value), false, -1)
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Device.property', 'valueBoolean', TFhirBoolean(value.value), false, -1)
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Device.property', 'valueInteger', TFhirInteger(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseDeviceOperation(obj : TTurtleComplex) : TFhirDeviceOperation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceOperation.create;
  try
    ParseDeviceOperationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceOperationProperties(obj : TTurtleComplex; value : TFhirDeviceOperation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.status := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Device.operation.status'));
    for item in obj.complexes('http://hl7.org/fhir/Device.operation.statusReason') do
      value.statusReasonList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Device.operation.operator') do
      value.operatorList.Add(parseReference(item));
    value.mode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Device.operation.mode'));
    value.cycle := ParseCount(obj.complex('http://hl7.org/fhir/Device.operation.cycle'));
    value.duration := ParseDuration(obj.complex('http://hl7.org/fhir/Device.operation.duration'));
end;

procedure TFHIRTurtleComposer.ComposeDeviceOperation(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceOperation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceOperation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'Device.operation', 'status', value.statusElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.statusReasonList.Count - 1 do
      ComposeCodeableConcept(this, 'Device.operation', 'statusReason', value.statusReasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.operatorList.Count - 1 do
      ComposeReference(this, 'Device.operation', 'operator', value.operatorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Device.operation', 'mode', value.modeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCount(this, 'Device.operation', 'cycle', value.cycleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(this, 'Device.operation', 'duration', value.durationElement, false, -1);
end;

function TFHIRTurtleParser.ParseDeviceAssociation(obj : TTurtleComplex) : TFhirDeviceAssociation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceAssociation.create;
  try
    ParseDeviceAssociationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceAssociationProperties(obj : TTurtleComplex; value : TFhirDeviceAssociation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.status := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Device.association.status'));
    for item in obj.complexes('http://hl7.org/fhir/Device.association.statusReason') do
      value.statusReasonList.Add(parseCodeableConcept(item));
    value.humanSubject := ParseReference(obj.complex('http://hl7.org/fhir/Device.association.humanSubject'));
    value.bodyStructure := ParseCodeableReference(obj.complex('http://hl7.org/fhir/Device.association.bodyStructure'));
end;

procedure TFHIRTurtleComposer.ComposeDeviceAssociation(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceAssociation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceAssociation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'Device.association', 'status', value.statusElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.statusReasonList.Count - 1 do
      ComposeCodeableConcept(this, 'Device.association', 'statusReason', value.statusReasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Device.association', 'humanSubject', value.humanSubjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(this, 'Device.association', 'bodyStructure', value.bodyStructureElement, false, -1);
end;

function TFHIRTurtleParser.ParseDevice(obj : TTurtleComplex) : TFhirDevice;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDevice.create;
  try
    ParseDeviceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceProperties(obj : TTurtleComplex; value : TFhirDevice);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Device.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.displayNameElement := ParseString(obj.complex('http://hl7.org/fhir/Device.displayName'));
    value.definition := ParseCodeableReference(obj.complex('http://hl7.org/fhir/Device.definition'));
    for item in obj.complexes('http://hl7.org/fhir/Device.udiCarrier') do
      value.udiCarrierList.Add(parseDeviceUdiCarrier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Device.status'), CODES_TFhirFHIRDeviceStatusEnum, SYSTEMS_TFhirFHIRDeviceStatusEnum);
    value.availabilityStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Device.availabilityStatus'));
    value.biologicalSourceEvent := ParseIdentifier(obj.complex('http://hl7.org/fhir/Device.biologicalSourceEvent'));
    value.manufacturerElement := ParseString(obj.complex('http://hl7.org/fhir/Device.manufacturer'));
    value.manufactureDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Device.manufactureDate'));
    value.expirationDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Device.expirationDate'));
    value.lotNumberElement := ParseString(obj.complex('http://hl7.org/fhir/Device.lotNumber'));
    value.serialNumberElement := ParseString(obj.complex('http://hl7.org/fhir/Device.serialNumber'));
    for item in obj.complexes('http://hl7.org/fhir/Device.deviceName') do
      value.deviceNameList.Add(parseDeviceDeviceName(item));
    value.modelNumberElement := ParseString(obj.complex('http://hl7.org/fhir/Device.modelNumber'));
    value.partNumberElement := ParseString(obj.complex('http://hl7.org/fhir/Device.partNumber'));
    for item in obj.complexes('http://hl7.org/fhir/Device.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Device.type') do
      value.type_List.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Device.version') do
      value.versionList.Add(parseDeviceVersion(item));
    for item in obj.complexes('http://hl7.org/fhir/Device.specialization') do
      value.specializationList.Add(parseDeviceSpecialization(item));
    for item in obj.complexes('http://hl7.org/fhir/Device.property') do
      value.property_List.Add(parseDeviceProperty(item));
    for item in obj.complexes('http://hl7.org/fhir/Device.operation') do
      value.operationList.Add(parseDeviceOperation(item));
    for item in obj.complexes('http://hl7.org/fhir/Device.association') do
      value.associationList.Add(parseDeviceAssociation(item));
    value.owner := ParseReference(obj.complex('http://hl7.org/fhir/Device.owner'));
    for item in obj.complexes('http://hl7.org/fhir/Device.contact') do
      value.contactList.Add(parseContactPoint(item));
    value.location := ParseReference(obj.complex('http://hl7.org/fhir/Device.location'));
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Device.url'));
    for item in obj.complexes('http://hl7.org/fhir/Device.endpoint') do
      value.endpointList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Device.gateway') do
      value.gatewayList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Device.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/Device.safety') do
      value.safetyList.Add(parseCodeableConcept(item));
    value.parent := ParseReference(obj.complex('http://hl7.org/fhir/Device.parent'));
end;

procedure TFHIRTurtleComposer.ComposeDevice(parent :  TTurtleComplex; parentType, name : String; value : TFhirDevice; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Device');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Device', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Device', 'displayName', value.displayNameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(this, 'Device', 'definition', value.definitionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.udiCarrierList.Count - 1 do
      ComposeDeviceUdiCarrier(this, 'Device', 'udiCarrier', value.udiCarrierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Device', 'status', value.statusElement, CODES_TFhirFHIRDeviceStatusEnum, SYSTEMS_TFhirFHIRDeviceStatusEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Device', 'availabilityStatus', value.availabilityStatusElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'Device', 'biologicalSourceEvent', value.biologicalSourceEventElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Device', 'manufacturer', value.manufacturerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Device', 'manufactureDate', value.manufactureDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Device', 'expirationDate', value.expirationDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Device', 'lotNumber', value.lotNumberElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Device', 'serialNumber', value.serialNumberElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.deviceNameList.Count - 1 do
      ComposeDeviceDeviceName(this, 'Device', 'deviceName', value.deviceNameList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Device', 'modelNumber', value.modelNumberElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Device', 'partNumber', value.partNumberElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Device', 'category', value.categoryList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Device', 'type', value.type_List[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.versionList.Count - 1 do
      ComposeDeviceVersion(this, 'Device', 'version', value.versionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.specializationList.Count - 1 do
      ComposeDeviceSpecialization(this, 'Device', 'specialization', value.specializationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeDeviceProperty(this, 'Device', 'property', value.property_List[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.operationList.Count - 1 do
      ComposeDeviceOperation(this, 'Device', 'operation', value.operationList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.associationList.Count - 1 do
      ComposeDeviceAssociation(this, 'Device', 'association', value.associationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Device', 'owner', value.ownerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactPoint(this, 'Device', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Device', 'location', value.locationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'Device', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endpointList.Count - 1 do
      ComposeReference(this, 'Device', 'endpoint', value.endpointList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.gatewayList.Count - 1 do
      ComposeCodeableReference(this, 'Device', 'gateway', value.gatewayList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'Device', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.safetyList.Count - 1 do
      ComposeCodeableConcept(this, 'Device', 'safety', value.safetyList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Device', 'parent', value.parentElement, false, -1);
end;

{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
function TFHIRTurtleParser.ParseDeviceDefinitionUdiDeviceIdentifier(obj : TTurtleComplex) : TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDefinitionUdiDeviceIdentifier.create;
  try
    ParseDeviceDefinitionUdiDeviceIdentifierProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDefinitionUdiDeviceIdentifierProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionUdiDeviceIdentifier);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.deviceIdentifierElement := ParseString(obj.complex('http://hl7.org/fhir/DeviceDefinition.udiDeviceIdentifier.deviceIdentifier'));
    value.issuerElement := ParseUri(obj.complex('http://hl7.org/fhir/DeviceDefinition.udiDeviceIdentifier.issuer'));
    value.jurisdictionElement := ParseUri(obj.complex('http://hl7.org/fhir/DeviceDefinition.udiDeviceIdentifier.jurisdiction'));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.udiDeviceIdentifier.marketDistribution') do
      value.marketDistributionList.Add(parseDeviceDefinitionUdiDeviceIdentifierMarketDistribution(item));
end;

procedure TFHIRTurtleComposer.ComposeDeviceDefinitionUdiDeviceIdentifier(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionUdiDeviceIdentifier; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDefinitionUdiDeviceIdentifier');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'DeviceDefinition.udiDeviceIdentifier', 'deviceIdentifier', value.deviceIdentifierElement, false, -1);
  ComposeUri(this, 'DeviceDefinition.udiDeviceIdentifier', 'issuer', value.issuerElement, false, -1);
  ComposeUri(this, 'DeviceDefinition.udiDeviceIdentifier', 'jurisdiction', value.jurisdictionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.marketDistributionList.Count - 1 do
      ComposeDeviceDefinitionUdiDeviceIdentifierMarketDistribution(this, 'DeviceDefinition.udiDeviceIdentifier', 'marketDistribution', value.marketDistributionList[i], false, i);
end;

function TFHIRTurtleParser.ParseDeviceDefinitionUdiDeviceIdentifierMarketDistribution(obj : TTurtleComplex) : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution.create;
  try
    ParseDeviceDefinitionUdiDeviceIdentifierMarketDistributionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDefinitionUdiDeviceIdentifierMarketDistributionProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution);
begin
    ParseBackboneElementProperties(obj, value);
    value.marketPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/DeviceDefinition.udiDeviceIdentifier.marketDistribution.marketPeriod'));
    value.subJurisdictionElement := ParseUri(obj.complex('http://hl7.org/fhir/DeviceDefinition.udiDeviceIdentifier.marketDistribution.subJurisdiction'));
end;

procedure TFHIRTurtleComposer.ComposeDeviceDefinitionUdiDeviceIdentifierMarketDistribution(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionUdiDeviceIdentifierMarketDistribution; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDefinitionUdiDeviceIdentifierMarketDistribution');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposePeriod(this, 'DeviceDefinition.udiDeviceIdentifier.marketDistribution', 'marketPeriod', value.marketPeriodElement, false, -1);
  ComposeUri(this, 'DeviceDefinition.udiDeviceIdentifier.marketDistribution', 'subJurisdiction', value.subJurisdictionElement, false, -1);
end;

function TFHIRTurtleParser.ParseDeviceDefinitionRegulatoryIdentifier(obj : TTurtleComplex) : TFhirDeviceDefinitionRegulatoryIdentifier;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDefinitionRegulatoryIdentifier.create;
  try
    ParseDeviceDefinitionRegulatoryIdentifierProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDefinitionRegulatoryIdentifierProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionRegulatoryIdentifier);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceDefinition.regulatoryIdentifier.type'), CODES_TFhirDeviceDefinitionRegulatoryIdentifierTypeEnum, SYSTEMS_TFhirDeviceDefinitionRegulatoryIdentifierTypeEnum);
    value.deviceIdentifierElement := ParseString(obj.complex('http://hl7.org/fhir/DeviceDefinition.regulatoryIdentifier.deviceIdentifier'));
    value.issuerElement := ParseUri(obj.complex('http://hl7.org/fhir/DeviceDefinition.regulatoryIdentifier.issuer'));
    value.jurisdictionElement := ParseUri(obj.complex('http://hl7.org/fhir/DeviceDefinition.regulatoryIdentifier.jurisdiction'));
end;

procedure TFHIRTurtleComposer.ComposeDeviceDefinitionRegulatoryIdentifier(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionRegulatoryIdentifier; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDefinitionRegulatoryIdentifier');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'DeviceDefinition.regulatoryIdentifier', 'type', value.type_Element, CODES_TFhirDeviceDefinitionRegulatoryIdentifierTypeEnum, SYSTEMS_TFhirDeviceDefinitionRegulatoryIdentifierTypeEnum, false, -1);
  ComposeString(this, 'DeviceDefinition.regulatoryIdentifier', 'deviceIdentifier', value.deviceIdentifierElement, false, -1);
  ComposeUri(this, 'DeviceDefinition.regulatoryIdentifier', 'issuer', value.issuerElement, false, -1);
  ComposeUri(this, 'DeviceDefinition.regulatoryIdentifier', 'jurisdiction', value.jurisdictionElement, false, -1);
end;

function TFHIRTurtleParser.ParseDeviceDefinitionDeviceName(obj : TTurtleComplex) : TFhirDeviceDefinitionDeviceName;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDefinitionDeviceName.create;
  try
    ParseDeviceDefinitionDeviceNameProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDefinitionDeviceNameProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionDeviceName);
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/DeviceDefinition.deviceName.name'));
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceDefinition.deviceName.type'), CODES_TFhirDeviceNameTypeEnum, SYSTEMS_TFhirDeviceNameTypeEnum);
end;

procedure TFHIRTurtleComposer.ComposeDeviceDefinitionDeviceName(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionDeviceName; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDefinitionDeviceName');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'DeviceDefinition.deviceName', 'name', value.nameElement, false, -1);
  ComposeEnum(this, 'DeviceDefinition.deviceName', 'type', value.type_Element, CODES_TFhirDeviceNameTypeEnum, SYSTEMS_TFhirDeviceNameTypeEnum, false, -1);
end;

function TFHIRTurtleParser.ParseDeviceDefinitionClassification(obj : TTurtleComplex) : TFhirDeviceDefinitionClassification;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDefinitionClassification.create;
  try
    ParseDeviceDefinitionClassificationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDefinitionClassificationProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionClassification);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceDefinition.classification.type'));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.classification.justification') do
      value.justificationList.Add(parseRelatedArtifact(item));
end;

procedure TFHIRTurtleComposer.ComposeDeviceDefinitionClassification(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionClassification; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDefinitionClassification');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'DeviceDefinition.classification', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.justificationList.Count - 1 do
      ComposeRelatedArtifact(this, 'DeviceDefinition.classification', 'justification', value.justificationList[i], false, i);
end;

function TFHIRTurtleParser.ParseDeviceDefinitionHasPart(obj : TTurtleComplex) : TFhirDeviceDefinitionHasPart;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDefinitionHasPart.create;
  try
    ParseDeviceDefinitionHasPartProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDefinitionHasPartProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionHasPart);
begin
    ParseBackboneElementProperties(obj, value);
    value.reference := ParseReference(obj.complex('http://hl7.org/fhir/DeviceDefinition.hasPart.reference'));
    value.countElement := ParseInteger(obj.complex('http://hl7.org/fhir/DeviceDefinition.hasPart.count'));
end;

procedure TFHIRTurtleComposer.ComposeDeviceDefinitionHasPart(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionHasPart; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDefinitionHasPart');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeReference(this, 'DeviceDefinition.hasPart', 'reference', value.referenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'DeviceDefinition.hasPart', 'count', value.countElement, false, -1);
end;

function TFHIRTurtleParser.ParseDeviceDefinitionPackaging(obj : TTurtleComplex) : TFhirDeviceDefinitionPackaging;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDefinitionPackaging.create;
  try
    ParseDeviceDefinitionPackagingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDefinitionPackagingProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionPackaging);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/DeviceDefinition.packaging.identifier'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceDefinition.packaging.type'));
    value.countElement := ParseInteger(obj.complex('http://hl7.org/fhir/DeviceDefinition.packaging.count'));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.packaging.distributor') do
      value.distributorList.Add(parseDeviceDefinitionPackagingDistributor(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.packaging.udiDeviceIdentifier') do
      value.udiDeviceIdentifierList.Add(parseDeviceDefinitionUdiDeviceIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.packaging.packaging') do
      value.packagingList.Add(parseDeviceDefinitionPackaging(item));
end;

procedure TFHIRTurtleComposer.ComposeDeviceDefinitionPackaging(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionPackaging; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDefinitionPackaging');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'DeviceDefinition.packaging', 'identifier', value.identifierElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'DeviceDefinition.packaging', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'DeviceDefinition.packaging', 'count', value.countElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.distributorList.Count - 1 do
      ComposeDeviceDefinitionPackagingDistributor(this, 'DeviceDefinition.packaging', 'distributor', value.distributorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.udiDeviceIdentifierList.Count - 1 do
      ComposeDeviceDefinitionUdiDeviceIdentifier(this, 'DeviceDefinition.packaging', 'udiDeviceIdentifier', value.udiDeviceIdentifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.packagingList.Count - 1 do
      ComposeDeviceDefinitionPackaging(this, 'DeviceDefinition.packaging', 'packaging', value.packagingList[i], false, i);
end;

function TFHIRTurtleParser.ParseDeviceDefinitionPackagingDistributor(obj : TTurtleComplex) : TFhirDeviceDefinitionPackagingDistributor;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDefinitionPackagingDistributor.create;
  try
    ParseDeviceDefinitionPackagingDistributorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDefinitionPackagingDistributorProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionPackagingDistributor);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/DeviceDefinition.packaging.distributor.name'));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.packaging.distributor.organizationReference') do
      value.organizationReferenceList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeDeviceDefinitionPackagingDistributor(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionPackagingDistributor; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDefinitionPackagingDistributor');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'DeviceDefinition.packaging.distributor', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.organizationReferenceList.Count - 1 do
      ComposeReference(this, 'DeviceDefinition.packaging.distributor', 'organizationReference', value.organizationReferenceList[i], false, i);
end;

function TFHIRTurtleParser.ParseDeviceDefinitionVersion(obj : TTurtleComplex) : TFhirDeviceDefinitionVersion;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDefinitionVersion.create;
  try
    ParseDeviceDefinitionVersionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDefinitionVersionProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionVersion);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceDefinition.version.type'));
    value.component := ParseIdentifier(obj.complex('http://hl7.org/fhir/DeviceDefinition.version.component'));
    value.valueElement := ParseString(obj.complex('http://hl7.org/fhir/DeviceDefinition.version.value'));
end;

procedure TFHIRTurtleComposer.ComposeDeviceDefinitionVersion(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionVersion; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDefinitionVersion');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'DeviceDefinition.version', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'DeviceDefinition.version', 'component', value.componentElement, false, -1);
  ComposeString(this, 'DeviceDefinition.version', 'value', value.valueElement, false, -1);
end;

function TFHIRTurtleParser.ParseDeviceDefinitionProperty(obj : TTurtleComplex) : TFhirDeviceDefinitionProperty;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDefinitionProperty.create;
  try
    ParseDeviceDefinitionPropertyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDefinitionPropertyProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionProperty);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceDefinition.property.type'));
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueRange', item) then
      value.value := parseRange(item);
    if obj.has('valueAttachment', item) then
      value.value := parseAttachment(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    if obj.has('valueInteger', item) then
      value.value := parseInteger(item);
end;

procedure TFHIRTurtleComposer.ComposeDeviceDefinitionProperty(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionProperty; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDefinitionProperty');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'DeviceDefinition.property', 'type', value.type_Element, false, -1);
  if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'DeviceDefinition.property', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'DeviceDefinition.property', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (value.value is TFhirRange) {6} then
    ComposeRange(this, 'DeviceDefinition.property', 'valueRange', TFhirRange(value.value), false, -1)
  else if (value.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'DeviceDefinition.property', 'valueAttachment', TFhirAttachment(value.value), false, -1)
  else if (value.value is TFhirString) {6} then
    ComposeString(this, 'DeviceDefinition.property', 'valueString', TFhirString(value.value), false, -1)
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'DeviceDefinition.property', 'valueBoolean', TFhirBoolean(value.value), false, -1)
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(this, 'DeviceDefinition.property', 'valueInteger', TFhirInteger(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseDeviceDefinitionLink(obj : TTurtleComplex) : TFhirDeviceDefinitionLink;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDefinitionLink.create;
  try
    ParseDeviceDefinitionLinkProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDefinitionLinkProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionLink);
begin
    ParseBackboneElementProperties(obj, value);
    value.relation := ParseCoding(obj.complex('http://hl7.org/fhir/DeviceDefinition.link.relation'));
    value.relatedDevice := ParseCodeableReference(obj.complex('http://hl7.org/fhir/DeviceDefinition.link.relatedDevice'));
end;

procedure TFHIRTurtleComposer.ComposeDeviceDefinitionLink(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionLink; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDefinitionLink');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCoding(this, 'DeviceDefinition.link', 'relation', value.relationElement, false, -1);
  ComposeCodeableReference(this, 'DeviceDefinition.link', 'relatedDevice', value.relatedDeviceElement, false, -1);
end;

function TFHIRTurtleParser.ParseDeviceDefinitionMaterial(obj : TTurtleComplex) : TFhirDeviceDefinitionMaterial;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDefinitionMaterial.create;
  try
    ParseDeviceDefinitionMaterialProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDefinitionMaterialProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionMaterial);
begin
    ParseBackboneElementProperties(obj, value);
    value.substance := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceDefinition.material.substance'));
    value.alternateElement := ParseBoolean(obj.complex('http://hl7.org/fhir/DeviceDefinition.material.alternate'));
    value.allergenicIndicatorElement := ParseBoolean(obj.complex('http://hl7.org/fhir/DeviceDefinition.material.allergenicIndicator'));
end;

procedure TFHIRTurtleComposer.ComposeDeviceDefinitionMaterial(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionMaterial; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDefinitionMaterial');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'DeviceDefinition.material', 'substance', value.substanceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'DeviceDefinition.material', 'alternate', value.alternateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'DeviceDefinition.material', 'allergenicIndicator', value.allergenicIndicatorElement, false, -1);
end;

function TFHIRTurtleParser.ParseDeviceDefinitionGuideline(obj : TTurtleComplex) : TFhirDeviceDefinitionGuideline;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDefinitionGuideline.create;
  try
    ParseDeviceDefinitionGuidelineProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDefinitionGuidelineProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionGuideline);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.guideline.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    value.usageInstructionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/DeviceDefinition.guideline.usageInstruction'));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.guideline.relatedArtifact') do
      value.relatedArtifactList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.guideline.indication') do
      value.indicationList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.guideline.contraindication') do
      value.contraindicationList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.guideline.warning') do
      value.warningList.Add(parseCodeableReference(item));
    value.intendedUseElement := ParseString(obj.complex('http://hl7.org/fhir/DeviceDefinition.guideline.intendedUse'));
end;

procedure TFHIRTurtleComposer.ComposeDeviceDefinitionGuideline(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionGuideline; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDefinitionGuideline');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'DeviceDefinition.guideline', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'DeviceDefinition.guideline', 'usageInstruction', value.usageInstructionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'DeviceDefinition.guideline', 'relatedArtifact', value.relatedArtifactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.indicationList.Count - 1 do
      ComposeCodeableReference(this, 'DeviceDefinition.guideline', 'indication', value.indicationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contraindicationList.Count - 1 do
      ComposeCodeableReference(this, 'DeviceDefinition.guideline', 'contraindication', value.contraindicationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.warningList.Count - 1 do
      ComposeCodeableReference(this, 'DeviceDefinition.guideline', 'warning', value.warningList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'DeviceDefinition.guideline', 'intendedUse', value.intendedUseElement, false, -1);
end;

function TFHIRTurtleParser.ParseDeviceDefinitionCorrectiveAction(obj : TTurtleComplex) : TFhirDeviceDefinitionCorrectiveAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDefinitionCorrectiveAction.create;
  try
    ParseDeviceDefinitionCorrectiveActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDefinitionCorrectiveActionProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionCorrectiveAction);
begin
    ParseBackboneElementProperties(obj, value);
    value.recallElement := ParseBoolean(obj.complex('http://hl7.org/fhir/DeviceDefinition.correctiveAction.recall'));
    value.scopeElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceDefinition.correctiveAction.scope'), CODES_TFhirDeviceCorrectiveActionScopeEnum, SYSTEMS_TFhirDeviceCorrectiveActionScopeEnum);
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/DeviceDefinition.correctiveAction.period'));
end;

procedure TFHIRTurtleComposer.ComposeDeviceDefinitionCorrectiveAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionCorrectiveAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDefinitionCorrectiveAction');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeBoolean(this, 'DeviceDefinition.correctiveAction', 'recall', value.recallElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'DeviceDefinition.correctiveAction', 'scope', value.scopeElement, CODES_TFhirDeviceCorrectiveActionScopeEnum, SYSTEMS_TFhirDeviceCorrectiveActionScopeEnum, false, -1);
  ComposePeriod(this, 'DeviceDefinition.correctiveAction', 'period', value.periodElement, false, -1);
end;

function TFHIRTurtleParser.ParseDeviceDefinitionChargeItem(obj : TTurtleComplex) : TFhirDeviceDefinitionChargeItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDefinitionChargeItem.create;
  try
    ParseDeviceDefinitionChargeItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDefinitionChargeItemProperties(obj : TTurtleComplex; value : TFhirDeviceDefinitionChargeItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.chargeItemCode := ParseCodeableReference(obj.complex('http://hl7.org/fhir/DeviceDefinition.chargeItem.chargeItemCode'));
    value.count := ParseQuantity(obj.complex('http://hl7.org/fhir/DeviceDefinition.chargeItem.count'));
    value.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/DeviceDefinition.chargeItem.effectivePeriod'));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.chargeItem.useContext') do
      value.useContextList.Add(parseUsageContext(item));
end;

procedure TFHIRTurtleComposer.ComposeDeviceDefinitionChargeItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinitionChargeItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDefinitionChargeItem');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableReference(this, 'DeviceDefinition.chargeItem', 'chargeItemCode', value.chargeItemCodeElement, false, -1);
  ComposeQuantity(this, 'DeviceDefinition.chargeItem', 'count', value.countElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'DeviceDefinition.chargeItem', 'effectivePeriod', value.effectivePeriodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'DeviceDefinition.chargeItem', 'useContext', value.useContextList[i], false, i);
end;

function TFHIRTurtleParser.ParseDeviceDefinition(obj : TTurtleComplex) : TFhirDeviceDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDefinition.create;
  try
    ParseDeviceDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDefinitionProperties(obj : TTurtleComplex; value : TFhirDeviceDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/DeviceDefinition.description'));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.udiDeviceIdentifier') do
      value.udiDeviceIdentifierList.Add(parseDeviceDefinitionUdiDeviceIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.regulatoryIdentifier') do
      value.regulatoryIdentifierList.Add(parseDeviceDefinitionRegulatoryIdentifier(item));
    value.partNumberElement := ParseString(obj.complex('http://hl7.org/fhir/DeviceDefinition.partNumber'));
    value.manufacturer := ParseReference(obj.complex('http://hl7.org/fhir/DeviceDefinition.manufacturer'));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.deviceName') do
      value.deviceNameList.Add(parseDeviceDefinitionDeviceName(item));
    value.modelNumberElement := ParseString(obj.complex('http://hl7.org/fhir/DeviceDefinition.modelNumber'));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.classification') do
      value.classificationList.Add(parseDeviceDefinitionClassification(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.specialization') do
      value.specializationList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.hasPart') do
      value.hasPartList.Add(parseDeviceDefinitionHasPart(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.packaging') do
      value.packagingList.Add(parseDeviceDefinitionPackaging(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.version') do
      value.versionList.Add(parseDeviceDefinitionVersion(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.safety') do
      value.safetyList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.shelfLifeStorage') do
      value.shelfLifeStorageList.Add(parseProductShelfLife(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.languageCode') do
      value.languageCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.property') do
      value.property_List.Add(parseDeviceDefinitionProperty(item));
    value.owner := ParseReference(obj.complex('http://hl7.org/fhir/DeviceDefinition.owner'));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.contact') do
      value.contactList.Add(parseContactPoint(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.link') do
      value.link_List.Add(parseDeviceDefinitionLink(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.note') do
      value.noteList.Add(parseAnnotation(item));
    value.parentDevice := ParseReference(obj.complex('http://hl7.org/fhir/DeviceDefinition.parentDevice'));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.material') do
      value.materialList.Add(parseDeviceDefinitionMaterial(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.productionIdentifierInUDI') do
      value.productionIdentifierInUDIList.Add(parseEnum(item, CODES_TFhirDeviceProductionIdentifierInUDIEnum, SYSTEMS_TFhirDeviceProductionIdentifierInUDIEnum));
    value.guideline := ParseDeviceDefinitionGuideline(obj.complex('http://hl7.org/fhir/DeviceDefinition.guideline'));
    value.correctiveAction := ParseDeviceDefinitionCorrectiveAction(obj.complex('http://hl7.org/fhir/DeviceDefinition.correctiveAction'));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.chargeItem') do
      value.chargeItemList.Add(parseDeviceDefinitionChargeItem(item));
end;

procedure TFHIRTurtleComposer.ComposeDeviceDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDefinition');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'DeviceDefinition', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DeviceDefinition', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.udiDeviceIdentifierList.Count - 1 do
      ComposeDeviceDefinitionUdiDeviceIdentifier(this, 'DeviceDefinition', 'udiDeviceIdentifier', value.udiDeviceIdentifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.regulatoryIdentifierList.Count - 1 do
      ComposeDeviceDefinitionRegulatoryIdentifier(this, 'DeviceDefinition', 'regulatoryIdentifier', value.regulatoryIdentifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'DeviceDefinition', 'partNumber', value.partNumberElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'DeviceDefinition', 'manufacturer', value.manufacturerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.deviceNameList.Count - 1 do
      ComposeDeviceDefinitionDeviceName(this, 'DeviceDefinition', 'deviceName', value.deviceNameList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'DeviceDefinition', 'modelNumber', value.modelNumberElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.classificationList.Count - 1 do
      ComposeDeviceDefinitionClassification(this, 'DeviceDefinition', 'classification', value.classificationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.specializationList.Count - 1 do
      ComposeRelatedArtifact(this, 'DeviceDefinition', 'specialization', value.specializationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.hasPartList.Count - 1 do
      ComposeDeviceDefinitionHasPart(this, 'DeviceDefinition', 'hasPart', value.hasPartList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.packagingList.Count - 1 do
      ComposeDeviceDefinitionPackaging(this, 'DeviceDefinition', 'packaging', value.packagingList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.versionList.Count - 1 do
      ComposeDeviceDefinitionVersion(this, 'DeviceDefinition', 'version', value.versionList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.safetyList.Count - 1 do
      ComposeCodeableConcept(this, 'DeviceDefinition', 'safety', value.safetyList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.shelfLifeStorageList.Count - 1 do
      ComposeProductShelfLife(this, 'DeviceDefinition', 'shelfLifeStorage', value.shelfLifeStorageList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.languageCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'DeviceDefinition', 'languageCode', value.languageCodeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeDeviceDefinitionProperty(this, 'DeviceDefinition', 'property', value.property_List[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'DeviceDefinition', 'owner', value.ownerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactPoint(this, 'DeviceDefinition', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.link_List.Count - 1 do
      ComposeDeviceDefinitionLink(this, 'DeviceDefinition', 'link', value.link_List[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'DeviceDefinition', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'DeviceDefinition', 'parentDevice', value.parentDeviceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.materialList.Count - 1 do
      ComposeDeviceDefinitionMaterial(this, 'DeviceDefinition', 'material', value.materialList[i], false, i);
  for i := 0 to value.productionIdentifierInUDIList.Count - 1 do
      ComposeEnum(this, 'DeviceDefinition', 'productionIdentifierInUDI', value.productionIdentifierInUDIList[i], CODES_TFhirDeviceProductionIdentifierInUDIEnum, SYSTEMS_TFhirDeviceProductionIdentifierInUDIEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.productionIdentifierInUDIList.Count - 1 do
      ComposeEnum(this, 'DeviceDefinition', 'productionIdentifierInUDI', value.productionIdentifierInUDIList[i], CODES_TFhirDeviceProductionIdentifierInUDIEnum, SYSTEMS_TFhirDeviceProductionIdentifierInUDIEnum, false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeDeviceDefinitionGuideline(this, 'DeviceDefinition', 'guideline', value.guidelineElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDeviceDefinitionCorrectiveAction(this, 'DeviceDefinition', 'correctiveAction', value.correctiveActionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.chargeItemList.Count - 1 do
      ComposeDeviceDefinitionChargeItem(this, 'DeviceDefinition', 'chargeItem', value.chargeItemList[i], false, i);
end;

{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEDISPENSE}
function TFHIRTurtleParser.ParseDeviceDispensePerformer(obj : TTurtleComplex) : TFhirDeviceDispensePerformer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDispensePerformer.create;
  try
    ParseDeviceDispensePerformerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDispensePerformerProperties(obj : TTurtleComplex; value : TFhirDeviceDispensePerformer);
begin
    ParseBackboneElementProperties(obj, value);
    value.function_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceDispense.performer.function'));
    value.actor := ParseReference(obj.complex('http://hl7.org/fhir/DeviceDispense.performer.actor'));
end;

procedure TFHIRTurtleComposer.ComposeDeviceDispensePerformer(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDispensePerformer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDispensePerformer');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'DeviceDispense.performer', 'function', value.function_Element, false, -1);
  ComposeReference(this, 'DeviceDispense.performer', 'actor', value.actorElement, false, -1);
end;

function TFHIRTurtleParser.ParseDeviceDispense(obj : TTurtleComplex) : TFhirDeviceDispense;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDispense.create;
  try
    ParseDeviceDispenseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDispenseProperties(obj : TTurtleComplex; value : TFhirDeviceDispense);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/DeviceDispense.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDispense.basedOn') do
      value.basedOnList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDispense.partOf') do
      value.partOfList.Add(parseReference(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceDispense.status'), CODES_TFhirDeviceDispenseStatusCodesEnum, SYSTEMS_TFhirDeviceDispenseStatusCodesEnum);
    value.statusReason := ParseCodeableReference(obj.complex('http://hl7.org/fhir/DeviceDispense.statusReason'));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDispense.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    value.device := ParseCodeableReference(obj.complex('http://hl7.org/fhir/DeviceDispense.device'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/DeviceDispense.subject'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/DeviceDispense.encounter'));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDispense.supportingInformation') do
      value.supportingInformationList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDispense.performer') do
      value.performerList.Add(parseDeviceDispensePerformer(item));
    value.location := ParseReference(obj.complex('http://hl7.org/fhir/DeviceDispense.location'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceDispense.type'));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/DeviceDispense.quantity'));
    value.preparedDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DeviceDispense.preparedDate'));
    value.whenHandedOverElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DeviceDispense.whenHandedOver'));
    value.destination := ParseReference(obj.complex('http://hl7.org/fhir/DeviceDispense.destination'));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDispense.note') do
      value.noteList.Add(parseAnnotation(item));
    value.usageInstructionElement := ParseString(obj.complex('http://hl7.org/fhir/DeviceDispense.usageInstruction'));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDispense.eventHistory') do
      value.eventHistoryList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeDeviceDispense(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceDispense; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDispense');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DeviceDispense', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'DeviceDispense', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(this, 'DeviceDispense', 'partOf', value.partOfList[i], false, i);
  ComposeEnum(this, 'DeviceDispense', 'status', value.statusElement, CODES_TFhirDeviceDispenseStatusCodesEnum, SYSTEMS_TFhirDeviceDispenseStatusCodesEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(this, 'DeviceDispense', 'statusReason', value.statusReasonElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'DeviceDispense', 'category', value.categoryList[i], false, i);
  ComposeCodeableReference(this, 'DeviceDispense', 'device', value.deviceElement, false, -1);
  ComposeReference(this, 'DeviceDispense', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'DeviceDispense', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInformationList.Count - 1 do
      ComposeReference(this, 'DeviceDispense', 'supportingInformation', value.supportingInformationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeDeviceDispensePerformer(this, 'DeviceDispense', 'performer', value.performerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'DeviceDispense', 'location', value.locationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'DeviceDispense', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'DeviceDispense', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'DeviceDispense', 'preparedDate', value.preparedDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'DeviceDispense', 'whenHandedOver', value.whenHandedOverElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'DeviceDispense', 'destination', value.destinationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'DeviceDispense', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'DeviceDispense', 'usageInstruction', value.usageInstructionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.eventHistoryList.Count - 1 do
      ComposeReference(this, 'DeviceDispense', 'eventHistory', value.eventHistoryList[i], false, i);
end;

{$ENDIF FHIR_DEVICEDISPENSE}
{$IFDEF FHIR_DEVICEMETRIC}
function TFHIRTurtleParser.ParseDeviceMetricCalibration(obj : TTurtleComplex) : TFhirDeviceMetricCalibration;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceMetricCalibration.create;
  try
    ParseDeviceMetricCalibrationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceMetricCalibrationProperties(obj : TTurtleComplex; value : TFhirDeviceMetricCalibration);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceMetric.calibration.type'), CODES_TFhirDeviceMetricCalibrationTypeEnum, SYSTEMS_TFhirDeviceMetricCalibrationTypeEnum);
    value.stateElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceMetric.calibration.state'), CODES_TFhirDeviceMetricCalibrationStateEnum, SYSTEMS_TFhirDeviceMetricCalibrationStateEnum);
    value.timeElement := ParseInstant(obj.complex('http://hl7.org/fhir/DeviceMetric.calibration.time'));
end;

procedure TFHIRTurtleComposer.ComposeDeviceMetricCalibration(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceMetricCalibration; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceMetricCalibration');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'DeviceMetric.calibration', 'type', value.type_Element, CODES_TFhirDeviceMetricCalibrationTypeEnum, SYSTEMS_TFhirDeviceMetricCalibrationTypeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'DeviceMetric.calibration', 'state', value.stateElement, CODES_TFhirDeviceMetricCalibrationStateEnum, SYSTEMS_TFhirDeviceMetricCalibrationStateEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'DeviceMetric.calibration', 'time', value.timeElement, false, -1);
end;

function TFHIRTurtleParser.ParseDeviceMetric(obj : TTurtleComplex) : TFhirDeviceMetric;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceMetric.create;
  try
    ParseDeviceMetricProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceMetricProperties(obj : TTurtleComplex; value : TFhirDeviceMetric);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/DeviceMetric.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceMetric.type'));
    value.unit_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceMetric.unit'));
    value.source := ParseReference(obj.complex('http://hl7.org/fhir/DeviceMetric.source'));
    value.parent := ParseReference(obj.complex('http://hl7.org/fhir/DeviceMetric.parent'));
    value.operationalStatusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceMetric.operationalStatus'), CODES_TFhirDeviceMetricOperationalStatusEnum, SYSTEMS_TFhirDeviceMetricOperationalStatusEnum);
    value.colorElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceMetric.color'), CODES_TFhirDeviceMetricColorEnum, SYSTEMS_TFhirDeviceMetricColorEnum);
    value.categoryElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceMetric.category'), CODES_TFhirDeviceMetricCategoryEnum, SYSTEMS_TFhirDeviceMetricCategoryEnum);
    value.measurementPeriod := ParseTiming(obj.complex('http://hl7.org/fhir/DeviceMetric.measurementPeriod'));
    for item in obj.complexes('http://hl7.org/fhir/DeviceMetric.calibration') do
      value.calibrationList.Add(parseDeviceMetricCalibration(item));
end;

procedure TFHIRTurtleComposer.ComposeDeviceMetric(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceMetric; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceMetric');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DeviceMetric', 'identifier', value.identifierList[i], false, i);
  ComposeCodeableConcept(this, 'DeviceMetric', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DeviceMetric', 'unit', value.unit_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'DeviceMetric', 'source', value.sourceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'DeviceMetric', 'parent', value.parentElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'DeviceMetric', 'operationalStatus', value.operationalStatusElement, CODES_TFhirDeviceMetricOperationalStatusEnum, SYSTEMS_TFhirDeviceMetricOperationalStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'DeviceMetric', 'color', value.colorElement, CODES_TFhirDeviceMetricColorEnum, SYSTEMS_TFhirDeviceMetricColorEnum, false, -1);
  ComposeEnum(this, 'DeviceMetric', 'category', value.categoryElement, CODES_TFhirDeviceMetricCategoryEnum, SYSTEMS_TFhirDeviceMetricCategoryEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(this, 'DeviceMetric', 'measurementPeriod', value.measurementPeriodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.calibrationList.Count - 1 do
      ComposeDeviceMetricCalibration(this, 'DeviceMetric', 'calibration', value.calibrationList[i], false, i);
end;

{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
function TFHIRTurtleParser.ParseDeviceRequestParameter(obj : TTurtleComplex) : TFhirDeviceRequestParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceRequestParameter.create;
  try
    ParseDeviceRequestParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceRequestParameterProperties(obj : TTurtleComplex; value : TFhirDeviceRequestParameter);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceRequest.parameter.code'));
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueRange', item) then
      value.value := parseRange(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
end;

procedure TFHIRTurtleComposer.ComposeDeviceRequestParameter(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceRequestParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceRequestParameter');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'DeviceRequest.parameter', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'DeviceRequest.parameter', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'DeviceRequest.parameter', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirRange) {6} then
    ComposeRange(this, 'DeviceRequest.parameter', 'valueRange', TFhirRange(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'DeviceRequest.parameter', 'valueBoolean', TFhirBoolean(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseDeviceRequest(obj : TTurtleComplex) : TFhirDeviceRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceRequest.create;
  try
    ParseDeviceRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceRequestProperties(obj : TTurtleComplex; value : TFhirDeviceRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.instantiatesCanonical') do
      value.instantiatesCanonicalList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.instantiatesUri') do
      value.instantiatesUriList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.basedOn') do
      value.basedOnList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.replaces') do
      value.replacesList.Add(parseReference(item));
    value.groupIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/DeviceRequest.groupIdentifier'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceRequest.status'), CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum);
    value.intentElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceRequest.intent'), CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum);
    value.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceRequest.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    value.doNotPerformElement := ParseBoolean(obj.complex('http://hl7.org/fhir/DeviceRequest.doNotPerform'));
    value.code := ParseCodeableReference(obj.complex('http://hl7.org/fhir/DeviceRequest.code'));
    value.quantityElement := ParseInteger(obj.complex('http://hl7.org/fhir/DeviceRequest.quantity'));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.parameter') do
      value.parameterList.Add(parseDeviceRequestParameter(item));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/DeviceRequest.subject'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/DeviceRequest.encounter'));
    if obj.has('occurrencePeriod', item) then
      value.occurrence := parsePeriod(item);
    if obj.has('occurrenceTiming', item) then
      value.occurrence := parseTiming(item);
    if obj.has('occurrenceDateTime', item) then
      value.occurrence := parseDateTime(item);
    value.authoredOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DeviceRequest.authoredOn'));
    value.requester := ParseReference(obj.complex('http://hl7.org/fhir/DeviceRequest.requester'));
    value.performerType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceRequest.performerType'));
    value.performer := ParseReference(obj.complex('http://hl7.org/fhir/DeviceRequest.performer'));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.reason') do
      value.reasonList.Add(parseCodeableReference(item));
    value.asNeededElement := ParseBoolean(obj.complex('http://hl7.org/fhir/DeviceRequest.asNeeded'));
    value.asNeededFor := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceRequest.asNeededFor'));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.insurance') do
      value.insuranceList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.supportingInfo') do
      value.supportingInfoList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.relevantHistory') do
      value.relevantHistoryList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeDeviceRequest(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceRequest');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DeviceRequest', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(this, 'DeviceRequest', 'instantiatesCanonical', value.instantiatesCanonicalList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesUriList.Count - 1 do
      ComposeUri(this, 'DeviceRequest', 'instantiatesUri', value.instantiatesUriList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'DeviceRequest', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.replacesList.Count - 1 do
      ComposeReference(this, 'DeviceRequest', 'replaces', value.replacesList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'DeviceRequest', 'groupIdentifier', value.groupIdentifierElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'DeviceRequest', 'status', value.statusElement, CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, false, -1);
  ComposeEnum(this, 'DeviceRequest', 'intent', value.intentElement, CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'DeviceRequest', 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'DeviceRequest', 'doNotPerform', value.doNotPerformElement, false, -1);
  ComposeCodeableReference(this, 'DeviceRequest', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'DeviceRequest', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.parameterList.Count - 1 do
      ComposeDeviceRequestParameter(this, 'DeviceRequest', 'parameter', value.parameterList[i], false, i);
  ComposeReference(this, 'DeviceRequest', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'DeviceRequest', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'DeviceRequest', 'occurrencePeriod', TFhirPeriod(value.occurrence), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirTiming) {6} then
    ComposeTiming(this, 'DeviceRequest', 'occurrenceTiming', TFhirTiming(value.occurrence), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'DeviceRequest', 'occurrenceDateTime', TFhirDateTime(value.occurrence), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'DeviceRequest', 'authoredOn', value.authoredOnElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'DeviceRequest', 'requester', value.requesterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DeviceRequest', 'performerType', value.performerTypeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'DeviceRequest', 'performer', value.performerElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(this, 'DeviceRequest', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'DeviceRequest', 'asNeeded', value.asNeededElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'DeviceRequest', 'asNeededFor', value.asNeededForElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.insuranceList.Count - 1 do
      ComposeReference(this, 'DeviceRequest', 'insurance', value.insuranceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInfoList.Count - 1 do
      ComposeReference(this, 'DeviceRequest', 'supportingInfo', value.supportingInfoList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'DeviceRequest', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relevantHistoryList.Count - 1 do
      ComposeReference(this, 'DeviceRequest', 'relevantHistory', value.relevantHistoryList[i], false, i);
end;

{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSAGE}
function TFHIRTurtleParser.ParseDeviceUsageAdherence(obj : TTurtleComplex) : TFhirDeviceUsageAdherence;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceUsageAdherence.create;
  try
    ParseDeviceUsageAdherenceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceUsageAdherenceProperties(obj : TTurtleComplex; value : TFhirDeviceUsageAdherence);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceUsage.adherence.code'));
    for item in obj.complexes('http://hl7.org/fhir/DeviceUsage.adherence.reason') do
      value.reasonList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeDeviceUsageAdherence(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceUsageAdherence; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceUsageAdherence');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'DeviceUsage.adherence', 'code', value.codeElement, false, -1);
  for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'DeviceUsage.adherence', 'reason', value.reasonList[i], false, i);
end;

function TFHIRTurtleParser.ParseDeviceUsage(obj : TTurtleComplex) : TFhirDeviceUsage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceUsage.create;
  try
    ParseDeviceUsageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceUsageProperties(obj : TTurtleComplex; value : TFhirDeviceUsage);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/DeviceUsage.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceUsage.basedOn') do
      value.basedOnList.Add(parseReference(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceUsage.status'), CODES_TFhirDeviceUsageStatusEnum, SYSTEMS_TFhirDeviceUsageStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/DeviceUsage.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    value.patient := ParseReference(obj.complex('http://hl7.org/fhir/DeviceUsage.patient'));
    for item in obj.complexes('http://hl7.org/fhir/DeviceUsage.derivedFrom') do
      value.derivedFromList.Add(parseReference(item));
    value.context := ParseReference(obj.complex('http://hl7.org/fhir/DeviceUsage.context'));
    if obj.has('timingTiming', item) then
      value.timing := parseTiming(item);
    if obj.has('timingPeriod', item) then
      value.timing := parsePeriod(item);
    if obj.has('timingDateTime', item) then
      value.timing := parseDateTime(item);
    value.dateAssertedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DeviceUsage.dateAsserted'));
    value.usageStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceUsage.usageStatus'));
    for item in obj.complexes('http://hl7.org/fhir/DeviceUsage.usageReason') do
      value.usageReasonList.Add(parseCodeableConcept(item));
    value.adherence := ParseDeviceUsageAdherence(obj.complex('http://hl7.org/fhir/DeviceUsage.adherence'));
    value.informationSource := ParseReference(obj.complex('http://hl7.org/fhir/DeviceUsage.informationSource'));
    value.device := ParseCodeableReference(obj.complex('http://hl7.org/fhir/DeviceUsage.device'));
    for item in obj.complexes('http://hl7.org/fhir/DeviceUsage.reason') do
      value.reasonList.Add(parseCodeableReference(item));
    value.bodySite := ParseCodeableReference(obj.complex('http://hl7.org/fhir/DeviceUsage.bodySite'));
    for item in obj.complexes('http://hl7.org/fhir/DeviceUsage.note') do
      value.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeDeviceUsage(parent :  TTurtleComplex; parentType, name : String; value : TFhirDeviceUsage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceUsage');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DeviceUsage', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'DeviceUsage', 'basedOn', value.basedOnList[i], false, i);
  ComposeEnum(this, 'DeviceUsage', 'status', value.statusElement, CODES_TFhirDeviceUsageStatusEnum, SYSTEMS_TFhirDeviceUsageStatusEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'DeviceUsage', 'category', value.categoryList[i], false, i);
  ComposeReference(this, 'DeviceUsage', 'patient', value.patientElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.derivedFromList.Count - 1 do
      ComposeReference(this, 'DeviceUsage', 'derivedFrom', value.derivedFromList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'DeviceUsage', 'context', value.contextElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.timing is TFhirTiming) {6} then
    ComposeTiming(this, 'DeviceUsage', 'timingTiming', TFhirTiming(value.timing), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.timing is TFhirPeriod) {6} then
    ComposePeriod(this, 'DeviceUsage', 'timingPeriod', TFhirPeriod(value.timing), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.timing is TFhirDateTime) {6} then
    ComposeDateTime(this, 'DeviceUsage', 'timingDateTime', TFhirDateTime(value.timing), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'DeviceUsage', 'dateAsserted', value.dateAssertedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'DeviceUsage', 'usageStatus', value.usageStatusElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.usageReasonList.Count - 1 do
      ComposeCodeableConcept(this, 'DeviceUsage', 'usageReason', value.usageReasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeDeviceUsageAdherence(this, 'DeviceUsage', 'adherence', value.adherenceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'DeviceUsage', 'informationSource', value.informationSourceElement, false, -1);
  ComposeCodeableReference(this, 'DeviceUsage', 'device', value.deviceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(this, 'DeviceUsage', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(this, 'DeviceUsage', 'bodySite', value.bodySiteElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'DeviceUsage', 'note', value.noteList[i], false, i);
end;

{$ENDIF FHIR_DEVICEUSAGE}
{$IFDEF FHIR_DIAGNOSTICREPORT}
function TFHIRTurtleParser.ParseDiagnosticReportSupportingInfo(obj : TTurtleComplex) : TFhirDiagnosticReportSupportingInfo;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDiagnosticReportSupportingInfo.create;
  try
    ParseDiagnosticReportSupportingInfoProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDiagnosticReportSupportingInfoProperties(obj : TTurtleComplex; value : TFhirDiagnosticReportSupportingInfo);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DiagnosticReport.supportingInfo.type'));
    value.reference := ParseReference(obj.complex('http://hl7.org/fhir/DiagnosticReport.supportingInfo.reference'));
end;

procedure TFHIRTurtleComposer.ComposeDiagnosticReportSupportingInfo(parent :  TTurtleComplex; parentType, name : String; value : TFhirDiagnosticReportSupportingInfo; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DiagnosticReportSupportingInfo');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'DiagnosticReport.supportingInfo', 'type', value.type_Element, false, -1);
  ComposeReference(this, 'DiagnosticReport.supportingInfo', 'reference', value.referenceElement, false, -1);
end;

function TFHIRTurtleParser.ParseDiagnosticReportMedia(obj : TTurtleComplex) : TFhirDiagnosticReportMedia;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDiagnosticReportMedia.create;
  try
    ParseDiagnosticReportMediaProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDiagnosticReportMediaProperties(obj : TTurtleComplex; value : TFhirDiagnosticReportMedia);
begin
    ParseBackboneElementProperties(obj, value);
    value.commentElement := ParseString(obj.complex('http://hl7.org/fhir/DiagnosticReport.media.comment'));
    value.link_ := ParseReference(obj.complex('http://hl7.org/fhir/DiagnosticReport.media.link'));
end;

procedure TFHIRTurtleComposer.ComposeDiagnosticReportMedia(parent :  TTurtleComplex; parentType, name : String; value : TFhirDiagnosticReportMedia; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DiagnosticReportMedia');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'DiagnosticReport.media', 'comment', value.commentElement, false, -1);
  ComposeReference(this, 'DiagnosticReport.media', 'link', value.link_Element, false, -1);
end;

function TFHIRTurtleParser.ParseDiagnosticReport(obj : TTurtleComplex) : TFhirDiagnosticReport;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDiagnosticReport.create;
  try
    ParseDiagnosticReportProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDiagnosticReportProperties(obj : TTurtleComplex; value : TFhirDiagnosticReport);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.basedOn') do
      value.basedOnList.Add(parseReference(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DiagnosticReport.status'), CODES_TFhirDiagnosticReportStatusEnum, SYSTEMS_TFhirDiagnosticReportStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DiagnosticReport.code'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/DiagnosticReport.subject'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/DiagnosticReport.encounter'));
    if obj.has('effectivePeriod', item) then
      value.effective := parsePeriod(item);
    if obj.has('effectiveDateTime', item) then
      value.effective := parseDateTime(item);
    value.issuedElement := ParseInstant(obj.complex('http://hl7.org/fhir/DiagnosticReport.issued'));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.performer') do
      value.performerList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.resultsInterpreter') do
      value.resultsInterpreterList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.specimen') do
      value.specimenList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.result') do
      value.resultList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.study') do
      value.studyList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.supportingInfo') do
      value.supportingInfoList.Add(parseDiagnosticReportSupportingInfo(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.media') do
      value.mediaList.Add(parseDiagnosticReportMedia(item));
    value.composition := ParseReference(obj.complex('http://hl7.org/fhir/DiagnosticReport.composition'));
    value.conclusionElement := ParseString(obj.complex('http://hl7.org/fhir/DiagnosticReport.conclusion'));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.conclusionCode') do
      value.conclusionCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.presentedForm') do
      value.presentedFormList.Add(parseAttachment(item));
end;

procedure TFHIRTurtleComposer.ComposeDiagnosticReport(parent :  TTurtleComplex; parentType, name : String; value : TFhirDiagnosticReport; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DiagnosticReport');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DiagnosticReport', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'DiagnosticReport', 'basedOn', value.basedOnList[i], false, i);
  ComposeEnum(this, 'DiagnosticReport', 'status', value.statusElement, CODES_TFhirDiagnosticReportStatusEnum, SYSTEMS_TFhirDiagnosticReportStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'DiagnosticReport', 'category', value.categoryList[i], false, i);
  ComposeCodeableConcept(this, 'DiagnosticReport', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'DiagnosticReport', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'DiagnosticReport', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.effective is TFhirPeriod) {6} then
    ComposePeriod(this, 'DiagnosticReport', 'effectivePeriod', TFhirPeriod(value.effective), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.effective is TFhirDateTime) {6} then
    ComposeDateTime(this, 'DiagnosticReport', 'effectiveDateTime', TFhirDateTime(value.effective), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'DiagnosticReport', 'issued', value.issuedElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeReference(this, 'DiagnosticReport', 'performer', value.performerList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.resultsInterpreterList.Count - 1 do
      ComposeReference(this, 'DiagnosticReport', 'resultsInterpreter', value.resultsInterpreterList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.specimenList.Count - 1 do
      ComposeReference(this, 'DiagnosticReport', 'specimen', value.specimenList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.resultList.Count - 1 do
      ComposeReference(this, 'DiagnosticReport', 'result', value.resultList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'DiagnosticReport', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.studyList.Count - 1 do
      ComposeReference(this, 'DiagnosticReport', 'study', value.studyList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInfoList.Count - 1 do
      ComposeDiagnosticReportSupportingInfo(this, 'DiagnosticReport', 'supportingInfo', value.supportingInfoList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.mediaList.Count - 1 do
      ComposeDiagnosticReportMedia(this, 'DiagnosticReport', 'media', value.mediaList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'DiagnosticReport', 'composition', value.compositionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'DiagnosticReport', 'conclusion', value.conclusionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.conclusionCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'DiagnosticReport', 'conclusionCode', value.conclusionCodeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.presentedFormList.Count - 1 do
      ComposeAttachment(this, 'DiagnosticReport', 'presentedForm', value.presentedFormList[i], false, i);
end;

{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
function TFHIRTurtleParser.ParseDocumentManifestRelated(obj : TTurtleComplex) : TFhirDocumentManifestRelated;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentManifestRelated.create;
  try
    ParseDocumentManifestRelatedProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentManifestRelatedProperties(obj : TTurtleComplex; value : TFhirDocumentManifestRelated);
begin
    ParseBackboneElementProperties(obj, value);
    value.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/DocumentManifest.related.identifier'));
    value.ref := ParseReference(obj.complex('http://hl7.org/fhir/DocumentManifest.related.ref'));
end;

procedure TFHIRTurtleComposer.ComposeDocumentManifestRelated(parent :  TTurtleComplex; parentType, name : String; value : TFhirDocumentManifestRelated; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentManifestRelated');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'DocumentManifest.related', 'identifier', value.identifierElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'DocumentManifest.related', 'ref', value.refElement, false, -1);
end;

function TFHIRTurtleParser.ParseDocumentManifest(obj : TTurtleComplex) : TFhirDocumentManifest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentManifest.create;
  try
    ParseDocumentManifestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentManifestProperties(obj : TTurtleComplex; value : TFhirDocumentManifest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    value.masterIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/DocumentManifest.masterIdentifier'));
    for item in obj.complexes('http://hl7.org/fhir/DocumentManifest.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DocumentManifest.status'), CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DocumentManifest.type'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/DocumentManifest.subject'));
    value.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DocumentManifest.created'));
    for item in obj.complexes('http://hl7.org/fhir/DocumentManifest.author') do
      value.authorList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/DocumentManifest.recipient') do
      value.recipientList.Add(parseReference(item));
    value.sourceElement := ParseUri(obj.complex('http://hl7.org/fhir/DocumentManifest.source'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/DocumentManifest.description'));
    for item in obj.complexes('http://hl7.org/fhir/DocumentManifest.content') do
      value.contentList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/DocumentManifest.related') do
      value.relatedList.Add(parseDocumentManifestRelated(item));
end;

procedure TFHIRTurtleComposer.ComposeDocumentManifest(parent :  TTurtleComplex; parentType, name : String; value : TFhirDocumentManifest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentManifest');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'DocumentManifest', 'masterIdentifier', value.masterIdentifierElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DocumentManifest', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'DocumentManifest', 'status', value.statusElement, CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DocumentManifest', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'DocumentManifest', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'DocumentManifest', 'created', value.createdElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeReference(this, 'DocumentManifest', 'author', value.authorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.recipientList.Count - 1 do
      ComposeReference(this, 'DocumentManifest', 'recipient', value.recipientList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'DocumentManifest', 'source', value.sourceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'DocumentManifest', 'description', value.descriptionElement, false, -1);
  for i := 0 to value.contentList.Count - 1 do
      ComposeReference(this, 'DocumentManifest', 'content', value.contentList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedList.Count - 1 do
      ComposeDocumentManifestRelated(this, 'DocumentManifest', 'related', value.relatedList[i], false, i);
end;

{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
function TFHIRTurtleParser.ParseDocumentReferenceAttester(obj : TTurtleComplex) : TFhirDocumentReferenceAttester;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentReferenceAttester.create;
  try
    ParseDocumentReferenceAttesterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentReferenceAttesterProperties(obj : TTurtleComplex; value : TFhirDocumentReferenceAttester);
begin
    ParseBackboneElementProperties(obj, value);
    value.mode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DocumentReference.attester.mode'));
    value.timeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DocumentReference.attester.time'));
    value.party := ParseReference(obj.complex('http://hl7.org/fhir/DocumentReference.attester.party'));
end;

procedure TFHIRTurtleComposer.ComposeDocumentReferenceAttester(parent :  TTurtleComplex; parentType, name : String; value : TFhirDocumentReferenceAttester; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentReferenceAttester');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'DocumentReference.attester', 'mode', value.modeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'DocumentReference.attester', 'time', value.timeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'DocumentReference.attester', 'party', value.partyElement, false, -1);
end;

function TFHIRTurtleParser.ParseDocumentReferenceRelatesTo(obj : TTurtleComplex) : TFhirDocumentReferenceRelatesTo;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    ParseDocumentReferenceRelatesToProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentReferenceRelatesToProperties(obj : TTurtleComplex; value : TFhirDocumentReferenceRelatesTo);
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DocumentReference.relatesTo.code'));
    value.target := ParseReference(obj.complex('http://hl7.org/fhir/DocumentReference.relatesTo.target'));
end;

procedure TFHIRTurtleComposer.ComposeDocumentReferenceRelatesTo(parent :  TTurtleComplex; parentType, name : String; value : TFhirDocumentReferenceRelatesTo; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentReferenceRelatesTo');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'DocumentReference.relatesTo', 'code', value.codeElement, false, -1);
  ComposeReference(this, 'DocumentReference.relatesTo', 'target', value.targetElement, false, -1);
end;

function TFHIRTurtleParser.ParseDocumentReferenceContent(obj : TTurtleComplex) : TFhirDocumentReferenceContent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentReferenceContent.create;
  try
    ParseDocumentReferenceContentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentReferenceContentProperties(obj : TTurtleComplex; value : TFhirDocumentReferenceContent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.attachment := ParseAttachment(obj.complex('http://hl7.org/fhir/DocumentReference.content.attachment'));
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.content.profile') do
      value.profileList.Add(parseDocumentReferenceContentProfile(item));
end;

procedure TFHIRTurtleComposer.ComposeDocumentReferenceContent(parent :  TTurtleComplex; parentType, name : String; value : TFhirDocumentReferenceContent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentReferenceContent');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeAttachment(this, 'DocumentReference.content', 'attachment', value.attachmentElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.profileList.Count - 1 do
      ComposeDocumentReferenceContentProfile(this, 'DocumentReference.content', 'profile', value.profileList[i], false, i);
end;

function TFHIRTurtleParser.ParseDocumentReferenceContentProfile(obj : TTurtleComplex) : TFhirDocumentReferenceContentProfile;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentReferenceContentProfile.create;
  try
    ParseDocumentReferenceContentProfileProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentReferenceContentProfileProperties(obj : TTurtleComplex; value : TFhirDocumentReferenceContentProfile);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('valueCoding', item) then
      value.value := parseCoding(item);
    if obj.has('valueCanonical', item) then
      value.value := parseCanonical(item);
    if obj.has('valueUri', item) then
      value.value := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeDocumentReferenceContentProfile(parent :  TTurtleComplex; parentType, name : String; value : TFhirDocumentReferenceContentProfile; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentReferenceContentProfile');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (value.value is TFhirCoding) {6} then
    ComposeCoding(this, 'DocumentReference.content.profile', 'valueCoding', TFhirCoding(value.value), false, -1)
  else if (value.value is TFhirCanonical) {6} then
    ComposeCanonical(this, 'DocumentReference.content.profile', 'valueCanonical', TFhirCanonical(value.value), false, -1)
  else if (value.value is TFhirUri) {6} then
    ComposeUri(this, 'DocumentReference.content.profile', 'valueUri', TFhirUri(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseDocumentReference(obj : TTurtleComplex) : TFhirDocumentReference;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentReference.create;
  try
    ParseDocumentReferenceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentReferenceProperties(obj : TTurtleComplex; value : TFhirDocumentReference);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.basedOn') do
      value.basedOnList.Add(parseReference(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DocumentReference.status'), CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum);
    value.docStatusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DocumentReference.docStatus'), CODES_TFhirCompositionStatusEnum, SYSTEMS_TFhirCompositionStatusEnum);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DocumentReference.type'));
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/DocumentReference.subject'));
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.context') do
      value.contextList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.event') do
      value.eventList.Add(parseCodeableReference(item));
    value.facilityType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DocumentReference.facilityType'));
    value.practiceSetting := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DocumentReference.practiceSetting'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/DocumentReference.period'));
    value.dateElement := ParseInstant(obj.complex('http://hl7.org/fhir/DocumentReference.date'));
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.author') do
      value.authorList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.attester') do
      value.attesterList.Add(parseDocumentReferenceAttester(item));
    value.custodian := ParseReference(obj.complex('http://hl7.org/fhir/DocumentReference.custodian'));
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.relatesTo') do
      value.relatesToList.Add(parseDocumentReferenceRelatesTo(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/DocumentReference.description'));
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.securityLabel') do
      value.securityLabelList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.content') do
      value.contentList.Add(parseDocumentReferenceContent(item));
end;

procedure TFHIRTurtleComposer.ComposeDocumentReference(parent :  TTurtleComplex; parentType, name : String; value : TFhirDocumentReference; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentReference');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DocumentReference', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'DocumentReference', 'basedOn', value.basedOnList[i], false, i);
  ComposeEnum(this, 'DocumentReference', 'status', value.statusElement, CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'DocumentReference', 'docStatus', value.docStatusElement, CODES_TFhirCompositionStatusEnum, SYSTEMS_TFhirCompositionStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'DocumentReference', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'DocumentReference', 'category', value.categoryList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'DocumentReference', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contextList.Count - 1 do
      ComposeReference(this, 'DocumentReference', 'context', value.contextList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.eventList.Count - 1 do
      ComposeCodeableReference(this, 'DocumentReference', 'event', value.eventList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'DocumentReference', 'facilityType', value.facilityTypeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'DocumentReference', 'practiceSetting', value.practiceSettingElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'DocumentReference', 'period', value.periodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'DocumentReference', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeReference(this, 'DocumentReference', 'author', value.authorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.attesterList.Count - 1 do
      ComposeDocumentReferenceAttester(this, 'DocumentReference', 'attester', value.attesterList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'DocumentReference', 'custodian', value.custodianElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.relatesToList.Count - 1 do
      ComposeDocumentReferenceRelatesTo(this, 'DocumentReference', 'relatesTo', value.relatesToList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'DocumentReference', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.securityLabelList.Count - 1 do
      ComposeCodeableConcept(this, 'DocumentReference', 'securityLabel', value.securityLabelList[i], false, i);
  for i := 0 to value.contentList.Count - 1 do
      ComposeDocumentReferenceContent(this, 'DocumentReference', 'content', value.contentList[i], false, i);
end;

{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ENCOUNTER}
function TFHIRTurtleParser.ParseEncounterStatusHistory(obj : TTurtleComplex) : TFhirEncounterStatusHistory;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounterStatusHistory.create;
  try
    ParseEncounterStatusHistoryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterStatusHistoryProperties(obj : TTurtleComplex; value : TFhirEncounterStatusHistory);
begin
    ParseBackboneElementProperties(obj, value);
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Encounter.statusHistory.status'), CODES_TFhirEncounterStatusEnum, SYSTEMS_TFhirEncounterStatusEnum);
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Encounter.statusHistory.period'));
end;

procedure TFHIRTurtleComposer.ComposeEncounterStatusHistory(parent :  TTurtleComplex; parentType, name : String; value : TFhirEncounterStatusHistory; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EncounterStatusHistory');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'Encounter.statusHistory', 'status', value.statusElement, CODES_TFhirEncounterStatusEnum, SYSTEMS_TFhirEncounterStatusEnum, false, -1);
  ComposePeriod(this, 'Encounter.statusHistory', 'period', value.periodElement, false, -1);
end;

function TFHIRTurtleParser.ParseEncounterClassHistory(obj : TTurtleComplex) : TFhirEncounterClassHistory;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounterClassHistory.create;
  try
    ParseEncounterClassHistoryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterClassHistoryProperties(obj : TTurtleComplex; value : TFhirEncounterClassHistory);
begin
    ParseBackboneElementProperties(obj, value);
    value.class_ := ParseCoding(obj.complex('http://hl7.org/fhir/Encounter.classHistory.class'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Encounter.classHistory.period'));
end;

procedure TFHIRTurtleComposer.ComposeEncounterClassHistory(parent :  TTurtleComplex; parentType, name : String; value : TFhirEncounterClassHistory; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EncounterClassHistory');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCoding(this, 'Encounter.classHistory', 'class', value.class_Element, false, -1);
  ComposePeriod(this, 'Encounter.classHistory', 'period', value.periodElement, false, -1);
end;

function TFHIRTurtleParser.ParseEncounterParticipant(obj : TTurtleComplex) : TFhirEncounterParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounterParticipant.create;
  try
    ParseEncounterParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterParticipantProperties(obj : TTurtleComplex; value : TFhirEncounterParticipant);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Encounter.participant.type') do
      value.type_List.Add(parseCodeableConcept(item));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Encounter.participant.period'));
    value.actor := ParseReference(obj.complex('http://hl7.org/fhir/Encounter.participant.actor'));
end;

procedure TFHIRTurtleComposer.ComposeEncounterParticipant(parent :  TTurtleComplex; parentType, name : String; value : TFhirEncounterParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EncounterParticipant');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter.participant', 'type', value.type_List[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Encounter.participant', 'period', value.periodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Encounter.participant', 'actor', value.actorElement, false, -1);
end;

function TFHIRTurtleParser.ParseEncounterDiagnosis(obj : TTurtleComplex) : TFhirEncounterDiagnosis;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounterDiagnosis.create;
  try
    ParseEncounterDiagnosisProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterDiagnosisProperties(obj : TTurtleComplex; value : TFhirEncounterDiagnosis);
begin
    ParseBackboneElementProperties(obj, value);
    value.condition := ParseReference(obj.complex('http://hl7.org/fhir/Encounter.diagnosis.condition'));
    value.use := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Encounter.diagnosis.use'));
    value.rankElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Encounter.diagnosis.rank'));
end;

procedure TFHIRTurtleComposer.ComposeEncounterDiagnosis(parent :  TTurtleComplex; parentType, name : String; value : TFhirEncounterDiagnosis; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EncounterDiagnosis');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeReference(this, 'Encounter.diagnosis', 'condition', value.conditionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Encounter.diagnosis', 'use', value.useElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'Encounter.diagnosis', 'rank', value.rankElement, false, -1);
end;

function TFHIRTurtleParser.ParseEncounterAdmission(obj : TTurtleComplex) : TFhirEncounterAdmission;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounterAdmission.create;
  try
    ParseEncounterAdmissionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterAdmissionProperties(obj : TTurtleComplex; value : TFhirEncounterAdmission);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.preAdmissionIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Encounter.admission.preAdmissionIdentifier'));
    value.origin := ParseReference(obj.complex('http://hl7.org/fhir/Encounter.admission.origin'));
    value.admitSource := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Encounter.admission.admitSource'));
    value.reAdmission := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Encounter.admission.reAdmission'));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.admission.dietPreference') do
      value.dietPreferenceList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.admission.specialCourtesy') do
      value.specialCourtesyList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.admission.specialArrangement') do
      value.specialArrangementList.Add(parseCodeableConcept(item));
    value.destination := ParseReference(obj.complex('http://hl7.org/fhir/Encounter.admission.destination'));
    value.dischargeDisposition := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Encounter.admission.dischargeDisposition'));
end;

procedure TFHIRTurtleComposer.ComposeEncounterAdmission(parent :  TTurtleComplex; parentType, name : String; value : TFhirEncounterAdmission; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EncounterAdmission');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'Encounter.admission', 'preAdmissionIdentifier', value.preAdmissionIdentifierElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Encounter.admission', 'origin', value.originElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Encounter.admission', 'admitSource', value.admitSourceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Encounter.admission', 'reAdmission', value.reAdmissionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dietPreferenceList.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter.admission', 'dietPreference', value.dietPreferenceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.specialCourtesyList.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter.admission', 'specialCourtesy', value.specialCourtesyList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.specialArrangementList.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter.admission', 'specialArrangement', value.specialArrangementList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Encounter.admission', 'destination', value.destinationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Encounter.admission', 'dischargeDisposition', value.dischargeDispositionElement, false, -1);
end;

function TFHIRTurtleParser.ParseEncounterLocation(obj : TTurtleComplex) : TFhirEncounterLocation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounterLocation.create;
  try
    ParseEncounterLocationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterLocationProperties(obj : TTurtleComplex; value : TFhirEncounterLocation);
begin
    ParseBackboneElementProperties(obj, value);
    value.location := ParseReference(obj.complex('http://hl7.org/fhir/Encounter.location.location'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Encounter.location.status'), CODES_TFhirEncounterLocationStatusEnum, SYSTEMS_TFhirEncounterLocationStatusEnum);
    value.form := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Encounter.location.form'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Encounter.location.period'));
end;

procedure TFHIRTurtleComposer.ComposeEncounterLocation(parent :  TTurtleComplex; parentType, name : String; value : TFhirEncounterLocation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EncounterLocation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeReference(this, 'Encounter.location', 'location', value.locationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Encounter.location', 'status', value.statusElement, CODES_TFhirEncounterLocationStatusEnum, SYSTEMS_TFhirEncounterLocationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Encounter.location', 'form', value.formElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Encounter.location', 'period', value.periodElement, false, -1);
end;

function TFHIRTurtleParser.ParseEncounter(obj : TTurtleComplex) : TFhirEncounter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounter.create;
  try
    ParseEncounterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterProperties(obj : TTurtleComplex; value : TFhirEncounter);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Encounter.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Encounter.status'), CODES_TFhirEncounterStatusEnum, SYSTEMS_TFhirEncounterStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/Encounter.statusHistory') do
      value.statusHistoryList.Add(parseEncounterStatusHistory(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.class') do
      value.class_List.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.classHistory') do
      value.classHistoryList.Add(parseEncounterClassHistory(item));
    value.priority := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Encounter.priority'));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.type') do
      value.type_List.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.serviceType') do
      value.serviceTypeList.Add(parseCodeableReference(item));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/Encounter.subject'));
    value.subjectStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Encounter.subjectStatus'));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.episodeOfCare') do
      value.episodeOfCareList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.basedOn') do
      value.basedOnList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.careTeam') do
      value.careTeamList.Add(parseReference(item));
    value.partOf := ParseReference(obj.complex('http://hl7.org/fhir/Encounter.partOf'));
    value.serviceProvider := ParseReference(obj.complex('http://hl7.org/fhir/Encounter.serviceProvider'));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.participant') do
      value.participantList.Add(parseEncounterParticipant(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.appointment') do
      value.appointmentList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.virtualService') do
      value.virtualServiceList.Add(parseVirtualServiceDetail(item));
    value.actualPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Encounter.actualPeriod'));
    value.plannedStartDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Encounter.plannedStartDate'));
    value.plannedEndDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Encounter.plannedEndDate'));
    value.length := ParseDuration(obj.complex('http://hl7.org/fhir/Encounter.length'));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.reason') do
      value.reasonList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.diagnosis') do
      value.diagnosisList.Add(parseEncounterDiagnosis(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.account') do
      value.accountList.Add(parseReference(item));
    value.admission := ParseEncounterAdmission(obj.complex('http://hl7.org/fhir/Encounter.admission'));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.location') do
      value.locationList.Add(parseEncounterLocation(item));
end;

procedure TFHIRTurtleComposer.ComposeEncounter(parent :  TTurtleComplex; parentType, name : String; value : TFhirEncounter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Encounter');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Encounter', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'Encounter', 'status', value.statusElement, CODES_TFhirEncounterStatusEnum, SYSTEMS_TFhirEncounterStatusEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.statusHistoryList.Count - 1 do
      ComposeEncounterStatusHistory(this, 'Encounter', 'statusHistory', value.statusHistoryList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.class_List.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter', 'class', value.class_List[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.classHistoryList.Count - 1 do
      ComposeEncounterClassHistory(this, 'Encounter', 'classHistory', value.classHistoryList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Encounter', 'priority', value.priorityElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter', 'type', value.type_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.serviceTypeList.Count - 1 do
      ComposeCodeableReference(this, 'Encounter', 'serviceType', value.serviceTypeList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Encounter', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Encounter', 'subjectStatus', value.subjectStatusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.episodeOfCareList.Count - 1 do
      ComposeReference(this, 'Encounter', 'episodeOfCare', value.episodeOfCareList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'Encounter', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.careTeamList.Count - 1 do
      ComposeReference(this, 'Encounter', 'careTeam', value.careTeamList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Encounter', 'partOf', value.partOfElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Encounter', 'serviceProvider', value.serviceProviderElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.participantList.Count - 1 do
      ComposeEncounterParticipant(this, 'Encounter', 'participant', value.participantList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.appointmentList.Count - 1 do
      ComposeReference(this, 'Encounter', 'appointment', value.appointmentList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.virtualServiceList.Count - 1 do
      ComposeVirtualServiceDetail(this, 'Encounter', 'virtualService', value.virtualServiceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Encounter', 'actualPeriod', value.actualPeriodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Encounter', 'plannedStartDate', value.plannedStartDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Encounter', 'plannedEndDate', value.plannedEndDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(this, 'Encounter', 'length', value.lengthElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(this, 'Encounter', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.diagnosisList.Count - 1 do
      ComposeEncounterDiagnosis(this, 'Encounter', 'diagnosis', value.diagnosisList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.accountList.Count - 1 do
      ComposeReference(this, 'Encounter', 'account', value.accountList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeEncounterAdmission(this, 'Encounter', 'admission', value.admissionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.locationList.Count - 1 do
      ComposeEncounterLocation(this, 'Encounter', 'location', value.locationList[i], false, i);
end;

{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
function TFHIRTurtleParser.ParseEndpoint(obj : TTurtleComplex) : TFhirEndpoint;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEndpoint.create;
  try
    ParseEndpointProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEndpointProperties(obj : TTurtleComplex; value : TFhirEndpoint);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Endpoint.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Endpoint.status'), CODES_TFhirEndpointStatusEnum, SYSTEMS_TFhirEndpointStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/Endpoint.connectionType') do
      value.connectionTypeList.Add(parseCodeableConcept(item));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Endpoint.name'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Endpoint.description'));
    for item in obj.complexes('http://hl7.org/fhir/Endpoint.environmentType') do
      value.environmentTypeList.Add(parseCodeableConcept(item));
    value.managingOrganization := ParseReference(obj.complex('http://hl7.org/fhir/Endpoint.managingOrganization'));
    for item in obj.complexes('http://hl7.org/fhir/Endpoint.contact') do
      value.contactList.Add(parseContactPoint(item));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Endpoint.period'));
    for item in obj.complexes('http://hl7.org/fhir/Endpoint.payloadType') do
      value.payloadTypeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Endpoint.payloadMimeType') do
      value.payloadMimeTypeList.Add(parseCode(item));
    value.addressElement := ParseUrl(obj.complex('http://hl7.org/fhir/Endpoint.address'));
    for item in obj.complexes('http://hl7.org/fhir/Endpoint.header') do
      value.headerList.Add(parseString(item));
end;

procedure TFHIRTurtleComposer.ComposeEndpoint(parent :  TTurtleComplex; parentType, name : String; value : TFhirEndpoint; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Endpoint');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Endpoint', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'Endpoint', 'status', value.statusElement, CODES_TFhirEndpointStatusEnum, SYSTEMS_TFhirEndpointStatusEnum, false, -1);
  for i := 0 to value.connectionTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Endpoint', 'connectionType', value.connectionTypeList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Endpoint', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Endpoint', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.environmentTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Endpoint', 'environmentType', value.environmentTypeList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Endpoint', 'managingOrganization', value.managingOrganizationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactPoint(this, 'Endpoint', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Endpoint', 'period', value.periodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.payloadTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Endpoint', 'payloadType', value.payloadTypeList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.payloadMimeTypeList.Count - 1 do
      ComposeCode(this, 'Endpoint', 'payloadMimeType', value.payloadMimeTypeList[i], false, i);
  ComposeUrl(this, 'Endpoint', 'address', value.addressElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.headerList.Count - 1 do
      ComposeString(this, 'Endpoint', 'header', value.headerList[i], false, i);
end;

{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
function TFHIRTurtleParser.ParseEnrollmentRequest(obj : TTurtleComplex) : TFhirEnrollmentRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEnrollmentRequest.create;
  try
    ParseEnrollmentRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEnrollmentRequestProperties(obj : TTurtleComplex; value : TFhirEnrollmentRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/EnrollmentRequest.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/EnrollmentRequest.status'), CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum);
    value.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/EnrollmentRequest.created'));
    value.insurer := ParseReference(obj.complex('http://hl7.org/fhir/EnrollmentRequest.insurer'));
    value.provider := ParseReference(obj.complex('http://hl7.org/fhir/EnrollmentRequest.provider'));
    value.candidate := ParseReference(obj.complex('http://hl7.org/fhir/EnrollmentRequest.candidate'));
    value.coverage := ParseReference(obj.complex('http://hl7.org/fhir/EnrollmentRequest.coverage'));
end;

procedure TFHIRTurtleComposer.ComposeEnrollmentRequest(parent :  TTurtleComplex; parentType, name : String; value : TFhirEnrollmentRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EnrollmentRequest');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EnrollmentRequest', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'EnrollmentRequest', 'status', value.statusElement, CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'EnrollmentRequest', 'created', value.createdElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'EnrollmentRequest', 'insurer', value.insurerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'EnrollmentRequest', 'provider', value.providerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'EnrollmentRequest', 'candidate', value.candidateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'EnrollmentRequest', 'coverage', value.coverageElement, false, -1);
end;

{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
function TFHIRTurtleParser.ParseEnrollmentResponse(obj : TTurtleComplex) : TFhirEnrollmentResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEnrollmentResponse.create;
  try
    ParseEnrollmentResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEnrollmentResponseProperties(obj : TTurtleComplex; value : TFhirEnrollmentResponse);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/EnrollmentResponse.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/EnrollmentResponse.status'), CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum);
    value.request := ParseReference(obj.complex('http://hl7.org/fhir/EnrollmentResponse.request'));
    value.outcomeElement := ParseEnum(obj.complex('http://hl7.org/fhir/EnrollmentResponse.outcome'), CODES_TFhirEnrollmentOutcomeEnum, SYSTEMS_TFhirEnrollmentOutcomeEnum);
    value.dispositionElement := ParseString(obj.complex('http://hl7.org/fhir/EnrollmentResponse.disposition'));
    value.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/EnrollmentResponse.created'));
    value.organization := ParseReference(obj.complex('http://hl7.org/fhir/EnrollmentResponse.organization'));
    value.requestProvider := ParseReference(obj.complex('http://hl7.org/fhir/EnrollmentResponse.requestProvider'));
end;

procedure TFHIRTurtleComposer.ComposeEnrollmentResponse(parent :  TTurtleComplex; parentType, name : String; value : TFhirEnrollmentResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EnrollmentResponse');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EnrollmentResponse', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'EnrollmentResponse', 'status', value.statusElement, CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'EnrollmentResponse', 'request', value.requestElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'EnrollmentResponse', 'outcome', value.outcomeElement, CODES_TFhirEnrollmentOutcomeEnum, SYSTEMS_TFhirEnrollmentOutcomeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'EnrollmentResponse', 'disposition', value.dispositionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'EnrollmentResponse', 'created', value.createdElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'EnrollmentResponse', 'organization', value.organizationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'EnrollmentResponse', 'requestProvider', value.requestProviderElement, false, -1);
end;

{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
function TFHIRTurtleParser.ParseEpisodeOfCareStatusHistory(obj : TTurtleComplex) : TFhirEpisodeOfCareStatusHistory;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEpisodeOfCareStatusHistory.create;
  try
    ParseEpisodeOfCareStatusHistoryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEpisodeOfCareStatusHistoryProperties(obj : TTurtleComplex; value : TFhirEpisodeOfCareStatusHistory);
begin
    ParseBackboneElementProperties(obj, value);
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/EpisodeOfCare.statusHistory.status'), CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum);
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/EpisodeOfCare.statusHistory.period'));
end;

procedure TFHIRTurtleComposer.ComposeEpisodeOfCareStatusHistory(parent :  TTurtleComplex; parentType, name : String; value : TFhirEpisodeOfCareStatusHistory; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EpisodeOfCareStatusHistory');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'EpisodeOfCare.statusHistory', 'status', value.statusElement, CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum, false, -1);
  ComposePeriod(this, 'EpisodeOfCare.statusHistory', 'period', value.periodElement, false, -1);
end;

function TFHIRTurtleParser.ParseEpisodeOfCareDiagnosis(obj : TTurtleComplex) : TFhirEpisodeOfCareDiagnosis;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEpisodeOfCareDiagnosis.create;
  try
    ParseEpisodeOfCareDiagnosisProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEpisodeOfCareDiagnosisProperties(obj : TTurtleComplex; value : TFhirEpisodeOfCareDiagnosis);
begin
    ParseBackboneElementProperties(obj, value);
    value.condition := ParseCodeableReference(obj.complex('http://hl7.org/fhir/EpisodeOfCare.diagnosis.condition'));
    value.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EpisodeOfCare.diagnosis.role'));
    value.rankElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/EpisodeOfCare.diagnosis.rank'));
end;

procedure TFHIRTurtleComposer.ComposeEpisodeOfCareDiagnosis(parent :  TTurtleComplex; parentType, name : String; value : TFhirEpisodeOfCareDiagnosis; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EpisodeOfCareDiagnosis');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableReference(this, 'EpisodeOfCare.diagnosis', 'condition', value.conditionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'EpisodeOfCare.diagnosis', 'role', value.roleElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'EpisodeOfCare.diagnosis', 'rank', value.rankElement, false, -1);
end;

function TFHIRTurtleParser.ParseEpisodeOfCare(obj : TTurtleComplex) : TFhirEpisodeOfCare;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEpisodeOfCare.create;
  try
    ParseEpisodeOfCareProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEpisodeOfCareProperties(obj : TTurtleComplex; value : TFhirEpisodeOfCare);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/EpisodeOfCare.status'), CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.statusHistory') do
      value.statusHistoryList.Add(parseEpisodeOfCareStatusHistory(item));
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.type') do
      value.type_List.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.diagnosis') do
      value.diagnosisList.Add(parseEpisodeOfCareDiagnosis(item));
    value.patient := ParseReference(obj.complex('http://hl7.org/fhir/EpisodeOfCare.patient'));
    value.managingOrganization := ParseReference(obj.complex('http://hl7.org/fhir/EpisodeOfCare.managingOrganization'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/EpisodeOfCare.period'));
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.referralRequest') do
      value.referralRequestList.Add(parseReference(item));
    value.careManager := ParseReference(obj.complex('http://hl7.org/fhir/EpisodeOfCare.careManager'));
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.careTeam') do
      value.careTeamList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.account') do
      value.accountList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeEpisodeOfCare(parent :  TTurtleComplex; parentType, name : String; value : TFhirEpisodeOfCare; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EpisodeOfCare');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EpisodeOfCare', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'EpisodeOfCare', 'status', value.statusElement, CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.statusHistoryList.Count - 1 do
      ComposeEpisodeOfCareStatusHistory(this, 'EpisodeOfCare', 'statusHistory', value.statusHistoryList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'EpisodeOfCare', 'type', value.type_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.diagnosisList.Count - 1 do
      ComposeEpisodeOfCareDiagnosis(this, 'EpisodeOfCare', 'diagnosis', value.diagnosisList[i], false, i);
  ComposeReference(this, 'EpisodeOfCare', 'patient', value.patientElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'EpisodeOfCare', 'managingOrganization', value.managingOrganizationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'EpisodeOfCare', 'period', value.periodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.referralRequestList.Count - 1 do
      ComposeReference(this, 'EpisodeOfCare', 'referralRequest', value.referralRequestList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'EpisodeOfCare', 'careManager', value.careManagerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.careTeamList.Count - 1 do
      ComposeReference(this, 'EpisodeOfCare', 'careTeam', value.careTeamList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.accountList.Count - 1 do
      ComposeReference(this, 'EpisodeOfCare', 'account', value.accountList[i], false, i);
end;

{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EVENTDEFINITION}
function TFHIRTurtleParser.ParseEventDefinition(obj : TTurtleComplex) : TFhirEventDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEventDefinition.create;
  try
    ParseEventDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEventDefinitionProperties(obj : TTurtleComplex; value : TFhirEventDefinition);
var
  item : TTurtleComplex;
begin
    ParseMetadataResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/EventDefinition.url'));
    for item in obj.complexes('http://hl7.org/fhir/EventDefinition.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/EventDefinition.version'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/EventDefinition.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/EventDefinition.title'));
    value.subtitleElement := ParseString(obj.complex('http://hl7.org/fhir/EventDefinition.subtitle'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/EventDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/EventDefinition.experimental'));
    if obj.has('subjectCodeableConcept', item) then
      value.subject := parseCodeableConcept(item);
    if obj.has('subjectReference', item) {a3} then
      value.subject := ParseReference(item);
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/EventDefinition.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/EventDefinition.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/EventDefinition.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/EventDefinition.description'));
    for item in obj.complexes('http://hl7.org/fhir/EventDefinition.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/EventDefinition.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/EventDefinition.purpose'));
    value.usageElement := ParseString(obj.complex('http://hl7.org/fhir/EventDefinition.usage'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/EventDefinition.copyright'));
    value.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/EventDefinition.approvalDate'));
    value.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/EventDefinition.lastReviewDate'));
    value.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/EventDefinition.effectivePeriod'));
    for item in obj.complexes('http://hl7.org/fhir/EventDefinition.topic') do
      value.topicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/EventDefinition.author') do
      value.authorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/EventDefinition.editor') do
      value.editorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/EventDefinition.reviewer') do
      value.reviewerList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/EventDefinition.endorser') do
      value.endorserList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/EventDefinition.relatedArtifact') do
      value.relatedArtifactList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/EventDefinition.trigger') do
      value.triggerList.Add(parseTriggerDefinition(item));
end;

procedure TFHIRTurtleComposer.ComposeEventDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirEventDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EventDefinition');
  end;
  composeMetadataResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'EventDefinition', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EventDefinition', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'EventDefinition', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'EventDefinition', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'EventDefinition', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'EventDefinition', 'subtitle', value.subtitleElement, false, -1);
  ComposeEnum(this, 'EventDefinition', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'EventDefinition', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.subject is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'EventDefinition', 'subjectCodeableConcept', TFhirCodeableConcept(value.subject), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.subject is TFhirReference) {2} then
    ComposeReference(this, 'EventDefinition', 'subjectReference', TFhirReference(value.subject), false,-1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'EventDefinition', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'EventDefinition', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'EventDefinition', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'EventDefinition', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'EventDefinition', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'EventDefinition', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'EventDefinition', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'EventDefinition', 'usage', value.usageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'EventDefinition', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'EventDefinition', 'approvalDate', value.approvalDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'EventDefinition', 'lastReviewDate', value.lastReviewDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'EventDefinition', 'effectivePeriod', value.effectivePeriodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.topicList.Count - 1 do
      ComposeCodeableConcept(this, 'EventDefinition', 'topic', value.topicList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(this, 'EventDefinition', 'author', value.authorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(this, 'EventDefinition', 'editor', value.editorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(this, 'EventDefinition', 'reviewer', value.reviewerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(this, 'EventDefinition', 'endorser', value.endorserList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'EventDefinition', 'relatedArtifact', value.relatedArtifactList[i], false, i);
  for i := 0 to value.triggerList.Count - 1 do
      ComposeTriggerDefinition(this, 'EventDefinition', 'trigger', value.triggerList[i], false, i);
end;

{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EVIDENCE}
function TFHIRTurtleParser.ParseEvidenceVariableDefinition(obj : TTurtleComplex) : TFhirEvidenceVariableDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEvidenceVariableDefinition.create;
  try
    ParseEvidenceVariableDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEvidenceVariableDefinitionProperties(obj : TTurtleComplex; value : TFhirEvidenceVariableDefinition);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Evidence.variableDefinition.description'));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.variableDefinition.note') do
      value.noteList.Add(parseAnnotation(item));
    value.variableRole := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Evidence.variableDefinition.variableRole'));
    value.observed := ParseReference(obj.complex('http://hl7.org/fhir/Evidence.variableDefinition.observed'));
    value.intended := ParseReference(obj.complex('http://hl7.org/fhir/Evidence.variableDefinition.intended'));
    value.directnessMatch := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Evidence.variableDefinition.directnessMatch'));
end;

procedure TFHIRTurtleComposer.ComposeEvidenceVariableDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceVariableDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EvidenceVariableDefinition');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'Evidence.variableDefinition', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'Evidence.variableDefinition', 'note', value.noteList[i], false, i);
  ComposeCodeableConcept(this, 'Evidence.variableDefinition', 'variableRole', value.variableRoleElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Evidence.variableDefinition', 'observed', value.observedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Evidence.variableDefinition', 'intended', value.intendedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Evidence.variableDefinition', 'directnessMatch', value.directnessMatchElement, false, -1);
end;

function TFHIRTurtleParser.ParseEvidenceStatistic(obj : TTurtleComplex) : TFhirEvidenceStatistic;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEvidenceStatistic.create;
  try
    ParseEvidenceStatisticProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEvidenceStatisticProperties(obj : TTurtleComplex; value : TFhirEvidenceStatistic);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Evidence.statistic.description'));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.statistic.note') do
      value.noteList.Add(parseAnnotation(item));
    value.statisticType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Evidence.statistic.statisticType'));
    value.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Evidence.statistic.category'));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Evidence.statistic.quantity'));
    value.numberOfEventsElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Evidence.statistic.numberOfEvents'));
    value.numberAffectedElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Evidence.statistic.numberAffected'));
    value.sampleSize := ParseEvidenceStatisticSampleSize(obj.complex('http://hl7.org/fhir/Evidence.statistic.sampleSize'));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.statistic.attributeEstimate') do
      value.attributeEstimateList.Add(parseEvidenceStatisticAttributeEstimate(item));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.statistic.modelCharacteristic') do
      value.modelCharacteristicList.Add(parseEvidenceStatisticModelCharacteristic(item));
end;

procedure TFHIRTurtleComposer.ComposeEvidenceStatistic(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceStatistic; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EvidenceStatistic');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Evidence.statistic', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'Evidence.statistic', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Evidence.statistic', 'statisticType', value.statisticTypeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Evidence.statistic', 'category', value.categoryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Evidence.statistic', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(this, 'Evidence.statistic', 'numberOfEvents', value.numberOfEventsElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(this, 'Evidence.statistic', 'numberAffected', value.numberAffectedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEvidenceStatisticSampleSize(this, 'Evidence.statistic', 'sampleSize', value.sampleSizeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.attributeEstimateList.Count - 1 do
      ComposeEvidenceStatisticAttributeEstimate(this, 'Evidence.statistic', 'attributeEstimate', value.attributeEstimateList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modelCharacteristicList.Count - 1 do
      ComposeEvidenceStatisticModelCharacteristic(this, 'Evidence.statistic', 'modelCharacteristic', value.modelCharacteristicList[i], false, i);
end;

function TFHIRTurtleParser.ParseEvidenceStatisticSampleSize(obj : TTurtleComplex) : TFhirEvidenceStatisticSampleSize;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEvidenceStatisticSampleSize.create;
  try
    ParseEvidenceStatisticSampleSizeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEvidenceStatisticSampleSizeProperties(obj : TTurtleComplex; value : TFhirEvidenceStatisticSampleSize);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Evidence.statistic.sampleSize.description'));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.statistic.sampleSize.note') do
      value.noteList.Add(parseAnnotation(item));
    value.numberOfStudiesElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Evidence.statistic.sampleSize.numberOfStudies'));
    value.numberOfParticipantsElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Evidence.statistic.sampleSize.numberOfParticipants'));
    value.knownDataCountElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Evidence.statistic.sampleSize.knownDataCount'));
end;

procedure TFHIRTurtleComposer.ComposeEvidenceStatisticSampleSize(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceStatisticSampleSize; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EvidenceStatisticSampleSize');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Evidence.statistic.sampleSize', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'Evidence.statistic.sampleSize', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(this, 'Evidence.statistic.sampleSize', 'numberOfStudies', value.numberOfStudiesElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(this, 'Evidence.statistic.sampleSize', 'numberOfParticipants', value.numberOfParticipantsElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(this, 'Evidence.statistic.sampleSize', 'knownDataCount', value.knownDataCountElement, false, -1);
end;

function TFHIRTurtleParser.ParseEvidenceStatisticAttributeEstimate(obj : TTurtleComplex) : TFhirEvidenceStatisticAttributeEstimate;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEvidenceStatisticAttributeEstimate.create;
  try
    ParseEvidenceStatisticAttributeEstimateProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEvidenceStatisticAttributeEstimateProperties(obj : TTurtleComplex; value : TFhirEvidenceStatisticAttributeEstimate);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Evidence.statistic.attributeEstimate.description'));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.statistic.attributeEstimate.note') do
      value.noteList.Add(parseAnnotation(item));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Evidence.statistic.attributeEstimate.type'));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Evidence.statistic.attributeEstimate.quantity'));
    value.levelElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Evidence.statistic.attributeEstimate.level'));
    value.range := ParseRange(obj.complex('http://hl7.org/fhir/Evidence.statistic.attributeEstimate.range'));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.statistic.attributeEstimate.attributeEstimate') do
      value.attributeEstimateList.Add(parseEvidenceStatisticAttributeEstimate(item));
end;

procedure TFHIRTurtleComposer.ComposeEvidenceStatisticAttributeEstimate(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceStatisticAttributeEstimate; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EvidenceStatisticAttributeEstimate');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Evidence.statistic.attributeEstimate', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'Evidence.statistic.attributeEstimate', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Evidence.statistic.attributeEstimate', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Evidence.statistic.attributeEstimate', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Evidence.statistic.attributeEstimate', 'level', value.levelElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(this, 'Evidence.statistic.attributeEstimate', 'range', value.rangeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.attributeEstimateList.Count - 1 do
      ComposeEvidenceStatisticAttributeEstimate(this, 'Evidence.statistic.attributeEstimate', 'attributeEstimate', value.attributeEstimateList[i], false, i);
end;

function TFHIRTurtleParser.ParseEvidenceStatisticModelCharacteristic(obj : TTurtleComplex) : TFhirEvidenceStatisticModelCharacteristic;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEvidenceStatisticModelCharacteristic.create;
  try
    ParseEvidenceStatisticModelCharacteristicProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEvidenceStatisticModelCharacteristicProperties(obj : TTurtleComplex; value : TFhirEvidenceStatisticModelCharacteristic);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Evidence.statistic.modelCharacteristic.code'));
    value.value := ParseQuantity(obj.complex('http://hl7.org/fhir/Evidence.statistic.modelCharacteristic.value'));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.statistic.modelCharacteristic.variable') do
      value.variableList.Add(parseEvidenceStatisticModelCharacteristicVariable(item));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.statistic.modelCharacteristic.attributeEstimate') do
      value.attributeEstimateList.Add(parseEvidenceStatisticAttributeEstimate(item));
end;

procedure TFHIRTurtleComposer.ComposeEvidenceStatisticModelCharacteristic(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceStatisticModelCharacteristic; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EvidenceStatisticModelCharacteristic');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'Evidence.statistic.modelCharacteristic', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Evidence.statistic.modelCharacteristic', 'value', value.valueElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.variableList.Count - 1 do
      ComposeEvidenceStatisticModelCharacteristicVariable(this, 'Evidence.statistic.modelCharacteristic', 'variable', value.variableList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.attributeEstimateList.Count - 1 do
      ComposeEvidenceStatisticAttributeEstimate(this, 'Evidence.statistic.modelCharacteristic', 'attributeEstimate', value.attributeEstimateList[i], false, i);
end;

function TFHIRTurtleParser.ParseEvidenceStatisticModelCharacteristicVariable(obj : TTurtleComplex) : TFhirEvidenceStatisticModelCharacteristicVariable;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEvidenceStatisticModelCharacteristicVariable.create;
  try
    ParseEvidenceStatisticModelCharacteristicVariableProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEvidenceStatisticModelCharacteristicVariableProperties(obj : TTurtleComplex; value : TFhirEvidenceStatisticModelCharacteristicVariable);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.variableDefinition := ParseReference(obj.complex('http://hl7.org/fhir/Evidence.statistic.modelCharacteristic.variable.variableDefinition'));
    value.handlingElement := ParseEnum(obj.complex('http://hl7.org/fhir/Evidence.statistic.modelCharacteristic.variable.handling'), CODES_TFhirEvidenceVariableHandlingEnum, SYSTEMS_TFhirEvidenceVariableHandlingEnum);
    for item in obj.complexes('http://hl7.org/fhir/Evidence.statistic.modelCharacteristic.variable.valueCategory') do
      value.valueCategoryList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.statistic.modelCharacteristic.variable.valueQuantity') do
      value.valueQuantityList.Add(parseQuantity(item));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.statistic.modelCharacteristic.variable.valueRange') do
      value.valueRangeList.Add(parseRange(item));
end;

procedure TFHIRTurtleComposer.ComposeEvidenceStatisticModelCharacteristicVariable(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceStatisticModelCharacteristicVariable; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EvidenceStatisticModelCharacteristicVariable');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeReference(this, 'Evidence.statistic.modelCharacteristic.variable', 'variableDefinition', value.variableDefinitionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Evidence.statistic.modelCharacteristic.variable', 'handling', value.handlingElement, CODES_TFhirEvidenceVariableHandlingEnum, SYSTEMS_TFhirEvidenceVariableHandlingEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.valueCategoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Evidence.statistic.modelCharacteristic.variable', 'valueCategory', value.valueCategoryList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.valueQuantityList.Count - 1 do
      ComposeQuantity(this, 'Evidence.statistic.modelCharacteristic.variable', 'valueQuantity', value.valueQuantityList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.valueRangeList.Count - 1 do
      ComposeRange(this, 'Evidence.statistic.modelCharacteristic.variable', 'valueRange', value.valueRangeList[i], false, i);
end;

function TFHIRTurtleParser.ParseEvidenceCertainty(obj : TTurtleComplex) : TFhirEvidenceCertainty;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEvidenceCertainty.create;
  try
    ParseEvidenceCertaintyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEvidenceCertaintyProperties(obj : TTurtleComplex; value : TFhirEvidenceCertainty);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Evidence.certainty.description'));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.certainty.note') do
      value.noteList.Add(parseAnnotation(item));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Evidence.certainty.type'));
    value.rating := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Evidence.certainty.rating'));
    value.raterElement := ParseString(obj.complex('http://hl7.org/fhir/Evidence.certainty.rater'));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.certainty.subcomponent') do
      value.subcomponentList.Add(parseEvidenceCertainty(item));
end;

procedure TFHIRTurtleComposer.ComposeEvidenceCertainty(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceCertainty; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EvidenceCertainty');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Evidence.certainty', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'Evidence.certainty', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Evidence.certainty', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Evidence.certainty', 'rating', value.ratingElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Evidence.certainty', 'rater', value.raterElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subcomponentList.Count - 1 do
      ComposeEvidenceCertainty(this, 'Evidence.certainty', 'subcomponent', value.subcomponentList[i], false, i);
end;

function TFHIRTurtleParser.ParseEvidence(obj : TTurtleComplex) : TFhirEvidence;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEvidence.create;
  try
    ParseEvidenceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEvidenceProperties(obj : TTurtleComplex; value : TFhirEvidence);
var
  item : TTurtleComplex;
begin
    ParseMetadataResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Evidence.url'));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Evidence.version'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Evidence.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Evidence.title'));
    if obj.has('citeAsReference', item) {a3} then
      value.citeAs := ParseReference(item);
    if obj.has('citeAsMarkdown', item) then
      value.citeAs := parseMarkdown(item);
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Evidence.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Evidence.experimental'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Evidence.date'));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    value.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Evidence.approvalDate'));
    value.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Evidence.lastReviewDate'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/Evidence.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.contact') do
      value.contactList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.author') do
      value.authorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.editor') do
      value.editorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.reviewer') do
      value.reviewerList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.endorser') do
      value.endorserList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.relatedArtifact') do
      value.relatedArtifactList.Add(parseRelatedArtifact(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Evidence.description'));
    value.assertionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Evidence.assertion'));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.variableDefinition') do
      value.variableDefinitionList.Add(parseEvidenceVariableDefinition(item));
    value.synthesisType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Evidence.synthesisType'));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.studyDesign') do
      value.studyDesignList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.statistic') do
      value.statisticList.Add(parseEvidenceStatistic(item));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.certainty') do
      value.certaintyList.Add(parseEvidenceCertainty(item));
end;

procedure TFHIRTurtleComposer.ComposeEvidence(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidence; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Evidence');
  end;
  composeMetadataResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'Evidence', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Evidence', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Evidence', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Evidence', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Evidence', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.citeAs is TFhirReference) {2} then
    ComposeReference(this, 'Evidence', 'citeAsReference', TFhirReference(value.citeAs), false,-1)
  else if (SummaryOption in [soFull, soData]) and (value.citeAs is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'Evidence', 'citeAsMarkdown', TFhirMarkdown(value.citeAs), false, -1);
  ComposeEnum(this, 'Evidence', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Evidence', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Evidence', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'Evidence', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'Evidence', 'approvalDate', value.approvalDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'Evidence', 'lastReviewDate', value.lastReviewDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Evidence', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'Evidence', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(this, 'Evidence', 'author', value.authorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(this, 'Evidence', 'editor', value.editorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(this, 'Evidence', 'reviewer', value.reviewerList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(this, 'Evidence', 'endorser', value.endorserList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'Evidence', 'relatedArtifact', value.relatedArtifactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'Evidence', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'Evidence', 'assertion', value.assertionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'Evidence', 'note', value.noteList[i], false, i);
  for i := 0 to value.variableDefinitionList.Count - 1 do
      ComposeEvidenceVariableDefinition(this, 'Evidence', 'variableDefinition', value.variableDefinitionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Evidence', 'synthesisType', value.synthesisTypeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.studyDesignList.Count - 1 do
      ComposeCodeableConcept(this, 'Evidence', 'studyDesign', value.studyDesignList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.statisticList.Count - 1 do
      ComposeEvidenceStatistic(this, 'Evidence', 'statistic', value.statisticList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.certaintyList.Count - 1 do
      ComposeEvidenceCertainty(this, 'Evidence', 'certainty', value.certaintyList[i], false, i);
end;

{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEREPORT}
function TFHIRTurtleParser.ParseEvidenceReportSubject(obj : TTurtleComplex) : TFhirEvidenceReportSubject;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEvidenceReportSubject.create;
  try
    ParseEvidenceReportSubjectProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEvidenceReportSubjectProperties(obj : TTurtleComplex; value : TFhirEvidenceReportSubject);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/EvidenceReport.subject.characteristic') do
      value.characteristicList.Add(parseEvidenceReportSubjectCharacteristic(item));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceReport.subject.note') do
      value.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeEvidenceReportSubject(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceReportSubject; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EvidenceReportSubject');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.characteristicList.Count - 1 do
      ComposeEvidenceReportSubjectCharacteristic(this, 'EvidenceReport.subject', 'characteristic', value.characteristicList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'EvidenceReport.subject', 'note', value.noteList[i], false, i);
end;

function TFHIRTurtleParser.ParseEvidenceReportSubjectCharacteristic(obj : TTurtleComplex) : TFhirEvidenceReportSubjectCharacteristic;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEvidenceReportSubjectCharacteristic.create;
  try
    ParseEvidenceReportSubjectCharacteristicProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEvidenceReportSubjectCharacteristicProperties(obj : TTurtleComplex; value : TFhirEvidenceReportSubjectCharacteristic);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EvidenceReport.subject.characteristic.code'));
    if obj.has('valueReference', item) {a3} then
      value.value := ParseReference(item);
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueRange', item) then
      value.value := parseRange(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    value.excludeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/EvidenceReport.subject.characteristic.exclude'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/EvidenceReport.subject.characteristic.period'));
end;

procedure TFHIRTurtleComposer.ComposeEvidenceReportSubjectCharacteristic(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceReportSubjectCharacteristic; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EvidenceReportSubjectCharacteristic');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'EvidenceReport.subject.characteristic', 'code', value.codeElement, false, -1);
  if (value.value is TFhirReference) {2} then
    ComposeReference(this, 'EvidenceReport.subject.characteristic', 'valueReference', TFhirReference(value.value), false,-1)
  else if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'EvidenceReport.subject.characteristic', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'EvidenceReport.subject.characteristic', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (value.value is TFhirRange) {6} then
    ComposeRange(this, 'EvidenceReport.subject.characteristic', 'valueRange', TFhirRange(value.value), false, -1)
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'EvidenceReport.subject.characteristic', 'valueBoolean', TFhirBoolean(value.value), false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'EvidenceReport.subject.characteristic', 'exclude', value.excludeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'EvidenceReport.subject.characteristic', 'period', value.periodElement, false, -1);
end;

function TFHIRTurtleParser.ParseEvidenceReportRelatesTo(obj : TTurtleComplex) : TFhirEvidenceReportRelatesTo;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEvidenceReportRelatesTo.create;
  try
    ParseEvidenceReportRelatesToProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEvidenceReportRelatesToProperties(obj : TTurtleComplex; value : TFhirEvidenceReportRelatesTo);
begin
    ParseBackboneElementProperties(obj, value);
    value.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/EvidenceReport.relatesTo.code'), CODES_TFhirReportRelationshipTypeEnum, SYSTEMS_TFhirReportRelationshipTypeEnum);
    value.target := ParseEvidenceReportRelatesToTarget(obj.complex('http://hl7.org/fhir/EvidenceReport.relatesTo.target'));
end;

procedure TFHIRTurtleComposer.ComposeEvidenceReportRelatesTo(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceReportRelatesTo; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EvidenceReportRelatesTo');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'EvidenceReport.relatesTo', 'code', value.codeElement, CODES_TFhirReportRelationshipTypeEnum, SYSTEMS_TFhirReportRelationshipTypeEnum, false, -1);
  ComposeEvidenceReportRelatesToTarget(this, 'EvidenceReport.relatesTo', 'target', value.targetElement, false, -1);
end;

function TFHIRTurtleParser.ParseEvidenceReportRelatesToTarget(obj : TTurtleComplex) : TFhirEvidenceReportRelatesToTarget;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEvidenceReportRelatesToTarget.create;
  try
    ParseEvidenceReportRelatesToTargetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEvidenceReportRelatesToTargetProperties(obj : TTurtleComplex; value : TFhirEvidenceReportRelatesToTarget);
begin
    ParseBackboneElementProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/EvidenceReport.relatesTo.target.url'));
    value.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/EvidenceReport.relatesTo.target.identifier'));
    value.displayElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/EvidenceReport.relatesTo.target.display'));
    value.resource := ParseReference(obj.complex('http://hl7.org/fhir/EvidenceReport.relatesTo.target.resource'));
end;

procedure TFHIRTurtleComposer.ComposeEvidenceReportRelatesToTarget(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceReportRelatesToTarget; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EvidenceReportRelatesToTarget');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'EvidenceReport.relatesTo.target', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'EvidenceReport.relatesTo.target', 'identifier', value.identifierElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'EvidenceReport.relatesTo.target', 'display', value.displayElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'EvidenceReport.relatesTo.target', 'resource', value.resourceElement, false, -1);
end;

function TFHIRTurtleParser.ParseEvidenceReportSection(obj : TTurtleComplex) : TFhirEvidenceReportSection;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEvidenceReportSection.create;
  try
    ParseEvidenceReportSectionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEvidenceReportSectionProperties(obj : TTurtleComplex; value : TFhirEvidenceReportSection);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/EvidenceReport.section.title'));
    value.focus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EvidenceReport.section.focus'));
    value.focusReference := ParseReference(obj.complex('http://hl7.org/fhir/EvidenceReport.section.focusReference'));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceReport.section.author') do
      value.authorList.Add(parseReference(item));
    value.text := ParseNarrative(obj.complex('http://hl7.org/fhir/EvidenceReport.section.text'));
    value.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/EvidenceReport.section.mode'), CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum);
    value.orderedBy := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EvidenceReport.section.orderedBy'));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceReport.section.entryClassifier') do
      value.entryClassifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceReport.section.entryReference') do
      value.entryReferenceList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceReport.section.entryQuantity') do
      value.entryQuantityList.Add(parseQuantity(item));
    value.emptyReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EvidenceReport.section.emptyReason'));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceReport.section.section') do
      value.sectionList.Add(parseEvidenceReportSection(item));
end;

procedure TFHIRTurtleComposer.ComposeEvidenceReportSection(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceReportSection; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EvidenceReportSection');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'EvidenceReport.section', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'EvidenceReport.section', 'focus', value.focusElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'EvidenceReport.section', 'focusReference', value.focusReferenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeReference(this, 'EvidenceReport.section', 'author', value.authorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeNarrative(this, 'EvidenceReport.section', 'text', value.textElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'EvidenceReport.section', 'mode', value.modeElement, CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'EvidenceReport.section', 'orderedBy', value.orderedByElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.entryClassifierList.Count - 1 do
      ComposeCodeableConcept(this, 'EvidenceReport.section', 'entryClassifier', value.entryClassifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.entryReferenceList.Count - 1 do
      ComposeReference(this, 'EvidenceReport.section', 'entryReference', value.entryReferenceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.entryQuantityList.Count - 1 do
      ComposeQuantity(this, 'EvidenceReport.section', 'entryQuantity', value.entryQuantityList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'EvidenceReport.section', 'emptyReason', value.emptyReasonElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.sectionList.Count - 1 do
      ComposeEvidenceReportSection(this, 'EvidenceReport.section', 'section', value.sectionList[i], false, i);
end;

function TFHIRTurtleParser.ParseEvidenceReport(obj : TTurtleComplex) : TFhirEvidenceReport;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEvidenceReport.create;
  try
    ParseEvidenceReportProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEvidenceReportProperties(obj : TTurtleComplex; value : TFhirEvidenceReport);
var
  item : TTurtleComplex;
begin
    ParseMetadataResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/EvidenceReport.url'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/EvidenceReport.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/EvidenceReport.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceReport.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceReport.relatedIdentifier') do
      value.relatedIdentifierList.Add(parseIdentifier(item));
    if obj.has('citeAsReference', item) {a3} then
      value.citeAs := ParseReference(item);
    if obj.has('citeAsMarkdown', item) then
      value.citeAs := parseMarkdown(item);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EvidenceReport.type'));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceReport.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceReport.relatedArtifact') do
      value.relatedArtifactList.Add(parseRelatedArtifact(item));
    value.subject := ParseEvidenceReportSubject(obj.complex('http://hl7.org/fhir/EvidenceReport.subject'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/EvidenceReport.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceReport.contact') do
      value.contactList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceReport.author') do
      value.authorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceReport.editor') do
      value.editorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceReport.reviewer') do
      value.reviewerList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceReport.endorser') do
      value.endorserList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceReport.relatesTo') do
      value.relatesToList.Add(parseEvidenceReportRelatesTo(item));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceReport.section') do
      value.sectionList.Add(parseEvidenceReportSection(item));
end;

procedure TFHIRTurtleComposer.ComposeEvidenceReport(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceReport; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EvidenceReport');
  end;
  composeMetadataResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'EvidenceReport', 'url', value.urlElement, false, -1);
  ComposeEnum(this, 'EvidenceReport', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'EvidenceReport', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EvidenceReport', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.relatedIdentifierList.Count - 1 do
      ComposeIdentifier(this, 'EvidenceReport', 'relatedIdentifier', value.relatedIdentifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) and (value.citeAs is TFhirReference) {2} then
    ComposeReference(this, 'EvidenceReport', 'citeAsReference', TFhirReference(value.citeAs), false,-1)
  else if (SummaryOption in [soFull, soData]) and (value.citeAs is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'EvidenceReport', 'citeAsMarkdown', TFhirMarkdown(value.citeAs), false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'EvidenceReport', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'EvidenceReport', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'EvidenceReport', 'relatedArtifact', value.relatedArtifactList[i], false, i);
  ComposeEvidenceReportSubject(this, 'EvidenceReport', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'EvidenceReport', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'EvidenceReport', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(this, 'EvidenceReport', 'author', value.authorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(this, 'EvidenceReport', 'editor', value.editorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(this, 'EvidenceReport', 'reviewer', value.reviewerList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(this, 'EvidenceReport', 'endorser', value.endorserList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatesToList.Count - 1 do
      ComposeEvidenceReportRelatesTo(this, 'EvidenceReport', 'relatesTo', value.relatesToList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.sectionList.Count - 1 do
      ComposeEvidenceReportSection(this, 'EvidenceReport', 'section', value.sectionList[i], false, i);
end;

{$ENDIF FHIR_EVIDENCEREPORT}
{$IFDEF FHIR_EVIDENCEVARIABLE}
function TFHIRTurtleParser.ParseEvidenceVariableCharacteristic(obj : TTurtleComplex) : TFhirEvidenceVariableCharacteristic;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEvidenceVariableCharacteristic.create;
  try
    ParseEvidenceVariableCharacteristicProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEvidenceVariableCharacteristicProperties(obj : TTurtleComplex; value : TFhirEvidenceVariableCharacteristic);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.linkIdElement := ParseId(obj.complex('http://hl7.org/fhir/EvidenceVariable.characteristic.linkId'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/EvidenceVariable.characteristic.description'));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.characteristic.note') do
      value.noteList.Add(parseAnnotation(item));
    value.excludeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/EvidenceVariable.characteristic.exclude'));
    value.definitionReference := ParseReference(obj.complex('http://hl7.org/fhir/EvidenceVariable.characteristic.definitionReference'));
    value.definitionCanonicalElement := ParseCanonical(obj.complex('http://hl7.org/fhir/EvidenceVariable.characteristic.definitionCanonical'));
    value.definitionCodeableConcept := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EvidenceVariable.characteristic.definitionCodeableConcept'));
    value.definitionExpression := ParseExpression(obj.complex('http://hl7.org/fhir/EvidenceVariable.characteristic.definitionExpression'));
    value.definitionIdElement := ParseId(obj.complex('http://hl7.org/fhir/EvidenceVariable.characteristic.definitionId'));
    value.definitionByTypeAndValue := ParseEvidenceVariableCharacteristicDefinitionByTypeAndValue(obj.complex('http://hl7.org/fhir/EvidenceVariable.characteristic.definitionByTypeAndValue'));
    value.definitionByCombination := ParseEvidenceVariableCharacteristicDefinitionByCombination(obj.complex('http://hl7.org/fhir/EvidenceVariable.characteristic.definitionByCombination'));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.characteristic.timeFromEvent') do
      value.timeFromEventList.Add(parseEvidenceVariableCharacteristicTimeFromEvent(item));
end;

procedure TFHIRTurtleComposer.ComposeEvidenceVariableCharacteristic(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceVariableCharacteristic; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EvidenceVariableCharacteristic');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'EvidenceVariable.characteristic', 'linkId', value.linkIdElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'EvidenceVariable.characteristic', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'EvidenceVariable.characteristic', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'EvidenceVariable.characteristic', 'exclude', value.excludeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'EvidenceVariable.characteristic', 'definitionReference', value.definitionReferenceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(this, 'EvidenceVariable.characteristic', 'definitionCanonical', value.definitionCanonicalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'EvidenceVariable.characteristic', 'definitionCodeableConcept', value.definitionCodeableConceptElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeExpression(this, 'EvidenceVariable.characteristic', 'definitionExpression', value.definitionExpressionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'EvidenceVariable.characteristic', 'definitionId', value.definitionIdElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEvidenceVariableCharacteristicDefinitionByTypeAndValue(this, 'EvidenceVariable.characteristic', 'definitionByTypeAndValue', value.definitionByTypeAndValueElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEvidenceVariableCharacteristicDefinitionByCombination(this, 'EvidenceVariable.characteristic', 'definitionByCombination', value.definitionByCombinationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.timeFromEventList.Count - 1 do
      ComposeEvidenceVariableCharacteristicTimeFromEvent(this, 'EvidenceVariable.characteristic', 'timeFromEvent', value.timeFromEventList[i], false, i);
end;

function TFHIRTurtleParser.ParseEvidenceVariableCharacteristicDefinitionByTypeAndValue(obj : TTurtleComplex) : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.create;
  try
    ParseEvidenceVariableCharacteristicDefinitionByTypeAndValueProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEvidenceVariableCharacteristicDefinitionByTypeAndValueProperties(obj : TTurtleComplex; value : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EvidenceVariable.characteristic.definitionByTypeAndValue.type'));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.characteristic.definitionByTypeAndValue.method') do
      value.methodList.Add(parseCodeableConcept(item));
    value.device := ParseReference(obj.complex('http://hl7.org/fhir/EvidenceVariable.characteristic.definitionByTypeAndValue.device'));
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueRange', item) then
      value.value := parseRange(item);
    if obj.has('valueReference', item) then
      value.value := parseReference(item);
    if obj.has('valueId', item) then
      value.value := parseId(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    value.offset := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EvidenceVariable.characteristic.definitionByTypeAndValue.offset'));
end;

procedure TFHIRTurtleComposer.ComposeEvidenceVariableCharacteristicDefinitionByTypeAndValue(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EvidenceVariableCharacteristicDefinitionByTypeAndValue');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'EvidenceVariable.characteristic.definitionByTypeAndValue', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.methodList.Count - 1 do
      ComposeCodeableConcept(this, 'EvidenceVariable.characteristic.definitionByTypeAndValue', 'method', value.methodList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'EvidenceVariable.characteristic.definitionByTypeAndValue', 'device', value.deviceElement, false, -1);
  if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'EvidenceVariable.characteristic.definitionByTypeAndValue', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'EvidenceVariable.characteristic.definitionByTypeAndValue', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (value.value is TFhirRange) {6} then
    ComposeRange(this, 'EvidenceVariable.characteristic.definitionByTypeAndValue', 'valueRange', TFhirRange(value.value), false, -1)
  else if (value.value is TFhirReference) {6} then
    ComposeReference(this, 'EvidenceVariable.characteristic.definitionByTypeAndValue', 'valueReference', TFhirReference(value.value), false, -1)
  else if (value.value is TFhirId) {6} then
    ComposeId(this, 'EvidenceVariable.characteristic.definitionByTypeAndValue', 'valueId', TFhirId(value.value), false, -1)
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'EvidenceVariable.characteristic.definitionByTypeAndValue', 'valueBoolean', TFhirBoolean(value.value), false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'EvidenceVariable.characteristic.definitionByTypeAndValue', 'offset', value.offsetElement, false, -1);
end;

function TFHIRTurtleParser.ParseEvidenceVariableCharacteristicDefinitionByCombination(obj : TTurtleComplex) : TFhirEvidenceVariableCharacteristicDefinitionByCombination;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEvidenceVariableCharacteristicDefinitionByCombination.create;
  try
    ParseEvidenceVariableCharacteristicDefinitionByCombinationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEvidenceVariableCharacteristicDefinitionByCombinationProperties(obj : TTurtleComplex; value : TFhirEvidenceVariableCharacteristicDefinitionByCombination);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/EvidenceVariable.characteristic.definitionByCombination.code'), CODES_TFhirCharacteristicCombinationEnum, SYSTEMS_TFhirCharacteristicCombinationEnum);
    value.thresholdElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/EvidenceVariable.characteristic.definitionByCombination.threshold'));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.characteristic.definitionByCombination.characteristic') do
      value.characteristicList.Add(parseEvidenceVariableCharacteristic(item));
end;

procedure TFHIRTurtleComposer.ComposeEvidenceVariableCharacteristicDefinitionByCombination(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceVariableCharacteristicDefinitionByCombination; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EvidenceVariableCharacteristicDefinitionByCombination');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'EvidenceVariable.characteristic.definitionByCombination', 'code', value.codeElement, CODES_TFhirCharacteristicCombinationEnum, SYSTEMS_TFhirCharacteristicCombinationEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'EvidenceVariable.characteristic.definitionByCombination', 'threshold', value.thresholdElement, false, -1);
  for i := 0 to value.characteristicList.Count - 1 do
      ComposeEvidenceVariableCharacteristic(this, 'EvidenceVariable.characteristic.definitionByCombination', 'characteristic', value.characteristicList[i], false, i);
end;

function TFHIRTurtleParser.ParseEvidenceVariableCharacteristicTimeFromEvent(obj : TTurtleComplex) : TFhirEvidenceVariableCharacteristicTimeFromEvent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEvidenceVariableCharacteristicTimeFromEvent.create;
  try
    ParseEvidenceVariableCharacteristicTimeFromEventProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEvidenceVariableCharacteristicTimeFromEventProperties(obj : TTurtleComplex; value : TFhirEvidenceVariableCharacteristicTimeFromEvent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/EvidenceVariable.characteristic.timeFromEvent.description'));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.characteristic.timeFromEvent.note') do
      value.noteList.Add(parseAnnotation(item));
    if obj.has('eventCodeableConcept', item) then
      value.event := parseCodeableConcept(item);
    if obj.has('eventReference', item) then
      value.event := parseReference(item);
    if obj.has('eventId', item) then
      value.event := parseId(item);
    if obj.has('eventDateTime', item) then
      value.event := parseDateTime(item);
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/EvidenceVariable.characteristic.timeFromEvent.quantity'));
    value.range := ParseRange(obj.complex('http://hl7.org/fhir/EvidenceVariable.characteristic.timeFromEvent.range'));
end;

procedure TFHIRTurtleComposer.ComposeEvidenceVariableCharacteristicTimeFromEvent(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceVariableCharacteristicTimeFromEvent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EvidenceVariableCharacteristicTimeFromEvent');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'EvidenceVariable.characteristic.timeFromEvent', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'EvidenceVariable.characteristic.timeFromEvent', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) and (value.event is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'EvidenceVariable.characteristic.timeFromEvent', 'eventCodeableConcept', TFhirCodeableConcept(value.event), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.event is TFhirReference) {6} then
    ComposeReference(this, 'EvidenceVariable.characteristic.timeFromEvent', 'eventReference', TFhirReference(value.event), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.event is TFhirId) {6} then
    ComposeId(this, 'EvidenceVariable.characteristic.timeFromEvent', 'eventId', TFhirId(value.event), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.event is TFhirDateTime) {6} then
    ComposeDateTime(this, 'EvidenceVariable.characteristic.timeFromEvent', 'eventDateTime', TFhirDateTime(value.event), false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'EvidenceVariable.characteristic.timeFromEvent', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(this, 'EvidenceVariable.characteristic.timeFromEvent', 'range', value.rangeElement, false, -1);
end;

function TFHIRTurtleParser.ParseEvidenceVariableCategory(obj : TTurtleComplex) : TFhirEvidenceVariableCategory;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEvidenceVariableCategory.create;
  try
    ParseEvidenceVariableCategoryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEvidenceVariableCategoryProperties(obj : TTurtleComplex; value : TFhirEvidenceVariableCategory);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/EvidenceVariable.category.name'));
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueRange', item) then
      value.value := parseRange(item);
end;

procedure TFHIRTurtleComposer.ComposeEvidenceVariableCategory(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceVariableCategory; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EvidenceVariableCategory');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'EvidenceVariable.category', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'EvidenceVariable.category', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'EvidenceVariable.category', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirRange) {6} then
    ComposeRange(this, 'EvidenceVariable.category', 'valueRange', TFhirRange(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseEvidenceVariable(obj : TTurtleComplex) : TFhirEvidenceVariable;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEvidenceVariable.create;
  try
    ParseEvidenceVariableProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEvidenceVariableProperties(obj : TTurtleComplex; value : TFhirEvidenceVariable);
var
  item : TTurtleComplex;
begin
    ParseMetadataResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/EvidenceVariable.url'));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/EvidenceVariable.version'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/EvidenceVariable.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/EvidenceVariable.title'));
    value.shortTitleElement := ParseString(obj.complex('http://hl7.org/fhir/EvidenceVariable.shortTitle'));
    value.subtitleElement := ParseString(obj.complex('http://hl7.org/fhir/EvidenceVariable.subtitle'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/EvidenceVariable.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/EvidenceVariable.experimental'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/EvidenceVariable.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/EvidenceVariable.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/EvidenceVariable.description'));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/EvidenceVariable.copyright'));
    value.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/EvidenceVariable.approvalDate'));
    value.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/EvidenceVariable.lastReviewDate'));
    value.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/EvidenceVariable.effectivePeriod'));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.author') do
      value.authorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.editor') do
      value.editorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.reviewer') do
      value.reviewerList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.endorser') do
      value.endorserList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.relatedArtifact') do
      value.relatedArtifactList.Add(parseRelatedArtifact(item));
    value.actualElement := ParseBoolean(obj.complex('http://hl7.org/fhir/EvidenceVariable.actual'));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.characteristic') do
      value.characteristicList.Add(parseEvidenceVariableCharacteristic(item));
    value.handlingElement := ParseEnum(obj.complex('http://hl7.org/fhir/EvidenceVariable.handling'), CODES_TFhirEvidenceVariableHandlingEnum, SYSTEMS_TFhirEvidenceVariableHandlingEnum);
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.category') do
      value.categoryList.Add(parseEvidenceVariableCategory(item));
end;

procedure TFHIRTurtleComposer.ComposeEvidenceVariable(parent :  TTurtleComplex; parentType, name : String; value : TFhirEvidenceVariable; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EvidenceVariable');
  end;
  composeMetadataResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'EvidenceVariable', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EvidenceVariable', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'EvidenceVariable', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'EvidenceVariable', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'EvidenceVariable', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'EvidenceVariable', 'shortTitle', value.shortTitleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'EvidenceVariable', 'subtitle', value.subtitleElement, false, -1);
  ComposeEnum(this, 'EvidenceVariable', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'EvidenceVariable', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'EvidenceVariable', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'EvidenceVariable', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'EvidenceVariable', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'EvidenceVariable', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'EvidenceVariable', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'EvidenceVariable', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'EvidenceVariable', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'EvidenceVariable', 'approvalDate', value.approvalDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'EvidenceVariable', 'lastReviewDate', value.lastReviewDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'EvidenceVariable', 'effectivePeriod', value.effectivePeriodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(this, 'EvidenceVariable', 'author', value.authorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(this, 'EvidenceVariable', 'editor', value.editorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(this, 'EvidenceVariable', 'reviewer', value.reviewerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(this, 'EvidenceVariable', 'endorser', value.endorserList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'EvidenceVariable', 'relatedArtifact', value.relatedArtifactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'EvidenceVariable', 'actual', value.actualElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.characteristicList.Count - 1 do
      ComposeEvidenceVariableCharacteristic(this, 'EvidenceVariable', 'characteristic', value.characteristicList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'EvidenceVariable', 'handling', value.handlingElement, CODES_TFhirEvidenceVariableHandlingEnum, SYSTEMS_TFhirEvidenceVariableHandlingEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeEvidenceVariableCategory(this, 'EvidenceVariable', 'category', value.categoryList[i], false, i);
end;

{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_EXAMPLESCENARIO}
function TFHIRTurtleParser.ParseExampleScenarioActor(obj : TTurtleComplex) : TFhirExampleScenarioActor;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExampleScenarioActor.create;
  try
    ParseExampleScenarioActorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExampleScenarioActorProperties(obj : TTurtleComplex; value : TFhirExampleScenarioActor);
begin
    ParseBackboneElementProperties(obj, value);
    value.keyElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.actor.key'));
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ExampleScenario.actor.type'), CODES_TFhirExampleScenarioActorTypeEnum, SYSTEMS_TFhirExampleScenarioActorTypeEnum);
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.actor.title'));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ExampleScenario.actor.description'));
end;

procedure TFHIRTurtleComposer.ComposeExampleScenarioActor(parent :  TTurtleComplex; parentType, name : String; value : TFhirExampleScenarioActor; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExampleScenarioActor');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'ExampleScenario.actor', 'key', value.keyElement, false, -1);
  ComposeEnum(this, 'ExampleScenario.actor', 'type', value.type_Element, CODES_TFhirExampleScenarioActorTypeEnum, SYSTEMS_TFhirExampleScenarioActorTypeEnum, false, -1);
  ComposeString(this, 'ExampleScenario.actor', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ExampleScenario.actor', 'description', value.descriptionElement, false, -1);
end;

function TFHIRTurtleParser.ParseExampleScenarioInstance(obj : TTurtleComplex) : TFhirExampleScenarioInstance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExampleScenarioInstance.create;
  try
    ParseExampleScenarioInstanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExampleScenarioInstanceProperties(obj : TTurtleComplex; value : TFhirExampleScenarioInstance);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.keyElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.instance.key'));
    value.structureType := ParseCoding(obj.complex('http://hl7.org/fhir/ExampleScenario.instance.structureType'));
    value.structureVersionElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.instance.structureVersion'));
    if obj.has('structureProfileCanonical', item) then
      value.structureProfile := parseCanonical(item);
    if obj.has('structureProfileUri', item) then
      value.structureProfile := parseUri(item);
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.instance.title'));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ExampleScenario.instance.description'));
    value.content := ParseReference(obj.complex('http://hl7.org/fhir/ExampleScenario.instance.content'));
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.instance.version') do
      value.versionList.Add(parseExampleScenarioInstanceVersion(item));
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.instance.containedInstance') do
      value.containedInstanceList.Add(parseExampleScenarioInstanceContainedInstance(item));
end;

procedure TFHIRTurtleComposer.ComposeExampleScenarioInstance(parent :  TTurtleComplex; parentType, name : String; value : TFhirExampleScenarioInstance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExampleScenarioInstance');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'ExampleScenario.instance', 'key', value.keyElement, false, -1);
  ComposeCoding(this, 'ExampleScenario.instance', 'structureType', value.structureTypeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ExampleScenario.instance', 'structureVersion', value.structureVersionElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.structureProfile is TFhirCanonical) {6} then
    ComposeCanonical(this, 'ExampleScenario.instance', 'structureProfileCanonical', TFhirCanonical(value.structureProfile), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.structureProfile is TFhirUri) {6} then
    ComposeUri(this, 'ExampleScenario.instance', 'structureProfileUri', TFhirUri(value.structureProfile), false, -1);
  ComposeString(this, 'ExampleScenario.instance', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ExampleScenario.instance', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ExampleScenario.instance', 'content', value.contentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.versionList.Count - 1 do
      ComposeExampleScenarioInstanceVersion(this, 'ExampleScenario.instance', 'version', value.versionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.containedInstanceList.Count - 1 do
      ComposeExampleScenarioInstanceContainedInstance(this, 'ExampleScenario.instance', 'containedInstance', value.containedInstanceList[i], false, i);
end;

function TFHIRTurtleParser.ParseExampleScenarioInstanceVersion(obj : TTurtleComplex) : TFhirExampleScenarioInstanceVersion;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExampleScenarioInstanceVersion.create;
  try
    ParseExampleScenarioInstanceVersionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExampleScenarioInstanceVersionProperties(obj : TTurtleComplex; value : TFhirExampleScenarioInstanceVersion);
begin
    ParseBackboneElementProperties(obj, value);
    value.keyElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.instance.version.key'));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ExampleScenario.instance.version.description'));
    value.content := ParseReference(obj.complex('http://hl7.org/fhir/ExampleScenario.instance.version.content'));
end;

procedure TFHIRTurtleComposer.ComposeExampleScenarioInstanceVersion(parent :  TTurtleComplex; parentType, name : String; value : TFhirExampleScenarioInstanceVersion; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExampleScenarioInstanceVersion');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'ExampleScenario.instance.version', 'key', value.keyElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ExampleScenario.instance.version', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ExampleScenario.instance.version', 'content', value.contentElement, false, -1);
end;

function TFHIRTurtleParser.ParseExampleScenarioInstanceContainedInstance(obj : TTurtleComplex) : TFhirExampleScenarioInstanceContainedInstance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExampleScenarioInstanceContainedInstance.create;
  try
    ParseExampleScenarioInstanceContainedInstanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExampleScenarioInstanceContainedInstanceProperties(obj : TTurtleComplex; value : TFhirExampleScenarioInstanceContainedInstance);
begin
    ParseBackboneElementProperties(obj, value);
    value.instanceReferenceElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.instance.containedInstance.instanceReference'));
    value.versionReferenceElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.instance.containedInstance.versionReference'));
end;

procedure TFHIRTurtleComposer.ComposeExampleScenarioInstanceContainedInstance(parent :  TTurtleComplex; parentType, name : String; value : TFhirExampleScenarioInstanceContainedInstance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExampleScenarioInstanceContainedInstance');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'ExampleScenario.instance.containedInstance', 'instanceReference', value.instanceReferenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ExampleScenario.instance.containedInstance', 'versionReference', value.versionReferenceElement, false, -1);
end;

function TFHIRTurtleParser.ParseExampleScenarioProcess(obj : TTurtleComplex) : TFhirExampleScenarioProcess;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExampleScenarioProcess.create;
  try
    ParseExampleScenarioProcessProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExampleScenarioProcessProperties(obj : TTurtleComplex; value : TFhirExampleScenarioProcess);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.process.title'));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ExampleScenario.process.description'));
    value.preConditionsElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ExampleScenario.process.preConditions'));
    value.postConditionsElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ExampleScenario.process.postConditions'));
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.process.step') do
      value.stepList.Add(parseExampleScenarioProcessStep(item));
end;

procedure TFHIRTurtleComposer.ComposeExampleScenarioProcess(parent :  TTurtleComplex; parentType, name : String; value : TFhirExampleScenarioProcess; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExampleScenarioProcess');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'ExampleScenario.process', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ExampleScenario.process', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ExampleScenario.process', 'preConditions', value.preConditionsElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ExampleScenario.process', 'postConditions', value.postConditionsElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.stepList.Count - 1 do
      ComposeExampleScenarioProcessStep(this, 'ExampleScenario.process', 'step', value.stepList[i], false, i);
end;

function TFHIRTurtleParser.ParseExampleScenarioProcessStep(obj : TTurtleComplex) : TFhirExampleScenarioProcessStep;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExampleScenarioProcessStep.create;
  try
    ParseExampleScenarioProcessStepProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExampleScenarioProcessStepProperties(obj : TTurtleComplex; value : TFhirExampleScenarioProcessStep);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.numberElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.number'));
    value.process := ParseExampleScenarioProcess(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.process'));
    value.workflowElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.workflow'));
    value.operation := ParseExampleScenarioProcessStepOperation(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.operation'));
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.process.step.alternative') do
      value.alternativeList.Add(parseExampleScenarioProcessStepAlternative(item));
    value.pauseElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.pause'));
end;

procedure TFHIRTurtleComposer.ComposeExampleScenarioProcessStep(parent :  TTurtleComplex; parentType, name : String; value : TFhirExampleScenarioProcessStep; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExampleScenarioProcessStep');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ExampleScenario.process.step', 'number', value.numberElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeExampleScenarioProcess(this, 'ExampleScenario.process.step', 'process', value.processElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'ExampleScenario.process.step', 'workflow', value.workflowElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeExampleScenarioProcessStepOperation(this, 'ExampleScenario.process.step', 'operation', value.operationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.alternativeList.Count - 1 do
      ComposeExampleScenarioProcessStepAlternative(this, 'ExampleScenario.process.step', 'alternative', value.alternativeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ExampleScenario.process.step', 'pause', value.pauseElement, false, -1);
end;

function TFHIRTurtleParser.ParseExampleScenarioProcessStepOperation(obj : TTurtleComplex) : TFhirExampleScenarioProcessStepOperation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExampleScenarioProcessStepOperation.create;
  try
    ParseExampleScenarioProcessStepOperationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExampleScenarioProcessStepOperationProperties(obj : TTurtleComplex; value : TFhirExampleScenarioProcessStepOperation);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.operation.type'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.operation.title'));
    value.initiatorElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.operation.initiator'));
    value.receiverElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.operation.receiver'));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.operation.description'));
    value.initiatorActiveElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.operation.initiatorActive'));
    value.receiverActiveElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.operation.receiverActive'));
    value.request := ParseExampleScenarioInstanceContainedInstance(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.operation.request'));
    value.response := ParseExampleScenarioInstanceContainedInstance(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.operation.response'));
end;

procedure TFHIRTurtleComposer.ComposeExampleScenarioProcessStepOperation(parent :  TTurtleComplex; parentType, name : String; value : TFhirExampleScenarioProcessStepOperation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExampleScenarioProcessStepOperation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'ExampleScenario.process.step.operation', 'type', value.type_Element, false, -1);
  ComposeString(this, 'ExampleScenario.process.step.operation', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ExampleScenario.process.step.operation', 'initiator', value.initiatorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ExampleScenario.process.step.operation', 'receiver', value.receiverElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ExampleScenario.process.step.operation', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ExampleScenario.process.step.operation', 'initiatorActive', value.initiatorActiveElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ExampleScenario.process.step.operation', 'receiverActive', value.receiverActiveElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeExampleScenarioInstanceContainedInstance(this, 'ExampleScenario.process.step.operation', 'request', value.requestElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeExampleScenarioInstanceContainedInstance(this, 'ExampleScenario.process.step.operation', 'response', value.responseElement, false, -1);
end;

function TFHIRTurtleParser.ParseExampleScenarioProcessStepAlternative(obj : TTurtleComplex) : TFhirExampleScenarioProcessStepAlternative;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExampleScenarioProcessStepAlternative.create;
  try
    ParseExampleScenarioProcessStepAlternativeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExampleScenarioProcessStepAlternativeProperties(obj : TTurtleComplex; value : TFhirExampleScenarioProcessStepAlternative);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.alternative.title'));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.alternative.description'));
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.process.step.alternative.step') do
      value.stepList.Add(parseExampleScenarioProcessStep(item));
end;

procedure TFHIRTurtleComposer.ComposeExampleScenarioProcessStepAlternative(parent :  TTurtleComplex; parentType, name : String; value : TFhirExampleScenarioProcessStepAlternative; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExampleScenarioProcessStepAlternative');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'ExampleScenario.process.step.alternative', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ExampleScenario.process.step.alternative', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.stepList.Count - 1 do
      ComposeExampleScenarioProcessStep(this, 'ExampleScenario.process.step.alternative', 'step', value.stepList[i], false, i);
end;

function TFHIRTurtleParser.ParseExampleScenario(obj : TTurtleComplex) : TFhirExampleScenario;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExampleScenario.create;
  try
    ParseExampleScenarioProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExampleScenarioProperties(obj : TTurtleComplex; value : TFhirExampleScenario);
var
  item : TTurtleComplex;
begin
    ParseCanonicalResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ExampleScenario.url'));
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.version'));
    if obj.has('versionAlgorithmCoding', item) then
      value.versionAlgorithm := parseCoding(item);
    if obj.has('versionAlgorithmString', item) then
      value.versionAlgorithm := parseString(item);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.title'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ExampleScenario.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ExampleScenario.experimental'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ExampleScenario.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ExampleScenario.description'));
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ExampleScenario.purpose'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ExampleScenario.copyright'));
    value.copyrightLabelElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.copyrightLabel'));
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.actor') do
      value.actorList.Add(parseExampleScenarioActor(item));
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.instance') do
      value.instanceList.Add(parseExampleScenarioInstance(item));
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.process') do
      value.processList.Add(parseExampleScenarioProcess(item));
end;

procedure TFHIRTurtleComposer.ComposeExampleScenario(parent :  TTurtleComplex; parentType, name : String; value : TFhirExampleScenario; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExampleScenario');
  end;
  composeCanonicalResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ExampleScenario', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ExampleScenario', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ExampleScenario', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirCoding) {6} then
    ComposeCoding(this, 'ExampleScenario', 'versionAlgorithmCoding', TFhirCoding(value.versionAlgorithm), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirString) {6} then
    ComposeString(this, 'ExampleScenario', 'versionAlgorithmString', TFhirString(value.versionAlgorithm), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ExampleScenario', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ExampleScenario', 'title', value.titleElement, false, -1);
  ComposeEnum(this, 'ExampleScenario', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ExampleScenario', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ExampleScenario', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ExampleScenario', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'ExampleScenario', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'ExampleScenario', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'ExampleScenario', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'ExampleScenario', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ExampleScenario', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ExampleScenario', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ExampleScenario', 'copyrightLabel', value.copyrightLabelElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.actorList.Count - 1 do
      ComposeExampleScenarioActor(this, 'ExampleScenario', 'actor', value.actorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.instanceList.Count - 1 do
      ComposeExampleScenarioInstance(this, 'ExampleScenario', 'instance', value.instanceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.processList.Count - 1 do
      ComposeExampleScenarioProcess(this, 'ExampleScenario', 'process', value.processList[i], false, i);
end;

{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
function TFHIRTurtleParser.ParseExplanationOfBenefitRelated(obj : TTurtleComplex) : TFhirExplanationOfBenefitRelated;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitRelated.create;
  try
    ParseExplanationOfBenefitRelatedProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitRelatedProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitRelated);
begin
    ParseBackboneElementProperties(obj, value);
    value.claim := ParseReference(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.related.claim'));
    value.relationship := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.related.relationship'));
    value.reference := ParseIdentifier(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.related.reference'));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitRelated(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitRelated; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitRelated');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ExplanationOfBenefit.related', 'claim', value.claimElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.related', 'relationship', value.relationshipElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'ExplanationOfBenefit.related', 'reference', value.referenceElement, false, -1);
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitPayee(obj : TTurtleComplex) : TFhirExplanationOfBenefitPayee;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitPayee.create;
  try
    ParseExplanationOfBenefitPayeeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitPayeeProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitPayee);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payee.type'));
    value.party := ParseReference(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payee.party'));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitPayee(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitPayee; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitPayee');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.payee', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ExplanationOfBenefit.payee', 'party', value.partyElement, false, -1);
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitCareTeam(obj : TTurtleComplex) : TFhirExplanationOfBenefitCareTeam;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitCareTeam.create;
  try
    ParseExplanationOfBenefitCareTeamProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitCareTeamProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitCareTeam);
begin
    ParseBackboneElementProperties(obj, value);
    value.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.careTeam.sequence'));
    value.provider := ParseReference(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.careTeam.provider'));
    value.responsibleElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.careTeam.responsible'));
    value.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.careTeam.role'));
    value.specialty := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.careTeam.specialty'));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitCareTeam(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitCareTeam; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitCareTeam');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposePositiveInt(this, 'ExplanationOfBenefit.careTeam', 'sequence', value.sequenceElement, false, -1);
  ComposeReference(this, 'ExplanationOfBenefit.careTeam', 'provider', value.providerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ExplanationOfBenefit.careTeam', 'responsible', value.responsibleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.careTeam', 'role', value.roleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.careTeam', 'specialty', value.specialtyElement, false, -1);
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitSupportingInfo(obj : TTurtleComplex) : TFhirExplanationOfBenefitSupportingInfo;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitSupportingInfo.create;
  try
    ParseExplanationOfBenefitSupportingInfoProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitSupportingInfoProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitSupportingInfo);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.supportingInfo.sequence'));
    value.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.supportingInfo.category'));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.supportingInfo.code'));
    if obj.has('timingPeriod', item) then
      value.timing := parsePeriod(item);
    if obj.has('timingDate', item) then
      value.timing := parseDate(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueAttachment', item) then
      value.value := parseAttachment(item);
    if obj.has('valueReference', item) {a3} then
      value.value := ParseReference(item);
    if obj.has('valueIdentifier', item) then
      value.value := parseIdentifier(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    value.reason := ParseCoding(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.supportingInfo.reason'));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitSupportingInfo(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitSupportingInfo; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitSupportingInfo');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposePositiveInt(this, 'ExplanationOfBenefit.supportingInfo', 'sequence', value.sequenceElement, false, -1);
  ComposeCodeableConcept(this, 'ExplanationOfBenefit.supportingInfo', 'category', value.categoryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.supportingInfo', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.timing is TFhirPeriod) {6} then
    ComposePeriod(this, 'ExplanationOfBenefit.supportingInfo', 'timingPeriod', TFhirPeriod(value.timing), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirDate) {6} then
    ComposeDate(this, 'ExplanationOfBenefit.supportingInfo', 'timingDate', TFhirDate(value.timing), false, -1);
  if (SummaryOption in [soFull, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ExplanationOfBenefit.supportingInfo', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'ExplanationOfBenefit.supportingInfo', 'valueAttachment', TFhirAttachment(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirReference) {2} then
    ComposeReference(this, 'ExplanationOfBenefit.supportingInfo', 'valueReference', TFhirReference(value.value), false,-1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'ExplanationOfBenefit.supportingInfo', 'valueIdentifier', TFhirIdentifier(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ExplanationOfBenefit.supportingInfo', 'valueBoolean', TFhirBoolean(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirString) {6} then
    ComposeString(this, 'ExplanationOfBenefit.supportingInfo', 'valueString', TFhirString(value.value), false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'ExplanationOfBenefit.supportingInfo', 'reason', value.reasonElement, false, -1);
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitDiagnosis(obj : TTurtleComplex) : TFhirExplanationOfBenefitDiagnosis;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitDiagnosis.create;
  try
    ParseExplanationOfBenefitDiagnosisProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitDiagnosisProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitDiagnosis);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.diagnosis.sequence'));
    if obj.has('diagnosisCodeableConcept', item) then
      value.diagnosis := parseCodeableConcept(item);
    if obj.has('diagnosisReference', item) {a3} then
      value.diagnosis := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.diagnosis.type') do
      value.type_List.Add(parseCodeableConcept(item));
    value.onAdmission := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.diagnosis.onAdmission'));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitDiagnosis(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitDiagnosis; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitDiagnosis');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposePositiveInt(this, 'ExplanationOfBenefit.diagnosis', 'sequence', value.sequenceElement, false, -1);
  if (value.diagnosis is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.diagnosis', 'diagnosisCodeableConcept', TFhirCodeableConcept(value.diagnosis), false, -1)
  else if (value.diagnosis is TFhirReference) {2} then
    ComposeReference(this, 'ExplanationOfBenefit.diagnosis', 'diagnosisReference', TFhirReference(value.diagnosis), false,-1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.diagnosis', 'type', value.type_List[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.diagnosis', 'onAdmission', value.onAdmissionElement, false, -1);
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitProcedure(obj : TTurtleComplex) : TFhirExplanationOfBenefitProcedure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitProcedure.create;
  try
    ParseExplanationOfBenefitProcedureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitProcedureProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitProcedure);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.procedure.sequence'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.procedure.type') do
      value.type_List.Add(parseCodeableConcept(item));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.procedure.date'));
    if obj.has('procedureCodeableConcept', item) then
      value.procedure_ := parseCodeableConcept(item);
    if obj.has('procedureReference', item) {a3} then
      value.procedure_ := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.procedure.udi') do
      value.udiList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitProcedure(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitProcedure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitProcedure');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposePositiveInt(this, 'ExplanationOfBenefit.procedure', 'sequence', value.sequenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.procedure', 'type', value.type_List[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'ExplanationOfBenefit.procedure', 'date', value.dateElement, false, -1);
  if (value.procedure_ is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.procedure', 'procedureCodeableConcept', TFhirCodeableConcept(value.procedure_), false, -1)
  else if (value.procedure_ is TFhirReference) {2} then
    ComposeReference(this, 'ExplanationOfBenefit.procedure', 'procedureReference', TFhirReference(value.procedure_), false,-1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.udiList.Count - 1 do
      ComposeReference(this, 'ExplanationOfBenefit.procedure', 'udi', value.udiList[i], false, i);
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitInsurance(obj : TTurtleComplex) : TFhirExplanationOfBenefitInsurance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitInsurance.create;
  try
    ParseExplanationOfBenefitInsuranceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitInsuranceProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitInsurance);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.focalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.insurance.focal'));
    value.coverage := ParseReference(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.insurance.coverage'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.insurance.preAuthRef') do
      value.preAuthRefList.Add(parseString(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitInsurance(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitInsurance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitInsurance');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeBoolean(this, 'ExplanationOfBenefit.insurance', 'focal', value.focalElement, false, -1);
  ComposeReference(this, 'ExplanationOfBenefit.insurance', 'coverage', value.coverageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.preAuthRefList.Count - 1 do
      ComposeString(this, 'ExplanationOfBenefit.insurance', 'preAuthRef', value.preAuthRefList[i], false, i);
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitAccident(obj : TTurtleComplex) : TFhirExplanationOfBenefitAccident;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitAccident.create;
  try
    ParseExplanationOfBenefitAccidentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitAccidentProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitAccident);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.dateElement := ParseDate(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.accident.date'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.accident.type'));
    if obj.has('locationAddress', item) then
      value.location := parseAddress(item);
    if obj.has('locationReference', item) {a3} then
      value.location := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitAccident(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitAccident; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitAccident');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'ExplanationOfBenefit.accident', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.accident', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.location is TFhirAddress) {6} then
    ComposeAddress(this, 'ExplanationOfBenefit.accident', 'locationAddress', TFhirAddress(value.location), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.location is TFhirReference) {2} then
    ComposeReference(this, 'ExplanationOfBenefit.accident', 'locationReference', TFhirReference(value.location), false,-1);
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitItem(obj : TTurtleComplex) : TFhirExplanationOfBenefitItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitItem.create;
  try
    ParseExplanationOfBenefitItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitItemProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.sequence'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.careTeamSequence') do
      value.careTeamSequenceList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.diagnosisSequence') do
      value.diagnosisSequenceList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.procedureSequence') do
      value.procedureSequenceList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.informationSequence') do
      value.informationSequenceList.Add(parsePositiveInt(item));
    value.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.revenue'));
    value.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.category'));
    value.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.productOrService'));
    value.productOrServiceEnd := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.productOrServiceEnd'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.modifier') do
      value.modifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.programCode') do
      value.programCodeList.Add(parseCodeableConcept(item));
    if obj.has('servicedPeriod', item) then
      value.serviced := parsePeriod(item);
    if obj.has('servicedDate', item) then
      value.serviced := parseDate(item);
    if obj.has('locationCodeableConcept', item) then
      value.location := parseCodeableConcept(item);
    if obj.has('locationAddress', item) then
      value.location := parseAddress(item);
    if obj.has('locationReference', item) {a3} then
      value.location := ParseReference(item);
    value.patientPaid := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.patientPaid'));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.quantity'));
    value.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.unitPrice'));
    value.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.factor'));
    value.tax := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.tax'));
    value.net := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.net'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.udi') do
      value.udiList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.bodySite') do
      value.bodySiteList.Add(parseExplanationOfBenefitItemBodySite(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.encounter') do
      value.encounterList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.noteNumber') do
      value.noteNumberList.Add(parsePositiveInt(item));
    value.decision := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.decision'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.adjudication') do
      value.adjudicationList.Add(parseExplanationOfBenefitItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail') do
      value.detailList.Add(parseExplanationOfBenefitItemDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitItem');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposePositiveInt(this, 'ExplanationOfBenefit.item', 'sequence', value.sequenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.careTeamSequenceList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.item', 'careTeamSequence', value.careTeamSequenceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.diagnosisSequenceList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.item', 'diagnosisSequence', value.diagnosisSequenceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.procedureSequenceList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.item', 'procedureSequence', value.procedureSequenceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.informationSequenceList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.item', 'informationSequence', value.informationSequenceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item', 'revenue', value.revenueElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item', 'category', value.categoryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item', 'productOrService', value.productOrServiceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item', 'productOrServiceEnd', value.productOrServiceEndElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.item', 'modifier', value.modifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.programCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.item', 'programCode', value.programCodeList[i], false, i);
  if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirPeriod) {6} then
    ComposePeriod(this, 'ExplanationOfBenefit.item', 'servicedPeriod', TFhirPeriod(value.serviced), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirDate) {6} then
    ComposeDate(this, 'ExplanationOfBenefit.item', 'servicedDate', TFhirDate(value.serviced), false, -1);
  if (SummaryOption in [soFull, soData]) and (value.location is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item', 'locationCodeableConcept', TFhirCodeableConcept(value.location), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.location is TFhirAddress) {6} then
    ComposeAddress(this, 'ExplanationOfBenefit.item', 'locationAddress', TFhirAddress(value.location), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.location is TFhirReference) {2} then
    ComposeReference(this, 'ExplanationOfBenefit.item', 'locationReference', TFhirReference(value.location), false,-1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item', 'patientPaid', value.patientPaidElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ExplanationOfBenefit.item', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item', 'unitPrice', value.unitPriceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ExplanationOfBenefit.item', 'factor', value.factorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item', 'tax', value.taxElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item', 'net', value.netElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.udiList.Count - 1 do
      ComposeReference(this, 'ExplanationOfBenefit.item', 'udi', value.udiList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.bodySiteList.Count - 1 do
      ComposeExplanationOfBenefitItemBodySite(this, 'ExplanationOfBenefit.item', 'bodySite', value.bodySiteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.encounterList.Count - 1 do
      ComposeReference(this, 'ExplanationOfBenefit.item', 'encounter', value.encounterList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.item', 'noteNumber', value.noteNumberList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item', 'decision', value.decisionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(this, 'ExplanationOfBenefit.item', 'adjudication', value.adjudicationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.detailList.Count - 1 do
      ComposeExplanationOfBenefitItemDetail(this, 'ExplanationOfBenefit.item', 'detail', value.detailList[i], false, i);
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitItemBodySite(obj : TTurtleComplex) : TFhirExplanationOfBenefitItemBodySite;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitItemBodySite.create;
  try
    ParseExplanationOfBenefitItemBodySiteProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitItemBodySiteProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitItemBodySite);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.bodySite.site') do
      value.siteList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.bodySite.subSite') do
      value.subSiteList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitItemBodySite(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitItemBodySite; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitItemBodySite');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  for i := 0 to value.siteList.Count - 1 do
      ComposeCodeableReference(this, 'ExplanationOfBenefit.item.bodySite', 'site', value.siteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subSiteList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.bodySite', 'subSite', value.subSiteList[i], false, i);
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitItemAdjudication(obj : TTurtleComplex) : TFhirExplanationOfBenefitItemAdjudication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitItemAdjudication.create;
  try
    ParseExplanationOfBenefitItemAdjudicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitItemAdjudicationProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitItemAdjudication);
begin
    ParseBackboneElementProperties(obj, value);
    value.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.adjudication.category'));
    value.reason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.adjudication.reason'));
    value.amount := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.adjudication.amount'));
    value.valueElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.adjudication.value'));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitItemAdjudication(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitItemAdjudication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitItemAdjudication');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.adjudication', 'category', value.categoryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.adjudication', 'reason', value.reasonElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item.adjudication', 'amount', value.amountElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ExplanationOfBenefit.item.adjudication', 'value', value.valueElement, false, -1);
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitItemDetail(obj : TTurtleComplex) : TFhirExplanationOfBenefitItemDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitItemDetail.create;
  try
    ParseExplanationOfBenefitItemDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitItemDetailProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitItemDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.sequence'));
    value.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.revenue'));
    value.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.category'));
    value.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.productOrService'));
    value.productOrServiceEnd := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.productOrServiceEnd'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.modifier') do
      value.modifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.programCode') do
      value.programCodeList.Add(parseCodeableConcept(item));
    value.patientPaid := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.patientPaid'));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.quantity'));
    value.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.unitPrice'));
    value.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.factor'));
    value.tax := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.tax'));
    value.net := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.net'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.udi') do
      value.udiList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.noteNumber') do
      value.noteNumberList.Add(parsePositiveInt(item));
    value.decision := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.decision'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.adjudication') do
      value.adjudicationList.Add(parseExplanationOfBenefitItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail') do
      value.subDetailList.Add(parseExplanationOfBenefitItemDetailSubDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitItemDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitItemDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitItemDetail');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposePositiveInt(this, 'ExplanationOfBenefit.item.detail', 'sequence', value.sequenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail', 'revenue', value.revenueElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail', 'category', value.categoryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail', 'productOrService', value.productOrServiceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail', 'productOrServiceEnd', value.productOrServiceEndElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail', 'modifier', value.modifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.programCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail', 'programCode', value.programCodeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item.detail', 'patientPaid', value.patientPaidElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ExplanationOfBenefit.item.detail', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item.detail', 'unitPrice', value.unitPriceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ExplanationOfBenefit.item.detail', 'factor', value.factorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item.detail', 'tax', value.taxElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item.detail', 'net', value.netElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.udiList.Count - 1 do
      ComposeReference(this, 'ExplanationOfBenefit.item.detail', 'udi', value.udiList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.item.detail', 'noteNumber', value.noteNumberList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail', 'decision', value.decisionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(this, 'ExplanationOfBenefit.item.detail', 'adjudication', value.adjudicationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subDetailList.Count - 1 do
      ComposeExplanationOfBenefitItemDetailSubDetail(this, 'ExplanationOfBenefit.item.detail', 'subDetail', value.subDetailList[i], false, i);
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitItemDetailSubDetail(obj : TTurtleComplex) : TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitItemDetailSubDetail.create;
  try
    ParseExplanationOfBenefitItemDetailSubDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitItemDetailSubDetailProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitItemDetailSubDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.sequence'));
    value.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.revenue'));
    value.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.category'));
    value.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.productOrService'));
    value.productOrServiceEnd := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.productOrServiceEnd'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.modifier') do
      value.modifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.programCode') do
      value.programCodeList.Add(parseCodeableConcept(item));
    value.patientPaid := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.patientPaid'));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.quantity'));
    value.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.unitPrice'));
    value.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.factor'));
    value.tax := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.tax'));
    value.net := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.net'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.udi') do
      value.udiList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.noteNumber') do
      value.noteNumberList.Add(parsePositiveInt(item));
    value.decision := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.decision'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.adjudication') do
      value.adjudicationList.Add(parseExplanationOfBenefitItemAdjudication(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitItemDetailSubDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitItemDetailSubDetail');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposePositiveInt(this, 'ExplanationOfBenefit.item.detail.subDetail', 'sequence', value.sequenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail.subDetail', 'revenue', value.revenueElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail.subDetail', 'category', value.categoryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail.subDetail', 'productOrService', value.productOrServiceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail.subDetail', 'productOrServiceEnd', value.productOrServiceEndElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail.subDetail', 'modifier', value.modifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.programCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail.subDetail', 'programCode', value.programCodeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item.detail.subDetail', 'patientPaid', value.patientPaidElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ExplanationOfBenefit.item.detail.subDetail', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item.detail.subDetail', 'unitPrice', value.unitPriceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ExplanationOfBenefit.item.detail.subDetail', 'factor', value.factorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item.detail.subDetail', 'tax', value.taxElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item.detail.subDetail', 'net', value.netElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.udiList.Count - 1 do
      ComposeReference(this, 'ExplanationOfBenefit.item.detail.subDetail', 'udi', value.udiList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.item.detail.subDetail', 'noteNumber', value.noteNumberList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail.subDetail', 'decision', value.decisionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(this, 'ExplanationOfBenefit.item.detail.subDetail', 'adjudication', value.adjudicationList[i], false, i);
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitAddItem(obj : TTurtleComplex) : TFhirExplanationOfBenefitAddItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitAddItem.create;
  try
    ParseExplanationOfBenefitAddItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitAddItemProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitAddItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.itemSequence') do
      value.itemSequenceList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detailSequence') do
      value.detailSequenceList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.subDetailSequence') do
      value.subDetailSequenceList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.provider') do
      value.providerList.Add(parseReference(item));
    value.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.revenue'));
    value.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.productOrService'));
    value.productOrServiceEnd := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.productOrServiceEnd'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.modifier') do
      value.modifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.programCode') do
      value.programCodeList.Add(parseCodeableConcept(item));
    if obj.has('servicedPeriod', item) then
      value.serviced := parsePeriod(item);
    if obj.has('servicedDate', item) then
      value.serviced := parseDate(item);
    if obj.has('locationCodeableConcept', item) then
      value.location := parseCodeableConcept(item);
    if obj.has('locationAddress', item) then
      value.location := parseAddress(item);
    if obj.has('locationReference', item) {a3} then
      value.location := ParseReference(item);
    value.patientPaid := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.patientPaid'));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.quantity'));
    value.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.unitPrice'));
    value.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.factor'));
    value.tax := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.tax'));
    value.net := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.net'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.bodySite') do
      value.bodySiteList.Add(parseExplanationOfBenefitAddItemBodySite(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.noteNumber') do
      value.noteNumberList.Add(parsePositiveInt(item));
    value.decision := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.decision'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.adjudication') do
      value.adjudicationList.Add(parseExplanationOfBenefitItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail') do
      value.detailList.Add(parseExplanationOfBenefitAddItemDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitAddItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitAddItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitAddItem');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.itemSequenceList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.addItem', 'itemSequence', value.itemSequenceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.detailSequenceList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.addItem', 'detailSequence', value.detailSequenceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subDetailSequenceList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.addItem', 'subDetailSequence', value.subDetailSequenceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.providerList.Count - 1 do
      ComposeReference(this, 'ExplanationOfBenefit.addItem', 'provider', value.providerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem', 'revenue', value.revenueElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem', 'productOrService', value.productOrServiceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem', 'productOrServiceEnd', value.productOrServiceEndElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem', 'modifier', value.modifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.programCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem', 'programCode', value.programCodeList[i], false, i);
  if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirPeriod) {6} then
    ComposePeriod(this, 'ExplanationOfBenefit.addItem', 'servicedPeriod', TFhirPeriod(value.serviced), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirDate) {6} then
    ComposeDate(this, 'ExplanationOfBenefit.addItem', 'servicedDate', TFhirDate(value.serviced), false, -1);
  if (SummaryOption in [soFull, soData]) and (value.location is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem', 'locationCodeableConcept', TFhirCodeableConcept(value.location), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.location is TFhirAddress) {6} then
    ComposeAddress(this, 'ExplanationOfBenefit.addItem', 'locationAddress', TFhirAddress(value.location), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.location is TFhirReference) {2} then
    ComposeReference(this, 'ExplanationOfBenefit.addItem', 'locationReference', TFhirReference(value.location), false,-1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.addItem', 'patientPaid', value.patientPaidElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ExplanationOfBenefit.addItem', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.addItem', 'unitPrice', value.unitPriceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ExplanationOfBenefit.addItem', 'factor', value.factorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.addItem', 'tax', value.taxElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.addItem', 'net', value.netElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.bodySiteList.Count - 1 do
      ComposeExplanationOfBenefitAddItemBodySite(this, 'ExplanationOfBenefit.addItem', 'bodySite', value.bodySiteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.addItem', 'noteNumber', value.noteNumberList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem', 'decision', value.decisionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(this, 'ExplanationOfBenefit.addItem', 'adjudication', value.adjudicationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.detailList.Count - 1 do
      ComposeExplanationOfBenefitAddItemDetail(this, 'ExplanationOfBenefit.addItem', 'detail', value.detailList[i], false, i);
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitAddItemBodySite(obj : TTurtleComplex) : TFhirExplanationOfBenefitAddItemBodySite;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitAddItemBodySite.create;
  try
    ParseExplanationOfBenefitAddItemBodySiteProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitAddItemBodySiteProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitAddItemBodySite);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.bodySite.site') do
      value.siteList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.bodySite.subSite') do
      value.subSiteList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitAddItemBodySite(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitAddItemBodySite; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitAddItemBodySite');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  for i := 0 to value.siteList.Count - 1 do
      ComposeCodeableReference(this, 'ExplanationOfBenefit.addItem.bodySite', 'site', value.siteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subSiteList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem.bodySite', 'subSite', value.subSiteList[i], false, i);
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitAddItemDetail(obj : TTurtleComplex) : TFhirExplanationOfBenefitAddItemDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitAddItemDetail.create;
  try
    ParseExplanationOfBenefitAddItemDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitAddItemDetailProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitAddItemDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.revenue'));
    value.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.productOrService'));
    value.productOrServiceEnd := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.productOrServiceEnd'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.modifier') do
      value.modifierList.Add(parseCodeableConcept(item));
    value.patientPaid := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.patientPaid'));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.quantity'));
    value.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.unitPrice'));
    value.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.factor'));
    value.tax := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.tax'));
    value.net := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.net'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.noteNumber') do
      value.noteNumberList.Add(parsePositiveInt(item));
    value.decision := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.decision'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.adjudication') do
      value.adjudicationList.Add(parseExplanationOfBenefitItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.subDetail') do
      value.subDetailList.Add(parseExplanationOfBenefitAddItemDetailSubDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitAddItemDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitAddItemDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitAddItemDetail');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem.detail', 'revenue', value.revenueElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem.detail', 'productOrService', value.productOrServiceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem.detail', 'productOrServiceEnd', value.productOrServiceEndElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem.detail', 'modifier', value.modifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.addItem.detail', 'patientPaid', value.patientPaidElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ExplanationOfBenefit.addItem.detail', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.addItem.detail', 'unitPrice', value.unitPriceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ExplanationOfBenefit.addItem.detail', 'factor', value.factorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.addItem.detail', 'tax', value.taxElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.addItem.detail', 'net', value.netElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.addItem.detail', 'noteNumber', value.noteNumberList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem.detail', 'decision', value.decisionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(this, 'ExplanationOfBenefit.addItem.detail', 'adjudication', value.adjudicationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subDetailList.Count - 1 do
      ComposeExplanationOfBenefitAddItemDetailSubDetail(this, 'ExplanationOfBenefit.addItem.detail', 'subDetail', value.subDetailList[i], false, i);
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitAddItemDetailSubDetail(obj : TTurtleComplex) : TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitAddItemDetailSubDetail.create;
  try
    ParseExplanationOfBenefitAddItemDetailSubDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitAddItemDetailSubDetailProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitAddItemDetailSubDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.subDetail.revenue'));
    value.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.subDetail.productOrService'));
    value.productOrServiceEnd := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.subDetail.productOrServiceEnd'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.subDetail.modifier') do
      value.modifierList.Add(parseCodeableConcept(item));
    value.patientPaid := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.subDetail.patientPaid'));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.subDetail.quantity'));
    value.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.subDetail.unitPrice'));
    value.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.subDetail.factor'));
    value.tax := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.subDetail.tax'));
    value.net := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.subDetail.net'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.subDetail.noteNumber') do
      value.noteNumberList.Add(parsePositiveInt(item));
    value.decision := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.subDetail.decision'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.subDetail.adjudication') do
      value.adjudicationList.Add(parseExplanationOfBenefitItemAdjudication(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitAddItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitAddItemDetailSubDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitAddItemDetailSubDetail');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem.detail.subDetail', 'revenue', value.revenueElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem.detail.subDetail', 'productOrService', value.productOrServiceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem.detail.subDetail', 'productOrServiceEnd', value.productOrServiceEndElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem.detail.subDetail', 'modifier', value.modifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.addItem.detail.subDetail', 'patientPaid', value.patientPaidElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ExplanationOfBenefit.addItem.detail.subDetail', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.addItem.detail.subDetail', 'unitPrice', value.unitPriceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ExplanationOfBenefit.addItem.detail.subDetail', 'factor', value.factorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.addItem.detail.subDetail', 'tax', value.taxElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.addItem.detail.subDetail', 'net', value.netElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.addItem.detail.subDetail', 'noteNumber', value.noteNumberList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem.detail.subDetail', 'decision', value.decisionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(this, 'ExplanationOfBenefit.addItem.detail.subDetail', 'adjudication', value.adjudicationList[i], false, i);
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitTotal(obj : TTurtleComplex) : TFhirExplanationOfBenefitTotal;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitTotal.create;
  try
    ParseExplanationOfBenefitTotalProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitTotalProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitTotal);
begin
    ParseBackboneElementProperties(obj, value);
    value.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.total.category'));
    value.amount := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.total.amount'));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitTotal(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitTotal; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitTotal');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'ExplanationOfBenefit.total', 'category', value.categoryElement, false, -1);
  ComposeMoney(this, 'ExplanationOfBenefit.total', 'amount', value.amountElement, false, -1);
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitPayment(obj : TTurtleComplex) : TFhirExplanationOfBenefitPayment;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitPayment.create;
  try
    ParseExplanationOfBenefitPaymentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitPaymentProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitPayment);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payment.type'));
    value.adjustment := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payment.adjustment'));
    value.adjustmentReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payment.adjustmentReason'));
    value.dateElement := ParseDate(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payment.date'));
    value.amount := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payment.amount'));
    value.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payment.identifier'));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitPayment(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitPayment; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitPayment');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.payment', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.payment', 'adjustment', value.adjustmentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.payment', 'adjustmentReason', value.adjustmentReasonElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'ExplanationOfBenefit.payment', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.payment', 'amount', value.amountElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'ExplanationOfBenefit.payment', 'identifier', value.identifierElement, false, -1);
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitProcessNote(obj : TTurtleComplex) : TFhirExplanationOfBenefitProcessNote;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitProcessNote.create;
  try
    ParseExplanationOfBenefitProcessNoteProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitProcessNoteProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitProcessNote);
begin
    ParseBackboneElementProperties(obj, value);
    value.numberElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.processNote.number'));
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.processNote.type'), CODES_TFhirNoteTypeEnum, SYSTEMS_TFhirNoteTypeEnum);
    value.textElement := ParseString(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.processNote.text'));
    value.language := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.processNote.language'));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitProcessNote(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitProcessNote; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitProcessNote');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'ExplanationOfBenefit.processNote', 'number', value.numberElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'ExplanationOfBenefit.processNote', 'type', value.type_Element, CODES_TFhirNoteTypeEnum, SYSTEMS_TFhirNoteTypeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ExplanationOfBenefit.processNote', 'text', value.textElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.processNote', 'language', value.languageElement, false, -1);
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitBenefitBalance(obj : TTurtleComplex) : TFhirExplanationOfBenefitBenefitBalance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitBenefitBalance.create;
  try
    ParseExplanationOfBenefitBenefitBalanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitBenefitBalanceProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitBenefitBalance);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.category'));
    value.excludedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.excluded'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.name'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.description'));
    value.network := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.network'));
    value.unit_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.unit'));
    value.term := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.term'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.financial') do
      value.financialList.Add(parseExplanationOfBenefitBenefitBalanceFinancial(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitBenefitBalance(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitBenefitBalance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitBenefitBalance');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'ExplanationOfBenefit.benefitBalance', 'category', value.categoryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ExplanationOfBenefit.benefitBalance', 'excluded', value.excludedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ExplanationOfBenefit.benefitBalance', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ExplanationOfBenefit.benefitBalance', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.benefitBalance', 'network', value.networkElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.benefitBalance', 'unit', value.unit_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.benefitBalance', 'term', value.termElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.financialList.Count - 1 do
      ComposeExplanationOfBenefitBenefitBalanceFinancial(this, 'ExplanationOfBenefit.benefitBalance', 'financial', value.financialList[i], false, i);
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitBenefitBalanceFinancial(obj : TTurtleComplex) : TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial.create;
  try
    ParseExplanationOfBenefitBenefitBalanceFinancialProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitBenefitBalanceFinancialProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefitBenefitBalanceFinancial);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.financial.type'));
    if obj.has('allowedUnsignedInt', item) then
      value.allowed := parseUnsignedInt(item);
    if obj.has('allowedMoney', item) then
      value.allowed := parseMoney(item);
    if obj.has('allowedString', item) then
      value.allowed := parseString(item);
    if obj.has('usedUnsignedInt', item) then
      value.used := parseUnsignedInt(item);
    if obj.has('usedMoney', item) then
      value.used := parseMoney(item);
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitBenefitBalanceFinancial(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefitBenefitBalanceFinancial; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitBenefitBalanceFinancial');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'ExplanationOfBenefit.benefitBalance.financial', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.allowed is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'ExplanationOfBenefit.benefitBalance.financial', 'allowedUnsignedInt', TFhirUnsignedInt(value.allowed), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.allowed is TFhirMoney) {6} then
    ComposeMoney(this, 'ExplanationOfBenefit.benefitBalance.financial', 'allowedMoney', TFhirMoney(value.allowed), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.allowed is TFhirString) {6} then
    ComposeString(this, 'ExplanationOfBenefit.benefitBalance.financial', 'allowedString', TFhirString(value.allowed), false, -1);
  if (SummaryOption in [soFull, soData]) and (value.used is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'ExplanationOfBenefit.benefitBalance.financial', 'usedUnsignedInt', TFhirUnsignedInt(value.used), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.used is TFhirMoney) {6} then
    ComposeMoney(this, 'ExplanationOfBenefit.benefitBalance.financial', 'usedMoney', TFhirMoney(value.used), false, -1);
end;

function TFHIRTurtleParser.ParseExplanationOfBenefit(obj : TTurtleComplex) : TFhirExplanationOfBenefit;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefit.create;
  try
    ParseExplanationOfBenefitProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitProperties(obj : TTurtleComplex; value : TFhirExplanationOfBenefit);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.status'), CODES_TFhirExplanationOfBenefitStatusEnum, SYSTEMS_TFhirExplanationOfBenefitStatusEnum);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.type'));
    value.subType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.subType'));
    value.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.use'), CODES_TFhirUseEnum, SYSTEMS_TFhirUseEnum);
    value.patient := ParseReference(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.patient'));
    value.billablePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.billablePeriod'));
    value.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.created'));
    value.enterer := ParseReference(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.enterer'));
    value.insurer := ParseReference(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.insurer'));
    value.provider := ParseReference(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.provider'));
    value.priority := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.priority'));
    value.fundsReserveRequested := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.fundsReserveRequested'));
    value.fundsReserve := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.fundsReserve'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.related') do
      value.relatedList.Add(parseExplanationOfBenefitRelated(item));
    value.prescription := ParseReference(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.prescription'));
    value.originalPrescription := ParseReference(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.originalPrescription'));
    value.payee := ParseExplanationOfBenefitPayee(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payee'));
    value.referral := ParseReference(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.referral'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.encounter') do
      value.encounterList.Add(parseReference(item));
    value.facility := ParseReference(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.facility'));
    value.claim := ParseReference(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.claim'));
    value.claimResponse := ParseReference(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.claimResponse'));
    value.outcomeElement := ParseEnum(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.outcome'), CODES_TFhirClaimProcessingCodesEnum, SYSTEMS_TFhirClaimProcessingCodesEnum);
    value.decision := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.decision'));
    value.dispositionElement := ParseString(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.disposition'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.preAuthRef') do
      value.preAuthRefList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.preAuthRefPeriod') do
      value.preAuthRefPeriodList.Add(parsePeriod(item));
    value.diagnosisRelatedGroup := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.diagnosisRelatedGroup'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.careTeam') do
      value.careTeamList.Add(parseExplanationOfBenefitCareTeam(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.supportingInfo') do
      value.supportingInfoList.Add(parseExplanationOfBenefitSupportingInfo(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.diagnosis') do
      value.diagnosisList.Add(parseExplanationOfBenefitDiagnosis(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.procedure') do
      value.procedure_List.Add(parseExplanationOfBenefitProcedure(item));
    value.precedenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.precedence'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.insurance') do
      value.insuranceList.Add(parseExplanationOfBenefitInsurance(item));
    value.accident := ParseExplanationOfBenefitAccident(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.accident'));
    value.patientPaid := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.patientPaid'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item') do
      value.itemList.Add(parseExplanationOfBenefitItem(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem') do
      value.addItemList.Add(parseExplanationOfBenefitAddItem(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.adjudication') do
      value.adjudicationList.Add(parseExplanationOfBenefitItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.total') do
      value.totalList.Add(parseExplanationOfBenefitTotal(item));
    value.payment := ParseExplanationOfBenefitPayment(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payment'));
    value.formCode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.formCode'));
    value.form := ParseAttachment(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.form'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.processNote') do
      value.processNoteList.Add(parseExplanationOfBenefitProcessNote(item));
    value.benefitPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitPeriod'));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance') do
      value.benefitBalanceList.Add(parseExplanationOfBenefitBenefitBalance(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefit(parent :  TTurtleComplex; parentType, name : String; value : TFhirExplanationOfBenefit; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefit');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ExplanationOfBenefit', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'ExplanationOfBenefit', 'status', value.statusElement, CODES_TFhirExplanationOfBenefitStatusEnum, SYSTEMS_TFhirExplanationOfBenefitStatusEnum, false, -1);
  ComposeCodeableConcept(this, 'ExplanationOfBenefit', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit', 'subType', value.subTypeElement, false, -1);
  ComposeEnum(this, 'ExplanationOfBenefit', 'use', value.useElement, CODES_TFhirUseEnum, SYSTEMS_TFhirUseEnum, false, -1);
  ComposeReference(this, 'ExplanationOfBenefit', 'patient', value.patientElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'ExplanationOfBenefit', 'billablePeriod', value.billablePeriodElement, false, -1);
  ComposeDateTime(this, 'ExplanationOfBenefit', 'created', value.createdElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ExplanationOfBenefit', 'enterer', value.entererElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'ExplanationOfBenefit', 'insurer', value.insurerElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'ExplanationOfBenefit', 'provider', value.providerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit', 'priority', value.priorityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit', 'fundsReserveRequested', value.fundsReserveRequestedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit', 'fundsReserve', value.fundsReserveElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedList.Count - 1 do
      ComposeExplanationOfBenefitRelated(this, 'ExplanationOfBenefit', 'related', value.relatedList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ExplanationOfBenefit', 'prescription', value.prescriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ExplanationOfBenefit', 'originalPrescription', value.originalPrescriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeExplanationOfBenefitPayee(this, 'ExplanationOfBenefit', 'payee', value.payeeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ExplanationOfBenefit', 'referral', value.referralElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.encounterList.Count - 1 do
      ComposeReference(this, 'ExplanationOfBenefit', 'encounter', value.encounterList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ExplanationOfBenefit', 'facility', value.facilityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ExplanationOfBenefit', 'claim', value.claimElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ExplanationOfBenefit', 'claimResponse', value.claimResponseElement, false, -1);
  ComposeEnum(this, 'ExplanationOfBenefit', 'outcome', value.outcomeElement, CODES_TFhirClaimProcessingCodesEnum, SYSTEMS_TFhirClaimProcessingCodesEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit', 'decision', value.decisionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ExplanationOfBenefit', 'disposition', value.dispositionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.preAuthRefList.Count - 1 do
      ComposeString(this, 'ExplanationOfBenefit', 'preAuthRef', value.preAuthRefList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.preAuthRefPeriodList.Count - 1 do
      ComposePeriod(this, 'ExplanationOfBenefit', 'preAuthRefPeriod', value.preAuthRefPeriodList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit', 'diagnosisRelatedGroup', value.diagnosisRelatedGroupElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.careTeamList.Count - 1 do
      ComposeExplanationOfBenefitCareTeam(this, 'ExplanationOfBenefit', 'careTeam', value.careTeamList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInfoList.Count - 1 do
      ComposeExplanationOfBenefitSupportingInfo(this, 'ExplanationOfBenefit', 'supportingInfo', value.supportingInfoList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.diagnosisList.Count - 1 do
      ComposeExplanationOfBenefitDiagnosis(this, 'ExplanationOfBenefit', 'diagnosis', value.diagnosisList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.procedure_List.Count - 1 do
      ComposeExplanationOfBenefitProcedure(this, 'ExplanationOfBenefit', 'procedure', value.procedure_List[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'ExplanationOfBenefit', 'precedence', value.precedenceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.insuranceList.Count - 1 do
      ComposeExplanationOfBenefitInsurance(this, 'ExplanationOfBenefit', 'insurance', value.insuranceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeExplanationOfBenefitAccident(this, 'ExplanationOfBenefit', 'accident', value.accidentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit', 'patientPaid', value.patientPaidElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.itemList.Count - 1 do
      ComposeExplanationOfBenefitItem(this, 'ExplanationOfBenefit', 'item', value.itemList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.addItemList.Count - 1 do
      ComposeExplanationOfBenefitAddItem(this, 'ExplanationOfBenefit', 'addItem', value.addItemList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(this, 'ExplanationOfBenefit', 'adjudication', value.adjudicationList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.totalList.Count - 1 do
      ComposeExplanationOfBenefitTotal(this, 'ExplanationOfBenefit', 'total', value.totalList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeExplanationOfBenefitPayment(this, 'ExplanationOfBenefit', 'payment', value.paymentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit', 'formCode', value.formCodeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeAttachment(this, 'ExplanationOfBenefit', 'form', value.formElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.processNoteList.Count - 1 do
      ComposeExplanationOfBenefitProcessNote(this, 'ExplanationOfBenefit', 'processNote', value.processNoteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'ExplanationOfBenefit', 'benefitPeriod', value.benefitPeriodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.benefitBalanceList.Count - 1 do
      ComposeExplanationOfBenefitBenefitBalance(this, 'ExplanationOfBenefit', 'benefitBalance', value.benefitBalanceList[i], false, i);
end;

{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
function TFHIRTurtleParser.ParseFamilyMemberHistoryCondition(obj : TTurtleComplex) : TFhirFamilyMemberHistoryCondition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirFamilyMemberHistoryCondition.create;
  try
    ParseFamilyMemberHistoryConditionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseFamilyMemberHistoryConditionProperties(obj : TTurtleComplex; value : TFhirFamilyMemberHistoryCondition);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.condition.code'));
    value.outcome := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.condition.outcome'));
    value.contributedToDeathElement := ParseBoolean(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.condition.contributedToDeath'));
    if obj.has('onsetAge', item) then
      value.onset := parseAge(item);
    if obj.has('onsetRange', item) then
      value.onset := parseRange(item);
    if obj.has('onsetPeriod', item) then
      value.onset := parsePeriod(item);
    if obj.has('onsetString', item) then
      value.onset := parseString(item);
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.condition.note') do
      value.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeFamilyMemberHistoryCondition(parent :  TTurtleComplex; parentType, name : String; value : TFhirFamilyMemberHistoryCondition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:FamilyMemberHistoryCondition');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'FamilyMemberHistory.condition', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'FamilyMemberHistory.condition', 'outcome', value.outcomeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'FamilyMemberHistory.condition', 'contributedToDeath', value.contributedToDeathElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.onset is TFhirAge) {6} then
    ComposeAge(this, 'FamilyMemberHistory.condition', 'onsetAge', TFhirAge(value.onset), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.onset is TFhirRange) {6} then
    ComposeRange(this, 'FamilyMemberHistory.condition', 'onsetRange', TFhirRange(value.onset), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.onset is TFhirPeriod) {6} then
    ComposePeriod(this, 'FamilyMemberHistory.condition', 'onsetPeriod', TFhirPeriod(value.onset), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.onset is TFhirString) {6} then
    ComposeString(this, 'FamilyMemberHistory.condition', 'onsetString', TFhirString(value.onset), false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'FamilyMemberHistory.condition', 'note', value.noteList[i], false, i);
end;

function TFHIRTurtleParser.ParseFamilyMemberHistoryProcedure(obj : TTurtleComplex) : TFhirFamilyMemberHistoryProcedure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirFamilyMemberHistoryProcedure.create;
  try
    ParseFamilyMemberHistoryProcedureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseFamilyMemberHistoryProcedureProperties(obj : TTurtleComplex; value : TFhirFamilyMemberHistoryProcedure);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.procedure.code'));
    value.outcome := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.procedure.outcome'));
    value.contributedToDeathElement := ParseBoolean(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.procedure.contributedToDeath'));
    if obj.has('performedAge', item) then
      value.performed := parseAge(item);
    if obj.has('performedRange', item) then
      value.performed := parseRange(item);
    if obj.has('performedPeriod', item) then
      value.performed := parsePeriod(item);
    if obj.has('performedString', item) then
      value.performed := parseString(item);
    if obj.has('performedDateTime', item) then
      value.performed := parseDateTime(item);
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.procedure.note') do
      value.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeFamilyMemberHistoryProcedure(parent :  TTurtleComplex; parentType, name : String; value : TFhirFamilyMemberHistoryProcedure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:FamilyMemberHistoryProcedure');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'FamilyMemberHistory.procedure', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'FamilyMemberHistory.procedure', 'outcome', value.outcomeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'FamilyMemberHistory.procedure', 'contributedToDeath', value.contributedToDeathElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.performed is TFhirAge) {6} then
    ComposeAge(this, 'FamilyMemberHistory.procedure', 'performedAge', TFhirAge(value.performed), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.performed is TFhirRange) {6} then
    ComposeRange(this, 'FamilyMemberHistory.procedure', 'performedRange', TFhirRange(value.performed), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.performed is TFhirPeriod) {6} then
    ComposePeriod(this, 'FamilyMemberHistory.procedure', 'performedPeriod', TFhirPeriod(value.performed), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.performed is TFhirString) {6} then
    ComposeString(this, 'FamilyMemberHistory.procedure', 'performedString', TFhirString(value.performed), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.performed is TFhirDateTime) {6} then
    ComposeDateTime(this, 'FamilyMemberHistory.procedure', 'performedDateTime', TFhirDateTime(value.performed), false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'FamilyMemberHistory.procedure', 'note', value.noteList[i], false, i);
end;

function TFHIRTurtleParser.ParseFamilyMemberHistory(obj : TTurtleComplex) : TFhirFamilyMemberHistory;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirFamilyMemberHistory.create;
  try
    ParseFamilyMemberHistoryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseFamilyMemberHistoryProperties(obj : TTurtleComplex; value : TFhirFamilyMemberHistory);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.instantiatesCanonical') do
      value.instantiatesCanonicalList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.instantiatesUri') do
      value.instantiatesUriList.Add(parseUri(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.status'), CODES_TFhirFamilyHistoryStatusEnum, SYSTEMS_TFhirFamilyHistoryStatusEnum);
    value.dataAbsentReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.dataAbsentReason'));
    value.patient := ParseReference(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.patient'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.date'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.name'));
    value.relationship := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.relationship'));
    value.sex := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.sex'));
    if obj.has('bornPeriod', item) then
      value.born := parsePeriod(item);
    if obj.has('bornDate', item) then
      value.born := parseDate(item);
    if obj.has('bornString', item) then
      value.born := parseString(item);
    if obj.has('ageAge', item) then
      value.age := parseAge(item);
    if obj.has('ageRange', item) then
      value.age := parseRange(item);
    if obj.has('ageString', item) then
      value.age := parseString(item);
    value.estimatedAgeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.estimatedAge'));
    if obj.has('deceasedAge', item) then
      value.deceased := parseAge(item);
    if obj.has('deceasedRange', item) then
      value.deceased := parseRange(item);
    if obj.has('deceasedBoolean', item) then
      value.deceased := parseBoolean(item);
    if obj.has('deceasedDate', item) then
      value.deceased := parseDate(item);
    if obj.has('deceasedString', item) then
      value.deceased := parseString(item);
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.reason') do
      value.reasonList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.condition') do
      value.conditionList.Add(parseFamilyMemberHistoryCondition(item));
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.procedure') do
      value.procedure_List.Add(parseFamilyMemberHistoryProcedure(item));
end;

procedure TFHIRTurtleComposer.ComposeFamilyMemberHistory(parent :  TTurtleComplex; parentType, name : String; value : TFhirFamilyMemberHistory; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:FamilyMemberHistory');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'FamilyMemberHistory', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(this, 'FamilyMemberHistory', 'instantiatesCanonical', value.instantiatesCanonicalList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesUriList.Count - 1 do
      ComposeUri(this, 'FamilyMemberHistory', 'instantiatesUri', value.instantiatesUriList[i], false, i);
  ComposeEnum(this, 'FamilyMemberHistory', 'status', value.statusElement, CODES_TFhirFamilyHistoryStatusEnum, SYSTEMS_TFhirFamilyHistoryStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'FamilyMemberHistory', 'dataAbsentReason', value.dataAbsentReasonElement, false, -1);
  ComposeReference(this, 'FamilyMemberHistory', 'patient', value.patientElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'FamilyMemberHistory', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'FamilyMemberHistory', 'name', value.nameElement, false, -1);
  ComposeCodeableConcept(this, 'FamilyMemberHistory', 'relationship', value.relationshipElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'FamilyMemberHistory', 'sex', value.sexElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.born is TFhirPeriod) {6} then
    ComposePeriod(this, 'FamilyMemberHistory', 'bornPeriod', TFhirPeriod(value.born), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.born is TFhirDate) {6} then
    ComposeDate(this, 'FamilyMemberHistory', 'bornDate', TFhirDate(value.born), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.born is TFhirString) {6} then
    ComposeString(this, 'FamilyMemberHistory', 'bornString', TFhirString(value.born), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.age is TFhirAge) {6} then
    ComposeAge(this, 'FamilyMemberHistory', 'ageAge', TFhirAge(value.age), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.age is TFhirRange) {6} then
    ComposeRange(this, 'FamilyMemberHistory', 'ageRange', TFhirRange(value.age), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.age is TFhirString) {6} then
    ComposeString(this, 'FamilyMemberHistory', 'ageString', TFhirString(value.age), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'FamilyMemberHistory', 'estimatedAge', value.estimatedAgeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.deceased is TFhirAge) {6} then
    ComposeAge(this, 'FamilyMemberHistory', 'deceasedAge', TFhirAge(value.deceased), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.deceased is TFhirRange) {6} then
    ComposeRange(this, 'FamilyMemberHistory', 'deceasedRange', TFhirRange(value.deceased), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.deceased is TFhirBoolean) {6} then
    ComposeBoolean(this, 'FamilyMemberHistory', 'deceasedBoolean', TFhirBoolean(value.deceased), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.deceased is TFhirDate) {6} then
    ComposeDate(this, 'FamilyMemberHistory', 'deceasedDate', TFhirDate(value.deceased), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.deceased is TFhirString) {6} then
    ComposeString(this, 'FamilyMemberHistory', 'deceasedString', TFhirString(value.deceased), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(this, 'FamilyMemberHistory', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'FamilyMemberHistory', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.conditionList.Count - 1 do
      ComposeFamilyMemberHistoryCondition(this, 'FamilyMemberHistory', 'condition', value.conditionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.procedure_List.Count - 1 do
      ComposeFamilyMemberHistoryProcedure(this, 'FamilyMemberHistory', 'procedure', value.procedure_List[i], false, i);
end;

{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
function TFHIRTurtleParser.ParseFlag(obj : TTurtleComplex) : TFhirFlag;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirFlag.create;
  try
    ParseFlagProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseFlagProperties(obj : TTurtleComplex; value : TFhirFlag);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Flag.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Flag.status'), CODES_TFhirFlagStatusEnum, SYSTEMS_TFhirFlagStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/Flag.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Flag.code'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/Flag.subject'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Flag.period'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/Flag.encounter'));
    value.author := ParseReference(obj.complex('http://hl7.org/fhir/Flag.author'));
end;

procedure TFHIRTurtleComposer.ComposeFlag(parent :  TTurtleComplex; parentType, name : String; value : TFhirFlag; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Flag');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Flag', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'Flag', 'status', value.statusElement, CODES_TFhirFlagStatusEnum, SYSTEMS_TFhirFlagStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Flag', 'category', value.categoryList[i], false, i);
  ComposeCodeableConcept(this, 'Flag', 'code', value.codeElement, false, -1);
  ComposeReference(this, 'Flag', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Flag', 'period', value.periodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Flag', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Flag', 'author', value.authorElement, false, -1);
end;

{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_FORMULARYITEM}
function TFHIRTurtleParser.ParseFormularyItem(obj : TTurtleComplex) : TFhirFormularyItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirFormularyItem.create;
  try
    ParseFormularyItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseFormularyItemProperties(obj : TTurtleComplex; value : TFhirFormularyItem);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/FormularyItem.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/FormularyItem.code'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/FormularyItem.status'), CODES_TFhirFormularyItemStatusCodesEnum, SYSTEMS_TFhirFormularyItemStatusCodesEnum);
end;

procedure TFHIRTurtleComposer.ComposeFormularyItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirFormularyItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:FormularyItem');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'FormularyItem', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'FormularyItem', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'FormularyItem', 'status', value.statusElement, CODES_TFhirFormularyItemStatusCodesEnum, SYSTEMS_TFhirFormularyItemStatusCodesEnum, false, -1);
end;

{$ENDIF FHIR_FORMULARYITEM}
{$IFDEF FHIR_GENOMICSTUDY}
function TFHIRTurtleParser.ParseGenomicStudyAnalysis(obj : TTurtleComplex) : TFhirGenomicStudyAnalysis;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGenomicStudyAnalysis.create;
  try
    ParseGenomicStudyAnalysisProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGenomicStudyAnalysisProperties(obj : TTurtleComplex; value : TFhirGenomicStudyAnalysis);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/GenomicStudy.analysis.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/GenomicStudy.analysis.methodType') do
      value.methodTypeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/GenomicStudy.analysis.changeType') do
      value.changeTypeList.Add(parseCodeableConcept(item));
    value.genomeBuild := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/GenomicStudy.analysis.genomeBuild'));
    value.instantiatesCanonicalElement := ParseCanonical(obj.complex('http://hl7.org/fhir/GenomicStudy.analysis.instantiatesCanonical'));
    value.instantiatesUriElement := ParseUri(obj.complex('http://hl7.org/fhir/GenomicStudy.analysis.instantiatesUri'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/GenomicStudy.analysis.title'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/GenomicStudy.analysis.subject'));
    for item in obj.complexes('http://hl7.org/fhir/GenomicStudy.analysis.specimen') do
      value.specimenList.Add(parseReference(item));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/GenomicStudy.analysis.date'));
    for item in obj.complexes('http://hl7.org/fhir/GenomicStudy.analysis.note') do
      value.noteList.Add(parseAnnotation(item));
    value.protocolPerformed := ParseReference(obj.complex('http://hl7.org/fhir/GenomicStudy.analysis.protocolPerformed'));
    for item in obj.complexes('http://hl7.org/fhir/GenomicStudy.analysis.regionsStudied') do
      value.regionsStudiedList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/GenomicStudy.analysis.regionsCalled') do
      value.regionsCalledList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/GenomicStudy.analysis.input') do
      value.inputList.Add(parseGenomicStudyAnalysisInput(item));
    for item in obj.complexes('http://hl7.org/fhir/GenomicStudy.analysis.output') do
      value.outputList.Add(parseGenomicStudyAnalysisOutput(item));
    for item in obj.complexes('http://hl7.org/fhir/GenomicStudy.analysis.performer') do
      value.performerList.Add(parseGenomicStudyAnalysisPerformer(item));
    for item in obj.complexes('http://hl7.org/fhir/GenomicStudy.analysis.device') do
      value.deviceList.Add(parseGenomicStudyAnalysisDevice(item));
end;

procedure TFHIRTurtleComposer.ComposeGenomicStudyAnalysis(parent :  TTurtleComplex; parentType, name : String; value : TFhirGenomicStudyAnalysis; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GenomicStudyAnalysis');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'GenomicStudy.analysis', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.methodTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'GenomicStudy.analysis', 'methodType', value.methodTypeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.changeTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'GenomicStudy.analysis', 'changeType', value.changeTypeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'GenomicStudy.analysis', 'genomeBuild', value.genomeBuildElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'GenomicStudy.analysis', 'instantiatesCanonical', value.instantiatesCanonicalElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'GenomicStudy.analysis', 'instantiatesUri', value.instantiatesUriElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'GenomicStudy.analysis', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'GenomicStudy.analysis', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.specimenList.Count - 1 do
      ComposeReference(this, 'GenomicStudy.analysis', 'specimen', value.specimenList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'GenomicStudy.analysis', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'GenomicStudy.analysis', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'GenomicStudy.analysis', 'protocolPerformed', value.protocolPerformedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.regionsStudiedList.Count - 1 do
      ComposeReference(this, 'GenomicStudy.analysis', 'regionsStudied', value.regionsStudiedList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.regionsCalledList.Count - 1 do
      ComposeReference(this, 'GenomicStudy.analysis', 'regionsCalled', value.regionsCalledList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.inputList.Count - 1 do
      ComposeGenomicStudyAnalysisInput(this, 'GenomicStudy.analysis', 'input', value.inputList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.outputList.Count - 1 do
      ComposeGenomicStudyAnalysisOutput(this, 'GenomicStudy.analysis', 'output', value.outputList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeGenomicStudyAnalysisPerformer(this, 'GenomicStudy.analysis', 'performer', value.performerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.deviceList.Count - 1 do
      ComposeGenomicStudyAnalysisDevice(this, 'GenomicStudy.analysis', 'device', value.deviceList[i], false, i);
end;

function TFHIRTurtleParser.ParseGenomicStudyAnalysisInput(obj : TTurtleComplex) : TFhirGenomicStudyAnalysisInput;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGenomicStudyAnalysisInput.create;
  try
    ParseGenomicStudyAnalysisInputProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGenomicStudyAnalysisInputProperties(obj : TTurtleComplex; value : TFhirGenomicStudyAnalysisInput);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.file_ := ParseReference(obj.complex('http://hl7.org/fhir/GenomicStudy.analysis.input.file'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/GenomicStudy.analysis.input.type'));
    if obj.has('generatedByIdentifier', item) then
      value.generatedBy := parseIdentifier(item);
    if obj.has('generatedByReference', item) {a3} then
      value.generatedBy := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeGenomicStudyAnalysisInput(parent :  TTurtleComplex; parentType, name : String; value : TFhirGenomicStudyAnalysisInput; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GenomicStudyAnalysisInput');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'GenomicStudy.analysis.input', 'file', value.file_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'GenomicStudy.analysis.input', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.generatedBy is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'GenomicStudy.analysis.input', 'generatedByIdentifier', TFhirIdentifier(value.generatedBy), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.generatedBy is TFhirReference) {2} then
    ComposeReference(this, 'GenomicStudy.analysis.input', 'generatedByReference', TFhirReference(value.generatedBy), false,-1);
end;

function TFHIRTurtleParser.ParseGenomicStudyAnalysisOutput(obj : TTurtleComplex) : TFhirGenomicStudyAnalysisOutput;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGenomicStudyAnalysisOutput.create;
  try
    ParseGenomicStudyAnalysisOutputProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGenomicStudyAnalysisOutputProperties(obj : TTurtleComplex; value : TFhirGenomicStudyAnalysisOutput);
begin
    ParseBackboneElementProperties(obj, value);
    value.file_ := ParseReference(obj.complex('http://hl7.org/fhir/GenomicStudy.analysis.output.file'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/GenomicStudy.analysis.output.type'));
end;

procedure TFHIRTurtleComposer.ComposeGenomicStudyAnalysisOutput(parent :  TTurtleComplex; parentType, name : String; value : TFhirGenomicStudyAnalysisOutput; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GenomicStudyAnalysisOutput');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'GenomicStudy.analysis.output', 'file', value.file_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'GenomicStudy.analysis.output', 'type', value.type_Element, false, -1);
end;

function TFHIRTurtleParser.ParseGenomicStudyAnalysisPerformer(obj : TTurtleComplex) : TFhirGenomicStudyAnalysisPerformer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGenomicStudyAnalysisPerformer.create;
  try
    ParseGenomicStudyAnalysisPerformerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGenomicStudyAnalysisPerformerProperties(obj : TTurtleComplex; value : TFhirGenomicStudyAnalysisPerformer);
begin
    ParseBackboneElementProperties(obj, value);
    value.actor := ParseReference(obj.complex('http://hl7.org/fhir/GenomicStudy.analysis.performer.actor'));
    value.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/GenomicStudy.analysis.performer.role'));
end;

procedure TFHIRTurtleComposer.ComposeGenomicStudyAnalysisPerformer(parent :  TTurtleComplex; parentType, name : String; value : TFhirGenomicStudyAnalysisPerformer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GenomicStudyAnalysisPerformer');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'GenomicStudy.analysis.performer', 'actor', value.actorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'GenomicStudy.analysis.performer', 'role', value.roleElement, false, -1);
end;

function TFHIRTurtleParser.ParseGenomicStudyAnalysisDevice(obj : TTurtleComplex) : TFhirGenomicStudyAnalysisDevice;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGenomicStudyAnalysisDevice.create;
  try
    ParseGenomicStudyAnalysisDeviceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGenomicStudyAnalysisDeviceProperties(obj : TTurtleComplex; value : TFhirGenomicStudyAnalysisDevice);
begin
    ParseBackboneElementProperties(obj, value);
    value.device := ParseReference(obj.complex('http://hl7.org/fhir/GenomicStudy.analysis.device.device'));
    value.function_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/GenomicStudy.analysis.device.function'));
end;

procedure TFHIRTurtleComposer.ComposeGenomicStudyAnalysisDevice(parent :  TTurtleComplex; parentType, name : String; value : TFhirGenomicStudyAnalysisDevice; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GenomicStudyAnalysisDevice');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'GenomicStudy.analysis.device', 'device', value.deviceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'GenomicStudy.analysis.device', 'function', value.function_Element, false, -1);
end;

function TFHIRTurtleParser.ParseGenomicStudy(obj : TTurtleComplex) : TFhirGenomicStudy;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGenomicStudy.create;
  try
    ParseGenomicStudyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGenomicStudyProperties(obj : TTurtleComplex; value : TFhirGenomicStudy);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/GenomicStudy.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.status := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/GenomicStudy.status'));
    for item in obj.complexes('http://hl7.org/fhir/GenomicStudy.type') do
      value.type_List.Add(parseCodeableConcept(item));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/GenomicStudy.subject'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/GenomicStudy.encounter'));
    value.startDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/GenomicStudy.startDate'));
    for item in obj.complexes('http://hl7.org/fhir/GenomicStudy.basedOn') do
      value.basedOnList.Add(parseReference(item));
    value.referrer := ParseReference(obj.complex('http://hl7.org/fhir/GenomicStudy.referrer'));
    for item in obj.complexes('http://hl7.org/fhir/GenomicStudy.interpreter') do
      value.interpreterList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/GenomicStudy.reason') do
      value.reasonList.Add(parseCodeableReference(item));
    value.instantiatesCanonicalElement := ParseCanonical(obj.complex('http://hl7.org/fhir/GenomicStudy.instantiatesCanonical'));
    value.instantiatesUriElement := ParseUri(obj.complex('http://hl7.org/fhir/GenomicStudy.instantiatesUri'));
    for item in obj.complexes('http://hl7.org/fhir/GenomicStudy.note') do
      value.noteList.Add(parseAnnotation(item));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/GenomicStudy.description'));
    for item in obj.complexes('http://hl7.org/fhir/GenomicStudy.analysis') do
      value.analysisList.Add(parseGenomicStudyAnalysis(item));
end;

procedure TFHIRTurtleComposer.ComposeGenomicStudy(parent :  TTurtleComplex; parentType, name : String; value : TFhirGenomicStudy; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GenomicStudy');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'GenomicStudy', 'identifier', value.identifierList[i], false, i);
  ComposeCodeableConcept(this, 'GenomicStudy', 'status', value.statusElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'GenomicStudy', 'type', value.type_List[i], false, i);
  ComposeReference(this, 'GenomicStudy', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'GenomicStudy', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'GenomicStudy', 'startDate', value.startDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'GenomicStudy', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'GenomicStudy', 'referrer', value.referrerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.interpreterList.Count - 1 do
      ComposeReference(this, 'GenomicStudy', 'interpreter', value.interpreterList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(this, 'GenomicStudy', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'GenomicStudy', 'instantiatesCanonical', value.instantiatesCanonicalElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'GenomicStudy', 'instantiatesUri', value.instantiatesUriElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'GenomicStudy', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'GenomicStudy', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.analysisList.Count - 1 do
      ComposeGenomicStudyAnalysis(this, 'GenomicStudy', 'analysis', value.analysisList[i], false, i);
end;

{$ENDIF FHIR_GENOMICSTUDY}
{$IFDEF FHIR_GOAL}
function TFHIRTurtleParser.ParseGoalTarget(obj : TTurtleComplex) : TFhirGoalTarget;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGoalTarget.create;
  try
    ParseGoalTargetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGoalTargetProperties(obj : TTurtleComplex; value : TFhirGoalTarget);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.measure := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Goal.target.measure'));
    if obj.has('detailQuantity', item) then
      value.detail := parseQuantity(item);
    if obj.has('detailRange', item) then
      value.detail := parseRange(item);
    if obj.has('detailCodeableConcept', item) then
      value.detail := parseCodeableConcept(item);
    if obj.has('detailRatio', item) then
      value.detail := parseRatio(item);
    if obj.has('detailString', item) then
      value.detail := parseString(item);
    if obj.has('detailBoolean', item) then
      value.detail := parseBoolean(item);
    if obj.has('detailInteger', item) then
      value.detail := parseInteger(item);
    if obj.has('dueDuration', item) then
      value.due := parseDuration(item);
    if obj.has('dueDate', item) then
      value.due := parseDate(item);
end;

procedure TFHIRTurtleComposer.ComposeGoalTarget(parent :  TTurtleComplex; parentType, name : String; value : TFhirGoalTarget; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GoalTarget');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Goal.target', 'measure', value.measureElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.detail is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Goal.target', 'detailQuantity', TFhirQuantity(value.detail), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.detail is TFhirRange) {6} then
    ComposeRange(this, 'Goal.target', 'detailRange', TFhirRange(value.detail), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.detail is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Goal.target', 'detailCodeableConcept', TFhirCodeableConcept(value.detail), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.detail is TFhirRatio) {6} then
    ComposeRatio(this, 'Goal.target', 'detailRatio', TFhirRatio(value.detail), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.detail is TFhirString) {6} then
    ComposeString(this, 'Goal.target', 'detailString', TFhirString(value.detail), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.detail is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Goal.target', 'detailBoolean', TFhirBoolean(value.detail), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.detail is TFhirInteger) {6} then
    ComposeInteger(this, 'Goal.target', 'detailInteger', TFhirInteger(value.detail), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.due is TFhirDuration) {6} then
    ComposeDuration(this, 'Goal.target', 'dueDuration', TFhirDuration(value.due), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.due is TFhirDate) {6} then
    ComposeDate(this, 'Goal.target', 'dueDate', TFhirDate(value.due), false, -1);
end;

function TFHIRTurtleParser.ParseGoal(obj : TTurtleComplex) : TFhirGoal;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGoal.create;
  try
    ParseGoalProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGoalProperties(obj : TTurtleComplex; value : TFhirGoal);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Goal.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.lifecycleStatusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Goal.lifecycleStatus'), CODES_TFhirGoalLifecycleStatusEnum, SYSTEMS_TFhirGoalLifecycleStatusEnum);
    value.achievementStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Goal.achievementStatus'));
    for item in obj.complexes('http://hl7.org/fhir/Goal.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    value.continuousElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Goal.continuous'));
    value.priority := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Goal.priority'));
    value.description := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Goal.description'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/Goal.subject'));
    if obj.has('startCodeableConcept', item) then
      value.start := parseCodeableConcept(item);
    if obj.has('startDate', item) then
      value.start := parseDate(item);
    for item in obj.complexes('http://hl7.org/fhir/Goal.target') do
      value.targetList.Add(parseGoalTarget(item));
    value.statusDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Goal.statusDate'));
    value.statusReasonElement := ParseString(obj.complex('http://hl7.org/fhir/Goal.statusReason'));
    value.source := ParseReference(obj.complex('http://hl7.org/fhir/Goal.source'));
    for item in obj.complexes('http://hl7.org/fhir/Goal.addresses') do
      value.addressesList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Goal.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/Goal.outcome') do
      value.outcomeList.Add(parseCodeableReference(item));
end;

procedure TFHIRTurtleComposer.ComposeGoal(parent :  TTurtleComplex; parentType, name : String; value : TFhirGoal; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Goal');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Goal', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'Goal', 'lifecycleStatus', value.lifecycleStatusElement, CODES_TFhirGoalLifecycleStatusEnum, SYSTEMS_TFhirGoalLifecycleStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Goal', 'achievementStatus', value.achievementStatusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Goal', 'category', value.categoryList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Goal', 'continuous', value.continuousElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Goal', 'priority', value.priorityElement, false, -1);
  ComposeCodeableConcept(this, 'Goal', 'description', value.descriptionElement, false, -1);
  ComposeReference(this, 'Goal', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.start is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Goal', 'startCodeableConcept', TFhirCodeableConcept(value.start), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.start is TFhirDate) {6} then
    ComposeDate(this, 'Goal', 'startDate', TFhirDate(value.start), false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.targetList.Count - 1 do
      ComposeGoalTarget(this, 'Goal', 'target', value.targetList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'Goal', 'statusDate', value.statusDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Goal', 'statusReason', value.statusReasonElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Goal', 'source', value.sourceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.addressesList.Count - 1 do
      ComposeReference(this, 'Goal', 'addresses', value.addressesList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'Goal', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.outcomeList.Count - 1 do
      ComposeCodeableReference(this, 'Goal', 'outcome', value.outcomeList[i], false, i);
end;

{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
function TFHIRTurtleParser.ParseGraphDefinitionLink(obj : TTurtleComplex) : TFhirGraphDefinitionLink;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGraphDefinitionLink.create;
  try
    ParseGraphDefinitionLinkProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGraphDefinitionLinkProperties(obj : TTurtleComplex; value : TFhirGraphDefinitionLink);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.pathElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.link.path'));
    value.sliceNameElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.link.sliceName'));
    value.minElement := ParseInteger(obj.complex('http://hl7.org/fhir/GraphDefinition.link.min'));
    value.maxElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.link.max'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.link.description'));
    for item in obj.complexes('http://hl7.org/fhir/GraphDefinition.link.target') do
      value.targetList.Add(parseGraphDefinitionLinkTarget(item));
end;

procedure TFHIRTurtleComposer.ComposeGraphDefinitionLink(parent :  TTurtleComplex; parentType, name : String; value : TFhirGraphDefinitionLink; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GraphDefinitionLink');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'GraphDefinition.link', 'path', value.pathElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'GraphDefinition.link', 'sliceName', value.sliceNameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'GraphDefinition.link', 'min', value.minElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'GraphDefinition.link', 'max', value.maxElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'GraphDefinition.link', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.targetList.Count - 1 do
      ComposeGraphDefinitionLinkTarget(this, 'GraphDefinition.link', 'target', value.targetList[i], false, i);
end;

function TFHIRTurtleParser.ParseGraphDefinitionLinkTarget(obj : TTurtleComplex) : TFhirGraphDefinitionLinkTarget;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGraphDefinitionLinkTarget.create;
  try
    ParseGraphDefinitionLinkTargetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGraphDefinitionLinkTargetProperties(obj : TTurtleComplex; value : TFhirGraphDefinitionLinkTarget);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/GraphDefinition.link.target.type'), CODES_TFhirAllResourceTypesEnum, SYSTEMS_TFhirAllResourceTypesEnum);
    value.paramsElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.link.target.params'));
    value.profileElement := ParseCanonical(obj.complex('http://hl7.org/fhir/GraphDefinition.link.target.profile'));
    for item in obj.complexes('http://hl7.org/fhir/GraphDefinition.link.target.compartment') do
      value.compartmentList.Add(parseGraphDefinitionLinkTargetCompartment(item));
    for item in obj.complexes('http://hl7.org/fhir/GraphDefinition.link.target.link') do
      value.link_List.Add(parseGraphDefinitionLink(item));
end;

procedure TFHIRTurtleComposer.ComposeGraphDefinitionLinkTarget(parent :  TTurtleComplex; parentType, name : String; value : TFhirGraphDefinitionLinkTarget; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GraphDefinitionLinkTarget');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'GraphDefinition.link.target', 'type', value.type_Element, CODES_TFhirAllResourceTypesEnum, SYSTEMS_TFhirAllResourceTypesEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'GraphDefinition.link.target', 'params', value.paramsElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'GraphDefinition.link.target', 'profile', value.profileElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.compartmentList.Count - 1 do
      ComposeGraphDefinitionLinkTargetCompartment(this, 'GraphDefinition.link.target', 'compartment', value.compartmentList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.link_List.Count - 1 do
      ComposeGraphDefinitionLink(this, 'GraphDefinition.link.target', 'link', value.link_List[i], false, i);
end;

function TFHIRTurtleParser.ParseGraphDefinitionLinkTargetCompartment(obj : TTurtleComplex) : TFhirGraphDefinitionLinkTargetCompartment;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGraphDefinitionLinkTargetCompartment.create;
  try
    ParseGraphDefinitionLinkTargetCompartmentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGraphDefinitionLinkTargetCompartmentProperties(obj : TTurtleComplex; value : TFhirGraphDefinitionLinkTargetCompartment);
begin
    ParseBackboneElementProperties(obj, value);
    value.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/GraphDefinition.link.target.compartment.use'), CODES_TFhirGraphCompartmentUseEnum, SYSTEMS_TFhirGraphCompartmentUseEnum);
    value.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/GraphDefinition.link.target.compartment.code'), CODES_TFhirCompartmentTypeEnum, SYSTEMS_TFhirCompartmentTypeEnum);
    value.ruleElement := ParseEnum(obj.complex('http://hl7.org/fhir/GraphDefinition.link.target.compartment.rule'), CODES_TFhirGraphCompartmentRuleEnum, SYSTEMS_TFhirGraphCompartmentRuleEnum);
    value.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.link.target.compartment.expression'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.link.target.compartment.description'));
end;

procedure TFHIRTurtleComposer.ComposeGraphDefinitionLinkTargetCompartment(parent :  TTurtleComplex; parentType, name : String; value : TFhirGraphDefinitionLinkTargetCompartment; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GraphDefinitionLinkTargetCompartment');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'GraphDefinition.link.target.compartment', 'use', value.useElement, CODES_TFhirGraphCompartmentUseEnum, SYSTEMS_TFhirGraphCompartmentUseEnum, false, -1);
  ComposeEnum(this, 'GraphDefinition.link.target.compartment', 'code', value.codeElement, CODES_TFhirCompartmentTypeEnum, SYSTEMS_TFhirCompartmentTypeEnum, false, -1);
  ComposeEnum(this, 'GraphDefinition.link.target.compartment', 'rule', value.ruleElement, CODES_TFhirGraphCompartmentRuleEnum, SYSTEMS_TFhirGraphCompartmentRuleEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'GraphDefinition.link.target.compartment', 'expression', value.expressionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'GraphDefinition.link.target.compartment', 'description', value.descriptionElement, false, -1);
end;

function TFHIRTurtleParser.ParseGraphDefinition(obj : TTurtleComplex) : TFhirGraphDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGraphDefinition.create;
  try
    ParseGraphDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGraphDefinitionProperties(obj : TTurtleComplex; value : TFhirGraphDefinition);
var
  item : TTurtleComplex;
begin
    ParseCanonicalResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/GraphDefinition.url'));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.version'));
    if obj.has('versionAlgorithmCoding', item) then
      value.versionAlgorithm := parseCoding(item);
    if obj.has('versionAlgorithmString', item) then
      value.versionAlgorithm := parseString(item);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.title'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/GraphDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/GraphDefinition.experimental'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/GraphDefinition.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/GraphDefinition.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/GraphDefinition.description'));
    for item in obj.complexes('http://hl7.org/fhir/GraphDefinition.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/GraphDefinition.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/GraphDefinition.purpose'));
    value.startElement := ParseEnum(obj.complex('http://hl7.org/fhir/GraphDefinition.start'), CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    value.profileElement := ParseCanonical(obj.complex('http://hl7.org/fhir/GraphDefinition.profile'));
    for item in obj.complexes('http://hl7.org/fhir/GraphDefinition.link') do
      value.link_List.Add(parseGraphDefinitionLink(item));
end;

procedure TFHIRTurtleComposer.ComposeGraphDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirGraphDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GraphDefinition');
  end;
  composeCanonicalResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'GraphDefinition', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'GraphDefinition', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirCoding) {6} then
    ComposeCoding(this, 'GraphDefinition', 'versionAlgorithmCoding', TFhirCoding(value.versionAlgorithm), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirString) {6} then
    ComposeString(this, 'GraphDefinition', 'versionAlgorithmString', TFhirString(value.versionAlgorithm), false, -1);
  ComposeString(this, 'GraphDefinition', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'GraphDefinition', 'title', value.titleElement, false, -1);
  ComposeEnum(this, 'GraphDefinition', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'GraphDefinition', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'GraphDefinition', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'GraphDefinition', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'GraphDefinition', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'GraphDefinition', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'GraphDefinition', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'GraphDefinition', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'GraphDefinition', 'purpose', value.purposeElement, false, -1);
  ComposeEnum(this, 'GraphDefinition', 'start', value.startElement, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'GraphDefinition', 'profile', value.profileElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.link_List.Count - 1 do
      ComposeGraphDefinitionLink(this, 'GraphDefinition', 'link', value.link_List[i], false, i);
end;

{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
function TFHIRTurtleParser.ParseGroupCharacteristic(obj : TTurtleComplex) : TFhirGroupCharacteristic;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGroupCharacteristic.create;
  try
    ParseGroupCharacteristicProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGroupCharacteristicProperties(obj : TTurtleComplex; value : TFhirGroupCharacteristic);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Group.characteristic.code'));
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueRange', item) then
      value.value := parseRange(item);
    if obj.has('valueReference', item) then
      value.value := parseReference(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    value.excludeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Group.characteristic.exclude'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Group.characteristic.period'));
end;

procedure TFHIRTurtleComposer.ComposeGroupCharacteristic(parent :  TTurtleComplex; parentType, name : String; value : TFhirGroupCharacteristic; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GroupCharacteristic');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'Group.characteristic', 'code', value.codeElement, false, -1);
  if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Group.characteristic', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Group.characteristic', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (value.value is TFhirRange) {6} then
    ComposeRange(this, 'Group.characteristic', 'valueRange', TFhirRange(value.value), false, -1)
  else if (value.value is TFhirReference) {6} then
    ComposeReference(this, 'Group.characteristic', 'valueReference', TFhirReference(value.value), false, -1)
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Group.characteristic', 'valueBoolean', TFhirBoolean(value.value), false, -1);
  ComposeBoolean(this, 'Group.characteristic', 'exclude', value.excludeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Group.characteristic', 'period', value.periodElement, false, -1);
end;

function TFHIRTurtleParser.ParseGroupMember(obj : TTurtleComplex) : TFhirGroupMember;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGroupMember.create;
  try
    ParseGroupMemberProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGroupMemberProperties(obj : TTurtleComplex; value : TFhirGroupMember);
begin
    ParseBackboneElementProperties(obj, value);
    value.entity := ParseReference(obj.complex('http://hl7.org/fhir/Group.member.entity'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Group.member.period'));
    value.inactiveElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Group.member.inactive'));
end;

procedure TFHIRTurtleComposer.ComposeGroupMember(parent :  TTurtleComplex; parentType, name : String; value : TFhirGroupMember; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GroupMember');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeReference(this, 'Group.member', 'entity', value.entityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Group.member', 'period', value.periodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Group.member', 'inactive', value.inactiveElement, false, -1);
end;

function TFHIRTurtleParser.ParseGroup(obj : TTurtleComplex) : TFhirGroup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGroup.create;
  try
    ParseGroupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGroupProperties(obj : TTurtleComplex; value : TFhirGroup);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Group.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Group.active'));
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Group.type'), CODES_TFhirGroupTypeEnum, SYSTEMS_TFhirGroupTypeEnum);
    value.membershipElement := ParseEnum(obj.complex('http://hl7.org/fhir/Group.membership'), CODES_TFhirGroupMembershipBasisEnum, SYSTEMS_TFhirGroupMembershipBasisEnum);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Group.code'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Group.name'));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Group.description'));
    value.quantityElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Group.quantity'));
    value.managingEntity := ParseReference(obj.complex('http://hl7.org/fhir/Group.managingEntity'));
    for item in obj.complexes('http://hl7.org/fhir/Group.characteristic') do
      value.characteristicList.Add(parseGroupCharacteristic(item));
    for item in obj.complexes('http://hl7.org/fhir/Group.member') do
      value.memberList.Add(parseGroupMember(item));
end;

procedure TFHIRTurtleComposer.ComposeGroup(parent :  TTurtleComplex; parentType, name : String; value : TFhirGroup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Group');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Group', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Group', 'active', value.activeElement, false, -1);
  ComposeEnum(this, 'Group', 'type', value.type_Element, CODES_TFhirGroupTypeEnum, SYSTEMS_TFhirGroupTypeEnum, false, -1);
  ComposeEnum(this, 'Group', 'membership', value.membershipElement, CODES_TFhirGroupMembershipBasisEnum, SYSTEMS_TFhirGroupMembershipBasisEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Group', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Group', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'Group', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'Group', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Group', 'managingEntity', value.managingEntityElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.characteristicList.Count - 1 do
      ComposeGroupCharacteristic(this, 'Group', 'characteristic', value.characteristicList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.memberList.Count - 1 do
      ComposeGroupMember(this, 'Group', 'member', value.memberList[i], false, i);
end;

{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
function TFHIRTurtleParser.ParseGuidanceResponse(obj : TTurtleComplex) : TFhirGuidanceResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGuidanceResponse.create;
  try
    ParseGuidanceResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGuidanceResponseProperties(obj : TTurtleComplex; value : TFhirGuidanceResponse);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    value.requestIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/GuidanceResponse.requestIdentifier'));
    for item in obj.complexes('http://hl7.org/fhir/GuidanceResponse.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    if obj.has('moduleCanonical', item) then
      value.module := parseCanonical(item);
    if obj.has('moduleCodeableConcept', item) then
      value.module := parseCodeableConcept(item);
    if obj.has('moduleUri', item) then
      value.module := parseUri(item);
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/GuidanceResponse.status'), CODES_TFhirGuidanceResponseStatusEnum, SYSTEMS_TFhirGuidanceResponseStatusEnum);
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/GuidanceResponse.subject'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/GuidanceResponse.encounter'));
    value.occurrenceDateTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/GuidanceResponse.occurrenceDateTime'));
    value.performer := ParseReference(obj.complex('http://hl7.org/fhir/GuidanceResponse.performer'));
    for item in obj.complexes('http://hl7.org/fhir/GuidanceResponse.reason') do
      value.reasonList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/GuidanceResponse.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/GuidanceResponse.evaluationMessage') do
      value.evaluationMessageList.Add(parseReference(item));
    value.outputParameters := ParseReference(obj.complex('http://hl7.org/fhir/GuidanceResponse.outputParameters'));
    value.result := ParseReference(obj.complex('http://hl7.org/fhir/GuidanceResponse.result'));
    for item in obj.complexes('http://hl7.org/fhir/GuidanceResponse.dataRequirement') do
      value.dataRequirementList.Add(parseDataRequirement(item));
end;

procedure TFHIRTurtleComposer.ComposeGuidanceResponse(parent :  TTurtleComplex; parentType, name : String; value : TFhirGuidanceResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GuidanceResponse');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'GuidanceResponse', 'requestIdentifier', value.requestIdentifierElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'GuidanceResponse', 'identifier', value.identifierList[i], false, i);
  if (value.module is TFhirCanonical) {6} then
    ComposeCanonical(this, 'GuidanceResponse', 'moduleCanonical', TFhirCanonical(value.module), false, -1)
  else if (value.module is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'GuidanceResponse', 'moduleCodeableConcept', TFhirCodeableConcept(value.module), false, -1)
  else if (value.module is TFhirUri) {6} then
    ComposeUri(this, 'GuidanceResponse', 'moduleUri', TFhirUri(value.module), false, -1);
  ComposeEnum(this, 'GuidanceResponse', 'status', value.statusElement, CODES_TFhirGuidanceResponseStatusEnum, SYSTEMS_TFhirGuidanceResponseStatusEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'GuidanceResponse', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'GuidanceResponse', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'GuidanceResponse', 'occurrenceDateTime', value.occurrenceDateTimeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'GuidanceResponse', 'performer', value.performerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(this, 'GuidanceResponse', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'GuidanceResponse', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.evaluationMessageList.Count - 1 do
      ComposeReference(this, 'GuidanceResponse', 'evaluationMessage', value.evaluationMessageList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'GuidanceResponse', 'outputParameters', value.outputParametersElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'GuidanceResponse', 'result', value.resultElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dataRequirementList.Count - 1 do
      ComposeDataRequirement(this, 'GuidanceResponse', 'dataRequirement', value.dataRequirementList[i], false, i);
end;

{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
function TFHIRTurtleParser.ParseHealthcareServiceEligibility(obj : TTurtleComplex) : TFhirHealthcareServiceEligibility;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirHealthcareServiceEligibility.create;
  try
    ParseHealthcareServiceEligibilityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseHealthcareServiceEligibilityProperties(obj : TTurtleComplex; value : TFhirHealthcareServiceEligibility);
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/HealthcareService.eligibility.code'));
    value.commentElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/HealthcareService.eligibility.comment'));
end;

procedure TFHIRTurtleComposer.ComposeHealthcareServiceEligibility(parent :  TTurtleComplex; parentType, name : String; value : TFhirHealthcareServiceEligibility; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:HealthcareServiceEligibility');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'HealthcareService.eligibility', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'HealthcareService.eligibility', 'comment', value.commentElement, false, -1);
end;

function TFHIRTurtleParser.ParseHealthcareService(obj : TTurtleComplex) : TFhirHealthcareService;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirHealthcareService.create;
  try
    ParseHealthcareServiceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseHealthcareServiceProperties(obj : TTurtleComplex; value : TFhirHealthcareService);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/HealthcareService.active'));
    value.providedBy := ParseReference(obj.complex('http://hl7.org/fhir/HealthcareService.providedBy'));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.offeredIn') do
      value.offeredInList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.type') do
      value.type_List.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.specialty') do
      value.specialtyList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.location') do
      value.locationList.Add(parseReference(item));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/HealthcareService.name'));
    value.commentElement := ParseString(obj.complex('http://hl7.org/fhir/HealthcareService.comment'));
    value.extraDetailsElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/HealthcareService.extraDetails'));
    value.photo := ParseAttachment(obj.complex('http://hl7.org/fhir/HealthcareService.photo'));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.contact') do
      value.contactList.Add(parseExtendedContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.coverageArea') do
      value.coverageAreaList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.serviceProvisionCode') do
      value.serviceProvisionCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.eligibility') do
      value.eligibilityList.Add(parseHealthcareServiceEligibility(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.program') do
      value.program_List.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.characteristic') do
      value.characteristicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.communication') do
      value.communicationList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.referralMethod') do
      value.referralMethodList.Add(parseCodeableConcept(item));
    value.appointmentRequiredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/HealthcareService.appointmentRequired'));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.availability') do
      value.availabilityList.Add(parseAvailability(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.endpoint') do
      value.endpointList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeHealthcareService(parent :  TTurtleComplex; parentType, name : String; value : TFhirHealthcareService; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:HealthcareService');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'HealthcareService', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'HealthcareService', 'active', value.activeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'HealthcareService', 'providedBy', value.providedByElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.offeredInList.Count - 1 do
      ComposeReference(this, 'HealthcareService', 'offeredIn', value.offeredInList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'category', value.categoryList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'type', value.type_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.specialtyList.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'specialty', value.specialtyList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.locationList.Count - 1 do
      ComposeReference(this, 'HealthcareService', 'location', value.locationList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'HealthcareService', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'HealthcareService', 'comment', value.commentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'HealthcareService', 'extraDetails', value.extraDetailsElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAttachment(this, 'HealthcareService', 'photo', value.photoElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeExtendedContactDetail(this, 'HealthcareService', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.coverageAreaList.Count - 1 do
      ComposeReference(this, 'HealthcareService', 'coverageArea', value.coverageAreaList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.serviceProvisionCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'serviceProvisionCode', value.serviceProvisionCodeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.eligibilityList.Count - 1 do
      ComposeHealthcareServiceEligibility(this, 'HealthcareService', 'eligibility', value.eligibilityList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.program_List.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'program', value.program_List[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.characteristicList.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'characteristic', value.characteristicList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.communicationList.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'communication', value.communicationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.referralMethodList.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'referralMethod', value.referralMethodList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'HealthcareService', 'appointmentRequired', value.appointmentRequiredElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.availabilityList.Count - 1 do
      ComposeAvailability(this, 'HealthcareService', 'availability', value.availabilityList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endpointList.Count - 1 do
      ComposeReference(this, 'HealthcareService', 'endpoint', value.endpointList[i], false, i);
end;

{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGSELECTION}
function TFHIRTurtleParser.ParseImagingSelectionPerformer(obj : TTurtleComplex) : TFhirImagingSelectionPerformer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingSelectionPerformer.create;
  try
    ParseImagingSelectionPerformerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingSelectionPerformerProperties(obj : TTurtleComplex; value : TFhirImagingSelectionPerformer);
begin
    ParseBackboneElementProperties(obj, value);
    value.function_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ImagingSelection.performer.function'));
    value.actor := ParseReference(obj.complex('http://hl7.org/fhir/ImagingSelection.performer.actor'));
end;

procedure TFHIRTurtleComposer.ComposeImagingSelectionPerformer(parent :  TTurtleComplex; parentType, name : String; value : TFhirImagingSelectionPerformer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingSelectionPerformer');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ImagingSelection.performer', 'function', value.function_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'ImagingSelection.performer', 'actor', value.actorElement, false, -1);
end;

function TFHIRTurtleParser.ParseImagingSelectionInstance(obj : TTurtleComplex) : TFhirImagingSelectionInstance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingSelectionInstance.create;
  try
    ParseImagingSelectionInstanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingSelectionInstanceProperties(obj : TTurtleComplex; value : TFhirImagingSelectionInstance);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.uidElement := ParseId(obj.complex('http://hl7.org/fhir/ImagingSelection.instance.uid'));
    value.numberElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ImagingSelection.instance.number'));
    value.sopClass := ParseCoding(obj.complex('http://hl7.org/fhir/ImagingSelection.instance.sopClass'));
    for item in obj.complexes('http://hl7.org/fhir/ImagingSelection.instance.subset') do
      value.subsetList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/ImagingSelection.instance.imageRegion') do
      value.imageRegionList.Add(parseImagingSelectionInstanceImageRegion(item));
end;

procedure TFHIRTurtleComposer.ComposeImagingSelectionInstance(parent :  TTurtleComplex; parentType, name : String; value : TFhirImagingSelectionInstance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingSelectionInstance');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeId(this, 'ImagingSelection.instance', 'uid', value.uidElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'ImagingSelection.instance', 'number', value.numberElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'ImagingSelection.instance', 'sopClass', value.sopClassElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subsetList.Count - 1 do
      ComposeString(this, 'ImagingSelection.instance', 'subset', value.subsetList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.imageRegionList.Count - 1 do
      ComposeImagingSelectionInstanceImageRegion(this, 'ImagingSelection.instance', 'imageRegion', value.imageRegionList[i], false, i);
end;

function TFHIRTurtleParser.ParseImagingSelectionInstanceImageRegion(obj : TTurtleComplex) : TFhirImagingSelectionInstanceImageRegion;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingSelectionInstanceImageRegion.create;
  try
    ParseImagingSelectionInstanceImageRegionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingSelectionInstanceImageRegionProperties(obj : TTurtleComplex; value : TFhirImagingSelectionInstanceImageRegion);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.regionTypeElement := ParseEnum(obj.complex('http://hl7.org/fhir/ImagingSelection.instance.imageRegion.regionType'), CODES_TFhirImagingSelection2DGraphicTypeEnum, SYSTEMS_TFhirImagingSelection2DGraphicTypeEnum);
    for item in obj.complexes('http://hl7.org/fhir/ImagingSelection.instance.imageRegion.coordinate') do
      value.coordinateList.Add(parseDecimal(item));
end;

procedure TFHIRTurtleComposer.ComposeImagingSelectionInstanceImageRegion(parent :  TTurtleComplex; parentType, name : String; value : TFhirImagingSelectionInstanceImageRegion; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingSelectionInstanceImageRegion');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'ImagingSelection.instance.imageRegion', 'regionType', value.regionTypeElement, CODES_TFhirImagingSelection2DGraphicTypeEnum, SYSTEMS_TFhirImagingSelection2DGraphicTypeEnum, false, -1);
  for i := 0 to value.coordinateList.Count - 1 do
      ComposeDecimal(this, 'ImagingSelection.instance.imageRegion', 'coordinate', value.coordinateList[i], false, i);
end;

function TFHIRTurtleParser.ParseImagingSelectionImageRegion(obj : TTurtleComplex) : TFhirImagingSelectionImageRegion;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingSelectionImageRegion.create;
  try
    ParseImagingSelectionImageRegionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingSelectionImageRegionProperties(obj : TTurtleComplex; value : TFhirImagingSelectionImageRegion);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.regionTypeElement := ParseEnum(obj.complex('http://hl7.org/fhir/ImagingSelection.imageRegion.regionType'), CODES_TFhirImagingSelection3DGraphicTypeEnum, SYSTEMS_TFhirImagingSelection3DGraphicTypeEnum);
    for item in obj.complexes('http://hl7.org/fhir/ImagingSelection.imageRegion.coordinate') do
      value.coordinateList.Add(parseDecimal(item));
end;

procedure TFHIRTurtleComposer.ComposeImagingSelectionImageRegion(parent :  TTurtleComplex; parentType, name : String; value : TFhirImagingSelectionImageRegion; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingSelectionImageRegion');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'ImagingSelection.imageRegion', 'regionType', value.regionTypeElement, CODES_TFhirImagingSelection3DGraphicTypeEnum, SYSTEMS_TFhirImagingSelection3DGraphicTypeEnum, false, -1);
  for i := 0 to value.coordinateList.Count - 1 do
      ComposeDecimal(this, 'ImagingSelection.imageRegion', 'coordinate', value.coordinateList[i], false, i);
end;

function TFHIRTurtleParser.ParseImagingSelection(obj : TTurtleComplex) : TFhirImagingSelection;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingSelection.create;
  try
    ParseImagingSelectionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingSelectionProperties(obj : TTurtleComplex; value : TFhirImagingSelection);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/ImagingSelection.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ImagingSelection.status'), CODES_TFhirImagingSelectionStatusEnum, SYSTEMS_TFhirImagingSelectionStatusEnum);
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/ImagingSelection.subject'));
    value.issuedElement := ParseInstant(obj.complex('http://hl7.org/fhir/ImagingSelection.issued'));
    for item in obj.complexes('http://hl7.org/fhir/ImagingSelection.performer') do
      value.performerList.Add(parseImagingSelectionPerformer(item));
    for item in obj.complexes('http://hl7.org/fhir/ImagingSelection.basedOn') do
      value.basedOnList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ImagingSelection.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ImagingSelection.code'));
    value.studyUidElement := ParseId(obj.complex('http://hl7.org/fhir/ImagingSelection.studyUid'));
    for item in obj.complexes('http://hl7.org/fhir/ImagingSelection.derivedFrom') do
      value.derivedFromList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ImagingSelection.endpoint') do
      value.endpointList.Add(parseReference(item));
    value.seriesUidElement := ParseId(obj.complex('http://hl7.org/fhir/ImagingSelection.seriesUid'));
    value.seriesNumberElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ImagingSelection.seriesNumber'));
    value.frameOfReferenceUidElement := ParseId(obj.complex('http://hl7.org/fhir/ImagingSelection.frameOfReferenceUid'));
    value.bodySite := ParseCodeableReference(obj.complex('http://hl7.org/fhir/ImagingSelection.bodySite'));
    for item in obj.complexes('http://hl7.org/fhir/ImagingSelection.focus') do
      value.focusList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ImagingSelection.instance') do
      value.instanceList.Add(parseImagingSelectionInstance(item));
    for item in obj.complexes('http://hl7.org/fhir/ImagingSelection.imageRegion') do
      value.imageRegionList.Add(parseImagingSelectionImageRegion(item));
end;

procedure TFHIRTurtleComposer.ComposeImagingSelection(parent :  TTurtleComplex; parentType, name : String; value : TFhirImagingSelection; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingSelection');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ImagingSelection', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'ImagingSelection', 'status', value.statusElement, CODES_TFhirImagingSelectionStatusEnum, SYSTEMS_TFhirImagingSelectionStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'ImagingSelection', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'ImagingSelection', 'issued', value.issuedElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeImagingSelectionPerformer(this, 'ImagingSelection', 'performer', value.performerList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'ImagingSelection', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'ImagingSelection', 'category', value.categoryList[i], false, i);
  ComposeCodeableConcept(this, 'ImagingSelection', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'ImagingSelection', 'studyUid', value.studyUidElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.derivedFromList.Count - 1 do
      ComposeReference(this, 'ImagingSelection', 'derivedFrom', value.derivedFromList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.endpointList.Count - 1 do
      ComposeReference(this, 'ImagingSelection', 'endpoint', value.endpointList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'ImagingSelection', 'seriesUid', value.seriesUidElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'ImagingSelection', 'seriesNumber', value.seriesNumberElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'ImagingSelection', 'frameOfReferenceUid', value.frameOfReferenceUidElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(this, 'ImagingSelection', 'bodySite', value.bodySiteElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.focusList.Count - 1 do
      ComposeReference(this, 'ImagingSelection', 'focus', value.focusList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instanceList.Count - 1 do
      ComposeImagingSelectionInstance(this, 'ImagingSelection', 'instance', value.instanceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.imageRegionList.Count - 1 do
      ComposeImagingSelectionImageRegion(this, 'ImagingSelection', 'imageRegion', value.imageRegionList[i], false, i);
end;

{$ENDIF FHIR_IMAGINGSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
function TFHIRTurtleParser.ParseImagingStudySeries(obj : TTurtleComplex) : TFhirImagingStudySeries;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingStudySeries.create;
  try
    ParseImagingStudySeriesProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingStudySeriesProperties(obj : TTurtleComplex; value : TFhirImagingStudySeries);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.uidElement := ParseId(obj.complex('http://hl7.org/fhir/ImagingStudy.series.uid'));
    value.numberElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ImagingStudy.series.number'));
    value.modality := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ImagingStudy.series.modality'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ImagingStudy.series.description'));
    value.numberOfInstancesElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ImagingStudy.series.numberOfInstances'));
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.series.endpoint') do
      value.endpointList.Add(parseReference(item));
    value.bodySite := ParseCodeableReference(obj.complex('http://hl7.org/fhir/ImagingStudy.series.bodySite'));
    value.laterality := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ImagingStudy.series.laterality'));
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.series.specimen') do
      value.specimenList.Add(parseReference(item));
    value.startedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ImagingStudy.series.started'));
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.series.performer') do
      value.performerList.Add(parseImagingStudySeriesPerformer(item));
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.series.instance') do
      value.instanceList.Add(parseImagingStudySeriesInstance(item));
end;

procedure TFHIRTurtleComposer.ComposeImagingStudySeries(parent :  TTurtleComplex; parentType, name : String; value : TFhirImagingStudySeries; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingStudySeries');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeId(this, 'ImagingStudy.series', 'uid', value.uidElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'ImagingStudy.series', 'number', value.numberElement, false, -1);
  ComposeCodeableConcept(this, 'ImagingStudy.series', 'modality', value.modalityElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImagingStudy.series', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'ImagingStudy.series', 'numberOfInstances', value.numberOfInstancesElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.endpointList.Count - 1 do
      ComposeReference(this, 'ImagingStudy.series', 'endpoint', value.endpointList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(this, 'ImagingStudy.series', 'bodySite', value.bodySiteElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ImagingStudy.series', 'laterality', value.lateralityElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.specimenList.Count - 1 do
      ComposeReference(this, 'ImagingStudy.series', 'specimen', value.specimenList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ImagingStudy.series', 'started', value.startedElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeImagingStudySeriesPerformer(this, 'ImagingStudy.series', 'performer', value.performerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.instanceList.Count - 1 do
      ComposeImagingStudySeriesInstance(this, 'ImagingStudy.series', 'instance', value.instanceList[i], false, i);
end;

function TFHIRTurtleParser.ParseImagingStudySeriesPerformer(obj : TTurtleComplex) : TFhirImagingStudySeriesPerformer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingStudySeriesPerformer.create;
  try
    ParseImagingStudySeriesPerformerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingStudySeriesPerformerProperties(obj : TTurtleComplex; value : TFhirImagingStudySeriesPerformer);
begin
    ParseBackboneElementProperties(obj, value);
    value.function_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ImagingStudy.series.performer.function'));
    value.actor := ParseReference(obj.complex('http://hl7.org/fhir/ImagingStudy.series.performer.actor'));
end;

procedure TFHIRTurtleComposer.ComposeImagingStudySeriesPerformer(parent :  TTurtleComplex; parentType, name : String; value : TFhirImagingStudySeriesPerformer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingStudySeriesPerformer');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ImagingStudy.series.performer', 'function', value.function_Element, false, -1);
  ComposeReference(this, 'ImagingStudy.series.performer', 'actor', value.actorElement, false, -1);
end;

function TFHIRTurtleParser.ParseImagingStudySeriesInstance(obj : TTurtleComplex) : TFhirImagingStudySeriesInstance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingStudySeriesInstance.create;
  try
    ParseImagingStudySeriesInstanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingStudySeriesInstanceProperties(obj : TTurtleComplex; value : TFhirImagingStudySeriesInstance);
begin
    ParseBackboneElementProperties(obj, value);
    value.uidElement := ParseId(obj.complex('http://hl7.org/fhir/ImagingStudy.series.instance.uid'));
    value.sopClass := ParseCoding(obj.complex('http://hl7.org/fhir/ImagingStudy.series.instance.sopClass'));
    value.numberElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ImagingStudy.series.instance.number'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ImagingStudy.series.instance.title'));
end;

procedure TFHIRTurtleComposer.ComposeImagingStudySeriesInstance(parent :  TTurtleComplex; parentType, name : String; value : TFhirImagingStudySeriesInstance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingStudySeriesInstance');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeId(this, 'ImagingStudy.series.instance', 'uid', value.uidElement, false, -1);
  ComposeCoding(this, 'ImagingStudy.series.instance', 'sopClass', value.sopClassElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(this, 'ImagingStudy.series.instance', 'number', value.numberElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImagingStudy.series.instance', 'title', value.titleElement, false, -1);
end;

function TFHIRTurtleParser.ParseImagingStudy(obj : TTurtleComplex) : TFhirImagingStudy;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingStudy.create;
  try
    ParseImagingStudyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingStudyProperties(obj : TTurtleComplex; value : TFhirImagingStudy);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ImagingStudy.status'), CODES_TFhirImagingStudyStatusEnum, SYSTEMS_TFhirImagingStudyStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.modality') do
      value.modalityList.Add(parseCodeableConcept(item));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/ImagingStudy.subject'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/ImagingStudy.encounter'));
    value.startedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ImagingStudy.started'));
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.basedOn') do
      value.basedOnList.Add(parseReference(item));
    value.referrer := ParseReference(obj.complex('http://hl7.org/fhir/ImagingStudy.referrer'));
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.interpreter') do
      value.interpreterList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.endpoint') do
      value.endpointList.Add(parseReference(item));
    value.numberOfSeriesElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ImagingStudy.numberOfSeries'));
    value.numberOfInstancesElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ImagingStudy.numberOfInstances'));
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.procedure') do
      value.procedure_List.Add(parseCodeableReference(item));
    value.location := ParseReference(obj.complex('http://hl7.org/fhir/ImagingStudy.location'));
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.reason') do
      value.reasonList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.note') do
      value.noteList.Add(parseAnnotation(item));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ImagingStudy.description'));
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.series') do
      value.seriesList.Add(parseImagingStudySeries(item));
end;

procedure TFHIRTurtleComposer.ComposeImagingStudy(parent :  TTurtleComplex; parentType, name : String; value : TFhirImagingStudy; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingStudy');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ImagingStudy', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'ImagingStudy', 'status', value.statusElement, CODES_TFhirImagingStudyStatusEnum, SYSTEMS_TFhirImagingStudyStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.modalityList.Count - 1 do
      ComposeCodeableConcept(this, 'ImagingStudy', 'modality', value.modalityList[i], false, i);
  ComposeReference(this, 'ImagingStudy', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'ImagingStudy', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ImagingStudy', 'started', value.startedElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'ImagingStudy', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'ImagingStudy', 'referrer', value.referrerElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.interpreterList.Count - 1 do
      ComposeReference(this, 'ImagingStudy', 'interpreter', value.interpreterList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.endpointList.Count - 1 do
      ComposeReference(this, 'ImagingStudy', 'endpoint', value.endpointList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'ImagingStudy', 'numberOfSeries', value.numberOfSeriesElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'ImagingStudy', 'numberOfInstances', value.numberOfInstancesElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.procedure_List.Count - 1 do
      ComposeCodeableReference(this, 'ImagingStudy', 'procedure', value.procedure_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'ImagingStudy', 'location', value.locationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(this, 'ImagingStudy', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'ImagingStudy', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImagingStudy', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.seriesList.Count - 1 do
      ComposeImagingStudySeries(this, 'ImagingStudy', 'series', value.seriesList[i], false, i);
end;

{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
function TFHIRTurtleParser.ParseImmunizationPerformer(obj : TTurtleComplex) : TFhirImmunizationPerformer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationPerformer.create;
  try
    ParseImmunizationPerformerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationPerformerProperties(obj : TTurtleComplex; value : TFhirImmunizationPerformer);
begin
    ParseBackboneElementProperties(obj, value);
    value.function_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.performer.function'));
    value.actor := ParseReference(obj.complex('http://hl7.org/fhir/Immunization.performer.actor'));
end;

procedure TFHIRTurtleComposer.ComposeImmunizationPerformer(parent :  TTurtleComplex; parentType, name : String; value : TFhirImmunizationPerformer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationPerformer');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Immunization.performer', 'function', value.function_Element, false, -1);
  ComposeReference(this, 'Immunization.performer', 'actor', value.actorElement, false, -1);
end;

function TFHIRTurtleParser.ParseImmunizationProgramEligibility(obj : TTurtleComplex) : TFhirImmunizationProgramEligibility;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationProgramEligibility.create;
  try
    ParseImmunizationProgramEligibilityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationProgramEligibilityProperties(obj : TTurtleComplex; value : TFhirImmunizationProgramEligibility);
begin
    ParseBackboneElementProperties(obj, value);
    value.program_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.programEligibility.program'));
    value.programStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.programEligibility.programStatus'));
end;

procedure TFHIRTurtleComposer.ComposeImmunizationProgramEligibility(parent :  TTurtleComplex; parentType, name : String; value : TFhirImmunizationProgramEligibility; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationProgramEligibility');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'Immunization.programEligibility', 'program', value.program_Element, false, -1);
  ComposeCodeableConcept(this, 'Immunization.programEligibility', 'programStatus', value.programStatusElement, false, -1);
end;

function TFHIRTurtleParser.ParseImmunizationReaction(obj : TTurtleComplex) : TFhirImmunizationReaction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationReaction.create;
  try
    ParseImmunizationReactionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationReactionProperties(obj : TTurtleComplex; value : TFhirImmunizationReaction);
begin
    ParseBackboneElementProperties(obj, value);
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Immunization.reaction.date'));
    value.manifestation := ParseCodeableReference(obj.complex('http://hl7.org/fhir/Immunization.reaction.manifestation'));
    value.reportedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Immunization.reaction.reported'));
end;

procedure TFHIRTurtleComposer.ComposeImmunizationReaction(parent :  TTurtleComplex; parentType, name : String; value : TFhirImmunizationReaction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationReaction');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Immunization.reaction', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(this, 'Immunization.reaction', 'manifestation', value.manifestationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Immunization.reaction', 'reported', value.reportedElement, false, -1);
end;

function TFHIRTurtleParser.ParseImmunizationProtocolApplied(obj : TTurtleComplex) : TFhirImmunizationProtocolApplied;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationProtocolApplied.create;
  try
    ParseImmunizationProtocolAppliedProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationProtocolAppliedProperties(obj : TTurtleComplex; value : TFhirImmunizationProtocolApplied);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.seriesElement := ParseString(obj.complex('http://hl7.org/fhir/Immunization.protocolApplied.series'));
    value.authority := ParseReference(obj.complex('http://hl7.org/fhir/Immunization.protocolApplied.authority'));
    for item in obj.complexes('http://hl7.org/fhir/Immunization.protocolApplied.targetDisease') do
      value.targetDiseaseList.Add(parseCodeableConcept(item));
    value.doseNumberElement := ParseString(obj.complex('http://hl7.org/fhir/Immunization.protocolApplied.doseNumber'));
    value.seriesDosesElement := ParseString(obj.complex('http://hl7.org/fhir/Immunization.protocolApplied.seriesDoses'));
end;

procedure TFHIRTurtleComposer.ComposeImmunizationProtocolApplied(parent :  TTurtleComplex; parentType, name : String; value : TFhirImmunizationProtocolApplied; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationProtocolApplied');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Immunization.protocolApplied', 'series', value.seriesElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Immunization.protocolApplied', 'authority', value.authorityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.targetDiseaseList.Count - 1 do
      ComposeCodeableConcept(this, 'Immunization.protocolApplied', 'targetDisease', value.targetDiseaseList[i], false, i);
  ComposeString(this, 'Immunization.protocolApplied', 'doseNumber', value.doseNumberElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Immunization.protocolApplied', 'seriesDoses', value.seriesDosesElement, false, -1);
end;

function TFHIRTurtleParser.ParseImmunization(obj : TTurtleComplex) : TFhirImmunization;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunization.create;
  try
    ParseImmunizationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationProperties(obj : TTurtleComplex; value : TFhirImmunization);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Immunization.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/Immunization.basedOn') do
      value.basedOnList.Add(parseReference(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Immunization.status'), CODES_TFhirImmunizationStatusCodesEnum, SYSTEMS_TFhirImmunizationStatusCodesEnum);
    value.statusReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.statusReason'));
    value.vaccineCode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.vaccineCode'));
    value.administeredProduct := ParseCodeableReference(obj.complex('http://hl7.org/fhir/Immunization.administeredProduct'));
    value.manufacturer := ParseCodeableReference(obj.complex('http://hl7.org/fhir/Immunization.manufacturer'));
    value.lotNumberElement := ParseString(obj.complex('http://hl7.org/fhir/Immunization.lotNumber'));
    value.expirationDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Immunization.expirationDate'));
    value.patient := ParseReference(obj.complex('http://hl7.org/fhir/Immunization.patient'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/Immunization.encounter'));
    for item in obj.complexes('http://hl7.org/fhir/Immunization.supportingInformation') do
      value.supportingInformationList.Add(parseReference(item));
    if obj.has('occurrenceDateTime', item) then
      value.occurrence := parseDateTime(item);
    if obj.has('occurrenceString', item) then
      value.occurrence := parseString(item);
    value.primarySourceElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Immunization.primarySource'));
    value.informationSource := ParseCodeableReference(obj.complex('http://hl7.org/fhir/Immunization.informationSource'));
    value.location := ParseReference(obj.complex('http://hl7.org/fhir/Immunization.location'));
    value.site := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.site'));
    value.route := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.route'));
    value.doseQuantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Immunization.doseQuantity'));
    for item in obj.complexes('http://hl7.org/fhir/Immunization.performer') do
      value.performerList.Add(parseImmunizationPerformer(item));
    for item in obj.complexes('http://hl7.org/fhir/Immunization.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/Immunization.reason') do
      value.reasonList.Add(parseCodeableReference(item));
    value.isSubpotentElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Immunization.isSubpotent'));
    for item in obj.complexes('http://hl7.org/fhir/Immunization.subpotentReason') do
      value.subpotentReasonList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Immunization.programEligibility') do
      value.programEligibilityList.Add(parseImmunizationProgramEligibility(item));
    value.fundingSource := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.fundingSource'));
    for item in obj.complexes('http://hl7.org/fhir/Immunization.reaction') do
      value.reactionList.Add(parseImmunizationReaction(item));
    for item in obj.complexes('http://hl7.org/fhir/Immunization.protocolApplied') do
      value.protocolAppliedList.Add(parseImmunizationProtocolApplied(item));
end;

procedure TFHIRTurtleComposer.ComposeImmunization(parent :  TTurtleComplex; parentType, name : String; value : TFhirImmunization; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Immunization');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Immunization', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'Immunization', 'basedOn', value.basedOnList[i], false, i);
  ComposeEnum(this, 'Immunization', 'status', value.statusElement, CODES_TFhirImmunizationStatusCodesEnum, SYSTEMS_TFhirImmunizationStatusCodesEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Immunization', 'statusReason', value.statusReasonElement, false, -1);
  ComposeCodeableConcept(this, 'Immunization', 'vaccineCode', value.vaccineCodeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(this, 'Immunization', 'administeredProduct', value.administeredProductElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(this, 'Immunization', 'manufacturer', value.manufacturerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Immunization', 'lotNumber', value.lotNumberElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'Immunization', 'expirationDate', value.expirationDateElement, false, -1);
  ComposeReference(this, 'Immunization', 'patient', value.patientElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Immunization', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInformationList.Count - 1 do
      ComposeReference(this, 'Immunization', 'supportingInformation', value.supportingInformationList[i], false, i);
  if (value.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Immunization', 'occurrenceDateTime', TFhirDateTime(value.occurrence), false, -1)
  else if (value.occurrence is TFhirString) {6} then
    ComposeString(this, 'Immunization', 'occurrenceString', TFhirString(value.occurrence), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Immunization', 'primarySource', value.primarySourceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(this, 'Immunization', 'informationSource', value.informationSourceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Immunization', 'location', value.locationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Immunization', 'site', value.siteElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Immunization', 'route', value.routeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Immunization', 'doseQuantity', value.doseQuantityElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeImmunizationPerformer(this, 'Immunization', 'performer', value.performerList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'Immunization', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(this, 'Immunization', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Immunization', 'isSubpotent', value.isSubpotentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subpotentReasonList.Count - 1 do
      ComposeCodeableConcept(this, 'Immunization', 'subpotentReason', value.subpotentReasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.programEligibilityList.Count - 1 do
      ComposeImmunizationProgramEligibility(this, 'Immunization', 'programEligibility', value.programEligibilityList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Immunization', 'fundingSource', value.fundingSourceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reactionList.Count - 1 do
      ComposeImmunizationReaction(this, 'Immunization', 'reaction', value.reactionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.protocolAppliedList.Count - 1 do
      ComposeImmunizationProtocolApplied(this, 'Immunization', 'protocolApplied', value.protocolAppliedList[i], false, i);
end;

{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
function TFHIRTurtleParser.ParseImmunizationEvaluation(obj : TTurtleComplex) : TFhirImmunizationEvaluation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationEvaluation.create;
  try
    ParseImmunizationEvaluationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationEvaluationProperties(obj : TTurtleComplex; value : TFhirImmunizationEvaluation);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationEvaluation.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ImmunizationEvaluation.status'), CODES_TFhirImmunizationEvaluationStatusCodesEnum, SYSTEMS_TFhirImmunizationEvaluationStatusCodesEnum);
    value.patient := ParseReference(obj.complex('http://hl7.org/fhir/ImmunizationEvaluation.patient'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ImmunizationEvaluation.date'));
    value.authority := ParseReference(obj.complex('http://hl7.org/fhir/ImmunizationEvaluation.authority'));
    value.targetDisease := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ImmunizationEvaluation.targetDisease'));
    value.immunizationEvent := ParseReference(obj.complex('http://hl7.org/fhir/ImmunizationEvaluation.immunizationEvent'));
    value.doseStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ImmunizationEvaluation.doseStatus'));
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationEvaluation.doseStatusReason') do
      value.doseStatusReasonList.Add(parseCodeableConcept(item));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ImmunizationEvaluation.description'));
    value.seriesElement := ParseString(obj.complex('http://hl7.org/fhir/ImmunizationEvaluation.series'));
    value.doseNumberElement := ParseString(obj.complex('http://hl7.org/fhir/ImmunizationEvaluation.doseNumber'));
    value.seriesDosesElement := ParseString(obj.complex('http://hl7.org/fhir/ImmunizationEvaluation.seriesDoses'));
end;

procedure TFHIRTurtleComposer.ComposeImmunizationEvaluation(parent :  TTurtleComplex; parentType, name : String; value : TFhirImmunizationEvaluation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationEvaluation');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ImmunizationEvaluation', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'ImmunizationEvaluation', 'status', value.statusElement, CODES_TFhirImmunizationEvaluationStatusCodesEnum, SYSTEMS_TFhirImmunizationEvaluationStatusCodesEnum, false, -1);
  ComposeReference(this, 'ImmunizationEvaluation', 'patient', value.patientElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'ImmunizationEvaluation', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ImmunizationEvaluation', 'authority', value.authorityElement, false, -1);
  ComposeCodeableConcept(this, 'ImmunizationEvaluation', 'targetDisease', value.targetDiseaseElement, false, -1);
  ComposeReference(this, 'ImmunizationEvaluation', 'immunizationEvent', value.immunizationEventElement, false, -1);
  ComposeCodeableConcept(this, 'ImmunizationEvaluation', 'doseStatus', value.doseStatusElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.doseStatusReasonList.Count - 1 do
      ComposeCodeableConcept(this, 'ImmunizationEvaluation', 'doseStatusReason', value.doseStatusReasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImmunizationEvaluation', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImmunizationEvaluation', 'series', value.seriesElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImmunizationEvaluation', 'doseNumber', value.doseNumberElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImmunizationEvaluation', 'seriesDoses', value.seriesDosesElement, false, -1);
end;

{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
function TFHIRTurtleParser.ParseImmunizationRecommendationRecommendation(obj : TTurtleComplex) : TFhirImmunizationRecommendationRecommendation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    ParseImmunizationRecommendationRecommendationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationRecommendationRecommendationProperties(obj : TTurtleComplex; value : TFhirImmunizationRecommendationRecommendation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.vaccineCode') do
      value.vaccineCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.targetDisease') do
      value.targetDiseaseList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.contraindicatedVaccineCode') do
      value.contraindicatedVaccineCodeList.Add(parseCodeableConcept(item));
    value.forecastStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.forecastStatus'));
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.forecastReason') do
      value.forecastReasonList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.dateCriterion') do
      value.dateCriterionList.Add(parseImmunizationRecommendationRecommendationDateCriterion(item));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.description'));
    value.seriesElement := ParseString(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.series'));
    value.doseNumberElement := ParseString(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.doseNumber'));
    value.seriesDosesElement := ParseString(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.seriesDoses'));
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.supportingImmunization') do
      value.supportingImmunizationList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.supportingPatientInformation') do
      value.supportingPatientInformationList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeImmunizationRecommendationRecommendation(parent :  TTurtleComplex; parentType, name : String; value : TFhirImmunizationRecommendationRecommendation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationRecommendationRecommendation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.vaccineCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'ImmunizationRecommendation.recommendation', 'vaccineCode', value.vaccineCodeList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.targetDiseaseList.Count - 1 do
      ComposeCodeableConcept(this, 'ImmunizationRecommendation.recommendation', 'targetDisease', value.targetDiseaseList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contraindicatedVaccineCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'ImmunizationRecommendation.recommendation', 'contraindicatedVaccineCode', value.contraindicatedVaccineCodeList[i], false, i);
  ComposeCodeableConcept(this, 'ImmunizationRecommendation.recommendation', 'forecastStatus', value.forecastStatusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.forecastReasonList.Count - 1 do
      ComposeCodeableConcept(this, 'ImmunizationRecommendation.recommendation', 'forecastReason', value.forecastReasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dateCriterionList.Count - 1 do
      ComposeImmunizationRecommendationRecommendationDateCriterion(this, 'ImmunizationRecommendation.recommendation', 'dateCriterion', value.dateCriterionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImmunizationRecommendation.recommendation', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImmunizationRecommendation.recommendation', 'series', value.seriesElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImmunizationRecommendation.recommendation', 'doseNumber', value.doseNumberElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImmunizationRecommendation.recommendation', 'seriesDoses', value.seriesDosesElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingImmunizationList.Count - 1 do
      ComposeReference(this, 'ImmunizationRecommendation.recommendation', 'supportingImmunization', value.supportingImmunizationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingPatientInformationList.Count - 1 do
      ComposeReference(this, 'ImmunizationRecommendation.recommendation', 'supportingPatientInformation', value.supportingPatientInformationList[i], false, i);
end;

function TFHIRTurtleParser.ParseImmunizationRecommendationRecommendationDateCriterion(obj : TTurtleComplex) : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    ParseImmunizationRecommendationRecommendationDateCriterionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationRecommendationRecommendationDateCriterionProperties(obj : TTurtleComplex; value : TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.dateCriterion.code'));
    value.valueElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.dateCriterion.value'));
end;

procedure TFHIRTurtleComposer.ComposeImmunizationRecommendationRecommendationDateCriterion(parent :  TTurtleComplex; parentType, name : String; value : TFhirImmunizationRecommendationRecommendationDateCriterion; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationRecommendationRecommendationDateCriterion');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'ImmunizationRecommendation.recommendation.dateCriterion', 'code', value.codeElement, false, -1);
  ComposeDateTime(this, 'ImmunizationRecommendation.recommendation.dateCriterion', 'value', value.valueElement, false, -1);
end;

function TFHIRTurtleParser.ParseImmunizationRecommendation(obj : TTurtleComplex) : TFhirImmunizationRecommendation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationRecommendation.create;
  try
    ParseImmunizationRecommendationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationRecommendationProperties(obj : TTurtleComplex; value : TFhirImmunizationRecommendation);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.patient := ParseReference(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.patient'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.date'));
    value.authority := ParseReference(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.authority'));
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.recommendation') do
      value.recommendationList.Add(parseImmunizationRecommendationRecommendation(item));
end;

procedure TFHIRTurtleComposer.ComposeImmunizationRecommendation(parent :  TTurtleComplex; parentType, name : String; value : TFhirImmunizationRecommendation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationRecommendation');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ImmunizationRecommendation', 'identifier', value.identifierList[i], false, i);
  ComposeReference(this, 'ImmunizationRecommendation', 'patient', value.patientElement, false, -1);
  ComposeDateTime(this, 'ImmunizationRecommendation', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ImmunizationRecommendation', 'authority', value.authorityElement, false, -1);
  for i := 0 to value.recommendationList.Count - 1 do
      ComposeImmunizationRecommendationRecommendation(this, 'ImmunizationRecommendation', 'recommendation', value.recommendationList[i], false, i);
end;

{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
function TFHIRTurtleParser.ParseImplementationGuideDependsOn(obj : TTurtleComplex) : TFhirImplementationGuideDependsOn;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideDependsOn.create;
  try
    ParseImplementationGuideDependsOnProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideDependsOnProperties(obj : TTurtleComplex; value : TFhirImplementationGuideDependsOn);
begin
    ParseBackboneElementProperties(obj, value);
    value.uriElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ImplementationGuide.dependsOn.uri'));
    value.packageIdElement := ParseId(obj.complex('http://hl7.org/fhir/ImplementationGuide.dependsOn.packageId'));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.dependsOn.version'));
    value.reasonElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ImplementationGuide.dependsOn.reason'));
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideDependsOn(parent :  TTurtleComplex; parentType, name : String; value : TFhirImplementationGuideDependsOn; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideDependsOn');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCanonical(this, 'ImplementationGuide.dependsOn', 'uri', value.uriElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'ImplementationGuide.dependsOn', 'packageId', value.packageIdElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImplementationGuide.dependsOn', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ImplementationGuide.dependsOn', 'reason', value.reasonElement, false, -1);
end;

function TFHIRTurtleParser.ParseImplementationGuideGlobal(obj : TTurtleComplex) : TFhirImplementationGuideGlobal;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideGlobal.create;
  try
    ParseImplementationGuideGlobalProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideGlobalProperties(obj : TTurtleComplex; value : TFhirImplementationGuideGlobal);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ImplementationGuide.global.type'), CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    value.profileElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ImplementationGuide.global.profile'));
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideGlobal(parent :  TTurtleComplex; parentType, name : String; value : TFhirImplementationGuideGlobal; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideGlobal');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'ImplementationGuide.global', 'type', value.type_Element, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, -1);
  ComposeCanonical(this, 'ImplementationGuide.global', 'profile', value.profileElement, false, -1);
end;

function TFHIRTurtleParser.ParseImplementationGuideDefinition(obj : TTurtleComplex) : TFhirImplementationGuideDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideDefinition.create;
  try
    ParseImplementationGuideDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideDefinitionProperties(obj : TTurtleComplex; value : TFhirImplementationGuideDefinition);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.definition.grouping') do
      value.groupingList.Add(parseImplementationGuideDefinitionGrouping(item));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.definition.resource') do
      value.resourceList.Add(parseImplementationGuideDefinitionResource(item));
    value.page := ParseImplementationGuideDefinitionPage(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.page'));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.definition.parameter') do
      value.parameterList.Add(parseImplementationGuideDefinitionParameter(item));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.definition.template') do
      value.templateList.Add(parseImplementationGuideDefinitionTemplate(item));
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirImplementationGuideDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideDefinition');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.groupingList.Count - 1 do
      ComposeImplementationGuideDefinitionGrouping(this, 'ImplementationGuide.definition', 'grouping', value.groupingList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.resourceList.Count - 1 do
      ComposeImplementationGuideDefinitionResource(this, 'ImplementationGuide.definition', 'resource', value.resourceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeImplementationGuideDefinitionPage(this, 'ImplementationGuide.definition', 'page', value.pageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.parameterList.Count - 1 do
      ComposeImplementationGuideDefinitionParameter(this, 'ImplementationGuide.definition', 'parameter', value.parameterList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.templateList.Count - 1 do
      ComposeImplementationGuideDefinitionTemplate(this, 'ImplementationGuide.definition', 'template', value.templateList[i], false, i);
end;

function TFHIRTurtleParser.ParseImplementationGuideDefinitionGrouping(obj : TTurtleComplex) : TFhirImplementationGuideDefinitionGrouping;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideDefinitionGrouping.create;
  try
    ParseImplementationGuideDefinitionGroupingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideDefinitionGroupingProperties(obj : TTurtleComplex; value : TFhirImplementationGuideDefinitionGrouping);
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.grouping.name'));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.grouping.description'));
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideDefinitionGrouping(parent :  TTurtleComplex; parentType, name : String; value : TFhirImplementationGuideDefinitionGrouping; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideDefinitionGrouping');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'ImplementationGuide.definition.grouping', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ImplementationGuide.definition.grouping', 'description', value.descriptionElement, false, -1);
end;

function TFHIRTurtleParser.ParseImplementationGuideDefinitionResource(obj : TTurtleComplex) : TFhirImplementationGuideDefinitionResource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideDefinitionResource.create;
  try
    ParseImplementationGuideDefinitionResourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideDefinitionResourceProperties(obj : TTurtleComplex; value : TFhirImplementationGuideDefinitionResource);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.reference := ParseReference(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.resource.reference'));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.definition.resource.fhirVersion') do
      value.fhirVersion.Add(parseEnum(item, CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.resource.name'));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.resource.description'));
    value.isExampleElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.resource.isExample'));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.definition.resource.profile') do
      value.profileList.Add(parseCanonical(item));
    value.groupingIdElement := ParseId(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.resource.groupingId'));
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideDefinitionResource(parent :  TTurtleComplex; parentType, name : String; value : TFhirImplementationGuideDefinitionResource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideDefinitionResource');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeReference(this, 'ImplementationGuide.definition.resource', 'reference', value.referenceElement, false, -1);
  for i := 0 to value.fhirVersion.Count - 1 do
      ComposeEnum(this, 'ImplementationGuide.definition.resource', 'fhirVersion', value.fhirVersion[i], CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.fhirVersion.Count - 1 do
      ComposeEnum(this, 'ImplementationGuide.definition.resource', 'fhirVersion', value.fhirVersion[i], CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum, false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImplementationGuide.definition.resource', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ImplementationGuide.definition.resource', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ImplementationGuide.definition.resource', 'isExample', value.isExampleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.profileList.Count - 1 do
      ComposeCanonical(this, 'ImplementationGuide.definition.resource', 'profile', value.profileList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'ImplementationGuide.definition.resource', 'groupingId', value.groupingIdElement, false, -1);
end;

function TFHIRTurtleParser.ParseImplementationGuideDefinitionPage(obj : TTurtleComplex) : TFhirImplementationGuideDefinitionPage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideDefinitionPage.create;
  try
    ParseImplementationGuideDefinitionPageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideDefinitionPageProperties(obj : TTurtleComplex; value : TFhirImplementationGuideDefinitionPage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('sourceUrl', item) then
      value.source := parseUrl(item);
    if obj.has('sourceMarkdown', item) then
      value.source := parseMarkdown(item);
    if obj.has('sourceString', item) then
      value.source := parseString(item);
    value.nameElement := ParseUrl(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.page.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.page.title'));
    value.generationElement := ParseEnum(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.page.generation'), CODES_TFhirGuidePageGenerationEnum, SYSTEMS_TFhirGuidePageGenerationEnum);
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.definition.page.page') do
      value.pageList.Add(parseImplementationGuideDefinitionPage(item));
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideDefinitionPage(parent :  TTurtleComplex; parentType, name : String; value : TFhirImplementationGuideDefinitionPage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideDefinitionPage');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) and (value.source is TFhirUrl) {6} then
    ComposeUrl(this, 'ImplementationGuide.definition.page', 'sourceUrl', TFhirUrl(value.source), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.source is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'ImplementationGuide.definition.page', 'sourceMarkdown', TFhirMarkdown(value.source), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.source is TFhirString) {6} then
    ComposeString(this, 'ImplementationGuide.definition.page', 'sourceString', TFhirString(value.source), false, -1);
  ComposeUrl(this, 'ImplementationGuide.definition.page', 'name', value.nameElement, false, -1);
  ComposeString(this, 'ImplementationGuide.definition.page', 'title', value.titleElement, false, -1);
  ComposeEnum(this, 'ImplementationGuide.definition.page', 'generation', value.generationElement, CODES_TFhirGuidePageGenerationEnum, SYSTEMS_TFhirGuidePageGenerationEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.pageList.Count - 1 do
      ComposeImplementationGuideDefinitionPage(this, 'ImplementationGuide.definition.page', 'page', value.pageList[i], false, i);
end;

function TFHIRTurtleParser.ParseImplementationGuideDefinitionParameter(obj : TTurtleComplex) : TFhirImplementationGuideDefinitionParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideDefinitionParameter.create;
  try
    ParseImplementationGuideDefinitionParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideDefinitionParameterProperties(obj : TTurtleComplex; value : TFhirImplementationGuideDefinitionParameter);
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCoding(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.parameter.code'));
    value.valueElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.parameter.value'));
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideDefinitionParameter(parent :  TTurtleComplex; parentType, name : String; value : TFhirImplementationGuideDefinitionParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideDefinitionParameter');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCoding(this, 'ImplementationGuide.definition.parameter', 'code', value.codeElement, false, -1);
  ComposeString(this, 'ImplementationGuide.definition.parameter', 'value', value.valueElement, false, -1);
end;

function TFHIRTurtleParser.ParseImplementationGuideDefinitionTemplate(obj : TTurtleComplex) : TFhirImplementationGuideDefinitionTemplate;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideDefinitionTemplate.create;
  try
    ParseImplementationGuideDefinitionTemplateProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideDefinitionTemplateProperties(obj : TTurtleComplex; value : TFhirImplementationGuideDefinitionTemplate);
begin
    ParseBackboneElementProperties(obj, value);
    value.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.template.code'));
    value.sourceElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.template.source'));
    value.scopeElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.template.scope'));
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideDefinitionTemplate(parent :  TTurtleComplex; parentType, name : String; value : TFhirImplementationGuideDefinitionTemplate; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideDefinitionTemplate');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCode(this, 'ImplementationGuide.definition.template', 'code', value.codeElement, false, -1);
  ComposeString(this, 'ImplementationGuide.definition.template', 'source', value.sourceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImplementationGuide.definition.template', 'scope', value.scopeElement, false, -1);
end;

function TFHIRTurtleParser.ParseImplementationGuideManifest(obj : TTurtleComplex) : TFhirImplementationGuideManifest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideManifest.create;
  try
    ParseImplementationGuideManifestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideManifestProperties(obj : TTurtleComplex; value : TFhirImplementationGuideManifest);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.renderingElement := ParseUrl(obj.complex('http://hl7.org/fhir/ImplementationGuide.manifest.rendering'));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.manifest.resource') do
      value.resourceList.Add(parseImplementationGuideManifestResource(item));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.manifest.page') do
      value.pageList.Add(parseImplementationGuideManifestPage(item));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.manifest.image') do
      value.imageList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.manifest.other') do
      value.otherList.Add(parseString(item));
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideManifest(parent :  TTurtleComplex; parentType, name : String; value : TFhirImplementationGuideManifest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideManifest');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrl(this, 'ImplementationGuide.manifest', 'rendering', value.renderingElement, false, -1);
  for i := 0 to value.resourceList.Count - 1 do
      ComposeImplementationGuideManifestResource(this, 'ImplementationGuide.manifest', 'resource', value.resourceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.pageList.Count - 1 do
      ComposeImplementationGuideManifestPage(this, 'ImplementationGuide.manifest', 'page', value.pageList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.imageList.Count - 1 do
      ComposeString(this, 'ImplementationGuide.manifest', 'image', value.imageList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.otherList.Count - 1 do
      ComposeString(this, 'ImplementationGuide.manifest', 'other', value.otherList[i], false, i);
end;

function TFHIRTurtleParser.ParseImplementationGuideManifestResource(obj : TTurtleComplex) : TFhirImplementationGuideManifestResource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideManifestResource.create;
  try
    ParseImplementationGuideManifestResourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideManifestResourceProperties(obj : TTurtleComplex; value : TFhirImplementationGuideManifestResource);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.reference := ParseReference(obj.complex('http://hl7.org/fhir/ImplementationGuide.manifest.resource.reference'));
    value.isExampleElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ImplementationGuide.manifest.resource.isExample'));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.manifest.resource.profile') do
      value.profileList.Add(parseCanonical(item));
    value.relativePathElement := ParseUrl(obj.complex('http://hl7.org/fhir/ImplementationGuide.manifest.resource.relativePath'));
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideManifestResource(parent :  TTurtleComplex; parentType, name : String; value : TFhirImplementationGuideManifestResource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideManifestResource');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeReference(this, 'ImplementationGuide.manifest.resource', 'reference', value.referenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ImplementationGuide.manifest.resource', 'isExample', value.isExampleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.profileList.Count - 1 do
      ComposeCanonical(this, 'ImplementationGuide.manifest.resource', 'profile', value.profileList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeUrl(this, 'ImplementationGuide.manifest.resource', 'relativePath', value.relativePathElement, false, -1);
end;

function TFHIRTurtleParser.ParseImplementationGuideManifestPage(obj : TTurtleComplex) : TFhirImplementationGuideManifestPage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideManifestPage.create;
  try
    ParseImplementationGuideManifestPageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideManifestPageProperties(obj : TTurtleComplex; value : TFhirImplementationGuideManifestPage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.manifest.page.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.manifest.page.title'));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.manifest.page.anchor') do
      value.anchorList.Add(parseString(item));
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideManifestPage(parent :  TTurtleComplex; parentType, name : String; value : TFhirImplementationGuideManifestPage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideManifestPage');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'ImplementationGuide.manifest.page', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImplementationGuide.manifest.page', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.anchorList.Count - 1 do
      ComposeString(this, 'ImplementationGuide.manifest.page', 'anchor', value.anchorList[i], false, i);
end;

function TFHIRTurtleParser.ParseImplementationGuide(obj : TTurtleComplex) : TFhirImplementationGuide;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuide.create;
  try
    ParseImplementationGuideProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideProperties(obj : TTurtleComplex; value : TFhirImplementationGuide);
var
  item : TTurtleComplex;
begin
    ParseCanonicalResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ImplementationGuide.url'));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.version'));
    if obj.has('versionAlgorithmCoding', item) then
      value.versionAlgorithm := parseCoding(item);
    if obj.has('versionAlgorithmString', item) then
      value.versionAlgorithm := parseString(item);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.title'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ImplementationGuide.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ImplementationGuide.experimental'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ImplementationGuide.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ImplementationGuide.description'));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ImplementationGuide.copyright'));
    value.copyrightLabelElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.copyrightLabel'));
    value.packageIdElement := ParseId(obj.complex('http://hl7.org/fhir/ImplementationGuide.packageId'));
    value.licenseElement := ParseEnum(obj.complex('http://hl7.org/fhir/ImplementationGuide.license'), CODES_TFhirSPDXLicenseEnum, SYSTEMS_TFhirSPDXLicenseEnum);
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.fhirVersion') do
      value.fhirVersion.Add(parseEnum(item, CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.dependsOn') do
      value.dependsOnList.Add(parseImplementationGuideDependsOn(item));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.global') do
      value.globalList.Add(parseImplementationGuideGlobal(item));
    value.definition := ParseImplementationGuideDefinition(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition'));
    value.manifest := ParseImplementationGuideManifest(obj.complex('http://hl7.org/fhir/ImplementationGuide.manifest'));
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuide(parent :  TTurtleComplex; parentType, name : String; value : TFhirImplementationGuide; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuide');
  end;
  composeCanonicalResource(this, '', name, value, false, index);
  ComposeUri(this, 'ImplementationGuide', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImplementationGuide', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirCoding) {6} then
    ComposeCoding(this, 'ImplementationGuide', 'versionAlgorithmCoding', TFhirCoding(value.versionAlgorithm), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirString) {6} then
    ComposeString(this, 'ImplementationGuide', 'versionAlgorithmString', TFhirString(value.versionAlgorithm), false, -1);
  ComposeString(this, 'ImplementationGuide', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImplementationGuide', 'title', value.titleElement, false, -1);
  ComposeEnum(this, 'ImplementationGuide', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ImplementationGuide', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ImplementationGuide', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImplementationGuide', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'ImplementationGuide', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ImplementationGuide', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'ImplementationGuide', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'ImplementationGuide', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ImplementationGuide', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImplementationGuide', 'copyrightLabel', value.copyrightLabelElement, false, -1);
  ComposeId(this, 'ImplementationGuide', 'packageId', value.packageIdElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'ImplementationGuide', 'license', value.licenseElement, CODES_TFhirSPDXLicenseEnum, SYSTEMS_TFhirSPDXLicenseEnum, false, -1);
  for i := 0 to value.fhirVersion.Count - 1 do
      ComposeEnum(this, 'ImplementationGuide', 'fhirVersion', value.fhirVersion[i], CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum, false, i); {x.d1}
  for i := 0 to value.fhirVersion.Count - 1 do
      ComposeEnum(this, 'ImplementationGuide', 'fhirVersion', value.fhirVersion[i], CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum, false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.dependsOnList.Count - 1 do
      ComposeImplementationGuideDependsOn(this, 'ImplementationGuide', 'dependsOn', value.dependsOnList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.globalList.Count - 1 do
      ComposeImplementationGuideGlobal(this, 'ImplementationGuide', 'global', value.globalList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeImplementationGuideDefinition(this, 'ImplementationGuide', 'definition', value.definitionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeImplementationGuideManifest(this, 'ImplementationGuide', 'manifest', value.manifestElement, false, -1);
end;

{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_INGREDIENT}
function TFHIRTurtleParser.ParseIngredientManufacturer(obj : TTurtleComplex) : TFhirIngredientManufacturer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirIngredientManufacturer.create;
  try
    ParseIngredientManufacturerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseIngredientManufacturerProperties(obj : TTurtleComplex; value : TFhirIngredientManufacturer);
begin
    ParseBackboneElementProperties(obj, value);
    value.roleElement := ParseEnum(obj.complex('http://hl7.org/fhir/Ingredient.manufacturer.role'), CODES_TFhirIngredientManufacturerRoleEnum, SYSTEMS_TFhirIngredientManufacturerRoleEnum);
    value.manufacturer := ParseReference(obj.complex('http://hl7.org/fhir/Ingredient.manufacturer.manufacturer'));
end;

procedure TFHIRTurtleComposer.ComposeIngredientManufacturer(parent :  TTurtleComplex; parentType, name : String; value : TFhirIngredientManufacturer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:IngredientManufacturer');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Ingredient.manufacturer', 'role', value.roleElement, CODES_TFhirIngredientManufacturerRoleEnum, SYSTEMS_TFhirIngredientManufacturerRoleEnum, false, -1);
  ComposeReference(this, 'Ingredient.manufacturer', 'manufacturer', value.manufacturerElement, false, -1);
end;

function TFHIRTurtleParser.ParseIngredientSubstance(obj : TTurtleComplex) : TFhirIngredientSubstance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirIngredientSubstance.create;
  try
    ParseIngredientSubstanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseIngredientSubstanceProperties(obj : TTurtleComplex; value : TFhirIngredientSubstance);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableReference(obj.complex('http://hl7.org/fhir/Ingredient.substance.code'));
    for item in obj.complexes('http://hl7.org/fhir/Ingredient.substance.strength') do
      value.strengthList.Add(parseIngredientSubstanceStrength(item));
end;

procedure TFHIRTurtleComposer.ComposeIngredientSubstance(parent :  TTurtleComplex; parentType, name : String; value : TFhirIngredientSubstance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:IngredientSubstance');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableReference(this, 'Ingredient.substance', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.strengthList.Count - 1 do
      ComposeIngredientSubstanceStrength(this, 'Ingredient.substance', 'strength', value.strengthList[i], false, i);
end;

function TFHIRTurtleParser.ParseIngredientSubstanceStrength(obj : TTurtleComplex) : TFhirIngredientSubstanceStrength;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirIngredientSubstanceStrength.create;
  try
    ParseIngredientSubstanceStrengthProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseIngredientSubstanceStrengthProperties(obj : TTurtleComplex; value : TFhirIngredientSubstanceStrength);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('presentationRatio', item) then
      value.presentation := parseRatio(item);
    if obj.has('presentationRatioRange', item) then
      value.presentation := parseRatioRange(item);
    if obj.has('presentationCodeableConcept', item) then
      value.presentation := parseCodeableConcept(item);
    if obj.has('presentationQuantity', item) then
      value.presentation := parseQuantity(item);
    value.textPresentationElement := ParseString(obj.complex('http://hl7.org/fhir/Ingredient.substance.strength.textPresentation'));
    if obj.has('concentrationRatio', item) then
      value.concentration := parseRatio(item);
    if obj.has('concentrationRatioRange', item) then
      value.concentration := parseRatioRange(item);
    if obj.has('concentrationCodeableConcept', item) then
      value.concentration := parseCodeableConcept(item);
    if obj.has('concentrationQuantity', item) then
      value.concentration := parseQuantity(item);
    value.textConcentrationElement := ParseString(obj.complex('http://hl7.org/fhir/Ingredient.substance.strength.textConcentration'));
    value.basis := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Ingredient.substance.strength.basis'));
    value.measurementPointElement := ParseString(obj.complex('http://hl7.org/fhir/Ingredient.substance.strength.measurementPoint'));
    for item in obj.complexes('http://hl7.org/fhir/Ingredient.substance.strength.country') do
      value.countryList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Ingredient.substance.strength.referenceStrength') do
      value.referenceStrengthList.Add(parseIngredientSubstanceStrengthReferenceStrength(item));
end;

procedure TFHIRTurtleComposer.ComposeIngredientSubstanceStrength(parent :  TTurtleComplex; parentType, name : String; value : TFhirIngredientSubstanceStrength; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:IngredientSubstanceStrength');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.presentation is TFhirRatio) {6} then
    ComposeRatio(this, 'Ingredient.substance.strength', 'presentationRatio', TFhirRatio(value.presentation), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.presentation is TFhirRatioRange) {6} then
    ComposeRatioRange(this, 'Ingredient.substance.strength', 'presentationRatioRange', TFhirRatioRange(value.presentation), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.presentation is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Ingredient.substance.strength', 'presentationCodeableConcept', TFhirCodeableConcept(value.presentation), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.presentation is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Ingredient.substance.strength', 'presentationQuantity', TFhirQuantity(value.presentation), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Ingredient.substance.strength', 'textPresentation', value.textPresentationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.concentration is TFhirRatio) {6} then
    ComposeRatio(this, 'Ingredient.substance.strength', 'concentrationRatio', TFhirRatio(value.concentration), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.concentration is TFhirRatioRange) {6} then
    ComposeRatioRange(this, 'Ingredient.substance.strength', 'concentrationRatioRange', TFhirRatioRange(value.concentration), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.concentration is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Ingredient.substance.strength', 'concentrationCodeableConcept', TFhirCodeableConcept(value.concentration), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.concentration is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Ingredient.substance.strength', 'concentrationQuantity', TFhirQuantity(value.concentration), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Ingredient.substance.strength', 'textConcentration', value.textConcentrationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Ingredient.substance.strength', 'basis', value.basisElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Ingredient.substance.strength', 'measurementPoint', value.measurementPointElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.countryList.Count - 1 do
      ComposeCodeableConcept(this, 'Ingredient.substance.strength', 'country', value.countryList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.referenceStrengthList.Count - 1 do
      ComposeIngredientSubstanceStrengthReferenceStrength(this, 'Ingredient.substance.strength', 'referenceStrength', value.referenceStrengthList[i], false, i);
end;

function TFHIRTurtleParser.ParseIngredientSubstanceStrengthReferenceStrength(obj : TTurtleComplex) : TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirIngredientSubstanceStrengthReferenceStrength.create;
  try
    ParseIngredientSubstanceStrengthReferenceStrengthProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseIngredientSubstanceStrengthReferenceStrengthProperties(obj : TTurtleComplex; value : TFhirIngredientSubstanceStrengthReferenceStrength);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.substance := ParseCodeableReference(obj.complex('http://hl7.org/fhir/Ingredient.substance.strength.referenceStrength.substance'));
    if obj.has('strengthRatio', item) then
      value.strength := parseRatio(item);
    if obj.has('strengthRatioRange', item) then
      value.strength := parseRatioRange(item);
    if obj.has('strengthQuantity', item) then
      value.strength := parseQuantity(item);
    value.measurementPointElement := ParseString(obj.complex('http://hl7.org/fhir/Ingredient.substance.strength.referenceStrength.measurementPoint'));
    for item in obj.complexes('http://hl7.org/fhir/Ingredient.substance.strength.referenceStrength.country') do
      value.countryList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeIngredientSubstanceStrengthReferenceStrength(parent :  TTurtleComplex; parentType, name : String; value : TFhirIngredientSubstanceStrengthReferenceStrength; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:IngredientSubstanceStrengthReferenceStrength');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(this, 'Ingredient.substance.strength.referenceStrength', 'substance', value.substanceElement, false, -1);
  if (value.strength is TFhirRatio) {6} then
    ComposeRatio(this, 'Ingredient.substance.strength.referenceStrength', 'strengthRatio', TFhirRatio(value.strength), false, -1)
  else if (value.strength is TFhirRatioRange) {6} then
    ComposeRatioRange(this, 'Ingredient.substance.strength.referenceStrength', 'strengthRatioRange', TFhirRatioRange(value.strength), false, -1)
  else if (value.strength is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Ingredient.substance.strength.referenceStrength', 'strengthQuantity', TFhirQuantity(value.strength), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Ingredient.substance.strength.referenceStrength', 'measurementPoint', value.measurementPointElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.countryList.Count - 1 do
      ComposeCodeableConcept(this, 'Ingredient.substance.strength.referenceStrength', 'country', value.countryList[i], false, i);
end;

function TFHIRTurtleParser.ParseIngredient(obj : TTurtleComplex) : TFhirIngredient;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirIngredient.create;
  try
    ParseIngredientProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseIngredientProperties(obj : TTurtleComplex; value : TFhirIngredient);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    value.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Ingredient.identifier'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Ingredient.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/Ingredient.for') do
      value.for_List.Add(parseReference(item));
    value.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Ingredient.role'));
    for item in obj.complexes('http://hl7.org/fhir/Ingredient.function') do
      value.function_List.Add(parseCodeableConcept(item));
    value.group := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Ingredient.group'));
    value.allergenicIndicatorElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Ingredient.allergenicIndicator'));
    for item in obj.complexes('http://hl7.org/fhir/Ingredient.manufacturer') do
      value.manufacturerList.Add(parseIngredientManufacturer(item));
    value.substance := ParseIngredientSubstance(obj.complex('http://hl7.org/fhir/Ingredient.substance'));
end;

procedure TFHIRTurtleComposer.ComposeIngredient(parent :  TTurtleComplex; parentType, name : String; value : TFhirIngredient; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Ingredient');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'Ingredient', 'identifier', value.identifierElement, false, -1);
  ComposeEnum(this, 'Ingredient', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.for_List.Count - 1 do
      ComposeReference(this, 'Ingredient', 'for', value.for_List[i], false, i);
  ComposeCodeableConcept(this, 'Ingredient', 'role', value.roleElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.function_List.Count - 1 do
      ComposeCodeableConcept(this, 'Ingredient', 'function', value.function_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Ingredient', 'group', value.groupElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Ingredient', 'allergenicIndicator', value.allergenicIndicatorElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.manufacturerList.Count - 1 do
      ComposeIngredientManufacturer(this, 'Ingredient', 'manufacturer', value.manufacturerList[i], false, i);
  ComposeIngredientSubstance(this, 'Ingredient', 'substance', value.substanceElement, false, -1);
end;

{$ENDIF FHIR_INGREDIENT}
{$IFDEF FHIR_INSURANCEPLAN}
function TFHIRTurtleParser.ParseInsurancePlanCoverage(obj : TTurtleComplex) : TFhirInsurancePlanCoverage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInsurancePlanCoverage.create;
  try
    ParseInsurancePlanCoverageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInsurancePlanCoverageProperties(obj : TTurtleComplex; value : TFhirInsurancePlanCoverage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/InsurancePlan.coverage.type'));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.coverage.network') do
      value.networkList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.coverage.benefit') do
      value.benefitList.Add(parseInsurancePlanCoverageBenefit(item));
end;

procedure TFHIRTurtleComposer.ComposeInsurancePlanCoverage(parent :  TTurtleComplex; parentType, name : String; value : TFhirInsurancePlanCoverage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InsurancePlanCoverage');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'InsurancePlan.coverage', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.networkList.Count - 1 do
      ComposeReference(this, 'InsurancePlan.coverage', 'network', value.networkList[i], false, i);
  for i := 0 to value.benefitList.Count - 1 do
      ComposeInsurancePlanCoverageBenefit(this, 'InsurancePlan.coverage', 'benefit', value.benefitList[i], false, i);
end;

function TFHIRTurtleParser.ParseInsurancePlanCoverageBenefit(obj : TTurtleComplex) : TFhirInsurancePlanCoverageBenefit;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInsurancePlanCoverageBenefit.create;
  try
    ParseInsurancePlanCoverageBenefitProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInsurancePlanCoverageBenefitProperties(obj : TTurtleComplex; value : TFhirInsurancePlanCoverageBenefit);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/InsurancePlan.coverage.benefit.type'));
    value.requirementElement := ParseString(obj.complex('http://hl7.org/fhir/InsurancePlan.coverage.benefit.requirement'));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.coverage.benefit.limit') do
      value.limitList.Add(parseInsurancePlanCoverageBenefitLimit(item));
end;

procedure TFHIRTurtleComposer.ComposeInsurancePlanCoverageBenefit(parent :  TTurtleComplex; parentType, name : String; value : TFhirInsurancePlanCoverageBenefit; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InsurancePlanCoverageBenefit');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'InsurancePlan.coverage.benefit', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'InsurancePlan.coverage.benefit', 'requirement', value.requirementElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.limitList.Count - 1 do
      ComposeInsurancePlanCoverageBenefitLimit(this, 'InsurancePlan.coverage.benefit', 'limit', value.limitList[i], false, i);
end;

function TFHIRTurtleParser.ParseInsurancePlanCoverageBenefitLimit(obj : TTurtleComplex) : TFhirInsurancePlanCoverageBenefitLimit;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInsurancePlanCoverageBenefitLimit.create;
  try
    ParseInsurancePlanCoverageBenefitLimitProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInsurancePlanCoverageBenefitLimitProperties(obj : TTurtleComplex; value : TFhirInsurancePlanCoverageBenefitLimit);
begin
    ParseBackboneElementProperties(obj, value);
    value.value := ParseQuantity(obj.complex('http://hl7.org/fhir/InsurancePlan.coverage.benefit.limit.value'));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/InsurancePlan.coverage.benefit.limit.code'));
end;

procedure TFHIRTurtleComposer.ComposeInsurancePlanCoverageBenefitLimit(parent :  TTurtleComplex; parentType, name : String; value : TFhirInsurancePlanCoverageBenefitLimit; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InsurancePlanCoverageBenefitLimit');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'InsurancePlan.coverage.benefit.limit', 'value', value.valueElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'InsurancePlan.coverage.benefit.limit', 'code', value.codeElement, false, -1);
end;

function TFHIRTurtleParser.ParseInsurancePlanPlan(obj : TTurtleComplex) : TFhirInsurancePlanPlan;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInsurancePlanPlan.create;
  try
    ParseInsurancePlanPlanProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInsurancePlanPlanProperties(obj : TTurtleComplex; value : TFhirInsurancePlanPlan);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.plan.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/InsurancePlan.plan.type'));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.plan.coverageArea') do
      value.coverageAreaList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.plan.network') do
      value.networkList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.plan.generalCost') do
      value.generalCostList.Add(parseInsurancePlanPlanGeneralCost(item));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.plan.specificCost') do
      value.specificCostList.Add(parseInsurancePlanPlanSpecificCost(item));
end;

procedure TFHIRTurtleComposer.ComposeInsurancePlanPlan(parent :  TTurtleComplex; parentType, name : String; value : TFhirInsurancePlanPlan; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InsurancePlanPlan');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'InsurancePlan.plan', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'InsurancePlan.plan', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.coverageAreaList.Count - 1 do
      ComposeReference(this, 'InsurancePlan.plan', 'coverageArea', value.coverageAreaList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.networkList.Count - 1 do
      ComposeReference(this, 'InsurancePlan.plan', 'network', value.networkList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.generalCostList.Count - 1 do
      ComposeInsurancePlanPlanGeneralCost(this, 'InsurancePlan.plan', 'generalCost', value.generalCostList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.specificCostList.Count - 1 do
      ComposeInsurancePlanPlanSpecificCost(this, 'InsurancePlan.plan', 'specificCost', value.specificCostList[i], false, i);
end;

function TFHIRTurtleParser.ParseInsurancePlanPlanGeneralCost(obj : TTurtleComplex) : TFhirInsurancePlanPlanGeneralCost;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInsurancePlanPlanGeneralCost.create;
  try
    ParseInsurancePlanPlanGeneralCostProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInsurancePlanPlanGeneralCostProperties(obj : TTurtleComplex; value : TFhirInsurancePlanPlanGeneralCost);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/InsurancePlan.plan.generalCost.type'));
    value.groupSizeElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/InsurancePlan.plan.generalCost.groupSize'));
    value.cost := ParseMoney(obj.complex('http://hl7.org/fhir/InsurancePlan.plan.generalCost.cost'));
    value.commentElement := ParseString(obj.complex('http://hl7.org/fhir/InsurancePlan.plan.generalCost.comment'));
end;

procedure TFHIRTurtleComposer.ComposeInsurancePlanPlanGeneralCost(parent :  TTurtleComplex; parentType, name : String; value : TFhirInsurancePlanPlanGeneralCost; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InsurancePlanPlanGeneralCost');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'InsurancePlan.plan.generalCost', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'InsurancePlan.plan.generalCost', 'groupSize', value.groupSizeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'InsurancePlan.plan.generalCost', 'cost', value.costElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'InsurancePlan.plan.generalCost', 'comment', value.commentElement, false, -1);
end;

function TFHIRTurtleParser.ParseInsurancePlanPlanSpecificCost(obj : TTurtleComplex) : TFhirInsurancePlanPlanSpecificCost;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInsurancePlanPlanSpecificCost.create;
  try
    ParseInsurancePlanPlanSpecificCostProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInsurancePlanPlanSpecificCostProperties(obj : TTurtleComplex; value : TFhirInsurancePlanPlanSpecificCost);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/InsurancePlan.plan.specificCost.category'));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.plan.specificCost.benefit') do
      value.benefitList.Add(parseInsurancePlanPlanSpecificCostBenefit(item));
end;

procedure TFHIRTurtleComposer.ComposeInsurancePlanPlanSpecificCost(parent :  TTurtleComplex; parentType, name : String; value : TFhirInsurancePlanPlanSpecificCost; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InsurancePlanPlanSpecificCost');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'InsurancePlan.plan.specificCost', 'category', value.categoryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.benefitList.Count - 1 do
      ComposeInsurancePlanPlanSpecificCostBenefit(this, 'InsurancePlan.plan.specificCost', 'benefit', value.benefitList[i], false, i);
end;

function TFHIRTurtleParser.ParseInsurancePlanPlanSpecificCostBenefit(obj : TTurtleComplex) : TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInsurancePlanPlanSpecificCostBenefit.create;
  try
    ParseInsurancePlanPlanSpecificCostBenefitProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInsurancePlanPlanSpecificCostBenefitProperties(obj : TTurtleComplex; value : TFhirInsurancePlanPlanSpecificCostBenefit);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/InsurancePlan.plan.specificCost.benefit.type'));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.plan.specificCost.benefit.cost') do
      value.costList.Add(parseInsurancePlanPlanSpecificCostBenefitCost(item));
end;

procedure TFHIRTurtleComposer.ComposeInsurancePlanPlanSpecificCostBenefit(parent :  TTurtleComplex; parentType, name : String; value : TFhirInsurancePlanPlanSpecificCostBenefit; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InsurancePlanPlanSpecificCostBenefit');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'InsurancePlan.plan.specificCost.benefit', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.costList.Count - 1 do
      ComposeInsurancePlanPlanSpecificCostBenefitCost(this, 'InsurancePlan.plan.specificCost.benefit', 'cost', value.costList[i], false, i);
end;

function TFHIRTurtleParser.ParseInsurancePlanPlanSpecificCostBenefitCost(obj : TTurtleComplex) : TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInsurancePlanPlanSpecificCostBenefitCost.create;
  try
    ParseInsurancePlanPlanSpecificCostBenefitCostProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInsurancePlanPlanSpecificCostBenefitCostProperties(obj : TTurtleComplex; value : TFhirInsurancePlanPlanSpecificCostBenefitCost);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/InsurancePlan.plan.specificCost.benefit.cost.type'));
    value.applicability := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/InsurancePlan.plan.specificCost.benefit.cost.applicability'));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.plan.specificCost.benefit.cost.qualifiers') do
      value.qualifiersList.Add(parseCodeableConcept(item));
    value.value := ParseQuantity(obj.complex('http://hl7.org/fhir/InsurancePlan.plan.specificCost.benefit.cost.value'));
end;

procedure TFHIRTurtleComposer.ComposeInsurancePlanPlanSpecificCostBenefitCost(parent :  TTurtleComplex; parentType, name : String; value : TFhirInsurancePlanPlanSpecificCostBenefitCost; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InsurancePlanPlanSpecificCostBenefitCost');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'InsurancePlan.plan.specificCost.benefit.cost', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'InsurancePlan.plan.specificCost.benefit.cost', 'applicability', value.applicabilityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.qualifiersList.Count - 1 do
      ComposeCodeableConcept(this, 'InsurancePlan.plan.specificCost.benefit.cost', 'qualifiers', value.qualifiersList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'InsurancePlan.plan.specificCost.benefit.cost', 'value', value.valueElement, false, -1);
end;

function TFHIRTurtleParser.ParseInsurancePlan(obj : TTurtleComplex) : TFhirInsurancePlan;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInsurancePlan.create;
  try
    ParseInsurancePlanProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInsurancePlanProperties(obj : TTurtleComplex; value : TFhirInsurancePlan);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/InsurancePlan.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.type') do
      value.type_List.Add(parseCodeableConcept(item));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/InsurancePlan.name'));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.alias') do
      value.aliasList.Add(parseString(item));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/InsurancePlan.period'));
    value.ownedBy := ParseReference(obj.complex('http://hl7.org/fhir/InsurancePlan.ownedBy'));
    value.administeredBy := ParseReference(obj.complex('http://hl7.org/fhir/InsurancePlan.administeredBy'));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.coverageArea') do
      value.coverageAreaList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.contact') do
      value.contactList.Add(parseExtendedContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.endpoint') do
      value.endpointList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.network') do
      value.networkList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.coverage') do
      value.coverageList.Add(parseInsurancePlanCoverage(item));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.plan') do
      value.planList.Add(parseInsurancePlanPlan(item));
end;

procedure TFHIRTurtleComposer.ComposeInsurancePlan(parent :  TTurtleComplex; parentType, name : String; value : TFhirInsurancePlan; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InsurancePlan');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'InsurancePlan', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'InsurancePlan', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'InsurancePlan', 'type', value.type_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'InsurancePlan', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.aliasList.Count - 1 do
      ComposeString(this, 'InsurancePlan', 'alias', value.aliasList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'InsurancePlan', 'period', value.periodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'InsurancePlan', 'ownedBy', value.ownedByElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'InsurancePlan', 'administeredBy', value.administeredByElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.coverageAreaList.Count - 1 do
      ComposeReference(this, 'InsurancePlan', 'coverageArea', value.coverageAreaList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeExtendedContactDetail(this, 'InsurancePlan', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endpointList.Count - 1 do
      ComposeReference(this, 'InsurancePlan', 'endpoint', value.endpointList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.networkList.Count - 1 do
      ComposeReference(this, 'InsurancePlan', 'network', value.networkList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.coverageList.Count - 1 do
      ComposeInsurancePlanCoverage(this, 'InsurancePlan', 'coverage', value.coverageList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.planList.Count - 1 do
      ComposeInsurancePlanPlan(this, 'InsurancePlan', 'plan', value.planList[i], false, i);
end;

{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVENTORYREPORT}
function TFHIRTurtleParser.ParseInventoryReportInventoryListing(obj : TTurtleComplex) : TFhirInventoryReportInventoryListing;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInventoryReportInventoryListing.create;
  try
    ParseInventoryReportInventoryListingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInventoryReportInventoryListingProperties(obj : TTurtleComplex; value : TFhirInventoryReportInventoryListing);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.location := ParseReference(obj.complex('http://hl7.org/fhir/InventoryReport.inventoryListing.location'));
    value.itemStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/InventoryReport.inventoryListing.itemStatus'));
    value.countingDateTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/InventoryReport.inventoryListing.countingDateTime'));
    for item in obj.complexes('http://hl7.org/fhir/InventoryReport.inventoryListing.items') do
      value.itemsList.Add(parseInventoryReportInventoryListingItems(item));
end;

procedure TFHIRTurtleComposer.ComposeInventoryReportInventoryListing(parent :  TTurtleComplex; parentType, name : String; value : TFhirInventoryReportInventoryListing; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InventoryReportInventoryListing');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'InventoryReport.inventoryListing', 'location', value.locationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'InventoryReport.inventoryListing', 'itemStatus', value.itemStatusElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'InventoryReport.inventoryListing', 'countingDateTime', value.countingDateTimeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.itemsList.Count - 1 do
      ComposeInventoryReportInventoryListingItems(this, 'InventoryReport.inventoryListing', 'items', value.itemsList[i], false, i);
end;

function TFHIRTurtleParser.ParseInventoryReportInventoryListingItems(obj : TTurtleComplex) : TFhirInventoryReportInventoryListingItems;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInventoryReportInventoryListingItems.create;
  try
    ParseInventoryReportInventoryListingItemsProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInventoryReportInventoryListingItemsProperties(obj : TTurtleComplex; value : TFhirInventoryReportInventoryListingItems);
begin
    ParseBackboneElementProperties(obj, value);
    value.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/InventoryReport.inventoryListing.items.category'));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/InventoryReport.inventoryListing.items.quantity'));
    value.item := ParseCodeableReference(obj.complex('http://hl7.org/fhir/InventoryReport.inventoryListing.items.item'));
    value.lotElement := ParseString(obj.complex('http://hl7.org/fhir/InventoryReport.inventoryListing.items.lot'));
    value.serialElement := ParseString(obj.complex('http://hl7.org/fhir/InventoryReport.inventoryListing.items.serial'));
    value.expiryElement := ParseDateTime(obj.complex('http://hl7.org/fhir/InventoryReport.inventoryListing.items.expiry'));
    value.manufacturingDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/InventoryReport.inventoryListing.items.manufacturingDate'));
end;

procedure TFHIRTurtleComposer.ComposeInventoryReportInventoryListingItems(parent :  TTurtleComplex; parentType, name : String; value : TFhirInventoryReportInventoryListingItems; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InventoryReportInventoryListingItems');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'InventoryReport.inventoryListing.items', 'category', value.categoryElement, false, -1);
  ComposeQuantity(this, 'InventoryReport.inventoryListing.items', 'quantity', value.quantityElement, false, -1);
  ComposeCodeableReference(this, 'InventoryReport.inventoryListing.items', 'item', value.itemElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'InventoryReport.inventoryListing.items', 'lot', value.lotElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'InventoryReport.inventoryListing.items', 'serial', value.serialElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'InventoryReport.inventoryListing.items', 'expiry', value.expiryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'InventoryReport.inventoryListing.items', 'manufacturingDate', value.manufacturingDateElement, false, -1);
end;

function TFHIRTurtleParser.ParseInventoryReport(obj : TTurtleComplex) : TFhirInventoryReport;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInventoryReport.create;
  try
    ParseInventoryReportProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInventoryReportProperties(obj : TTurtleComplex; value : TFhirInventoryReport);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/InventoryReport.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/InventoryReport.status'), CODES_TFhirInventoryReportStatusEnum, SYSTEMS_TFhirInventoryReportStatusEnum);
    value.countTypeElement := ParseEnum(obj.complex('http://hl7.org/fhir/InventoryReport.countType'), CODES_TFhirInventoryCountTypeEnum, SYSTEMS_TFhirInventoryCountTypeEnum);
    value.operationType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/InventoryReport.operationType'));
    value.operationTypeReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/InventoryReport.operationTypeReason'));
    value.reportedDateTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/InventoryReport.reportedDateTime'));
    value.reporter := ParseReference(obj.complex('http://hl7.org/fhir/InventoryReport.reporter'));
    value.reportingPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/InventoryReport.reportingPeriod'));
    for item in obj.complexes('http://hl7.org/fhir/InventoryReport.inventoryListing') do
      value.inventoryListingList.Add(parseInventoryReportInventoryListing(item));
    value.note := ParseAnnotation(obj.complex('http://hl7.org/fhir/InventoryReport.note'));
end;

procedure TFHIRTurtleComposer.ComposeInventoryReport(parent :  TTurtleComplex; parentType, name : String; value : TFhirInventoryReport; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InventoryReport');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'InventoryReport', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'InventoryReport', 'status', value.statusElement, CODES_TFhirInventoryReportStatusEnum, SYSTEMS_TFhirInventoryReportStatusEnum, false, -1);
  ComposeEnum(this, 'InventoryReport', 'countType', value.countTypeElement, CODES_TFhirInventoryCountTypeEnum, SYSTEMS_TFhirInventoryCountTypeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'InventoryReport', 'operationType', value.operationTypeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'InventoryReport', 'operationTypeReason', value.operationTypeReasonElement, false, -1);
  ComposeDateTime(this, 'InventoryReport', 'reportedDateTime', value.reportedDateTimeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'InventoryReport', 'reporter', value.reporterElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'InventoryReport', 'reportingPeriod', value.reportingPeriodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.inventoryListingList.Count - 1 do
      ComposeInventoryReportInventoryListing(this, 'InventoryReport', 'inventoryListing', value.inventoryListingList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeAnnotation(this, 'InventoryReport', 'note', value.noteElement, false, -1);
end;

{$ENDIF FHIR_INVENTORYREPORT}
{$IFDEF FHIR_INVOICE}
function TFHIRTurtleParser.ParseInvoiceParticipant(obj : TTurtleComplex) : TFhirInvoiceParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInvoiceParticipant.create;
  try
    ParseInvoiceParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInvoiceParticipantProperties(obj : TTurtleComplex; value : TFhirInvoiceParticipant);
begin
    ParseBackboneElementProperties(obj, value);
    value.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Invoice.participant.role'));
    value.actor := ParseReference(obj.complex('http://hl7.org/fhir/Invoice.participant.actor'));
end;

procedure TFHIRTurtleComposer.ComposeInvoiceParticipant(parent :  TTurtleComplex; parentType, name : String; value : TFhirInvoiceParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InvoiceParticipant');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Invoice.participant', 'role', value.roleElement, false, -1);
  ComposeReference(this, 'Invoice.participant', 'actor', value.actorElement, false, -1);
end;

function TFHIRTurtleParser.ParseInvoiceLineItem(obj : TTurtleComplex) : TFhirInvoiceLineItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInvoiceLineItem.create;
  try
    ParseInvoiceLineItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInvoiceLineItemProperties(obj : TTurtleComplex; value : TFhirInvoiceLineItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Invoice.lineItem.sequence'));
    if obj.has('servicedPeriod', item) then
      value.serviced := parsePeriod(item);
    if obj.has('servicedDate', item) then
      value.serviced := parseDate(item);
    if obj.has('chargeItemReference', item) {a3} then
      value.chargeItem := ParseReference(item);
    if obj.has('chargeItemCodeableConcept', item) then
      value.chargeItem := parseCodeableConcept(item);
    for item in obj.complexes('http://hl7.org/fhir/Invoice.lineItem.priceComponent') do
      value.priceComponentList.Add(parseMonetaryComponent(item));
end;

procedure TFHIRTurtleComposer.ComposeInvoiceLineItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirInvoiceLineItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InvoiceLineItem');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'Invoice.lineItem', 'sequence', value.sequenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirPeriod) {6} then
    ComposePeriod(this, 'Invoice.lineItem', 'servicedPeriod', TFhirPeriod(value.serviced), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.serviced is TFhirDate) {6} then
    ComposeDate(this, 'Invoice.lineItem', 'servicedDate', TFhirDate(value.serviced), false, -1);
  if (value.chargeItem is TFhirReference) {2} then
    ComposeReference(this, 'Invoice.lineItem', 'chargeItemReference', TFhirReference(value.chargeItem), false,-1)
  else if (value.chargeItem is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Invoice.lineItem', 'chargeItemCodeableConcept', TFhirCodeableConcept(value.chargeItem), false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.priceComponentList.Count - 1 do
      ComposeMonetaryComponent(this, 'Invoice.lineItem', 'priceComponent', value.priceComponentList[i], false, i);
end;

function TFHIRTurtleParser.ParseInvoice(obj : TTurtleComplex) : TFhirInvoice;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInvoice.create;
  try
    ParseInvoiceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInvoiceProperties(obj : TTurtleComplex; value : TFhirInvoice);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Invoice.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Invoice.status'), CODES_TFhirInvoiceStatusEnum, SYSTEMS_TFhirInvoiceStatusEnum);
    value.cancelledReasonElement := ParseString(obj.complex('http://hl7.org/fhir/Invoice.cancelledReason'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Invoice.type'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/Invoice.subject'));
    value.recipient := ParseReference(obj.complex('http://hl7.org/fhir/Invoice.recipient'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Invoice.date'));
    value.creationElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Invoice.creation'));
    if obj.has('periodPeriod', item) then
      value.period := parsePeriod(item);
    if obj.has('periodDate', item) then
      value.period := parseDate(item);
    for item in obj.complexes('http://hl7.org/fhir/Invoice.participant') do
      value.participantList.Add(parseInvoiceParticipant(item));
    value.issuer := ParseReference(obj.complex('http://hl7.org/fhir/Invoice.issuer'));
    value.account := ParseReference(obj.complex('http://hl7.org/fhir/Invoice.account'));
    for item in obj.complexes('http://hl7.org/fhir/Invoice.lineItem') do
      value.lineItemList.Add(parseInvoiceLineItem(item));
    for item in obj.complexes('http://hl7.org/fhir/Invoice.totalPriceComponent') do
      value.totalPriceComponentList.Add(parseMonetaryComponent(item));
    value.totalNet := ParseMoney(obj.complex('http://hl7.org/fhir/Invoice.totalNet'));
    value.totalGross := ParseMoney(obj.complex('http://hl7.org/fhir/Invoice.totalGross'));
    value.paymentTermsElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Invoice.paymentTerms'));
    for item in obj.complexes('http://hl7.org/fhir/Invoice.note') do
      value.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeInvoice(parent :  TTurtleComplex; parentType, name : String; value : TFhirInvoice; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Invoice');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Invoice', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'Invoice', 'status', value.statusElement, CODES_TFhirInvoiceStatusEnum, SYSTEMS_TFhirInvoiceStatusEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Invoice', 'cancelledReason', value.cancelledReasonElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Invoice', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Invoice', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Invoice', 'recipient', value.recipientElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Invoice', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Invoice', 'creation', value.creationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.period is TFhirPeriod) {6} then
    ComposePeriod(this, 'Invoice', 'periodPeriod', TFhirPeriod(value.period), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.period is TFhirDate) {6} then
    ComposeDate(this, 'Invoice', 'periodDate', TFhirDate(value.period), false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.participantList.Count - 1 do
      ComposeInvoiceParticipant(this, 'Invoice', 'participant', value.participantList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Invoice', 'issuer', value.issuerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Invoice', 'account', value.accountElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.lineItemList.Count - 1 do
      ComposeInvoiceLineItem(this, 'Invoice', 'lineItem', value.lineItemList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.totalPriceComponentList.Count - 1 do
      ComposeMonetaryComponent(this, 'Invoice', 'totalPriceComponent', value.totalPriceComponentList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMoney(this, 'Invoice', 'totalNet', value.totalNetElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMoney(this, 'Invoice', 'totalGross', value.totalGrossElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'Invoice', 'paymentTerms', value.paymentTermsElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'Invoice', 'note', value.noteList[i], false, i);
end;

{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_LIBRARY}
function TFHIRTurtleParser.ParseLibrary(obj : TTurtleComplex) : TFhirLibrary;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirLibrary.create;
  try
    ParseLibraryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseLibraryProperties(obj : TTurtleComplex; value : TFhirLibrary);
var
  item : TTurtleComplex;
begin
    ParseMetadataResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Library.url'));
    for item in obj.complexes('http://hl7.org/fhir/Library.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Library.version'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Library.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Library.title'));
    value.subtitleElement := ParseString(obj.complex('http://hl7.org/fhir/Library.subtitle'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Library.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Library.experimental'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Library.type'));
    if obj.has('subjectCodeableConcept', item) then
      value.subject := parseCodeableConcept(item);
    if obj.has('subjectReference', item) {a3} then
      value.subject := ParseReference(item);
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Library.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/Library.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/Library.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Library.description'));
    for item in obj.complexes('http://hl7.org/fhir/Library.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/Library.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Library.purpose'));
    value.usageElement := ParseString(obj.complex('http://hl7.org/fhir/Library.usage'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Library.copyright'));
    value.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Library.approvalDate'));
    value.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Library.lastReviewDate'));
    value.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Library.effectivePeriod'));
    for item in obj.complexes('http://hl7.org/fhir/Library.topic') do
      value.topicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Library.author') do
      value.authorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Library.editor') do
      value.editorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Library.reviewer') do
      value.reviewerList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Library.endorser') do
      value.endorserList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Library.relatedArtifact') do
      value.relatedArtifactList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/Library.parameter') do
      value.parameterList.Add(parseParameterDefinition(item));
    for item in obj.complexes('http://hl7.org/fhir/Library.dataRequirement') do
      value.dataRequirementList.Add(parseDataRequirement(item));
    for item in obj.complexes('http://hl7.org/fhir/Library.content') do
      value.contentList.Add(parseAttachment(item));
end;

procedure TFHIRTurtleComposer.ComposeLibrary(parent :  TTurtleComplex; parentType, name : String; value : TFhirLibrary; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Library');
  end;
  composeMetadataResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'Library', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Library', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Library', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Library', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Library', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Library', 'subtitle', value.subtitleElement, false, -1);
  ComposeEnum(this, 'Library', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Library', 'experimental', value.experimentalElement, false, -1);
  ComposeCodeableConcept(this, 'Library', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.subject is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Library', 'subjectCodeableConcept', TFhirCodeableConcept(value.subject), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.subject is TFhirReference) {2} then
    ComposeReference(this, 'Library', 'subjectReference', TFhirReference(value.subject), false,-1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Library', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Library', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'Library', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'Library', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'Library', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'Library', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'Library', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Library', 'usage', value.usageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'Library', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'Library', 'approvalDate', value.approvalDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'Library', 'lastReviewDate', value.lastReviewDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Library', 'effectivePeriod', value.effectivePeriodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.topicList.Count - 1 do
      ComposeCodeableConcept(this, 'Library', 'topic', value.topicList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(this, 'Library', 'author', value.authorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(this, 'Library', 'editor', value.editorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(this, 'Library', 'reviewer', value.reviewerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(this, 'Library', 'endorser', value.endorserList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'Library', 'relatedArtifact', value.relatedArtifactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.parameterList.Count - 1 do
      ComposeParameterDefinition(this, 'Library', 'parameter', value.parameterList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dataRequirementList.Count - 1 do
      ComposeDataRequirement(this, 'Library', 'dataRequirement', value.dataRequirementList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contentList.Count - 1 do
      ComposeAttachment(this, 'Library', 'content', value.contentList[i], false, i);
end;

{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
function TFHIRTurtleParser.ParseLinkageItem(obj : TTurtleComplex) : TFhirLinkageItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirLinkageItem.create;
  try
    ParseLinkageItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseLinkageItemProperties(obj : TTurtleComplex; value : TFhirLinkageItem);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Linkage.item.type'), CODES_TFhirLinkageTypeEnum, SYSTEMS_TFhirLinkageTypeEnum);
    value.resource := ParseReference(obj.complex('http://hl7.org/fhir/Linkage.item.resource'));
end;

procedure TFHIRTurtleComposer.ComposeLinkageItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirLinkageItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:LinkageItem');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'Linkage.item', 'type', value.type_Element, CODES_TFhirLinkageTypeEnum, SYSTEMS_TFhirLinkageTypeEnum, false, -1);
  ComposeReference(this, 'Linkage.item', 'resource', value.resourceElement, false, -1);
end;

function TFHIRTurtleParser.ParseLinkage(obj : TTurtleComplex) : TFhirLinkage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirLinkage.create;
  try
    ParseLinkageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseLinkageProperties(obj : TTurtleComplex; value : TFhirLinkage);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    value.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Linkage.active'));
    value.author := ParseReference(obj.complex('http://hl7.org/fhir/Linkage.author'));
    for item in obj.complexes('http://hl7.org/fhir/Linkage.item') do
      value.itemList.Add(parseLinkageItem(item));
end;

procedure TFHIRTurtleComposer.ComposeLinkage(parent :  TTurtleComplex; parentType, name : String; value : TFhirLinkage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Linkage');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Linkage', 'active', value.activeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Linkage', 'author', value.authorElement, false, -1);
  for i := 0 to value.itemList.Count - 1 do
      ComposeLinkageItem(this, 'Linkage', 'item', value.itemList[i], false, i);
end;

{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
function TFHIRTurtleParser.ParseListEntry(obj : TTurtleComplex) : TFhirListEntry;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirListEntry.create;
  try
    ParseListEntryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseListEntryProperties(obj : TTurtleComplex; value : TFhirListEntry);
begin
    ParseBackboneElementProperties(obj, value);
    value.flag := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/List.entry.flag'));
    value.deletedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/List.entry.deleted'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/List.entry.date'));
    value.item := ParseReference(obj.complex('http://hl7.org/fhir/List.entry.item'));
end;

procedure TFHIRTurtleComposer.ComposeListEntry(parent :  TTurtleComplex; parentType, name : String; value : TFhirListEntry; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ListEntry');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'List.entry', 'flag', value.flagElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'List.entry', 'deleted', value.deletedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'List.entry', 'date', value.dateElement, false, -1);
  ComposeReference(this, 'List.entry', 'item', value.itemElement, false, -1);
end;

function TFHIRTurtleParser.ParseList(obj : TTurtleComplex) : TFhirList;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirList.create;
  try
    ParseListProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseListProperties(obj : TTurtleComplex; value : TFhirList);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/List.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/List.status'), CODES_TFhirListStatusEnum, SYSTEMS_TFhirListStatusEnum);
    value.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/List.mode'), CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum);
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/List.title'));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/List.code'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/List.subject'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/List.encounter'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/List.date'));
    value.source := ParseReference(obj.complex('http://hl7.org/fhir/List.source'));
    value.orderedBy := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/List.orderedBy'));
    for item in obj.complexes('http://hl7.org/fhir/List.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/List.entry') do
      value.entryList.Add(parseListEntry(item));
    value.emptyReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/List.emptyReason'));
end;

procedure TFHIRTurtleComposer.ComposeList(parent :  TTurtleComplex; parentType, name : String; value : TFhirList; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:List');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'List', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'List', 'status', value.statusElement, CODES_TFhirListStatusEnum, SYSTEMS_TFhirListStatusEnum, false, -1);
  ComposeEnum(this, 'List', 'mode', value.modeElement, CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'List', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'List', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'List', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'List', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'List', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'List', 'source', value.sourceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'List', 'orderedBy', value.orderedByElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'List', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.entryList.Count - 1 do
      ComposeListEntry(this, 'List', 'entry', value.entryList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'List', 'emptyReason', value.emptyReasonElement, false, -1);
end;

{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
function TFHIRTurtleParser.ParseLocationPosition(obj : TTurtleComplex) : TFhirLocationPosition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirLocationPosition.create;
  try
    ParseLocationPositionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseLocationPositionProperties(obj : TTurtleComplex; value : TFhirLocationPosition);
begin
    ParseBackboneElementProperties(obj, value);
    value.longitudeElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Location.position.longitude'));
    value.latitudeElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Location.position.latitude'));
    value.altitudeElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Location.position.altitude'));
end;

procedure TFHIRTurtleComposer.ComposeLocationPosition(parent :  TTurtleComplex; parentType, name : String; value : TFhirLocationPosition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:LocationPosition');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeDecimal(this, 'Location.position', 'longitude', value.longitudeElement, false, -1);
  ComposeDecimal(this, 'Location.position', 'latitude', value.latitudeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Location.position', 'altitude', value.altitudeElement, false, -1);
end;

function TFHIRTurtleParser.ParseLocation(obj : TTurtleComplex) : TFhirLocation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirLocation.create;
  try
    ParseLocationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseLocationProperties(obj : TTurtleComplex; value : TFhirLocation);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Location.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Location.status'), CODES_TFhirLocationStatusEnum, SYSTEMS_TFhirLocationStatusEnum);
    value.operationalStatus := ParseCoding(obj.complex('http://hl7.org/fhir/Location.operationalStatus'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Location.name'));
    for item in obj.complexes('http://hl7.org/fhir/Location.alias') do
      value.aliasList.Add(parseString(item));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Location.description'));
    value.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/Location.mode'), CODES_TFhirLocationModeEnum, SYSTEMS_TFhirLocationModeEnum);
    for item in obj.complexes('http://hl7.org/fhir/Location.type') do
      value.type_List.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Location.contact') do
      value.contactList.Add(parseExtendedContactDetail(item));
    value.address := ParseAddress(obj.complex('http://hl7.org/fhir/Location.address'));
    value.form := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Location.form'));
    value.position := ParseLocationPosition(obj.complex('http://hl7.org/fhir/Location.position'));
    value.managingOrganization := ParseReference(obj.complex('http://hl7.org/fhir/Location.managingOrganization'));
    value.partOf := ParseReference(obj.complex('http://hl7.org/fhir/Location.partOf'));
    for item in obj.complexes('http://hl7.org/fhir/Location.characteristic') do
      value.characteristicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Location.hoursOfOperation') do
      value.hoursOfOperationList.Add(parseAvailability(item));
    for item in obj.complexes('http://hl7.org/fhir/Location.virtualService') do
      value.virtualServiceList.Add(parseVirtualServiceDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Location.endpoint') do
      value.endpointList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeLocation(parent :  TTurtleComplex; parentType, name : String; value : TFhirLocation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Location');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Location', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Location', 'status', value.statusElement, CODES_TFhirLocationStatusEnum, SYSTEMS_TFhirLocationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(this, 'Location', 'operationalStatus', value.operationalStatusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Location', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.aliasList.Count - 1 do
      ComposeString(this, 'Location', 'alias', value.aliasList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Location', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Location', 'mode', value.modeElement, CODES_TFhirLocationModeEnum, SYSTEMS_TFhirLocationModeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Location', 'type', value.type_List[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeExtendedContactDetail(this, 'Location', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(this, 'Location', 'address', value.addressElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Location', 'form', value.formElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeLocationPosition(this, 'Location', 'position', value.positionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Location', 'managingOrganization', value.managingOrganizationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Location', 'partOf', value.partOfElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.characteristicList.Count - 1 do
      ComposeCodeableConcept(this, 'Location', 'characteristic', value.characteristicList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.hoursOfOperationList.Count - 1 do
      ComposeAvailability(this, 'Location', 'hoursOfOperation', value.hoursOfOperationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.virtualServiceList.Count - 1 do
      ComposeVirtualServiceDetail(this, 'Location', 'virtualService', value.virtualServiceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endpointList.Count - 1 do
      ComposeReference(this, 'Location', 'endpoint', value.endpointList[i], false, i);
end;

{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MANUFACTUREDITEMDEFINITION}
function TFHIRTurtleParser.ParseManufacturedItemDefinitionProperty(obj : TTurtleComplex) : TFhirManufacturedItemDefinitionProperty;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirManufacturedItemDefinitionProperty.create;
  try
    ParseManufacturedItemDefinitionPropertyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseManufacturedItemDefinitionPropertyProperties(obj : TTurtleComplex; value : TFhirManufacturedItemDefinitionProperty);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ManufacturedItemDefinition.property.type'));
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueAttachment', item) then
      value.value := parseAttachment(item);
    if obj.has('valueDate', item) then
      value.value := parseDate(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
end;

procedure TFHIRTurtleComposer.ComposeManufacturedItemDefinitionProperty(parent :  TTurtleComplex; parentType, name : String; value : TFhirManufacturedItemDefinitionProperty; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ManufacturedItemDefinitionProperty');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'ManufacturedItemDefinition.property', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ManufacturedItemDefinition.property', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ManufacturedItemDefinition.property', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'ManufacturedItemDefinition.property', 'valueAttachment', TFhirAttachment(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirDate) {6} then
    ComposeDate(this, 'ManufacturedItemDefinition.property', 'valueDate', TFhirDate(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ManufacturedItemDefinition.property', 'valueBoolean', TFhirBoolean(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseManufacturedItemDefinitionComponent(obj : TTurtleComplex) : TFhirManufacturedItemDefinitionComponent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirManufacturedItemDefinitionComponent.create;
  try
    ParseManufacturedItemDefinitionComponentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseManufacturedItemDefinitionComponentProperties(obj : TTurtleComplex; value : TFhirManufacturedItemDefinitionComponent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ManufacturedItemDefinition.component.type'));
    for item in obj.complexes('http://hl7.org/fhir/ManufacturedItemDefinition.component.function') do
      value.function_List.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ManufacturedItemDefinition.component.amount') do
      value.amountList.Add(parseQuantity(item));
    for item in obj.complexes('http://hl7.org/fhir/ManufacturedItemDefinition.component.constituent') do
      value.constituentList.Add(parseManufacturedItemDefinitionComponentConstituent(item));
    for item in obj.complexes('http://hl7.org/fhir/ManufacturedItemDefinition.component.property') do
      value.property_List.Add(parseManufacturedItemDefinitionProperty(item));
    for item in obj.complexes('http://hl7.org/fhir/ManufacturedItemDefinition.component.component') do
      value.componentList.Add(parseManufacturedItemDefinitionComponent(item));
end;

procedure TFHIRTurtleComposer.ComposeManufacturedItemDefinitionComponent(parent :  TTurtleComplex; parentType, name : String; value : TFhirManufacturedItemDefinitionComponent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ManufacturedItemDefinitionComponent');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'ManufacturedItemDefinition.component', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.function_List.Count - 1 do
      ComposeCodeableConcept(this, 'ManufacturedItemDefinition.component', 'function', value.function_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.amountList.Count - 1 do
      ComposeQuantity(this, 'ManufacturedItemDefinition.component', 'amount', value.amountList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.constituentList.Count - 1 do
      ComposeManufacturedItemDefinitionComponentConstituent(this, 'ManufacturedItemDefinition.component', 'constituent', value.constituentList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeManufacturedItemDefinitionProperty(this, 'ManufacturedItemDefinition.component', 'property', value.property_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.componentList.Count - 1 do
      ComposeManufacturedItemDefinitionComponent(this, 'ManufacturedItemDefinition.component', 'component', value.componentList[i], false, i);
end;

function TFHIRTurtleParser.ParseManufacturedItemDefinitionComponentConstituent(obj : TTurtleComplex) : TFhirManufacturedItemDefinitionComponentConstituent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirManufacturedItemDefinitionComponentConstituent.create;
  try
    ParseManufacturedItemDefinitionComponentConstituentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseManufacturedItemDefinitionComponentConstituentProperties(obj : TTurtleComplex; value : TFhirManufacturedItemDefinitionComponentConstituent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/ManufacturedItemDefinition.component.constituent.amount') do
      value.amountList.Add(parseQuantity(item));
    for item in obj.complexes('http://hl7.org/fhir/ManufacturedItemDefinition.component.constituent.location') do
      value.locationList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ManufacturedItemDefinition.component.constituent.function') do
      value.function_List.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ManufacturedItemDefinition.component.constituent.locationForIngredient') do
      value.locationForIngredientList.Add(parseCodeableReference(item));
end;

procedure TFHIRTurtleComposer.ComposeManufacturedItemDefinitionComponentConstituent(parent :  TTurtleComplex; parentType, name : String; value : TFhirManufacturedItemDefinitionComponentConstituent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ManufacturedItemDefinitionComponentConstituent');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.amountList.Count - 1 do
      ComposeQuantity(this, 'ManufacturedItemDefinition.component.constituent', 'amount', value.amountList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.locationList.Count - 1 do
      ComposeCodeableConcept(this, 'ManufacturedItemDefinition.component.constituent', 'location', value.locationList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.function_List.Count - 1 do
      ComposeCodeableConcept(this, 'ManufacturedItemDefinition.component.constituent', 'function', value.function_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.locationForIngredientList.Count - 1 do
      ComposeCodeableReference(this, 'ManufacturedItemDefinition.component.constituent', 'locationForIngredient', value.locationForIngredientList[i], false, i);
end;

function TFHIRTurtleParser.ParseManufacturedItemDefinition(obj : TTurtleComplex) : TFhirManufacturedItemDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirManufacturedItemDefinition.create;
  try
    ParseManufacturedItemDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseManufacturedItemDefinitionProperties(obj : TTurtleComplex; value : TFhirManufacturedItemDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/ManufacturedItemDefinition.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ManufacturedItemDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ManufacturedItemDefinition.name'));
    value.manufacturedDoseForm := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ManufacturedItemDefinition.manufacturedDoseForm'));
    value.unitOfPresentation := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ManufacturedItemDefinition.unitOfPresentation'));
    for item in obj.complexes('http://hl7.org/fhir/ManufacturedItemDefinition.manufacturer') do
      value.manufacturerList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ManufacturedItemDefinition.marketingStatus') do
      value.marketingStatusList.Add(parseMarketingStatus(item));
    for item in obj.complexes('http://hl7.org/fhir/ManufacturedItemDefinition.ingredient') do
      value.ingredientList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ManufacturedItemDefinition.property') do
      value.property_List.Add(parseManufacturedItemDefinitionProperty(item));
    for item in obj.complexes('http://hl7.org/fhir/ManufacturedItemDefinition.component') do
      value.componentList.Add(parseManufacturedItemDefinitionComponent(item));
end;

procedure TFHIRTurtleComposer.ComposeManufacturedItemDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirManufacturedItemDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ManufacturedItemDefinition');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ManufacturedItemDefinition', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'ManufacturedItemDefinition', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ManufacturedItemDefinition', 'name', value.nameElement, false, -1);
  ComposeCodeableConcept(this, 'ManufacturedItemDefinition', 'manufacturedDoseForm', value.manufacturedDoseFormElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ManufacturedItemDefinition', 'unitOfPresentation', value.unitOfPresentationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.manufacturerList.Count - 1 do
      ComposeReference(this, 'ManufacturedItemDefinition', 'manufacturer', value.manufacturerList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.marketingStatusList.Count - 1 do
      ComposeMarketingStatus(this, 'ManufacturedItemDefinition', 'marketingStatus', value.marketingStatusList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.ingredientList.Count - 1 do
      ComposeCodeableConcept(this, 'ManufacturedItemDefinition', 'ingredient', value.ingredientList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeManufacturedItemDefinitionProperty(this, 'ManufacturedItemDefinition', 'property', value.property_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.componentList.Count - 1 do
      ComposeManufacturedItemDefinitionComponent(this, 'ManufacturedItemDefinition', 'component', value.componentList[i], false, i);
end;

{$ENDIF FHIR_MANUFACTUREDITEMDEFINITION}
{$IFDEF FHIR_MEASURE}
function TFHIRTurtleParser.ParseMeasureTerm(obj : TTurtleComplex) : TFhirMeasureTerm;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureTerm.create;
  try
    ParseMeasureTermProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureTermProperties(obj : TTurtleComplex; value : TFhirMeasureTerm);
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Measure.term.code'));
    value.definitionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Measure.term.definition'));
end;

procedure TFHIRTurtleComposer.ComposeMeasureTerm(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureTerm; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureTerm');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Measure.term', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'Measure.term', 'definition', value.definitionElement, false, -1);
end;

function TFHIRTurtleParser.ParseMeasureGroup(obj : TTurtleComplex) : TFhirMeasureGroup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureGroup.create;
  try
    ParseMeasureGroupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureGroupProperties(obj : TTurtleComplex; value : TFhirMeasureGroup);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Measure.group.code'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.group.description'));
    for item in obj.complexes('http://hl7.org/fhir/Measure.group.type') do
      value.type_List.Add(parseCodeableConcept(item));
    value.basisElement := ParseEnum(obj.complex('http://hl7.org/fhir/Measure.group.basis'), CODES_TFhirFHIRTypesEnum, SYSTEMS_TFhirFHIRTypesEnum);
    value.scoring := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Measure.group.scoring'));
    value.scoringUnit := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Measure.group.scoringUnit'));
    value.improvementNotation := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Measure.group.improvementNotation'));
    for item in obj.complexes('http://hl7.org/fhir/Measure.group.population') do
      value.populationList.Add(parseMeasureGroupPopulation(item));
    for item in obj.complexes('http://hl7.org/fhir/Measure.group.stratifier') do
      value.stratifierList.Add(parseMeasureGroupStratifier(item));
end;

procedure TFHIRTurtleComposer.ComposeMeasureGroup(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureGroup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureGroup');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Measure.group', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Measure.group', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Measure.group', 'type', value.type_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Measure.group', 'basis', value.basisElement, CODES_TFhirFHIRTypesEnum, SYSTEMS_TFhirFHIRTypesEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Measure.group', 'scoring', value.scoringElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Measure.group', 'scoringUnit', value.scoringUnitElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Measure.group', 'improvementNotation', value.improvementNotationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.populationList.Count - 1 do
      ComposeMeasureGroupPopulation(this, 'Measure.group', 'population', value.populationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.stratifierList.Count - 1 do
      ComposeMeasureGroupStratifier(this, 'Measure.group', 'stratifier', value.stratifierList[i], false, i);
end;

function TFHIRTurtleParser.ParseMeasureGroupPopulation(obj : TTurtleComplex) : TFhirMeasureGroupPopulation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureGroupPopulation.create;
  try
    ParseMeasureGroupPopulationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureGroupPopulationProperties(obj : TTurtleComplex; value : TFhirMeasureGroupPopulation);
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Measure.group.population.code'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.group.population.description'));
    value.criteria := ParseExpression(obj.complex('http://hl7.org/fhir/Measure.group.population.criteria'));
    value.inputPopulationIdElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.group.population.inputPopulationId'));
    value.aggregateMethod := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Measure.group.population.aggregateMethod'));
end;

procedure TFHIRTurtleComposer.ComposeMeasureGroupPopulation(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureGroupPopulation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureGroupPopulation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Measure.group.population', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Measure.group.population', 'description', value.descriptionElement, false, -1);
  ComposeExpression(this, 'Measure.group.population', 'criteria', value.criteriaElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Measure.group.population', 'inputPopulationId', value.inputPopulationIdElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Measure.group.population', 'aggregateMethod', value.aggregateMethodElement, false, -1);
end;

function TFHIRTurtleParser.ParseMeasureGroupStratifier(obj : TTurtleComplex) : TFhirMeasureGroupStratifier;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureGroupStratifier.create;
  try
    ParseMeasureGroupStratifierProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureGroupStratifierProperties(obj : TTurtleComplex; value : TFhirMeasureGroupStratifier);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Measure.group.stratifier.code'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.group.stratifier.description'));
    value.criteria := ParseExpression(obj.complex('http://hl7.org/fhir/Measure.group.stratifier.criteria'));
    for item in obj.complexes('http://hl7.org/fhir/Measure.group.stratifier.component') do
      value.componentList.Add(parseMeasureGroupStratifierComponent(item));
end;

procedure TFHIRTurtleComposer.ComposeMeasureGroupStratifier(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureGroupStratifier; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureGroupStratifier');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Measure.group.stratifier', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Measure.group.stratifier', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeExpression(this, 'Measure.group.stratifier', 'criteria', value.criteriaElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.componentList.Count - 1 do
      ComposeMeasureGroupStratifierComponent(this, 'Measure.group.stratifier', 'component', value.componentList[i], false, i);
end;

function TFHIRTurtleParser.ParseMeasureGroupStratifierComponent(obj : TTurtleComplex) : TFhirMeasureGroupStratifierComponent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureGroupStratifierComponent.create;
  try
    ParseMeasureGroupStratifierComponentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureGroupStratifierComponentProperties(obj : TTurtleComplex; value : TFhirMeasureGroupStratifierComponent);
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Measure.group.stratifier.component.code'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.group.stratifier.component.description'));
    value.criteria := ParseExpression(obj.complex('http://hl7.org/fhir/Measure.group.stratifier.component.criteria'));
end;

procedure TFHIRTurtleComposer.ComposeMeasureGroupStratifierComponent(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureGroupStratifierComponent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureGroupStratifierComponent');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Measure.group.stratifier.component', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Measure.group.stratifier.component', 'description', value.descriptionElement, false, -1);
  ComposeExpression(this, 'Measure.group.stratifier.component', 'criteria', value.criteriaElement, false, -1);
end;

function TFHIRTurtleParser.ParseMeasureSupplementalData(obj : TTurtleComplex) : TFhirMeasureSupplementalData;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureSupplementalData.create;
  try
    ParseMeasureSupplementalDataProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureSupplementalDataProperties(obj : TTurtleComplex; value : TFhirMeasureSupplementalData);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Measure.supplementalData.code'));
    for item in obj.complexes('http://hl7.org/fhir/Measure.supplementalData.usage') do
      value.usageList.Add(parseCodeableConcept(item));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.supplementalData.description'));
    value.criteria := ParseExpression(obj.complex('http://hl7.org/fhir/Measure.supplementalData.criteria'));
end;

procedure TFHIRTurtleComposer.ComposeMeasureSupplementalData(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureSupplementalData; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureSupplementalData');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Measure.supplementalData', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.usageList.Count - 1 do
      ComposeCodeableConcept(this, 'Measure.supplementalData', 'usage', value.usageList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Measure.supplementalData', 'description', value.descriptionElement, false, -1);
  ComposeExpression(this, 'Measure.supplementalData', 'criteria', value.criteriaElement, false, -1);
end;

function TFHIRTurtleParser.ParseMeasure(obj : TTurtleComplex) : TFhirMeasure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasure.create;
  try
    ParseMeasureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureProperties(obj : TTurtleComplex; value : TFhirMeasure);
var
  item : TTurtleComplex;
begin
    ParseMetadataResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Measure.url'));
    for item in obj.complexes('http://hl7.org/fhir/Measure.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.version'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.title'));
    value.subtitleElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.subtitle'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Measure.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Measure.experimental'));
    if obj.has('subjectCodeableConcept', item) then
      value.subject := parseCodeableConcept(item);
    if obj.has('subjectReference', item) {a3} then
      value.subject := ParseReference(item);
    value.basisElement := ParseEnum(obj.complex('http://hl7.org/fhir/Measure.basis'), CODES_TFhirFHIRTypesEnum, SYSTEMS_TFhirFHIRTypesEnum);
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Measure.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/Measure.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Measure.description'));
    for item in obj.complexes('http://hl7.org/fhir/Measure.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/Measure.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Measure.purpose'));
    value.usageElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.usage'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Measure.copyright'));
    value.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Measure.approvalDate'));
    value.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Measure.lastReviewDate'));
    value.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Measure.effectivePeriod'));
    for item in obj.complexes('http://hl7.org/fhir/Measure.topic') do
      value.topicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Measure.author') do
      value.authorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Measure.editor') do
      value.editorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Measure.reviewer') do
      value.reviewerList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Measure.endorser') do
      value.endorserList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Measure.relatedArtifact') do
      value.relatedArtifactList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/Measure.library') do
      value.library_List.Add(parseCanonical(item));
    value.disclaimerElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Measure.disclaimer'));
    value.scoring := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Measure.scoring'));
    value.scoringUnit := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Measure.scoringUnit'));
    value.compositeScoring := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Measure.compositeScoring'));
    for item in obj.complexes('http://hl7.org/fhir/Measure.type') do
      value.type_List.Add(parseCodeableConcept(item));
    value.riskAdjustmentElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.riskAdjustment'));
    value.rateAggregationElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.rateAggregation'));
    value.rationaleElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Measure.rationale'));
    value.clinicalRecommendationStatementElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Measure.clinicalRecommendationStatement'));
    value.improvementNotation := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Measure.improvementNotation'));
    for item in obj.complexes('http://hl7.org/fhir/Measure.term') do
      value.termList.Add(parseMeasureTerm(item));
    value.guidanceElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Measure.guidance'));
    for item in obj.complexes('http://hl7.org/fhir/Measure.group') do
      value.groupList.Add(parseMeasureGroup(item));
    for item in obj.complexes('http://hl7.org/fhir/Measure.supplementalData') do
      value.supplementalDataList.Add(parseMeasureSupplementalData(item));
end;

procedure TFHIRTurtleComposer.ComposeMeasure(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Measure');
  end;
  composeMetadataResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'Measure', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Measure', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Measure', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Measure', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Measure', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Measure', 'subtitle', value.subtitleElement, false, -1);
  ComposeEnum(this, 'Measure', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Measure', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.subject is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Measure', 'subjectCodeableConcept', TFhirCodeableConcept(value.subject), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.subject is TFhirReference) {2} then
    ComposeReference(this, 'Measure', 'subjectReference', TFhirReference(value.subject), false,-1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Measure', 'basis', value.basisElement, CODES_TFhirFHIRTypesEnum, SYSTEMS_TFhirFHIRTypesEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Measure', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Measure', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'Measure', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'Measure', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'Measure', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'Measure', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'Measure', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Measure', 'usage', value.usageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'Measure', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'Measure', 'approvalDate', value.approvalDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'Measure', 'lastReviewDate', value.lastReviewDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Measure', 'effectivePeriod', value.effectivePeriodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.topicList.Count - 1 do
      ComposeCodeableConcept(this, 'Measure', 'topic', value.topicList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(this, 'Measure', 'author', value.authorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(this, 'Measure', 'editor', value.editorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(this, 'Measure', 'reviewer', value.reviewerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(this, 'Measure', 'endorser', value.endorserList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'Measure', 'relatedArtifact', value.relatedArtifactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.library_List.Count - 1 do
      ComposeCanonical(this, 'Measure', 'library', value.library_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'Measure', 'disclaimer', value.disclaimerElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Measure', 'scoring', value.scoringElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Measure', 'scoringUnit', value.scoringUnitElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Measure', 'compositeScoring', value.compositeScoringElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Measure', 'type', value.type_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Measure', 'riskAdjustment', value.riskAdjustmentElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Measure', 'rateAggregation', value.rateAggregationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'Measure', 'rationale', value.rationaleElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'Measure', 'clinicalRecommendationStatement', value.clinicalRecommendationStatementElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Measure', 'improvementNotation', value.improvementNotationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.termList.Count - 1 do
      ComposeMeasureTerm(this, 'Measure', 'term', value.termList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'Measure', 'guidance', value.guidanceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.groupList.Count - 1 do
      ComposeMeasureGroup(this, 'Measure', 'group', value.groupList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supplementalDataList.Count - 1 do
      ComposeMeasureSupplementalData(this, 'Measure', 'supplementalData', value.supplementalDataList[i], false, i);
end;

{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
function TFHIRTurtleParser.ParseMeasureReportGroup(obj : TTurtleComplex) : TFhirMeasureReportGroup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureReportGroup.create;
  try
    ParseMeasureReportGroupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureReportGroupProperties(obj : TTurtleComplex; value : TFhirMeasureReportGroup);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MeasureReport.group.code'));
    for item in obj.complexes('http://hl7.org/fhir/MeasureReport.group.population') do
      value.populationList.Add(parseMeasureReportGroupPopulation(item));
    if obj.has('measureScoreQuantity', item) then
      value.measureScore := parseQuantity(item);
    if obj.has('measureScoreCodeableConcept', item) then
      value.measureScore := parseCodeableConcept(item);
    if obj.has('measureScorePeriod', item) then
      value.measureScore := parsePeriod(item);
    if obj.has('measureScoreRange', item) then
      value.measureScore := parseRange(item);
    if obj.has('measureScoreDuration', item) then
      value.measureScore := parseDuration(item);
    if obj.has('measureScoreDateTime', item) then
      value.measureScore := parseDateTime(item);
    for item in obj.complexes('http://hl7.org/fhir/MeasureReport.group.stratifier') do
      value.stratifierList.Add(parseMeasureReportGroupStratifier(item));
end;

procedure TFHIRTurtleComposer.ComposeMeasureReportGroup(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureReportGroup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureReportGroup');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MeasureReport.group', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.populationList.Count - 1 do
      ComposeMeasureReportGroupPopulation(this, 'MeasureReport.group', 'population', value.populationList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.measureScore is TFhirQuantity) {6} then
    ComposeQuantity(this, 'MeasureReport.group', 'measureScoreQuantity', TFhirQuantity(value.measureScore), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.measureScore is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MeasureReport.group', 'measureScoreCodeableConcept', TFhirCodeableConcept(value.measureScore), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.measureScore is TFhirPeriod) {6} then
    ComposePeriod(this, 'MeasureReport.group', 'measureScorePeriod', TFhirPeriod(value.measureScore), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.measureScore is TFhirRange) {6} then
    ComposeRange(this, 'MeasureReport.group', 'measureScoreRange', TFhirRange(value.measureScore), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.measureScore is TFhirDuration) {6} then
    ComposeDuration(this, 'MeasureReport.group', 'measureScoreDuration', TFhirDuration(value.measureScore), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.measureScore is TFhirDateTime) {6} then
    ComposeDateTime(this, 'MeasureReport.group', 'measureScoreDateTime', TFhirDateTime(value.measureScore), false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.stratifierList.Count - 1 do
      ComposeMeasureReportGroupStratifier(this, 'MeasureReport.group', 'stratifier', value.stratifierList[i], false, i);
end;

function TFHIRTurtleParser.ParseMeasureReportGroupPopulation(obj : TTurtleComplex) : TFhirMeasureReportGroupPopulation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureReportGroupPopulation.create;
  try
    ParseMeasureReportGroupPopulationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureReportGroupPopulationProperties(obj : TTurtleComplex; value : TFhirMeasureReportGroupPopulation);
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MeasureReport.group.population.code'));
    value.countElement := ParseInteger(obj.complex('http://hl7.org/fhir/MeasureReport.group.population.count'));
    value.subjectResults := ParseReference(obj.complex('http://hl7.org/fhir/MeasureReport.group.population.subjectResults'));
end;

procedure TFHIRTurtleComposer.ComposeMeasureReportGroupPopulation(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureReportGroupPopulation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureReportGroupPopulation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MeasureReport.group.population', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'MeasureReport.group.population', 'count', value.countElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'MeasureReport.group.population', 'subjectResults', value.subjectResultsElement, false, -1);
end;

function TFHIRTurtleParser.ParseMeasureReportGroupStratifier(obj : TTurtleComplex) : TFhirMeasureReportGroupStratifier;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureReportGroupStratifier.create;
  try
    ParseMeasureReportGroupStratifierProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureReportGroupStratifierProperties(obj : TTurtleComplex; value : TFhirMeasureReportGroupStratifier);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MeasureReport.group.stratifier.code'));
    for item in obj.complexes('http://hl7.org/fhir/MeasureReport.group.stratifier.stratum') do
      value.stratumList.Add(parseMeasureReportGroupStratifierStratum(item));
end;

procedure TFHIRTurtleComposer.ComposeMeasureReportGroupStratifier(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureReportGroupStratifier; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureReportGroupStratifier');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MeasureReport.group.stratifier', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.stratumList.Count - 1 do
      ComposeMeasureReportGroupStratifierStratum(this, 'MeasureReport.group.stratifier', 'stratum', value.stratumList[i], false, i);
end;

function TFHIRTurtleParser.ParseMeasureReportGroupStratifierStratum(obj : TTurtleComplex) : TFhirMeasureReportGroupStratifierStratum;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureReportGroupStratifierStratum.create;
  try
    ParseMeasureReportGroupStratifierStratumProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureReportGroupStratifierStratumProperties(obj : TTurtleComplex; value : TFhirMeasureReportGroupStratifierStratum);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueRange', item) then
      value.value := parseRange(item);
    if obj.has('valueReference', item) then
      value.value := parseReference(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    for item in obj.complexes('http://hl7.org/fhir/MeasureReport.group.stratifier.stratum.component') do
      value.componentList.Add(parseMeasureReportGroupStratifierStratumComponent(item));
    for item in obj.complexes('http://hl7.org/fhir/MeasureReport.group.stratifier.stratum.population') do
      value.populationList.Add(parseMeasureReportGroupStratifierStratumPopulation(item));
    if obj.has('measureScoreQuantity', item) then
      value.measureScore := parseQuantity(item);
    if obj.has('measureScoreCodeableConcept', item) then
      value.measureScore := parseCodeableConcept(item);
    if obj.has('measureScorePeriod', item) then
      value.measureScore := parsePeriod(item);
    if obj.has('measureScoreRange', item) then
      value.measureScore := parseRange(item);
    if obj.has('measureScoreDuration', item) then
      value.measureScore := parseDuration(item);
    if obj.has('measureScoreDateTime', item) then
      value.measureScore := parseDateTime(item);
end;

procedure TFHIRTurtleComposer.ComposeMeasureReportGroupStratifierStratum(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureReportGroupStratifierStratum; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureReportGroupStratifierStratum');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MeasureReport.group.stratifier.stratum', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'MeasureReport.group.stratifier.stratum', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirRange) {6} then
    ComposeRange(this, 'MeasureReport.group.stratifier.stratum', 'valueRange', TFhirRange(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirReference) {6} then
    ComposeReference(this, 'MeasureReport.group.stratifier.stratum', 'valueReference', TFhirReference(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'MeasureReport.group.stratifier.stratum', 'valueBoolean', TFhirBoolean(value.value), false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.componentList.Count - 1 do
      ComposeMeasureReportGroupStratifierStratumComponent(this, 'MeasureReport.group.stratifier.stratum', 'component', value.componentList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.populationList.Count - 1 do
      ComposeMeasureReportGroupStratifierStratumPopulation(this, 'MeasureReport.group.stratifier.stratum', 'population', value.populationList[i], false, i);
  if (SummaryOption in [soFull, soData]) and (value.measureScore is TFhirQuantity) {6} then
    ComposeQuantity(this, 'MeasureReport.group.stratifier.stratum', 'measureScoreQuantity', TFhirQuantity(value.measureScore), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.measureScore is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MeasureReport.group.stratifier.stratum', 'measureScoreCodeableConcept', TFhirCodeableConcept(value.measureScore), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.measureScore is TFhirPeriod) {6} then
    ComposePeriod(this, 'MeasureReport.group.stratifier.stratum', 'measureScorePeriod', TFhirPeriod(value.measureScore), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.measureScore is TFhirRange) {6} then
    ComposeRange(this, 'MeasureReport.group.stratifier.stratum', 'measureScoreRange', TFhirRange(value.measureScore), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.measureScore is TFhirDuration) {6} then
    ComposeDuration(this, 'MeasureReport.group.stratifier.stratum', 'measureScoreDuration', TFhirDuration(value.measureScore), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.measureScore is TFhirDateTime) {6} then
    ComposeDateTime(this, 'MeasureReport.group.stratifier.stratum', 'measureScoreDateTime', TFhirDateTime(value.measureScore), false, -1);
end;

function TFHIRTurtleParser.ParseMeasureReportGroupStratifierStratumComponent(obj : TTurtleComplex) : TFhirMeasureReportGroupStratifierStratumComponent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureReportGroupStratifierStratumComponent.create;
  try
    ParseMeasureReportGroupStratifierStratumComponentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureReportGroupStratifierStratumComponentProperties(obj : TTurtleComplex; value : TFhirMeasureReportGroupStratifierStratumComponent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MeasureReport.group.stratifier.stratum.component.code'));
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueRange', item) then
      value.value := parseRange(item);
    if obj.has('valueReference', item) then
      value.value := parseReference(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
end;

procedure TFHIRTurtleComposer.ComposeMeasureReportGroupStratifierStratumComponent(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureReportGroupStratifierStratumComponent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureReportGroupStratifierStratumComponent');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'MeasureReport.group.stratifier.stratum.component', 'code', value.codeElement, false, -1);
  if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MeasureReport.group.stratifier.stratum.component', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'MeasureReport.group.stratifier.stratum.component', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (value.value is TFhirRange) {6} then
    ComposeRange(this, 'MeasureReport.group.stratifier.stratum.component', 'valueRange', TFhirRange(value.value), false, -1)
  else if (value.value is TFhirReference) {6} then
    ComposeReference(this, 'MeasureReport.group.stratifier.stratum.component', 'valueReference', TFhirReference(value.value), false, -1)
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'MeasureReport.group.stratifier.stratum.component', 'valueBoolean', TFhirBoolean(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseMeasureReportGroupStratifierStratumPopulation(obj : TTurtleComplex) : TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureReportGroupStratifierStratumPopulation.create;
  try
    ParseMeasureReportGroupStratifierStratumPopulationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureReportGroupStratifierStratumPopulationProperties(obj : TTurtleComplex; value : TFhirMeasureReportGroupStratifierStratumPopulation);
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MeasureReport.group.stratifier.stratum.population.code'));
    value.countElement := ParseInteger(obj.complex('http://hl7.org/fhir/MeasureReport.group.stratifier.stratum.population.count'));
    value.subjectResults := ParseReference(obj.complex('http://hl7.org/fhir/MeasureReport.group.stratifier.stratum.population.subjectResults'));
end;

procedure TFHIRTurtleComposer.ComposeMeasureReportGroupStratifierStratumPopulation(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureReportGroupStratifierStratumPopulation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureReportGroupStratifierStratumPopulation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MeasureReport.group.stratifier.stratum.population', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'MeasureReport.group.stratifier.stratum.population', 'count', value.countElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'MeasureReport.group.stratifier.stratum.population', 'subjectResults', value.subjectResultsElement, false, -1);
end;

function TFHIRTurtleParser.ParseMeasureReport(obj : TTurtleComplex) : TFhirMeasureReport;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureReport.create;
  try
    ParseMeasureReportProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureReportProperties(obj : TTurtleComplex; value : TFhirMeasureReport);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/MeasureReport.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/MeasureReport.status'), CODES_TFhirMeasureReportStatusEnum, SYSTEMS_TFhirMeasureReportStatusEnum);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/MeasureReport.type'), CODES_TFhirMeasureReportTypeEnum, SYSTEMS_TFhirMeasureReportTypeEnum);
    value.dataUpdateTypeElement := ParseEnum(obj.complex('http://hl7.org/fhir/MeasureReport.dataUpdateType'), CODES_TFhirSubmitDataUpdateTypeEnum, SYSTEMS_TFhirSubmitDataUpdateTypeEnum);
    value.measureElement := ParseCanonical(obj.complex('http://hl7.org/fhir/MeasureReport.measure'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/MeasureReport.subject'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MeasureReport.date'));
    value.reporter := ParseReference(obj.complex('http://hl7.org/fhir/MeasureReport.reporter'));
    value.reportingVendor := ParseReference(obj.complex('http://hl7.org/fhir/MeasureReport.reportingVendor'));
    value.location := ParseReference(obj.complex('http://hl7.org/fhir/MeasureReport.location'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/MeasureReport.period'));
    value.inputParameters := ParseReference(obj.complex('http://hl7.org/fhir/MeasureReport.inputParameters'));
    value.scoring := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MeasureReport.scoring'));
    value.improvementNotation := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MeasureReport.improvementNotation'));
    for item in obj.complexes('http://hl7.org/fhir/MeasureReport.group') do
      value.groupList.Add(parseMeasureReportGroup(item));
    for item in obj.complexes('http://hl7.org/fhir/MeasureReport.evaluatedResource') do
      value.evaluatedResourceList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeMeasureReport(parent :  TTurtleComplex; parentType, name : String; value : TFhirMeasureReport; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureReport');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MeasureReport', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'MeasureReport', 'status', value.statusElement, CODES_TFhirMeasureReportStatusEnum, SYSTEMS_TFhirMeasureReportStatusEnum, false, -1);
  ComposeEnum(this, 'MeasureReport', 'type', value.type_Element, CODES_TFhirMeasureReportTypeEnum, SYSTEMS_TFhirMeasureReportTypeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'MeasureReport', 'dataUpdateType', value.dataUpdateTypeElement, CODES_TFhirSubmitDataUpdateTypeEnum, SYSTEMS_TFhirSubmitDataUpdateTypeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(this, 'MeasureReport', 'measure', value.measureElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'MeasureReport', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'MeasureReport', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'MeasureReport', 'reporter', value.reporterElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'MeasureReport', 'reportingVendor', value.reportingVendorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'MeasureReport', 'location', value.locationElement, false, -1);
  ComposePeriod(this, 'MeasureReport', 'period', value.periodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'MeasureReport', 'inputParameters', value.inputParametersElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MeasureReport', 'scoring', value.scoringElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MeasureReport', 'improvementNotation', value.improvementNotationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.groupList.Count - 1 do
      ComposeMeasureReportGroup(this, 'MeasureReport', 'group', value.groupList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.evaluatedResourceList.Count - 1 do
      ComposeReference(this, 'MeasureReport', 'evaluatedResource', value.evaluatedResourceList[i], false, i);
end;

{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDICATION}
function TFHIRTurtleParser.ParseMedicationIngredient(obj : TTurtleComplex) : TFhirMedicationIngredient;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationIngredient.create;
  try
    ParseMedicationIngredientProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationIngredientProperties(obj : TTurtleComplex; value : TFhirMedicationIngredient);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.item := ParseCodeableReference(obj.complex('http://hl7.org/fhir/Medication.ingredient.item'));
    value.isActiveElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Medication.ingredient.isActive'));
    if obj.has('strengthRatio', item) then
      value.strength := parseRatio(item);
    if obj.has('strengthCodeableConcept', item) then
      value.strength := parseCodeableConcept(item);
    if obj.has('strengthQuantity', item) then
      value.strength := parseQuantity(item);
end;

procedure TFHIRTurtleComposer.ComposeMedicationIngredient(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationIngredient; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationIngredient');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableReference(this, 'Medication.ingredient', 'item', value.itemElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Medication.ingredient', 'isActive', value.isActiveElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.strength is TFhirRatio) {6} then
    ComposeRatio(this, 'Medication.ingredient', 'strengthRatio', TFhirRatio(value.strength), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.strength is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Medication.ingredient', 'strengthCodeableConcept', TFhirCodeableConcept(value.strength), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.strength is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Medication.ingredient', 'strengthQuantity', TFhirQuantity(value.strength), false, -1);
end;

function TFHIRTurtleParser.ParseMedicationBatch(obj : TTurtleComplex) : TFhirMedicationBatch;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationBatch.create;
  try
    ParseMedicationBatchProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationBatchProperties(obj : TTurtleComplex; value : TFhirMedicationBatch);
begin
    ParseBackboneElementProperties(obj, value);
    value.lotNumberElement := ParseString(obj.complex('http://hl7.org/fhir/Medication.batch.lotNumber'));
    value.expirationDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Medication.batch.expirationDate'));
end;

procedure TFHIRTurtleComposer.ComposeMedicationBatch(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationBatch; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationBatch');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Medication.batch', 'lotNumber', value.lotNumberElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Medication.batch', 'expirationDate', value.expirationDateElement, false, -1);
end;

function TFHIRTurtleParser.ParseMedication(obj : TTurtleComplex) : TFhirMedication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedication.create;
  try
    ParseMedicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationProperties(obj : TTurtleComplex; value : TFhirMedication);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Medication.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Medication.code'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Medication.status'), CODES_TFhirMedicationStatusCodesEnum, SYSTEMS_TFhirMedicationStatusCodesEnum);
    value.marketingAuthorizationHolder := ParseReference(obj.complex('http://hl7.org/fhir/Medication.marketingAuthorizationHolder'));
    value.doseForm := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Medication.doseForm'));
    value.totalVolume := ParseRatio(obj.complex('http://hl7.org/fhir/Medication.totalVolume'));
    for item in obj.complexes('http://hl7.org/fhir/Medication.ingredient') do
      value.ingredientList.Add(parseMedicationIngredient(item));
    value.batch := ParseMedicationBatch(obj.complex('http://hl7.org/fhir/Medication.batch'));
end;

procedure TFHIRTurtleComposer.ComposeMedication(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Medication');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Medication', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Medication', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Medication', 'status', value.statusElement, CODES_TFhirMedicationStatusCodesEnum, SYSTEMS_TFhirMedicationStatusCodesEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Medication', 'marketingAuthorizationHolder', value.marketingAuthorizationHolderElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Medication', 'doseForm', value.doseFormElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(this, 'Medication', 'totalVolume', value.totalVolumeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.ingredientList.Count - 1 do
      ComposeMedicationIngredient(this, 'Medication', 'ingredient', value.ingredientList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationBatch(this, 'Medication', 'batch', value.batchElement, false, -1);
end;

{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
function TFHIRTurtleParser.ParseMedicationAdministrationPerformer(obj : TTurtleComplex) : TFhirMedicationAdministrationPerformer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationAdministrationPerformer.create;
  try
    ParseMedicationAdministrationPerformerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationAdministrationPerformerProperties(obj : TTurtleComplex; value : TFhirMedicationAdministrationPerformer);
begin
    ParseBackboneElementProperties(obj, value);
    value.function_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationAdministration.performer.function'));
    value.actor := ParseReference(obj.complex('http://hl7.org/fhir/MedicationAdministration.performer.actor'));
end;

procedure TFHIRTurtleComposer.ComposeMedicationAdministrationPerformer(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationAdministrationPerformer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationAdministrationPerformer');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationAdministration.performer', 'function', value.function_Element, false, -1);
  ComposeReference(this, 'MedicationAdministration.performer', 'actor', value.actorElement, false, -1);
end;

function TFHIRTurtleParser.ParseMedicationAdministrationDosage(obj : TTurtleComplex) : TFhirMedicationAdministrationDosage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationAdministrationDosage.create;
  try
    ParseMedicationAdministrationDosageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationAdministrationDosageProperties(obj : TTurtleComplex; value : TFhirMedicationAdministrationDosage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.textElement := ParseString(obj.complex('http://hl7.org/fhir/MedicationAdministration.dosage.text'));
    value.site := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationAdministration.dosage.site'));
    value.route := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationAdministration.dosage.route'));
    value.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationAdministration.dosage.method'));
    value.dose := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicationAdministration.dosage.dose'));
    if obj.has('rateRatio', item) then
      value.rate := parseRatio(item);
    if obj.has('rateQuantity', item) then
      value.rate := parseQuantity(item);
end;

procedure TFHIRTurtleComposer.ComposeMedicationAdministrationDosage(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationAdministrationDosage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationAdministrationDosage');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'MedicationAdministration.dosage', 'text', value.textElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationAdministration.dosage', 'site', value.siteElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationAdministration.dosage', 'route', value.routeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationAdministration.dosage', 'method', value.methodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'MedicationAdministration.dosage', 'dose', value.doseElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.rate is TFhirRatio) {6} then
    ComposeRatio(this, 'MedicationAdministration.dosage', 'rateRatio', TFhirRatio(value.rate), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.rate is TFhirQuantity) {6} then
    ComposeQuantity(this, 'MedicationAdministration.dosage', 'rateQuantity', TFhirQuantity(value.rate), false, -1);
end;

function TFHIRTurtleParser.ParseMedicationAdministration(obj : TTurtleComplex) : TFhirMedicationAdministration;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationAdministration.create;
  try
    ParseMedicationAdministrationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationAdministrationProperties(obj : TTurtleComplex; value : TFhirMedicationAdministration);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.basedOn') do
      value.basedOnList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.partOf') do
      value.partOfList.Add(parseReference(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/MedicationAdministration.status'), CODES_TFhirMedicationAdministrationStatusCodesEnum, SYSTEMS_TFhirMedicationAdministrationStatusCodesEnum);
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.statusReason') do
      value.statusReasonList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    value.medication := ParseCodeableReference(obj.complex('http://hl7.org/fhir/MedicationAdministration.medication'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/MedicationAdministration.subject'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/MedicationAdministration.encounter'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.supportingInformation') do
      value.supportingInformationList.Add(parseReference(item));
    if obj.has('occurencePeriod', item) then
      value.occurence := parsePeriod(item);
    if obj.has('occurenceDateTime', item) then
      value.occurence := parseDateTime(item);
    value.recordedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicationAdministration.recorded'));
    value.isSubPotentElement := ParseBoolean(obj.complex('http://hl7.org/fhir/MedicationAdministration.isSubPotent'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.subPotentReason') do
      value.subPotentReasonList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.performer') do
      value.performerList.Add(parseMedicationAdministrationPerformer(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.reason') do
      value.reasonList.Add(parseCodeableReference(item));
    value.request := ParseReference(obj.complex('http://hl7.org/fhir/MedicationAdministration.request'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.device') do
      value.deviceList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.note') do
      value.noteList.Add(parseAnnotation(item));
    value.dosage := ParseMedicationAdministrationDosage(obj.complex('http://hl7.org/fhir/MedicationAdministration.dosage'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.eventHistory') do
      value.eventHistoryList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationAdministration(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationAdministration; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationAdministration');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicationAdministration', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'MedicationAdministration', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(this, 'MedicationAdministration', 'partOf', value.partOfList[i], false, i);
  ComposeEnum(this, 'MedicationAdministration', 'status', value.statusElement, CODES_TFhirMedicationAdministrationStatusCodesEnum, SYSTEMS_TFhirMedicationAdministrationStatusCodesEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.statusReasonList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationAdministration', 'statusReason', value.statusReasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationAdministration', 'category', value.categoryList[i], false, i);
  ComposeCodeableReference(this, 'MedicationAdministration', 'medication', value.medicationElement, false, -1);
  ComposeReference(this, 'MedicationAdministration', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'MedicationAdministration', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInformationList.Count - 1 do
      ComposeReference(this, 'MedicationAdministration', 'supportingInformation', value.supportingInformationList[i], false, i);
  if (value.occurence is TFhirPeriod) {6} then
    ComposePeriod(this, 'MedicationAdministration', 'occurencePeriod', TFhirPeriod(value.occurence), false, -1)
  else if (value.occurence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'MedicationAdministration', 'occurenceDateTime', TFhirDateTime(value.occurence), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'MedicationAdministration', 'recorded', value.recordedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'MedicationAdministration', 'isSubPotent', value.isSubPotentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subPotentReasonList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationAdministration', 'subPotentReason', value.subPotentReasonList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeMedicationAdministrationPerformer(this, 'MedicationAdministration', 'performer', value.performerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(this, 'MedicationAdministration', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'MedicationAdministration', 'request', value.requestElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.deviceList.Count - 1 do
      ComposeReference(this, 'MedicationAdministration', 'device', value.deviceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'MedicationAdministration', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationAdministrationDosage(this, 'MedicationAdministration', 'dosage', value.dosageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.eventHistoryList.Count - 1 do
      ComposeReference(this, 'MedicationAdministration', 'eventHistory', value.eventHistoryList[i], false, i);
end;

{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
function TFHIRTurtleParser.ParseMedicationDispensePerformer(obj : TTurtleComplex) : TFhirMedicationDispensePerformer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationDispensePerformer.create;
  try
    ParseMedicationDispensePerformerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationDispensePerformerProperties(obj : TTurtleComplex; value : TFhirMedicationDispensePerformer);
begin
    ParseBackboneElementProperties(obj, value);
    value.function_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationDispense.performer.function'));
    value.actor := ParseReference(obj.complex('http://hl7.org/fhir/MedicationDispense.performer.actor'));
end;

procedure TFHIRTurtleComposer.ComposeMedicationDispensePerformer(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationDispensePerformer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationDispensePerformer');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationDispense.performer', 'function', value.function_Element, false, -1);
  ComposeReference(this, 'MedicationDispense.performer', 'actor', value.actorElement, false, -1);
end;

function TFHIRTurtleParser.ParseMedicationDispenseSubstitution(obj : TTurtleComplex) : TFhirMedicationDispenseSubstitution;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationDispenseSubstitution.create;
  try
    ParseMedicationDispenseSubstitutionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationDispenseSubstitutionProperties(obj : TTurtleComplex; value : TFhirMedicationDispenseSubstitution);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.wasSubstitutedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/MedicationDispense.substitution.wasSubstituted'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationDispense.substitution.type'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.substitution.reason') do
      value.reasonList.Add(parseCodeableConcept(item));
    value.responsibleParty := ParseReference(obj.complex('http://hl7.org/fhir/MedicationDispense.substitution.responsibleParty'));
end;

procedure TFHIRTurtleComposer.ComposeMedicationDispenseSubstitution(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationDispenseSubstitution; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationDispenseSubstitution');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeBoolean(this, 'MedicationDispense.substitution', 'wasSubstituted', value.wasSubstitutedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationDispense.substitution', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationDispense.substitution', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'MedicationDispense.substitution', 'responsibleParty', value.responsiblePartyElement, false, -1);
end;

function TFHIRTurtleParser.ParseMedicationDispense(obj : TTurtleComplex) : TFhirMedicationDispense;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationDispense.create;
  try
    ParseMedicationDispenseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationDispenseProperties(obj : TTurtleComplex; value : TFhirMedicationDispense);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.basedOn') do
      value.basedOnList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.partOf') do
      value.partOfList.Add(parseReference(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/MedicationDispense.status'), CODES_TFhirMedicationDispenseStatusCodesEnum, SYSTEMS_TFhirMedicationDispenseStatusCodesEnum);
    value.notPerformedReason := ParseCodeableReference(obj.complex('http://hl7.org/fhir/MedicationDispense.notPerformedReason'));
    value.statusChangedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicationDispense.statusChanged'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    value.medication := ParseCodeableReference(obj.complex('http://hl7.org/fhir/MedicationDispense.medication'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/MedicationDispense.subject'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/MedicationDispense.encounter'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.supportingInformation') do
      value.supportingInformationList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.performer') do
      value.performerList.Add(parseMedicationDispensePerformer(item));
    value.location := ParseReference(obj.complex('http://hl7.org/fhir/MedicationDispense.location'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.authorizingPrescription') do
      value.authorizingPrescriptionList.Add(parseReference(item));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationDispense.type'));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicationDispense.quantity'));
    value.daysSupply := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicationDispense.daysSupply'));
    value.recordedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicationDispense.recorded'));
    value.whenPreparedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicationDispense.whenPrepared'));
    value.whenHandedOverElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicationDispense.whenHandedOver'));
    value.destination := ParseReference(obj.complex('http://hl7.org/fhir/MedicationDispense.destination'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.receiver') do
      value.receiverList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.note') do
      value.noteList.Add(parseAnnotation(item));
    value.renderedDosageInstructionElement := ParseString(obj.complex('http://hl7.org/fhir/MedicationDispense.renderedDosageInstruction'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.dosageInstruction') do
      value.dosageInstructionList.Add(parseDosage(item));
    value.substitution := ParseMedicationDispenseSubstitution(obj.complex('http://hl7.org/fhir/MedicationDispense.substitution'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.eventHistory') do
      value.eventHistoryList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationDispense(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationDispense; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationDispense');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicationDispense', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'MedicationDispense', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(this, 'MedicationDispense', 'partOf', value.partOfList[i], false, i);
  ComposeEnum(this, 'MedicationDispense', 'status', value.statusElement, CODES_TFhirMedicationDispenseStatusCodesEnum, SYSTEMS_TFhirMedicationDispenseStatusCodesEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(this, 'MedicationDispense', 'notPerformedReason', value.notPerformedReasonElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'MedicationDispense', 'statusChanged', value.statusChangedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationDispense', 'category', value.categoryList[i], false, i);
  ComposeCodeableReference(this, 'MedicationDispense', 'medication', value.medicationElement, false, -1);
  ComposeReference(this, 'MedicationDispense', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'MedicationDispense', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInformationList.Count - 1 do
      ComposeReference(this, 'MedicationDispense', 'supportingInformation', value.supportingInformationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeMedicationDispensePerformer(this, 'MedicationDispense', 'performer', value.performerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'MedicationDispense', 'location', value.locationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorizingPrescriptionList.Count - 1 do
      ComposeReference(this, 'MedicationDispense', 'authorizingPrescription', value.authorizingPrescriptionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationDispense', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'MedicationDispense', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'MedicationDispense', 'daysSupply', value.daysSupplyElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'MedicationDispense', 'recorded', value.recordedElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'MedicationDispense', 'whenPrepared', value.whenPreparedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'MedicationDispense', 'whenHandedOver', value.whenHandedOverElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'MedicationDispense', 'destination', value.destinationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.receiverList.Count - 1 do
      ComposeReference(this, 'MedicationDispense', 'receiver', value.receiverList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'MedicationDispense', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'MedicationDispense', 'renderedDosageInstruction', value.renderedDosageInstructionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dosageInstructionList.Count - 1 do
      ComposeDosage(this, 'MedicationDispense', 'dosageInstruction', value.dosageInstructionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationDispenseSubstitution(this, 'MedicationDispense', 'substitution', value.substitutionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.eventHistoryList.Count - 1 do
      ComposeReference(this, 'MedicationDispense', 'eventHistory', value.eventHistoryList[i], false, i);
end;

{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
function TFHIRTurtleParser.ParseMedicationKnowledgeRelatedMedicationKnowledge(obj : TTurtleComplex) : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge.create;
  try
    ParseMedicationKnowledgeRelatedMedicationKnowledgeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeRelatedMedicationKnowledgeProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeRelatedMedicationKnowledge);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.relatedMedicationKnowledge.type'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.relatedMedicationKnowledge.reference') do
      value.referenceList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeRelatedMedicationKnowledge(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeRelatedMedicationKnowledge; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeRelatedMedicationKnowledge');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'MedicationKnowledge.relatedMedicationKnowledge', 'type', value.type_Element, false, -1);
  for i := 0 to value.referenceList.Count - 1 do
      ComposeReference(this, 'MedicationKnowledge.relatedMedicationKnowledge', 'reference', value.referenceList[i], false, i);
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeMonograph(obj : TTurtleComplex) : TFhirMedicationKnowledgeMonograph;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeMonograph.create;
  try
    ParseMedicationKnowledgeMonographProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeMonographProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeMonograph);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.monograph.type'));
    value.source := ParseReference(obj.complex('http://hl7.org/fhir/MedicationKnowledge.monograph.source'));
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeMonograph(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeMonograph; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeMonograph');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationKnowledge.monograph', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'MedicationKnowledge.monograph', 'source', value.sourceElement, false, -1);
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeCost(obj : TTurtleComplex) : TFhirMedicationKnowledgeCost;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeCost.create;
  try
    ParseMedicationKnowledgeCostProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeCostProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeCost);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.cost.effectiveDate') do
      value.effectiveDateList.Add(parsePeriod(item));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.cost.type'));
    value.sourceElement := ParseString(obj.complex('http://hl7.org/fhir/MedicationKnowledge.cost.source'));
    if obj.has('costMoney', item) then
      value.cost := parseMoney(item);
    if obj.has('costCodeableConcept', item) then
      value.cost := parseCodeableConcept(item);
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeCost(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeCost; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeCost');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.effectiveDateList.Count - 1 do
      ComposePeriod(this, 'MedicationKnowledge.cost', 'effectiveDate', value.effectiveDateList[i], false, i);
  ComposeCodeableConcept(this, 'MedicationKnowledge.cost', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'MedicationKnowledge.cost', 'source', value.sourceElement, false, -1);
  if (value.cost is TFhirMoney) {6} then
    ComposeMoney(this, 'MedicationKnowledge.cost', 'costMoney', TFhirMoney(value.cost), false, -1)
  else if (value.cost is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationKnowledge.cost', 'costCodeableConcept', TFhirCodeableConcept(value.cost), false, -1);
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeMonitoringProgram(obj : TTurtleComplex) : TFhirMedicationKnowledgeMonitoringProgram;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeMonitoringProgram.create;
  try
    ParseMedicationKnowledgeMonitoringProgramProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeMonitoringProgramProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeMonitoringProgram);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.monitoringProgram.type'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/MedicationKnowledge.monitoringProgram.name'));
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeMonitoringProgram(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeMonitoringProgram; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeMonitoringProgram');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationKnowledge.monitoringProgram', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'MedicationKnowledge.monitoringProgram', 'name', value.nameElement, false, -1);
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeIndicationGuideline(obj : TTurtleComplex) : TFhirMedicationKnowledgeIndicationGuideline;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeIndicationGuideline.create;
  try
    ParseMedicationKnowledgeIndicationGuidelineProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeIndicationGuidelineProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeIndicationGuideline);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.indicationGuideline.indication') do
      value.indicationList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.indicationGuideline.dosingGuideline') do
      value.dosingGuidelineList.Add(parseMedicationKnowledgeIndicationGuidelineDosingGuideline(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeIndicationGuideline(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeIndicationGuideline; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeIndicationGuideline');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.indicationList.Count - 1 do
      ComposeCodeableReference(this, 'MedicationKnowledge.indicationGuideline', 'indication', value.indicationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dosingGuidelineList.Count - 1 do
      ComposeMedicationKnowledgeIndicationGuidelineDosingGuideline(this, 'MedicationKnowledge.indicationGuideline', 'dosingGuideline', value.dosingGuidelineList[i], false, i);
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeIndicationGuidelineDosingGuideline(obj : TTurtleComplex) : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline.create;
  try
    ParseMedicationKnowledgeIndicationGuidelineDosingGuidelineProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeIndicationGuidelineDosingGuidelineProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.treatmentIntent := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.indicationGuideline.dosingGuideline.treatmentIntent'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.indicationGuideline.dosingGuideline.dosage') do
      value.dosageList.Add(parseMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage(item));
    value.administrationTreatment := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.indicationGuideline.dosingGuideline.administrationTreatment'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.indicationGuideline.dosingGuideline.patientCharacteristic') do
      value.patientCharacteristicList.Add(parseMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeIndicationGuidelineDosingGuideline(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuideline; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeIndicationGuidelineDosingGuideline');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationKnowledge.indicationGuideline.dosingGuideline', 'treatmentIntent', value.treatmentIntentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dosageList.Count - 1 do
      ComposeMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage(this, 'MedicationKnowledge.indicationGuideline.dosingGuideline', 'dosage', value.dosageList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationKnowledge.indicationGuideline.dosingGuideline', 'administrationTreatment', value.administrationTreatmentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.patientCharacteristicList.Count - 1 do
      ComposeMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic(this, 'MedicationKnowledge.indicationGuideline.dosingGuideline', 'patientCharacteristic', value.patientCharacteristicList[i], false, i);
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage(obj : TTurtleComplex) : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage.create;
  try
    ParseMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeIndicationGuidelineDosingGuidelineDosageProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.indicationGuideline.dosingGuideline.dosage.type'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.indicationGuideline.dosingGuideline.dosage.dosage') do
      value.dosageList.Add(parseDosage(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelineDosage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeIndicationGuidelineDosingGuidelineDosage');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'MedicationKnowledge.indicationGuideline.dosingGuideline.dosage', 'type', value.type_Element, false, -1);
  for i := 0 to value.dosageList.Count - 1 do
      ComposeDosage(this, 'MedicationKnowledge.indicationGuideline.dosingGuideline.dosage', 'dosage', value.dosageList[i], false, i);
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic(obj : TTurtleComplex) : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic.create;
  try
    ParseMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.indicationGuideline.dosingGuideline.patientCharacteristic.type'));
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueRange', item) then
      value.value := parseRange(item);
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'MedicationKnowledge.indicationGuideline.dosingGuideline.patientCharacteristic', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationKnowledge.indicationGuideline.dosingGuideline.patientCharacteristic', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'MedicationKnowledge.indicationGuideline.dosingGuideline.patientCharacteristic', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirRange) {6} then
    ComposeRange(this, 'MedicationKnowledge.indicationGuideline.dosingGuideline.patientCharacteristic', 'valueRange', TFhirRange(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeMedicineClassification(obj : TTurtleComplex) : TFhirMedicationKnowledgeMedicineClassification;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeMedicineClassification.create;
  try
    ParseMedicationKnowledgeMedicineClassificationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeMedicineClassificationProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeMedicineClassification);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.medicineClassification.type'));
    if obj.has('sourceString', item) then
      value.source := parseString(item);
    if obj.has('sourceUri', item) then
      value.source := parseUri(item);
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.medicineClassification.classification') do
      value.classificationList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeMedicineClassification(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeMedicineClassification; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeMedicineClassification');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'MedicationKnowledge.medicineClassification', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.source is TFhirString) {6} then
    ComposeString(this, 'MedicationKnowledge.medicineClassification', 'sourceString', TFhirString(value.source), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.source is TFhirUri) {6} then
    ComposeUri(this, 'MedicationKnowledge.medicineClassification', 'sourceUri', TFhirUri(value.source), false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.classificationList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationKnowledge.medicineClassification', 'classification', value.classificationList[i], false, i);
end;

function TFHIRTurtleParser.ParseMedicationKnowledgePackaging(obj : TTurtleComplex) : TFhirMedicationKnowledgePackaging;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgePackaging.create;
  try
    ParseMedicationKnowledgePackagingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgePackagingProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgePackaging);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.packaging.cost') do
      value.costList.Add(parseMedicationKnowledgeCost(item));
    value.packagedProduct := ParseReference(obj.complex('http://hl7.org/fhir/MedicationKnowledge.packaging.packagedProduct'));
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgePackaging(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgePackaging; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgePackaging');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.costList.Count - 1 do
      ComposeMedicationKnowledgeCost(this, 'MedicationKnowledge.packaging', 'cost', value.costList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'MedicationKnowledge.packaging', 'packagedProduct', value.packagedProductElement, false, -1);
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeStorageGuideline(obj : TTurtleComplex) : TFhirMedicationKnowledgeStorageGuideline;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeStorageGuideline.create;
  try
    ParseMedicationKnowledgeStorageGuidelineProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeStorageGuidelineProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeStorageGuideline);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.referenceElement := ParseUri(obj.complex('http://hl7.org/fhir/MedicationKnowledge.storageGuideline.reference'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.storageGuideline.note') do
      value.noteList.Add(parseAnnotation(item));
    value.stabilityDuration := ParseDuration(obj.complex('http://hl7.org/fhir/MedicationKnowledge.storageGuideline.stabilityDuration'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.storageGuideline.environmentalSetting') do
      value.environmentalSettingList.Add(parseMedicationKnowledgeStorageGuidelineEnvironmentalSetting(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeStorageGuideline(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeStorageGuideline; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeStorageGuideline');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'MedicationKnowledge.storageGuideline', 'reference', value.referenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'MedicationKnowledge.storageGuideline', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(this, 'MedicationKnowledge.storageGuideline', 'stabilityDuration', value.stabilityDurationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.environmentalSettingList.Count - 1 do
      ComposeMedicationKnowledgeStorageGuidelineEnvironmentalSetting(this, 'MedicationKnowledge.storageGuideline', 'environmentalSetting', value.environmentalSettingList[i], false, i);
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeStorageGuidelineEnvironmentalSetting(obj : TTurtleComplex) : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting.create;
  try
    ParseMedicationKnowledgeStorageGuidelineEnvironmentalSettingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeStorageGuidelineEnvironmentalSettingProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.storageGuideline.environmentalSetting.type'));
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueRange', item) then
      value.value := parseRange(item);
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeStorageGuidelineEnvironmentalSetting(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeStorageGuidelineEnvironmentalSetting; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeStorageGuidelineEnvironmentalSetting');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'MedicationKnowledge.storageGuideline.environmentalSetting', 'type', value.type_Element, false, -1);
  if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'MedicationKnowledge.storageGuideline.environmentalSetting', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (value.value is TFhirRange) {6} then
    ComposeRange(this, 'MedicationKnowledge.storageGuideline.environmentalSetting', 'valueRange', TFhirRange(value.value), false, -1)
  else if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationKnowledge.storageGuideline.environmentalSetting', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeRegulatory(obj : TTurtleComplex) : TFhirMedicationKnowledgeRegulatory;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeRegulatory.create;
  try
    ParseMedicationKnowledgeRegulatoryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeRegulatoryProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeRegulatory);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.regulatoryAuthority := ParseReference(obj.complex('http://hl7.org/fhir/MedicationKnowledge.regulatory.regulatoryAuthority'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.regulatory.substitution') do
      value.substitutionList.Add(parseMedicationKnowledgeRegulatorySubstitution(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.regulatory.schedule') do
      value.scheduleList.Add(parseCodeableConcept(item));
    value.maxDispense := ParseMedicationKnowledgeRegulatoryMaxDispense(obj.complex('http://hl7.org/fhir/MedicationKnowledge.regulatory.maxDispense'));
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeRegulatory(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeRegulatory; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeRegulatory');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeReference(this, 'MedicationKnowledge.regulatory', 'regulatoryAuthority', value.regulatoryAuthorityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.substitutionList.Count - 1 do
      ComposeMedicationKnowledgeRegulatorySubstitution(this, 'MedicationKnowledge.regulatory', 'substitution', value.substitutionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.scheduleList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationKnowledge.regulatory', 'schedule', value.scheduleList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationKnowledgeRegulatoryMaxDispense(this, 'MedicationKnowledge.regulatory', 'maxDispense', value.maxDispenseElement, false, -1);
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeRegulatorySubstitution(obj : TTurtleComplex) : TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeRegulatorySubstitution.create;
  try
    ParseMedicationKnowledgeRegulatorySubstitutionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeRegulatorySubstitutionProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeRegulatorySubstitution);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.regulatory.substitution.type'));
    value.allowedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/MedicationKnowledge.regulatory.substitution.allowed'));
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeRegulatorySubstitution(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeRegulatorySubstitution; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeRegulatorySubstitution');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'MedicationKnowledge.regulatory.substitution', 'type', value.type_Element, false, -1);
  ComposeBoolean(this, 'MedicationKnowledge.regulatory.substitution', 'allowed', value.allowedElement, false, -1);
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeRegulatoryMaxDispense(obj : TTurtleComplex) : TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense.create;
  try
    ParseMedicationKnowledgeRegulatoryMaxDispenseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeRegulatoryMaxDispenseProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeRegulatoryMaxDispense);
begin
    ParseBackboneElementProperties(obj, value);
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicationKnowledge.regulatory.maxDispense.quantity'));
    value.period := ParseDuration(obj.complex('http://hl7.org/fhir/MedicationKnowledge.regulatory.maxDispense.period'));
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeRegulatoryMaxDispense(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeRegulatoryMaxDispense; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeRegulatoryMaxDispense');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeQuantity(this, 'MedicationKnowledge.regulatory.maxDispense', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(this, 'MedicationKnowledge.regulatory.maxDispense', 'period', value.periodElement, false, -1);
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeDefinitional(obj : TTurtleComplex) : TFhirMedicationKnowledgeDefinitional;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeDefinitional.create;
  try
    ParseMedicationKnowledgeDefinitionalProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeDefinitionalProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeDefinitional);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.definitional.definition') do
      value.definitionList.Add(parseReference(item));
    value.doseForm := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.definitional.doseForm'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.definitional.intendedRoute') do
      value.intendedRouteList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.definitional.ingredient') do
      value.ingredientList.Add(parseMedicationKnowledgeDefinitionalIngredient(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.definitional.drugCharacteristic') do
      value.drugCharacteristicList.Add(parseMedicationKnowledgeDefinitionalDrugCharacteristic(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeDefinitional(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeDefinitional; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeDefinitional');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.definitionList.Count - 1 do
      ComposeReference(this, 'MedicationKnowledge.definitional', 'definition', value.definitionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationKnowledge.definitional', 'doseForm', value.doseFormElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.intendedRouteList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationKnowledge.definitional', 'intendedRoute', value.intendedRouteList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.ingredientList.Count - 1 do
      ComposeMedicationKnowledgeDefinitionalIngredient(this, 'MedicationKnowledge.definitional', 'ingredient', value.ingredientList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.drugCharacteristicList.Count - 1 do
      ComposeMedicationKnowledgeDefinitionalDrugCharacteristic(this, 'MedicationKnowledge.definitional', 'drugCharacteristic', value.drugCharacteristicList[i], false, i);
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeDefinitionalIngredient(obj : TTurtleComplex) : TFhirMedicationKnowledgeDefinitionalIngredient;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeDefinitionalIngredient.create;
  try
    ParseMedicationKnowledgeDefinitionalIngredientProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeDefinitionalIngredientProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeDefinitionalIngredient);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.item := ParseCodeableReference(obj.complex('http://hl7.org/fhir/MedicationKnowledge.definitional.ingredient.item'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.definitional.ingredient.type'));
    if obj.has('strengthRatio', item) then
      value.strength := parseRatio(item);
    if obj.has('strengthCodeableConcept', item) then
      value.strength := parseCodeableConcept(item);
    if obj.has('strengthQuantity', item) then
      value.strength := parseQuantity(item);
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeDefinitionalIngredient(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeDefinitionalIngredient; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeDefinitionalIngredient');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableReference(this, 'MedicationKnowledge.definitional.ingredient', 'item', value.itemElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationKnowledge.definitional.ingredient', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.strength is TFhirRatio) {6} then
    ComposeRatio(this, 'MedicationKnowledge.definitional.ingredient', 'strengthRatio', TFhirRatio(value.strength), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.strength is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationKnowledge.definitional.ingredient', 'strengthCodeableConcept', TFhirCodeableConcept(value.strength), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.strength is TFhirQuantity) {6} then
    ComposeQuantity(this, 'MedicationKnowledge.definitional.ingredient', 'strengthQuantity', TFhirQuantity(value.strength), false, -1);
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeDefinitionalDrugCharacteristic(obj : TTurtleComplex) : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeDefinitionalDrugCharacteristic.create;
  try
    ParseMedicationKnowledgeDefinitionalDrugCharacteristicProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeDefinitionalDrugCharacteristicProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.definitional.drugCharacteristic.type'));
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueAttachment', item) then
      value.value := parseAttachment(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    if obj.has('valueBase64Binary', item) then
      value.value := parseBase64Binary(item);
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeDefinitionalDrugCharacteristic(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledgeDefinitionalDrugCharacteristic; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeDefinitionalDrugCharacteristic');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationKnowledge.definitional.drugCharacteristic', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationKnowledge.definitional.drugCharacteristic', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'MedicationKnowledge.definitional.drugCharacteristic', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'MedicationKnowledge.definitional.drugCharacteristic', 'valueAttachment', TFhirAttachment(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirString) {6} then
    ComposeString(this, 'MedicationKnowledge.definitional.drugCharacteristic', 'valueString', TFhirString(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'MedicationKnowledge.definitional.drugCharacteristic', 'valueBase64Binary', TFhirBase64Binary(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseMedicationKnowledge(obj : TTurtleComplex) : TFhirMedicationKnowledge;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledge.create;
  try
    ParseMedicationKnowledgeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeProperties(obj : TTurtleComplex; value : TFhirMedicationKnowledge);
var
  item : TTurtleComplex;
begin
    ParseMetadataResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.code'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/MedicationKnowledge.status'), CODES_TFhirMedicationKnowledgeStatusCodesEnum, SYSTEMS_TFhirMedicationKnowledgeStatusCodesEnum);
    value.author := ParseContactDetail(obj.complex('http://hl7.org/fhir/MedicationKnowledge.author'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.intendedJurisdiction') do
      value.intendedJurisdictionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.name') do
      value.nameList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.relatedMedicationKnowledge') do
      value.relatedMedicationKnowledgeList.Add(parseMedicationKnowledgeRelatedMedicationKnowledge(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.associatedMedication') do
      value.associatedMedicationList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.productType') do
      value.productTypeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.monograph') do
      value.monographList.Add(parseMedicationKnowledgeMonograph(item));
    value.preparationInstructionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/MedicationKnowledge.preparationInstruction'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.cost') do
      value.costList.Add(parseMedicationKnowledgeCost(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.monitoringProgram') do
      value.monitoringProgramList.Add(parseMedicationKnowledgeMonitoringProgram(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.indicationGuideline') do
      value.indicationGuidelineList.Add(parseMedicationKnowledgeIndicationGuideline(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.medicineClassification') do
      value.medicineClassificationList.Add(parseMedicationKnowledgeMedicineClassification(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.packaging') do
      value.packagingList.Add(parseMedicationKnowledgePackaging(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.clinicalUseIssue') do
      value.clinicalUseIssueList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.storageGuideline') do
      value.storageGuidelineList.Add(parseMedicationKnowledgeStorageGuideline(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.regulatory') do
      value.regulatoryList.Add(parseMedicationKnowledgeRegulatory(item));
    value.definitional := ParseMedicationKnowledgeDefinitional(obj.complex('http://hl7.org/fhir/MedicationKnowledge.definitional'));
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledge(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationKnowledge; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledge');
  end;
  composeMetadataResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicationKnowledge', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationKnowledge', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'MedicationKnowledge', 'status', value.statusElement, CODES_TFhirMedicationKnowledgeStatusCodesEnum, SYSTEMS_TFhirMedicationKnowledgeStatusCodesEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeContactDetail(this, 'MedicationKnowledge', 'author', value.authorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.intendedJurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationKnowledge', 'intendedJurisdiction', value.intendedJurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.nameList.Count - 1 do
      ComposeString(this, 'MedicationKnowledge', 'name', value.nameList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedMedicationKnowledgeList.Count - 1 do
      ComposeMedicationKnowledgeRelatedMedicationKnowledge(this, 'MedicationKnowledge', 'relatedMedicationKnowledge', value.relatedMedicationKnowledgeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.associatedMedicationList.Count - 1 do
      ComposeReference(this, 'MedicationKnowledge', 'associatedMedication', value.associatedMedicationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.productTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationKnowledge', 'productType', value.productTypeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.monographList.Count - 1 do
      ComposeMedicationKnowledgeMonograph(this, 'MedicationKnowledge', 'monograph', value.monographList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'MedicationKnowledge', 'preparationInstruction', value.preparationInstructionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.costList.Count - 1 do
      ComposeMedicationKnowledgeCost(this, 'MedicationKnowledge', 'cost', value.costList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.monitoringProgramList.Count - 1 do
      ComposeMedicationKnowledgeMonitoringProgram(this, 'MedicationKnowledge', 'monitoringProgram', value.monitoringProgramList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.indicationGuidelineList.Count - 1 do
      ComposeMedicationKnowledgeIndicationGuideline(this, 'MedicationKnowledge', 'indicationGuideline', value.indicationGuidelineList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.medicineClassificationList.Count - 1 do
      ComposeMedicationKnowledgeMedicineClassification(this, 'MedicationKnowledge', 'medicineClassification', value.medicineClassificationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.packagingList.Count - 1 do
      ComposeMedicationKnowledgePackaging(this, 'MedicationKnowledge', 'packaging', value.packagingList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.clinicalUseIssueList.Count - 1 do
      ComposeReference(this, 'MedicationKnowledge', 'clinicalUseIssue', value.clinicalUseIssueList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.storageGuidelineList.Count - 1 do
      ComposeMedicationKnowledgeStorageGuideline(this, 'MedicationKnowledge', 'storageGuideline', value.storageGuidelineList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.regulatoryList.Count - 1 do
      ComposeMedicationKnowledgeRegulatory(this, 'MedicationKnowledge', 'regulatory', value.regulatoryList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationKnowledgeDefinitional(this, 'MedicationKnowledge', 'definitional', value.definitionalElement, false, -1);
end;

{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICATIONREQUEST}
function TFHIRTurtleParser.ParseMedicationRequestDose(obj : TTurtleComplex) : TFhirMedicationRequestDose;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationRequestDose.create;
  try
    ParseMedicationRequestDoseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationRequestDoseProperties(obj : TTurtleComplex; value : TFhirMedicationRequestDose);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.renderedDosageInstructionElement := ParseString(obj.complex('http://hl7.org/fhir/MedicationRequest.dose.renderedDosageInstruction'));
    value.effectiveDosePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/MedicationRequest.dose.effectiveDosePeriod'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.dose.dosageInstruction') do
      value.dosageInstructionList.Add(parseDosage(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationRequestDose(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationRequestDose; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationRequestDose');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'MedicationRequest.dose', 'renderedDosageInstruction', value.renderedDosageInstructionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'MedicationRequest.dose', 'effectiveDosePeriod', value.effectiveDosePeriodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dosageInstructionList.Count - 1 do
      ComposeDosage(this, 'MedicationRequest.dose', 'dosageInstruction', value.dosageInstructionList[i], false, i);
end;

function TFHIRTurtleParser.ParseMedicationRequestDispenseRequest(obj : TTurtleComplex) : TFhirMedicationRequestDispenseRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationRequestDispenseRequest.create;
  try
    ParseMedicationRequestDispenseRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationRequestDispenseRequestProperties(obj : TTurtleComplex; value : TFhirMedicationRequestDispenseRequest);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.initialFill := ParseMedicationRequestDispenseRequestInitialFill(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest.initialFill'));
    value.dispenseInterval := ParseDuration(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest.dispenseInterval'));
    value.validityPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest.validityPeriod'));
    value.numberOfRepeatsAllowedElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest.numberOfRepeatsAllowed'));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest.quantity'));
    value.expectedSupplyDuration := ParseDuration(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest.expectedSupplyDuration'));
    value.dispenser := ParseReference(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest.dispenser'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.dispenseRequest.dispenserInstruction') do
      value.dispenserInstructionList.Add(parseAnnotation(item));
    value.doseAdministrationAid := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest.doseAdministrationAid'));
end;

procedure TFHIRTurtleComposer.ComposeMedicationRequestDispenseRequest(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationRequestDispenseRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationRequestDispenseRequest');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationRequestDispenseRequestInitialFill(this, 'MedicationRequest.dispenseRequest', 'initialFill', value.initialFillElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(this, 'MedicationRequest.dispenseRequest', 'dispenseInterval', value.dispenseIntervalElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'MedicationRequest.dispenseRequest', 'validityPeriod', value.validityPeriodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(this, 'MedicationRequest.dispenseRequest', 'numberOfRepeatsAllowed', value.numberOfRepeatsAllowedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'MedicationRequest.dispenseRequest', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(this, 'MedicationRequest.dispenseRequest', 'expectedSupplyDuration', value.expectedSupplyDurationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'MedicationRequest.dispenseRequest', 'dispenser', value.dispenserElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dispenserInstructionList.Count - 1 do
      ComposeAnnotation(this, 'MedicationRequest.dispenseRequest', 'dispenserInstruction', value.dispenserInstructionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationRequest.dispenseRequest', 'doseAdministrationAid', value.doseAdministrationAidElement, false, -1);
end;

function TFHIRTurtleParser.ParseMedicationRequestDispenseRequestInitialFill(obj : TTurtleComplex) : TFhirMedicationRequestDispenseRequestInitialFill;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationRequestDispenseRequestInitialFill.create;
  try
    ParseMedicationRequestDispenseRequestInitialFillProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationRequestDispenseRequestInitialFillProperties(obj : TTurtleComplex; value : TFhirMedicationRequestDispenseRequestInitialFill);
begin
    ParseBackboneElementProperties(obj, value);
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest.initialFill.quantity'));
    value.duration := ParseDuration(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest.initialFill.duration'));
end;

procedure TFHIRTurtleComposer.ComposeMedicationRequestDispenseRequestInitialFill(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationRequestDispenseRequestInitialFill; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationRequestDispenseRequestInitialFill');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'MedicationRequest.dispenseRequest.initialFill', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(this, 'MedicationRequest.dispenseRequest.initialFill', 'duration', value.durationElement, false, -1);
end;

function TFHIRTurtleParser.ParseMedicationRequestSubstitution(obj : TTurtleComplex) : TFhirMedicationRequestSubstitution;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationRequestSubstitution.create;
  try
    ParseMedicationRequestSubstitutionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationRequestSubstitutionProperties(obj : TTurtleComplex; value : TFhirMedicationRequestSubstitution);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('allowedCodeableConcept', item) then
      value.allowed := parseCodeableConcept(item);
    if obj.has('allowedBoolean', item) then
      value.allowed := parseBoolean(item);
    value.reason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationRequest.substitution.reason'));
end;

procedure TFHIRTurtleComposer.ComposeMedicationRequestSubstitution(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationRequestSubstitution; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationRequestSubstitution');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (value.allowed is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationRequest.substitution', 'allowedCodeableConcept', TFhirCodeableConcept(value.allowed), false, -1)
  else if (value.allowed is TFhirBoolean) {6} then
    ComposeBoolean(this, 'MedicationRequest.substitution', 'allowedBoolean', TFhirBoolean(value.allowed), false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationRequest.substitution', 'reason', value.reasonElement, false, -1);
end;

function TFHIRTurtleParser.ParseMedicationRequest(obj : TTurtleComplex) : TFhirMedicationRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationRequest.create;
  try
    ParseMedicationRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationRequestProperties(obj : TTurtleComplex; value : TFhirMedicationRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.basedOn') do
      value.basedOnList.Add(parseReference(item));
    value.priorPrescription := ParseReference(obj.complex('http://hl7.org/fhir/MedicationRequest.priorPrescription'));
    value.groupIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/MedicationRequest.groupIdentifier'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/MedicationRequest.status'), CODES_TFhirMedicationrequestStatusEnum, SYSTEMS_TFhirMedicationrequestStatusEnum);
    value.statusReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationRequest.statusReason'));
    value.statusChangedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicationRequest.statusChanged'));
    value.intentElement := ParseEnum(obj.complex('http://hl7.org/fhir/MedicationRequest.intent'), CODES_TFhirMedicationRequestIntentEnum, SYSTEMS_TFhirMedicationRequestIntentEnum);
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    value.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/MedicationRequest.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    value.doNotPerformElement := ParseBoolean(obj.complex('http://hl7.org/fhir/MedicationRequest.doNotPerform'));
    value.medication := ParseCodeableReference(obj.complex('http://hl7.org/fhir/MedicationRequest.medication'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/MedicationRequest.subject'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.informationSource') do
      value.informationSourceList.Add(parseReference(item));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/MedicationRequest.encounter'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.supportingInformation') do
      value.supportingInformationList.Add(parseReference(item));
    value.authoredOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicationRequest.authoredOn'));
    value.requester := ParseReference(obj.complex('http://hl7.org/fhir/MedicationRequest.requester'));
    value.reportedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/MedicationRequest.reported'));
    value.performerType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationRequest.performerType'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.performer') do
      value.performerList.Add(parseReference(item));
    value.device := ParseCodeableReference(obj.complex('http://hl7.org/fhir/MedicationRequest.device'));
    value.recorder := ParseReference(obj.complex('http://hl7.org/fhir/MedicationRequest.recorder'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.reason') do
      value.reasonList.Add(parseCodeableReference(item));
    value.courseOfTherapyType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationRequest.courseOfTherapyType'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.insurance') do
      value.insuranceList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.note') do
      value.noteList.Add(parseAnnotation(item));
    value.dose := ParseMedicationRequestDose(obj.complex('http://hl7.org/fhir/MedicationRequest.dose'));
    value.dispenseRequest := ParseMedicationRequestDispenseRequest(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest'));
    value.substitution := ParseMedicationRequestSubstitution(obj.complex('http://hl7.org/fhir/MedicationRequest.substitution'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.eventHistory') do
      value.eventHistoryList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationRequest(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationRequest');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicationRequest', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'MedicationRequest', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'MedicationRequest', 'priorPrescription', value.priorPrescriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'MedicationRequest', 'groupIdentifier', value.groupIdentifierElement, false, -1);
  ComposeEnum(this, 'MedicationRequest', 'status', value.statusElement, CODES_TFhirMedicationrequestStatusEnum, SYSTEMS_TFhirMedicationrequestStatusEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationRequest', 'statusReason', value.statusReasonElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'MedicationRequest', 'statusChanged', value.statusChangedElement, false, -1);
  ComposeEnum(this, 'MedicationRequest', 'intent', value.intentElement, CODES_TFhirMedicationRequestIntentEnum, SYSTEMS_TFhirMedicationRequestIntentEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationRequest', 'category', value.categoryList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'MedicationRequest', 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'MedicationRequest', 'doNotPerform', value.doNotPerformElement, false, -1);
  ComposeCodeableReference(this, 'MedicationRequest', 'medication', value.medicationElement, false, -1);
  ComposeReference(this, 'MedicationRequest', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.informationSourceList.Count - 1 do
      ComposeReference(this, 'MedicationRequest', 'informationSource', value.informationSourceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'MedicationRequest', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInformationList.Count - 1 do
      ComposeReference(this, 'MedicationRequest', 'supportingInformation', value.supportingInformationList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'MedicationRequest', 'authoredOn', value.authoredOnElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'MedicationRequest', 'requester', value.requesterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'MedicationRequest', 'reported', value.reportedElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicationRequest', 'performerType', value.performerTypeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeReference(this, 'MedicationRequest', 'performer', value.performerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(this, 'MedicationRequest', 'device', value.deviceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'MedicationRequest', 'recorder', value.recorderElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(this, 'MedicationRequest', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationRequest', 'courseOfTherapyType', value.courseOfTherapyTypeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.insuranceList.Count - 1 do
      ComposeReference(this, 'MedicationRequest', 'insurance', value.insuranceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'MedicationRequest', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationRequestDose(this, 'MedicationRequest', 'dose', value.doseElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationRequestDispenseRequest(this, 'MedicationRequest', 'dispenseRequest', value.dispenseRequestElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationRequestSubstitution(this, 'MedicationRequest', 'substitution', value.substitutionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.eventHistoryList.Count - 1 do
      ComposeReference(this, 'MedicationRequest', 'eventHistory', value.eventHistoryList[i], false, i);
end;

{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONUSAGE}
function TFHIRTurtleParser.ParseMedicationUsageAdherence(obj : TTurtleComplex) : TFhirMedicationUsageAdherence;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationUsageAdherence.create;
  try
    ParseMedicationUsageAdherenceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationUsageAdherenceProperties(obj : TTurtleComplex; value : TFhirMedicationUsageAdherence);
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationUsage.adherence.code'));
    value.reason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationUsage.adherence.reason'));
end;

procedure TFHIRTurtleComposer.ComposeMedicationUsageAdherence(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationUsageAdherence; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationUsageAdherence');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'MedicationUsage.adherence', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationUsage.adherence', 'reason', value.reasonElement, false, -1);
end;

function TFHIRTurtleParser.ParseMedicationUsage(obj : TTurtleComplex) : TFhirMedicationUsage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationUsage.create;
  try
    ParseMedicationUsageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationUsageProperties(obj : TTurtleComplex; value : TFhirMedicationUsage);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/MedicationUsage.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationUsage.partOf') do
      value.partOfList.Add(parseReference(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/MedicationUsage.status'), CODES_TFhirMedicationUsageStatusCodesEnum, SYSTEMS_TFhirMedicationUsageStatusCodesEnum);
    for item in obj.complexes('http://hl7.org/fhir/MedicationUsage.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    value.medication := ParseCodeableReference(obj.complex('http://hl7.org/fhir/MedicationUsage.medication'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/MedicationUsage.subject'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/MedicationUsage.encounter'));
    if obj.has('effectivePeriod', item) then
      value.effective := parsePeriod(item);
    if obj.has('effectiveDateTime', item) then
      value.effective := parseDateTime(item);
    value.dateAssertedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicationUsage.dateAsserted'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationUsage.informationSource') do
      value.informationSourceList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationUsage.derivedFrom') do
      value.derivedFromList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationUsage.reason') do
      value.reasonList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationUsage.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationUsage.relatedClinicalInformation') do
      value.relatedClinicalInformationList.Add(parseReference(item));
    value.renderedDosageInstructionElement := ParseString(obj.complex('http://hl7.org/fhir/MedicationUsage.renderedDosageInstruction'));
    for item in obj.complexes('http://hl7.org/fhir/MedicationUsage.dosage') do
      value.dosageList.Add(parseDosage(item));
    value.adherence := ParseMedicationUsageAdherence(obj.complex('http://hl7.org/fhir/MedicationUsage.adherence'));
end;

procedure TFHIRTurtleComposer.ComposeMedicationUsage(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicationUsage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationUsage');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicationUsage', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(this, 'MedicationUsage', 'partOf', value.partOfList[i], false, i);
  ComposeEnum(this, 'MedicationUsage', 'status', value.statusElement, CODES_TFhirMedicationUsageStatusCodesEnum, SYSTEMS_TFhirMedicationUsageStatusCodesEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationUsage', 'category', value.categoryList[i], false, i);
  ComposeCodeableReference(this, 'MedicationUsage', 'medication', value.medicationElement, false, -1);
  ComposeReference(this, 'MedicationUsage', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'MedicationUsage', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.effective is TFhirPeriod) {6} then
    ComposePeriod(this, 'MedicationUsage', 'effectivePeriod', TFhirPeriod(value.effective), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.effective is TFhirDateTime) {6} then
    ComposeDateTime(this, 'MedicationUsage', 'effectiveDateTime', TFhirDateTime(value.effective), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'MedicationUsage', 'dateAsserted', value.dateAssertedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.informationSourceList.Count - 1 do
      ComposeReference(this, 'MedicationUsage', 'informationSource', value.informationSourceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.derivedFromList.Count - 1 do
      ComposeReference(this, 'MedicationUsage', 'derivedFrom', value.derivedFromList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(this, 'MedicationUsage', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'MedicationUsage', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedClinicalInformationList.Count - 1 do
      ComposeReference(this, 'MedicationUsage', 'relatedClinicalInformation', value.relatedClinicalInformationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'MedicationUsage', 'renderedDosageInstruction', value.renderedDosageInstructionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dosageList.Count - 1 do
      ComposeDosage(this, 'MedicationUsage', 'dosage', value.dosageList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMedicationUsageAdherence(this, 'MedicationUsage', 'adherence', value.adherenceElement, false, -1);
end;

{$ENDIF FHIR_MEDICATIONUSAGE}
{$IFDEF FHIR_MEDICINALPRODUCTDEFINITION}
function TFHIRTurtleParser.ParseMedicinalProductDefinitionContact(obj : TTurtleComplex) : TFhirMedicinalProductDefinitionContact;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductDefinitionContact.create;
  try
    ParseMedicinalProductDefinitionContactProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductDefinitionContactProperties(obj : TTurtleComplex; value : TFhirMedicinalProductDefinitionContact);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.contact.type'));
    value.contact := ParseReference(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.contact.contact'));
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductDefinitionContact(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicinalProductDefinitionContact; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductDefinitionContact');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicinalProductDefinition.contact', 'type', value.type_Element, false, -1);
  ComposeReference(this, 'MedicinalProductDefinition.contact', 'contact', value.contactElement, false, -1);
end;

function TFHIRTurtleParser.ParseMedicinalProductDefinitionName(obj : TTurtleComplex) : TFhirMedicinalProductDefinitionName;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductDefinitionName.create;
  try
    ParseMedicinalProductDefinitionNameProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductDefinitionNameProperties(obj : TTurtleComplex; value : TFhirMedicinalProductDefinitionName);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.productNameElement := ParseString(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.name.productName'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.name.type'));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductDefinition.name.part') do
      value.partList.Add(parseMedicinalProductDefinitionNamePart(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductDefinition.name.usage') do
      value.usageList.Add(parseMedicinalProductDefinitionNameUsage(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductDefinitionName(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicinalProductDefinitionName; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductDefinitionName');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'MedicinalProductDefinition.name', 'productName', value.productNameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicinalProductDefinition.name', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partList.Count - 1 do
      ComposeMedicinalProductDefinitionNamePart(this, 'MedicinalProductDefinition.name', 'part', value.partList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.usageList.Count - 1 do
      ComposeMedicinalProductDefinitionNameUsage(this, 'MedicinalProductDefinition.name', 'usage', value.usageList[i], false, i);
end;

function TFHIRTurtleParser.ParseMedicinalProductDefinitionNamePart(obj : TTurtleComplex) : TFhirMedicinalProductDefinitionNamePart;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductDefinitionNamePart.create;
  try
    ParseMedicinalProductDefinitionNamePartProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductDefinitionNamePartProperties(obj : TTurtleComplex; value : TFhirMedicinalProductDefinitionNamePart);
begin
    ParseBackboneElementProperties(obj, value);
    value.partElement := ParseString(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.name.part.part'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.name.part.type'));
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductDefinitionNamePart(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicinalProductDefinitionNamePart; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductDefinitionNamePart');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'MedicinalProductDefinition.name.part', 'part', value.partElement, false, -1);
  ComposeCodeableConcept(this, 'MedicinalProductDefinition.name.part', 'type', value.type_Element, false, -1);
end;

function TFHIRTurtleParser.ParseMedicinalProductDefinitionNameUsage(obj : TTurtleComplex) : TFhirMedicinalProductDefinitionNameUsage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductDefinitionNameUsage.create;
  try
    ParseMedicinalProductDefinitionNameUsageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductDefinitionNameUsageProperties(obj : TTurtleComplex; value : TFhirMedicinalProductDefinitionNameUsage);
begin
    ParseBackboneElementProperties(obj, value);
    value.country := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.name.usage.country'));
    value.jurisdiction := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.name.usage.jurisdiction'));
    value.language := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.name.usage.language'));
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductDefinitionNameUsage(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicinalProductDefinitionNameUsage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductDefinitionNameUsage');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'MedicinalProductDefinition.name.usage', 'country', value.countryElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicinalProductDefinition.name.usage', 'jurisdiction', value.jurisdictionElement, false, -1);
  ComposeCodeableConcept(this, 'MedicinalProductDefinition.name.usage', 'language', value.languageElement, false, -1);
end;

function TFHIRTurtleParser.ParseMedicinalProductDefinitionCrossReference(obj : TTurtleComplex) : TFhirMedicinalProductDefinitionCrossReference;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductDefinitionCrossReference.create;
  try
    ParseMedicinalProductDefinitionCrossReferenceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductDefinitionCrossReferenceProperties(obj : TTurtleComplex; value : TFhirMedicinalProductDefinitionCrossReference);
begin
    ParseBackboneElementProperties(obj, value);
    value.product := ParseCodeableReference(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.crossReference.product'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.crossReference.type'));
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductDefinitionCrossReference(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicinalProductDefinitionCrossReference; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductDefinitionCrossReference');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableReference(this, 'MedicinalProductDefinition.crossReference', 'product', value.productElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicinalProductDefinition.crossReference', 'type', value.type_Element, false, -1);
end;

function TFHIRTurtleParser.ParseMedicinalProductDefinitionOperation(obj : TTurtleComplex) : TFhirMedicinalProductDefinitionOperation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductDefinitionOperation.create;
  try
    ParseMedicinalProductDefinitionOperationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductDefinitionOperationProperties(obj : TTurtleComplex; value : TFhirMedicinalProductDefinitionOperation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableReference(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.operation.type'));
    value.effectiveDate := ParsePeriod(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.operation.effectiveDate'));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductDefinition.operation.organization') do
      value.organizationList.Add(parseReference(item));
    value.confidentialityIndicator := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.operation.confidentialityIndicator'));
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductDefinitionOperation(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicinalProductDefinitionOperation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductDefinitionOperation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(this, 'MedicinalProductDefinition.operation', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'MedicinalProductDefinition.operation', 'effectiveDate', value.effectiveDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.organizationList.Count - 1 do
      ComposeReference(this, 'MedicinalProductDefinition.operation', 'organization', value.organizationList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicinalProductDefinition.operation', 'confidentialityIndicator', value.confidentialityIndicatorElement, false, -1);
end;

function TFHIRTurtleParser.ParseMedicinalProductDefinitionCharacteristic(obj : TTurtleComplex) : TFhirMedicinalProductDefinitionCharacteristic;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductDefinitionCharacteristic.create;
  try
    ParseMedicinalProductDefinitionCharacteristicProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductDefinitionCharacteristicProperties(obj : TTurtleComplex; value : TFhirMedicinalProductDefinitionCharacteristic);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.characteristic.type'));
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueAttachment', item) then
      value.value := parseAttachment(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    if obj.has('valueInteger', item) then
      value.value := parseInteger(item);
    if obj.has('valueDate', item) then
      value.value := parseDate(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductDefinitionCharacteristic(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicinalProductDefinitionCharacteristic; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductDefinitionCharacteristic');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'MedicinalProductDefinition.characteristic', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicinalProductDefinition.characteristic', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'MedicinalProductDefinition.characteristic', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'MedicinalProductDefinition.characteristic', 'valueAttachment', TFhirAttachment(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirString) {6} then
    ComposeString(this, 'MedicinalProductDefinition.characteristic', 'valueString', TFhirString(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirInteger) {6} then
    ComposeInteger(this, 'MedicinalProductDefinition.characteristic', 'valueInteger', TFhirInteger(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirDate) {6} then
    ComposeDate(this, 'MedicinalProductDefinition.characteristic', 'valueDate', TFhirDate(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'MedicinalProductDefinition.characteristic', 'valueBoolean', TFhirBoolean(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseMedicinalProductDefinition(obj : TTurtleComplex) : TFhirMedicinalProductDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductDefinition.create;
  try
    ParseMedicinalProductDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductDefinitionProperties(obj : TTurtleComplex; value : TFhirMedicinalProductDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductDefinition.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.type'));
    value.domain := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.domain'));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.version'));
    value.status := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.status'));
    value.statusDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.statusDate'));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.description'));
    value.combinedPharmaceuticalDoseForm := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.combinedPharmaceuticalDoseForm'));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductDefinition.route') do
      value.routeList.Add(parseCodeableConcept(item));
    value.indicationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.indication'));
    value.legalStatusOfSupply := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.legalStatusOfSupply'));
    value.additionalMonitoringIndicator := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.additionalMonitoringIndicator'));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductDefinition.specialMeasures') do
      value.specialMeasuresList.Add(parseCodeableConcept(item));
    value.pediatricUseIndicator := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductDefinition.pediatricUseIndicator'));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductDefinition.classification') do
      value.classificationList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductDefinition.marketingStatus') do
      value.marketingStatusList.Add(parseMarketingStatus(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductDefinition.packagedMedicinalProduct') do
      value.packagedMedicinalProductList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductDefinition.comprisedOf') do
      value.comprisedOfList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductDefinition.ingredient') do
      value.ingredientList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductDefinition.impurity') do
      value.impurityList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductDefinition.attachedDocument') do
      value.attachedDocumentList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductDefinition.masterFile') do
      value.masterFileList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductDefinition.contact') do
      value.contactList.Add(parseMedicinalProductDefinitionContact(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductDefinition.clinicalTrial') do
      value.clinicalTrialList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductDefinition.code') do
      value.codeList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductDefinition.name') do
      value.nameList.Add(parseMedicinalProductDefinitionName(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductDefinition.crossReference') do
      value.crossReferenceList.Add(parseMedicinalProductDefinitionCrossReference(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductDefinition.operation') do
      value.operationList.Add(parseMedicinalProductDefinitionOperation(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductDefinition.characteristic') do
      value.characteristicList.Add(parseMedicinalProductDefinitionCharacteristic(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirMedicinalProductDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductDefinition');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicinalProductDefinition', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicinalProductDefinition', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicinalProductDefinition', 'domain', value.domainElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MedicinalProductDefinition', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicinalProductDefinition', 'status', value.statusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'MedicinalProductDefinition', 'statusDate', value.statusDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'MedicinalProductDefinition', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicinalProductDefinition', 'combinedPharmaceuticalDoseForm', value.combinedPharmaceuticalDoseFormElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.routeList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicinalProductDefinition', 'route', value.routeList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'MedicinalProductDefinition', 'indication', value.indicationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicinalProductDefinition', 'legalStatusOfSupply', value.legalStatusOfSupplyElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicinalProductDefinition', 'additionalMonitoringIndicator', value.additionalMonitoringIndicatorElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.specialMeasuresList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicinalProductDefinition', 'specialMeasures', value.specialMeasuresList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicinalProductDefinition', 'pediatricUseIndicator', value.pediatricUseIndicatorElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.classificationList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicinalProductDefinition', 'classification', value.classificationList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.marketingStatusList.Count - 1 do
      ComposeMarketingStatus(this, 'MedicinalProductDefinition', 'marketingStatus', value.marketingStatusList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.packagedMedicinalProductList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicinalProductDefinition', 'packagedMedicinalProduct', value.packagedMedicinalProductList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.comprisedOfList.Count - 1 do
      ComposeReference(this, 'MedicinalProductDefinition', 'comprisedOf', value.comprisedOfList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.ingredientList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicinalProductDefinition', 'ingredient', value.ingredientList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.impurityList.Count - 1 do
      ComposeCodeableReference(this, 'MedicinalProductDefinition', 'impurity', value.impurityList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.attachedDocumentList.Count - 1 do
      ComposeReference(this, 'MedicinalProductDefinition', 'attachedDocument', value.attachedDocumentList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.masterFileList.Count - 1 do
      ComposeReference(this, 'MedicinalProductDefinition', 'masterFile', value.masterFileList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeMedicinalProductDefinitionContact(this, 'MedicinalProductDefinition', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.clinicalTrialList.Count - 1 do
      ComposeReference(this, 'MedicinalProductDefinition', 'clinicalTrial', value.clinicalTrialList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCoding(this, 'MedicinalProductDefinition', 'code', value.codeList[i], false, i);
  for i := 0 to value.nameList.Count - 1 do
      ComposeMedicinalProductDefinitionName(this, 'MedicinalProductDefinition', 'name', value.nameList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.crossReferenceList.Count - 1 do
      ComposeMedicinalProductDefinitionCrossReference(this, 'MedicinalProductDefinition', 'crossReference', value.crossReferenceList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.operationList.Count - 1 do
      ComposeMedicinalProductDefinitionOperation(this, 'MedicinalProductDefinition', 'operation', value.operationList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.characteristicList.Count - 1 do
      ComposeMedicinalProductDefinitionCharacteristic(this, 'MedicinalProductDefinition', 'characteristic', value.characteristicList[i], false, i);
end;

{$ENDIF FHIR_MEDICINALPRODUCTDEFINITION}
{$IFDEF FHIR_MESSAGEDEFINITION}
function TFHIRTurtleParser.ParseMessageDefinitionFocus(obj : TTurtleComplex) : TFhirMessageDefinitionFocus;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMessageDefinitionFocus.create;
  try
    ParseMessageDefinitionFocusProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMessageDefinitionFocusProperties(obj : TTurtleComplex; value : TFhirMessageDefinitionFocus);
begin
    ParseBackboneElementProperties(obj, value);
    value.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/MessageDefinition.focus.code'), CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    value.profileElement := ParseCanonical(obj.complex('http://hl7.org/fhir/MessageDefinition.focus.profile'));
    value.minElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/MessageDefinition.focus.min'));
    value.maxElement := ParseString(obj.complex('http://hl7.org/fhir/MessageDefinition.focus.max'));
end;

procedure TFHIRTurtleComposer.ComposeMessageDefinitionFocus(parent :  TTurtleComplex; parentType, name : String; value : TFhirMessageDefinitionFocus; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MessageDefinitionFocus');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'MessageDefinition.focus', 'code', value.codeElement, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'MessageDefinition.focus', 'profile', value.profileElement, false, -1);
  ComposeUnsignedInt(this, 'MessageDefinition.focus', 'min', value.minElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'MessageDefinition.focus', 'max', value.maxElement, false, -1);
end;

function TFHIRTurtleParser.ParseMessageDefinitionAllowedResponse(obj : TTurtleComplex) : TFhirMessageDefinitionAllowedResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMessageDefinitionAllowedResponse.create;
  try
    ParseMessageDefinitionAllowedResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMessageDefinitionAllowedResponseProperties(obj : TTurtleComplex; value : TFhirMessageDefinitionAllowedResponse);
begin
    ParseBackboneElementProperties(obj, value);
    value.messageElement := ParseCanonical(obj.complex('http://hl7.org/fhir/MessageDefinition.allowedResponse.message'));
    value.situationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/MessageDefinition.allowedResponse.situation'));
end;

procedure TFHIRTurtleComposer.ComposeMessageDefinitionAllowedResponse(parent :  TTurtleComplex; parentType, name : String; value : TFhirMessageDefinitionAllowedResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MessageDefinitionAllowedResponse');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCanonical(this, 'MessageDefinition.allowedResponse', 'message', value.messageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'MessageDefinition.allowedResponse', 'situation', value.situationElement, false, -1);
end;

function TFHIRTurtleParser.ParseMessageDefinition(obj : TTurtleComplex) : TFhirMessageDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMessageDefinition.create;
  try
    ParseMessageDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMessageDefinitionProperties(obj : TTurtleComplex; value : TFhirMessageDefinition);
var
  item : TTurtleComplex;
begin
    ParseCanonicalResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/MessageDefinition.url'));
    for item in obj.complexes('http://hl7.org/fhir/MessageDefinition.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/MessageDefinition.version'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/MessageDefinition.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/MessageDefinition.title'));
    for item in obj.complexes('http://hl7.org/fhir/MessageDefinition.replaces') do
      value.replacesList.Add(parseCanonical(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/MessageDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/MessageDefinition.experimental'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MessageDefinition.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/MessageDefinition.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/MessageDefinition.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/MessageDefinition.description'));
    for item in obj.complexes('http://hl7.org/fhir/MessageDefinition.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/MessageDefinition.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/MessageDefinition.purpose'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/MessageDefinition.copyright'));
    value.baseElement := ParseCanonical(obj.complex('http://hl7.org/fhir/MessageDefinition.base'));
    for item in obj.complexes('http://hl7.org/fhir/MessageDefinition.parent') do
      value.parentList.Add(parseCanonical(item));
    if obj.has('eventCoding', item) then
      value.event := parseCoding(item);
    if obj.has('eventUri', item) then
      value.event := parseUri(item);
    value.categoryElement := ParseEnum(obj.complex('http://hl7.org/fhir/MessageDefinition.category'), CODES_TFhirMessageSignificanceCategoryEnum, SYSTEMS_TFhirMessageSignificanceCategoryEnum);
    for item in obj.complexes('http://hl7.org/fhir/MessageDefinition.focus') do
      value.focusList.Add(parseMessageDefinitionFocus(item));
    value.responseRequiredElement := ParseEnum(obj.complex('http://hl7.org/fhir/MessageDefinition.responseRequired'), CODES_TFhirMessageheaderResponseRequestEnum, SYSTEMS_TFhirMessageheaderResponseRequestEnum);
    for item in obj.complexes('http://hl7.org/fhir/MessageDefinition.allowedResponse') do
      value.allowedResponseList.Add(parseMessageDefinitionAllowedResponse(item));
    value.graphElement := ParseCanonical(obj.complex('http://hl7.org/fhir/MessageDefinition.graph'));
end;

procedure TFHIRTurtleComposer.ComposeMessageDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirMessageDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MessageDefinition');
  end;
  composeCanonicalResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'MessageDefinition', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MessageDefinition', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MessageDefinition', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MessageDefinition', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MessageDefinition', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.replacesList.Count - 1 do
      ComposeCanonical(this, 'MessageDefinition', 'replaces', value.replacesList[i], false, i);
  ComposeEnum(this, 'MessageDefinition', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'MessageDefinition', 'experimental', value.experimentalElement, false, -1);
  ComposeDateTime(this, 'MessageDefinition', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MessageDefinition', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'MessageDefinition', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'MessageDefinition', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'MessageDefinition', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'MessageDefinition', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'MessageDefinition', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'MessageDefinition', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(this, 'MessageDefinition', 'base', value.baseElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.parentList.Count - 1 do
      ComposeCanonical(this, 'MessageDefinition', 'parent', value.parentList[i], false, i);
  if (value.event is TFhirCoding) {6} then
    ComposeCoding(this, 'MessageDefinition', 'eventCoding', TFhirCoding(value.event), false, -1)
  else if (value.event is TFhirUri) {6} then
    ComposeUri(this, 'MessageDefinition', 'eventUri', TFhirUri(value.event), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'MessageDefinition', 'category', value.categoryElement, CODES_TFhirMessageSignificanceCategoryEnum, SYSTEMS_TFhirMessageSignificanceCategoryEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.focusList.Count - 1 do
      ComposeMessageDefinitionFocus(this, 'MessageDefinition', 'focus', value.focusList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'MessageDefinition', 'responseRequired', value.responseRequiredElement, CODES_TFhirMessageheaderResponseRequestEnum, SYSTEMS_TFhirMessageheaderResponseRequestEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.allowedResponseList.Count - 1 do
      ComposeMessageDefinitionAllowedResponse(this, 'MessageDefinition', 'allowedResponse', value.allowedResponseList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'MessageDefinition', 'graph', value.graphElement, false, -1);
end;

{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
function TFHIRTurtleParser.ParseMessageHeaderDestination(obj : TTurtleComplex) : TFhirMessageHeaderDestination;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMessageHeaderDestination.create;
  try
    ParseMessageHeaderDestinationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMessageHeaderDestinationProperties(obj : TTurtleComplex; value : TFhirMessageHeaderDestination);
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/MessageHeader.destination.name'));
    value.target := ParseReference(obj.complex('http://hl7.org/fhir/MessageHeader.destination.target'));
    value.endpointElement := ParseUrl(obj.complex('http://hl7.org/fhir/MessageHeader.destination.endpoint'));
    value.receiver := ParseReference(obj.complex('http://hl7.org/fhir/MessageHeader.destination.receiver'));
end;

procedure TFHIRTurtleComposer.ComposeMessageHeaderDestination(parent :  TTurtleComplex; parentType, name : String; value : TFhirMessageHeaderDestination; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MessageHeaderDestination');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MessageHeader.destination', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'MessageHeader.destination', 'target', value.targetElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrl(this, 'MessageHeader.destination', 'endpoint', value.endpointElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'MessageHeader.destination', 'receiver', value.receiverElement, false, -1);
end;

function TFHIRTurtleParser.ParseMessageHeaderSource(obj : TTurtleComplex) : TFhirMessageHeaderSource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMessageHeaderSource.create;
  try
    ParseMessageHeaderSourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMessageHeaderSourceProperties(obj : TTurtleComplex; value : TFhirMessageHeaderSource);
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/MessageHeader.source.name'));
    value.softwareElement := ParseString(obj.complex('http://hl7.org/fhir/MessageHeader.source.software'));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/MessageHeader.source.version'));
    value.contact := ParseContactPoint(obj.complex('http://hl7.org/fhir/MessageHeader.source.contact'));
    value.endpointElement := ParseUrl(obj.complex('http://hl7.org/fhir/MessageHeader.source.endpoint'));
end;

procedure TFHIRTurtleComposer.ComposeMessageHeaderSource(parent :  TTurtleComplex; parentType, name : String; value : TFhirMessageHeaderSource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MessageHeaderSource');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MessageHeader.source', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MessageHeader.source', 'software', value.softwareElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MessageHeader.source', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeContactPoint(this, 'MessageHeader.source', 'contact', value.contactElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrl(this, 'MessageHeader.source', 'endpoint', value.endpointElement, false, -1);
end;

function TFHIRTurtleParser.ParseMessageHeaderResponse(obj : TTurtleComplex) : TFhirMessageHeaderResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMessageHeaderResponse.create;
  try
    ParseMessageHeaderResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMessageHeaderResponseProperties(obj : TTurtleComplex; value : TFhirMessageHeaderResponse);
begin
    ParseBackboneElementProperties(obj, value);
    value.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/MessageHeader.response.identifier'));
    value.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/MessageHeader.response.code'), CODES_TFhirResponseTypeEnum, SYSTEMS_TFhirResponseTypeEnum);
    value.details := ParseReference(obj.complex('http://hl7.org/fhir/MessageHeader.response.details'));
end;

procedure TFHIRTurtleComposer.ComposeMessageHeaderResponse(parent :  TTurtleComplex; parentType, name : String; value : TFhirMessageHeaderResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MessageHeaderResponse');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeIdentifier(this, 'MessageHeader.response', 'identifier', value.identifierElement, false, -1);
  ComposeEnum(this, 'MessageHeader.response', 'code', value.codeElement, CODES_TFhirResponseTypeEnum, SYSTEMS_TFhirResponseTypeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'MessageHeader.response', 'details', value.detailsElement, false, -1);
end;

function TFHIRTurtleParser.ParseMessageHeader(obj : TTurtleComplex) : TFhirMessageHeader;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMessageHeader.create;
  try
    ParseMessageHeaderProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMessageHeaderProperties(obj : TTurtleComplex; value : TFhirMessageHeader);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    if obj.has('eventCoding', item) then
      value.event := parseCoding(item);
    if obj.has('eventCanonical', item) then
      value.event := parseCanonical(item);
    for item in obj.complexes('http://hl7.org/fhir/MessageHeader.destination') do
      value.destinationList.Add(parseMessageHeaderDestination(item));
    value.sender := ParseReference(obj.complex('http://hl7.org/fhir/MessageHeader.sender'));
    value.enterer := ParseReference(obj.complex('http://hl7.org/fhir/MessageHeader.enterer'));
    value.author := ParseReference(obj.complex('http://hl7.org/fhir/MessageHeader.author'));
    value.source := ParseMessageHeaderSource(obj.complex('http://hl7.org/fhir/MessageHeader.source'));
    value.responsible := ParseReference(obj.complex('http://hl7.org/fhir/MessageHeader.responsible'));
    value.reason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MessageHeader.reason'));
    value.response := ParseMessageHeaderResponse(obj.complex('http://hl7.org/fhir/MessageHeader.response'));
    for item in obj.complexes('http://hl7.org/fhir/MessageHeader.focus') do
      value.focusList.Add(parseReference(item));
    value.definitionElement := ParseCanonical(obj.complex('http://hl7.org/fhir/MessageHeader.definition'));
end;

procedure TFHIRTurtleComposer.ComposeMessageHeader(parent :  TTurtleComplex; parentType, name : String; value : TFhirMessageHeader; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MessageHeader');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (value.event is TFhirCoding) {6} then
    ComposeCoding(this, 'MessageHeader', 'eventCoding', TFhirCoding(value.event), false, -1)
  else if (value.event is TFhirCanonical) {6} then
    ComposeCanonical(this, 'MessageHeader', 'eventCanonical', TFhirCanonical(value.event), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.destinationList.Count - 1 do
      ComposeMessageHeaderDestination(this, 'MessageHeader', 'destination', value.destinationList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'MessageHeader', 'sender', value.senderElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'MessageHeader', 'enterer', value.entererElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'MessageHeader', 'author', value.authorElement, false, -1);
  ComposeMessageHeaderSource(this, 'MessageHeader', 'source', value.sourceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'MessageHeader', 'responsible', value.responsibleElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MessageHeader', 'reason', value.reasonElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMessageHeaderResponse(this, 'MessageHeader', 'response', value.responseElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.focusList.Count - 1 do
      ComposeReference(this, 'MessageHeader', 'focus', value.focusList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(this, 'MessageHeader', 'definition', value.definitionElement, false, -1);
end;

{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_MOLECULARSEQUENCE}
function TFHIRTurtleParser.ParseMolecularSequenceRelative(obj : TTurtleComplex) : TFhirMolecularSequenceRelative;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMolecularSequenceRelative.create;
  try
    ParseMolecularSequenceRelativeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMolecularSequenceRelativeProperties(obj : TTurtleComplex; value : TFhirMolecularSequenceRelative);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.coordinateSystem := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MolecularSequence.relative.coordinateSystem'));
    value.ordinalPositionElement := ParseInteger(obj.complex('http://hl7.org/fhir/MolecularSequence.relative.ordinalPosition'));
    value.sequenceRange := ParseRange(obj.complex('http://hl7.org/fhir/MolecularSequence.relative.sequenceRange'));
    value.startingSequence := ParseMolecularSequenceRelativeStartingSequence(obj.complex('http://hl7.org/fhir/MolecularSequence.relative.startingSequence'));
    for item in obj.complexes('http://hl7.org/fhir/MolecularSequence.relative.edit') do
      value.editList.Add(parseMolecularSequenceRelativeEdit(item));
end;

procedure TFHIRTurtleComposer.ComposeMolecularSequenceRelative(parent :  TTurtleComplex; parentType, name : String; value : TFhirMolecularSequenceRelative; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MolecularSequenceRelative');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'MolecularSequence.relative', 'coordinateSystem', value.coordinateSystemElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'MolecularSequence.relative', 'ordinalPosition', value.ordinalPositionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(this, 'MolecularSequence.relative', 'sequenceRange', value.sequenceRangeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMolecularSequenceRelativeStartingSequence(this, 'MolecularSequence.relative', 'startingSequence', value.startingSequenceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.editList.Count - 1 do
      ComposeMolecularSequenceRelativeEdit(this, 'MolecularSequence.relative', 'edit', value.editList[i], false, i);
end;

function TFHIRTurtleParser.ParseMolecularSequenceRelativeStartingSequence(obj : TTurtleComplex) : TFhirMolecularSequenceRelativeStartingSequence;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMolecularSequenceRelativeStartingSequence.create;
  try
    ParseMolecularSequenceRelativeStartingSequenceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMolecularSequenceRelativeStartingSequenceProperties(obj : TTurtleComplex; value : TFhirMolecularSequenceRelativeStartingSequence);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.genomeAssembly := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MolecularSequence.relative.startingSequence.genomeAssembly'));
    value.chromosome := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MolecularSequence.relative.startingSequence.chromosome'));
    if obj.has('sequenceCodeableConcept', item) then
      value.sequence := parseCodeableConcept(item);
    if obj.has('sequenceReference', item) {a3} then
      value.sequence := ParseReference(item);
    if obj.has('sequenceString', item) then
      value.sequence := parseString(item);
    value.windowStartElement := ParseInteger(obj.complex('http://hl7.org/fhir/MolecularSequence.relative.startingSequence.windowStart'));
    value.windowEndElement := ParseInteger(obj.complex('http://hl7.org/fhir/MolecularSequence.relative.startingSequence.windowEnd'));
    value.orientationElement := ParseEnum(obj.complex('http://hl7.org/fhir/MolecularSequence.relative.startingSequence.orientation'), CODES_TFhirOrientationTypeEnum, SYSTEMS_TFhirOrientationTypeEnum);
    value.strandElement := ParseEnum(obj.complex('http://hl7.org/fhir/MolecularSequence.relative.startingSequence.strand'), CODES_TFhirStrandTypeEnum, SYSTEMS_TFhirStrandTypeEnum);
end;

procedure TFHIRTurtleComposer.ComposeMolecularSequenceRelativeStartingSequence(parent :  TTurtleComplex; parentType, name : String; value : TFhirMolecularSequenceRelativeStartingSequence; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MolecularSequenceRelativeStartingSequence');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MolecularSequence.relative.startingSequence', 'genomeAssembly', value.genomeAssemblyElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MolecularSequence.relative.startingSequence', 'chromosome', value.chromosomeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.sequence is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MolecularSequence.relative.startingSequence', 'sequenceCodeableConcept', TFhirCodeableConcept(value.sequence), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.sequence is TFhirReference) {2} then
    ComposeReference(this, 'MolecularSequence.relative.startingSequence', 'sequenceReference', TFhirReference(value.sequence), false,-1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.sequence is TFhirString) {6} then
    ComposeString(this, 'MolecularSequence.relative.startingSequence', 'sequenceString', TFhirString(value.sequence), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'MolecularSequence.relative.startingSequence', 'windowStart', value.windowStartElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'MolecularSequence.relative.startingSequence', 'windowEnd', value.windowEndElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'MolecularSequence.relative.startingSequence', 'orientation', value.orientationElement, CODES_TFhirOrientationTypeEnum, SYSTEMS_TFhirOrientationTypeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'MolecularSequence.relative.startingSequence', 'strand', value.strandElement, CODES_TFhirStrandTypeEnum, SYSTEMS_TFhirStrandTypeEnum, false, -1);
end;

function TFHIRTurtleParser.ParseMolecularSequenceRelativeEdit(obj : TTurtleComplex) : TFhirMolecularSequenceRelativeEdit;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMolecularSequenceRelativeEdit.create;
  try
    ParseMolecularSequenceRelativeEditProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMolecularSequenceRelativeEditProperties(obj : TTurtleComplex; value : TFhirMolecularSequenceRelativeEdit);
begin
    ParseBackboneElementProperties(obj, value);
    value.startElement := ParseInteger(obj.complex('http://hl7.org/fhir/MolecularSequence.relative.edit.start'));
    value.end_Element := ParseInteger(obj.complex('http://hl7.org/fhir/MolecularSequence.relative.edit.end'));
    value.replacementSequenceElement := ParseString(obj.complex('http://hl7.org/fhir/MolecularSequence.relative.edit.replacementSequence'));
    value.replacedSequenceElement := ParseString(obj.complex('http://hl7.org/fhir/MolecularSequence.relative.edit.replacedSequence'));
end;

procedure TFHIRTurtleComposer.ComposeMolecularSequenceRelativeEdit(parent :  TTurtleComplex; parentType, name : String; value : TFhirMolecularSequenceRelativeEdit; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MolecularSequenceRelativeEdit');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'MolecularSequence.relative.edit', 'start', value.startElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'MolecularSequence.relative.edit', 'end', value.end_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MolecularSequence.relative.edit', 'replacementSequence', value.replacementSequenceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MolecularSequence.relative.edit', 'replacedSequence', value.replacedSequenceElement, false, -1);
end;

function TFHIRTurtleParser.ParseMolecularSequence(obj : TTurtleComplex) : TFhirMolecularSequence;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMolecularSequence.create;
  try
    ParseMolecularSequenceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMolecularSequenceProperties(obj : TTurtleComplex; value : TFhirMolecularSequence);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/MolecularSequence.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/MolecularSequence.type'), CODES_TFhirSequenceTypeEnum, SYSTEMS_TFhirSequenceTypeEnum);
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/MolecularSequence.subject'));
    value.specimen := ParseReference(obj.complex('http://hl7.org/fhir/MolecularSequence.specimen'));
    value.device := ParseReference(obj.complex('http://hl7.org/fhir/MolecularSequence.device'));
    value.performer := ParseReference(obj.complex('http://hl7.org/fhir/MolecularSequence.performer'));
    value.literalElement := ParseString(obj.complex('http://hl7.org/fhir/MolecularSequence.literal'));
    for item in obj.complexes('http://hl7.org/fhir/MolecularSequence.formatted') do
      value.formattedList.Add(parseAttachment(item));
    for item in obj.complexes('http://hl7.org/fhir/MolecularSequence.relative') do
      value.relativeList.Add(parseMolecularSequenceRelative(item));
end;

procedure TFHIRTurtleComposer.ComposeMolecularSequence(parent :  TTurtleComplex; parentType, name : String; value : TFhirMolecularSequence; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MolecularSequence');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MolecularSequence', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'MolecularSequence', 'type', value.type_Element, CODES_TFhirSequenceTypeEnum, SYSTEMS_TFhirSequenceTypeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'MolecularSequence', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'MolecularSequence', 'specimen', value.specimenElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'MolecularSequence', 'device', value.deviceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'MolecularSequence', 'performer', value.performerElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MolecularSequence', 'literal', value.literalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.formattedList.Count - 1 do
      ComposeAttachment(this, 'MolecularSequence', 'formatted', value.formattedList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.relativeList.Count - 1 do
      ComposeMolecularSequenceRelative(this, 'MolecularSequence', 'relative', value.relativeList[i], false, i);
end;

{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NAMINGSYSTEM}
function TFHIRTurtleParser.ParseNamingSystemUniqueId(obj : TTurtleComplex) : TFhirNamingSystemUniqueId;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNamingSystemUniqueId.create;
  try
    ParseNamingSystemUniqueIdProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNamingSystemUniqueIdProperties(obj : TTurtleComplex; value : TFhirNamingSystemUniqueId);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/NamingSystem.uniqueId.type'), CODES_TFhirNamingSystemIdentifierTypeEnum, SYSTEMS_TFhirNamingSystemIdentifierTypeEnum);
    value.valueElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.uniqueId.value'));
    value.preferredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/NamingSystem.uniqueId.preferred'));
    value.commentElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.uniqueId.comment'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/NamingSystem.uniqueId.period'));
    value.authoritativeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/NamingSystem.uniqueId.authoritative'));
end;

procedure TFHIRTurtleComposer.ComposeNamingSystemUniqueId(parent :  TTurtleComplex; parentType, name : String; value : TFhirNamingSystemUniqueId; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NamingSystemUniqueId');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'NamingSystem.uniqueId', 'type', value.type_Element, CODES_TFhirNamingSystemIdentifierTypeEnum, SYSTEMS_TFhirNamingSystemIdentifierTypeEnum, false, -1);
  ComposeString(this, 'NamingSystem.uniqueId', 'value', value.valueElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'NamingSystem.uniqueId', 'preferred', value.preferredElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NamingSystem.uniqueId', 'comment', value.commentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'NamingSystem.uniqueId', 'period', value.periodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'NamingSystem.uniqueId', 'authoritative', value.authoritativeElement, false, -1);
end;

function TFHIRTurtleParser.ParseNamingSystem(obj : TTurtleComplex) : TFhirNamingSystem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNamingSystem.create;
  try
    ParseNamingSystemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNamingSystemProperties(obj : TTurtleComplex; value : TFhirNamingSystem);
var
  item : TTurtleComplex;
begin
    ParseMetadataResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/NamingSystem.url'));
    for item in obj.complexes('http://hl7.org/fhir/NamingSystem.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.version'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.title'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/NamingSystem.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/NamingSystem.kind'), CODES_TFhirNamingSystemTypeEnum, SYSTEMS_TFhirNamingSystemTypeEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/NamingSystem.experimental'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/NamingSystem.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/NamingSystem.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.responsibleElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.responsible'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NamingSystem.type'));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/NamingSystem.description'));
    for item in obj.complexes('http://hl7.org/fhir/NamingSystem.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/NamingSystem.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/NamingSystem.purpose'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/NamingSystem.copyright'));
    value.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/NamingSystem.approvalDate'));
    value.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/NamingSystem.lastReviewDate'));
    value.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/NamingSystem.effectivePeriod'));
    for item in obj.complexes('http://hl7.org/fhir/NamingSystem.topic') do
      value.topicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/NamingSystem.author') do
      value.authorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/NamingSystem.editor') do
      value.editorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/NamingSystem.reviewer') do
      value.reviewerList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/NamingSystem.endorser') do
      value.endorserList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/NamingSystem.relatedArtifact') do
      value.relatedArtifactList.Add(parseRelatedArtifact(item));
    value.usageElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.usage'));
    for item in obj.complexes('http://hl7.org/fhir/NamingSystem.uniqueId') do
      value.uniqueIdList.Add(parseNamingSystemUniqueId(item));
end;

procedure TFHIRTurtleComposer.ComposeNamingSystem(parent :  TTurtleComplex; parentType, name : String; value : TFhirNamingSystem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NamingSystem');
  end;
  composeMetadataResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'NamingSystem', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'NamingSystem', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'NamingSystem', 'version', value.versionElement, false, -1);
  ComposeString(this, 'NamingSystem', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'NamingSystem', 'title', value.titleElement, false, -1);
  ComposeEnum(this, 'NamingSystem', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  ComposeEnum(this, 'NamingSystem', 'kind', value.kindElement, CODES_TFhirNamingSystemTypeEnum, SYSTEMS_TFhirNamingSystemTypeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'NamingSystem', 'experimental', value.experimentalElement, false, -1);
  ComposeDateTime(this, 'NamingSystem', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'NamingSystem', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'NamingSystem', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NamingSystem', 'responsible', value.responsibleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NamingSystem', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'NamingSystem', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'NamingSystem', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'NamingSystem', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'NamingSystem', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'NamingSystem', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'NamingSystem', 'approvalDate', value.approvalDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'NamingSystem', 'lastReviewDate', value.lastReviewDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'NamingSystem', 'effectivePeriod', value.effectivePeriodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.topicList.Count - 1 do
      ComposeCodeableConcept(this, 'NamingSystem', 'topic', value.topicList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(this, 'NamingSystem', 'author', value.authorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(this, 'NamingSystem', 'editor', value.editorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(this, 'NamingSystem', 'reviewer', value.reviewerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(this, 'NamingSystem', 'endorser', value.endorserList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'NamingSystem', 'relatedArtifact', value.relatedArtifactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NamingSystem', 'usage', value.usageElement, false, -1);
  for i := 0 to value.uniqueIdList.Count - 1 do
      ComposeNamingSystemUniqueId(this, 'NamingSystem', 'uniqueId', value.uniqueIdList[i], false, i);
end;

{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONINTAKE}
function TFHIRTurtleParser.ParseNutritionIntakeConsumedItem(obj : TTurtleComplex) : TFhirNutritionIntakeConsumedItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionIntakeConsumedItem.create;
  try
    ParseNutritionIntakeConsumedItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionIntakeConsumedItemProperties(obj : TTurtleComplex; value : TFhirNutritionIntakeConsumedItem);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionIntake.consumedItem.type'));
    value.nutritionProduct := ParseCodeableReference(obj.complex('http://hl7.org/fhir/NutritionIntake.consumedItem.nutritionProduct'));
    value.schedule := ParseTiming(obj.complex('http://hl7.org/fhir/NutritionIntake.consumedItem.schedule'));
    value.amount := ParseQuantity(obj.complex('http://hl7.org/fhir/NutritionIntake.consumedItem.amount'));
    value.rate := ParseQuantity(obj.complex('http://hl7.org/fhir/NutritionIntake.consumedItem.rate'));
    value.notConsumedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/NutritionIntake.consumedItem.notConsumed'));
    value.notConsumedReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionIntake.consumedItem.notConsumedReason'));
end;

procedure TFHIRTurtleComposer.ComposeNutritionIntakeConsumedItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionIntakeConsumedItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionIntakeConsumedItem');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'NutritionIntake.consumedItem', 'type', value.type_Element, false, -1);
  ComposeCodeableReference(this, 'NutritionIntake.consumedItem', 'nutritionProduct', value.nutritionProductElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeTiming(this, 'NutritionIntake.consumedItem', 'schedule', value.scheduleElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'NutritionIntake.consumedItem', 'amount', value.amountElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'NutritionIntake.consumedItem', 'rate', value.rateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'NutritionIntake.consumedItem', 'notConsumed', value.notConsumedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionIntake.consumedItem', 'notConsumedReason', value.notConsumedReasonElement, false, -1);
end;

function TFHIRTurtleParser.ParseNutritionIntakeIngredientLabel(obj : TTurtleComplex) : TFhirNutritionIntakeIngredientLabel;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionIntakeIngredientLabel.create;
  try
    ParseNutritionIntakeIngredientLabelProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionIntakeIngredientLabelProperties(obj : TTurtleComplex; value : TFhirNutritionIntakeIngredientLabel);
begin
    ParseBackboneElementProperties(obj, value);
    value.nutrient := ParseCodeableReference(obj.complex('http://hl7.org/fhir/NutritionIntake.ingredientLabel.nutrient'));
    value.amount := ParseQuantity(obj.complex('http://hl7.org/fhir/NutritionIntake.ingredientLabel.amount'));
end;

procedure TFHIRTurtleComposer.ComposeNutritionIntakeIngredientLabel(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionIntakeIngredientLabel; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionIntakeIngredientLabel');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableReference(this, 'NutritionIntake.ingredientLabel', 'nutrient', value.nutrientElement, false, -1);
  ComposeQuantity(this, 'NutritionIntake.ingredientLabel', 'amount', value.amountElement, false, -1);
end;

function TFHIRTurtleParser.ParseNutritionIntakePerformer(obj : TTurtleComplex) : TFhirNutritionIntakePerformer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionIntakePerformer.create;
  try
    ParseNutritionIntakePerformerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionIntakePerformerProperties(obj : TTurtleComplex; value : TFhirNutritionIntakePerformer);
begin
    ParseBackboneElementProperties(obj, value);
    value.function_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionIntake.performer.function'));
    value.actor := ParseReference(obj.complex('http://hl7.org/fhir/NutritionIntake.performer.actor'));
end;

procedure TFHIRTurtleComposer.ComposeNutritionIntakePerformer(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionIntakePerformer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionIntakePerformer');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionIntake.performer', 'function', value.function_Element, false, -1);
  ComposeReference(this, 'NutritionIntake.performer', 'actor', value.actorElement, false, -1);
end;

function TFHIRTurtleParser.ParseNutritionIntake(obj : TTurtleComplex) : TFhirNutritionIntake;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionIntake.create;
  try
    ParseNutritionIntakeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionIntakeProperties(obj : TTurtleComplex; value : TFhirNutritionIntake);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/NutritionIntake.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionIntake.instantiatesCanonical') do
      value.instantiatesCanonicalList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionIntake.instantiatesUri') do
      value.instantiatesUriList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionIntake.basedOn') do
      value.basedOnList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionIntake.partOf') do
      value.partOfList.Add(parseReference(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/NutritionIntake.status'), CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/NutritionIntake.statusReason') do
      value.statusReasonList.Add(parseCodeableConcept(item));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionIntake.code'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/NutritionIntake.subject'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/NutritionIntake.encounter'));
    if obj.has('occurrencePeriod', item) then
      value.occurrence := parsePeriod(item);
    if obj.has('occurrenceDateTime', item) then
      value.occurrence := parseDateTime(item);
    value.recordedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/NutritionIntake.recorded'));
    if obj.has('reportedReference', item) {a3} then
      value.reported := ParseReference(item);
    if obj.has('reportedBoolean', item) then
      value.reported := parseBoolean(item);
    for item in obj.complexes('http://hl7.org/fhir/NutritionIntake.consumedItem') do
      value.consumedItemList.Add(parseNutritionIntakeConsumedItem(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionIntake.ingredientLabel') do
      value.ingredientLabelList.Add(parseNutritionIntakeIngredientLabel(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionIntake.performer') do
      value.performerList.Add(parseNutritionIntakePerformer(item));
    value.location := ParseReference(obj.complex('http://hl7.org/fhir/NutritionIntake.location'));
    for item in obj.complexes('http://hl7.org/fhir/NutritionIntake.derivedFrom') do
      value.derivedFromList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionIntake.reason') do
      value.reasonList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionIntake.note') do
      value.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeNutritionIntake(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionIntake; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionIntake');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'NutritionIntake', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(this, 'NutritionIntake', 'instantiatesCanonical', value.instantiatesCanonicalList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.instantiatesUriList.Count - 1 do
      ComposeUri(this, 'NutritionIntake', 'instantiatesUri', value.instantiatesUriList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'NutritionIntake', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(this, 'NutritionIntake', 'partOf', value.partOfList[i], false, i);
  ComposeEnum(this, 'NutritionIntake', 'status', value.statusElement, CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.statusReasonList.Count - 1 do
      ComposeCodeableConcept(this, 'NutritionIntake', 'statusReason', value.statusReasonList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'NutritionIntake', 'code', value.codeElement, false, -1);
  ComposeReference(this, 'NutritionIntake', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'NutritionIntake', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'NutritionIntake', 'occurrencePeriod', TFhirPeriod(value.occurrence), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'NutritionIntake', 'occurrenceDateTime', TFhirDateTime(value.occurrence), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'NutritionIntake', 'recorded', value.recordedElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.reported is TFhirReference) {2} then
    ComposeReference(this, 'NutritionIntake', 'reportedReference', TFhirReference(value.reported), false,-1)
  else if (SummaryOption in [soFull, soData]) and (value.reported is TFhirBoolean) {6} then
    ComposeBoolean(this, 'NutritionIntake', 'reportedBoolean', TFhirBoolean(value.reported), false, -1);
  for i := 0 to value.consumedItemList.Count - 1 do
      ComposeNutritionIntakeConsumedItem(this, 'NutritionIntake', 'consumedItem', value.consumedItemList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.ingredientLabelList.Count - 1 do
      ComposeNutritionIntakeIngredientLabel(this, 'NutritionIntake', 'ingredientLabel', value.ingredientLabelList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeNutritionIntakePerformer(this, 'NutritionIntake', 'performer', value.performerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'NutritionIntake', 'location', value.locationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.derivedFromList.Count - 1 do
      ComposeReference(this, 'NutritionIntake', 'derivedFrom', value.derivedFromList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(this, 'NutritionIntake', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'NutritionIntake', 'note', value.noteList[i], false, i);
end;

{$ENDIF FHIR_NUTRITIONINTAKE}
{$IFDEF FHIR_NUTRITIONORDER}
function TFHIRTurtleParser.ParseNutritionOrderOralDiet(obj : TTurtleComplex) : TFhirNutritionOrderOralDiet;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderOralDiet.create;
  try
    ParseNutritionOrderOralDietProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderOralDietProperties(obj : TTurtleComplex; value : TFhirNutritionOrderOralDiet);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.oralDiet.type') do
      value.type_List.Add(parseCodeableConcept(item));
    value.schedule := ParseNutritionOrderOralDietSchedule(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet.schedule'));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.oralDiet.nutrient') do
      value.nutrientList.Add(parseNutritionOrderOralDietNutrient(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.oralDiet.texture') do
      value.textureList.Add(parseNutritionOrderOralDietTexture(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.oralDiet.fluidConsistencyType') do
      value.fluidConsistencyTypeList.Add(parseCodeableConcept(item));
    value.instructionElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet.instruction'));
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderOralDiet(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionOrderOralDiet; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderOralDiet');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'NutritionOrder.oralDiet', 'type', value.type_List[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeNutritionOrderOralDietSchedule(this, 'NutritionOrder.oralDiet', 'schedule', value.scheduleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.nutrientList.Count - 1 do
      ComposeNutritionOrderOralDietNutrient(this, 'NutritionOrder.oralDiet', 'nutrient', value.nutrientList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.textureList.Count - 1 do
      ComposeNutritionOrderOralDietTexture(this, 'NutritionOrder.oralDiet', 'texture', value.textureList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.fluidConsistencyTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'NutritionOrder.oralDiet', 'fluidConsistencyType', value.fluidConsistencyTypeList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'NutritionOrder.oralDiet', 'instruction', value.instructionElement, false, -1);
end;

function TFHIRTurtleParser.ParseNutritionOrderOralDietSchedule(obj : TTurtleComplex) : TFhirNutritionOrderOralDietSchedule;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderOralDietSchedule.create;
  try
    ParseNutritionOrderOralDietScheduleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderOralDietScheduleProperties(obj : TTurtleComplex; value : TFhirNutritionOrderOralDietSchedule);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.oralDiet.schedule.timing') do
      value.timingList.Add(parseTiming(item));
    value.asNeededElement := ParseBoolean(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet.schedule.asNeeded'));
    value.asNeededFor := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet.schedule.asNeededFor'));
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderOralDietSchedule(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionOrderOralDietSchedule; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderOralDietSchedule');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.timingList.Count - 1 do
      ComposeTiming(this, 'NutritionOrder.oralDiet.schedule', 'timing', value.timingList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'NutritionOrder.oralDiet.schedule', 'asNeeded', value.asNeededElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.oralDiet.schedule', 'asNeededFor', value.asNeededForElement, false, -1);
end;

function TFHIRTurtleParser.ParseNutritionOrderOralDietNutrient(obj : TTurtleComplex) : TFhirNutritionOrderOralDietNutrient;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderOralDietNutrient.create;
  try
    ParseNutritionOrderOralDietNutrientProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderOralDietNutrientProperties(obj : TTurtleComplex; value : TFhirNutritionOrderOralDietNutrient);
begin
    ParseBackboneElementProperties(obj, value);
    value.modifier := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet.nutrient.modifier'));
    value.amount := ParseQuantity(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet.nutrient.amount'));
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderOralDietNutrient(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionOrderOralDietNutrient; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderOralDietNutrient');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.oralDiet.nutrient', 'modifier', value.modifierElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrder.oralDiet.nutrient', 'amount', value.amountElement, false, -1);
end;

function TFHIRTurtleParser.ParseNutritionOrderOralDietTexture(obj : TTurtleComplex) : TFhirNutritionOrderOralDietTexture;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderOralDietTexture.create;
  try
    ParseNutritionOrderOralDietTextureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderOralDietTextureProperties(obj : TTurtleComplex; value : TFhirNutritionOrderOralDietTexture);
begin
    ParseBackboneElementProperties(obj, value);
    value.modifier := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet.texture.modifier'));
    value.foodType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet.texture.foodType'));
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderOralDietTexture(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionOrderOralDietTexture; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderOralDietTexture');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.oralDiet.texture', 'modifier', value.modifierElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.oralDiet.texture', 'foodType', value.foodTypeElement, false, -1);
end;

function TFHIRTurtleParser.ParseNutritionOrderSupplement(obj : TTurtleComplex) : TFhirNutritionOrderSupplement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderSupplement.create;
  try
    ParseNutritionOrderSupplementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderSupplementProperties(obj : TTurtleComplex; value : TFhirNutritionOrderSupplement);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableReference(obj.complex('http://hl7.org/fhir/NutritionOrder.supplement.type'));
    value.productNameElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionOrder.supplement.productName'));
    value.schedule := ParseNutritionOrderSupplementSchedule(obj.complex('http://hl7.org/fhir/NutritionOrder.supplement.schedule'));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/NutritionOrder.supplement.quantity'));
    value.instructionElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionOrder.supplement.instruction'));
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderSupplement(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionOrderSupplement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderSupplement');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(this, 'NutritionOrder.supplement', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NutritionOrder.supplement', 'productName', value.productNameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeNutritionOrderSupplementSchedule(this, 'NutritionOrder.supplement', 'schedule', value.scheduleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrder.supplement', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'NutritionOrder.supplement', 'instruction', value.instructionElement, false, -1);
end;

function TFHIRTurtleParser.ParseNutritionOrderSupplementSchedule(obj : TTurtleComplex) : TFhirNutritionOrderSupplementSchedule;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderSupplementSchedule.create;
  try
    ParseNutritionOrderSupplementScheduleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderSupplementScheduleProperties(obj : TTurtleComplex; value : TFhirNutritionOrderSupplementSchedule);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.supplement.schedule.timing') do
      value.timingList.Add(parseTiming(item));
    value.asNeededElement := ParseBoolean(obj.complex('http://hl7.org/fhir/NutritionOrder.supplement.schedule.asNeeded'));
    value.asNeededFor := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.supplement.schedule.asNeededFor'));
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderSupplementSchedule(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionOrderSupplementSchedule; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderSupplementSchedule');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.timingList.Count - 1 do
      ComposeTiming(this, 'NutritionOrder.supplement.schedule', 'timing', value.timingList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'NutritionOrder.supplement.schedule', 'asNeeded', value.asNeededElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.supplement.schedule', 'asNeededFor', value.asNeededForElement, false, -1);
end;

function TFHIRTurtleParser.ParseNutritionOrderEnteralFormula(obj : TTurtleComplex) : TFhirNutritionOrderEnteralFormula;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderEnteralFormula.create;
  try
    ParseNutritionOrderEnteralFormulaProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderEnteralFormulaProperties(obj : TTurtleComplex; value : TFhirNutritionOrderEnteralFormula);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.baseFormulaType := ParseCodeableReference(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.baseFormulaType'));
    value.baseFormulaProductNameElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.baseFormulaProductName'));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.enteralFormula.deliveryDevice') do
      value.deliveryDeviceList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.enteralFormula.additive') do
      value.additiveList.Add(parseNutritionOrderEnteralFormulaAdditive(item));
    value.caloricDensity := ParseQuantity(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.caloricDensity'));
    value.routeOfAdministration := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.routeOfAdministration'));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.enteralFormula.administration') do
      value.administrationList.Add(parseNutritionOrderEnteralFormulaAdministration(item));
    value.maxVolumeToDeliver := ParseQuantity(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.maxVolumeToDeliver'));
    value.administrationInstructionElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.administrationInstruction'));
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderEnteralFormula(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionOrderEnteralFormula; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderEnteralFormula');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(this, 'NutritionOrder.enteralFormula', 'baseFormulaType', value.baseFormulaTypeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NutritionOrder.enteralFormula', 'baseFormulaProductName', value.baseFormulaProductNameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.deliveryDeviceList.Count - 1 do
      ComposeCodeableReference(this, 'NutritionOrder.enteralFormula', 'deliveryDevice', value.deliveryDeviceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.additiveList.Count - 1 do
      ComposeNutritionOrderEnteralFormulaAdditive(this, 'NutritionOrder.enteralFormula', 'additive', value.additiveList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrder.enteralFormula', 'caloricDensity', value.caloricDensityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.enteralFormula', 'routeOfAdministration', value.routeOfAdministrationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.administrationList.Count - 1 do
      ComposeNutritionOrderEnteralFormulaAdministration(this, 'NutritionOrder.enteralFormula', 'administration', value.administrationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrder.enteralFormula', 'maxVolumeToDeliver', value.maxVolumeToDeliverElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'NutritionOrder.enteralFormula', 'administrationInstruction', value.administrationInstructionElement, false, -1);
end;

function TFHIRTurtleParser.ParseNutritionOrderEnteralFormulaAdditive(obj : TTurtleComplex) : TFhirNutritionOrderEnteralFormulaAdditive;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderEnteralFormulaAdditive.create;
  try
    ParseNutritionOrderEnteralFormulaAdditiveProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderEnteralFormulaAdditiveProperties(obj : TTurtleComplex; value : TFhirNutritionOrderEnteralFormulaAdditive);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableReference(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.additive.type'));
    value.productNameElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.additive.productName'));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.additive.quantity'));
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderEnteralFormulaAdditive(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionOrderEnteralFormulaAdditive; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderEnteralFormulaAdditive');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(this, 'NutritionOrder.enteralFormula.additive', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NutritionOrder.enteralFormula.additive', 'productName', value.productNameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrder.enteralFormula.additive', 'quantity', value.quantityElement, false, -1);
end;

function TFHIRTurtleParser.ParseNutritionOrderEnteralFormulaAdministration(obj : TTurtleComplex) : TFhirNutritionOrderEnteralFormulaAdministration;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderEnteralFormulaAdministration.create;
  try
    ParseNutritionOrderEnteralFormulaAdministrationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderEnteralFormulaAdministrationProperties(obj : TTurtleComplex; value : TFhirNutritionOrderEnteralFormulaAdministration);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.schedule := ParseNutritionOrderEnteralFormulaAdministrationSchedule(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.administration.schedule'));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.administration.quantity'));
    if obj.has('rateQuantity', item) then
      value.rate := parseQuantity(item);
    if obj.has('rateRatio', item) then
      value.rate := parseRatio(item);
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderEnteralFormulaAdministration(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionOrderEnteralFormulaAdministration; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderEnteralFormulaAdministration');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeNutritionOrderEnteralFormulaAdministrationSchedule(this, 'NutritionOrder.enteralFormula.administration', 'schedule', value.scheduleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrder.enteralFormula.administration', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.rate is TFhirQuantity) {6} then
    ComposeQuantity(this, 'NutritionOrder.enteralFormula.administration', 'rateQuantity', TFhirQuantity(value.rate), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.rate is TFhirRatio) {6} then
    ComposeRatio(this, 'NutritionOrder.enteralFormula.administration', 'rateRatio', TFhirRatio(value.rate), false, -1);
end;

function TFHIRTurtleParser.ParseNutritionOrderEnteralFormulaAdministrationSchedule(obj : TTurtleComplex) : TFhirNutritionOrderEnteralFormulaAdministrationSchedule;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderEnteralFormulaAdministrationSchedule.create;
  try
    ParseNutritionOrderEnteralFormulaAdministrationScheduleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderEnteralFormulaAdministrationScheduleProperties(obj : TTurtleComplex; value : TFhirNutritionOrderEnteralFormulaAdministrationSchedule);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.enteralFormula.administration.schedule.timing') do
      value.timingList.Add(parseTiming(item));
    value.asNeededElement := ParseBoolean(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.administration.schedule.asNeeded'));
    value.asNeededFor := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.administration.schedule.asNeededFor'));
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderEnteralFormulaAdministrationSchedule(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionOrderEnteralFormulaAdministrationSchedule; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderEnteralFormulaAdministrationSchedule');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.timingList.Count - 1 do
      ComposeTiming(this, 'NutritionOrder.enteralFormula.administration.schedule', 'timing', value.timingList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'NutritionOrder.enteralFormula.administration.schedule', 'asNeeded', value.asNeededElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.enteralFormula.administration.schedule', 'asNeededFor', value.asNeededForElement, false, -1);
end;

function TFHIRTurtleParser.ParseNutritionOrder(obj : TTurtleComplex) : TFhirNutritionOrder;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrder.create;
  try
    ParseNutritionOrderProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderProperties(obj : TTurtleComplex; value : TFhirNutritionOrder);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.instantiatesCanonical') do
      value.instantiatesCanonicalList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.instantiatesUri') do
      value.instantiatesUriList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.instantiates') do
      value.instantiatesList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.basedOn') do
      value.basedOnList.Add(parseReference(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/NutritionOrder.status'), CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum);
    value.intentElement := ParseEnum(obj.complex('http://hl7.org/fhir/NutritionOrder.intent'), CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum);
    value.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/NutritionOrder.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/NutritionOrder.subject'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/NutritionOrder.encounter'));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.supportingInformation') do
      value.supportingInformationList.Add(parseReference(item));
    value.dateTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/NutritionOrder.dateTime'));
    value.orderer := ParseReference(obj.complex('http://hl7.org/fhir/NutritionOrder.orderer'));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.performer') do
      value.performerList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.allergyIntolerance') do
      value.allergyIntoleranceList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.foodPreferenceModifier') do
      value.foodPreferenceModifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.excludeFoodModifier') do
      value.excludeFoodModifierList.Add(parseCodeableConcept(item));
    value.outsideFoodAllowedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/NutritionOrder.outsideFoodAllowed'));
    value.oralDiet := ParseNutritionOrderOralDiet(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet'));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.supplement') do
      value.supplementList.Add(parseNutritionOrderSupplement(item));
    value.enteralFormula := ParseNutritionOrderEnteralFormula(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula'));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.note') do
      value.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrder(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionOrder; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrder');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'NutritionOrder', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(this, 'NutritionOrder', 'instantiatesCanonical', value.instantiatesCanonicalList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesUriList.Count - 1 do
      ComposeUri(this, 'NutritionOrder', 'instantiatesUri', value.instantiatesUriList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.instantiatesList.Count - 1 do
      ComposeUri(this, 'NutritionOrder', 'instantiates', value.instantiatesList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'NutritionOrder', 'basedOn', value.basedOnList[i], false, i);
  ComposeEnum(this, 'NutritionOrder', 'status', value.statusElement, CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, false, -1);
  ComposeEnum(this, 'NutritionOrder', 'intent', value.intentElement, CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'NutritionOrder', 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);
  ComposeReference(this, 'NutritionOrder', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'NutritionOrder', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInformationList.Count - 1 do
      ComposeReference(this, 'NutritionOrder', 'supportingInformation', value.supportingInformationList[i], false, i);
  ComposeDateTime(this, 'NutritionOrder', 'dateTime', value.dateTimeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'NutritionOrder', 'orderer', value.ordererElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeCodeableReference(this, 'NutritionOrder', 'performer', value.performerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.allergyIntoleranceList.Count - 1 do
      ComposeReference(this, 'NutritionOrder', 'allergyIntolerance', value.allergyIntoleranceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.foodPreferenceModifierList.Count - 1 do
      ComposeCodeableConcept(this, 'NutritionOrder', 'foodPreferenceModifier', value.foodPreferenceModifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.excludeFoodModifierList.Count - 1 do
      ComposeCodeableConcept(this, 'NutritionOrder', 'excludeFoodModifier', value.excludeFoodModifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'NutritionOrder', 'outsideFoodAllowed', value.outsideFoodAllowedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeNutritionOrderOralDiet(this, 'NutritionOrder', 'oralDiet', value.oralDietElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supplementList.Count - 1 do
      ComposeNutritionOrderSupplement(this, 'NutritionOrder', 'supplement', value.supplementList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeNutritionOrderEnteralFormula(this, 'NutritionOrder', 'enteralFormula', value.enteralFormulaElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'NutritionOrder', 'note', value.noteList[i], false, i);
end;

{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_NUTRITIONPRODUCT}
function TFHIRTurtleParser.ParseNutritionProductNutrient(obj : TTurtleComplex) : TFhirNutritionProductNutrient;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionProductNutrient.create;
  try
    ParseNutritionProductNutrientProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionProductNutrientProperties(obj : TTurtleComplex; value : TFhirNutritionProductNutrient);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.item := ParseCodeableReference(obj.complex('http://hl7.org/fhir/NutritionProduct.nutrient.item'));
    for item in obj.complexes('http://hl7.org/fhir/NutritionProduct.nutrient.amount') do
      value.amountList.Add(parseRatio(item));
end;

procedure TFHIRTurtleComposer.ComposeNutritionProductNutrient(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionProductNutrient; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionProductNutrient');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(this, 'NutritionProduct.nutrient', 'item', value.itemElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.amountList.Count - 1 do
      ComposeRatio(this, 'NutritionProduct.nutrient', 'amount', value.amountList[i], false, i);
end;

function TFHIRTurtleParser.ParseNutritionProductIngredient(obj : TTurtleComplex) : TFhirNutritionProductIngredient;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionProductIngredient.create;
  try
    ParseNutritionProductIngredientProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionProductIngredientProperties(obj : TTurtleComplex; value : TFhirNutritionProductIngredient);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.item := ParseCodeableReference(obj.complex('http://hl7.org/fhir/NutritionProduct.ingredient.item'));
    for item in obj.complexes('http://hl7.org/fhir/NutritionProduct.ingredient.amount') do
      value.amountList.Add(parseRatio(item));
end;

procedure TFHIRTurtleComposer.ComposeNutritionProductIngredient(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionProductIngredient; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionProductIngredient');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableReference(this, 'NutritionProduct.ingredient', 'item', value.itemElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.amountList.Count - 1 do
      ComposeRatio(this, 'NutritionProduct.ingredient', 'amount', value.amountList[i], false, i);
end;

function TFHIRTurtleParser.ParseNutritionProductCharacteristic(obj : TTurtleComplex) : TFhirNutritionProductCharacteristic;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionProductCharacteristic.create;
  try
    ParseNutritionProductCharacteristicProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionProductCharacteristicProperties(obj : TTurtleComplex; value : TFhirNutritionProductCharacteristic);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionProduct.characteristic.type'));
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueAttachment', item) then
      value.value := parseAttachment(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    if obj.has('valueBase64Binary', item) then
      value.value := parseBase64Binary(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
end;

procedure TFHIRTurtleComposer.ComposeNutritionProductCharacteristic(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionProductCharacteristic; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionProductCharacteristic');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'NutritionProduct.characteristic', 'type', value.type_Element, false, -1);
  if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'NutritionProduct.characteristic', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'NutritionProduct.characteristic', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (value.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'NutritionProduct.characteristic', 'valueAttachment', TFhirAttachment(value.value), false, -1)
  else if (value.value is TFhirString) {6} then
    ComposeString(this, 'NutritionProduct.characteristic', 'valueString', TFhirString(value.value), false, -1)
  else if (value.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'NutritionProduct.characteristic', 'valueBase64Binary', TFhirBase64Binary(value.value), false, -1)
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'NutritionProduct.characteristic', 'valueBoolean', TFhirBoolean(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseNutritionProductInstance(obj : TTurtleComplex) : TFhirNutritionProductInstance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionProductInstance.create;
  try
    ParseNutritionProductInstanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionProductInstanceProperties(obj : TTurtleComplex; value : TFhirNutritionProductInstance);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/NutritionProduct.instance.quantity'));
    for item in obj.complexes('http://hl7.org/fhir/NutritionProduct.instance.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionProduct.instance.name'));
    value.lotNumberElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionProduct.instance.lotNumber'));
    value.expiryElement := ParseDateTime(obj.complex('http://hl7.org/fhir/NutritionProduct.instance.expiry'));
    value.useByElement := ParseDateTime(obj.complex('http://hl7.org/fhir/NutritionProduct.instance.useBy'));
    value.biologicalSourceEvent := ParseIdentifier(obj.complex('http://hl7.org/fhir/NutritionProduct.instance.biologicalSourceEvent'));
end;

procedure TFHIRTurtleComposer.ComposeNutritionProductInstance(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionProductInstance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionProductInstance');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionProduct.instance', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'NutritionProduct.instance', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NutritionProduct.instance', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NutritionProduct.instance', 'lotNumber', value.lotNumberElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'NutritionProduct.instance', 'expiry', value.expiryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'NutritionProduct.instance', 'useBy', value.useByElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'NutritionProduct.instance', 'biologicalSourceEvent', value.biologicalSourceEventElement, false, -1);
end;

function TFHIRTurtleParser.ParseNutritionProduct(obj : TTurtleComplex) : TFhirNutritionProduct;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionProduct.create;
  try
    ParseNutritionProductProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionProductProperties(obj : TTurtleComplex; value : TFhirNutritionProduct);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionProduct.code'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/NutritionProduct.status'), CODES_TFhirNutritionProductStatusEnum, SYSTEMS_TFhirNutritionProductStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/NutritionProduct.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionProduct.manufacturer') do
      value.manufacturerList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionProduct.nutrient') do
      value.nutrientList.Add(parseNutritionProductNutrient(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionProduct.ingredient') do
      value.ingredientList.Add(parseNutritionProductIngredient(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionProduct.knownAllergen') do
      value.knownAllergenList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionProduct.characteristic') do
      value.characteristicList.Add(parseNutritionProductCharacteristic(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionProduct.instance') do
      value.instanceList.Add(parseNutritionProductInstance(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionProduct.note') do
      value.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeNutritionProduct(parent :  TTurtleComplex; parentType, name : String; value : TFhirNutritionProduct; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionProduct');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'NutritionProduct', 'code', value.codeElement, false, -1);
  ComposeEnum(this, 'NutritionProduct', 'status', value.statusElement, CODES_TFhirNutritionProductStatusEnum, SYSTEMS_TFhirNutritionProductStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'NutritionProduct', 'category', value.categoryList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.manufacturerList.Count - 1 do
      ComposeReference(this, 'NutritionProduct', 'manufacturer', value.manufacturerList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.nutrientList.Count - 1 do
      ComposeNutritionProductNutrient(this, 'NutritionProduct', 'nutrient', value.nutrientList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.ingredientList.Count - 1 do
      ComposeNutritionProductIngredient(this, 'NutritionProduct', 'ingredient', value.ingredientList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.knownAllergenList.Count - 1 do
      ComposeCodeableReference(this, 'NutritionProduct', 'knownAllergen', value.knownAllergenList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.characteristicList.Count - 1 do
      ComposeNutritionProductCharacteristic(this, 'NutritionProduct', 'characteristic', value.characteristicList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.instanceList.Count - 1 do
      ComposeNutritionProductInstance(this, 'NutritionProduct', 'instance', value.instanceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'NutritionProduct', 'note', value.noteList[i], false, i);
end;

{$ENDIF FHIR_NUTRITIONPRODUCT}
{$IFDEF FHIR_OBSERVATION}
function TFHIRTurtleParser.ParseObservationTriggeredBy(obj : TTurtleComplex) : TFhirObservationTriggeredBy;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirObservationTriggeredBy.create;
  try
    ParseObservationTriggeredByProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseObservationTriggeredByProperties(obj : TTurtleComplex; value : TFhirObservationTriggeredBy);
begin
    ParseBackboneElementProperties(obj, value);
    value.observation := ParseReference(obj.complex('http://hl7.org/fhir/Observation.triggeredBy.observation'));
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Observation.triggeredBy.type'), CODES_TFhirTriggeredBytypeEnum, SYSTEMS_TFhirTriggeredBytypeEnum);
    value.reasonElement := ParseString(obj.complex('http://hl7.org/fhir/Observation.triggeredBy.reason'));
end;

procedure TFHIRTurtleComposer.ComposeObservationTriggeredBy(parent :  TTurtleComplex; parentType, name : String; value : TFhirObservationTriggeredBy; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ObservationTriggeredBy');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeReference(this, 'Observation.triggeredBy', 'observation', value.observationElement, false, -1);
  ComposeEnum(this, 'Observation.triggeredBy', 'type', value.type_Element, CODES_TFhirTriggeredBytypeEnum, SYSTEMS_TFhirTriggeredBytypeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Observation.triggeredBy', 'reason', value.reasonElement, false, -1);
end;

function TFHIRTurtleParser.ParseObservationReferenceRange(obj : TTurtleComplex) : TFhirObservationReferenceRange;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirObservationReferenceRange.create;
  try
    ParseObservationReferenceRangeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseObservationReferenceRangeProperties(obj : TTurtleComplex; value : TFhirObservationReferenceRange);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.low := ParseQuantity(obj.complex('http://hl7.org/fhir/Observation.referenceRange.low'));
    value.high := ParseQuantity(obj.complex('http://hl7.org/fhir/Observation.referenceRange.high'));
    value.normalValue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.referenceRange.normalValue'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.referenceRange.type'));
    for item in obj.complexes('http://hl7.org/fhir/Observation.referenceRange.appliesTo') do
      value.appliesToList.Add(parseCodeableConcept(item));
    value.age := ParseRange(obj.complex('http://hl7.org/fhir/Observation.referenceRange.age'));
    value.textElement := ParseString(obj.complex('http://hl7.org/fhir/Observation.referenceRange.text'));
end;

procedure TFHIRTurtleComposer.ComposeObservationReferenceRange(parent :  TTurtleComplex; parentType, name : String; value : TFhirObservationReferenceRange; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ObservationReferenceRange');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Observation.referenceRange', 'low', value.lowElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Observation.referenceRange', 'high', value.highElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Observation.referenceRange', 'normalValue', value.normalValueElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Observation.referenceRange', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.appliesToList.Count - 1 do
      ComposeCodeableConcept(this, 'Observation.referenceRange', 'appliesTo', value.appliesToList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(this, 'Observation.referenceRange', 'age', value.ageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Observation.referenceRange', 'text', value.textElement, false, -1);
end;

function TFHIRTurtleParser.ParseObservationComponent(obj : TTurtleComplex) : TFhirObservationComponent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirObservationComponent.create;
  try
    ParseObservationComponentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseObservationComponentProperties(obj : TTurtleComplex; value : TFhirObservationComponent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.component.code'));
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueRange', item) then
      value.value := parseRange(item);
    if obj.has('valueRatio', item) then
      value.value := parseRatio(item);
    if obj.has('valueSampledData', item) then
      value.value := parseSampledData(item);
    if obj.has('valuePeriod', item) then
      value.value := parsePeriod(item);
    if obj.has('valueAttachment', item) then
      value.value := parseAttachment(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    if obj.has('valueInteger', item) then
      value.value := parseInteger(item);
    if obj.has('valueTime', item) then
      value.value := parseTime(item);
    if obj.has('valueDateTime', item) then
      value.value := parseDateTime(item);
    value.dataAbsentReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.component.dataAbsentReason'));
    for item in obj.complexes('http://hl7.org/fhir/Observation.component.interpretation') do
      value.interpretationList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Observation.component.referenceRange') do
      value.referenceRangeList.Add(parseObservationReferenceRange(item));
end;

procedure TFHIRTurtleComposer.ComposeObservationComponent(parent :  TTurtleComplex; parentType, name : String; value : TFhirObservationComponent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ObservationComponent');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'Observation.component', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Observation.component', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Observation.component', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirRange) {6} then
    ComposeRange(this, 'Observation.component', 'valueRange', TFhirRange(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirRatio) {6} then
    ComposeRatio(this, 'Observation.component', 'valueRatio', TFhirRatio(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'Observation.component', 'valueSampledData', TFhirSampledData(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'Observation.component', 'valuePeriod', TFhirPeriod(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Observation.component', 'valueAttachment', TFhirAttachment(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirString) {6} then
    ComposeString(this, 'Observation.component', 'valueString', TFhirString(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Observation.component', 'valueBoolean', TFhirBoolean(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Observation.component', 'valueInteger', TFhirInteger(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirTime) {6} then
    ComposeTime(this, 'Observation.component', 'valueTime', TFhirTime(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Observation.component', 'valueDateTime', TFhirDateTime(value.value), false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Observation.component', 'dataAbsentReason', value.dataAbsentReasonElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.interpretationList.Count - 1 do
      ComposeCodeableConcept(this, 'Observation.component', 'interpretation', value.interpretationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(this, 'Observation.component', 'referenceRange', value.referenceRangeList[i], false, i);
end;

function TFHIRTurtleParser.ParseObservation(obj : TTurtleComplex) : TFhirObservation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirObservation.create;
  try
    ParseObservationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseObservationProperties(obj : TTurtleComplex; value : TFhirObservation);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Observation.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    if obj.has('instantiatesCanonical', item) then
      value.instantiates := parseCanonical(item);
    if obj.has('instantiatesReference', item) {a3} then
      value.instantiates := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/Observation.basedOn') do
      value.basedOnList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Observation.triggeredBy') do
      value.triggeredByList.Add(parseObservationTriggeredBy(item));
    for item in obj.complexes('http://hl7.org/fhir/Observation.partOf') do
      value.partOfList.Add(parseReference(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Observation.status'), CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/Observation.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.code'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/Observation.subject'));
    for item in obj.complexes('http://hl7.org/fhir/Observation.focus') do
      value.focusList.Add(parseReference(item));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/Observation.encounter'));
    if obj.has('effectivePeriod', item) then
      value.effective := parsePeriod(item);
    if obj.has('effectiveTiming', item) then
      value.effective := parseTiming(item);
    if obj.has('effectiveDateTime', item) then
      value.effective := parseDateTime(item);
    if obj.has('effectiveInstant', item) then
      value.effective := parseInstant(item);
    value.issuedElement := ParseInstant(obj.complex('http://hl7.org/fhir/Observation.issued'));
    for item in obj.complexes('http://hl7.org/fhir/Observation.performer') do
      value.performerList.Add(parseReference(item));
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueRange', item) then
      value.value := parseRange(item);
    if obj.has('valueRatio', item) then
      value.value := parseRatio(item);
    if obj.has('valueSampledData', item) then
      value.value := parseSampledData(item);
    if obj.has('valuePeriod', item) then
      value.value := parsePeriod(item);
    if obj.has('valueAttachment', item) then
      value.value := parseAttachment(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    if obj.has('valueInteger', item) then
      value.value := parseInteger(item);
    if obj.has('valueTime', item) then
      value.value := parseTime(item);
    if obj.has('valueDateTime', item) then
      value.value := parseDateTime(item);
    value.dataAbsentReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.dataAbsentReason'));
    for item in obj.complexes('http://hl7.org/fhir/Observation.interpretation') do
      value.interpretationList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Observation.note') do
      value.noteList.Add(parseAnnotation(item));
    value.bodySite := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.bodySite'));
    value.bodyStructure := ParseReference(obj.complex('http://hl7.org/fhir/Observation.bodyStructure'));
    value.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.method'));
    value.specimen := ParseReference(obj.complex('http://hl7.org/fhir/Observation.specimen'));
    value.device := ParseReference(obj.complex('http://hl7.org/fhir/Observation.device'));
    for item in obj.complexes('http://hl7.org/fhir/Observation.referenceRange') do
      value.referenceRangeList.Add(parseObservationReferenceRange(item));
    for item in obj.complexes('http://hl7.org/fhir/Observation.hasMember') do
      value.hasMemberList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Observation.derivedFrom') do
      value.derivedFromList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Observation.component') do
      value.componentList.Add(parseObservationComponent(item));
end;

procedure TFHIRTurtleComposer.ComposeObservation(parent :  TTurtleComplex; parentType, name : String; value : TFhirObservation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Observation');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Observation', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.instantiates is TFhirCanonical) {6} then
    ComposeCanonical(this, 'Observation', 'instantiatesCanonical', TFhirCanonical(value.instantiates), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.instantiates is TFhirReference) {2} then
    ComposeReference(this, 'Observation', 'instantiatesReference', TFhirReference(value.instantiates), false,-1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'Observation', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.triggeredByList.Count - 1 do
      ComposeObservationTriggeredBy(this, 'Observation', 'triggeredBy', value.triggeredByList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(this, 'Observation', 'partOf', value.partOfList[i], false, i);
  ComposeEnum(this, 'Observation', 'status', value.statusElement, CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Observation', 'category', value.categoryList[i], false, i);
  ComposeCodeableConcept(this, 'Observation', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Observation', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.focusList.Count - 1 do
      ComposeReference(this, 'Observation', 'focus', value.focusList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Observation', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.effective is TFhirPeriod) {6} then
    ComposePeriod(this, 'Observation', 'effectivePeriod', TFhirPeriod(value.effective), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.effective is TFhirTiming) {6} then
    ComposeTiming(this, 'Observation', 'effectiveTiming', TFhirTiming(value.effective), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.effective is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Observation', 'effectiveDateTime', TFhirDateTime(value.effective), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.effective is TFhirInstant) {6} then
    ComposeInstant(this, 'Observation', 'effectiveInstant', TFhirInstant(value.effective), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'Observation', 'issued', value.issuedElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeReference(this, 'Observation', 'performer', value.performerList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Observation', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Observation', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirRange) {6} then
    ComposeRange(this, 'Observation', 'valueRange', TFhirRange(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirRatio) {6} then
    ComposeRatio(this, 'Observation', 'valueRatio', TFhirRatio(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'Observation', 'valueSampledData', TFhirSampledData(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'Observation', 'valuePeriod', TFhirPeriod(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Observation', 'valueAttachment', TFhirAttachment(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirString) {6} then
    ComposeString(this, 'Observation', 'valueString', TFhirString(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Observation', 'valueBoolean', TFhirBoolean(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Observation', 'valueInteger', TFhirInteger(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirTime) {6} then
    ComposeTime(this, 'Observation', 'valueTime', TFhirTime(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Observation', 'valueDateTime', TFhirDateTime(value.value), false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Observation', 'dataAbsentReason', value.dataAbsentReasonElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.interpretationList.Count - 1 do
      ComposeCodeableConcept(this, 'Observation', 'interpretation', value.interpretationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'Observation', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Observation', 'bodySite', value.bodySiteElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Observation', 'bodyStructure', value.bodyStructureElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Observation', 'method', value.methodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Observation', 'specimen', value.specimenElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Observation', 'device', value.deviceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(this, 'Observation', 'referenceRange', value.referenceRangeList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.hasMemberList.Count - 1 do
      ComposeReference(this, 'Observation', 'hasMember', value.hasMemberList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.derivedFromList.Count - 1 do
      ComposeReference(this, 'Observation', 'derivedFrom', value.derivedFromList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.componentList.Count - 1 do
      ComposeObservationComponent(this, 'Observation', 'component', value.componentList[i], false, i);
end;

{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
function TFHIRTurtleParser.ParseObservationDefinitionQuantitativeDetails(obj : TTurtleComplex) : TFhirObservationDefinitionQuantitativeDetails;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirObservationDefinitionQuantitativeDetails.create;
  try
    ParseObservationDefinitionQuantitativeDetailsProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseObservationDefinitionQuantitativeDetailsProperties(obj : TTurtleComplex; value : TFhirObservationDefinitionQuantitativeDetails);
begin
    ParseBackboneElementProperties(obj, value);
    value.unit_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ObservationDefinition.quantitativeDetails.unit'));
    value.customaryUnit := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ObservationDefinition.quantitativeDetails.customaryUnit'));
    value.conversionFactorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ObservationDefinition.quantitativeDetails.conversionFactor'));
    value.decimalPrecisionElement := ParseInteger(obj.complex('http://hl7.org/fhir/ObservationDefinition.quantitativeDetails.decimalPrecision'));
end;

procedure TFHIRTurtleComposer.ComposeObservationDefinitionQuantitativeDetails(parent :  TTurtleComplex; parentType, name : String; value : TFhirObservationDefinitionQuantitativeDetails; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ObservationDefinitionQuantitativeDetails');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ObservationDefinition.quantitativeDetails', 'unit', value.unit_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ObservationDefinition.quantitativeDetails', 'customaryUnit', value.customaryUnitElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ObservationDefinition.quantitativeDetails', 'conversionFactor', value.conversionFactorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'ObservationDefinition.quantitativeDetails', 'decimalPrecision', value.decimalPrecisionElement, false, -1);
end;

function TFHIRTurtleParser.ParseObservationDefinitionQualifiedValue(obj : TTurtleComplex) : TFhirObservationDefinitionQualifiedValue;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirObservationDefinitionQualifiedValue.create;
  try
    ParseObservationDefinitionQualifiedValueProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseObservationDefinitionQualifiedValueProperties(obj : TTurtleComplex; value : TFhirObservationDefinitionQualifiedValue);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.context := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ObservationDefinition.qualifiedValue.context'));
    for item in obj.complexes('http://hl7.org/fhir/ObservationDefinition.qualifiedValue.appliesTo') do
      value.appliesToList.Add(parseCodeableConcept(item));
    value.genderElement := ParseEnum(obj.complex('http://hl7.org/fhir/ObservationDefinition.qualifiedValue.gender'), CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    value.age := ParseRange(obj.complex('http://hl7.org/fhir/ObservationDefinition.qualifiedValue.age'));
    value.gestationalAge := ParseRange(obj.complex('http://hl7.org/fhir/ObservationDefinition.qualifiedValue.gestationalAge'));
    value.conditionElement := ParseString(obj.complex('http://hl7.org/fhir/ObservationDefinition.qualifiedValue.condition'));
    value.rangeCategoryElement := ParseEnum(obj.complex('http://hl7.org/fhir/ObservationDefinition.qualifiedValue.rangeCategory'), CODES_TFhirObservationRangeCategoryEnum, SYSTEMS_TFhirObservationRangeCategoryEnum);
    value.range := ParseRange(obj.complex('http://hl7.org/fhir/ObservationDefinition.qualifiedValue.range'));
    value.validCodedValueSetElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ObservationDefinition.qualifiedValue.validCodedValueSet'));
    value.normalCodedValueSetElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ObservationDefinition.qualifiedValue.normalCodedValueSet'));
    value.abnormalCodedValueSetElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ObservationDefinition.qualifiedValue.abnormalCodedValueSet'));
    value.criticalCodedValueSetElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ObservationDefinition.qualifiedValue.criticalCodedValueSet'));
end;

procedure TFHIRTurtleComposer.ComposeObservationDefinitionQualifiedValue(parent :  TTurtleComplex; parentType, name : String; value : TFhirObservationDefinitionQualifiedValue; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ObservationDefinitionQualifiedValue');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ObservationDefinition.qualifiedValue', 'context', value.contextElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.appliesToList.Count - 1 do
      ComposeCodeableConcept(this, 'ObservationDefinition.qualifiedValue', 'appliesTo', value.appliesToList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'ObservationDefinition.qualifiedValue', 'gender', value.genderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(this, 'ObservationDefinition.qualifiedValue', 'age', value.ageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(this, 'ObservationDefinition.qualifiedValue', 'gestationalAge', value.gestationalAgeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ObservationDefinition.qualifiedValue', 'condition', value.conditionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'ObservationDefinition.qualifiedValue', 'rangeCategory', value.rangeCategoryElement, CODES_TFhirObservationRangeCategoryEnum, SYSTEMS_TFhirObservationRangeCategoryEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(this, 'ObservationDefinition.qualifiedValue', 'range', value.rangeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'ObservationDefinition.qualifiedValue', 'validCodedValueSet', value.validCodedValueSetElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'ObservationDefinition.qualifiedValue', 'normalCodedValueSet', value.normalCodedValueSetElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'ObservationDefinition.qualifiedValue', 'abnormalCodedValueSet', value.abnormalCodedValueSetElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'ObservationDefinition.qualifiedValue', 'criticalCodedValueSet', value.criticalCodedValueSetElement, false, -1);
end;

function TFHIRTurtleParser.ParseObservationDefinitionComponent(obj : TTurtleComplex) : TFhirObservationDefinitionComponent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirObservationDefinitionComponent.create;
  try
    ParseObservationDefinitionComponentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseObservationDefinitionComponentProperties(obj : TTurtleComplex; value : TFhirObservationDefinitionComponent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ObservationDefinition.component.code'));
    for item in obj.complexes('http://hl7.org/fhir/ObservationDefinition.component.permittedDataType') do
      value.permittedDataTypeList.Add(parseEnum(item, CODES_TFhirObservationDataTypeEnum, SYSTEMS_TFhirObservationDataTypeEnum));
    value.quantitativeDetails := ParseObservationDefinitionQuantitativeDetails(obj.complex('http://hl7.org/fhir/ObservationDefinition.component.quantitativeDetails'));
    for item in obj.complexes('http://hl7.org/fhir/ObservationDefinition.component.qualifiedValue') do
      value.qualifiedValueList.Add(parseObservationDefinitionQualifiedValue(item));
end;

procedure TFHIRTurtleComposer.ComposeObservationDefinitionComponent(parent :  TTurtleComplex; parentType, name : String; value : TFhirObservationDefinitionComponent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ObservationDefinitionComponent');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'ObservationDefinition.component', 'code', value.codeElement, false, -1);
  for i := 0 to value.permittedDataTypeList.Count - 1 do
      ComposeEnum(this, 'ObservationDefinition.component', 'permittedDataType', value.permittedDataTypeList[i], CODES_TFhirObservationDataTypeEnum, SYSTEMS_TFhirObservationDataTypeEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.permittedDataTypeList.Count - 1 do
      ComposeEnum(this, 'ObservationDefinition.component', 'permittedDataType', value.permittedDataTypeList[i], CODES_TFhirObservationDataTypeEnum, SYSTEMS_TFhirObservationDataTypeEnum, false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeObservationDefinitionQuantitativeDetails(this, 'ObservationDefinition.component', 'quantitativeDetails', value.quantitativeDetailsElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.qualifiedValueList.Count - 1 do
      ComposeObservationDefinitionQualifiedValue(this, 'ObservationDefinition.component', 'qualifiedValue', value.qualifiedValueList[i], false, i);
end;

function TFHIRTurtleParser.ParseObservationDefinition(obj : TTurtleComplex) : TFhirObservationDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirObservationDefinition.create;
  try
    ParseObservationDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseObservationDefinitionProperties(obj : TTurtleComplex; value : TFhirObservationDefinition);
var
  item : TTurtleComplex;
begin
    ParseMetadataResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ObservationDefinition.url'));
    value.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/ObservationDefinition.identifier'));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ObservationDefinition.version'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ObservationDefinition.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ObservationDefinition.title'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ObservationDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ObservationDefinition.experimental'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ObservationDefinition.date'));
    value.publisher := ParseString(obj.complex('http://hl7.org/fhir/ObservationDefinition.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/ObservationDefinition.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ObservationDefinition.description'));
    for item in obj.complexes('http://hl7.org/fhir/ObservationDefinition.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/ObservationDefinition.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ObservationDefinition.purpose'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ObservationDefinition.copyright'));
    value.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ObservationDefinition.approvalDate'));
    value.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ObservationDefinition.lastReviewDate'));
    value.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/ObservationDefinition.effectivePeriod'));
    for item in obj.complexes('http://hl7.org/fhir/ObservationDefinition.derivedFromCanonical') do
      value.derivedFromCanonicalList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/ObservationDefinition.derivedFromUri') do
      value.derivedFromUriList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/ObservationDefinition.subject') do
      value.subjectList.Add(parseCodeableConcept(item));
    value.performerType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ObservationDefinition.performerType'));
    for item in obj.complexes('http://hl7.org/fhir/ObservationDefinition.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ObservationDefinition.code'));
    for item in obj.complexes('http://hl7.org/fhir/ObservationDefinition.permittedDataType') do
      value.permittedDataTypeList.Add(parseEnum(item, CODES_TFhirObservationDataTypeEnum, SYSTEMS_TFhirObservationDataTypeEnum));
    value.multipleResultsAllowedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ObservationDefinition.multipleResultsAllowed'));
    value.bodySite := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ObservationDefinition.bodySite'));
    value.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ObservationDefinition.method'));
    for item in obj.complexes('http://hl7.org/fhir/ObservationDefinition.specimen') do
      value.specimenList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ObservationDefinition.device') do
      value.deviceList.Add(parseReference(item));
    value.preferredReportNameElement := ParseString(obj.complex('http://hl7.org/fhir/ObservationDefinition.preferredReportName'));
    value.quantitativeDetails := ParseObservationDefinitionQuantitativeDetails(obj.complex('http://hl7.org/fhir/ObservationDefinition.quantitativeDetails'));
    for item in obj.complexes('http://hl7.org/fhir/ObservationDefinition.qualifiedValue') do
      value.qualifiedValueList.Add(parseObservationDefinitionQualifiedValue(item));
    for item in obj.complexes('http://hl7.org/fhir/ObservationDefinition.hasMember') do
      value.hasMemberList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ObservationDefinition.component') do
      value.componentList.Add(parseObservationDefinitionComponent(item));
end;

procedure TFHIRTurtleComposer.ComposeObservationDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirObservationDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ObservationDefinition');
  end;
  composeMetadataResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ObservationDefinition', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'ObservationDefinition', 'identifier', value.identifierElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ObservationDefinition', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ObservationDefinition', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ObservationDefinition', 'title', value.titleElement, false, -1);
  ComposeEnum(this, 'ObservationDefinition', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ObservationDefinition', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ObservationDefinition', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ObservationDefinition', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'ObservationDefinition', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ObservationDefinition', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'ObservationDefinition', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'ObservationDefinition', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ObservationDefinition', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ObservationDefinition', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'ObservationDefinition', 'approvalDate', value.approvalDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'ObservationDefinition', 'lastReviewDate', value.lastReviewDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'ObservationDefinition', 'effectivePeriod', value.effectivePeriodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.derivedFromCanonicalList.Count - 1 do
      ComposeCanonical(this, 'ObservationDefinition', 'derivedFromCanonical', value.derivedFromCanonicalList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.derivedFromUriList.Count - 1 do
      ComposeUri(this, 'ObservationDefinition', 'derivedFromUri', value.derivedFromUriList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.subjectList.Count - 1 do
      ComposeCodeableConcept(this, 'ObservationDefinition', 'subject', value.subjectList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ObservationDefinition', 'performerType', value.performerTypeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'ObservationDefinition', 'category', value.categoryList[i], false, i);
  ComposeCodeableConcept(this, 'ObservationDefinition', 'code', value.codeElement, false, -1);
  for i := 0 to value.permittedDataTypeList.Count - 1 do
      ComposeEnum(this, 'ObservationDefinition', 'permittedDataType', value.permittedDataTypeList[i], CODES_TFhirObservationDataTypeEnum, SYSTEMS_TFhirObservationDataTypeEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.permittedDataTypeList.Count - 1 do
      ComposeEnum(this, 'ObservationDefinition', 'permittedDataType', value.permittedDataTypeList[i], CODES_TFhirObservationDataTypeEnum, SYSTEMS_TFhirObservationDataTypeEnum, false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ObservationDefinition', 'multipleResultsAllowed', value.multipleResultsAllowedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ObservationDefinition', 'bodySite', value.bodySiteElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ObservationDefinition', 'method', value.methodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.specimenList.Count - 1 do
      ComposeReference(this, 'ObservationDefinition', 'specimen', value.specimenList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.deviceList.Count - 1 do
      ComposeReference(this, 'ObservationDefinition', 'device', value.deviceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ObservationDefinition', 'preferredReportName', value.preferredReportNameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeObservationDefinitionQuantitativeDetails(this, 'ObservationDefinition', 'quantitativeDetails', value.quantitativeDetailsElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.qualifiedValueList.Count - 1 do
      ComposeObservationDefinitionQualifiedValue(this, 'ObservationDefinition', 'qualifiedValue', value.qualifiedValueList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.hasMemberList.Count - 1 do
      ComposeReference(this, 'ObservationDefinition', 'hasMember', value.hasMemberList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.componentList.Count - 1 do
      ComposeObservationDefinitionComponent(this, 'ObservationDefinition', 'component', value.componentList[i], false, i);
end;

{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
function TFHIRTurtleParser.ParseOperationDefinitionParameter(obj : TTurtleComplex) : TFhirOperationDefinitionParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationDefinitionParameter.create;
  try
    ParseOperationDefinitionParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationDefinitionParameterProperties(obj : TTurtleComplex; value : TFhirOperationDefinitionParameter);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseCode(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.name'));
    value.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.use'), CODES_TFhirOperationParameterUseEnum, SYSTEMS_TFhirOperationParameterUseEnum);
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.parameter.scope') do
      value.scopeList.Add(parseEnum(item, CODES_TFhirOperationParameterScopeEnum, SYSTEMS_TFhirOperationParameterScopeEnum));
    value.minElement := ParseInteger(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.min'));
    value.maxElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.max'));
    value.documentationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.documentation'));
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.type'), CODES_TFhirFHIRTypesEnum, SYSTEMS_TFhirFHIRTypesEnum);
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.parameter.allowedType') do
      value.allowedType.Add(parseEnum(item, CODES_TFhirFHIRTypesEnum, SYSTEMS_TFhirFHIRTypesEnum));
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.parameter.targetProfile') do
      value.targetProfileList.Add(parseCanonical(item));
    value.searchTypeElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.searchType'), CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum);
    value.binding := ParseOperationDefinitionParameterBinding(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.binding'));
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.parameter.referencedFrom') do
      value.referencedFromList.Add(parseOperationDefinitionParameterReferencedFrom(item));
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.parameter.part') do
      value.partList.Add(parseOperationDefinitionParameter(item));
end;

procedure TFHIRTurtleComposer.ComposeOperationDefinitionParameter(parent :  TTurtleComplex; parentType, name : String; value : TFhirOperationDefinitionParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationDefinitionParameter');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCode(this, 'OperationDefinition.parameter', 'name', value.nameElement, false, -1);
  ComposeEnum(this, 'OperationDefinition.parameter', 'use', value.useElement, CODES_TFhirOperationParameterUseEnum, SYSTEMS_TFhirOperationParameterUseEnum, false, -1);
  for i := 0 to value.scopeList.Count - 1 do
      ComposeEnum(this, 'OperationDefinition.parameter', 'scope', value.scopeList[i], CODES_TFhirOperationParameterScopeEnum, SYSTEMS_TFhirOperationParameterScopeEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.scopeList.Count - 1 do
      ComposeEnum(this, 'OperationDefinition.parameter', 'scope', value.scopeList[i], CODES_TFhirOperationParameterScopeEnum, SYSTEMS_TFhirOperationParameterScopeEnum, false, i);
  ComposeInteger(this, 'OperationDefinition.parameter', 'min', value.minElement, false, -1);
  ComposeString(this, 'OperationDefinition.parameter', 'max', value.maxElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'OperationDefinition.parameter', 'documentation', value.documentationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'OperationDefinition.parameter', 'type', value.type_Element, CODES_TFhirFHIRTypesEnum, SYSTEMS_TFhirFHIRTypesEnum, false, -1);
  for i := 0 to value.allowedType.Count - 1 do
      ComposeEnum(this, 'OperationDefinition.parameter', 'allowedType', value.allowedType[i], CODES_TFhirFHIRTypesEnum, SYSTEMS_TFhirFHIRTypesEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.allowedType.Count - 1 do
      ComposeEnum(this, 'OperationDefinition.parameter', 'allowedType', value.allowedType[i], CODES_TFhirFHIRTypesEnum, SYSTEMS_TFhirFHIRTypesEnum, false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.targetProfileList.Count - 1 do
      ComposeCanonical(this, 'OperationDefinition.parameter', 'targetProfile', value.targetProfileList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'OperationDefinition.parameter', 'searchType', value.searchTypeElement, CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeOperationDefinitionParameterBinding(this, 'OperationDefinition.parameter', 'binding', value.bindingElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.referencedFromList.Count - 1 do
      ComposeOperationDefinitionParameterReferencedFrom(this, 'OperationDefinition.parameter', 'referencedFrom', value.referencedFromList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.partList.Count - 1 do
      ComposeOperationDefinitionParameter(this, 'OperationDefinition.parameter', 'part', value.partList[i], false, i);
end;

function TFHIRTurtleParser.ParseOperationDefinitionParameterBinding(obj : TTurtleComplex) : TFhirOperationDefinitionParameterBinding;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationDefinitionParameterBinding.create;
  try
    ParseOperationDefinitionParameterBindingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationDefinitionParameterBindingProperties(obj : TTurtleComplex; value : TFhirOperationDefinitionParameterBinding);
begin
    ParseBackboneElementProperties(obj, value);
    value.strengthElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.binding.strength'), CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum);
    value.valueSetElement := ParseCanonical(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.binding.valueSet'));
end;

procedure TFHIRTurtleComposer.ComposeOperationDefinitionParameterBinding(parent :  TTurtleComplex; parentType, name : String; value : TFhirOperationDefinitionParameterBinding; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationDefinitionParameterBinding');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'OperationDefinition.parameter.binding', 'strength', value.strengthElement, CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum, false, -1);
  ComposeCanonical(this, 'OperationDefinition.parameter.binding', 'valueSet', value.valueSetElement, false, -1);
end;

function TFHIRTurtleParser.ParseOperationDefinitionParameterReferencedFrom(obj : TTurtleComplex) : TFhirOperationDefinitionParameterReferencedFrom;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationDefinitionParameterReferencedFrom.create;
  try
    ParseOperationDefinitionParameterReferencedFromProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationDefinitionParameterReferencedFromProperties(obj : TTurtleComplex; value : TFhirOperationDefinitionParameterReferencedFrom);
begin
    ParseBackboneElementProperties(obj, value);
    value.sourceElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.referencedFrom.source'));
    value.sourceIdElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.referencedFrom.sourceId'));
end;

procedure TFHIRTurtleComposer.ComposeOperationDefinitionParameterReferencedFrom(parent :  TTurtleComplex; parentType, name : String; value : TFhirOperationDefinitionParameterReferencedFrom; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationDefinitionParameterReferencedFrom');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'OperationDefinition.parameter.referencedFrom', 'source', value.sourceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'OperationDefinition.parameter.referencedFrom', 'sourceId', value.sourceIdElement, false, -1);
end;

function TFHIRTurtleParser.ParseOperationDefinitionOverload(obj : TTurtleComplex) : TFhirOperationDefinitionOverload;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationDefinitionOverload.create;
  try
    ParseOperationDefinitionOverloadProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationDefinitionOverloadProperties(obj : TTurtleComplex; value : TFhirOperationDefinitionOverload);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.overload.parameterName') do
      value.parameterNameList.Add(parseString(item));
    value.commentElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.overload.comment'));
end;

procedure TFHIRTurtleComposer.ComposeOperationDefinitionOverload(parent :  TTurtleComplex; parentType, name : String; value : TFhirOperationDefinitionOverload; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationDefinitionOverload');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.parameterNameList.Count - 1 do
      ComposeString(this, 'OperationDefinition.overload', 'parameterName', value.parameterNameList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'OperationDefinition.overload', 'comment', value.commentElement, false, -1);
end;

function TFHIRTurtleParser.ParseOperationDefinition(obj : TTurtleComplex) : TFhirOperationDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationDefinition.create;
  try
    ParseOperationDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationDefinitionProperties(obj : TTurtleComplex; value : TFhirOperationDefinition);
var
  item : TTurtleComplex;
begin
    ParseCanonicalResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/OperationDefinition.url'));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.version'));
    if obj.has('versionAlgorithmCoding', item) then
      value.versionAlgorithm := parseCoding(item);
    if obj.has('versionAlgorithmString', item) then
      value.versionAlgorithm := parseString(item);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.title'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationDefinition.kind'), CODES_TFhirOperationKindEnum, SYSTEMS_TFhirOperationKindEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/OperationDefinition.experimental'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/OperationDefinition.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/OperationDefinition.description'));
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/OperationDefinition.purpose'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/OperationDefinition.copyright'));
    value.copyrightLabelElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.copyrightLabel'));
    value.affectsStateElement := ParseBoolean(obj.complex('http://hl7.org/fhir/OperationDefinition.affectsState'));
    value.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/OperationDefinition.code'));
    value.commentElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/OperationDefinition.comment'));
    value.baseElement := ParseCanonical(obj.complex('http://hl7.org/fhir/OperationDefinition.base'));
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.resource') do
      value.resource.Add(parseEnum(item, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum));
    value.systemElement := ParseBoolean(obj.complex('http://hl7.org/fhir/OperationDefinition.system'));
    value.type_Element := ParseBoolean(obj.complex('http://hl7.org/fhir/OperationDefinition.type'));
    value.instanceElement := ParseBoolean(obj.complex('http://hl7.org/fhir/OperationDefinition.instance'));
    value.inputProfileElement := ParseCanonical(obj.complex('http://hl7.org/fhir/OperationDefinition.inputProfile'));
    value.outputProfileElement := ParseCanonical(obj.complex('http://hl7.org/fhir/OperationDefinition.outputProfile'));
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.parameter') do
      value.parameterList.Add(parseOperationDefinitionParameter(item));
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.overload') do
      value.overloadList.Add(parseOperationDefinitionOverload(item));
end;

procedure TFHIRTurtleComposer.ComposeOperationDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirOperationDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationDefinition');
  end;
  composeCanonicalResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'OperationDefinition', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'OperationDefinition', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirCoding) {6} then
    ComposeCoding(this, 'OperationDefinition', 'versionAlgorithmCoding', TFhirCoding(value.versionAlgorithm), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirString) {6} then
    ComposeString(this, 'OperationDefinition', 'versionAlgorithmString', TFhirString(value.versionAlgorithm), false, -1);
  ComposeString(this, 'OperationDefinition', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'OperationDefinition', 'title', value.titleElement, false, -1);
  ComposeEnum(this, 'OperationDefinition', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  ComposeEnum(this, 'OperationDefinition', 'kind', value.kindElement, CODES_TFhirOperationKindEnum, SYSTEMS_TFhirOperationKindEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'OperationDefinition', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'OperationDefinition', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'OperationDefinition', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'OperationDefinition', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'OperationDefinition', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'OperationDefinition', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'OperationDefinition', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'OperationDefinition', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'OperationDefinition', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'OperationDefinition', 'copyrightLabel', value.copyrightLabelElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'OperationDefinition', 'affectsState', value.affectsStateElement, false, -1);
  ComposeCode(this, 'OperationDefinition', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'OperationDefinition', 'comment', value.commentElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(this, 'OperationDefinition', 'base', value.baseElement, false, -1);
  for i := 0 to value.resource.Count - 1 do
      ComposeEnum(this, 'OperationDefinition', 'resource', value.resource[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.resource.Count - 1 do
      ComposeEnum(this, 'OperationDefinition', 'resource', value.resource[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i);
  ComposeBoolean(this, 'OperationDefinition', 'system', value.systemElement, false, -1);
  ComposeBoolean(this, 'OperationDefinition', 'type', value.type_Element, false, -1);
  ComposeBoolean(this, 'OperationDefinition', 'instance', value.instanceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'OperationDefinition', 'inputProfile', value.inputProfileElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'OperationDefinition', 'outputProfile', value.outputProfileElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.parameterList.Count - 1 do
      ComposeOperationDefinitionParameter(this, 'OperationDefinition', 'parameter', value.parameterList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.overloadList.Count - 1 do
      ComposeOperationDefinitionOverload(this, 'OperationDefinition', 'overload', value.overloadList[i], false, i);
end;

{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
function TFHIRTurtleParser.ParseOperationOutcomeIssue(obj : TTurtleComplex) : TFhirOperationOutcomeIssue;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationOutcomeIssue.create;
  try
    ParseOperationOutcomeIssueProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationOutcomeIssueProperties(obj : TTurtleComplex; value : TFhirOperationOutcomeIssue);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.severityElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationOutcome.issue.severity'), CODES_TFhirIssueSeverityEnum, SYSTEMS_TFhirIssueSeverityEnum);
    value.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationOutcome.issue.code'), CODES_TFhirIssueTypeEnum, SYSTEMS_TFhirIssueTypeEnum);
    value.details := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/OperationOutcome.issue.details'));
    value.diagnosticsElement := ParseString(obj.complex('http://hl7.org/fhir/OperationOutcome.issue.diagnostics'));
    for item in obj.complexes('http://hl7.org/fhir/OperationOutcome.issue.location') do
      value.locationList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/OperationOutcome.issue.expression') do
      value.expressionList.Add(parseString(item));
end;

procedure TFHIRTurtleComposer.ComposeOperationOutcomeIssue(parent :  TTurtleComplex; parentType, name : String; value : TFhirOperationOutcomeIssue; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationOutcomeIssue');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'OperationOutcome.issue', 'severity', value.severityElement, CODES_TFhirIssueSeverityEnum, SYSTEMS_TFhirIssueSeverityEnum, false, -1);
  ComposeEnum(this, 'OperationOutcome.issue', 'code', value.codeElement, CODES_TFhirIssueTypeEnum, SYSTEMS_TFhirIssueTypeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'OperationOutcome.issue', 'details', value.detailsElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'OperationOutcome.issue', 'diagnostics', value.diagnosticsElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.locationList.Count - 1 do
      ComposeString(this, 'OperationOutcome.issue', 'location', value.locationList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.expressionList.Count - 1 do
      ComposeString(this, 'OperationOutcome.issue', 'expression', value.expressionList[i], false, i);
end;

function TFHIRTurtleParser.ParseOperationOutcome(obj : TTurtleComplex) : TFhirOperationOutcome;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationOutcome.create;
  try
    ParseOperationOutcomeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationOutcomeProperties(obj : TTurtleComplex; value : TFhirOperationOutcome);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/OperationOutcome.issue') do
      value.issueList.Add(parseOperationOutcomeIssue(item));
end;

procedure TFHIRTurtleComposer.ComposeOperationOutcome(parent :  TTurtleComplex; parentType, name : String; value : TFhirOperationOutcome; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationOutcome');
  end;
  composeDomainResource(this, '', name, value, false, index);
  for i := 0 to value.issueList.Count - 1 do
      ComposeOperationOutcomeIssue(this, 'OperationOutcome', 'issue', value.issueList[i], false, i);
end;

{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
function TFHIRTurtleParser.ParseOrganizationQualification(obj : TTurtleComplex) : TFhirOrganizationQualification;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOrganizationQualification.create;
  try
    ParseOrganizationQualificationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOrganizationQualificationProperties(obj : TTurtleComplex; value : TFhirOrganizationQualification);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Organization.qualification.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Organization.qualification.code'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Organization.qualification.period'));
    value.issuer := ParseReference(obj.complex('http://hl7.org/fhir/Organization.qualification.issuer'));
end;

procedure TFHIRTurtleComposer.ComposeOrganizationQualification(parent :  TTurtleComplex; parentType, name : String; value : TFhirOrganizationQualification; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OrganizationQualification');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Organization.qualification', 'identifier', value.identifierList[i], false, i);
  ComposeCodeableConcept(this, 'Organization.qualification', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Organization.qualification', 'period', value.periodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Organization.qualification', 'issuer', value.issuerElement, false, -1);
end;

function TFHIRTurtleParser.ParseOrganization(obj : TTurtleComplex) : TFhirOrganization;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOrganization.create;
  try
    ParseOrganizationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOrganizationProperties(obj : TTurtleComplex; value : TFhirOrganization);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Organization.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Organization.active'));
    for item in obj.complexes('http://hl7.org/fhir/Organization.type') do
      value.type_List.Add(parseCodeableConcept(item));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Organization.name'));
    for item in obj.complexes('http://hl7.org/fhir/Organization.alias') do
      value.aliasList.Add(parseString(item));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Organization.description'));
    for item in obj.complexes('http://hl7.org/fhir/Organization.contact') do
      value.contactList.Add(parseExtendedContactDetail(item));
    value.partOf := ParseReference(obj.complex('http://hl7.org/fhir/Organization.partOf'));
    for item in obj.complexes('http://hl7.org/fhir/Organization.endpoint') do
      value.endpointList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Organization.qualification') do
      value.qualificationList.Add(parseOrganizationQualification(item));
end;

procedure TFHIRTurtleComposer.ComposeOrganization(parent :  TTurtleComplex; parentType, name : String; value : TFhirOrganization; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Organization');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Organization', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Organization', 'active', value.activeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Organization', 'type', value.type_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Organization', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.aliasList.Count - 1 do
      ComposeString(this, 'Organization', 'alias', value.aliasList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Organization', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeExtendedContactDetail(this, 'Organization', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Organization', 'partOf', value.partOfElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endpointList.Count - 1 do
      ComposeReference(this, 'Organization', 'endpoint', value.endpointList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.qualificationList.Count - 1 do
      ComposeOrganizationQualification(this, 'Organization', 'qualification', value.qualificationList[i], false, i);
end;

{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
function TFHIRTurtleParser.ParseOrganizationAffiliation(obj : TTurtleComplex) : TFhirOrganizationAffiliation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOrganizationAffiliation.create;
  try
    ParseOrganizationAffiliationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOrganizationAffiliationProperties(obj : TTurtleComplex; value : TFhirOrganizationAffiliation);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/OrganizationAffiliation.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/OrganizationAffiliation.active'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/OrganizationAffiliation.period'));
    value.organization := ParseReference(obj.complex('http://hl7.org/fhir/OrganizationAffiliation.organization'));
    value.participatingOrganization := ParseReference(obj.complex('http://hl7.org/fhir/OrganizationAffiliation.participatingOrganization'));
    for item in obj.complexes('http://hl7.org/fhir/OrganizationAffiliation.network') do
      value.networkList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/OrganizationAffiliation.code') do
      value.codeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/OrganizationAffiliation.specialty') do
      value.specialtyList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/OrganizationAffiliation.location') do
      value.locationList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/OrganizationAffiliation.healthcareService') do
      value.healthcareServiceList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/OrganizationAffiliation.contact') do
      value.contactList.Add(parseExtendedContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/OrganizationAffiliation.endpoint') do
      value.endpointList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeOrganizationAffiliation(parent :  TTurtleComplex; parentType, name : String; value : TFhirOrganizationAffiliation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OrganizationAffiliation');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'OrganizationAffiliation', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'OrganizationAffiliation', 'active', value.activeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'OrganizationAffiliation', 'period', value.periodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'OrganizationAffiliation', 'organization', value.organizationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'OrganizationAffiliation', 'participatingOrganization', value.participatingOrganizationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.networkList.Count - 1 do
      ComposeReference(this, 'OrganizationAffiliation', 'network', value.networkList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCodeableConcept(this, 'OrganizationAffiliation', 'code', value.codeList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.specialtyList.Count - 1 do
      ComposeCodeableConcept(this, 'OrganizationAffiliation', 'specialty', value.specialtyList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.locationList.Count - 1 do
      ComposeReference(this, 'OrganizationAffiliation', 'location', value.locationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.healthcareServiceList.Count - 1 do
      ComposeReference(this, 'OrganizationAffiliation', 'healthcareService', value.healthcareServiceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeExtendedContactDetail(this, 'OrganizationAffiliation', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endpointList.Count - 1 do
      ComposeReference(this, 'OrganizationAffiliation', 'endpoint', value.endpointList[i], false, i);
end;

{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PACKAGEDPRODUCTDEFINITION}
function TFHIRTurtleParser.ParsePackagedProductDefinitionLegalStatusOfSupply(obj : TTurtleComplex) : TFhirPackagedProductDefinitionLegalStatusOfSupply;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPackagedProductDefinitionLegalStatusOfSupply.create;
  try
    ParsePackagedProductDefinitionLegalStatusOfSupplyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePackagedProductDefinitionLegalStatusOfSupplyProperties(obj : TTurtleComplex; value : TFhirPackagedProductDefinitionLegalStatusOfSupply);
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PackagedProductDefinition.legalStatusOfSupply.code'));
    value.jurisdiction := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PackagedProductDefinition.legalStatusOfSupply.jurisdiction'));
end;

procedure TFHIRTurtleComposer.ComposePackagedProductDefinitionLegalStatusOfSupply(parent :  TTurtleComplex; parentType, name : String; value : TFhirPackagedProductDefinitionLegalStatusOfSupply; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PackagedProductDefinitionLegalStatusOfSupply');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'PackagedProductDefinition.legalStatusOfSupply', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'PackagedProductDefinition.legalStatusOfSupply', 'jurisdiction', value.jurisdictionElement, false, -1);
end;

function TFHIRTurtleParser.ParsePackagedProductDefinitionPackaging(obj : TTurtleComplex) : TFhirPackagedProductDefinitionPackaging;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPackagedProductDefinitionPackaging.create;
  try
    ParsePackagedProductDefinitionPackagingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePackagedProductDefinitionPackagingProperties(obj : TTurtleComplex; value : TFhirPackagedProductDefinitionPackaging);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/PackagedProductDefinition.packaging.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PackagedProductDefinition.packaging.type'));
    value.quantityElement := ParseInteger(obj.complex('http://hl7.org/fhir/PackagedProductDefinition.packaging.quantity'));
    for item in obj.complexes('http://hl7.org/fhir/PackagedProductDefinition.packaging.material') do
      value.materialList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/PackagedProductDefinition.packaging.alternateMaterial') do
      value.alternateMaterialList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/PackagedProductDefinition.packaging.shelfLifeStorage') do
      value.shelfLifeStorageList.Add(parseProductShelfLife(item));
    for item in obj.complexes('http://hl7.org/fhir/PackagedProductDefinition.packaging.manufacturer') do
      value.manufacturerList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/PackagedProductDefinition.packaging.property') do
      value.property_List.Add(parsePackagedProductDefinitionPackagingProperty(item));
    for item in obj.complexes('http://hl7.org/fhir/PackagedProductDefinition.packaging.containedItem') do
      value.containedItemList.Add(parsePackagedProductDefinitionPackagingContainedItem(item));
    for item in obj.complexes('http://hl7.org/fhir/PackagedProductDefinition.packaging.packaging') do
      value.packagingList.Add(parsePackagedProductDefinitionPackaging(item));
end;

procedure TFHIRTurtleComposer.ComposePackagedProductDefinitionPackaging(parent :  TTurtleComplex; parentType, name : String; value : TFhirPackagedProductDefinitionPackaging; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PackagedProductDefinitionPackaging');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'PackagedProductDefinition.packaging', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'PackagedProductDefinition.packaging', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'PackagedProductDefinition.packaging', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.materialList.Count - 1 do
      ComposeCodeableConcept(this, 'PackagedProductDefinition.packaging', 'material', value.materialList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.alternateMaterialList.Count - 1 do
      ComposeCodeableConcept(this, 'PackagedProductDefinition.packaging', 'alternateMaterial', value.alternateMaterialList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.shelfLifeStorageList.Count - 1 do
      ComposeProductShelfLife(this, 'PackagedProductDefinition.packaging', 'shelfLifeStorage', value.shelfLifeStorageList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.manufacturerList.Count - 1 do
      ComposeReference(this, 'PackagedProductDefinition.packaging', 'manufacturer', value.manufacturerList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposePackagedProductDefinitionPackagingProperty(this, 'PackagedProductDefinition.packaging', 'property', value.property_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.containedItemList.Count - 1 do
      ComposePackagedProductDefinitionPackagingContainedItem(this, 'PackagedProductDefinition.packaging', 'containedItem', value.containedItemList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.packagingList.Count - 1 do
      ComposePackagedProductDefinitionPackaging(this, 'PackagedProductDefinition.packaging', 'packaging', value.packagingList[i], false, i);
end;

function TFHIRTurtleParser.ParsePackagedProductDefinitionPackagingProperty(obj : TTurtleComplex) : TFhirPackagedProductDefinitionPackagingProperty;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPackagedProductDefinitionPackagingProperty.create;
  try
    ParsePackagedProductDefinitionPackagingPropertyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePackagedProductDefinitionPackagingPropertyProperties(obj : TTurtleComplex; value : TFhirPackagedProductDefinitionPackagingProperty);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PackagedProductDefinition.packaging.property.type'));
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueAttachment', item) then
      value.value := parseAttachment(item);
    if obj.has('valueDate', item) then
      value.value := parseDate(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
end;

procedure TFHIRTurtleComposer.ComposePackagedProductDefinitionPackagingProperty(parent :  TTurtleComplex; parentType, name : String; value : TFhirPackagedProductDefinitionPackagingProperty; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PackagedProductDefinitionPackagingProperty');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'PackagedProductDefinition.packaging.property', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'PackagedProductDefinition.packaging.property', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'PackagedProductDefinition.packaging.property', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'PackagedProductDefinition.packaging.property', 'valueAttachment', TFhirAttachment(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirDate) {6} then
    ComposeDate(this, 'PackagedProductDefinition.packaging.property', 'valueDate', TFhirDate(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'PackagedProductDefinition.packaging.property', 'valueBoolean', TFhirBoolean(value.value), false, -1);
end;

function TFHIRTurtleParser.ParsePackagedProductDefinitionPackagingContainedItem(obj : TTurtleComplex) : TFhirPackagedProductDefinitionPackagingContainedItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPackagedProductDefinitionPackagingContainedItem.create;
  try
    ParsePackagedProductDefinitionPackagingContainedItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePackagedProductDefinitionPackagingContainedItemProperties(obj : TTurtleComplex; value : TFhirPackagedProductDefinitionPackagingContainedItem);
begin
    ParseBackboneElementProperties(obj, value);
    value.item := ParseCodeableReference(obj.complex('http://hl7.org/fhir/PackagedProductDefinition.packaging.containedItem.item'));
    value.amount := ParseQuantity(obj.complex('http://hl7.org/fhir/PackagedProductDefinition.packaging.containedItem.amount'));
end;

procedure TFHIRTurtleComposer.ComposePackagedProductDefinitionPackagingContainedItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirPackagedProductDefinitionPackagingContainedItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PackagedProductDefinitionPackagingContainedItem');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableReference(this, 'PackagedProductDefinition.packaging.containedItem', 'item', value.itemElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'PackagedProductDefinition.packaging.containedItem', 'amount', value.amountElement, false, -1);
end;

function TFHIRTurtleParser.ParsePackagedProductDefinition(obj : TTurtleComplex) : TFhirPackagedProductDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPackagedProductDefinition.create;
  try
    ParsePackagedProductDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePackagedProductDefinitionProperties(obj : TTurtleComplex; value : TFhirPackagedProductDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/PackagedProductDefinition.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/PackagedProductDefinition.name'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PackagedProductDefinition.type'));
    for item in obj.complexes('http://hl7.org/fhir/PackagedProductDefinition.packageFor') do
      value.packageForList.Add(parseReference(item));
    value.status := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PackagedProductDefinition.status'));
    value.statusDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/PackagedProductDefinition.statusDate'));
    for item in obj.complexes('http://hl7.org/fhir/PackagedProductDefinition.containedItemQuantity') do
      value.containedItemQuantityList.Add(parseQuantity(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/PackagedProductDefinition.description'));
    for item in obj.complexes('http://hl7.org/fhir/PackagedProductDefinition.legalStatusOfSupply') do
      value.legalStatusOfSupplyList.Add(parsePackagedProductDefinitionLegalStatusOfSupply(item));
    for item in obj.complexes('http://hl7.org/fhir/PackagedProductDefinition.marketingStatus') do
      value.marketingStatusList.Add(parseMarketingStatus(item));
    for item in obj.complexes('http://hl7.org/fhir/PackagedProductDefinition.characteristic') do
      value.characteristicList.Add(parseCodeableConcept(item));
    value.copackagedIndicatorElement := ParseBoolean(obj.complex('http://hl7.org/fhir/PackagedProductDefinition.copackagedIndicator'));
    for item in obj.complexes('http://hl7.org/fhir/PackagedProductDefinition.manufacturer') do
      value.manufacturerList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/PackagedProductDefinition.attachedDocument') do
      value.attachedDocumentList.Add(parseReference(item));
    value.packaging := ParsePackagedProductDefinitionPackaging(obj.complex('http://hl7.org/fhir/PackagedProductDefinition.packaging'));
end;

procedure TFHIRTurtleComposer.ComposePackagedProductDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirPackagedProductDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PackagedProductDefinition');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'PackagedProductDefinition', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'PackagedProductDefinition', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'PackagedProductDefinition', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.packageForList.Count - 1 do
      ComposeReference(this, 'PackagedProductDefinition', 'packageFor', value.packageForList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'PackagedProductDefinition', 'status', value.statusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'PackagedProductDefinition', 'statusDate', value.statusDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.containedItemQuantityList.Count - 1 do
      ComposeQuantity(this, 'PackagedProductDefinition', 'containedItemQuantity', value.containedItemQuantityList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'PackagedProductDefinition', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.legalStatusOfSupplyList.Count - 1 do
      ComposePackagedProductDefinitionLegalStatusOfSupply(this, 'PackagedProductDefinition', 'legalStatusOfSupply', value.legalStatusOfSupplyList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.marketingStatusList.Count - 1 do
      ComposeMarketingStatus(this, 'PackagedProductDefinition', 'marketingStatus', value.marketingStatusList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.characteristicList.Count - 1 do
      ComposeCodeableConcept(this, 'PackagedProductDefinition', 'characteristic', value.characteristicList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'PackagedProductDefinition', 'copackagedIndicator', value.copackagedIndicatorElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.manufacturerList.Count - 1 do
      ComposeReference(this, 'PackagedProductDefinition', 'manufacturer', value.manufacturerList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.attachedDocumentList.Count - 1 do
      ComposeReference(this, 'PackagedProductDefinition', 'attachedDocument', value.attachedDocumentList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePackagedProductDefinitionPackaging(this, 'PackagedProductDefinition', 'packaging', value.packagingElement, false, -1);
end;

{$ENDIF FHIR_PACKAGEDPRODUCTDEFINITION}
{$IFDEF FHIR_PARAMETERS}
function TFHIRTurtleParser.ParseParametersParameter(obj : TTurtleComplex) : TFhirParametersParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirParametersParameter.create;
  try
    ParseParametersParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseParametersParameterProperties(obj : TTurtleComplex; value : TFhirParametersParameter);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Parameters.parameter.name'));
    if obj.has('valueCanonical', item) then
      value.value := parseCanonical(item);
    if obj.has('valueCode', item) then
      value.value := parseCode(item);
    if obj.has('valueId', item) then
      value.value := parseId(item);
    if obj.has('valueMarkdown', item) then
      value.value := parseMarkdown(item);
    if obj.has('valueOid', item) then
      value.value := parseOid(item);
    if obj.has('valuePositiveInt', item) then
      value.value := parsePositiveInt(item);
    if obj.has('valueUnsignedInt', item) then
      value.value := parseUnsignedInt(item);
    if obj.has('valueUrl', item) then
      value.value := parseUrl(item);
    if obj.has('valueUuid', item) then
      value.value := parseUuid(item);
    if obj.has('valueAddress', item) then
      value.value := parseAddress(item);
    if obj.has('valueAge', item) then
      value.value := parseAge(item);
    if obj.has('valueAnnotation', item) then
      value.value := parseAnnotation(item);
    if obj.has('valueAttachment', item) then
      value.value := parseAttachment(item);
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueCodeableReference', item) then
      value.value := parseCodeableReference(item);
    if obj.has('valueCoding', item) then
      value.value := parseCoding(item);
    if obj.has('valueContactPoint', item) then
      value.value := parseContactPoint(item);
    if obj.has('valueCount', item) then
      value.value := parseCount(item);
    if obj.has('valueDistance', item) then
      value.value := parseDistance(item);
    if obj.has('valueDuration', item) then
      value.value := parseDuration(item);
    if obj.has('valueHumanName', item) then
      value.value := parseHumanName(item);
    if obj.has('valueIdentifier', item) then
      value.value := parseIdentifier(item);
    if obj.has('valueMoney', item) then
      value.value := parseMoney(item);
    if obj.has('valuePeriod', item) then
      value.value := parsePeriod(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueRange', item) then
      value.value := parseRange(item);
    if obj.has('valueRatio', item) then
      value.value := parseRatio(item);
    if obj.has('valueRatioRange', item) then
      value.value := parseRatioRange(item);
    if obj.has('valueReference', item) then
      value.value := parseReference(item);
    if obj.has('valueSampledData', item) then
      value.value := parseSampledData(item);
    if obj.has('valueSignature', item) then
      value.value := parseSignature(item);
    if obj.has('valueTiming', item) then
      value.value := parseTiming(item);
    if obj.has('valueContactDetail', item) then
      value.value := parseContactDetail(item);
    if obj.has('valueDataRequirement', item) then
      value.value := parseDataRequirement(item);
    if obj.has('valueExpression', item) then
      value.value := parseExpression(item);
    if obj.has('valueParameterDefinition', item) then
      value.value := parseParameterDefinition(item);
    if obj.has('valueRelatedArtifact', item) then
      value.value := parseRelatedArtifact(item);
    if obj.has('valueTriggerDefinition', item) then
      value.value := parseTriggerDefinition(item);
    if obj.has('valueUsageContext', item) then
      value.value := parseUsageContext(item);
    if obj.has('valueAvailability', item) then
      value.value := parseAvailability(item);
    if obj.has('valueExtendedContactDetail', item) then
      value.value := parseExtendedContactDetail(item);
    if obj.has('valueDosage', item) then
      value.value := parseDosage(item);
    if obj.has('valueMeta', item) then
      value.value := parseMeta(item);
    if obj.has('valueBase64Binary', item) then
      value.value := parseBase64Binary(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    if obj.has('valueDate', item) then
      value.value := parseDate(item);
    if obj.has('valueDateTime', item) then
      value.value := parseDateTime(item);
    if obj.has('valueDecimal', item) then
      value.value := parseDecimal(item);
    if obj.has('valueInstant', item) then
      value.value := parseInstant(item);
    if obj.has('valueInteger', item) then
      value.value := parseInteger(item);
    if obj.has('valueInteger64', item) then
      value.value := parseInteger64(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    if obj.has('valueTime', item) then
      value.value := parseTime(item);
    if obj.has('valueUri', item) then
      value.value := parseUri(item);
    value.resource := ParseInnerResource(obj.predicate('http://hl7.org/fhir/Parameters.parameter.resource'));
    for item in obj.complexes('http://hl7.org/fhir/Parameters.parameter.part') do
      value.partList.Add(parseParametersParameter(item));
end;

procedure TFHIRTurtleComposer.ComposeParametersParameter(parent :  TTurtleComplex; parentType, name : String; value : TFhirParametersParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ParametersParameter');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'Parameters.parameter', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirCanonical) {6} then
    ComposeCanonical(this, 'Parameters.parameter', 'valueCanonical', TFhirCanonical(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirCode) {6} then
    ComposeCode(this, 'Parameters.parameter', 'valueCode', TFhirCode(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirId) {6} then
    ComposeId(this, 'Parameters.parameter', 'valueId', TFhirId(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'Parameters.parameter', 'valueMarkdown', TFhirMarkdown(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirOid) {6} then
    ComposeOid(this, 'Parameters.parameter', 'valueOid', TFhirOid(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'Parameters.parameter', 'valuePositiveInt', TFhirPositiveInt(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'Parameters.parameter', 'valueUnsignedInt', TFhirUnsignedInt(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirUrl) {6} then
    ComposeUrl(this, 'Parameters.parameter', 'valueUrl', TFhirUrl(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirUuid) {6} then
    ComposeUuid(this, 'Parameters.parameter', 'valueUuid', TFhirUuid(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirAddress) {6} then
    ComposeAddress(this, 'Parameters.parameter', 'valueAddress', TFhirAddress(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirAge) {6} then
    ComposeAge(this, 'Parameters.parameter', 'valueAge', TFhirAge(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'Parameters.parameter', 'valueAnnotation', TFhirAnnotation(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Parameters.parameter', 'valueAttachment', TFhirAttachment(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Parameters.parameter', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirCodeableReference) {6} then
    ComposeCodeableReference(this, 'Parameters.parameter', 'valueCodeableReference', TFhirCodeableReference(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirCoding) {6} then
    ComposeCoding(this, 'Parameters.parameter', 'valueCoding', TFhirCoding(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'Parameters.parameter', 'valueContactPoint', TFhirContactPoint(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirCount) {6} then
    ComposeCount(this, 'Parameters.parameter', 'valueCount', TFhirCount(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirDistance) {6} then
    ComposeDistance(this, 'Parameters.parameter', 'valueDistance', TFhirDistance(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirDuration) {6} then
    ComposeDuration(this, 'Parameters.parameter', 'valueDuration', TFhirDuration(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirHumanName) {6} then
    ComposeHumanName(this, 'Parameters.parameter', 'valueHumanName', TFhirHumanName(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'Parameters.parameter', 'valueIdentifier', TFhirIdentifier(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirMoney) {6} then
    ComposeMoney(this, 'Parameters.parameter', 'valueMoney', TFhirMoney(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'Parameters.parameter', 'valuePeriod', TFhirPeriod(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Parameters.parameter', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirRange) {6} then
    ComposeRange(this, 'Parameters.parameter', 'valueRange', TFhirRange(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirRatio) {6} then
    ComposeRatio(this, 'Parameters.parameter', 'valueRatio', TFhirRatio(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirRatioRange) {6} then
    ComposeRatioRange(this, 'Parameters.parameter', 'valueRatioRange', TFhirRatioRange(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirReference) {6} then
    ComposeReference(this, 'Parameters.parameter', 'valueReference', TFhirReference(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'Parameters.parameter', 'valueSampledData', TFhirSampledData(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirSignature) {6} then
    ComposeSignature(this, 'Parameters.parameter', 'valueSignature', TFhirSignature(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirTiming) {6} then
    ComposeTiming(this, 'Parameters.parameter', 'valueTiming', TFhirTiming(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirContactDetail) {6} then
    ComposeContactDetail(this, 'Parameters.parameter', 'valueContactDetail', TFhirContactDetail(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirDataRequirement) {6} then
    ComposeDataRequirement(this, 'Parameters.parameter', 'valueDataRequirement', TFhirDataRequirement(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirExpression) {6} then
    ComposeExpression(this, 'Parameters.parameter', 'valueExpression', TFhirExpression(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(this, 'Parameters.parameter', 'valueParameterDefinition', TFhirParameterDefinition(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(this, 'Parameters.parameter', 'valueRelatedArtifact', TFhirRelatedArtifact(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(this, 'Parameters.parameter', 'valueTriggerDefinition', TFhirTriggerDefinition(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirUsageContext) {6} then
    ComposeUsageContext(this, 'Parameters.parameter', 'valueUsageContext', TFhirUsageContext(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirAvailability) {6} then
    ComposeAvailability(this, 'Parameters.parameter', 'valueAvailability', TFhirAvailability(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirExtendedContactDetail) {6} then
    ComposeExtendedContactDetail(this, 'Parameters.parameter', 'valueExtendedContactDetail', TFhirExtendedContactDetail(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirDosage) {6} then
    ComposeDosage(this, 'Parameters.parameter', 'valueDosage', TFhirDosage(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirMeta) {6} then
    ComposeMeta(this, 'Parameters.parameter', 'valueMeta', TFhirMeta(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'Parameters.parameter', 'valueBase64Binary', TFhirBase64Binary(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Parameters.parameter', 'valueBoolean', TFhirBoolean(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirDate) {6} then
    ComposeDate(this, 'Parameters.parameter', 'valueDate', TFhirDate(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Parameters.parameter', 'valueDateTime', TFhirDateTime(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'Parameters.parameter', 'valueDecimal', TFhirDecimal(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirInstant) {6} then
    ComposeInstant(this, 'Parameters.parameter', 'valueInstant', TFhirInstant(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Parameters.parameter', 'valueInteger', TFhirInteger(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirInteger64) {6} then
    ComposeInteger64(this, 'Parameters.parameter', 'valueInteger64', TFhirInteger64(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirString) {6} then
    ComposeString(this, 'Parameters.parameter', 'valueString', TFhirString(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirTime) {6} then
    ComposeTime(this, 'Parameters.parameter', 'valueTime', TFhirTime(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (value.value is TFhirUri) {6} then
    ComposeUri(this, 'Parameters.parameter', 'valueUri', TFhirUri(value.value), false, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(this, 'Parameters.parameter', 'resource', value.resourceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to value.partList.Count - 1 do
      ComposeParametersParameter(this, 'Parameters.parameter', 'part', value.partList[i], false, i);
end;

function TFHIRTurtleParser.ParseParameters(obj : TTurtleComplex) : TFhirParameters;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirParameters.create;
  try
    ParseParametersProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseParametersProperties(obj : TTurtleComplex; value : TFhirParameters);
var
  item : TTurtleComplex;
begin
    ParseResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Parameters.parameter') do
      value.parameterList.Add(parseParametersParameter(item));
end;

procedure TFHIRTurtleComposer.ComposeParameters(parent :  TTurtleComplex; parentType, name : String; value : TFhirParameters; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Parameters');
  end;
  composeResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to value.parameterList.Count - 1 do
      ComposeParametersParameter(this, 'Parameters', 'parameter', value.parameterList[i], false, i);
end;

{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_PATIENT}
function TFHIRTurtleParser.ParsePatientContact(obj : TTurtleComplex) : TFhirPatientContact;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPatientContact.create;
  try
    ParsePatientContactProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePatientContactProperties(obj : TTurtleComplex; value : TFhirPatientContact);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Patient.contact.relationship') do
      value.relationshipList.Add(parseCodeableConcept(item));
    value.name := ParseHumanName(obj.complex('http://hl7.org/fhir/Patient.contact.name'));
    for item in obj.complexes('http://hl7.org/fhir/Patient.contact.telecom') do
      value.telecomList.Add(parseContactPoint(item));
    value.address := ParseAddress(obj.complex('http://hl7.org/fhir/Patient.contact.address'));
    value.genderElement := ParseEnum(obj.complex('http://hl7.org/fhir/Patient.contact.gender'), CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    value.organization := ParseReference(obj.complex('http://hl7.org/fhir/Patient.contact.organization'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Patient.contact.period'));
end;

procedure TFHIRTurtleComposer.ComposePatientContact(parent :  TTurtleComplex; parentType, name : String; value : TFhirPatientContact; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PatientContact');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relationshipList.Count - 1 do
      ComposeCodeableConcept(this, 'Patient.contact', 'relationship', value.relationshipList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeHumanName(this, 'Patient.contact', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Patient.contact', 'telecom', value.telecomList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(this, 'Patient.contact', 'address', value.addressElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Patient.contact', 'gender', value.genderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Patient.contact', 'organization', value.organizationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Patient.contact', 'period', value.periodElement, false, -1);
end;

function TFHIRTurtleParser.ParsePatientCommunication(obj : TTurtleComplex) : TFhirPatientCommunication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPatientCommunication.create;
  try
    ParsePatientCommunicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePatientCommunicationProperties(obj : TTurtleComplex; value : TFhirPatientCommunication);
begin
    ParseBackboneElementProperties(obj, value);
    value.language := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Patient.communication.language'));
    value.preferredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Patient.communication.preferred'));
end;

procedure TFHIRTurtleComposer.ComposePatientCommunication(parent :  TTurtleComplex; parentType, name : String; value : TFhirPatientCommunication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PatientCommunication');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'Patient.communication', 'language', value.languageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Patient.communication', 'preferred', value.preferredElement, false, -1);
end;

function TFHIRTurtleParser.ParsePatientLink(obj : TTurtleComplex) : TFhirPatientLink;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPatientLink.create;
  try
    ParsePatientLinkProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePatientLinkProperties(obj : TTurtleComplex; value : TFhirPatientLink);
begin
    ParseBackboneElementProperties(obj, value);
    value.other := ParseReference(obj.complex('http://hl7.org/fhir/Patient.link.other'));
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Patient.link.type'), CODES_TFhirLinkTypeEnum, SYSTEMS_TFhirLinkTypeEnum);
end;

procedure TFHIRTurtleComposer.ComposePatientLink(parent :  TTurtleComplex; parentType, name : String; value : TFhirPatientLink; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PatientLink');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeReference(this, 'Patient.link', 'other', value.otherElement, false, -1);
  ComposeEnum(this, 'Patient.link', 'type', value.type_Element, CODES_TFhirLinkTypeEnum, SYSTEMS_TFhirLinkTypeEnum, false, -1);
end;

function TFHIRTurtleParser.ParsePatient(obj : TTurtleComplex) : TFhirPatient;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPatient.create;
  try
    ParsePatientProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePatientProperties(obj : TTurtleComplex; value : TFhirPatient);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Patient.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Patient.active'));
    for item in obj.complexes('http://hl7.org/fhir/Patient.name') do
      value.nameList.Add(parseHumanName(item));
    for item in obj.complexes('http://hl7.org/fhir/Patient.telecom') do
      value.telecomList.Add(parseContactPoint(item));
    value.genderElement := ParseEnum(obj.complex('http://hl7.org/fhir/Patient.gender'), CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    value.birthDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Patient.birthDate'));
    if obj.has('deceasedBoolean', item) then
      value.deceased := parseBoolean(item);
    if obj.has('deceasedDateTime', item) then
      value.deceased := parseDateTime(item);
    for item in obj.complexes('http://hl7.org/fhir/Patient.address') do
      value.addressList.Add(parseAddress(item));
    value.maritalStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Patient.maritalStatus'));
    if obj.has('multipleBirthBoolean', item) then
      value.multipleBirth := parseBoolean(item);
    if obj.has('multipleBirthInteger', item) then
      value.multipleBirth := parseInteger(item);
    for item in obj.complexes('http://hl7.org/fhir/Patient.photo') do
      value.photoList.Add(parseAttachment(item));
    for item in obj.complexes('http://hl7.org/fhir/Patient.contact') do
      value.contactList.Add(parsePatientContact(item));
    for item in obj.complexes('http://hl7.org/fhir/Patient.communication') do
      value.communicationList.Add(parsePatientCommunication(item));
    for item in obj.complexes('http://hl7.org/fhir/Patient.generalPractitioner') do
      value.generalPractitionerList.Add(parseReference(item));
    value.managingOrganization := ParseReference(obj.complex('http://hl7.org/fhir/Patient.managingOrganization'));
    for item in obj.complexes('http://hl7.org/fhir/Patient.link') do
      value.link_List.Add(parsePatientLink(item));
end;

procedure TFHIRTurtleComposer.ComposePatient(parent :  TTurtleComplex; parentType, name : String; value : TFhirPatient; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Patient');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Patient', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Patient', 'active', value.activeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.nameList.Count - 1 do
      ComposeHumanName(this, 'Patient', 'name', value.nameList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Patient', 'telecom', value.telecomList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Patient', 'gender', value.genderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'Patient', 'birthDate', value.birthDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.deceased is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Patient', 'deceasedBoolean', TFhirBoolean(value.deceased), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.deceased is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Patient', 'deceasedDateTime', TFhirDateTime(value.deceased), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.addressList.Count - 1 do
      ComposeAddress(this, 'Patient', 'address', value.addressList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Patient', 'maritalStatus', value.maritalStatusElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.multipleBirth is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Patient', 'multipleBirthBoolean', TFhirBoolean(value.multipleBirth), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.multipleBirth is TFhirInteger) {6} then
    ComposeInteger(this, 'Patient', 'multipleBirthInteger', TFhirInteger(value.multipleBirth), false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.photoList.Count - 1 do
      ComposeAttachment(this, 'Patient', 'photo', value.photoList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposePatientContact(this, 'Patient', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.communicationList.Count - 1 do
      ComposePatientCommunication(this, 'Patient', 'communication', value.communicationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.generalPractitionerList.Count - 1 do
      ComposeReference(this, 'Patient', 'generalPractitioner', value.generalPractitionerList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Patient', 'managingOrganization', value.managingOrganizationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.link_List.Count - 1 do
      ComposePatientLink(this, 'Patient', 'link', value.link_List[i], false, i);
end;

{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
function TFHIRTurtleParser.ParsePaymentNotice(obj : TTurtleComplex) : TFhirPaymentNotice;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPaymentNotice.create;
  try
    ParsePaymentNoticeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePaymentNoticeProperties(obj : TTurtleComplex; value : TFhirPaymentNotice);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/PaymentNotice.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/PaymentNotice.status'), CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum);
    value.request := ParseReference(obj.complex('http://hl7.org/fhir/PaymentNotice.request'));
    value.response := ParseReference(obj.complex('http://hl7.org/fhir/PaymentNotice.response'));
    value.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/PaymentNotice.created'));
    value.provider := ParseReference(obj.complex('http://hl7.org/fhir/PaymentNotice.provider'));
    value.payment := ParseReference(obj.complex('http://hl7.org/fhir/PaymentNotice.payment'));
    value.paymentDateElement := ParseDate(obj.complex('http://hl7.org/fhir/PaymentNotice.paymentDate'));
    value.payee := ParseReference(obj.complex('http://hl7.org/fhir/PaymentNotice.payee'));
    value.recipient := ParseReference(obj.complex('http://hl7.org/fhir/PaymentNotice.recipient'));
    value.amount := ParseMoney(obj.complex('http://hl7.org/fhir/PaymentNotice.amount'));
    value.paymentStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PaymentNotice.paymentStatus'));
end;

procedure TFHIRTurtleComposer.ComposePaymentNotice(parent :  TTurtleComplex; parentType, name : String; value : TFhirPaymentNotice; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PaymentNotice');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'PaymentNotice', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'PaymentNotice', 'status', value.statusElement, CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'PaymentNotice', 'request', value.requestElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'PaymentNotice', 'response', value.responseElement, false, -1);
  ComposeDateTime(this, 'PaymentNotice', 'created', value.createdElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'PaymentNotice', 'provider', value.providerElement, false, -1);
  ComposeReference(this, 'PaymentNotice', 'payment', value.paymentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'PaymentNotice', 'paymentDate', value.paymentDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'PaymentNotice', 'payee', value.payeeElement, false, -1);
  ComposeReference(this, 'PaymentNotice', 'recipient', value.recipientElement, false, -1);
  ComposeMoney(this, 'PaymentNotice', 'amount', value.amountElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PaymentNotice', 'paymentStatus', value.paymentStatusElement, false, -1);
end;

{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
function TFHIRTurtleParser.ParsePaymentReconciliationAllocation(obj : TTurtleComplex) : TFhirPaymentReconciliationAllocation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPaymentReconciliationAllocation.create;
  try
    ParsePaymentReconciliationAllocationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePaymentReconciliationAllocationProperties(obj : TTurtleComplex; value : TFhirPaymentReconciliationAllocation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/PaymentReconciliation.allocation.identifier'));
    value.predecessor := ParseIdentifier(obj.complex('http://hl7.org/fhir/PaymentReconciliation.allocation.predecessor'));
    value.target := ParseReference(obj.complex('http://hl7.org/fhir/PaymentReconciliation.allocation.target'));
    if obj.has('targetItemIdentifier', item) then
      value.targetItem := parseIdentifier(item);
    if obj.has('targetItemPositiveInt', item) then
      value.targetItem := parsePositiveInt(item);
    if obj.has('targetItemString', item) then
      value.targetItem := parseString(item);
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/PaymentReconciliation.allocation.encounter'));
    value.account := ParseReference(obj.complex('http://hl7.org/fhir/PaymentReconciliation.allocation.account'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PaymentReconciliation.allocation.type'));
    value.submitter := ParseReference(obj.complex('http://hl7.org/fhir/PaymentReconciliation.allocation.submitter'));
    value.response := ParseReference(obj.complex('http://hl7.org/fhir/PaymentReconciliation.allocation.response'));
    value.dateElement := ParseDate(obj.complex('http://hl7.org/fhir/PaymentReconciliation.allocation.date'));
    value.responsible := ParseReference(obj.complex('http://hl7.org/fhir/PaymentReconciliation.allocation.responsible'));
    value.payee := ParseReference(obj.complex('http://hl7.org/fhir/PaymentReconciliation.allocation.payee'));
    value.amount := ParseMoney(obj.complex('http://hl7.org/fhir/PaymentReconciliation.allocation.amount'));
end;

procedure TFHIRTurtleComposer.ComposePaymentReconciliationAllocation(parent :  TTurtleComplex; parentType, name : String; value : TFhirPaymentReconciliationAllocation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PaymentReconciliationAllocation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'PaymentReconciliation.allocation', 'identifier', value.identifierElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'PaymentReconciliation.allocation', 'predecessor', value.predecessorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'PaymentReconciliation.allocation', 'target', value.targetElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.targetItem is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'PaymentReconciliation.allocation', 'targetItemIdentifier', TFhirIdentifier(value.targetItem), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.targetItem is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'PaymentReconciliation.allocation', 'targetItemPositiveInt', TFhirPositiveInt(value.targetItem), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.targetItem is TFhirString) {6} then
    ComposeString(this, 'PaymentReconciliation.allocation', 'targetItemString', TFhirString(value.targetItem), false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'PaymentReconciliation.allocation', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'PaymentReconciliation.allocation', 'account', value.accountElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PaymentReconciliation.allocation', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'PaymentReconciliation.allocation', 'submitter', value.submitterElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'PaymentReconciliation.allocation', 'response', value.responseElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'PaymentReconciliation.allocation', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'PaymentReconciliation.allocation', 'responsible', value.responsibleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'PaymentReconciliation.allocation', 'payee', value.payeeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'PaymentReconciliation.allocation', 'amount', value.amountElement, false, -1);
end;

function TFHIRTurtleParser.ParsePaymentReconciliationProcessNote(obj : TTurtleComplex) : TFhirPaymentReconciliationProcessNote;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPaymentReconciliationProcessNote.create;
  try
    ParsePaymentReconciliationProcessNoteProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePaymentReconciliationProcessNoteProperties(obj : TTurtleComplex; value : TFhirPaymentReconciliationProcessNote);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/PaymentReconciliation.processNote.type'), CODES_TFhirNoteTypeEnum, SYSTEMS_TFhirNoteTypeEnum);
    value.textElement := ParseString(obj.complex('http://hl7.org/fhir/PaymentReconciliation.processNote.text'));
end;

procedure TFHIRTurtleComposer.ComposePaymentReconciliationProcessNote(parent :  TTurtleComplex; parentType, name : String; value : TFhirPaymentReconciliationProcessNote; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PaymentReconciliationProcessNote');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'PaymentReconciliation.processNote', 'type', value.type_Element, CODES_TFhirNoteTypeEnum, SYSTEMS_TFhirNoteTypeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PaymentReconciliation.processNote', 'text', value.textElement, false, -1);
end;

function TFHIRTurtleParser.ParsePaymentReconciliation(obj : TTurtleComplex) : TFhirPaymentReconciliation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPaymentReconciliation.create;
  try
    ParsePaymentReconciliationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePaymentReconciliationProperties(obj : TTurtleComplex; value : TFhirPaymentReconciliation);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/PaymentReconciliation.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PaymentReconciliation.type'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/PaymentReconciliation.status'), CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum);
    value.kind := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PaymentReconciliation.kind'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/PaymentReconciliation.period'));
    value.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/PaymentReconciliation.created'));
    value.enterer := ParseReference(obj.complex('http://hl7.org/fhir/PaymentReconciliation.enterer'));
    value.issuerType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PaymentReconciliation.issuerType'));
    value.paymentIssuer := ParseReference(obj.complex('http://hl7.org/fhir/PaymentReconciliation.paymentIssuer'));
    value.request := ParseReference(obj.complex('http://hl7.org/fhir/PaymentReconciliation.request'));
    value.requestor := ParseReference(obj.complex('http://hl7.org/fhir/PaymentReconciliation.requestor'));
    value.outcomeElement := ParseEnum(obj.complex('http://hl7.org/fhir/PaymentReconciliation.outcome'), CODES_TFhirPaymentOutcomeEnum, SYSTEMS_TFhirPaymentOutcomeEnum);
    value.dispositionElement := ParseString(obj.complex('http://hl7.org/fhir/PaymentReconciliation.disposition'));
    value.dateElement := ParseDate(obj.complex('http://hl7.org/fhir/PaymentReconciliation.date'));
    value.location := ParseReference(obj.complex('http://hl7.org/fhir/PaymentReconciliation.location'));
    value.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PaymentReconciliation.method'));
    value.cardBrandElement := ParseString(obj.complex('http://hl7.org/fhir/PaymentReconciliation.cardBrand'));
    value.accountNumberElement := ParseString(obj.complex('http://hl7.org/fhir/PaymentReconciliation.accountNumber'));
    value.expirationDateElement := ParseDate(obj.complex('http://hl7.org/fhir/PaymentReconciliation.expirationDate'));
    value.processorElement := ParseString(obj.complex('http://hl7.org/fhir/PaymentReconciliation.processor'));
    value.referenceNumberElement := ParseString(obj.complex('http://hl7.org/fhir/PaymentReconciliation.referenceNumber'));
    value.authorizationElement := ParseString(obj.complex('http://hl7.org/fhir/PaymentReconciliation.authorization'));
    value.tenderedAmount := ParseMoney(obj.complex('http://hl7.org/fhir/PaymentReconciliation.tenderedAmount'));
    value.returnedAmount := ParseMoney(obj.complex('http://hl7.org/fhir/PaymentReconciliation.returnedAmount'));
    value.amount := ParseMoney(obj.complex('http://hl7.org/fhir/PaymentReconciliation.amount'));
    value.paymentIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/PaymentReconciliation.paymentIdentifier'));
    for item in obj.complexes('http://hl7.org/fhir/PaymentReconciliation.allocation') do
      value.allocationList.Add(parsePaymentReconciliationAllocation(item));
    value.formCode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PaymentReconciliation.formCode'));
    for item in obj.complexes('http://hl7.org/fhir/PaymentReconciliation.processNote') do
      value.processNoteList.Add(parsePaymentReconciliationProcessNote(item));
end;

procedure TFHIRTurtleComposer.ComposePaymentReconciliation(parent :  TTurtleComplex; parentType, name : String; value : TFhirPaymentReconciliation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PaymentReconciliation');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'PaymentReconciliation', 'identifier', value.identifierList[i], false, i);
  ComposeCodeableConcept(this, 'PaymentReconciliation', 'type', value.type_Element, false, -1);
  ComposeEnum(this, 'PaymentReconciliation', 'status', value.statusElement, CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PaymentReconciliation', 'kind', value.kindElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'PaymentReconciliation', 'period', value.periodElement, false, -1);
  ComposeDateTime(this, 'PaymentReconciliation', 'created', value.createdElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'PaymentReconciliation', 'enterer', value.entererElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PaymentReconciliation', 'issuerType', value.issuerTypeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'PaymentReconciliation', 'paymentIssuer', value.paymentIssuerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'PaymentReconciliation', 'request', value.requestElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'PaymentReconciliation', 'requestor', value.requestorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'PaymentReconciliation', 'outcome', value.outcomeElement, CODES_TFhirPaymentOutcomeEnum, SYSTEMS_TFhirPaymentOutcomeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PaymentReconciliation', 'disposition', value.dispositionElement, false, -1);
  ComposeDate(this, 'PaymentReconciliation', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'PaymentReconciliation', 'location', value.locationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PaymentReconciliation', 'method', value.methodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PaymentReconciliation', 'cardBrand', value.cardBrandElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PaymentReconciliation', 'accountNumber', value.accountNumberElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'PaymentReconciliation', 'expirationDate', value.expirationDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PaymentReconciliation', 'processor', value.processorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PaymentReconciliation', 'referenceNumber', value.referenceNumberElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PaymentReconciliation', 'authorization', value.authorizationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'PaymentReconciliation', 'tenderedAmount', value.tenderedAmountElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'PaymentReconciliation', 'returnedAmount', value.returnedAmountElement, false, -1);
  ComposeMoney(this, 'PaymentReconciliation', 'amount', value.amountElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'PaymentReconciliation', 'paymentIdentifier', value.paymentIdentifierElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.allocationList.Count - 1 do
      ComposePaymentReconciliationAllocation(this, 'PaymentReconciliation', 'allocation', value.allocationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PaymentReconciliation', 'formCode', value.formCodeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.processNoteList.Count - 1 do
      ComposePaymentReconciliationProcessNote(this, 'PaymentReconciliation', 'processNote', value.processNoteList[i], false, i);
end;

{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERMISSION}
function TFHIRTurtleParser.ParsePermissionJustification(obj : TTurtleComplex) : TFhirPermissionJustification;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPermissionJustification.create;
  try
    ParsePermissionJustificationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePermissionJustificationProperties(obj : TTurtleComplex; value : TFhirPermissionJustification);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Permission.justification.basis') do
      value.basisList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Permission.justification.evidence') do
      value.evidenceList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposePermissionJustification(parent :  TTurtleComplex; parentType, name : String; value : TFhirPermissionJustification; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PermissionJustification');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basisList.Count - 1 do
      ComposeCodeableConcept(this, 'Permission.justification', 'basis', value.basisList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.evidenceList.Count - 1 do
      ComposeReference(this, 'Permission.justification', 'evidence', value.evidenceList[i], false, i);
end;

function TFHIRTurtleParser.ParsePermissionRule(obj : TTurtleComplex) : TFhirPermissionRule;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPermissionRule.create;
  try
    ParsePermissionRuleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePermissionRuleProperties(obj : TTurtleComplex; value : TFhirPermissionRule);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Permission.rule.type'), CODES_TFhirConsentProvisionTypeEnum, SYSTEMS_TFhirConsentProvisionTypeEnum);
    for item in obj.complexes('http://hl7.org/fhir/Permission.rule.data') do
      value.dataList.Add(parsePermissionRuleData(item));
    for item in obj.complexes('http://hl7.org/fhir/Permission.rule.activity') do
      value.activityList.Add(parsePermissionRuleActivity(item));
    for item in obj.complexes('http://hl7.org/fhir/Permission.rule.limit') do
      value.limitList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposePermissionRule(parent :  TTurtleComplex; parentType, name : String; value : TFhirPermissionRule; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PermissionRule');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Permission.rule', 'type', value.type_Element, CODES_TFhirConsentProvisionTypeEnum, SYSTEMS_TFhirConsentProvisionTypeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.dataList.Count - 1 do
      ComposePermissionRuleData(this, 'Permission.rule', 'data', value.dataList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.activityList.Count - 1 do
      ComposePermissionRuleActivity(this, 'Permission.rule', 'activity', value.activityList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.limitList.Count - 1 do
      ComposeCodeableConcept(this, 'Permission.rule', 'limit', value.limitList[i], false, i);
end;

function TFHIRTurtleParser.ParsePermissionRuleData(obj : TTurtleComplex) : TFhirPermissionRuleData;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPermissionRuleData.create;
  try
    ParsePermissionRuleDataProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePermissionRuleDataProperties(obj : TTurtleComplex; value : TFhirPermissionRuleData);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Permission.rule.data.resource') do
      value.resourceList.Add(parsePermissionRuleDataResource(item));
    for item in obj.complexes('http://hl7.org/fhir/Permission.rule.data.security') do
      value.securityList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Permission.rule.data.period') do
      value.periodList.Add(parsePeriod(item));
    value.expression := ParseExpression(obj.complex('http://hl7.org/fhir/Permission.rule.data.expression'));
end;

procedure TFHIRTurtleComposer.ComposePermissionRuleData(parent :  TTurtleComplex; parentType, name : String; value : TFhirPermissionRuleData; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PermissionRuleData');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.resourceList.Count - 1 do
      ComposePermissionRuleDataResource(this, 'Permission.rule.data', 'resource', value.resourceList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.securityList.Count - 1 do
      ComposeCoding(this, 'Permission.rule.data', 'security', value.securityList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.periodList.Count - 1 do
      ComposePeriod(this, 'Permission.rule.data', 'period', value.periodList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeExpression(this, 'Permission.rule.data', 'expression', value.expressionElement, false, -1);
end;

function TFHIRTurtleParser.ParsePermissionRuleDataResource(obj : TTurtleComplex) : TFhirPermissionRuleDataResource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPermissionRuleDataResource.create;
  try
    ParsePermissionRuleDataResourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePermissionRuleDataResourceProperties(obj : TTurtleComplex; value : TFhirPermissionRuleDataResource);
begin
    ParseBackboneElementProperties(obj, value);
    value.meaningElement := ParseEnum(obj.complex('http://hl7.org/fhir/Permission.rule.data.resource.meaning'), CODES_TFhirConsentDataMeaningEnum, SYSTEMS_TFhirConsentDataMeaningEnum);
    value.reference := ParseReference(obj.complex('http://hl7.org/fhir/Permission.rule.data.resource.reference'));
end;

procedure TFHIRTurtleComposer.ComposePermissionRuleDataResource(parent :  TTurtleComplex; parentType, name : String; value : TFhirPermissionRuleDataResource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PermissionRuleDataResource');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'Permission.rule.data.resource', 'meaning', value.meaningElement, CODES_TFhirConsentDataMeaningEnum, SYSTEMS_TFhirConsentDataMeaningEnum, false, -1);
  ComposeReference(this, 'Permission.rule.data.resource', 'reference', value.referenceElement, false, -1);
end;

function TFHIRTurtleParser.ParsePermissionRuleActivity(obj : TTurtleComplex) : TFhirPermissionRuleActivity;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPermissionRuleActivity.create;
  try
    ParsePermissionRuleActivityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePermissionRuleActivityProperties(obj : TTurtleComplex; value : TFhirPermissionRuleActivity);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Permission.rule.activity.actor') do
      value.actorList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Permission.rule.activity.action') do
      value.actionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Permission.rule.activity.purpose') do
      value.purposeList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposePermissionRuleActivity(parent :  TTurtleComplex; parentType, name : String; value : TFhirPermissionRuleActivity; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PermissionRuleActivity');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.actorList.Count - 1 do
      ComposeReference(this, 'Permission.rule.activity', 'actor', value.actorList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.actionList.Count - 1 do
      ComposeCodeableConcept(this, 'Permission.rule.activity', 'action', value.actionList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.purposeList.Count - 1 do
      ComposeCodeableConcept(this, 'Permission.rule.activity', 'purpose', value.purposeList[i], false, i);
end;

function TFHIRTurtleParser.ParsePermission(obj : TTurtleComplex) : TFhirPermission;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPermission.create;
  try
    ParsePermissionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePermissionProperties(obj : TTurtleComplex; value : TFhirPermission);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Permission.status'), CODES_TFhirPermissionStatusEnum, SYSTEMS_TFhirPermissionStatusEnum);
    value.asserter := ParseReference(obj.complex('http://hl7.org/fhir/Permission.asserter'));
    for item in obj.complexes('http://hl7.org/fhir/Permission.date') do
      value.dateList.Add(parseDateTime(item));
    value.validity := ParsePeriod(obj.complex('http://hl7.org/fhir/Permission.validity'));
    value.justification := ParsePermissionJustification(obj.complex('http://hl7.org/fhir/Permission.justification'));
    value.combiningElement := ParseEnum(obj.complex('http://hl7.org/fhir/Permission.combining'), CODES_TFhirPermissionRuleCombiningEnum, SYSTEMS_TFhirPermissionRuleCombiningEnum);
    for item in obj.complexes('http://hl7.org/fhir/Permission.rule') do
      value.ruleList.Add(parsePermissionRule(item));
end;

procedure TFHIRTurtleComposer.ComposePermission(parent :  TTurtleComplex; parentType, name : String; value : TFhirPermission; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Permission');
  end;
  composeDomainResource(this, '', name, value, false, index);
  ComposeEnum(this, 'Permission', 'status', value.statusElement, CODES_TFhirPermissionStatusEnum, SYSTEMS_TFhirPermissionStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Permission', 'asserter', value.asserterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.dateList.Count - 1 do
      ComposeDateTime(this, 'Permission', 'date', value.dateList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Permission', 'validity', value.validityElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePermissionJustification(this, 'Permission', 'justification', value.justificationElement, false, -1);
  ComposeEnum(this, 'Permission', 'combining', value.combiningElement, CODES_TFhirPermissionRuleCombiningEnum, SYSTEMS_TFhirPermissionRuleCombiningEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.ruleList.Count - 1 do
      ComposePermissionRule(this, 'Permission', 'rule', value.ruleList[i], false, i);
end;

{$ENDIF FHIR_PERMISSION}
{$IFDEF FHIR_PERSON}
function TFHIRTurtleParser.ParsePersonCommunication(obj : TTurtleComplex) : TFhirPersonCommunication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPersonCommunication.create;
  try
    ParsePersonCommunicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePersonCommunicationProperties(obj : TTurtleComplex; value : TFhirPersonCommunication);
begin
    ParseBackboneElementProperties(obj, value);
    value.language := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Person.communication.language'));
    value.preferredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Person.communication.preferred'));
end;

procedure TFHIRTurtleComposer.ComposePersonCommunication(parent :  TTurtleComplex; parentType, name : String; value : TFhirPersonCommunication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PersonCommunication');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'Person.communication', 'language', value.languageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Person.communication', 'preferred', value.preferredElement, false, -1);
end;

function TFHIRTurtleParser.ParsePersonLink(obj : TTurtleComplex) : TFhirPersonLink;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPersonLink.create;
  try
    ParsePersonLinkProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePersonLinkProperties(obj : TTurtleComplex; value : TFhirPersonLink);
begin
    ParseBackboneElementProperties(obj, value);
    value.target := ParseReference(obj.complex('http://hl7.org/fhir/Person.link.target'));
    value.assuranceElement := ParseEnum(obj.complex('http://hl7.org/fhir/Person.link.assurance'), CODES_TFhirIdentityAssuranceLevelEnum, SYSTEMS_TFhirIdentityAssuranceLevelEnum);
end;

procedure TFHIRTurtleComposer.ComposePersonLink(parent :  TTurtleComplex; parentType, name : String; value : TFhirPersonLink; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PersonLink');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeReference(this, 'Person.link', 'target', value.targetElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Person.link', 'assurance', value.assuranceElement, CODES_TFhirIdentityAssuranceLevelEnum, SYSTEMS_TFhirIdentityAssuranceLevelEnum, false, -1);
end;

function TFHIRTurtleParser.ParsePerson(obj : TTurtleComplex) : TFhirPerson;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPerson.create;
  try
    ParsePersonProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePersonProperties(obj : TTurtleComplex; value : TFhirPerson);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Person.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Person.active'));
    for item in obj.complexes('http://hl7.org/fhir/Person.name') do
      value.nameList.Add(parseHumanName(item));
    for item in obj.complexes('http://hl7.org/fhir/Person.telecom') do
      value.telecomList.Add(parseContactPoint(item));
    value.genderElement := ParseEnum(obj.complex('http://hl7.org/fhir/Person.gender'), CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    value.birthDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Person.birthDate'));
    if obj.has('deceasedBoolean', item) then
      value.deceased := parseBoolean(item);
    if obj.has('deceasedDateTime', item) then
      value.deceased := parseDateTime(item);
    for item in obj.complexes('http://hl7.org/fhir/Person.address') do
      value.addressList.Add(parseAddress(item));
    value.maritalStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Person.maritalStatus'));
    for item in obj.complexes('http://hl7.org/fhir/Person.photo') do
      value.photoList.Add(parseAttachment(item));
    for item in obj.complexes('http://hl7.org/fhir/Person.communication') do
      value.communicationList.Add(parsePersonCommunication(item));
    value.managingOrganization := ParseReference(obj.complex('http://hl7.org/fhir/Person.managingOrganization'));
    for item in obj.complexes('http://hl7.org/fhir/Person.link') do
      value.link_List.Add(parsePersonLink(item));
end;

procedure TFHIRTurtleComposer.ComposePerson(parent :  TTurtleComplex; parentType, name : String; value : TFhirPerson; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Person');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Person', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Person', 'active', value.activeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.nameList.Count - 1 do
      ComposeHumanName(this, 'Person', 'name', value.nameList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Person', 'telecom', value.telecomList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Person', 'gender', value.genderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'Person', 'birthDate', value.birthDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.deceased is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Person', 'deceasedBoolean', TFhirBoolean(value.deceased), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.deceased is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Person', 'deceasedDateTime', TFhirDateTime(value.deceased), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.addressList.Count - 1 do
      ComposeAddress(this, 'Person', 'address', value.addressList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Person', 'maritalStatus', value.maritalStatusElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.photoList.Count - 1 do
      ComposeAttachment(this, 'Person', 'photo', value.photoList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.communicationList.Count - 1 do
      ComposePersonCommunication(this, 'Person', 'communication', value.communicationList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Person', 'managingOrganization', value.managingOrganizationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.link_List.Count - 1 do
      ComposePersonLink(this, 'Person', 'link', value.link_List[i], false, i);
end;

{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
function TFHIRTurtleParser.ParsePlanDefinitionGoal(obj : TTurtleComplex) : TFhirPlanDefinitionGoal;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinitionGoal.create;
  try
    ParsePlanDefinitionGoalProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionGoalProperties(obj : TTurtleComplex; value : TFhirPlanDefinitionGoal);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.goal.category'));
    value.description := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.goal.description'));
    value.priority := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.goal.priority'));
    value.start := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.goal.start'));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.goal.addresses') do
      value.addressesList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.goal.documentation') do
      value.documentationList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.goal.target') do
      value.targetList.Add(parsePlanDefinitionGoalTarget(item));
end;

procedure TFHIRTurtleComposer.ComposePlanDefinitionGoal(parent :  TTurtleComplex; parentType, name : String; value : TFhirPlanDefinitionGoal; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinitionGoal');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PlanDefinition.goal', 'category', value.categoryElement, false, -1);
  ComposeCodeableConcept(this, 'PlanDefinition.goal', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PlanDefinition.goal', 'priority', value.priorityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PlanDefinition.goal', 'start', value.startElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.addressesList.Count - 1 do
      ComposeCodeableConcept(this, 'PlanDefinition.goal', 'addresses', value.addressesList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.documentationList.Count - 1 do
      ComposeRelatedArtifact(this, 'PlanDefinition.goal', 'documentation', value.documentationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.targetList.Count - 1 do
      ComposePlanDefinitionGoalTarget(this, 'PlanDefinition.goal', 'target', value.targetList[i], false, i);
end;

function TFHIRTurtleParser.ParsePlanDefinitionGoalTarget(obj : TTurtleComplex) : TFhirPlanDefinitionGoalTarget;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinitionGoalTarget.create;
  try
    ParsePlanDefinitionGoalTargetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionGoalTargetProperties(obj : TTurtleComplex; value : TFhirPlanDefinitionGoalTarget);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.measure := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.goal.target.measure'));
    if obj.has('detailQuantity', item) then
      value.detail := parseQuantity(item);
    if obj.has('detailRange', item) then
      value.detail := parseRange(item);
    if obj.has('detailCodeableConcept', item) then
      value.detail := parseCodeableConcept(item);
    if obj.has('detailRatio', item) then
      value.detail := parseRatio(item);
    if obj.has('detailString', item) then
      value.detail := parseString(item);
    if obj.has('detailBoolean', item) then
      value.detail := parseBoolean(item);
    if obj.has('detailInteger', item) then
      value.detail := parseInteger(item);
    value.due := ParseDuration(obj.complex('http://hl7.org/fhir/PlanDefinition.goal.target.due'));
end;

procedure TFHIRTurtleComposer.ComposePlanDefinitionGoalTarget(parent :  TTurtleComplex; parentType, name : String; value : TFhirPlanDefinitionGoalTarget; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinitionGoalTarget');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PlanDefinition.goal.target', 'measure', value.measureElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.detail is TFhirQuantity) {6} then
    ComposeQuantity(this, 'PlanDefinition.goal.target', 'detailQuantity', TFhirQuantity(value.detail), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.detail is TFhirRange) {6} then
    ComposeRange(this, 'PlanDefinition.goal.target', 'detailRange', TFhirRange(value.detail), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.detail is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'PlanDefinition.goal.target', 'detailCodeableConcept', TFhirCodeableConcept(value.detail), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.detail is TFhirRatio) {6} then
    ComposeRatio(this, 'PlanDefinition.goal.target', 'detailRatio', TFhirRatio(value.detail), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.detail is TFhirString) {6} then
    ComposeString(this, 'PlanDefinition.goal.target', 'detailString', TFhirString(value.detail), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.detail is TFhirBoolean) {6} then
    ComposeBoolean(this, 'PlanDefinition.goal.target', 'detailBoolean', TFhirBoolean(value.detail), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.detail is TFhirInteger) {6} then
    ComposeInteger(this, 'PlanDefinition.goal.target', 'detailInteger', TFhirInteger(value.detail), false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(this, 'PlanDefinition.goal.target', 'due', value.dueElement, false, -1);
end;

function TFHIRTurtleParser.ParsePlanDefinitionActor(obj : TTurtleComplex) : TFhirPlanDefinitionActor;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinitionActor.create;
  try
    ParsePlanDefinitionActorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionActorProperties(obj : TTurtleComplex; value : TFhirPlanDefinitionActor);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.actor.title'));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/PlanDefinition.actor.description'));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.actor.option') do
      value.optionList.Add(parsePlanDefinitionActorOption(item));
end;

procedure TFHIRTurtleComposer.ComposePlanDefinitionActor(parent :  TTurtleComplex; parentType, name : String; value : TFhirPlanDefinitionActor; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinitionActor');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.actor', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'PlanDefinition.actor', 'description', value.descriptionElement, false, -1);
  for i := 0 to value.optionList.Count - 1 do
      ComposePlanDefinitionActorOption(this, 'PlanDefinition.actor', 'option', value.optionList[i], false, i);
end;

function TFHIRTurtleParser.ParsePlanDefinitionActorOption(obj : TTurtleComplex) : TFhirPlanDefinitionActorOption;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinitionActorOption.create;
  try
    ParsePlanDefinitionActorOptionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionActorOptionProperties(obj : TTurtleComplex; value : TFhirPlanDefinitionActorOption);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.actor.option.type'), CODES_TFhirActionParticipantTypeEnum, SYSTEMS_TFhirActionParticipantTypeEnum);
    value.typeCanonicalElement := ParseCanonical(obj.complex('http://hl7.org/fhir/PlanDefinition.actor.option.typeCanonical'));
    value.typeReference := ParseReference(obj.complex('http://hl7.org/fhir/PlanDefinition.actor.option.typeReference'));
    value.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.actor.option.role'));
end;

procedure TFHIRTurtleComposer.ComposePlanDefinitionActorOption(parent :  TTurtleComplex; parentType, name : String; value : TFhirPlanDefinitionActorOption; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinitionActorOption');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'PlanDefinition.actor.option', 'type', value.type_Element, CODES_TFhirActionParticipantTypeEnum, SYSTEMS_TFhirActionParticipantTypeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'PlanDefinition.actor.option', 'typeCanonical', value.typeCanonicalElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'PlanDefinition.actor.option', 'typeReference', value.typeReferenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PlanDefinition.actor.option', 'role', value.roleElement, false, -1);
end;

function TFHIRTurtleParser.ParsePlanDefinitionAction(obj : TTurtleComplex) : TFhirPlanDefinitionAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinitionAction.create;
  try
    ParsePlanDefinitionActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionActionProperties(obj : TTurtleComplex; value : TFhirPlanDefinitionAction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.linkIdElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.linkId'));
    value.prefixElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.prefix'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.title'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.description'));
    value.textEquivalentElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.textEquivalent'));
    value.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.action.code'));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.reason') do
      value.reasonList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.documentation') do
      value.documentationList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.goalId') do
      value.goalIdList.Add(parseId(item));
    if obj.has('subjectCodeableConcept', item) then
      value.subject := parseCodeableConcept(item);
    if obj.has('subjectReference', item) {a3} then
      value.subject := ParseReference(item);
    if obj.has('subjectCanonical', item) then
      value.subject := parseCanonical(item);
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.trigger') do
      value.triggerList.Add(parseTriggerDefinition(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.condition') do
      value.conditionList.Add(parsePlanDefinitionActionCondition(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.input') do
      value.inputList.Add(parsePlanDefinitionActionInput(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.output') do
      value.outputList.Add(parsePlanDefinitionActionOutput(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.relatedAction') do
      value.relatedActionList.Add(parsePlanDefinitionActionRelatedAction(item));
    if obj.has('timingAge', item) then
      value.timing := parseAge(item);
    if obj.has('timingDuration', item) then
      value.timing := parseDuration(item);
    if obj.has('timingRange', item) then
      value.timing := parseRange(item);
    if obj.has('timingTiming', item) then
      value.timing := parseTiming(item);
    value.location := ParseCodeableReference(obj.complex('http://hl7.org/fhir/PlanDefinition.action.location'));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.participant') do
      value.participantList.Add(parsePlanDefinitionActionParticipant(item));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.action.type'));
    value.groupingBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.groupingBehavior'), CODES_TFhirActionGroupingBehaviorEnum, SYSTEMS_TFhirActionGroupingBehaviorEnum);
    value.selectionBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.selectionBehavior'), CODES_TFhirActionSelectionBehaviorEnum, SYSTEMS_TFhirActionSelectionBehaviorEnum);
    value.requiredBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.requiredBehavior'), CODES_TFhirActionRequiredBehaviorEnum, SYSTEMS_TFhirActionRequiredBehaviorEnum);
    value.precheckBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.precheckBehavior'), CODES_TFhirActionPrecheckBehaviorEnum, SYSTEMS_TFhirActionPrecheckBehaviorEnum);
    value.cardinalityBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.cardinalityBehavior'), CODES_TFhirActionCardinalityBehaviorEnum, SYSTEMS_TFhirActionCardinalityBehaviorEnum);
    if obj.has('definitionCanonical', item) then
      value.definition := parseCanonical(item);
    if obj.has('definitionUri', item) then
      value.definition := parseUri(item);
    value.transformElement := ParseCanonical(obj.complex('http://hl7.org/fhir/PlanDefinition.action.transform'));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.dynamicValue') do
      value.dynamicValueList.Add(parsePlanDefinitionActionDynamicValue(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.action') do
      value.actionList.Add(parsePlanDefinitionAction(item));
end;

procedure TFHIRTurtleComposer.ComposePlanDefinitionAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirPlanDefinitionAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinitionAction');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action', 'linkId', value.linkIdElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action', 'prefix', value.prefixElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action', 'textEquivalent', value.textEquivalentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'PlanDefinition.action', 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PlanDefinition.action', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'PlanDefinition.action', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.documentationList.Count - 1 do
      ComposeRelatedArtifact(this, 'PlanDefinition.action', 'documentation', value.documentationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.goalIdList.Count - 1 do
      ComposeId(this, 'PlanDefinition.action', 'goalId', value.goalIdList[i], false, i);
  if (SummaryOption in [soFull, soData]) and (value.subject is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'PlanDefinition.action', 'subjectCodeableConcept', TFhirCodeableConcept(value.subject), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.subject is TFhirReference) {2} then
    ComposeReference(this, 'PlanDefinition.action', 'subjectReference', TFhirReference(value.subject), false,-1)
  else if (SummaryOption in [soFull, soData]) and (value.subject is TFhirCanonical) {6} then
    ComposeCanonical(this, 'PlanDefinition.action', 'subjectCanonical', TFhirCanonical(value.subject), false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.triggerList.Count - 1 do
      ComposeTriggerDefinition(this, 'PlanDefinition.action', 'trigger', value.triggerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.conditionList.Count - 1 do
      ComposePlanDefinitionActionCondition(this, 'PlanDefinition.action', 'condition', value.conditionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.inputList.Count - 1 do
      ComposePlanDefinitionActionInput(this, 'PlanDefinition.action', 'input', value.inputList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.outputList.Count - 1 do
      ComposePlanDefinitionActionOutput(this, 'PlanDefinition.action', 'output', value.outputList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedActionList.Count - 1 do
      ComposePlanDefinitionActionRelatedAction(this, 'PlanDefinition.action', 'relatedAction', value.relatedActionList[i], false, i);
  if (SummaryOption in [soFull, soData]) and (value.timing is TFhirAge) {6} then
    ComposeAge(this, 'PlanDefinition.action', 'timingAge', TFhirAge(value.timing), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirDuration) {6} then
    ComposeDuration(this, 'PlanDefinition.action', 'timingDuration', TFhirDuration(value.timing), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirRange) {6} then
    ComposeRange(this, 'PlanDefinition.action', 'timingRange', TFhirRange(value.timing), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirTiming) {6} then
    ComposeTiming(this, 'PlanDefinition.action', 'timingTiming', TFhirTiming(value.timing), false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(this, 'PlanDefinition.action', 'location', value.locationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.participantList.Count - 1 do
      ComposePlanDefinitionActionParticipant(this, 'PlanDefinition.action', 'participant', value.participantList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PlanDefinition.action', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'PlanDefinition.action', 'groupingBehavior', value.groupingBehaviorElement, CODES_TFhirActionGroupingBehaviorEnum, SYSTEMS_TFhirActionGroupingBehaviorEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'PlanDefinition.action', 'selectionBehavior', value.selectionBehaviorElement, CODES_TFhirActionSelectionBehaviorEnum, SYSTEMS_TFhirActionSelectionBehaviorEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'PlanDefinition.action', 'requiredBehavior', value.requiredBehaviorElement, CODES_TFhirActionRequiredBehaviorEnum, SYSTEMS_TFhirActionRequiredBehaviorEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'PlanDefinition.action', 'precheckBehavior', value.precheckBehaviorElement, CODES_TFhirActionPrecheckBehaviorEnum, SYSTEMS_TFhirActionPrecheckBehaviorEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'PlanDefinition.action', 'cardinalityBehavior', value.cardinalityBehaviorElement, CODES_TFhirActionCardinalityBehaviorEnum, SYSTEMS_TFhirActionCardinalityBehaviorEnum, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.definition is TFhirCanonical) {6} then
    ComposeCanonical(this, 'PlanDefinition.action', 'definitionCanonical', TFhirCanonical(value.definition), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.definition is TFhirUri) {6} then
    ComposeUri(this, 'PlanDefinition.action', 'definitionUri', TFhirUri(value.definition), false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'PlanDefinition.action', 'transform', value.transformElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dynamicValueList.Count - 1 do
      ComposePlanDefinitionActionDynamicValue(this, 'PlanDefinition.action', 'dynamicValue', value.dynamicValueList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.actionList.Count - 1 do
      ComposePlanDefinitionAction(this, 'PlanDefinition.action', 'action', value.actionList[i], false, i);
end;

function TFHIRTurtleParser.ParsePlanDefinitionActionCondition(obj : TTurtleComplex) : TFhirPlanDefinitionActionCondition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinitionActionCondition.create;
  try
    ParsePlanDefinitionActionConditionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionActionConditionProperties(obj : TTurtleComplex; value : TFhirPlanDefinitionActionCondition);
begin
    ParseBackboneElementProperties(obj, value);
    value.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.condition.kind'), CODES_TFhirActionConditionKindEnum, SYSTEMS_TFhirActionConditionKindEnum);
    value.expression := ParseExpression(obj.complex('http://hl7.org/fhir/PlanDefinition.action.condition.expression'));
end;

procedure TFHIRTurtleComposer.ComposePlanDefinitionActionCondition(parent :  TTurtleComplex; parentType, name : String; value : TFhirPlanDefinitionActionCondition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinitionActionCondition');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'PlanDefinition.action.condition', 'kind', value.kindElement, CODES_TFhirActionConditionKindEnum, SYSTEMS_TFhirActionConditionKindEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeExpression(this, 'PlanDefinition.action.condition', 'expression', value.expressionElement, false, -1);
end;

function TFHIRTurtleParser.ParsePlanDefinitionActionInput(obj : TTurtleComplex) : TFhirPlanDefinitionActionInput;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinitionActionInput.create;
  try
    ParsePlanDefinitionActionInputProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionActionInputProperties(obj : TTurtleComplex; value : TFhirPlanDefinitionActionInput);
begin
    ParseBackboneElementProperties(obj, value);
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.input.title'));
    value.requirement := ParseDataRequirement(obj.complex('http://hl7.org/fhir/PlanDefinition.action.input.requirement'));
    value.relatedDataElement := ParseId(obj.complex('http://hl7.org/fhir/PlanDefinition.action.input.relatedData'));
end;

procedure TFHIRTurtleComposer.ComposePlanDefinitionActionInput(parent :  TTurtleComplex; parentType, name : String; value : TFhirPlanDefinitionActionInput; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinitionActionInput');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action.input', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDataRequirement(this, 'PlanDefinition.action.input', 'requirement', value.requirementElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'PlanDefinition.action.input', 'relatedData', value.relatedDataElement, false, -1);
end;

function TFHIRTurtleParser.ParsePlanDefinitionActionOutput(obj : TTurtleComplex) : TFhirPlanDefinitionActionOutput;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinitionActionOutput.create;
  try
    ParsePlanDefinitionActionOutputProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionActionOutputProperties(obj : TTurtleComplex; value : TFhirPlanDefinitionActionOutput);
begin
    ParseBackboneElementProperties(obj, value);
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.output.title'));
    value.requirement := ParseDataRequirement(obj.complex('http://hl7.org/fhir/PlanDefinition.action.output.requirement'));
    value.relatedDataElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.output.relatedData'));
end;

procedure TFHIRTurtleComposer.ComposePlanDefinitionActionOutput(parent :  TTurtleComplex; parentType, name : String; value : TFhirPlanDefinitionActionOutput; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinitionActionOutput');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action.output', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDataRequirement(this, 'PlanDefinition.action.output', 'requirement', value.requirementElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action.output', 'relatedData', value.relatedDataElement, false, -1);
end;

function TFHIRTurtleParser.ParsePlanDefinitionActionRelatedAction(obj : TTurtleComplex) : TFhirPlanDefinitionActionRelatedAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinitionActionRelatedAction.create;
  try
    ParsePlanDefinitionActionRelatedActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionActionRelatedActionProperties(obj : TTurtleComplex; value : TFhirPlanDefinitionActionRelatedAction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.targetIdElement := ParseId(obj.complex('http://hl7.org/fhir/PlanDefinition.action.relatedAction.targetId'));
    value.relationshipElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.relatedAction.relationship'), CODES_TFhirActionRelationshipTypeEnum, SYSTEMS_TFhirActionRelationshipTypeEnum);
    if obj.has('offsetDuration', item) then
      value.offset := parseDuration(item);
    if obj.has('offsetRange', item) then
      value.offset := parseRange(item);
end;

procedure TFHIRTurtleComposer.ComposePlanDefinitionActionRelatedAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirPlanDefinitionActionRelatedAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinitionActionRelatedAction');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeId(this, 'PlanDefinition.action.relatedAction', 'targetId', value.targetIdElement, false, -1);
  ComposeEnum(this, 'PlanDefinition.action.relatedAction', 'relationship', value.relationshipElement, CODES_TFhirActionRelationshipTypeEnum, SYSTEMS_TFhirActionRelationshipTypeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.offset is TFhirDuration) {6} then
    ComposeDuration(this, 'PlanDefinition.action.relatedAction', 'offsetDuration', TFhirDuration(value.offset), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.offset is TFhirRange) {6} then
    ComposeRange(this, 'PlanDefinition.action.relatedAction', 'offsetRange', TFhirRange(value.offset), false, -1);
end;

function TFHIRTurtleParser.ParsePlanDefinitionActionParticipant(obj : TTurtleComplex) : TFhirPlanDefinitionActionParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinitionActionParticipant.create;
  try
    ParsePlanDefinitionActionParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionActionParticipantProperties(obj : TTurtleComplex; value : TFhirPlanDefinitionActionParticipant);
begin
    ParseBackboneElementProperties(obj, value);
    value.actorIdElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.participant.actorId'));
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.participant.type'), CODES_TFhirActionParticipantTypeEnum, SYSTEMS_TFhirActionParticipantTypeEnum);
    value.typeCanonicalElement := ParseCanonical(obj.complex('http://hl7.org/fhir/PlanDefinition.action.participant.typeCanonical'));
    value.typeReference := ParseReference(obj.complex('http://hl7.org/fhir/PlanDefinition.action.participant.typeReference'));
    value.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.action.participant.role'));
    value.function_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.action.participant.function'));
end;

procedure TFHIRTurtleComposer.ComposePlanDefinitionActionParticipant(parent :  TTurtleComplex; parentType, name : String; value : TFhirPlanDefinitionActionParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinitionActionParticipant');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action.participant', 'actorId', value.actorIdElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'PlanDefinition.action.participant', 'type', value.type_Element, CODES_TFhirActionParticipantTypeEnum, SYSTEMS_TFhirActionParticipantTypeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'PlanDefinition.action.participant', 'typeCanonical', value.typeCanonicalElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'PlanDefinition.action.participant', 'typeReference', value.typeReferenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PlanDefinition.action.participant', 'role', value.roleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PlanDefinition.action.participant', 'function', value.function_Element, false, -1);
end;

function TFHIRTurtleParser.ParsePlanDefinitionActionDynamicValue(obj : TTurtleComplex) : TFhirPlanDefinitionActionDynamicValue;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinitionActionDynamicValue.create;
  try
    ParsePlanDefinitionActionDynamicValueProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionActionDynamicValueProperties(obj : TTurtleComplex; value : TFhirPlanDefinitionActionDynamicValue);
begin
    ParseBackboneElementProperties(obj, value);
    value.pathElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.dynamicValue.path'));
    value.expression := ParseExpression(obj.complex('http://hl7.org/fhir/PlanDefinition.action.dynamicValue.expression'));
end;

procedure TFHIRTurtleComposer.ComposePlanDefinitionActionDynamicValue(parent :  TTurtleComplex; parentType, name : String; value : TFhirPlanDefinitionActionDynamicValue; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinitionActionDynamicValue');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action.dynamicValue', 'path', value.pathElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeExpression(this, 'PlanDefinition.action.dynamicValue', 'expression', value.expressionElement, false, -1);
end;

function TFHIRTurtleParser.ParsePlanDefinition(obj : TTurtleComplex) : TFhirPlanDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinition.create;
  try
    ParsePlanDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionProperties(obj : TTurtleComplex; value : TFhirPlanDefinition);
var
  item : TTurtleComplex;
begin
    ParseMetadataResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/PlanDefinition.url'));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.version'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.title'));
    value.subtitleElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.subtitle'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.type'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/PlanDefinition.experimental'));
    if obj.has('subjectCodeableConcept', item) then
      value.subject := parseCodeableConcept(item);
    if obj.has('subjectReference', item) {a3} then
      value.subject := ParseReference(item);
    if obj.has('subjectCanonical', item) then
      value.subject := parseCanonical(item);
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/PlanDefinition.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/PlanDefinition.description'));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/PlanDefinition.purpose'));
    value.usageElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.usage'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/PlanDefinition.copyright'));
    value.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/PlanDefinition.approvalDate'));
    value.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/PlanDefinition.lastReviewDate'));
    value.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/PlanDefinition.effectivePeriod'));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.topic') do
      value.topicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.author') do
      value.authorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.editor') do
      value.editorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.reviewer') do
      value.reviewerList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.endorser') do
      value.endorserList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.relatedArtifact') do
      value.relatedArtifactList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.library') do
      value.library_List.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.goal') do
      value.goalList.Add(parsePlanDefinitionGoal(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.actor') do
      value.actorList.Add(parsePlanDefinitionActor(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action') do
      value.actionList.Add(parsePlanDefinitionAction(item));
    if obj.has('asNeededCodeableConcept', item) then
      value.asNeeded := parseCodeableConcept(item);
    if obj.has('asNeededBoolean', item) then
      value.asNeeded := parseBoolean(item);
end;

procedure TFHIRTurtleComposer.ComposePlanDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirPlanDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinition');
  end;
  composeMetadataResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'PlanDefinition', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'PlanDefinition', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'PlanDefinition', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'PlanDefinition', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'PlanDefinition', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition', 'subtitle', value.subtitleElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'PlanDefinition', 'type', value.type_Element, false, -1);
  ComposeEnum(this, 'PlanDefinition', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'PlanDefinition', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.subject is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'PlanDefinition', 'subjectCodeableConcept', TFhirCodeableConcept(value.subject), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.subject is TFhirReference) {2} then
    ComposeReference(this, 'PlanDefinition', 'subjectReference', TFhirReference(value.subject), false,-1)
  else if (SummaryOption in [soFull, soData]) and (value.subject is TFhirCanonical) {6} then
    ComposeCanonical(this, 'PlanDefinition', 'subjectCanonical', TFhirCanonical(value.subject), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'PlanDefinition', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'PlanDefinition', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'PlanDefinition', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'PlanDefinition', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'PlanDefinition', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'PlanDefinition', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'PlanDefinition', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition', 'usage', value.usageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'PlanDefinition', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'PlanDefinition', 'approvalDate', value.approvalDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'PlanDefinition', 'lastReviewDate', value.lastReviewDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'PlanDefinition', 'effectivePeriod', value.effectivePeriodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.topicList.Count - 1 do
      ComposeCodeableConcept(this, 'PlanDefinition', 'topic', value.topicList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(this, 'PlanDefinition', 'author', value.authorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(this, 'PlanDefinition', 'editor', value.editorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(this, 'PlanDefinition', 'reviewer', value.reviewerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(this, 'PlanDefinition', 'endorser', value.endorserList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'PlanDefinition', 'relatedArtifact', value.relatedArtifactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.library_List.Count - 1 do
      ComposeCanonical(this, 'PlanDefinition', 'library', value.library_List[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.goalList.Count - 1 do
      ComposePlanDefinitionGoal(this, 'PlanDefinition', 'goal', value.goalList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.actorList.Count - 1 do
      ComposePlanDefinitionActor(this, 'PlanDefinition', 'actor', value.actorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.actionList.Count - 1 do
      ComposePlanDefinitionAction(this, 'PlanDefinition', 'action', value.actionList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'PlanDefinition', 'asNeededCodeableConcept', TFhirCodeableConcept(value.asNeeded), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(this, 'PlanDefinition', 'asNeededBoolean', TFhirBoolean(value.asNeeded), false, -1);
end;

{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
function TFHIRTurtleParser.ParsePractitionerQualification(obj : TTurtleComplex) : TFhirPractitionerQualification;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPractitionerQualification.create;
  try
    ParsePractitionerQualificationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePractitionerQualificationProperties(obj : TTurtleComplex; value : TFhirPractitionerQualification);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.qualification.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Practitioner.qualification.code'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Practitioner.qualification.period'));
    value.issuer := ParseReference(obj.complex('http://hl7.org/fhir/Practitioner.qualification.issuer'));
end;

procedure TFHIRTurtleComposer.ComposePractitionerQualification(parent :  TTurtleComplex; parentType, name : String; value : TFhirPractitionerQualification; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PractitionerQualification');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Practitioner.qualification', 'identifier', value.identifierList[i], false, i);
  ComposeCodeableConcept(this, 'Practitioner.qualification', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Practitioner.qualification', 'period', value.periodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Practitioner.qualification', 'issuer', value.issuerElement, false, -1);
end;

function TFHIRTurtleParser.ParsePractitioner(obj : TTurtleComplex) : TFhirPractitioner;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPractitioner.create;
  try
    ParsePractitionerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePractitionerProperties(obj : TTurtleComplex; value : TFhirPractitioner);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Practitioner.active'));
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.name') do
      value.nameList.Add(parseHumanName(item));
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.telecom') do
      value.telecomList.Add(parseContactPoint(item));
    value.genderElement := ParseEnum(obj.complex('http://hl7.org/fhir/Practitioner.gender'), CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    value.birthDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Practitioner.birthDate'));
    if obj.has('deceasedBoolean', item) then
      value.deceased := parseBoolean(item);
    if obj.has('deceasedDateTime', item) then
      value.deceased := parseDateTime(item);
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.address') do
      value.addressList.Add(parseAddress(item));
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.photo') do
      value.photoList.Add(parseAttachment(item));
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.qualification') do
      value.qualificationList.Add(parsePractitionerQualification(item));
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.communication') do
      value.communicationList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposePractitioner(parent :  TTurtleComplex; parentType, name : String; value : TFhirPractitioner; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Practitioner');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Practitioner', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Practitioner', 'active', value.activeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.nameList.Count - 1 do
      ComposeHumanName(this, 'Practitioner', 'name', value.nameList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Practitioner', 'telecom', value.telecomList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Practitioner', 'gender', value.genderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'Practitioner', 'birthDate', value.birthDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.deceased is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Practitioner', 'deceasedBoolean', TFhirBoolean(value.deceased), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.deceased is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Practitioner', 'deceasedDateTime', TFhirDateTime(value.deceased), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.addressList.Count - 1 do
      ComposeAddress(this, 'Practitioner', 'address', value.addressList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.photoList.Count - 1 do
      ComposeAttachment(this, 'Practitioner', 'photo', value.photoList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.qualificationList.Count - 1 do
      ComposePractitionerQualification(this, 'Practitioner', 'qualification', value.qualificationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.communicationList.Count - 1 do
      ComposeCodeableConcept(this, 'Practitioner', 'communication', value.communicationList[i], false, i);
end;

{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
function TFHIRTurtleParser.ParsePractitionerRole(obj : TTurtleComplex) : TFhirPractitionerRole;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPractitionerRole.create;
  try
    ParsePractitionerRoleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePractitionerRoleProperties(obj : TTurtleComplex; value : TFhirPractitionerRole);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/PractitionerRole.active'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/PractitionerRole.period'));
    value.practitioner := ParseReference(obj.complex('http://hl7.org/fhir/PractitionerRole.practitioner'));
    value.organization := ParseReference(obj.complex('http://hl7.org/fhir/PractitionerRole.organization'));
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.code') do
      value.codeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.specialty') do
      value.specialtyList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.location') do
      value.locationList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.healthcareService') do
      value.healthcareServiceList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.contact') do
      value.contactList.Add(parseExtendedContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.availability') do
      value.availabilityList.Add(parseAvailability(item));
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.endpoint') do
      value.endpointList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposePractitionerRole(parent :  TTurtleComplex; parentType, name : String; value : TFhirPractitionerRole; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PractitionerRole');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'PractitionerRole', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'PractitionerRole', 'active', value.activeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'PractitionerRole', 'period', value.periodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'PractitionerRole', 'practitioner', value.practitionerElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'PractitionerRole', 'organization', value.organizationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCodeableConcept(this, 'PractitionerRole', 'code', value.codeList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.specialtyList.Count - 1 do
      ComposeCodeableConcept(this, 'PractitionerRole', 'specialty', value.specialtyList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.locationList.Count - 1 do
      ComposeReference(this, 'PractitionerRole', 'location', value.locationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.healthcareServiceList.Count - 1 do
      ComposeReference(this, 'PractitionerRole', 'healthcareService', value.healthcareServiceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeExtendedContactDetail(this, 'PractitionerRole', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.availabilityList.Count - 1 do
      ComposeAvailability(this, 'PractitionerRole', 'availability', value.availabilityList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endpointList.Count - 1 do
      ComposeReference(this, 'PractitionerRole', 'endpoint', value.endpointList[i], false, i);
end;

{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
function TFHIRTurtleParser.ParseProcedurePerformer(obj : TTurtleComplex) : TFhirProcedurePerformer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProcedurePerformer.create;
  try
    ParseProcedurePerformerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProcedurePerformerProperties(obj : TTurtleComplex; value : TFhirProcedurePerformer);
begin
    ParseBackboneElementProperties(obj, value);
    value.function_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Procedure.performer.function'));
    value.actor := ParseReference(obj.complex('http://hl7.org/fhir/Procedure.performer.actor'));
    value.onBehalfOf := ParseReference(obj.complex('http://hl7.org/fhir/Procedure.performer.onBehalfOf'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Procedure.performer.period'));
end;

procedure TFHIRTurtleComposer.ComposeProcedurePerformer(parent :  TTurtleComplex; parentType, name : String; value : TFhirProcedurePerformer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProcedurePerformer');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Procedure.performer', 'function', value.function_Element, false, -1);
  ComposeReference(this, 'Procedure.performer', 'actor', value.actorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Procedure.performer', 'onBehalfOf', value.onBehalfOfElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Procedure.performer', 'period', value.periodElement, false, -1);
end;

function TFHIRTurtleParser.ParseProcedureFocalDevice(obj : TTurtleComplex) : TFhirProcedureFocalDevice;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProcedureFocalDevice.create;
  try
    ParseProcedureFocalDeviceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProcedureFocalDeviceProperties(obj : TTurtleComplex; value : TFhirProcedureFocalDevice);
begin
    ParseBackboneElementProperties(obj, value);
    value.action := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Procedure.focalDevice.action'));
    value.manipulated := ParseReference(obj.complex('http://hl7.org/fhir/Procedure.focalDevice.manipulated'));
end;

procedure TFHIRTurtleComposer.ComposeProcedureFocalDevice(parent :  TTurtleComplex; parentType, name : String; value : TFhirProcedureFocalDevice; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProcedureFocalDevice');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Procedure.focalDevice', 'action', value.actionElement, false, -1);
  ComposeReference(this, 'Procedure.focalDevice', 'manipulated', value.manipulatedElement, false, -1);
end;

function TFHIRTurtleParser.ParseProcedure(obj : TTurtleComplex) : TFhirProcedure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProcedure.create;
  try
    ParseProcedureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProcedureProperties(obj : TTurtleComplex; value : TFhirProcedure);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Procedure.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.instantiatesCanonical') do
      value.instantiatesCanonicalList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.instantiatesUri') do
      value.instantiatesUriList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.basedOn') do
      value.basedOnList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.partOf') do
      value.partOfList.Add(parseReference(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Procedure.status'), CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum);
    value.statusReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Procedure.statusReason'));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Procedure.code'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/Procedure.subject'));
    value.focus := ParseReference(obj.complex('http://hl7.org/fhir/Procedure.focus'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/Procedure.encounter'));
    if obj.has('occurrencePeriod', item) then
      value.occurrence := parsePeriod(item);
    if obj.has('occurrenceAge', item) then
      value.occurrence := parseAge(item);
    if obj.has('occurrenceRange', item) then
      value.occurrence := parseRange(item);
    if obj.has('occurrenceTiming', item) then
      value.occurrence := parseTiming(item);
    if obj.has('occurrenceDateTime', item) then
      value.occurrence := parseDateTime(item);
    if obj.has('occurrenceString', item) then
      value.occurrence := parseString(item);
    value.recordedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Procedure.recorded'));
    value.recorder := ParseReference(obj.complex('http://hl7.org/fhir/Procedure.recorder'));
    if obj.has('reportedReference', item) {a3} then
      value.reported := ParseReference(item);
    if obj.has('reportedBoolean', item) then
      value.reported := parseBoolean(item);
    for item in obj.complexes('http://hl7.org/fhir/Procedure.performer') do
      value.performerList.Add(parseProcedurePerformer(item));
    value.location := ParseReference(obj.complex('http://hl7.org/fhir/Procedure.location'));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.reason') do
      value.reasonList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.bodySite') do
      value.bodySiteList.Add(parseCodeableConcept(item));
    value.outcome := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Procedure.outcome'));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.report') do
      value.reportList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.complication') do
      value.complicationList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.complicationDetail') do
      value.complicationDetailList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.followUp') do
      value.followUpList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.focalDevice') do
      value.focalDeviceList.Add(parseProcedureFocalDevice(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.used') do
      value.usedList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.supportingInfo') do
      value.supportingInfoList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeProcedure(parent :  TTurtleComplex; parentType, name : String; value : TFhirProcedure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Procedure');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Procedure', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(this, 'Procedure', 'instantiatesCanonical', value.instantiatesCanonicalList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesUriList.Count - 1 do
      ComposeUri(this, 'Procedure', 'instantiatesUri', value.instantiatesUriList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'Procedure', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(this, 'Procedure', 'partOf', value.partOfList[i], false, i);
  ComposeEnum(this, 'Procedure', 'status', value.statusElement, CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Procedure', 'statusReason', value.statusReasonElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Procedure', 'category', value.categoryList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Procedure', 'code', value.codeElement, false, -1);
  ComposeReference(this, 'Procedure', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Procedure', 'focus', value.focusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Procedure', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'Procedure', 'occurrencePeriod', TFhirPeriod(value.occurrence), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirAge) {6} then
    ComposeAge(this, 'Procedure', 'occurrenceAge', TFhirAge(value.occurrence), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirRange) {6} then
    ComposeRange(this, 'Procedure', 'occurrenceRange', TFhirRange(value.occurrence), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirTiming) {6} then
    ComposeTiming(this, 'Procedure', 'occurrenceTiming', TFhirTiming(value.occurrence), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Procedure', 'occurrenceDateTime', TFhirDateTime(value.occurrence), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirString) {6} then
    ComposeString(this, 'Procedure', 'occurrenceString', TFhirString(value.occurrence), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Procedure', 'recorded', value.recordedElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Procedure', 'recorder', value.recorderElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.reported is TFhirReference) {2} then
    ComposeReference(this, 'Procedure', 'reportedReference', TFhirReference(value.reported), false,-1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.reported is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Procedure', 'reportedBoolean', TFhirBoolean(value.reported), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeProcedurePerformer(this, 'Procedure', 'performer', value.performerList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Procedure', 'location', value.locationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(this, 'Procedure', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.bodySiteList.Count - 1 do
      ComposeCodeableConcept(this, 'Procedure', 'bodySite', value.bodySiteList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Procedure', 'outcome', value.outcomeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reportList.Count - 1 do
      ComposeReference(this, 'Procedure', 'report', value.reportList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.complicationList.Count - 1 do
      ComposeCodeableConcept(this, 'Procedure', 'complication', value.complicationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.complicationDetailList.Count - 1 do
      ComposeReference(this, 'Procedure', 'complicationDetail', value.complicationDetailList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.followUpList.Count - 1 do
      ComposeCodeableConcept(this, 'Procedure', 'followUp', value.followUpList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'Procedure', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.focalDeviceList.Count - 1 do
      ComposeProcedureFocalDevice(this, 'Procedure', 'focalDevice', value.focalDeviceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.usedList.Count - 1 do
      ComposeCodeableReference(this, 'Procedure', 'used', value.usedList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInfoList.Count - 1 do
      ComposeReference(this, 'Procedure', 'supportingInfo', value.supportingInfoList[i], false, i);
end;

{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROVENANCE}
function TFHIRTurtleParser.ParseProvenanceAgent(obj : TTurtleComplex) : TFhirProvenanceAgent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProvenanceAgent.create;
  try
    ParseProvenanceAgentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProvenanceAgentProperties(obj : TTurtleComplex; value : TFhirProvenanceAgent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Provenance.agent.type'));
    for item in obj.complexes('http://hl7.org/fhir/Provenance.agent.role') do
      value.roleList.Add(parseCodeableConcept(item));
    value.who := ParseReference(obj.complex('http://hl7.org/fhir/Provenance.agent.who'));
    value.onBehalfOf := ParseReference(obj.complex('http://hl7.org/fhir/Provenance.agent.onBehalfOf'));
end;

procedure TFHIRTurtleComposer.ComposeProvenanceAgent(parent :  TTurtleComplex; parentType, name : String; value : TFhirProvenanceAgent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProvenanceAgent');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Provenance.agent', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.roleList.Count - 1 do
      ComposeCodeableConcept(this, 'Provenance.agent', 'role', value.roleList[i], false, i);
  ComposeReference(this, 'Provenance.agent', 'who', value.whoElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Provenance.agent', 'onBehalfOf', value.onBehalfOfElement, false, -1);
end;

function TFHIRTurtleParser.ParseProvenanceEntity(obj : TTurtleComplex) : TFhirProvenanceEntity;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProvenanceEntity.create;
  try
    ParseProvenanceEntityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProvenanceEntityProperties(obj : TTurtleComplex; value : TFhirProvenanceEntity);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.roleElement := ParseEnum(obj.complex('http://hl7.org/fhir/Provenance.entity.role'), CODES_TFhirProvenanceEntityRoleEnum, SYSTEMS_TFhirProvenanceEntityRoleEnum);
    value.what := ParseReference(obj.complex('http://hl7.org/fhir/Provenance.entity.what'));
    for item in obj.complexes('http://hl7.org/fhir/Provenance.entity.agent') do
      value.agentList.Add(parseProvenanceAgent(item));
end;

procedure TFHIRTurtleComposer.ComposeProvenanceEntity(parent :  TTurtleComplex; parentType, name : String; value : TFhirProvenanceEntity; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProvenanceEntity');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'Provenance.entity', 'role', value.roleElement, CODES_TFhirProvenanceEntityRoleEnum, SYSTEMS_TFhirProvenanceEntityRoleEnum, false, -1);
  ComposeReference(this, 'Provenance.entity', 'what', value.whatElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.agentList.Count - 1 do
      ComposeProvenanceAgent(this, 'Provenance.entity', 'agent', value.agentList[i], false, i);
end;

function TFHIRTurtleParser.ParseProvenance(obj : TTurtleComplex) : TFhirProvenance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProvenance.create;
  try
    ParseProvenanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProvenanceProperties(obj : TTurtleComplex; value : TFhirProvenance);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Provenance.target') do
      value.targetList.Add(parseReference(item));
    if obj.has('occurredPeriod', item) then
      value.occurred := parsePeriod(item);
    if obj.has('occurredDateTime', item) then
      value.occurred := parseDateTime(item);
    value.recordedElement := ParseInstant(obj.complex('http://hl7.org/fhir/Provenance.recorded'));
    for item in obj.complexes('http://hl7.org/fhir/Provenance.policy') do
      value.policyList.Add(parseUri(item));
    value.location := ParseReference(obj.complex('http://hl7.org/fhir/Provenance.location'));
    for item in obj.complexes('http://hl7.org/fhir/Provenance.authorization') do
      value.authorizationList.Add(parseCodeableReference(item));
    value.activity := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Provenance.activity'));
    for item in obj.complexes('http://hl7.org/fhir/Provenance.basedOn') do
      value.basedOnList.Add(parseReference(item));
    value.patient := ParseReference(obj.complex('http://hl7.org/fhir/Provenance.patient'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/Provenance.encounter'));
    for item in obj.complexes('http://hl7.org/fhir/Provenance.agent') do
      value.agentList.Add(parseProvenanceAgent(item));
    for item in obj.complexes('http://hl7.org/fhir/Provenance.entity') do
      value.entityList.Add(parseProvenanceEntity(item));
    for item in obj.complexes('http://hl7.org/fhir/Provenance.signature') do
      value.signatureList.Add(parseSignature(item));
end;

procedure TFHIRTurtleComposer.ComposeProvenance(parent :  TTurtleComplex; parentType, name : String; value : TFhirProvenance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Provenance');
  end;
  composeDomainResource(this, '', name, value, false, index);
  for i := 0 to value.targetList.Count - 1 do
      ComposeReference(this, 'Provenance', 'target', value.targetList[i], false, i);
  if (SummaryOption in [soFull, soData]) and (value.occurred is TFhirPeriod) {6} then
    ComposePeriod(this, 'Provenance', 'occurredPeriod', TFhirPeriod(value.occurred), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.occurred is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Provenance', 'occurredDateTime', TFhirDateTime(value.occurred), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'Provenance', 'recorded', value.recordedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.policyList.Count - 1 do
      ComposeUri(this, 'Provenance', 'policy', value.policyList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Provenance', 'location', value.locationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorizationList.Count - 1 do
      ComposeCodeableReference(this, 'Provenance', 'authorization', value.authorizationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Provenance', 'activity', value.activityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'Provenance', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Provenance', 'patient', value.patientElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Provenance', 'encounter', value.encounterElement, false, -1);
  for i := 0 to value.agentList.Count - 1 do
      ComposeProvenanceAgent(this, 'Provenance', 'agent', value.agentList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.entityList.Count - 1 do
      ComposeProvenanceEntity(this, 'Provenance', 'entity', value.entityList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.signatureList.Count - 1 do
      ComposeSignature(this, 'Provenance', 'signature', value.signatureList[i], false, i);
end;

{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
function TFHIRTurtleParser.ParseQuestionnaireItem(obj : TTurtleComplex) : TFhirQuestionnaireItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireItem.create;
  try
    ParseQuestionnaireItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireItemProperties(obj : TTurtleComplex; value : TFhirQuestionnaireItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.linkIdElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.item.linkId'));
    value.definitionElement := ParseUri(obj.complex('http://hl7.org/fhir/Questionnaire.item.definition'));
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.item.code') do
      value.codeList.Add(parseCoding(item));
    value.prefixElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.item.prefix'));
    value.textElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.item.text'));
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Questionnaire.item.type'), CODES_TFhirQuestionnaireItemTypeEnum, SYSTEMS_TFhirQuestionnaireItemTypeEnum);
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.item.enableWhen') do
      value.enableWhenList.Add(parseQuestionnaireItemEnableWhen(item));
    value.enableBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/Questionnaire.item.enableBehavior'), CODES_TFhirEnableWhenBehaviorEnum, SYSTEMS_TFhirEnableWhenBehaviorEnum);
    value.disabledDisplayElement := ParseEnum(obj.complex('http://hl7.org/fhir/Questionnaire.item.disabledDisplay'), CODES_TFhirQuestionnaireItemDisabledDisplayEnum, SYSTEMS_TFhirQuestionnaireItemDisabledDisplayEnum);
    value.requiredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Questionnaire.item.required'));
    value.repeatsElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Questionnaire.item.repeats'));
    value.readOnlyElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Questionnaire.item.readOnly'));
    value.maxLengthElement := ParseInteger(obj.complex('http://hl7.org/fhir/Questionnaire.item.maxLength'));
    value.answerConstraintElement := ParseEnum(obj.complex('http://hl7.org/fhir/Questionnaire.item.answerConstraint'), CODES_TFhirQuestionnaireAnswerConstraintEnum, SYSTEMS_TFhirQuestionnaireAnswerConstraintEnum);
    value.answerValueSetElement := ParseCanonical(obj.complex('http://hl7.org/fhir/Questionnaire.item.answerValueSet'));
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.item.answerOption') do
      value.answerOptionList.Add(parseQuestionnaireItemAnswerOption(item));
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.item.initial') do
      value.initialList.Add(parseQuestionnaireItemInitial(item));
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.item.item') do
      value.itemList.Add(parseQuestionnaireItem(item));
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirQuestionnaireItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireItem');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'Questionnaire.item', 'linkId', value.linkIdElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'Questionnaire.item', 'definition', value.definitionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCoding(this, 'Questionnaire.item', 'code', value.codeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Questionnaire.item', 'prefix', value.prefixElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Questionnaire.item', 'text', value.textElement, false, -1);
  ComposeEnum(this, 'Questionnaire.item', 'type', value.type_Element, CODES_TFhirQuestionnaireItemTypeEnum, SYSTEMS_TFhirQuestionnaireItemTypeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.enableWhenList.Count - 1 do
      ComposeQuestionnaireItemEnableWhen(this, 'Questionnaire.item', 'enableWhen', value.enableWhenList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Questionnaire.item', 'enableBehavior', value.enableBehaviorElement, CODES_TFhirEnableWhenBehaviorEnum, SYSTEMS_TFhirEnableWhenBehaviorEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Questionnaire.item', 'disabledDisplay', value.disabledDisplayElement, CODES_TFhirQuestionnaireItemDisabledDisplayEnum, SYSTEMS_TFhirQuestionnaireItemDisabledDisplayEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Questionnaire.item', 'required', value.requiredElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Questionnaire.item', 'repeats', value.repeatsElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Questionnaire.item', 'readOnly', value.readOnlyElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'Questionnaire.item', 'maxLength', value.maxLengthElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Questionnaire.item', 'answerConstraint', value.answerConstraintElement, CODES_TFhirQuestionnaireAnswerConstraintEnum, SYSTEMS_TFhirQuestionnaireAnswerConstraintEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'Questionnaire.item', 'answerValueSet', value.answerValueSetElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.answerOptionList.Count - 1 do
      ComposeQuestionnaireItemAnswerOption(this, 'Questionnaire.item', 'answerOption', value.answerOptionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.initialList.Count - 1 do
      ComposeQuestionnaireItemInitial(this, 'Questionnaire.item', 'initial', value.initialList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.itemList.Count - 1 do
      ComposeQuestionnaireItem(this, 'Questionnaire.item', 'item', value.itemList[i], false, i);
end;

function TFHIRTurtleParser.ParseQuestionnaireItemEnableWhen(obj : TTurtleComplex) : TFhirQuestionnaireItemEnableWhen;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireItemEnableWhen.create;
  try
    ParseQuestionnaireItemEnableWhenProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireItemEnableWhenProperties(obj : TTurtleComplex; value : TFhirQuestionnaireItemEnableWhen);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.questionElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.item.enableWhen.question'));
    value.operatorElement := ParseEnum(obj.complex('http://hl7.org/fhir/Questionnaire.item.enableWhen.operator'), CODES_TFhirQuestionnaireItemOperatorEnum, SYSTEMS_TFhirQuestionnaireItemOperatorEnum);
    if obj.has('answerCoding', item) then
      value.answer := parseCoding(item);
    if obj.has('answerQuantity', item) then
      value.answer := parseQuantity(item);
    if obj.has('answerReference', item) {a3} then
      value.answer := ParseReference(item);
    if obj.has('answerBoolean', item) then
      value.answer := parseBoolean(item);
    if obj.has('answerDecimal', item) then
      value.answer := parseDecimal(item);
    if obj.has('answerInteger', item) then
      value.answer := parseInteger(item);
    if obj.has('answerDate', item) then
      value.answer := parseDate(item);
    if obj.has('answerDateTime', item) then
      value.answer := parseDateTime(item);
    if obj.has('answerTime', item) then
      value.answer := parseTime(item);
    if obj.has('answerString', item) then
      value.answer := parseString(item);
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireItemEnableWhen(parent :  TTurtleComplex; parentType, name : String; value : TFhirQuestionnaireItemEnableWhen; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireItemEnableWhen');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'Questionnaire.item.enableWhen', 'question', value.questionElement, false, -1);
  ComposeEnum(this, 'Questionnaire.item.enableWhen', 'operator', value.operatorElement, CODES_TFhirQuestionnaireItemOperatorEnum, SYSTEMS_TFhirQuestionnaireItemOperatorEnum, false, -1);
  if (value.answer is TFhirCoding) {6} then
    ComposeCoding(this, 'Questionnaire.item.enableWhen', 'answerCoding', TFhirCoding(value.answer), false, -1)
  else if (value.answer is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Questionnaire.item.enableWhen', 'answerQuantity', TFhirQuantity(value.answer), false, -1)
  else if (value.answer is TFhirReference) {2} then
    ComposeReference(this, 'Questionnaire.item.enableWhen', 'answerReference', TFhirReference(value.answer), false,-1)
  else if (value.answer is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Questionnaire.item.enableWhen', 'answerBoolean', TFhirBoolean(value.answer), false, -1)
  else if (value.answer is TFhirDecimal) {6} then
    ComposeDecimal(this, 'Questionnaire.item.enableWhen', 'answerDecimal', TFhirDecimal(value.answer), false, -1)
  else if (value.answer is TFhirInteger) {6} then
    ComposeInteger(this, 'Questionnaire.item.enableWhen', 'answerInteger', TFhirInteger(value.answer), false, -1)
  else if (value.answer is TFhirDate) {6} then
    ComposeDate(this, 'Questionnaire.item.enableWhen', 'answerDate', TFhirDate(value.answer), false, -1)
  else if (value.answer is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Questionnaire.item.enableWhen', 'answerDateTime', TFhirDateTime(value.answer), false, -1)
  else if (value.answer is TFhirTime) {6} then
    ComposeTime(this, 'Questionnaire.item.enableWhen', 'answerTime', TFhirTime(value.answer), false, -1)
  else if (value.answer is TFhirString) {6} then
    ComposeString(this, 'Questionnaire.item.enableWhen', 'answerString', TFhirString(value.answer), false, -1);
end;

function TFHIRTurtleParser.ParseQuestionnaireItemAnswerOption(obj : TTurtleComplex) : TFhirQuestionnaireItemAnswerOption;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireItemAnswerOption.create;
  try
    ParseQuestionnaireItemAnswerOptionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireItemAnswerOptionProperties(obj : TTurtleComplex; value : TFhirQuestionnaireItemAnswerOption);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('valueCoding', item) then
      value.value := parseCoding(item);
    if obj.has('valueReference', item) {a3} then
      value.value := ParseReference(item);
    if obj.has('valueInteger', item) then
      value.value := parseInteger(item);
    if obj.has('valueDate', item) then
      value.value := parseDate(item);
    if obj.has('valueTime', item) then
      value.value := parseTime(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    value.initialSelectedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Questionnaire.item.answerOption.initialSelected'));
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireItemAnswerOption(parent :  TTurtleComplex; parentType, name : String; value : TFhirQuestionnaireItemAnswerOption; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireItemAnswerOption');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (value.value is TFhirCoding) {6} then
    ComposeCoding(this, 'Questionnaire.item.answerOption', 'valueCoding', TFhirCoding(value.value), false, -1)
  else if (value.value is TFhirReference) {2} then
    ComposeReference(this, 'Questionnaire.item.answerOption', 'valueReference', TFhirReference(value.value), false,-1)
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Questionnaire.item.answerOption', 'valueInteger', TFhirInteger(value.value), false, -1)
  else if (value.value is TFhirDate) {6} then
    ComposeDate(this, 'Questionnaire.item.answerOption', 'valueDate', TFhirDate(value.value), false, -1)
  else if (value.value is TFhirTime) {6} then
    ComposeTime(this, 'Questionnaire.item.answerOption', 'valueTime', TFhirTime(value.value), false, -1)
  else if (value.value is TFhirString) {6} then
    ComposeString(this, 'Questionnaire.item.answerOption', 'valueString', TFhirString(value.value), false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Questionnaire.item.answerOption', 'initialSelected', value.initialSelectedElement, false, -1);
end;

function TFHIRTurtleParser.ParseQuestionnaireItemInitial(obj : TTurtleComplex) : TFhirQuestionnaireItemInitial;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireItemInitial.create;
  try
    ParseQuestionnaireItemInitialProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireItemInitialProperties(obj : TTurtleComplex; value : TFhirQuestionnaireItemInitial);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('valueAttachment', item) then
      value.value := parseAttachment(item);
    if obj.has('valueCoding', item) then
      value.value := parseCoding(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueReference', item) {a3} then
      value.value := ParseReference(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    if obj.has('valueDecimal', item) then
      value.value := parseDecimal(item);
    if obj.has('valueInteger', item) then
      value.value := parseInteger(item);
    if obj.has('valueDate', item) then
      value.value := parseDate(item);
    if obj.has('valueDateTime', item) then
      value.value := parseDateTime(item);
    if obj.has('valueTime', item) then
      value.value := parseTime(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    if obj.has('valueUri', item) then
      value.value := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireItemInitial(parent :  TTurtleComplex; parentType, name : String; value : TFhirQuestionnaireItemInitial; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireItemInitial');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (value.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Questionnaire.item.initial', 'valueAttachment', TFhirAttachment(value.value), false, -1)
  else if (value.value is TFhirCoding) {6} then
    ComposeCoding(this, 'Questionnaire.item.initial', 'valueCoding', TFhirCoding(value.value), false, -1)
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Questionnaire.item.initial', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (value.value is TFhirReference) {2} then
    ComposeReference(this, 'Questionnaire.item.initial', 'valueReference', TFhirReference(value.value), false,-1)
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Questionnaire.item.initial', 'valueBoolean', TFhirBoolean(value.value), false, -1)
  else if (value.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'Questionnaire.item.initial', 'valueDecimal', TFhirDecimal(value.value), false, -1)
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Questionnaire.item.initial', 'valueInteger', TFhirInteger(value.value), false, -1)
  else if (value.value is TFhirDate) {6} then
    ComposeDate(this, 'Questionnaire.item.initial', 'valueDate', TFhirDate(value.value), false, -1)
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Questionnaire.item.initial', 'valueDateTime', TFhirDateTime(value.value), false, -1)
  else if (value.value is TFhirTime) {6} then
    ComposeTime(this, 'Questionnaire.item.initial', 'valueTime', TFhirTime(value.value), false, -1)
  else if (value.value is TFhirString) {6} then
    ComposeString(this, 'Questionnaire.item.initial', 'valueString', TFhirString(value.value), false, -1)
  else if (value.value is TFhirUri) {6} then
    ComposeUri(this, 'Questionnaire.item.initial', 'valueUri', TFhirUri(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseQuestionnaire(obj : TTurtleComplex) : TFhirQuestionnaire;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaire.create;
  try
    ParseQuestionnaireProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireProperties(obj : TTurtleComplex; value : TFhirQuestionnaire);
var
  item : TTurtleComplex;
begin
    ParseMetadataResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Questionnaire.url'));
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.version'));
    if obj.has('versionAlgorithmCoding', item) then
      value.versionAlgorithm := parseCoding(item);
    if obj.has('versionAlgorithmString', item) then
      value.versionAlgorithm := parseString(item);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.title'));
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.derivedFrom') do
      value.derivedFromList.Add(parseCanonical(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Questionnaire.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Questionnaire.experimental'));
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.subjectType') do
      value.subjectType.Add(parseEnum(item, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Questionnaire.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Questionnaire.description'));
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Questionnaire.purpose'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Questionnaire.copyright'));
    value.copyrightLabelElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.copyrightLabel'));
    value.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Questionnaire.approvalDate'));
    value.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Questionnaire.lastReviewDate'));
    value.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Questionnaire.effectivePeriod'));
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.code') do
      value.codeList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.item') do
      value.itemList.Add(parseQuestionnaireItem(item));
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaire(parent :  TTurtleComplex; parentType, name : String; value : TFhirQuestionnaire; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Questionnaire');
  end;
  composeMetadataResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'Questionnaire', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Questionnaire', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Questionnaire', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirCoding) {6} then
    ComposeCoding(this, 'Questionnaire', 'versionAlgorithmCoding', TFhirCoding(value.versionAlgorithm), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirString) {6} then
    ComposeString(this, 'Questionnaire', 'versionAlgorithmString', TFhirString(value.versionAlgorithm), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Questionnaire', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Questionnaire', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.derivedFromList.Count - 1 do
      ComposeCanonical(this, 'Questionnaire', 'derivedFrom', value.derivedFromList[i], false, i);
  ComposeEnum(this, 'Questionnaire', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Questionnaire', 'experimental', value.experimentalElement, false, -1);
  for i := 0 to value.subjectType.Count - 1 do
      ComposeEnum(this, 'Questionnaire', 'subjectType', value.subjectType[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.subjectType.Count - 1 do
      ComposeEnum(this, 'Questionnaire', 'subjectType', value.subjectType[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Questionnaire', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Questionnaire', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'Questionnaire', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'Questionnaire', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'Questionnaire', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'Questionnaire', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'Questionnaire', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'Questionnaire', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Questionnaire', 'copyrightLabel', value.copyrightLabelElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'Questionnaire', 'approvalDate', value.approvalDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'Questionnaire', 'lastReviewDate', value.lastReviewDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Questionnaire', 'effectivePeriod', value.effectivePeriodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCoding(this, 'Questionnaire', 'code', value.codeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.itemList.Count - 1 do
      ComposeQuestionnaireItem(this, 'Questionnaire', 'item', value.itemList[i], false, i);
end;

{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
function TFHIRTurtleParser.ParseQuestionnaireResponseItem(obj : TTurtleComplex) : TFhirQuestionnaireResponseItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireResponseItem.create;
  try
    ParseQuestionnaireResponseItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireResponseItemProperties(obj : TTurtleComplex; value : TFhirQuestionnaireResponseItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.linkIdElement := ParseString(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.item.linkId'));
    value.definitionElement := ParseUri(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.item.definition'));
    value.textElement := ParseString(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.item.text'));
    for item in obj.complexes('http://hl7.org/fhir/QuestionnaireResponse.item.answer') do
      value.answerList.Add(parseQuestionnaireResponseItemAnswer(item));
    for item in obj.complexes('http://hl7.org/fhir/QuestionnaireResponse.item.item') do
      value.itemList.Add(parseQuestionnaireResponseItem(item));
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireResponseItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirQuestionnaireResponseItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireResponseItem');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'QuestionnaireResponse.item', 'linkId', value.linkIdElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'QuestionnaireResponse.item', 'definition', value.definitionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'QuestionnaireResponse.item', 'text', value.textElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.answerList.Count - 1 do
      ComposeQuestionnaireResponseItemAnswer(this, 'QuestionnaireResponse.item', 'answer', value.answerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.itemList.Count - 1 do
      ComposeQuestionnaireResponseItem(this, 'QuestionnaireResponse.item', 'item', value.itemList[i], false, i);
end;

function TFHIRTurtleParser.ParseQuestionnaireResponseItemAnswer(obj : TTurtleComplex) : TFhirQuestionnaireResponseItemAnswer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireResponseItemAnswer.create;
  try
    ParseQuestionnaireResponseItemAnswerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireResponseItemAnswerProperties(obj : TTurtleComplex; value : TFhirQuestionnaireResponseItemAnswer);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('valueAttachment', item) then
      value.value := parseAttachment(item);
    if obj.has('valueCoding', item) then
      value.value := parseCoding(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueReference', item) {a3} then
      value.value := ParseReference(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    if obj.has('valueDecimal', item) then
      value.value := parseDecimal(item);
    if obj.has('valueInteger', item) then
      value.value := parseInteger(item);
    if obj.has('valueDate', item) then
      value.value := parseDate(item);
    if obj.has('valueDateTime', item) then
      value.value := parseDateTime(item);
    if obj.has('valueTime', item) then
      value.value := parseTime(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    if obj.has('valueUri', item) then
      value.value := parseUri(item);
    for item in obj.complexes('http://hl7.org/fhir/QuestionnaireResponse.item.answer.item') do
      value.itemList.Add(parseQuestionnaireResponseItem(item));
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireResponseItemAnswer(parent :  TTurtleComplex; parentType, name : String; value : TFhirQuestionnaireResponseItemAnswer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireResponseItemAnswer');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (value.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'QuestionnaireResponse.item.answer', 'valueAttachment', TFhirAttachment(value.value), false, -1)
  else if (value.value is TFhirCoding) {6} then
    ComposeCoding(this, 'QuestionnaireResponse.item.answer', 'valueCoding', TFhirCoding(value.value), false, -1)
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'QuestionnaireResponse.item.answer', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (value.value is TFhirReference) {2} then
    ComposeReference(this, 'QuestionnaireResponse.item.answer', 'valueReference', TFhirReference(value.value), false,-1)
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'QuestionnaireResponse.item.answer', 'valueBoolean', TFhirBoolean(value.value), false, -1)
  else if (value.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'QuestionnaireResponse.item.answer', 'valueDecimal', TFhirDecimal(value.value), false, -1)
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(this, 'QuestionnaireResponse.item.answer', 'valueInteger', TFhirInteger(value.value), false, -1)
  else if (value.value is TFhirDate) {6} then
    ComposeDate(this, 'QuestionnaireResponse.item.answer', 'valueDate', TFhirDate(value.value), false, -1)
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'QuestionnaireResponse.item.answer', 'valueDateTime', TFhirDateTime(value.value), false, -1)
  else if (value.value is TFhirTime) {6} then
    ComposeTime(this, 'QuestionnaireResponse.item.answer', 'valueTime', TFhirTime(value.value), false, -1)
  else if (value.value is TFhirString) {6} then
    ComposeString(this, 'QuestionnaireResponse.item.answer', 'valueString', TFhirString(value.value), false, -1)
  else if (value.value is TFhirUri) {6} then
    ComposeUri(this, 'QuestionnaireResponse.item.answer', 'valueUri', TFhirUri(value.value), false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.itemList.Count - 1 do
      ComposeQuestionnaireResponseItem(this, 'QuestionnaireResponse.item.answer', 'item', value.itemList[i], false, i);
end;

function TFHIRTurtleParser.ParseQuestionnaireResponse(obj : TTurtleComplex) : TFhirQuestionnaireResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireResponse.create;
  try
    ParseQuestionnaireResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireResponseProperties(obj : TTurtleComplex; value : TFhirQuestionnaireResponse);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/QuestionnaireResponse.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/QuestionnaireResponse.basedOn') do
      value.basedOnList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/QuestionnaireResponse.partOf') do
      value.partOfList.Add(parseReference(item));
    value.questionnaireElement := ParseCanonical(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.questionnaire'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.status'), CODES_TFhirQuestionnaireResponseStatusEnum, SYSTEMS_TFhirQuestionnaireResponseStatusEnum);
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.subject'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.encounter'));
    value.authoredElement := ParseDateTime(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.authored'));
    value.author := ParseReference(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.author'));
    value.source := ParseReference(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.source'));
    for item in obj.complexes('http://hl7.org/fhir/QuestionnaireResponse.item') do
      value.itemList.Add(parseQuestionnaireResponseItem(item));
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireResponse(parent :  TTurtleComplex; parentType, name : String; value : TFhirQuestionnaireResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireResponse');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'QuestionnaireResponse', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'QuestionnaireResponse', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(this, 'QuestionnaireResponse', 'partOf', value.partOfList[i], false, i);
  ComposeCanonical(this, 'QuestionnaireResponse', 'questionnaire', value.questionnaireElement, false, -1);
  ComposeEnum(this, 'QuestionnaireResponse', 'status', value.statusElement, CODES_TFhirQuestionnaireResponseStatusEnum, SYSTEMS_TFhirQuestionnaireResponseStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'QuestionnaireResponse', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'QuestionnaireResponse', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'QuestionnaireResponse', 'authored', value.authoredElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'QuestionnaireResponse', 'author', value.authorElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'QuestionnaireResponse', 'source', value.sourceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.itemList.Count - 1 do
      ComposeQuestionnaireResponseItem(this, 'QuestionnaireResponse', 'item', value.itemList[i], false, i);
end;

{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REGULATEDAUTHORIZATION}
function TFHIRTurtleParser.ParseRegulatedAuthorizationCase(obj : TTurtleComplex) : TFhirRegulatedAuthorizationCase;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRegulatedAuthorizationCase.create;
  try
    ParseRegulatedAuthorizationCaseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRegulatedAuthorizationCaseProperties(obj : TTurtleComplex; value : TFhirRegulatedAuthorizationCase);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/RegulatedAuthorization.case.identifier'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RegulatedAuthorization.case.type'));
    value.status := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RegulatedAuthorization.case.status'));
    if obj.has('datePeriod', item) then
      value.date := parsePeriod(item);
    if obj.has('dateDateTime', item) then
      value.date := parseDateTime(item);
    for item in obj.complexes('http://hl7.org/fhir/RegulatedAuthorization.case.application') do
      value.applicationList.Add(parseRegulatedAuthorizationCase(item));
end;

procedure TFHIRTurtleComposer.ComposeRegulatedAuthorizationCase(parent :  TTurtleComplex; parentType, name : String; value : TFhirRegulatedAuthorizationCase; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RegulatedAuthorizationCase');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'RegulatedAuthorization.case', 'identifier', value.identifierElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'RegulatedAuthorization.case', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'RegulatedAuthorization.case', 'status', value.statusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.date is TFhirPeriod) {6} then
    ComposePeriod(this, 'RegulatedAuthorization.case', 'datePeriod', TFhirPeriod(value.date), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.date is TFhirDateTime) {6} then
    ComposeDateTime(this, 'RegulatedAuthorization.case', 'dateDateTime', TFhirDateTime(value.date), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.applicationList.Count - 1 do
      ComposeRegulatedAuthorizationCase(this, 'RegulatedAuthorization.case', 'application', value.applicationList[i], false, i);
end;

function TFHIRTurtleParser.ParseRegulatedAuthorization(obj : TTurtleComplex) : TFhirRegulatedAuthorization;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRegulatedAuthorization.create;
  try
    ParseRegulatedAuthorizationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRegulatedAuthorizationProperties(obj : TTurtleComplex; value : TFhirRegulatedAuthorization);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/RegulatedAuthorization.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/RegulatedAuthorization.subject') do
      value.subjectList.Add(parseReference(item));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RegulatedAuthorization.type'));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/RegulatedAuthorization.description'));
    for item in obj.complexes('http://hl7.org/fhir/RegulatedAuthorization.region') do
      value.regionList.Add(parseCodeableConcept(item));
    value.status := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RegulatedAuthorization.status'));
    value.statusDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/RegulatedAuthorization.statusDate'));
    value.validityPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/RegulatedAuthorization.validityPeriod'));
    for item in obj.complexes('http://hl7.org/fhir/RegulatedAuthorization.indication') do
      value.indicationList.Add(parseCodeableReference(item));
    value.intendedUse := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RegulatedAuthorization.intendedUse'));
    for item in obj.complexes('http://hl7.org/fhir/RegulatedAuthorization.basis') do
      value.basisList.Add(parseCodeableConcept(item));
    value.holder := ParseReference(obj.complex('http://hl7.org/fhir/RegulatedAuthorization.holder'));
    value.regulator := ParseReference(obj.complex('http://hl7.org/fhir/RegulatedAuthorization.regulator'));
    for item in obj.complexes('http://hl7.org/fhir/RegulatedAuthorization.attachedDocument') do
      value.attachedDocumentList.Add(parseReference(item));
    value.case_ := ParseRegulatedAuthorizationCase(obj.complex('http://hl7.org/fhir/RegulatedAuthorization.case'));
end;

procedure TFHIRTurtleComposer.ComposeRegulatedAuthorization(parent :  TTurtleComplex; parentType, name : String; value : TFhirRegulatedAuthorization; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RegulatedAuthorization');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'RegulatedAuthorization', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.subjectList.Count - 1 do
      ComposeReference(this, 'RegulatedAuthorization', 'subject', value.subjectList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'RegulatedAuthorization', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'RegulatedAuthorization', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.regionList.Count - 1 do
      ComposeCodeableConcept(this, 'RegulatedAuthorization', 'region', value.regionList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'RegulatedAuthorization', 'status', value.statusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'RegulatedAuthorization', 'statusDate', value.statusDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'RegulatedAuthorization', 'validityPeriod', value.validityPeriodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.indicationList.Count - 1 do
      ComposeCodeableReference(this, 'RegulatedAuthorization', 'indication', value.indicationList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'RegulatedAuthorization', 'intendedUse', value.intendedUseElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basisList.Count - 1 do
      ComposeCodeableConcept(this, 'RegulatedAuthorization', 'basis', value.basisList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'RegulatedAuthorization', 'holder', value.holderElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'RegulatedAuthorization', 'regulator', value.regulatorElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.attachedDocumentList.Count - 1 do
      ComposeReference(this, 'RegulatedAuthorization', 'attachedDocument', value.attachedDocumentList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRegulatedAuthorizationCase(this, 'RegulatedAuthorization', 'case', value.case_Element, false, -1);
end;

{$ENDIF FHIR_REGULATEDAUTHORIZATION}
{$IFDEF FHIR_RELATEDPERSON}
function TFHIRTurtleParser.ParseRelatedPersonCommunication(obj : TTurtleComplex) : TFhirRelatedPersonCommunication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRelatedPersonCommunication.create;
  try
    ParseRelatedPersonCommunicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRelatedPersonCommunicationProperties(obj : TTurtleComplex; value : TFhirRelatedPersonCommunication);
begin
    ParseBackboneElementProperties(obj, value);
    value.language := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RelatedPerson.communication.language'));
    value.preferredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/RelatedPerson.communication.preferred'));
end;

procedure TFHIRTurtleComposer.ComposeRelatedPersonCommunication(parent :  TTurtleComplex; parentType, name : String; value : TFhirRelatedPersonCommunication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RelatedPersonCommunication');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'RelatedPerson.communication', 'language', value.languageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'RelatedPerson.communication', 'preferred', value.preferredElement, false, -1);
end;

function TFHIRTurtleParser.ParseRelatedPerson(obj : TTurtleComplex) : TFhirRelatedPerson;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRelatedPerson.create;
  try
    ParseRelatedPersonProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRelatedPersonProperties(obj : TTurtleComplex; value : TFhirRelatedPerson);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/RelatedPerson.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/RelatedPerson.active'));
    value.patient := ParseReference(obj.complex('http://hl7.org/fhir/RelatedPerson.patient'));
    for item in obj.complexes('http://hl7.org/fhir/RelatedPerson.relationship') do
      value.relationshipList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/RelatedPerson.name') do
      value.nameList.Add(parseHumanName(item));
    for item in obj.complexes('http://hl7.org/fhir/RelatedPerson.telecom') do
      value.telecomList.Add(parseContactPoint(item));
    value.genderElement := ParseEnum(obj.complex('http://hl7.org/fhir/RelatedPerson.gender'), CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    value.birthDateElement := ParseDate(obj.complex('http://hl7.org/fhir/RelatedPerson.birthDate'));
    for item in obj.complexes('http://hl7.org/fhir/RelatedPerson.address') do
      value.addressList.Add(parseAddress(item));
    for item in obj.complexes('http://hl7.org/fhir/RelatedPerson.photo') do
      value.photoList.Add(parseAttachment(item));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/RelatedPerson.period'));
    for item in obj.complexes('http://hl7.org/fhir/RelatedPerson.communication') do
      value.communicationList.Add(parseRelatedPersonCommunication(item));
end;

procedure TFHIRTurtleComposer.ComposeRelatedPerson(parent :  TTurtleComplex; parentType, name : String; value : TFhirRelatedPerson; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RelatedPerson');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'RelatedPerson', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'RelatedPerson', 'active', value.activeElement, false, -1);
  ComposeReference(this, 'RelatedPerson', 'patient', value.patientElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.relationshipList.Count - 1 do
      ComposeCodeableConcept(this, 'RelatedPerson', 'relationship', value.relationshipList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.nameList.Count - 1 do
      ComposeHumanName(this, 'RelatedPerson', 'name', value.nameList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.telecomList.Count - 1 do
      ComposeContactPoint(this, 'RelatedPerson', 'telecom', value.telecomList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'RelatedPerson', 'gender', value.genderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'RelatedPerson', 'birthDate', value.birthDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.addressList.Count - 1 do
      ComposeAddress(this, 'RelatedPerson', 'address', value.addressList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.photoList.Count - 1 do
      ComposeAttachment(this, 'RelatedPerson', 'photo', value.photoList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'RelatedPerson', 'period', value.periodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.communicationList.Count - 1 do
      ComposeRelatedPersonCommunication(this, 'RelatedPerson', 'communication', value.communicationList[i], false, i);
end;

{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
function TFHIRTurtleParser.ParseRequestGroupAction(obj : TTurtleComplex) : TFhirRequestGroupAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRequestGroupAction.create;
  try
    ParseRequestGroupActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRequestGroupActionProperties(obj : TTurtleComplex; value : TFhirRequestGroupAction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.linkIdElement := ParseString(obj.complex('http://hl7.org/fhir/RequestGroup.action.linkId'));
    value.prefixElement := ParseString(obj.complex('http://hl7.org/fhir/RequestGroup.action.prefix'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/RequestGroup.action.title'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/RequestGroup.action.description'));
    value.textEquivalentElement := ParseString(obj.complex('http://hl7.org/fhir/RequestGroup.action.textEquivalent'));
    value.priorityElement := ParseCode(obj.complex('http://hl7.org/fhir/RequestGroup.action.priority'));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.action.code') do
      value.codeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.action.documentation') do
      value.documentationList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.action.goal') do
      value.goalList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.action.condition') do
      value.conditionList.Add(parseRequestGroupActionCondition(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.action.relatedAction') do
      value.relatedActionList.Add(parseRequestGroupActionRelatedAction(item));
    if obj.has('timingAge', item) then
      value.timing := parseAge(item);
    if obj.has('timingPeriod', item) then
      value.timing := parsePeriod(item);
    if obj.has('timingDuration', item) then
      value.timing := parseDuration(item);
    if obj.has('timingRange', item) then
      value.timing := parseRange(item);
    if obj.has('timingTiming', item) then
      value.timing := parseTiming(item);
    if obj.has('timingDateTime', item) then
      value.timing := parseDateTime(item);
    value.location := ParseCodeableReference(obj.complex('http://hl7.org/fhir/RequestGroup.action.location'));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.action.participant') do
      value.participantList.Add(parseRequestGroupActionParticipant(item));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RequestGroup.action.type'));
    value.groupingBehaviorElement := ParseCode(obj.complex('http://hl7.org/fhir/RequestGroup.action.groupingBehavior'));
    value.selectionBehaviorElement := ParseCode(obj.complex('http://hl7.org/fhir/RequestGroup.action.selectionBehavior'));
    value.requiredBehaviorElement := ParseCode(obj.complex('http://hl7.org/fhir/RequestGroup.action.requiredBehavior'));
    value.precheckBehaviorElement := ParseCode(obj.complex('http://hl7.org/fhir/RequestGroup.action.precheckBehavior'));
    value.cardinalityBehaviorElement := ParseCode(obj.complex('http://hl7.org/fhir/RequestGroup.action.cardinalityBehavior'));
    value.resource := ParseReference(obj.complex('http://hl7.org/fhir/RequestGroup.action.resource'));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.action.action') do
      value.actionList.Add(parseRequestGroupAction(item));
end;

procedure TFHIRTurtleComposer.ComposeRequestGroupAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestGroupAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RequestGroupAction');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RequestGroup.action', 'linkId', value.linkIdElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RequestGroup.action', 'prefix', value.prefixElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RequestGroup.action', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'RequestGroup.action', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'RequestGroup.action', 'textEquivalent', value.textEquivalentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'RequestGroup.action', 'priority', value.priorityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCodeableConcept(this, 'RequestGroup.action', 'code', value.codeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.documentationList.Count - 1 do
      ComposeRelatedArtifact(this, 'RequestGroup.action', 'documentation', value.documentationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.goalList.Count - 1 do
      ComposeReference(this, 'RequestGroup.action', 'goal', value.goalList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.conditionList.Count - 1 do
      ComposeRequestGroupActionCondition(this, 'RequestGroup.action', 'condition', value.conditionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedActionList.Count - 1 do
      ComposeRequestGroupActionRelatedAction(this, 'RequestGroup.action', 'relatedAction', value.relatedActionList[i], false, i);
  if (SummaryOption in [soFull, soData]) and (value.timing is TFhirAge) {6} then
    ComposeAge(this, 'RequestGroup.action', 'timingAge', TFhirAge(value.timing), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirPeriod) {6} then
    ComposePeriod(this, 'RequestGroup.action', 'timingPeriod', TFhirPeriod(value.timing), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirDuration) {6} then
    ComposeDuration(this, 'RequestGroup.action', 'timingDuration', TFhirDuration(value.timing), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirRange) {6} then
    ComposeRange(this, 'RequestGroup.action', 'timingRange', TFhirRange(value.timing), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirTiming) {6} then
    ComposeTiming(this, 'RequestGroup.action', 'timingTiming', TFhirTiming(value.timing), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirDateTime) {6} then
    ComposeDateTime(this, 'RequestGroup.action', 'timingDateTime', TFhirDateTime(value.timing), false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(this, 'RequestGroup.action', 'location', value.locationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.participantList.Count - 1 do
      ComposeRequestGroupActionParticipant(this, 'RequestGroup.action', 'participant', value.participantList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'RequestGroup.action', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'RequestGroup.action', 'groupingBehavior', value.groupingBehaviorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'RequestGroup.action', 'selectionBehavior', value.selectionBehaviorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'RequestGroup.action', 'requiredBehavior', value.requiredBehaviorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'RequestGroup.action', 'precheckBehavior', value.precheckBehaviorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'RequestGroup.action', 'cardinalityBehavior', value.cardinalityBehaviorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'RequestGroup.action', 'resource', value.resourceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.actionList.Count - 1 do
      ComposeRequestGroupAction(this, 'RequestGroup.action', 'action', value.actionList[i], false, i);
end;

function TFHIRTurtleParser.ParseRequestGroupActionCondition(obj : TTurtleComplex) : TFhirRequestGroupActionCondition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRequestGroupActionCondition.create;
  try
    ParseRequestGroupActionConditionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRequestGroupActionConditionProperties(obj : TTurtleComplex; value : TFhirRequestGroupActionCondition);
begin
    ParseBackboneElementProperties(obj, value);
    value.kindElement := ParseCode(obj.complex('http://hl7.org/fhir/RequestGroup.action.condition.kind'));
    value.expression := ParseExpression(obj.complex('http://hl7.org/fhir/RequestGroup.action.condition.expression'));
end;

procedure TFHIRTurtleComposer.ComposeRequestGroupActionCondition(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestGroupActionCondition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RequestGroupActionCondition');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCode(this, 'RequestGroup.action.condition', 'kind', value.kindElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeExpression(this, 'RequestGroup.action.condition', 'expression', value.expressionElement, false, -1);
end;

function TFHIRTurtleParser.ParseRequestGroupActionRelatedAction(obj : TTurtleComplex) : TFhirRequestGroupActionRelatedAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRequestGroupActionRelatedAction.create;
  try
    ParseRequestGroupActionRelatedActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRequestGroupActionRelatedActionProperties(obj : TTurtleComplex; value : TFhirRequestGroupActionRelatedAction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.targetIdElement := ParseId(obj.complex('http://hl7.org/fhir/RequestGroup.action.relatedAction.targetId'));
    value.relationshipElement := ParseCode(obj.complex('http://hl7.org/fhir/RequestGroup.action.relatedAction.relationship'));
    if obj.has('offsetDuration', item) then
      value.offset := parseDuration(item);
    if obj.has('offsetRange', item) then
      value.offset := parseRange(item);
end;

procedure TFHIRTurtleComposer.ComposeRequestGroupActionRelatedAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestGroupActionRelatedAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RequestGroupActionRelatedAction');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeId(this, 'RequestGroup.action.relatedAction', 'targetId', value.targetIdElement, false, -1);
  ComposeCode(this, 'RequestGroup.action.relatedAction', 'relationship', value.relationshipElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.offset is TFhirDuration) {6} then
    ComposeDuration(this, 'RequestGroup.action.relatedAction', 'offsetDuration', TFhirDuration(value.offset), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.offset is TFhirRange) {6} then
    ComposeRange(this, 'RequestGroup.action.relatedAction', 'offsetRange', TFhirRange(value.offset), false, -1);
end;

function TFHIRTurtleParser.ParseRequestGroupActionParticipant(obj : TTurtleComplex) : TFhirRequestGroupActionParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRequestGroupActionParticipant.create;
  try
    ParseRequestGroupActionParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRequestGroupActionParticipantProperties(obj : TTurtleComplex; value : TFhirRequestGroupActionParticipant);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_Element := ParseCode(obj.complex('http://hl7.org/fhir/RequestGroup.action.participant.type'));
    value.typeReference := ParseReference(obj.complex('http://hl7.org/fhir/RequestGroup.action.participant.typeReference'));
    value.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RequestGroup.action.participant.role'));
    value.function_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RequestGroup.action.participant.function'));
    value.actor := ParseReference(obj.complex('http://hl7.org/fhir/RequestGroup.action.participant.actor'));
end;

procedure TFHIRTurtleComposer.ComposeRequestGroupActionParticipant(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestGroupActionParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RequestGroupActionParticipant');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'RequestGroup.action.participant', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'RequestGroup.action.participant', 'typeReference', value.typeReferenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'RequestGroup.action.participant', 'role', value.roleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'RequestGroup.action.participant', 'function', value.function_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'RequestGroup.action.participant', 'actor', value.actorElement, false, -1);
end;

function TFHIRTurtleParser.ParseRequestGroup(obj : TTurtleComplex) : TFhirRequestGroup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRequestGroup.create;
  try
    ParseRequestGroupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRequestGroupProperties(obj : TTurtleComplex; value : TFhirRequestGroup);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.instantiatesCanonical') do
      value.instantiatesCanonicalList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.instantiatesUri') do
      value.instantiatesUriList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.basedOn') do
      value.basedOnList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.replaces') do
      value.replacesList.Add(parseReference(item));
    value.groupIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/RequestGroup.groupIdentifier'));
    value.statusElement := ParseCode(obj.complex('http://hl7.org/fhir/RequestGroup.status'));
    value.intentElement := ParseCode(obj.complex('http://hl7.org/fhir/RequestGroup.intent'));
    value.priorityElement := ParseCode(obj.complex('http://hl7.org/fhir/RequestGroup.priority'));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RequestGroup.code'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/RequestGroup.subject'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/RequestGroup.encounter'));
    value.authoredOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/RequestGroup.authoredOn'));
    value.author := ParseReference(obj.complex('http://hl7.org/fhir/RequestGroup.author'));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.reason') do
      value.reasonList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.goal') do
      value.goalList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.action') do
      value.actionList.Add(parseRequestGroupAction(item));
end;

procedure TFHIRTurtleComposer.ComposeRequestGroup(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestGroup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RequestGroup');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'RequestGroup', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(this, 'RequestGroup', 'instantiatesCanonical', value.instantiatesCanonicalList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesUriList.Count - 1 do
      ComposeUri(this, 'RequestGroup', 'instantiatesUri', value.instantiatesUriList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'RequestGroup', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.replacesList.Count - 1 do
      ComposeReference(this, 'RequestGroup', 'replaces', value.replacesList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'RequestGroup', 'groupIdentifier', value.groupIdentifierElement, false, -1);
  ComposeCode(this, 'RequestGroup', 'status', value.statusElement, false, -1);
  ComposeCode(this, 'RequestGroup', 'intent', value.intentElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(this, 'RequestGroup', 'priority', value.priorityElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'RequestGroup', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'RequestGroup', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'RequestGroup', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'RequestGroup', 'authoredOn', value.authoredOnElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'RequestGroup', 'author', value.authorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(this, 'RequestGroup', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.goalList.Count - 1 do
      ComposeReference(this, 'RequestGroup', 'goal', value.goalList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'RequestGroup', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.actionList.Count - 1 do
      ComposeRequestGroupAction(this, 'RequestGroup', 'action', value.actionList[i], false, i);
end;

{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_REQUESTORCHESTRATION}
function TFHIRTurtleParser.ParseRequestOrchestrationAction(obj : TTurtleComplex) : TFhirRequestOrchestrationAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRequestOrchestrationAction.create;
  try
    ParseRequestOrchestrationActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRequestOrchestrationActionProperties(obj : TTurtleComplex; value : TFhirRequestOrchestrationAction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.linkIdElement := ParseString(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.linkId'));
    value.prefixElement := ParseString(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.prefix'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.title'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.description'));
    value.textEquivalentElement := ParseString(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.textEquivalent'));
    value.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    for item in obj.complexes('http://hl7.org/fhir/RequestOrchestration.action.code') do
      value.codeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestOrchestration.action.documentation') do
      value.documentationList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestOrchestration.action.goal') do
      value.goalList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestOrchestration.action.condition') do
      value.conditionList.Add(parseRequestOrchestrationActionCondition(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestOrchestration.action.input') do
      value.inputList.Add(parseRequestOrchestrationActionInput(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestOrchestration.action.output') do
      value.outputList.Add(parseRequestOrchestrationActionOutput(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestOrchestration.action.relatedAction') do
      value.relatedActionList.Add(parseRequestOrchestrationActionRelatedAction(item));
    if obj.has('timingAge', item) then
      value.timing := parseAge(item);
    if obj.has('timingPeriod', item) then
      value.timing := parsePeriod(item);
    if obj.has('timingDuration', item) then
      value.timing := parseDuration(item);
    if obj.has('timingRange', item) then
      value.timing := parseRange(item);
    if obj.has('timingTiming', item) then
      value.timing := parseTiming(item);
    if obj.has('timingDateTime', item) then
      value.timing := parseDateTime(item);
    value.location := ParseCodeableReference(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.location'));
    for item in obj.complexes('http://hl7.org/fhir/RequestOrchestration.action.participant') do
      value.participantList.Add(parseRequestOrchestrationActionParticipant(item));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.type'));
    value.groupingBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.groupingBehavior'), CODES_TFhirActionGroupingBehaviorEnum, SYSTEMS_TFhirActionGroupingBehaviorEnum);
    value.selectionBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.selectionBehavior'), CODES_TFhirActionSelectionBehaviorEnum, SYSTEMS_TFhirActionSelectionBehaviorEnum);
    value.requiredBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.requiredBehavior'), CODES_TFhirActionRequiredBehaviorEnum, SYSTEMS_TFhirActionRequiredBehaviorEnum);
    value.precheckBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.precheckBehavior'), CODES_TFhirActionPrecheckBehaviorEnum, SYSTEMS_TFhirActionPrecheckBehaviorEnum);
    value.cardinalityBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.cardinalityBehavior'), CODES_TFhirActionCardinalityBehaviorEnum, SYSTEMS_TFhirActionCardinalityBehaviorEnum);
    value.resource := ParseReference(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.resource'));
    if obj.has('definitionCanonical', item) then
      value.definition := parseCanonical(item);
    if obj.has('definitionUri', item) then
      value.definition := parseUri(item);
    value.transformElement := ParseCanonical(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.transform'));
    for item in obj.complexes('http://hl7.org/fhir/RequestOrchestration.action.dynamicValue') do
      value.dynamicValueList.Add(parseRequestOrchestrationActionDynamicValue(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestOrchestration.action.action') do
      value.actionList.Add(parseRequestOrchestrationAction(item));
end;

procedure TFHIRTurtleComposer.ComposeRequestOrchestrationAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestOrchestrationAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RequestOrchestrationAction');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RequestOrchestration.action', 'linkId', value.linkIdElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RequestOrchestration.action', 'prefix', value.prefixElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RequestOrchestration.action', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'RequestOrchestration.action', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'RequestOrchestration.action', 'textEquivalent', value.textEquivalentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'RequestOrchestration.action', 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeCodeableConcept(this, 'RequestOrchestration.action', 'code', value.codeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.documentationList.Count - 1 do
      ComposeRelatedArtifact(this, 'RequestOrchestration.action', 'documentation', value.documentationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.goalList.Count - 1 do
      ComposeReference(this, 'RequestOrchestration.action', 'goal', value.goalList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.conditionList.Count - 1 do
      ComposeRequestOrchestrationActionCondition(this, 'RequestOrchestration.action', 'condition', value.conditionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.inputList.Count - 1 do
      ComposeRequestOrchestrationActionInput(this, 'RequestOrchestration.action', 'input', value.inputList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.outputList.Count - 1 do
      ComposeRequestOrchestrationActionOutput(this, 'RequestOrchestration.action', 'output', value.outputList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedActionList.Count - 1 do
      ComposeRequestOrchestrationActionRelatedAction(this, 'RequestOrchestration.action', 'relatedAction', value.relatedActionList[i], false, i);
  if (SummaryOption in [soFull, soData]) and (value.timing is TFhirAge) {6} then
    ComposeAge(this, 'RequestOrchestration.action', 'timingAge', TFhirAge(value.timing), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirPeriod) {6} then
    ComposePeriod(this, 'RequestOrchestration.action', 'timingPeriod', TFhirPeriod(value.timing), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirDuration) {6} then
    ComposeDuration(this, 'RequestOrchestration.action', 'timingDuration', TFhirDuration(value.timing), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirRange) {6} then
    ComposeRange(this, 'RequestOrchestration.action', 'timingRange', TFhirRange(value.timing), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirTiming) {6} then
    ComposeTiming(this, 'RequestOrchestration.action', 'timingTiming', TFhirTiming(value.timing), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.timing is TFhirDateTime) {6} then
    ComposeDateTime(this, 'RequestOrchestration.action', 'timingDateTime', TFhirDateTime(value.timing), false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(this, 'RequestOrchestration.action', 'location', value.locationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.participantList.Count - 1 do
      ComposeRequestOrchestrationActionParticipant(this, 'RequestOrchestration.action', 'participant', value.participantList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'RequestOrchestration.action', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'RequestOrchestration.action', 'groupingBehavior', value.groupingBehaviorElement, CODES_TFhirActionGroupingBehaviorEnum, SYSTEMS_TFhirActionGroupingBehaviorEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'RequestOrchestration.action', 'selectionBehavior', value.selectionBehaviorElement, CODES_TFhirActionSelectionBehaviorEnum, SYSTEMS_TFhirActionSelectionBehaviorEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'RequestOrchestration.action', 'requiredBehavior', value.requiredBehaviorElement, CODES_TFhirActionRequiredBehaviorEnum, SYSTEMS_TFhirActionRequiredBehaviorEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'RequestOrchestration.action', 'precheckBehavior', value.precheckBehaviorElement, CODES_TFhirActionPrecheckBehaviorEnum, SYSTEMS_TFhirActionPrecheckBehaviorEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'RequestOrchestration.action', 'cardinalityBehavior', value.cardinalityBehaviorElement, CODES_TFhirActionCardinalityBehaviorEnum, SYSTEMS_TFhirActionCardinalityBehaviorEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'RequestOrchestration.action', 'resource', value.resourceElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.definition is TFhirCanonical) {6} then
    ComposeCanonical(this, 'RequestOrchestration.action', 'definitionCanonical', TFhirCanonical(value.definition), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.definition is TFhirUri) {6} then
    ComposeUri(this, 'RequestOrchestration.action', 'definitionUri', TFhirUri(value.definition), false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'RequestOrchestration.action', 'transform', value.transformElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.dynamicValueList.Count - 1 do
      ComposeRequestOrchestrationActionDynamicValue(this, 'RequestOrchestration.action', 'dynamicValue', value.dynamicValueList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.actionList.Count - 1 do
      ComposeRequestOrchestrationAction(this, 'RequestOrchestration.action', 'action', value.actionList[i], false, i);
end;

function TFHIRTurtleParser.ParseRequestOrchestrationActionCondition(obj : TTurtleComplex) : TFhirRequestOrchestrationActionCondition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRequestOrchestrationActionCondition.create;
  try
    ParseRequestOrchestrationActionConditionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRequestOrchestrationActionConditionProperties(obj : TTurtleComplex; value : TFhirRequestOrchestrationActionCondition);
begin
    ParseBackboneElementProperties(obj, value);
    value.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.condition.kind'), CODES_TFhirActionConditionKindEnum, SYSTEMS_TFhirActionConditionKindEnum);
    value.expression := ParseExpression(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.condition.expression'));
end;

procedure TFHIRTurtleComposer.ComposeRequestOrchestrationActionCondition(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestOrchestrationActionCondition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RequestOrchestrationActionCondition');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'RequestOrchestration.action.condition', 'kind', value.kindElement, CODES_TFhirActionConditionKindEnum, SYSTEMS_TFhirActionConditionKindEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeExpression(this, 'RequestOrchestration.action.condition', 'expression', value.expressionElement, false, -1);
end;

function TFHIRTurtleParser.ParseRequestOrchestrationActionInput(obj : TTurtleComplex) : TFhirRequestOrchestrationActionInput;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRequestOrchestrationActionInput.create;
  try
    ParseRequestOrchestrationActionInputProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRequestOrchestrationActionInputProperties(obj : TTurtleComplex; value : TFhirRequestOrchestrationActionInput);
begin
    ParseBackboneElementProperties(obj, value);
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.input.title'));
    value.requirement := ParseDataRequirement(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.input.requirement'));
    value.relatedDataElement := ParseId(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.input.relatedData'));
end;

procedure TFHIRTurtleComposer.ComposeRequestOrchestrationActionInput(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestOrchestrationActionInput; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RequestOrchestrationActionInput');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RequestOrchestration.action.input', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDataRequirement(this, 'RequestOrchestration.action.input', 'requirement', value.requirementElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'RequestOrchestration.action.input', 'relatedData', value.relatedDataElement, false, -1);
end;

function TFHIRTurtleParser.ParseRequestOrchestrationActionOutput(obj : TTurtleComplex) : TFhirRequestOrchestrationActionOutput;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRequestOrchestrationActionOutput.create;
  try
    ParseRequestOrchestrationActionOutputProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRequestOrchestrationActionOutputProperties(obj : TTurtleComplex; value : TFhirRequestOrchestrationActionOutput);
begin
    ParseBackboneElementProperties(obj, value);
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.output.title'));
    value.requirement := ParseDataRequirement(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.output.requirement'));
    value.relatedDataElement := ParseString(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.output.relatedData'));
end;

procedure TFHIRTurtleComposer.ComposeRequestOrchestrationActionOutput(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestOrchestrationActionOutput; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RequestOrchestrationActionOutput');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RequestOrchestration.action.output', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDataRequirement(this, 'RequestOrchestration.action.output', 'requirement', value.requirementElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RequestOrchestration.action.output', 'relatedData', value.relatedDataElement, false, -1);
end;

function TFHIRTurtleParser.ParseRequestOrchestrationActionRelatedAction(obj : TTurtleComplex) : TFhirRequestOrchestrationActionRelatedAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRequestOrchestrationActionRelatedAction.create;
  try
    ParseRequestOrchestrationActionRelatedActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRequestOrchestrationActionRelatedActionProperties(obj : TTurtleComplex; value : TFhirRequestOrchestrationActionRelatedAction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.targetIdElement := ParseId(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.relatedAction.targetId'));
    value.relationshipElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.relatedAction.relationship'), CODES_TFhirActionRelationshipTypeEnum, SYSTEMS_TFhirActionRelationshipTypeEnum);
    if obj.has('offsetDuration', item) then
      value.offset := parseDuration(item);
    if obj.has('offsetRange', item) then
      value.offset := parseRange(item);
end;

procedure TFHIRTurtleComposer.ComposeRequestOrchestrationActionRelatedAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestOrchestrationActionRelatedAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RequestOrchestrationActionRelatedAction');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeId(this, 'RequestOrchestration.action.relatedAction', 'targetId', value.targetIdElement, false, -1);
  ComposeEnum(this, 'RequestOrchestration.action.relatedAction', 'relationship', value.relationshipElement, CODES_TFhirActionRelationshipTypeEnum, SYSTEMS_TFhirActionRelationshipTypeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.offset is TFhirDuration) {6} then
    ComposeDuration(this, 'RequestOrchestration.action.relatedAction', 'offsetDuration', TFhirDuration(value.offset), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.offset is TFhirRange) {6} then
    ComposeRange(this, 'RequestOrchestration.action.relatedAction', 'offsetRange', TFhirRange(value.offset), false, -1);
end;

function TFHIRTurtleParser.ParseRequestOrchestrationActionParticipant(obj : TTurtleComplex) : TFhirRequestOrchestrationActionParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRequestOrchestrationActionParticipant.create;
  try
    ParseRequestOrchestrationActionParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRequestOrchestrationActionParticipantProperties(obj : TTurtleComplex; value : TFhirRequestOrchestrationActionParticipant);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.participant.type'), CODES_TFhirActionParticipantTypeEnum, SYSTEMS_TFhirActionParticipantTypeEnum);
    value.typeCanonicalElement := ParseCanonical(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.participant.typeCanonical'));
    value.typeReference := ParseReference(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.participant.typeReference'));
    value.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.participant.role'));
    value.function_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.participant.function'));
    if obj.has('actorCanonical', item) then
      value.actor := parseCanonical(item);
    if obj.has('actorReference', item) {a3} then
      value.actor := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeRequestOrchestrationActionParticipant(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestOrchestrationActionParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RequestOrchestrationActionParticipant');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'RequestOrchestration.action.participant', 'type', value.type_Element, CODES_TFhirActionParticipantTypeEnum, SYSTEMS_TFhirActionParticipantTypeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'RequestOrchestration.action.participant', 'typeCanonical', value.typeCanonicalElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'RequestOrchestration.action.participant', 'typeReference', value.typeReferenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'RequestOrchestration.action.participant', 'role', value.roleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'RequestOrchestration.action.participant', 'function', value.function_Element, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.actor is TFhirCanonical) {6} then
    ComposeCanonical(this, 'RequestOrchestration.action.participant', 'actorCanonical', TFhirCanonical(value.actor), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.actor is TFhirReference) {2} then
    ComposeReference(this, 'RequestOrchestration.action.participant', 'actorReference', TFhirReference(value.actor), false,-1);
end;

function TFHIRTurtleParser.ParseRequestOrchestrationActionDynamicValue(obj : TTurtleComplex) : TFhirRequestOrchestrationActionDynamicValue;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRequestOrchestrationActionDynamicValue.create;
  try
    ParseRequestOrchestrationActionDynamicValueProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRequestOrchestrationActionDynamicValueProperties(obj : TTurtleComplex; value : TFhirRequestOrchestrationActionDynamicValue);
begin
    ParseBackboneElementProperties(obj, value);
    value.pathElement := ParseString(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.dynamicValue.path'));
    value.expression := ParseExpression(obj.complex('http://hl7.org/fhir/RequestOrchestration.action.dynamicValue.expression'));
end;

procedure TFHIRTurtleComposer.ComposeRequestOrchestrationActionDynamicValue(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestOrchestrationActionDynamicValue; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RequestOrchestrationActionDynamicValue');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RequestOrchestration.action.dynamicValue', 'path', value.pathElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeExpression(this, 'RequestOrchestration.action.dynamicValue', 'expression', value.expressionElement, false, -1);
end;

function TFHIRTurtleParser.ParseRequestOrchestration(obj : TTurtleComplex) : TFhirRequestOrchestration;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRequestOrchestration.create;
  try
    ParseRequestOrchestrationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRequestOrchestrationProperties(obj : TTurtleComplex; value : TFhirRequestOrchestration);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/RequestOrchestration.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestOrchestration.instantiatesCanonical') do
      value.instantiatesCanonicalList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestOrchestration.instantiatesUri') do
      value.instantiatesUriList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestOrchestration.basedOn') do
      value.basedOnList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestOrchestration.replaces') do
      value.replacesList.Add(parseReference(item));
    value.groupIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/RequestOrchestration.groupIdentifier'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestOrchestration.status'), CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum);
    value.intentElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestOrchestration.intent'), CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum);
    value.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestOrchestration.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RequestOrchestration.code'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/RequestOrchestration.subject'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/RequestOrchestration.encounter'));
    value.authoredOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/RequestOrchestration.authoredOn'));
    value.author := ParseReference(obj.complex('http://hl7.org/fhir/RequestOrchestration.author'));
    for item in obj.complexes('http://hl7.org/fhir/RequestOrchestration.reason') do
      value.reasonList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestOrchestration.goal') do
      value.goalList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestOrchestration.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestOrchestration.action') do
      value.actionList.Add(parseRequestOrchestrationAction(item));
end;

procedure TFHIRTurtleComposer.ComposeRequestOrchestration(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequestOrchestration; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RequestOrchestration');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'RequestOrchestration', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(this, 'RequestOrchestration', 'instantiatesCanonical', value.instantiatesCanonicalList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesUriList.Count - 1 do
      ComposeUri(this, 'RequestOrchestration', 'instantiatesUri', value.instantiatesUriList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'RequestOrchestration', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.replacesList.Count - 1 do
      ComposeReference(this, 'RequestOrchestration', 'replaces', value.replacesList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'RequestOrchestration', 'groupIdentifier', value.groupIdentifierElement, false, -1);
  ComposeEnum(this, 'RequestOrchestration', 'status', value.statusElement, CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, false, -1);
  ComposeEnum(this, 'RequestOrchestration', 'intent', value.intentElement, CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'RequestOrchestration', 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'RequestOrchestration', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'RequestOrchestration', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'RequestOrchestration', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'RequestOrchestration', 'authoredOn', value.authoredOnElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'RequestOrchestration', 'author', value.authorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(this, 'RequestOrchestration', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.goalList.Count - 1 do
      ComposeReference(this, 'RequestOrchestration', 'goal', value.goalList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'RequestOrchestration', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.actionList.Count - 1 do
      ComposeRequestOrchestrationAction(this, 'RequestOrchestration', 'action', value.actionList[i], false, i);
end;

{$ENDIF FHIR_REQUESTORCHESTRATION}
{$IFDEF FHIR_REQUIREMENTS}
function TFHIRTurtleParser.ParseRequirementsStatement(obj : TTurtleComplex) : TFhirRequirementsStatement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRequirementsStatement.create;
  try
    ParseRequirementsStatementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRequirementsStatementProperties(obj : TTurtleComplex; value : TFhirRequirementsStatement);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.keyElement := ParseId(obj.complex('http://hl7.org/fhir/Requirements.statement.key'));
    value.label_Element := ParseString(obj.complex('http://hl7.org/fhir/Requirements.statement.label'));
    for item in obj.complexes('http://hl7.org/fhir/Requirements.statement.conformance') do
      value.conformanceList.Add(parseEnum(item, CODES_TFhirConformanceExpectationEnum, SYSTEMS_TFhirConformanceExpectationEnum));
    value.requirementElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Requirements.statement.requirement'));
    value.derivedFromElement := ParseString(obj.complex('http://hl7.org/fhir/Requirements.statement.derivedFrom'));
    for item in obj.complexes('http://hl7.org/fhir/Requirements.statement.satisfiedBy') do
      value.satisfiedByList.Add(parseUrl(item));
    for item in obj.complexes('http://hl7.org/fhir/Requirements.statement.reference') do
      value.referenceList.Add(parseUrl(item));
    for item in obj.complexes('http://hl7.org/fhir/Requirements.statement.source') do
      value.sourceList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeRequirementsStatement(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequirementsStatement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RequirementsStatement');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeId(this, 'Requirements.statement', 'key', value.keyElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Requirements.statement', 'label', value.label_Element, false, -1);
  for i := 0 to value.conformanceList.Count - 1 do
      ComposeEnum(this, 'Requirements.statement', 'conformance', value.conformanceList[i], CODES_TFhirConformanceExpectationEnum, SYSTEMS_TFhirConformanceExpectationEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.conformanceList.Count - 1 do
      ComposeEnum(this, 'Requirements.statement', 'conformance', value.conformanceList[i], CODES_TFhirConformanceExpectationEnum, SYSTEMS_TFhirConformanceExpectationEnum, false, i);
  ComposeMarkdown(this, 'Requirements.statement', 'requirement', value.requirementElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Requirements.statement', 'derivedFrom', value.derivedFromElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.satisfiedByList.Count - 1 do
      ComposeUrl(this, 'Requirements.statement', 'satisfiedBy', value.satisfiedByList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.referenceList.Count - 1 do
      ComposeUrl(this, 'Requirements.statement', 'reference', value.referenceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.sourceList.Count - 1 do
      ComposeReference(this, 'Requirements.statement', 'source', value.sourceList[i], false, i);
end;

function TFHIRTurtleParser.ParseRequirements(obj : TTurtleComplex) : TFhirRequirements;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRequirements.create;
  try
    ParseRequirementsProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRequirementsProperties(obj : TTurtleComplex; value : TFhirRequirements);
var
  item : TTurtleComplex;
begin
    ParseCanonicalResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Requirements.url'));
    for item in obj.complexes('http://hl7.org/fhir/Requirements.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Requirements.version'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Requirements.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Requirements.title'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Requirements.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Requirements.experimental'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Requirements.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/Requirements.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/Requirements.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Requirements.description'));
    for item in obj.complexes('http://hl7.org/fhir/Requirements.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/Requirements.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Requirements.purpose'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Requirements.copyright'));
    value.copyrightLabelElement := ParseString(obj.complex('http://hl7.org/fhir/Requirements.copyrightLabel'));
    for item in obj.complexes('http://hl7.org/fhir/Requirements.derivedFrom') do
      value.derivedFromList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/Requirements.actor') do
      value.actorList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/Requirements.statement') do
      value.statementList.Add(parseRequirementsStatement(item));
end;

procedure TFHIRTurtleComposer.ComposeRequirements(parent :  TTurtleComplex; parentType, name : String; value : TFhirRequirements; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Requirements');
  end;
  composeCanonicalResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'Requirements', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Requirements', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Requirements', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Requirements', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Requirements', 'title', value.titleElement, false, -1);
  ComposeEnum(this, 'Requirements', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Requirements', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Requirements', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Requirements', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'Requirements', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'Requirements', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'Requirements', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'Requirements', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'Requirements', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'Requirements', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Requirements', 'copyrightLabel', value.copyrightLabelElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.derivedFromList.Count - 1 do
      ComposeCanonical(this, 'Requirements', 'derivedFrom', value.derivedFromList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.actorList.Count - 1 do
      ComposeCanonical(this, 'Requirements', 'actor', value.actorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.statementList.Count - 1 do
      ComposeRequirementsStatement(this, 'Requirements', 'statement', value.statementList[i], false, i);
end;

{$ENDIF FHIR_REQUIREMENTS}
{$IFDEF FHIR_RESEARCHSTUDY}
function TFHIRTurtleParser.ParseResearchStudyLabel(obj : TTurtleComplex) : TFhirResearchStudyLabel;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirResearchStudyLabel.create;
  try
    ParseResearchStudyLabelProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseResearchStudyLabelProperties(obj : TTurtleComplex; value : TFhirResearchStudyLabel);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ResearchStudy.label.type'));
    value.valueElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchStudy.label.value'));
end;

procedure TFHIRTurtleComposer.ComposeResearchStudyLabel(parent :  TTurtleComplex; parentType, name : String; value : TFhirResearchStudyLabel; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ResearchStudyLabel');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ResearchStudy.label', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ResearchStudy.label', 'value', value.valueElement, false, -1);
end;

function TFHIRTurtleParser.ParseResearchStudyFocus(obj : TTurtleComplex) : TFhirResearchStudyFocus;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirResearchStudyFocus.create;
  try
    ParseResearchStudyFocusProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseResearchStudyFocusProperties(obj : TTurtleComplex; value : TFhirResearchStudyFocus);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.productCode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ResearchStudy.focus.productCode'));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.focus.focusType') do
      value.focusTypeList.Add(parseCodeableConcept(item));
    value.factorElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ResearchStudy.focus.factor'));
end;

procedure TFHIRTurtleComposer.ComposeResearchStudyFocus(parent :  TTurtleComplex; parentType, name : String; value : TFhirResearchStudyFocus; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ResearchStudyFocus');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ResearchStudy.focus', 'productCode', value.productCodeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.focusTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'ResearchStudy.focus', 'focusType', value.focusTypeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ResearchStudy.focus', 'factor', value.factorElement, false, -1);
end;

function TFHIRTurtleParser.ParseResearchStudyAssociatedParty(obj : TTurtleComplex) : TFhirResearchStudyAssociatedParty;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirResearchStudyAssociatedParty.create;
  try
    ParseResearchStudyAssociatedPartyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseResearchStudyAssociatedPartyProperties(obj : TTurtleComplex; value : TFhirResearchStudyAssociatedParty);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchStudy.associatedParty.name'));
    value.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ResearchStudy.associatedParty.role'));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.associatedParty.period') do
      value.periodList.Add(parsePeriod(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.associatedParty.classifier') do
      value.classifierList.Add(parseCodeableConcept(item));
    value.party := ParseReference(obj.complex('http://hl7.org/fhir/ResearchStudy.associatedParty.party'));
end;

procedure TFHIRTurtleComposer.ComposeResearchStudyAssociatedParty(parent :  TTurtleComplex; parentType, name : String; value : TFhirResearchStudyAssociatedParty; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ResearchStudyAssociatedParty');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ResearchStudy.associatedParty', 'name', value.nameElement, false, -1);
  ComposeCodeableConcept(this, 'ResearchStudy.associatedParty', 'role', value.roleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.periodList.Count - 1 do
      ComposePeriod(this, 'ResearchStudy.associatedParty', 'period', value.periodList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.classifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ResearchStudy.associatedParty', 'classifier', value.classifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ResearchStudy.associatedParty', 'party', value.partyElement, false, -1);
end;

function TFHIRTurtleParser.ParseResearchStudyProgressStatus(obj : TTurtleComplex) : TFhirResearchStudyProgressStatus;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirResearchStudyProgressStatus.create;
  try
    ParseResearchStudyProgressStatusProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseResearchStudyProgressStatusProperties(obj : TTurtleComplex; value : TFhirResearchStudyProgressStatus);
begin
    ParseBackboneElementProperties(obj, value);
    value.state := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ResearchStudy.progressStatus.state'));
    value.actualElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ResearchStudy.progressStatus.actual'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/ResearchStudy.progressStatus.period'));
end;

procedure TFHIRTurtleComposer.ComposeResearchStudyProgressStatus(parent :  TTurtleComplex; parentType, name : String; value : TFhirResearchStudyProgressStatus; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ResearchStudyProgressStatus');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'ResearchStudy.progressStatus', 'state', value.stateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ResearchStudy.progressStatus', 'actual', value.actualElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'ResearchStudy.progressStatus', 'period', value.periodElement, false, -1);
end;

function TFHIRTurtleParser.ParseResearchStudyRecruitment(obj : TTurtleComplex) : TFhirResearchStudyRecruitment;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirResearchStudyRecruitment.create;
  try
    ParseResearchStudyRecruitmentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseResearchStudyRecruitmentProperties(obj : TTurtleComplex; value : TFhirResearchStudyRecruitment);
begin
    ParseBackboneElementProperties(obj, value);
    value.targetNumberElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ResearchStudy.recruitment.targetNumber'));
    value.actualNumberElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ResearchStudy.recruitment.actualNumber'));
    value.eligibility := ParseReference(obj.complex('http://hl7.org/fhir/ResearchStudy.recruitment.eligibility'));
    value.actualGroup := ParseReference(obj.complex('http://hl7.org/fhir/ResearchStudy.recruitment.actualGroup'));
end;

procedure TFHIRTurtleComposer.ComposeResearchStudyRecruitment(parent :  TTurtleComplex; parentType, name : String; value : TFhirResearchStudyRecruitment; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ResearchStudyRecruitment');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(this, 'ResearchStudy.recruitment', 'targetNumber', value.targetNumberElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(this, 'ResearchStudy.recruitment', 'actualNumber', value.actualNumberElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ResearchStudy.recruitment', 'eligibility', value.eligibilityElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'ResearchStudy.recruitment', 'actualGroup', value.actualGroupElement, false, -1);
end;

function TFHIRTurtleParser.ParseResearchStudyComparisonGroup(obj : TTurtleComplex) : TFhirResearchStudyComparisonGroup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirResearchStudyComparisonGroup.create;
  try
    ParseResearchStudyComparisonGroupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseResearchStudyComparisonGroupProperties(obj : TTurtleComplex; value : TFhirResearchStudyComparisonGroup);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('identifierIdentifier', item) then
      value.identifier := parseIdentifier(item);
    if obj.has('identifierUri', item) then
      value.identifier := parseUri(item);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchStudy.comparisonGroup.name'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ResearchStudy.comparisonGroup.type'));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ResearchStudy.comparisonGroup.description'));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.comparisonGroup.intendedExposure') do
      value.intendedExposureList.Add(parseReference(item));
    value.observedGroup := ParseReference(obj.complex('http://hl7.org/fhir/ResearchStudy.comparisonGroup.observedGroup'));
end;

procedure TFHIRTurtleComposer.ComposeResearchStudyComparisonGroup(parent :  TTurtleComplex; parentType, name : String; value : TFhirResearchStudyComparisonGroup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ResearchStudyComparisonGroup');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) and (value.identifier is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'ResearchStudy.comparisonGroup', 'identifierIdentifier', TFhirIdentifier(value.identifier), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.identifier is TFhirUri) {6} then
    ComposeUri(this, 'ResearchStudy.comparisonGroup', 'identifierUri', TFhirUri(value.identifier), false, -1);
  ComposeString(this, 'ResearchStudy.comparisonGroup', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ResearchStudy.comparisonGroup', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ResearchStudy.comparisonGroup', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.intendedExposureList.Count - 1 do
      ComposeReference(this, 'ResearchStudy.comparisonGroup', 'intendedExposure', value.intendedExposureList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ResearchStudy.comparisonGroup', 'observedGroup', value.observedGroupElement, false, -1);
end;

function TFHIRTurtleParser.ParseResearchStudyObjective(obj : TTurtleComplex) : TFhirResearchStudyObjective;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirResearchStudyObjective.create;
  try
    ParseResearchStudyObjectiveProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseResearchStudyObjectiveProperties(obj : TTurtleComplex; value : TFhirResearchStudyObjective);
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchStudy.objective.name'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ResearchStudy.objective.type'));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ResearchStudy.objective.description'));
end;

procedure TFHIRTurtleComposer.ComposeResearchStudyObjective(parent :  TTurtleComplex; parentType, name : String; value : TFhirResearchStudyObjective; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ResearchStudyObjective');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ResearchStudy.objective', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ResearchStudy.objective', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ResearchStudy.objective', 'description', value.descriptionElement, false, -1);
end;

function TFHIRTurtleParser.ParseResearchStudyOutcomeMeasure(obj : TTurtleComplex) : TFhirResearchStudyOutcomeMeasure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirResearchStudyOutcomeMeasure.create;
  try
    ParseResearchStudyOutcomeMeasureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseResearchStudyOutcomeMeasureProperties(obj : TTurtleComplex; value : TFhirResearchStudyOutcomeMeasure);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchStudy.outcomeMeasure.name'));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.outcomeMeasure.type') do
      value.type_List.Add(parseCodeableConcept(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ResearchStudy.outcomeMeasure.description'));
    value.reference := ParseReference(obj.complex('http://hl7.org/fhir/ResearchStudy.outcomeMeasure.reference'));
end;

procedure TFHIRTurtleComposer.ComposeResearchStudyOutcomeMeasure(parent :  TTurtleComplex; parentType, name : String; value : TFhirResearchStudyOutcomeMeasure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ResearchStudyOutcomeMeasure');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ResearchStudy.outcomeMeasure', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'ResearchStudy.outcomeMeasure', 'type', value.type_List[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ResearchStudy.outcomeMeasure', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ResearchStudy.outcomeMeasure', 'reference', value.referenceElement, false, -1);
end;

function TFHIRTurtleParser.ParseResearchStudyWebLocation(obj : TTurtleComplex) : TFhirResearchStudyWebLocation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirResearchStudyWebLocation.create;
  try
    ParseResearchStudyWebLocationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseResearchStudyWebLocationProperties(obj : TTurtleComplex; value : TFhirResearchStudyWebLocation);
begin
    ParseBackboneElementProperties(obj, value);
    value.classifier := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ResearchStudy.webLocation.classifier'));
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ResearchStudy.webLocation.url'));
end;

procedure TFHIRTurtleComposer.ComposeResearchStudyWebLocation(parent :  TTurtleComplex; parentType, name : String; value : TFhirResearchStudyWebLocation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ResearchStudyWebLocation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ResearchStudy.webLocation', 'classifier', value.classifierElement, false, -1);
  ComposeUri(this, 'ResearchStudy.webLocation', 'url', value.urlElement, false, -1);
end;

function TFHIRTurtleParser.ParseResearchStudy(obj : TTurtleComplex) : TFhirResearchStudy;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirResearchStudy.create;
  try
    ParseResearchStudyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseResearchStudyProperties(obj : TTurtleComplex; value : TFhirResearchStudy);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ResearchStudy.url'));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchStudy.version'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchStudy.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchStudy.title'));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.label') do
      value.label_List.Add(parseResearchStudyLabel(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.protocol') do
      value.protocolList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.partOf') do
      value.partOfList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.relatedArtifact') do
      value.relatedArtifactList.Add(parseRelatedArtifact(item));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ResearchStudy.date'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ResearchStudy.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.primaryPurposeType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ResearchStudy.primaryPurposeType'));
    value.phase := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ResearchStudy.phase'));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.studyDesign') do
      value.studyDesignList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.focus') do
      value.focusList.Add(parseResearchStudyFocus(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.condition') do
      value.conditionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.keyword') do
      value.keywordList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.region') do
      value.regionList.Add(parseCodeableConcept(item));
    value.descriptionSummaryElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ResearchStudy.descriptionSummary'));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ResearchStudy.description'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/ResearchStudy.period'));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.site') do
      value.siteList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.classifier') do
      value.classifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.associatedParty') do
      value.associatedPartyList.Add(parseResearchStudyAssociatedParty(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.progressStatus') do
      value.progressStatusList.Add(parseResearchStudyProgressStatus(item));
    value.whyStopped := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ResearchStudy.whyStopped'));
    value.recruitment := ParseResearchStudyRecruitment(obj.complex('http://hl7.org/fhir/ResearchStudy.recruitment'));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.comparisonGroup') do
      value.comparisonGroupList.Add(parseResearchStudyComparisonGroup(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.objective') do
      value.objectiveList.Add(parseResearchStudyObjective(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.outcomeMeasure') do
      value.outcomeMeasureList.Add(parseResearchStudyOutcomeMeasure(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.result') do
      value.resultList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.webLocation') do
      value.webLocationList.Add(parseResearchStudyWebLocation(item));
end;

procedure TFHIRTurtleComposer.ComposeResearchStudy(parent :  TTurtleComplex; parentType, name : String; value : TFhirResearchStudy; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ResearchStudy');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ResearchStudy', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ResearchStudy', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ResearchStudy', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ResearchStudy', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ResearchStudy', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.label_List.Count - 1 do
      ComposeResearchStudyLabel(this, 'ResearchStudy', 'label', value.label_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.protocolList.Count - 1 do
      ComposeReference(this, 'ResearchStudy', 'protocol', value.protocolList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(this, 'ResearchStudy', 'partOf', value.partOfList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'ResearchStudy', 'relatedArtifact', value.relatedArtifactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'ResearchStudy', 'date', value.dateElement, false, -1);
  ComposeEnum(this, 'ResearchStudy', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ResearchStudy', 'primaryPurposeType', value.primaryPurposeTypeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ResearchStudy', 'phase', value.phaseElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.studyDesignList.Count - 1 do
      ComposeCodeableConcept(this, 'ResearchStudy', 'studyDesign', value.studyDesignList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.focusList.Count - 1 do
      ComposeResearchStudyFocus(this, 'ResearchStudy', 'focus', value.focusList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.conditionList.Count - 1 do
      ComposeCodeableConcept(this, 'ResearchStudy', 'condition', value.conditionList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.keywordList.Count - 1 do
      ComposeCodeableConcept(this, 'ResearchStudy', 'keyword', value.keywordList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.regionList.Count - 1 do
      ComposeCodeableConcept(this, 'ResearchStudy', 'region', value.regionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ResearchStudy', 'descriptionSummary', value.descriptionSummaryElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ResearchStudy', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'ResearchStudy', 'period', value.periodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.siteList.Count - 1 do
      ComposeReference(this, 'ResearchStudy', 'site', value.siteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'ResearchStudy', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.classifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ResearchStudy', 'classifier', value.classifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.associatedPartyList.Count - 1 do
      ComposeResearchStudyAssociatedParty(this, 'ResearchStudy', 'associatedParty', value.associatedPartyList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.progressStatusList.Count - 1 do
      ComposeResearchStudyProgressStatus(this, 'ResearchStudy', 'progressStatus', value.progressStatusList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ResearchStudy', 'whyStopped', value.whyStoppedElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeResearchStudyRecruitment(this, 'ResearchStudy', 'recruitment', value.recruitmentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.comparisonGroupList.Count - 1 do
      ComposeResearchStudyComparisonGroup(this, 'ResearchStudy', 'comparisonGroup', value.comparisonGroupList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.objectiveList.Count - 1 do
      ComposeResearchStudyObjective(this, 'ResearchStudy', 'objective', value.objectiveList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.outcomeMeasureList.Count - 1 do
      ComposeResearchStudyOutcomeMeasure(this, 'ResearchStudy', 'outcomeMeasure', value.outcomeMeasureList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.resultList.Count - 1 do
      ComposeReference(this, 'ResearchStudy', 'result', value.resultList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.webLocationList.Count - 1 do
      ComposeResearchStudyWebLocation(this, 'ResearchStudy', 'webLocation', value.webLocationList[i], false, i);
end;

{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
function TFHIRTurtleParser.ParseResearchSubjectProgress(obj : TTurtleComplex) : TFhirResearchSubjectProgress;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirResearchSubjectProgress.create;
  try
    ParseResearchSubjectProgressProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseResearchSubjectProgressProperties(obj : TTurtleComplex; value : TFhirResearchSubjectProgress);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ResearchSubject.progress.type'));
    value.subjectState := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ResearchSubject.progress.subjectState'));
    value.milestone := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ResearchSubject.progress.milestone'));
    value.reason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ResearchSubject.progress.reason'));
    value.startDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ResearchSubject.progress.startDate'));
    value.endDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ResearchSubject.progress.endDate'));
end;

procedure TFHIRTurtleComposer.ComposeResearchSubjectProgress(parent :  TTurtleComplex; parentType, name : String; value : TFhirResearchSubjectProgress; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ResearchSubjectProgress');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ResearchSubject.progress', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ResearchSubject.progress', 'subjectState', value.subjectStateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ResearchSubject.progress', 'milestone', value.milestoneElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ResearchSubject.progress', 'reason', value.reasonElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'ResearchSubject.progress', 'startDate', value.startDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'ResearchSubject.progress', 'endDate', value.endDateElement, false, -1);
end;

function TFHIRTurtleParser.ParseResearchSubject(obj : TTurtleComplex) : TFhirResearchSubject;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirResearchSubject.create;
  try
    ParseResearchSubjectProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseResearchSubjectProperties(obj : TTurtleComplex; value : TFhirResearchSubject);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/ResearchSubject.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ResearchSubject.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/ResearchSubject.progress') do
      value.progressList.Add(parseResearchSubjectProgress(item));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/ResearchSubject.period'));
    value.study := ParseReference(obj.complex('http://hl7.org/fhir/ResearchSubject.study'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/ResearchSubject.subject'));
    value.assignedArmElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchSubject.assignedArm'));
    value.actualArmElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchSubject.actualArm'));
    value.consent := ParseReference(obj.complex('http://hl7.org/fhir/ResearchSubject.consent'));
end;

procedure TFHIRTurtleComposer.ComposeResearchSubject(parent :  TTurtleComplex; parentType, name : String; value : TFhirResearchSubject; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ResearchSubject');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ResearchSubject', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'ResearchSubject', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.progressList.Count - 1 do
      ComposeResearchSubjectProgress(this, 'ResearchSubject', 'progress', value.progressList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'ResearchSubject', 'period', value.periodElement, false, -1);
  ComposeReference(this, 'ResearchSubject', 'study', value.studyElement, false, -1);
  ComposeReference(this, 'ResearchSubject', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ResearchSubject', 'assignedArm', value.assignedArmElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ResearchSubject', 'actualArm', value.actualArmElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'ResearchSubject', 'consent', value.consentElement, false, -1);
end;

{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
function TFHIRTurtleParser.ParseRiskAssessmentPrediction(obj : TTurtleComplex) : TFhirRiskAssessmentPrediction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRiskAssessmentPrediction.create;
  try
    ParseRiskAssessmentPredictionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRiskAssessmentPredictionProperties(obj : TTurtleComplex; value : TFhirRiskAssessmentPrediction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.outcome := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RiskAssessment.prediction.outcome'));
    if obj.has('probabilityRange', item) then
      value.probability := parseRange(item);
    if obj.has('probabilityDecimal', item) then
      value.probability := parseDecimal(item);
    value.qualitativeRisk := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RiskAssessment.prediction.qualitativeRisk'));
    value.relativeRiskElement := ParseDecimal(obj.complex('http://hl7.org/fhir/RiskAssessment.prediction.relativeRisk'));
    if obj.has('whenPeriod', item) then
      value.when := parsePeriod(item);
    if obj.has('whenRange', item) then
      value.when := parseRange(item);
    value.rationaleElement := ParseString(obj.complex('http://hl7.org/fhir/RiskAssessment.prediction.rationale'));
end;

procedure TFHIRTurtleComposer.ComposeRiskAssessmentPrediction(parent :  TTurtleComplex; parentType, name : String; value : TFhirRiskAssessmentPrediction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RiskAssessmentPrediction');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'RiskAssessment.prediction', 'outcome', value.outcomeElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.probability is TFhirRange) {6} then
    ComposeRange(this, 'RiskAssessment.prediction', 'probabilityRange', TFhirRange(value.probability), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.probability is TFhirDecimal) {6} then
    ComposeDecimal(this, 'RiskAssessment.prediction', 'probabilityDecimal', TFhirDecimal(value.probability), false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'RiskAssessment.prediction', 'qualitativeRisk', value.qualitativeRiskElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'RiskAssessment.prediction', 'relativeRisk', value.relativeRiskElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.when is TFhirPeriod) {6} then
    ComposePeriod(this, 'RiskAssessment.prediction', 'whenPeriod', TFhirPeriod(value.when), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.when is TFhirRange) {6} then
    ComposeRange(this, 'RiskAssessment.prediction', 'whenRange', TFhirRange(value.when), false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RiskAssessment.prediction', 'rationale', value.rationaleElement, false, -1);
end;

function TFHIRTurtleParser.ParseRiskAssessment(obj : TTurtleComplex) : TFhirRiskAssessment;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRiskAssessment.create;
  try
    ParseRiskAssessmentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRiskAssessmentProperties(obj : TTurtleComplex; value : TFhirRiskAssessment);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/RiskAssessment.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.basedOn := ParseReference(obj.complex('http://hl7.org/fhir/RiskAssessment.basedOn'));
    value.parent := ParseReference(obj.complex('http://hl7.org/fhir/RiskAssessment.parent'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/RiskAssessment.status'), CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum);
    value.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RiskAssessment.method'));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RiskAssessment.code'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/RiskAssessment.subject'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/RiskAssessment.encounter'));
    if obj.has('occurrencePeriod', item) then
      value.occurrence := parsePeriod(item);
    if obj.has('occurrenceDateTime', item) then
      value.occurrence := parseDateTime(item);
    value.condition := ParseReference(obj.complex('http://hl7.org/fhir/RiskAssessment.condition'));
    value.performer := ParseReference(obj.complex('http://hl7.org/fhir/RiskAssessment.performer'));
    for item in obj.complexes('http://hl7.org/fhir/RiskAssessment.reason') do
      value.reasonList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/RiskAssessment.basis') do
      value.basisList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/RiskAssessment.prediction') do
      value.predictionList.Add(parseRiskAssessmentPrediction(item));
    value.mitigationElement := ParseString(obj.complex('http://hl7.org/fhir/RiskAssessment.mitigation'));
    for item in obj.complexes('http://hl7.org/fhir/RiskAssessment.note') do
      value.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeRiskAssessment(parent :  TTurtleComplex; parentType, name : String; value : TFhirRiskAssessment; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RiskAssessment');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'RiskAssessment', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'RiskAssessment', 'basedOn', value.basedOnElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'RiskAssessment', 'parent', value.parentElement, false, -1);
  ComposeEnum(this, 'RiskAssessment', 'status', value.statusElement, CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'RiskAssessment', 'method', value.methodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'RiskAssessment', 'code', value.codeElement, false, -1);
  ComposeReference(this, 'RiskAssessment', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'RiskAssessment', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'RiskAssessment', 'occurrencePeriod', TFhirPeriod(value.occurrence), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'RiskAssessment', 'occurrenceDateTime', TFhirDateTime(value.occurrence), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'RiskAssessment', 'condition', value.conditionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'RiskAssessment', 'performer', value.performerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(this, 'RiskAssessment', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.basisList.Count - 1 do
      ComposeReference(this, 'RiskAssessment', 'basis', value.basisList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.predictionList.Count - 1 do
      ComposeRiskAssessmentPrediction(this, 'RiskAssessment', 'prediction', value.predictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RiskAssessment', 'mitigation', value.mitigationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'RiskAssessment', 'note', value.noteList[i], false, i);
end;

{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
function TFHIRTurtleParser.ParseSchedule(obj : TTurtleComplex) : TFhirSchedule;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSchedule.create;
  try
    ParseScheduleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseScheduleProperties(obj : TTurtleComplex; value : TFhirSchedule);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Schedule.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Schedule.active'));
    for item in obj.complexes('http://hl7.org/fhir/Schedule.serviceCategory') do
      value.serviceCategoryList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Schedule.serviceType') do
      value.serviceTypeList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Schedule.specialty') do
      value.specialtyList.Add(parseCodeableConcept(item));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Schedule.name'));
    for item in obj.complexes('http://hl7.org/fhir/Schedule.actor') do
      value.actorList.Add(parseReference(item));
    value.planningHorizon := ParsePeriod(obj.complex('http://hl7.org/fhir/Schedule.planningHorizon'));
    value.commentElement := ParseString(obj.complex('http://hl7.org/fhir/Schedule.comment'));
end;

procedure TFHIRTurtleComposer.ComposeSchedule(parent :  TTurtleComplex; parentType, name : String; value : TFhirSchedule; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Schedule');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Schedule', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Schedule', 'active', value.activeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.serviceCategoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Schedule', 'serviceCategory', value.serviceCategoryList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.serviceTypeList.Count - 1 do
      ComposeCodeableReference(this, 'Schedule', 'serviceType', value.serviceTypeList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.specialtyList.Count - 1 do
      ComposeCodeableConcept(this, 'Schedule', 'specialty', value.specialtyList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Schedule', 'name', value.nameElement, false, -1);
  for i := 0 to value.actorList.Count - 1 do
      ComposeReference(this, 'Schedule', 'actor', value.actorList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Schedule', 'planningHorizon', value.planningHorizonElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Schedule', 'comment', value.commentElement, false, -1);
end;

{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
function TFHIRTurtleParser.ParseSearchParameterComponent(obj : TTurtleComplex) : TFhirSearchParameterComponent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSearchParameterComponent.create;
  try
    ParseSearchParameterComponentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSearchParameterComponentProperties(obj : TTurtleComplex; value : TFhirSearchParameterComponent);
begin
    ParseBackboneElementProperties(obj, value);
    value.definitionElement := ParseCanonical(obj.complex('http://hl7.org/fhir/SearchParameter.component.definition'));
    value.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/SearchParameter.component.expression'));
end;

procedure TFHIRTurtleComposer.ComposeSearchParameterComponent(parent :  TTurtleComplex; parentType, name : String; value : TFhirSearchParameterComponent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SearchParameterComponent');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCanonical(this, 'SearchParameter.component', 'definition', value.definitionElement, false, -1);
  ComposeString(this, 'SearchParameter.component', 'expression', value.expressionElement, false, -1);
end;

function TFHIRTurtleParser.ParseSearchParameter(obj : TTurtleComplex) : TFhirSearchParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSearchParameter.create;
  try
    ParseSearchParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSearchParameterProperties(obj : TTurtleComplex; value : TFhirSearchParameter);
var
  item : TTurtleComplex;
begin
    ParseCanonicalResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/SearchParameter.url'));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/SearchParameter.version'));
    if obj.has('versionAlgorithmCoding', item) then
      value.versionAlgorithm := parseCoding(item);
    if obj.has('versionAlgorithmString', item) then
      value.versionAlgorithm := parseString(item);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/SearchParameter.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/SearchParameter.title'));
    value.derivedFromElement := ParseCanonical(obj.complex('http://hl7.org/fhir/SearchParameter.derivedFrom'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/SearchParameter.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/SearchParameter.experimental'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/SearchParameter.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/SearchParameter.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/SearchParameter.description'));
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/SearchParameter.purpose'));
    value.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/SearchParameter.code'));
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.base') do
      value.base.Add(parseEnum(item, CODES_TFhirAllResourceTypesEnum, SYSTEMS_TFhirAllResourceTypesEnum));
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/SearchParameter.type'), CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum);
    value.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/SearchParameter.expression'));
    value.processingModeElement := ParseEnum(obj.complex('http://hl7.org/fhir/SearchParameter.processingMode'), CODES_TFhirSearchProcessingModeTypeEnum, SYSTEMS_TFhirSearchProcessingModeTypeEnum);
    value.constraintElement := ParseString(obj.complex('http://hl7.org/fhir/SearchParameter.constraint'));
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.target') do
      value.target.Add(parseEnum(item, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum));
    value.multipleOrElement := ParseBoolean(obj.complex('http://hl7.org/fhir/SearchParameter.multipleOr'));
    value.multipleAndElement := ParseBoolean(obj.complex('http://hl7.org/fhir/SearchParameter.multipleAnd'));
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.comparator') do
      value.comparatorList.Add(parseEnum(item, CODES_TFhirSearchComparatorEnum, SYSTEMS_TFhirSearchComparatorEnum));
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.modifier') do
      value.modifierList.Add(parseEnum(item, CODES_TFhirSearchModifierCodeEnum, SYSTEMS_TFhirSearchModifierCodeEnum));
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.chain') do
      value.chainList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.component') do
      value.componentList.Add(parseSearchParameterComponent(item));
end;

procedure TFHIRTurtleComposer.ComposeSearchParameter(parent :  TTurtleComplex; parentType, name : String; value : TFhirSearchParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SearchParameter');
  end;
  composeCanonicalResource(this, '', name, value, false, index);
  ComposeUri(this, 'SearchParameter', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SearchParameter', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirCoding) {6} then
    ComposeCoding(this, 'SearchParameter', 'versionAlgorithmCoding', TFhirCoding(value.versionAlgorithm), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirString) {6} then
    ComposeString(this, 'SearchParameter', 'versionAlgorithmString', TFhirString(value.versionAlgorithm), false, -1);
  ComposeString(this, 'SearchParameter', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SearchParameter', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'SearchParameter', 'derivedFrom', value.derivedFromElement, false, -1);
  ComposeEnum(this, 'SearchParameter', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'SearchParameter', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'SearchParameter', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SearchParameter', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'SearchParameter', 'contact', value.contactList[i], false, i);
  ComposeMarkdown(this, 'SearchParameter', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'SearchParameter', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'SearchParameter', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'SearchParameter', 'purpose', value.purposeElement, false, -1);
  ComposeCode(this, 'SearchParameter', 'code', value.codeElement, false, -1);
  for i := 0 to value.base.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'base', value.base[i], CODES_TFhirAllResourceTypesEnum, SYSTEMS_TFhirAllResourceTypesEnum, false, i); {x.d1}
  for i := 0 to value.base.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'base', value.base[i], CODES_TFhirAllResourceTypesEnum, SYSTEMS_TFhirAllResourceTypesEnum, false, i);
  ComposeEnum(this, 'SearchParameter', 'type', value.type_Element, CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'SearchParameter', 'expression', value.expressionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'SearchParameter', 'processingMode', value.processingModeElement, CODES_TFhirSearchProcessingModeTypeEnum, SYSTEMS_TFhirSearchProcessingModeTypeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'SearchParameter', 'constraint', value.constraintElement, false, -1);
  for i := 0 to value.target.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'target', value.target[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.target.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'target', value.target[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'SearchParameter', 'multipleOr', value.multipleOrElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'SearchParameter', 'multipleAnd', value.multipleAndElement, false, -1);
  for i := 0 to value.comparatorList.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'comparator', value.comparatorList[i], CODES_TFhirSearchComparatorEnum, SYSTEMS_TFhirSearchComparatorEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.comparatorList.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'comparator', value.comparatorList[i], CODES_TFhirSearchComparatorEnum, SYSTEMS_TFhirSearchComparatorEnum, false, i);
  for i := 0 to value.modifierList.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'modifier', value.modifierList[i], CODES_TFhirSearchModifierCodeEnum, SYSTEMS_TFhirSearchModifierCodeEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'modifier', value.modifierList[i], CODES_TFhirSearchModifierCodeEnum, SYSTEMS_TFhirSearchModifierCodeEnum, false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.chainList.Count - 1 do
      ComposeString(this, 'SearchParameter', 'chain', value.chainList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.componentList.Count - 1 do
      ComposeSearchParameterComponent(this, 'SearchParameter', 'component', value.componentList[i], false, i);
end;

{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEREQUEST}
function TFHIRTurtleParser.ParseServiceRequest(obj : TTurtleComplex) : TFhirServiceRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirServiceRequest.create;
  try
    ParseServiceRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseServiceRequestProperties(obj : TTurtleComplex; value : TFhirServiceRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.instantiatesCanonical') do
      value.instantiatesCanonicalList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.instantiatesUri') do
      value.instantiatesUriList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.basedOn') do
      value.basedOnList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.replaces') do
      value.replacesList.Add(parseReference(item));
    value.requisition := ParseIdentifier(obj.complex('http://hl7.org/fhir/ServiceRequest.requisition'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ServiceRequest.status'), CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum);
    value.intentElement := ParseEnum(obj.complex('http://hl7.org/fhir/ServiceRequest.intent'), CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum);
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    value.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/ServiceRequest.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    value.doNotPerformElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ServiceRequest.doNotPerform'));
    value.code := ParseCodeableReference(obj.complex('http://hl7.org/fhir/ServiceRequest.code'));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.orderDetail') do
      value.orderDetailList.Add(parseCodeableConcept(item));
    if obj.has('quantityQuantity', item) then
      value.quantity := parseQuantity(item);
    if obj.has('quantityRatio', item) then
      value.quantity := parseRatio(item);
    if obj.has('quantityRange', item) then
      value.quantity := parseRange(item);
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/ServiceRequest.subject'));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.focus') do
      value.focusList.Add(parseReference(item));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/ServiceRequest.encounter'));
    if obj.has('occurrencePeriod', item) then
      value.occurrence := parsePeriod(item);
    if obj.has('occurrenceTiming', item) then
      value.occurrence := parseTiming(item);
    if obj.has('occurrenceDateTime', item) then
      value.occurrence := parseDateTime(item);
    if obj.has('asNeededCodeableConcept', item) then
      value.asNeeded := parseCodeableConcept(item);
    if obj.has('asNeededBoolean', item) then
      value.asNeeded := parseBoolean(item);
    value.authoredOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ServiceRequest.authoredOn'));
    value.requester := ParseReference(obj.complex('http://hl7.org/fhir/ServiceRequest.requester'));
    value.performerType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ServiceRequest.performerType'));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.performer') do
      value.performerList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.location') do
      value.locationList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.reason') do
      value.reasonList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.insurance') do
      value.insuranceList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.supportingInfo') do
      value.supportingInfoList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.specimen') do
      value.specimenList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.bodySite') do
      value.bodySiteList.Add(parseCodeableConcept(item));
    value.bodyStructure := ParseReference(obj.complex('http://hl7.org/fhir/ServiceRequest.bodyStructure'));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.note') do
      value.noteList.Add(parseAnnotation(item));
    value.patientInstructionElement := ParseString(obj.complex('http://hl7.org/fhir/ServiceRequest.patientInstruction'));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.relevantHistory') do
      value.relevantHistoryList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeServiceRequest(parent :  TTurtleComplex; parentType, name : String; value : TFhirServiceRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ServiceRequest');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ServiceRequest', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(this, 'ServiceRequest', 'instantiatesCanonical', value.instantiatesCanonicalList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.instantiatesUriList.Count - 1 do
      ComposeUri(this, 'ServiceRequest', 'instantiatesUri', value.instantiatesUriList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'ServiceRequest', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.replacesList.Count - 1 do
      ComposeReference(this, 'ServiceRequest', 'replaces', value.replacesList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'ServiceRequest', 'requisition', value.requisitionElement, false, -1);
  ComposeEnum(this, 'ServiceRequest', 'status', value.statusElement, CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, false, -1);
  ComposeEnum(this, 'ServiceRequest', 'intent', value.intentElement, CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'ServiceRequest', 'category', value.categoryList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'ServiceRequest', 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ServiceRequest', 'doNotPerform', value.doNotPerformElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(this, 'ServiceRequest', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.orderDetailList.Count - 1 do
      ComposeCodeableConcept(this, 'ServiceRequest', 'orderDetail', value.orderDetailList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.quantity is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ServiceRequest', 'quantityQuantity', TFhirQuantity(value.quantity), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.quantity is TFhirRatio) {6} then
    ComposeRatio(this, 'ServiceRequest', 'quantityRatio', TFhirRatio(value.quantity), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.quantity is TFhirRange) {6} then
    ComposeRange(this, 'ServiceRequest', 'quantityRange', TFhirRange(value.quantity), false, -1);
  ComposeReference(this, 'ServiceRequest', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.focusList.Count - 1 do
      ComposeReference(this, 'ServiceRequest', 'focus', value.focusList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'ServiceRequest', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'ServiceRequest', 'occurrencePeriod', TFhirPeriod(value.occurrence), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirTiming) {6} then
    ComposeTiming(this, 'ServiceRequest', 'occurrenceTiming', TFhirTiming(value.occurrence), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ServiceRequest', 'occurrenceDateTime', TFhirDateTime(value.occurrence), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ServiceRequest', 'asNeededCodeableConcept', TFhirCodeableConcept(value.asNeeded), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ServiceRequest', 'asNeededBoolean', TFhirBoolean(value.asNeeded), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ServiceRequest', 'authoredOn', value.authoredOnElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'ServiceRequest', 'requester', value.requesterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ServiceRequest', 'performerType', value.performerTypeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.performerList.Count - 1 do
      ComposeReference(this, 'ServiceRequest', 'performer', value.performerList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.locationList.Count - 1 do
      ComposeCodeableReference(this, 'ServiceRequest', 'location', value.locationList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(this, 'ServiceRequest', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.insuranceList.Count - 1 do
      ComposeReference(this, 'ServiceRequest', 'insurance', value.insuranceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.supportingInfoList.Count - 1 do
      ComposeReference(this, 'ServiceRequest', 'supportingInfo', value.supportingInfoList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.specimenList.Count - 1 do
      ComposeReference(this, 'ServiceRequest', 'specimen', value.specimenList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.bodySiteList.Count - 1 do
      ComposeCodeableConcept(this, 'ServiceRequest', 'bodySite', value.bodySiteList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'ServiceRequest', 'bodyStructure', value.bodyStructureElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'ServiceRequest', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ServiceRequest', 'patientInstruction', value.patientInstructionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relevantHistoryList.Count - 1 do
      ComposeReference(this, 'ServiceRequest', 'relevantHistory', value.relevantHistoryList[i], false, i);
end;

{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SLOT}
function TFHIRTurtleParser.ParseSlot(obj : TTurtleComplex) : TFhirSlot;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSlot.create;
  try
    ParseSlotProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSlotProperties(obj : TTurtleComplex; value : TFhirSlot);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Slot.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/Slot.serviceCategory') do
      value.serviceCategoryList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Slot.serviceType') do
      value.serviceTypeList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Slot.specialty') do
      value.specialtyList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Slot.appointmentType') do
      value.appointmentTypeList.Add(parseCodeableConcept(item));
    value.schedule := ParseReference(obj.complex('http://hl7.org/fhir/Slot.schedule'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Slot.status'), CODES_TFhirSlotStatusEnum, SYSTEMS_TFhirSlotStatusEnum);
    value.startElement := ParseInstant(obj.complex('http://hl7.org/fhir/Slot.start'));
    value.end_Element := ParseInstant(obj.complex('http://hl7.org/fhir/Slot.end'));
    value.overbookedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Slot.overbooked'));
    value.commentElement := ParseString(obj.complex('http://hl7.org/fhir/Slot.comment'));
end;

procedure TFHIRTurtleComposer.ComposeSlot(parent :  TTurtleComplex; parentType, name : String; value : TFhirSlot; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Slot');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Slot', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.serviceCategoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Slot', 'serviceCategory', value.serviceCategoryList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.serviceTypeList.Count - 1 do
      ComposeCodeableReference(this, 'Slot', 'serviceType', value.serviceTypeList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.specialtyList.Count - 1 do
      ComposeCodeableConcept(this, 'Slot', 'specialty', value.specialtyList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.appointmentTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Slot', 'appointmentType', value.appointmentTypeList[i], false, i);
  ComposeReference(this, 'Slot', 'schedule', value.scheduleElement, false, -1);
  ComposeEnum(this, 'Slot', 'status', value.statusElement, CODES_TFhirSlotStatusEnum, SYSTEMS_TFhirSlotStatusEnum, false, -1);
  ComposeInstant(this, 'Slot', 'start', value.startElement, false, -1);
  ComposeInstant(this, 'Slot', 'end', value.end_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Slot', 'overbooked', value.overbookedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Slot', 'comment', value.commentElement, false, -1);
end;

{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
function TFHIRTurtleParser.ParseSpecimenFeature(obj : TTurtleComplex) : TFhirSpecimenFeature;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimenFeature.create;
  try
    ParseSpecimenFeatureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenFeatureProperties(obj : TTurtleComplex; value : TFhirSpecimenFeature);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Specimen.feature.type'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Specimen.feature.description'));
end;

procedure TFHIRTurtleComposer.ComposeSpecimenFeature(parent :  TTurtleComplex; parentType, name : String; value : TFhirSpecimenFeature; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SpecimenFeature');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'Specimen.feature', 'type', value.type_Element, false, -1);
  ComposeString(this, 'Specimen.feature', 'description', value.descriptionElement, false, -1);
end;

function TFHIRTurtleParser.ParseSpecimenCollection(obj : TTurtleComplex) : TFhirSpecimenCollection;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimenCollection.create;
  try
    ParseSpecimenCollectionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenCollectionProperties(obj : TTurtleComplex; value : TFhirSpecimenCollection);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.collector := ParseReference(obj.complex('http://hl7.org/fhir/Specimen.collection.collector'));
    if obj.has('collectedPeriod', item) then
      value.collected := parsePeriod(item);
    if obj.has('collectedDateTime', item) then
      value.collected := parseDateTime(item);
    value.duration := ParseDuration(obj.complex('http://hl7.org/fhir/Specimen.collection.duration'));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Specimen.collection.quantity'));
    value.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Specimen.collection.method'));
    value.device := ParseCodeableReference(obj.complex('http://hl7.org/fhir/Specimen.collection.device'));
    value.procedure_ := ParseReference(obj.complex('http://hl7.org/fhir/Specimen.collection.procedure'));
    value.bodySite := ParseCodeableReference(obj.complex('http://hl7.org/fhir/Specimen.collection.bodySite'));
    if obj.has('fastingStatusCodeableConcept', item) then
      value.fastingStatus := parseCodeableConcept(item);
    if obj.has('fastingStatusDuration', item) then
      value.fastingStatus := parseDuration(item);
end;

procedure TFHIRTurtleComposer.ComposeSpecimenCollection(parent :  TTurtleComplex; parentType, name : String; value : TFhirSpecimenCollection; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SpecimenCollection');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Specimen.collection', 'collector', value.collectorElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.collected is TFhirPeriod) {6} then
    ComposePeriod(this, 'Specimen.collection', 'collectedPeriod', TFhirPeriod(value.collected), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.collected is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Specimen.collection', 'collectedDateTime', TFhirDateTime(value.collected), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDuration(this, 'Specimen.collection', 'duration', value.durationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Specimen.collection', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Specimen.collection', 'method', value.methodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(this, 'Specimen.collection', 'device', value.deviceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Specimen.collection', 'procedure', value.procedure_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableReference(this, 'Specimen.collection', 'bodySite', value.bodySiteElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.fastingStatus is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Specimen.collection', 'fastingStatusCodeableConcept', TFhirCodeableConcept(value.fastingStatus), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.fastingStatus is TFhirDuration) {6} then
    ComposeDuration(this, 'Specimen.collection', 'fastingStatusDuration', TFhirDuration(value.fastingStatus), false, -1);
end;

function TFHIRTurtleParser.ParseSpecimenProcessing(obj : TTurtleComplex) : TFhirSpecimenProcessing;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimenProcessing.create;
  try
    ParseSpecimenProcessingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenProcessingProperties(obj : TTurtleComplex; value : TFhirSpecimenProcessing);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Specimen.processing.description'));
    value.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Specimen.processing.method'));
    for item in obj.complexes('http://hl7.org/fhir/Specimen.processing.additive') do
      value.additiveList.Add(parseReference(item));
    if obj.has('timePeriod', item) then
      value.time := parsePeriod(item);
    if obj.has('timeDateTime', item) then
      value.time := parseDateTime(item);
end;

procedure TFHIRTurtleComposer.ComposeSpecimenProcessing(parent :  TTurtleComplex; parentType, name : String; value : TFhirSpecimenProcessing; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SpecimenProcessing');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Specimen.processing', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Specimen.processing', 'method', value.methodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.additiveList.Count - 1 do
      ComposeReference(this, 'Specimen.processing', 'additive', value.additiveList[i], false, i);
  if (SummaryOption in [soFull, soData]) and (value.time is TFhirPeriod) {6} then
    ComposePeriod(this, 'Specimen.processing', 'timePeriod', TFhirPeriod(value.time), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.time is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Specimen.processing', 'timeDateTime', TFhirDateTime(value.time), false, -1);
end;

function TFHIRTurtleParser.ParseSpecimenContainer(obj : TTurtleComplex) : TFhirSpecimenContainer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimenContainer.create;
  try
    ParseSpecimenContainerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenContainerProperties(obj : TTurtleComplex; value : TFhirSpecimenContainer);
begin
    ParseBackboneElementProperties(obj, value);
    value.device := ParseReference(obj.complex('http://hl7.org/fhir/Specimen.container.device'));
    value.location := ParseReference(obj.complex('http://hl7.org/fhir/Specimen.container.location'));
    value.specimenQuantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Specimen.container.specimenQuantity'));
end;

procedure TFHIRTurtleComposer.ComposeSpecimenContainer(parent :  TTurtleComplex; parentType, name : String; value : TFhirSpecimenContainer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SpecimenContainer');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeReference(this, 'Specimen.container', 'device', value.deviceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Specimen.container', 'location', value.locationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Specimen.container', 'specimenQuantity', value.specimenQuantityElement, false, -1);
end;

function TFHIRTurtleParser.ParseSpecimen(obj : TTurtleComplex) : TFhirSpecimen;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimen.create;
  try
    ParseSpecimenProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenProperties(obj : TTurtleComplex; value : TFhirSpecimen);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Specimen.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.accessionIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Specimen.accessionIdentifier'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Specimen.status'), CODES_TFhirSpecimenStatusEnum, SYSTEMS_TFhirSpecimenStatusEnum);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Specimen.type'));
    value.subject := ParseReference(obj.complex('http://hl7.org/fhir/Specimen.subject'));
    value.receivedTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Specimen.receivedTime'));
    for item in obj.complexes('http://hl7.org/fhir/Specimen.parent') do
      value.parentList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Specimen.request') do
      value.requestList.Add(parseReference(item));
    value.combinedElement := ParseEnum(obj.complex('http://hl7.org/fhir/Specimen.combined'), CODES_TFhirSpecimenCombinedEnum, SYSTEMS_TFhirSpecimenCombinedEnum);
    for item in obj.complexes('http://hl7.org/fhir/Specimen.role') do
      value.roleList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Specimen.feature') do
      value.featureList.Add(parseSpecimenFeature(item));
    value.collection := ParseSpecimenCollection(obj.complex('http://hl7.org/fhir/Specimen.collection'));
    for item in obj.complexes('http://hl7.org/fhir/Specimen.processing') do
      value.processingList.Add(parseSpecimenProcessing(item));
    for item in obj.complexes('http://hl7.org/fhir/Specimen.container') do
      value.containerList.Add(parseSpecimenContainer(item));
    for item in obj.complexes('http://hl7.org/fhir/Specimen.condition') do
      value.conditionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Specimen.note') do
      value.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeSpecimen(parent :  TTurtleComplex; parentType, name : String; value : TFhirSpecimen; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Specimen');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Specimen', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'Specimen', 'accessionIdentifier', value.accessionIdentifierElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Specimen', 'status', value.statusElement, CODES_TFhirSpecimenStatusEnum, SYSTEMS_TFhirSpecimenStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Specimen', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Specimen', 'subject', value.subjectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Specimen', 'receivedTime', value.receivedTimeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.parentList.Count - 1 do
      ComposeReference(this, 'Specimen', 'parent', value.parentList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.requestList.Count - 1 do
      ComposeReference(this, 'Specimen', 'request', value.requestList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Specimen', 'combined', value.combinedElement, CODES_TFhirSpecimenCombinedEnum, SYSTEMS_TFhirSpecimenCombinedEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.roleList.Count - 1 do
      ComposeCodeableConcept(this, 'Specimen', 'role', value.roleList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.featureList.Count - 1 do
      ComposeSpecimenFeature(this, 'Specimen', 'feature', value.featureList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeSpecimenCollection(this, 'Specimen', 'collection', value.collectionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.processingList.Count - 1 do
      ComposeSpecimenProcessing(this, 'Specimen', 'processing', value.processingList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.containerList.Count - 1 do
      ComposeSpecimenContainer(this, 'Specimen', 'container', value.containerList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.conditionList.Count - 1 do
      ComposeCodeableConcept(this, 'Specimen', 'condition', value.conditionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'Specimen', 'note', value.noteList[i], false, i);
end;

{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SPECIMENDEFINITION}
function TFHIRTurtleParser.ParseSpecimenDefinitionTypeTested(obj : TTurtleComplex) : TFhirSpecimenDefinitionTypeTested;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimenDefinitionTypeTested.create;
  try
    ParseSpecimenDefinitionTypeTestedProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenDefinitionTypeTestedProperties(obj : TTurtleComplex; value : TFhirSpecimenDefinitionTypeTested);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.isDerivedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.isDerived'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.type'));
    value.preferenceElement := ParseEnum(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.preference'), CODES_TFhirSpecimenContainedPreferenceEnum, SYSTEMS_TFhirSpecimenContainedPreferenceEnum);
    value.container := ParseSpecimenDefinitionTypeTestedContainer(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.container'));
    value.requirementElement := ParseString(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.requirement'));
    value.retentionTime := ParseDuration(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.retentionTime'));
    value.singleUseElement := ParseBoolean(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.singleUse'));
    for item in obj.complexes('http://hl7.org/fhir/SpecimenDefinition.typeTested.rejectionCriterion') do
      value.rejectionCriterionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/SpecimenDefinition.typeTested.handling') do
      value.handlingList.Add(parseSpecimenDefinitionTypeTestedHandling(item));
    for item in obj.complexes('http://hl7.org/fhir/SpecimenDefinition.typeTested.testingDestination') do
      value.testingDestinationList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeSpecimenDefinitionTypeTested(parent :  TTurtleComplex; parentType, name : String; value : TFhirSpecimenDefinitionTypeTested; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SpecimenDefinitionTypeTested');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'SpecimenDefinition.typeTested', 'isDerived', value.isDerivedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'SpecimenDefinition.typeTested', 'type', value.type_Element, false, -1);
  ComposeEnum(this, 'SpecimenDefinition.typeTested', 'preference', value.preferenceElement, CODES_TFhirSpecimenContainedPreferenceEnum, SYSTEMS_TFhirSpecimenContainedPreferenceEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeSpecimenDefinitionTypeTestedContainer(this, 'SpecimenDefinition.typeTested', 'container', value.containerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'SpecimenDefinition.typeTested', 'requirement', value.requirementElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(this, 'SpecimenDefinition.typeTested', 'retentionTime', value.retentionTimeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'SpecimenDefinition.typeTested', 'singleUse', value.singleUseElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.rejectionCriterionList.Count - 1 do
      ComposeCodeableConcept(this, 'SpecimenDefinition.typeTested', 'rejectionCriterion', value.rejectionCriterionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.handlingList.Count - 1 do
      ComposeSpecimenDefinitionTypeTestedHandling(this, 'SpecimenDefinition.typeTested', 'handling', value.handlingList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.testingDestinationList.Count - 1 do
      ComposeCodeableConcept(this, 'SpecimenDefinition.typeTested', 'testingDestination', value.testingDestinationList[i], false, i);
end;

function TFHIRTurtleParser.ParseSpecimenDefinitionTypeTestedContainer(obj : TTurtleComplex) : TFhirSpecimenDefinitionTypeTestedContainer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimenDefinitionTypeTestedContainer.create;
  try
    ParseSpecimenDefinitionTypeTestedContainerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenDefinitionTypeTestedContainerProperties(obj : TTurtleComplex; value : TFhirSpecimenDefinitionTypeTestedContainer);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.material := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.container.material'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.container.type'));
    value.cap := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.container.cap'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.container.description'));
    value.capacity := ParseQuantity(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.container.capacity'));
    if obj.has('minimumVolumeQuantity', item) then
      value.minimumVolume := parseQuantity(item);
    if obj.has('minimumVolumeString', item) then
      value.minimumVolume := parseString(item);
    for item in obj.complexes('http://hl7.org/fhir/SpecimenDefinition.typeTested.container.additive') do
      value.additiveList.Add(parseSpecimenDefinitionTypeTestedContainerAdditive(item));
    value.preparationElement := ParseString(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.container.preparation'));
end;

procedure TFHIRTurtleComposer.ComposeSpecimenDefinitionTypeTestedContainer(parent :  TTurtleComplex; parentType, name : String; value : TFhirSpecimenDefinitionTypeTestedContainer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SpecimenDefinitionTypeTestedContainer');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'SpecimenDefinition.typeTested.container', 'material', value.materialElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'SpecimenDefinition.typeTested.container', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'SpecimenDefinition.typeTested.container', 'cap', value.capElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'SpecimenDefinition.typeTested.container', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'SpecimenDefinition.typeTested.container', 'capacity', value.capacityElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.minimumVolume is TFhirQuantity) {6} then
    ComposeQuantity(this, 'SpecimenDefinition.typeTested.container', 'minimumVolumeQuantity', TFhirQuantity(value.minimumVolume), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.minimumVolume is TFhirString) {6} then
    ComposeString(this, 'SpecimenDefinition.typeTested.container', 'minimumVolumeString', TFhirString(value.minimumVolume), false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.additiveList.Count - 1 do
      ComposeSpecimenDefinitionTypeTestedContainerAdditive(this, 'SpecimenDefinition.typeTested.container', 'additive', value.additiveList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'SpecimenDefinition.typeTested.container', 'preparation', value.preparationElement, false, -1);
end;

function TFHIRTurtleParser.ParseSpecimenDefinitionTypeTestedContainerAdditive(obj : TTurtleComplex) : TFhirSpecimenDefinitionTypeTestedContainerAdditive;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimenDefinitionTypeTestedContainerAdditive.create;
  try
    ParseSpecimenDefinitionTypeTestedContainerAdditiveProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenDefinitionTypeTestedContainerAdditiveProperties(obj : TTurtleComplex; value : TFhirSpecimenDefinitionTypeTestedContainerAdditive);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('additiveCodeableConcept', item) then
      value.additive := parseCodeableConcept(item);
    if obj.has('additiveReference', item) {a3} then
      value.additive := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeSpecimenDefinitionTypeTestedContainerAdditive(parent :  TTurtleComplex; parentType, name : String; value : TFhirSpecimenDefinitionTypeTestedContainerAdditive; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SpecimenDefinitionTypeTestedContainerAdditive');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (value.additive is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'SpecimenDefinition.typeTested.container.additive', 'additiveCodeableConcept', TFhirCodeableConcept(value.additive), false, -1)
  else if (value.additive is TFhirReference) {2} then
    ComposeReference(this, 'SpecimenDefinition.typeTested.container.additive', 'additiveReference', TFhirReference(value.additive), false,-1);
end;

function TFHIRTurtleParser.ParseSpecimenDefinitionTypeTestedHandling(obj : TTurtleComplex) : TFhirSpecimenDefinitionTypeTestedHandling;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimenDefinitionTypeTestedHandling.create;
  try
    ParseSpecimenDefinitionTypeTestedHandlingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenDefinitionTypeTestedHandlingProperties(obj : TTurtleComplex; value : TFhirSpecimenDefinitionTypeTestedHandling);
begin
    ParseBackboneElementProperties(obj, value);
    value.temperatureQualifier := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.handling.temperatureQualifier'));
    value.temperatureRange := ParseRange(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.handling.temperatureRange'));
    value.maxDuration := ParseDuration(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.handling.maxDuration'));
    value.instructionElement := ParseString(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.handling.instruction'));
end;

procedure TFHIRTurtleComposer.ComposeSpecimenDefinitionTypeTestedHandling(parent :  TTurtleComplex; parentType, name : String; value : TFhirSpecimenDefinitionTypeTestedHandling; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SpecimenDefinitionTypeTestedHandling');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'SpecimenDefinition.typeTested.handling', 'temperatureQualifier', value.temperatureQualifierElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(this, 'SpecimenDefinition.typeTested.handling', 'temperatureRange', value.temperatureRangeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(this, 'SpecimenDefinition.typeTested.handling', 'maxDuration', value.maxDurationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'SpecimenDefinition.typeTested.handling', 'instruction', value.instructionElement, false, -1);
end;

function TFHIRTurtleParser.ParseSpecimenDefinition(obj : TTurtleComplex) : TFhirSpecimenDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimenDefinition.create;
  try
    ParseSpecimenDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenDefinitionProperties(obj : TTurtleComplex; value : TFhirSpecimenDefinition);
var
  item : TTurtleComplex;
begin
    ParseMetadataResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/SpecimenDefinition.url'));
    value.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/SpecimenDefinition.identifier'));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/SpecimenDefinition.version'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/SpecimenDefinition.title'));
    for item in obj.complexes('http://hl7.org/fhir/SpecimenDefinition.derivedFromCanonical') do
      value.derivedFromCanonicalList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/SpecimenDefinition.derivedFromUri') do
      value.derivedFromUriList.Add(parseUri(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/SpecimenDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/SpecimenDefinition.experimental'));
    if obj.has('subjectCodeableConcept', item) then
      value.subject := parseCodeableConcept(item);
    if obj.has('subjectReference', item) {a3} then
      value.subject := ParseReference(item);
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/SpecimenDefinition.date'));
    value.publisher := ParseString(obj.complex('http://hl7.org/fhir/SpecimenDefinition.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/SpecimenDefinition.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/SpecimenDefinition.description'));
    for item in obj.complexes('http://hl7.org/fhir/SpecimenDefinition.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/SpecimenDefinition.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/SpecimenDefinition.purpose'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/SpecimenDefinition.copyright'));
    value.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/SpecimenDefinition.approvalDate'));
    value.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/SpecimenDefinition.lastReviewDate'));
    value.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/SpecimenDefinition.effectivePeriod'));
    value.typeCollected := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeCollected'));
    for item in obj.complexes('http://hl7.org/fhir/SpecimenDefinition.patientPreparation') do
      value.patientPreparationList.Add(parseCodeableConcept(item));
    value.timeAspectElement := ParseString(obj.complex('http://hl7.org/fhir/SpecimenDefinition.timeAspect'));
    for item in obj.complexes('http://hl7.org/fhir/SpecimenDefinition.collection') do
      value.collectionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/SpecimenDefinition.typeTested') do
      value.typeTestedList.Add(parseSpecimenDefinitionTypeTested(item));
end;

procedure TFHIRTurtleComposer.ComposeSpecimenDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirSpecimenDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SpecimenDefinition');
  end;
  composeMetadataResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'SpecimenDefinition', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'SpecimenDefinition', 'identifier', value.identifierElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SpecimenDefinition', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SpecimenDefinition', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.derivedFromCanonicalList.Count - 1 do
      ComposeCanonical(this, 'SpecimenDefinition', 'derivedFromCanonical', value.derivedFromCanonicalList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.derivedFromUriList.Count - 1 do
      ComposeUri(this, 'SpecimenDefinition', 'derivedFromUri', value.derivedFromUriList[i], false, i);
  ComposeEnum(this, 'SpecimenDefinition', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'SpecimenDefinition', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.subject is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'SpecimenDefinition', 'subjectCodeableConcept', TFhirCodeableConcept(value.subject), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.subject is TFhirReference) {2} then
    ComposeReference(this, 'SpecimenDefinition', 'subjectReference', TFhirReference(value.subject), false,-1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'SpecimenDefinition', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SpecimenDefinition', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'SpecimenDefinition', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'SpecimenDefinition', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'SpecimenDefinition', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'SpecimenDefinition', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'SpecimenDefinition', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'SpecimenDefinition', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'SpecimenDefinition', 'approvalDate', value.approvalDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'SpecimenDefinition', 'lastReviewDate', value.lastReviewDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'SpecimenDefinition', 'effectivePeriod', value.effectivePeriodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SpecimenDefinition', 'typeCollected', value.typeCollectedElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.patientPreparationList.Count - 1 do
      ComposeCodeableConcept(this, 'SpecimenDefinition', 'patientPreparation', value.patientPreparationList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SpecimenDefinition', 'timeAspect', value.timeAspectElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.collectionList.Count - 1 do
      ComposeCodeableConcept(this, 'SpecimenDefinition', 'collection', value.collectionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.typeTestedList.Count - 1 do
      ComposeSpecimenDefinitionTypeTested(this, 'SpecimenDefinition', 'typeTested', value.typeTestedList[i], false, i);
end;

{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
function TFHIRTurtleParser.ParseStructureDefinitionMapping(obj : TTurtleComplex) : TFhirStructureDefinitionMapping;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureDefinitionMapping.create;
  try
    ParseStructureDefinitionMappingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureDefinitionMappingProperties(obj : TTurtleComplex; value : TFhirStructureDefinitionMapping);
begin
    ParseBackboneElementProperties(obj, value);
    value.identityElement := ParseId(obj.complex('http://hl7.org/fhir/StructureDefinition.mapping.identity'));
    value.uriElement := ParseUri(obj.complex('http://hl7.org/fhir/StructureDefinition.mapping.uri'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.mapping.name'));
    value.commentElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.mapping.comment'));
end;

procedure TFHIRTurtleComposer.ComposeStructureDefinitionMapping(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureDefinitionMapping; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureDefinitionMapping');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeId(this, 'StructureDefinition.mapping', 'identity', value.identityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'StructureDefinition.mapping', 'uri', value.uriElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'StructureDefinition.mapping', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'StructureDefinition.mapping', 'comment', value.commentElement, false, -1);
end;

function TFHIRTurtleParser.ParseStructureDefinitionContext(obj : TTurtleComplex) : TFhirStructureDefinitionContext;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureDefinitionContext.create;
  try
    ParseStructureDefinitionContextProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureDefinitionContextProperties(obj : TTurtleComplex; value : TFhirStructureDefinitionContext);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/StructureDefinition.context.type'), CODES_TFhirExtensionContextTypeEnum, SYSTEMS_TFhirExtensionContextTypeEnum);
    value.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.context.expression'));
end;

procedure TFHIRTurtleComposer.ComposeStructureDefinitionContext(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureDefinitionContext; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureDefinitionContext');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'StructureDefinition.context', 'type', value.type_Element, CODES_TFhirExtensionContextTypeEnum, SYSTEMS_TFhirExtensionContextTypeEnum, false, -1);
  ComposeString(this, 'StructureDefinition.context', 'expression', value.expressionElement, false, -1);
end;

function TFHIRTurtleParser.ParseStructureDefinitionSnapshot(obj : TTurtleComplex) : TFhirStructureDefinitionSnapshot;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureDefinitionSnapshot.create;
  try
    ParseStructureDefinitionSnapshotProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureDefinitionSnapshotProperties(obj : TTurtleComplex; value : TFhirStructureDefinitionSnapshot);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.snapshot.element') do
      value.elementList.Add(parseElementDefinition(item));
end;

procedure TFHIRTurtleComposer.ComposeStructureDefinitionSnapshot(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureDefinitionSnapshot; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureDefinitionSnapshot');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  for i := 0 to value.elementList.Count - 1 do
      ComposeElementDefinition(this, 'StructureDefinition.snapshot', 'element', value.elementList[i], false, i);
end;

function TFHIRTurtleParser.ParseStructureDefinitionDifferential(obj : TTurtleComplex) : TFhirStructureDefinitionDifferential;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureDefinitionDifferential.create;
  try
    ParseStructureDefinitionDifferentialProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureDefinitionDifferentialProperties(obj : TTurtleComplex; value : TFhirStructureDefinitionDifferential);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.differential.element') do
      value.elementList.Add(parseElementDefinition(item));
end;

procedure TFHIRTurtleComposer.ComposeStructureDefinitionDifferential(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureDefinitionDifferential; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureDefinitionDifferential');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  for i := 0 to value.elementList.Count - 1 do
      ComposeElementDefinition(this, 'StructureDefinition.differential', 'element', value.elementList[i], false, i);
end;

function TFHIRTurtleParser.ParseStructureDefinition(obj : TTurtleComplex) : TFhirStructureDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureDefinition.create;
  try
    ParseStructureDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureDefinitionProperties(obj : TTurtleComplex; value : TFhirStructureDefinition);
var
  item : TTurtleComplex;
begin
    ParseCanonicalResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/StructureDefinition.url'));
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.version'));
    if obj.has('versionAlgorithmCoding', item) then
      value.versionAlgorithm := parseCoding(item);
    if obj.has('versionAlgorithmString', item) then
      value.versionAlgorithm := parseString(item);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.title'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/StructureDefinition.experimental'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/StructureDefinition.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/StructureDefinition.description'));
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/StructureDefinition.purpose'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/StructureDefinition.copyright'));
    value.copyrightLabelElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.copyrightLabel'));
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.keyword') do
      value.keywordList.Add(parseCoding(item));
    value.fhirVersionElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureDefinition.fhirVersion'), CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum);
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.mapping') do
      value.mappingList.Add(parseStructureDefinitionMapping(item));
    value.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureDefinition.kind'), CODES_TFhirStructureDefinitionKindEnum, SYSTEMS_TFhirStructureDefinitionKindEnum);
    value.abstractElement := ParseBoolean(obj.complex('http://hl7.org/fhir/StructureDefinition.abstract'));
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.context') do
      value.contextList.Add(parseStructureDefinitionContext(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.contextInvariant') do
      value.contextInvariantList.Add(parseString(item));
    value.type_Element := ParseUri(obj.complex('http://hl7.org/fhir/StructureDefinition.type'));
    value.baseDefinitionElement := ParseCanonical(obj.complex('http://hl7.org/fhir/StructureDefinition.baseDefinition'));
    value.derivationElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureDefinition.derivation'), CODES_TFhirTypeDerivationRuleEnum, SYSTEMS_TFhirTypeDerivationRuleEnum);
    value.snapshot := ParseStructureDefinitionSnapshot(obj.complex('http://hl7.org/fhir/StructureDefinition.snapshot'));
    value.differential := ParseStructureDefinitionDifferential(obj.complex('http://hl7.org/fhir/StructureDefinition.differential'));
end;

procedure TFHIRTurtleComposer.ComposeStructureDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureDefinition');
  end;
  composeCanonicalResource(this, '', name, value, false, index);
  ComposeUri(this, 'StructureDefinition', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'StructureDefinition', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureDefinition', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirCoding) {6} then
    ComposeCoding(this, 'StructureDefinition', 'versionAlgorithmCoding', TFhirCoding(value.versionAlgorithm), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirString) {6} then
    ComposeString(this, 'StructureDefinition', 'versionAlgorithmString', TFhirString(value.versionAlgorithm), false, -1);
  ComposeString(this, 'StructureDefinition', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureDefinition', 'title', value.titleElement, false, -1);
  ComposeEnum(this, 'StructureDefinition', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'StructureDefinition', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'StructureDefinition', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureDefinition', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'StructureDefinition', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'StructureDefinition', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'StructureDefinition', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'StructureDefinition', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'StructureDefinition', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'StructureDefinition', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'StructureDefinition', 'copyrightLabel', value.copyrightLabelElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.keywordList.Count - 1 do
      ComposeCoding(this, 'StructureDefinition', 'keyword', value.keywordList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'StructureDefinition', 'fhirVersion', value.fhirVersionElement, CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.mappingList.Count - 1 do
      ComposeStructureDefinitionMapping(this, 'StructureDefinition', 'mapping', value.mappingList[i], false, i);
  ComposeEnum(this, 'StructureDefinition', 'kind', value.kindElement, CODES_TFhirStructureDefinitionKindEnum, SYSTEMS_TFhirStructureDefinitionKindEnum, false, -1);
  ComposeBoolean(this, 'StructureDefinition', 'abstract', value.abstractElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contextList.Count - 1 do
      ComposeStructureDefinitionContext(this, 'StructureDefinition', 'context', value.contextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contextInvariantList.Count - 1 do
      ComposeString(this, 'StructureDefinition', 'contextInvariant', value.contextInvariantList[i], false, i);
  ComposeUri(this, 'StructureDefinition', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(this, 'StructureDefinition', 'baseDefinition', value.baseDefinitionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'StructureDefinition', 'derivation', value.derivationElement, CODES_TFhirTypeDerivationRuleEnum, SYSTEMS_TFhirTypeDerivationRuleEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeStructureDefinitionSnapshot(this, 'StructureDefinition', 'snapshot', value.snapshotElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeStructureDefinitionDifferential(this, 'StructureDefinition', 'differential', value.differentialElement, false, -1);
end;

{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
function TFHIRTurtleParser.ParseStructureMapStructure(obj : TTurtleComplex) : TFhirStructureMapStructure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMapStructure.create;
  try
    ParseStructureMapStructureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapStructureProperties(obj : TTurtleComplex; value : TFhirStructureMapStructure);
begin
    ParseBackboneElementProperties(obj, value);
    value.urlElement := ParseCanonical(obj.complex('http://hl7.org/fhir/StructureMap.structure.url'));
    value.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureMap.structure.mode'), CODES_TFhirStructureMapModelModeEnum, SYSTEMS_TFhirStructureMapModelModeEnum);
    value.aliasElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.structure.alias'));
    value.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.structure.documentation'));
end;

procedure TFHIRTurtleComposer.ComposeStructureMapStructure(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureMapStructure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMapStructure');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCanonical(this, 'StructureMap.structure', 'url', value.urlElement, false, -1);
  ComposeEnum(this, 'StructureMap.structure', 'mode', value.modeElement, CODES_TFhirStructureMapModelModeEnum, SYSTEMS_TFhirStructureMapModelModeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.structure', 'alias', value.aliasElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'StructureMap.structure', 'documentation', value.documentationElement, false, -1);
end;

function TFHIRTurtleParser.ParseStructureMapGroup(obj : TTurtleComplex) : TFhirStructureMapGroup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMapGroup.create;
  try
    ParseStructureMapGroupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapGroupProperties(obj : TTurtleComplex; value : TFhirStructureMapGroup);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.name'));
    value.extendsElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.extends'));
    value.typeModeElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureMap.group.typeMode'), CODES_TFhirStructureMapGroupTypeModeEnum, SYSTEMS_TFhirStructureMapGroupTypeModeEnum);
    value.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.documentation'));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.input') do
      value.inputList.Add(parseStructureMapGroupInput(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.rule') do
      value.ruleList.Add(parseStructureMapGroupRule(item));
end;

procedure TFHIRTurtleComposer.ComposeStructureMapGroup(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureMapGroup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMapGroup');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeId(this, 'StructureMap.group', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'StructureMap.group', 'extends', value.extendsElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'StructureMap.group', 'typeMode', value.typeModeElement, CODES_TFhirStructureMapGroupTypeModeEnum, SYSTEMS_TFhirStructureMapGroupTypeModeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group', 'documentation', value.documentationElement, false, -1);
  for i := 0 to value.inputList.Count - 1 do
      ComposeStructureMapGroupInput(this, 'StructureMap.group', 'input', value.inputList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.ruleList.Count - 1 do
      ComposeStructureMapGroupRule(this, 'StructureMap.group', 'rule', value.ruleList[i], false, i);
end;

function TFHIRTurtleParser.ParseStructureMapGroupInput(obj : TTurtleComplex) : TFhirStructureMapGroupInput;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMapGroupInput.create;
  try
    ParseStructureMapGroupInputProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapGroupInputProperties(obj : TTurtleComplex; value : TFhirStructureMapGroupInput);
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.input.name'));
    value.type_Element := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.input.type'));
    value.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureMap.group.input.mode'), CODES_TFhirStructureMapInputModeEnum, SYSTEMS_TFhirStructureMapInputModeEnum);
    value.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.input.documentation'));
end;

procedure TFHIRTurtleComposer.ComposeStructureMapGroupInput(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureMapGroupInput; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMapGroupInput');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeId(this, 'StructureMap.group.input', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group.input', 'type', value.type_Element, false, -1);
  ComposeEnum(this, 'StructureMap.group.input', 'mode', value.modeElement, CODES_TFhirStructureMapInputModeEnum, SYSTEMS_TFhirStructureMapInputModeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'StructureMap.group.input', 'documentation', value.documentationElement, false, -1);
end;

function TFHIRTurtleParser.ParseStructureMapGroupRule(obj : TTurtleComplex) : TFhirStructureMapGroupRule;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMapGroupRule.create;
  try
    ParseStructureMapGroupRuleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapGroupRuleProperties(obj : TTurtleComplex; value : TFhirStructureMapGroupRule);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.name'));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.rule.source') do
      value.sourceList.Add(parseStructureMapGroupRuleSource(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.rule.target') do
      value.targetList.Add(parseStructureMapGroupRuleTarget(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.rule.rule') do
      value.ruleList.Add(parseStructureMapGroupRule(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.rule.dependent') do
      value.dependentList.Add(parseStructureMapGroupRuleDependent(item));
    value.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.documentation'));
end;

procedure TFHIRTurtleComposer.ComposeStructureMapGroupRule(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureMapGroupRule; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMapGroupRule');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'StructureMap.group.rule', 'name', value.nameElement, false, -1);
  for i := 0 to value.sourceList.Count - 1 do
      ComposeStructureMapGroupRuleSource(this, 'StructureMap.group.rule', 'source', value.sourceList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.targetList.Count - 1 do
      ComposeStructureMapGroupRuleTarget(this, 'StructureMap.group.rule', 'target', value.targetList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.ruleList.Count - 1 do
      ComposeStructureMapGroupRule(this, 'StructureMap.group.rule', 'rule', value.ruleList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.dependentList.Count - 1 do
      ComposeStructureMapGroupRuleDependent(this, 'StructureMap.group.rule', 'dependent', value.dependentList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'StructureMap.group.rule', 'documentation', value.documentationElement, false, -1);
end;

function TFHIRTurtleParser.ParseStructureMapGroupRuleSource(obj : TTurtleComplex) : TFhirStructureMapGroupRuleSource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMapGroupRuleSource.create;
  try
    ParseStructureMapGroupRuleSourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapGroupRuleSourceProperties(obj : TTurtleComplex; value : TFhirStructureMapGroupRuleSource);
begin
    ParseBackboneElementProperties(obj, value);
    value.contextElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.context'));
    value.minElement := ParseInteger(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.min'));
    value.maxElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.max'));
    value.type_Element := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.type'));
    value.defaultValueElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValue'));
    value.elementElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.element'));
    value.listModeElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.listMode'), CODES_TFhirStructureMapSourceListModeEnum, SYSTEMS_TFhirStructureMapSourceListModeEnum);
    value.variableElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.variable'));
    value.conditionElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.condition'));
    value.checkElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.check'));
    value.logMessageElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.logMessage'));
end;

procedure TFHIRTurtleComposer.ComposeStructureMapGroupRuleSource(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureMapGroupRuleSource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMapGroupRuleSource');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeId(this, 'StructureMap.group.rule.source', 'context', value.contextElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'StructureMap.group.rule.source', 'min', value.minElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group.rule.source', 'max', value.maxElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group.rule.source', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group.rule.source', 'defaultValue', value.defaultValueElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group.rule.source', 'element', value.elementElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'StructureMap.group.rule.source', 'listMode', value.listModeElement, CODES_TFhirStructureMapSourceListModeEnum, SYSTEMS_TFhirStructureMapSourceListModeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'StructureMap.group.rule.source', 'variable', value.variableElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group.rule.source', 'condition', value.conditionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group.rule.source', 'check', value.checkElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group.rule.source', 'logMessage', value.logMessageElement, false, -1);
end;

function TFHIRTurtleParser.ParseStructureMapGroupRuleTarget(obj : TTurtleComplex) : TFhirStructureMapGroupRuleTarget;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMapGroupRuleTarget.create;
  try
    ParseStructureMapGroupRuleTargetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapGroupRuleTargetProperties(obj : TTurtleComplex; value : TFhirStructureMapGroupRuleTarget);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.contextElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.target.context'));
    value.elementElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.target.element'));
    value.variableElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.target.variable'));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.rule.target.listMode') do
      value.listModeList.Add(parseEnum(item, CODES_TFhirStructureMapTargetListModeEnum, SYSTEMS_TFhirStructureMapTargetListModeEnum));
    value.listRuleIdElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.target.listRuleId'));
    value.transformElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.target.transform'), CODES_TFhirStructureMapTransformEnum, SYSTEMS_TFhirStructureMapTransformEnum);
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.rule.target.parameter') do
      value.parameterList.Add(parseStructureMapGroupRuleTargetParameter(item));
end;

procedure TFHIRTurtleComposer.ComposeStructureMapGroupRuleTarget(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureMapGroupRuleTarget; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMapGroupRuleTarget');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'StructureMap.group.rule.target', 'context', value.contextElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group.rule.target', 'element', value.elementElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'StructureMap.group.rule.target', 'variable', value.variableElement, false, -1);
  for i := 0 to value.listModeList.Count - 1 do
      ComposeEnum(this, 'StructureMap.group.rule.target', 'listMode', value.listModeList[i], CODES_TFhirStructureMapTargetListModeEnum, SYSTEMS_TFhirStructureMapTargetListModeEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.listModeList.Count - 1 do
      ComposeEnum(this, 'StructureMap.group.rule.target', 'listMode', value.listModeList[i], CODES_TFhirStructureMapTargetListModeEnum, SYSTEMS_TFhirStructureMapTargetListModeEnum, false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'StructureMap.group.rule.target', 'listRuleId', value.listRuleIdElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'StructureMap.group.rule.target', 'transform', value.transformElement, CODES_TFhirStructureMapTransformEnum, SYSTEMS_TFhirStructureMapTransformEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.parameterList.Count - 1 do
      ComposeStructureMapGroupRuleTargetParameter(this, 'StructureMap.group.rule.target', 'parameter', value.parameterList[i], false, i);
end;

function TFHIRTurtleParser.ParseStructureMapGroupRuleTargetParameter(obj : TTurtleComplex) : TFhirStructureMapGroupRuleTargetParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMapGroupRuleTargetParameter.create;
  try
    ParseStructureMapGroupRuleTargetParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapGroupRuleTargetParameterProperties(obj : TTurtleComplex; value : TFhirStructureMapGroupRuleTargetParameter);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('valueId', item) then
      value.value := parseId(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    if obj.has('valueInteger', item) then
      value.value := parseInteger(item);
    if obj.has('valueDecimal', item) then
      value.value := parseDecimal(item);
    if obj.has('valueDate', item) then
      value.value := parseDate(item);
    if obj.has('valueTime', item) then
      value.value := parseTime(item);
    if obj.has('valueDateTime', item) then
      value.value := parseDateTime(item);
end;

procedure TFHIRTurtleComposer.ComposeStructureMapGroupRuleTargetParameter(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureMapGroupRuleTargetParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMapGroupRuleTargetParameter');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (value.value is TFhirId) {6} then
    ComposeId(this, 'StructureMap.group.rule.target.parameter', 'valueId', TFhirId(value.value), false, -1)
  else if (value.value is TFhirString) {6} then
    ComposeString(this, 'StructureMap.group.rule.target.parameter', 'valueString', TFhirString(value.value), false, -1)
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'StructureMap.group.rule.target.parameter', 'valueBoolean', TFhirBoolean(value.value), false, -1)
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(this, 'StructureMap.group.rule.target.parameter', 'valueInteger', TFhirInteger(value.value), false, -1)
  else if (value.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'StructureMap.group.rule.target.parameter', 'valueDecimal', TFhirDecimal(value.value), false, -1)
  else if (value.value is TFhirDate) {6} then
    ComposeDate(this, 'StructureMap.group.rule.target.parameter', 'valueDate', TFhirDate(value.value), false, -1)
  else if (value.value is TFhirTime) {6} then
    ComposeTime(this, 'StructureMap.group.rule.target.parameter', 'valueTime', TFhirTime(value.value), false, -1)
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'StructureMap.group.rule.target.parameter', 'valueDateTime', TFhirDateTime(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseStructureMapGroupRuleDependent(obj : TTurtleComplex) : TFhirStructureMapGroupRuleDependent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMapGroupRuleDependent.create;
  try
    ParseStructureMapGroupRuleDependentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapGroupRuleDependentProperties(obj : TTurtleComplex; value : TFhirStructureMapGroupRuleDependent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.dependent.name'));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.rule.dependent.parameter') do
      value.parameterList.Add(parseStructureMapGroupRuleTargetParameter(item));
end;

procedure TFHIRTurtleComposer.ComposeStructureMapGroupRuleDependent(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureMapGroupRuleDependent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMapGroupRuleDependent');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeId(this, 'StructureMap.group.rule.dependent', 'name', value.nameElement, false, -1);
  for i := 0 to value.parameterList.Count - 1 do
      ComposeStructureMapGroupRuleTargetParameter(this, 'StructureMap.group.rule.dependent', 'parameter', value.parameterList[i], false, i);
end;

function TFHIRTurtleParser.ParseStructureMap(obj : TTurtleComplex) : TFhirStructureMap;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMap.create;
  try
    ParseStructureMapProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapProperties(obj : TTurtleComplex; value : TFhirStructureMap);
var
  item : TTurtleComplex;
begin
    ParseCanonicalResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/StructureMap.url'));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.version'));
    if obj.has('versionAlgorithmCoding', item) then
      value.versionAlgorithm := parseCoding(item);
    if obj.has('versionAlgorithmString', item) then
      value.versionAlgorithm := parseString(item);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.title'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureMap.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/StructureMap.experimental'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/StructureMap.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/StructureMap.description'));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/StructureMap.purpose'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/StructureMap.copyright'));
    value.copyrightLabelElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.copyrightLabel'));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.structure') do
      value.structureList.Add(parseStructureMapStructure(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.import') do
      value.importList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group') do
      value.groupList.Add(parseStructureMapGroup(item));
end;

procedure TFHIRTurtleComposer.ComposeStructureMap(parent :  TTurtleComplex; parentType, name : String; value : TFhirStructureMap; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMap');
  end;
  composeCanonicalResource(this, '', name, value, false, index);
  ComposeUri(this, 'StructureMap', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'StructureMap', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirCoding) {6} then
    ComposeCoding(this, 'StructureMap', 'versionAlgorithmCoding', TFhirCoding(value.versionAlgorithm), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirString) {6} then
    ComposeString(this, 'StructureMap', 'versionAlgorithmString', TFhirString(value.versionAlgorithm), false, -1);
  ComposeString(this, 'StructureMap', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap', 'title', value.titleElement, false, -1);
  ComposeEnum(this, 'StructureMap', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'StructureMap', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'StructureMap', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'StructureMap', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'StructureMap', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'StructureMap', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'StructureMap', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'StructureMap', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'StructureMap', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'StructureMap', 'copyrightLabel', value.copyrightLabelElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.structureList.Count - 1 do
      ComposeStructureMapStructure(this, 'StructureMap', 'structure', value.structureList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.importList.Count - 1 do
      ComposeCanonical(this, 'StructureMap', 'import', value.importList[i], false, i);
  for i := 0 to value.groupList.Count - 1 do
      ComposeStructureMapGroup(this, 'StructureMap', 'group', value.groupList[i], false, i);
end;

{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
function TFHIRTurtleParser.ParseSubscriptionFilterBy(obj : TTurtleComplex) : TFhirSubscriptionFilterBy;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubscriptionFilterBy.create;
  try
    ParseSubscriptionFilterByProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubscriptionFilterByProperties(obj : TTurtleComplex; value : TFhirSubscriptionFilterBy);
begin
    ParseBackboneElementProperties(obj, value);
    value.resourceTypeElement := ParseUri(obj.complex('http://hl7.org/fhir/Subscription.filterBy.resourceType'));
    value.filterParameterElement := ParseString(obj.complex('http://hl7.org/fhir/Subscription.filterBy.filterParameter'));
    value.modifierElement := ParseEnum(obj.complex('http://hl7.org/fhir/Subscription.filterBy.modifier'), CODES_TFhirSubscriptionSearchModifierEnum, SYSTEMS_TFhirSubscriptionSearchModifierEnum);
    value.valueElement := ParseString(obj.complex('http://hl7.org/fhir/Subscription.filterBy.value'));
end;

procedure TFHIRTurtleComposer.ComposeSubscriptionFilterBy(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubscriptionFilterBy; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubscriptionFilterBy');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'Subscription.filterBy', 'resourceType', value.resourceTypeElement, false, -1);
  ComposeString(this, 'Subscription.filterBy', 'filterParameter', value.filterParameterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Subscription.filterBy', 'modifier', value.modifierElement, CODES_TFhirSubscriptionSearchModifierEnum, SYSTEMS_TFhirSubscriptionSearchModifierEnum, false, -1);
  ComposeString(this, 'Subscription.filterBy', 'value', value.valueElement, false, -1);
end;

function TFHIRTurtleParser.ParseSubscription(obj : TTurtleComplex) : TFhirSubscription;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubscription.create;
  try
    ParseSubscriptionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubscriptionProperties(obj : TTurtleComplex; value : TFhirSubscription);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Subscription.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Subscription.name'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Subscription.status'), CODES_TFhirSubscriptionStatusCodesEnum, SYSTEMS_TFhirSubscriptionStatusCodesEnum);
    value.topicElement := ParseCanonical(obj.complex('http://hl7.org/fhir/Subscription.topic'));
    for item in obj.complexes('http://hl7.org/fhir/Subscription.contact') do
      value.contactList.Add(parseContactPoint(item));
    value.end_Element := ParseInstant(obj.complex('http://hl7.org/fhir/Subscription.end'));
    value.managingEntity := ParseReference(obj.complex('http://hl7.org/fhir/Subscription.managingEntity'));
    value.reasonElement := ParseString(obj.complex('http://hl7.org/fhir/Subscription.reason'));
    for item in obj.complexes('http://hl7.org/fhir/Subscription.filterBy') do
      value.filterByList.Add(parseSubscriptionFilterBy(item));
    value.channelType := ParseCoding(obj.complex('http://hl7.org/fhir/Subscription.channelType'));
    value.endpointElement := ParseUrl(obj.complex('http://hl7.org/fhir/Subscription.endpoint'));
    for item in obj.complexes('http://hl7.org/fhir/Subscription.header') do
      value.headerList.Add(parseString(item));
    value.heartbeatPeriodElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Subscription.heartbeatPeriod'));
    value.timeoutElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Subscription.timeout'));
    value.contentTypeElement := ParseCode(obj.complex('http://hl7.org/fhir/Subscription.contentType'));
    value.contentElement := ParseEnum(obj.complex('http://hl7.org/fhir/Subscription.content'), CODES_TFhirSubscriptionPayloadContentEnum, SYSTEMS_TFhirSubscriptionPayloadContentEnum);
    value.maxCountElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Subscription.maxCount'));
end;

procedure TFHIRTurtleComposer.ComposeSubscription(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubscription; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Subscription');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Subscription', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Subscription', 'name', value.nameElement, false, -1);
  ComposeEnum(this, 'Subscription', 'status', value.statusElement, CODES_TFhirSubscriptionStatusCodesEnum, SYSTEMS_TFhirSubscriptionStatusCodesEnum, false, -1);
  ComposeCanonical(this, 'Subscription', 'topic', value.topicElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactPoint(this, 'Subscription', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'Subscription', 'end', value.end_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Subscription', 'managingEntity', value.managingEntityElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Subscription', 'reason', value.reasonElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.filterByList.Count - 1 do
      ComposeSubscriptionFilterBy(this, 'Subscription', 'filterBy', value.filterByList[i], false, i);
  ComposeCoding(this, 'Subscription', 'channelType', value.channelTypeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrl(this, 'Subscription', 'endpoint', value.endpointElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.headerList.Count - 1 do
      ComposeString(this, 'Subscription', 'header', value.headerList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'Subscription', 'heartbeatPeriod', value.heartbeatPeriodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'Subscription', 'timeout', value.timeoutElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(this, 'Subscription', 'contentType', value.contentTypeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Subscription', 'content', value.contentElement, CODES_TFhirSubscriptionPayloadContentEnum, SYSTEMS_TFhirSubscriptionPayloadContentEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'Subscription', 'maxCount', value.maxCountElement, false, -1);
end;

{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSCRIPTIONSTATUS}
function TFHIRTurtleParser.ParseSubscriptionStatusNotificationEvent(obj : TTurtleComplex) : TFhirSubscriptionStatusNotificationEvent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubscriptionStatusNotificationEvent.create;
  try
    ParseSubscriptionStatusNotificationEventProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubscriptionStatusNotificationEventProperties(obj : TTurtleComplex; value : TFhirSubscriptionStatusNotificationEvent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.eventNumberElement := ParseInteger64(obj.complex('http://hl7.org/fhir/SubscriptionStatus.notificationEvent.eventNumber'));
    value.timestampElement := ParseInstant(obj.complex('http://hl7.org/fhir/SubscriptionStatus.notificationEvent.timestamp'));
    value.focus := ParseReference(obj.complex('http://hl7.org/fhir/SubscriptionStatus.notificationEvent.focus'));
    for item in obj.complexes('http://hl7.org/fhir/SubscriptionStatus.notificationEvent.additionalContext') do
      value.additionalContextList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeSubscriptionStatusNotificationEvent(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubscriptionStatusNotificationEvent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubscriptionStatusNotificationEvent');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeInteger64(this, 'SubscriptionStatus.notificationEvent', 'eventNumber', value.eventNumberElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeInstant(this, 'SubscriptionStatus.notificationEvent', 'timestamp', value.timestampElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'SubscriptionStatus.notificationEvent', 'focus', value.focusElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.additionalContextList.Count - 1 do
      ComposeReference(this, 'SubscriptionStatus.notificationEvent', 'additionalContext', value.additionalContextList[i], false, i);
end;

function TFHIRTurtleParser.ParseSubscriptionStatus(obj : TTurtleComplex) : TFhirSubscriptionStatus;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubscriptionStatus.create;
  try
    ParseSubscriptionStatusProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubscriptionStatusProperties(obj : TTurtleComplex; value : TFhirSubscriptionStatus);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/SubscriptionStatus.status'), CODES_TFhirSubscriptionStatusCodesEnum, SYSTEMS_TFhirSubscriptionStatusCodesEnum);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/SubscriptionStatus.type'), CODES_TFhirSubscriptionNotificationTypeEnum, SYSTEMS_TFhirSubscriptionNotificationTypeEnum);
    value.eventsSinceSubscriptionStartElement := ParseInteger64(obj.complex('http://hl7.org/fhir/SubscriptionStatus.eventsSinceSubscriptionStart'));
    for item in obj.complexes('http://hl7.org/fhir/SubscriptionStatus.notificationEvent') do
      value.notificationEventList.Add(parseSubscriptionStatusNotificationEvent(item));
    value.subscription := ParseReference(obj.complex('http://hl7.org/fhir/SubscriptionStatus.subscription'));
    value.topicElement := ParseCanonical(obj.complex('http://hl7.org/fhir/SubscriptionStatus.topic'));
    for item in obj.complexes('http://hl7.org/fhir/SubscriptionStatus.error') do
      value.errorList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeSubscriptionStatus(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubscriptionStatus; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubscriptionStatus');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'SubscriptionStatus', 'status', value.statusElement, CODES_TFhirSubscriptionStatusCodesEnum, SYSTEMS_TFhirSubscriptionStatusCodesEnum, false, -1);
  ComposeEnum(this, 'SubscriptionStatus', 'type', value.type_Element, CODES_TFhirSubscriptionNotificationTypeEnum, SYSTEMS_TFhirSubscriptionNotificationTypeEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger64(this, 'SubscriptionStatus', 'eventsSinceSubscriptionStart', value.eventsSinceSubscriptionStartElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.notificationEventList.Count - 1 do
      ComposeSubscriptionStatusNotificationEvent(this, 'SubscriptionStatus', 'notificationEvent', value.notificationEventList[i], false, i);
  ComposeReference(this, 'SubscriptionStatus', 'subscription', value.subscriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(this, 'SubscriptionStatus', 'topic', value.topicElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.errorList.Count - 1 do
      ComposeCodeableConcept(this, 'SubscriptionStatus', 'error', value.errorList[i], false, i);
end;

{$ENDIF FHIR_SUBSCRIPTIONSTATUS}
{$IFDEF FHIR_SUBSCRIPTIONTOPIC}
function TFHIRTurtleParser.ParseSubscriptionTopicResourceTrigger(obj : TTurtleComplex) : TFhirSubscriptionTopicResourceTrigger;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubscriptionTopicResourceTrigger.create;
  try
    ParseSubscriptionTopicResourceTriggerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubscriptionTopicResourceTriggerProperties(obj : TTurtleComplex; value : TFhirSubscriptionTopicResourceTrigger);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/SubscriptionTopic.resourceTrigger.description'));
    value.resourceElement := ParseUri(obj.complex('http://hl7.org/fhir/SubscriptionTopic.resourceTrigger.resource'));
    for item in obj.complexes('http://hl7.org/fhir/SubscriptionTopic.resourceTrigger.supportedInteraction') do
      value.supportedInteractionList.Add(parseEnum(item, CODES_TFhirInteractionTriggerEnum, SYSTEMS_TFhirInteractionTriggerEnum));
    value.queryCriteria := ParseSubscriptionTopicResourceTriggerQueryCriteria(obj.complex('http://hl7.org/fhir/SubscriptionTopic.resourceTrigger.queryCriteria'));
    value.fhirPathCriteriaElement := ParseString(obj.complex('http://hl7.org/fhir/SubscriptionTopic.resourceTrigger.fhirPathCriteria'));
end;

procedure TFHIRTurtleComposer.ComposeSubscriptionTopicResourceTrigger(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubscriptionTopicResourceTrigger; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubscriptionTopicResourceTrigger');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'SubscriptionTopic.resourceTrigger', 'description', value.descriptionElement, false, -1);
  ComposeUri(this, 'SubscriptionTopic.resourceTrigger', 'resource', value.resourceElement, false, -1);
  for i := 0 to value.supportedInteractionList.Count - 1 do
      ComposeEnum(this, 'SubscriptionTopic.resourceTrigger', 'supportedInteraction', value.supportedInteractionList[i], CODES_TFhirInteractionTriggerEnum, SYSTEMS_TFhirInteractionTriggerEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.supportedInteractionList.Count - 1 do
      ComposeEnum(this, 'SubscriptionTopic.resourceTrigger', 'supportedInteraction', value.supportedInteractionList[i], CODES_TFhirInteractionTriggerEnum, SYSTEMS_TFhirInteractionTriggerEnum, false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubscriptionTopicResourceTriggerQueryCriteria(this, 'SubscriptionTopic.resourceTrigger', 'queryCriteria', value.queryCriteriaElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubscriptionTopic.resourceTrigger', 'fhirPathCriteria', value.fhirPathCriteriaElement, false, -1);
end;

function TFHIRTurtleParser.ParseSubscriptionTopicResourceTriggerQueryCriteria(obj : TTurtleComplex) : TFhirSubscriptionTopicResourceTriggerQueryCriteria;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubscriptionTopicResourceTriggerQueryCriteria.create;
  try
    ParseSubscriptionTopicResourceTriggerQueryCriteriaProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubscriptionTopicResourceTriggerQueryCriteriaProperties(obj : TTurtleComplex; value : TFhirSubscriptionTopicResourceTriggerQueryCriteria);
begin
    ParseBackboneElementProperties(obj, value);
    value.previousElement := ParseString(obj.complex('http://hl7.org/fhir/SubscriptionTopic.resourceTrigger.queryCriteria.previous'));
    value.resultForCreateElement := ParseEnum(obj.complex('http://hl7.org/fhir/SubscriptionTopic.resourceTrigger.queryCriteria.resultForCreate'), CODES_TFhirCriteriaNotExistsBehaviorEnum, SYSTEMS_TFhirCriteriaNotExistsBehaviorEnum);
    value.currentElement := ParseString(obj.complex('http://hl7.org/fhir/SubscriptionTopic.resourceTrigger.queryCriteria.current'));
    value.resultForDeleteElement := ParseEnum(obj.complex('http://hl7.org/fhir/SubscriptionTopic.resourceTrigger.queryCriteria.resultForDelete'), CODES_TFhirCriteriaNotExistsBehaviorEnum, SYSTEMS_TFhirCriteriaNotExistsBehaviorEnum);
    value.requireBothElement := ParseBoolean(obj.complex('http://hl7.org/fhir/SubscriptionTopic.resourceTrigger.queryCriteria.requireBoth'));
end;

procedure TFHIRTurtleComposer.ComposeSubscriptionTopicResourceTriggerQueryCriteria(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubscriptionTopicResourceTriggerQueryCriteria; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubscriptionTopicResourceTriggerQueryCriteria');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubscriptionTopic.resourceTrigger.queryCriteria', 'previous', value.previousElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'SubscriptionTopic.resourceTrigger.queryCriteria', 'resultForCreate', value.resultForCreateElement, CODES_TFhirCriteriaNotExistsBehaviorEnum, SYSTEMS_TFhirCriteriaNotExistsBehaviorEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubscriptionTopic.resourceTrigger.queryCriteria', 'current', value.currentElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'SubscriptionTopic.resourceTrigger.queryCriteria', 'resultForDelete', value.resultForDeleteElement, CODES_TFhirCriteriaNotExistsBehaviorEnum, SYSTEMS_TFhirCriteriaNotExistsBehaviorEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'SubscriptionTopic.resourceTrigger.queryCriteria', 'requireBoth', value.requireBothElement, false, -1);
end;

function TFHIRTurtleParser.ParseSubscriptionTopicEventTrigger(obj : TTurtleComplex) : TFhirSubscriptionTopicEventTrigger;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubscriptionTopicEventTrigger.create;
  try
    ParseSubscriptionTopicEventTriggerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubscriptionTopicEventTriggerProperties(obj : TTurtleComplex; value : TFhirSubscriptionTopicEventTrigger);
begin
    ParseBackboneElementProperties(obj, value);
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/SubscriptionTopic.eventTrigger.description'));
    value.event := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubscriptionTopic.eventTrigger.event'));
    value.resourceElement := ParseUri(obj.complex('http://hl7.org/fhir/SubscriptionTopic.eventTrigger.resource'));
end;

procedure TFHIRTurtleComposer.ComposeSubscriptionTopicEventTrigger(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubscriptionTopicEventTrigger; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubscriptionTopicEventTrigger');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'SubscriptionTopic.eventTrigger', 'description', value.descriptionElement, false, -1);
  ComposeCodeableConcept(this, 'SubscriptionTopic.eventTrigger', 'event', value.eventElement, false, -1);
  ComposeUri(this, 'SubscriptionTopic.eventTrigger', 'resource', value.resourceElement, false, -1);
end;

function TFHIRTurtleParser.ParseSubscriptionTopicCanFilterBy(obj : TTurtleComplex) : TFhirSubscriptionTopicCanFilterBy;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubscriptionTopicCanFilterBy.create;
  try
    ParseSubscriptionTopicCanFilterByProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubscriptionTopicCanFilterByProperties(obj : TTurtleComplex; value : TFhirSubscriptionTopicCanFilterBy);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/SubscriptionTopic.canFilterBy.description'));
    value.resourceElement := ParseUri(obj.complex('http://hl7.org/fhir/SubscriptionTopic.canFilterBy.resource'));
    value.filterParameterElement := ParseString(obj.complex('http://hl7.org/fhir/SubscriptionTopic.canFilterBy.filterParameter'));
    value.filterDefinitionElement := ParseUri(obj.complex('http://hl7.org/fhir/SubscriptionTopic.canFilterBy.filterDefinition'));
    for item in obj.complexes('http://hl7.org/fhir/SubscriptionTopic.canFilterBy.modifier') do
      value.modifierList.Add(parseEnum(item, CODES_TFhirSubscriptionSearchModifierEnum, SYSTEMS_TFhirSubscriptionSearchModifierEnum));
end;

procedure TFHIRTurtleComposer.ComposeSubscriptionTopicCanFilterBy(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubscriptionTopicCanFilterBy; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubscriptionTopicCanFilterBy');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'SubscriptionTopic.canFilterBy', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'SubscriptionTopic.canFilterBy', 'resource', value.resourceElement, false, -1);
  ComposeString(this, 'SubscriptionTopic.canFilterBy', 'filterParameter', value.filterParameterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'SubscriptionTopic.canFilterBy', 'filterDefinition', value.filterDefinitionElement, false, -1);
  for i := 0 to value.modifierList.Count - 1 do
      ComposeEnum(this, 'SubscriptionTopic.canFilterBy', 'modifier', value.modifierList[i], CODES_TFhirSubscriptionSearchModifierEnum, SYSTEMS_TFhirSubscriptionSearchModifierEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.modifierList.Count - 1 do
      ComposeEnum(this, 'SubscriptionTopic.canFilterBy', 'modifier', value.modifierList[i], CODES_TFhirSubscriptionSearchModifierEnum, SYSTEMS_TFhirSubscriptionSearchModifierEnum, false, i);
end;

function TFHIRTurtleParser.ParseSubscriptionTopicNotificationShape(obj : TTurtleComplex) : TFhirSubscriptionTopicNotificationShape;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubscriptionTopicNotificationShape.create;
  try
    ParseSubscriptionTopicNotificationShapeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubscriptionTopicNotificationShapeProperties(obj : TTurtleComplex; value : TFhirSubscriptionTopicNotificationShape);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.resourceElement := ParseUri(obj.complex('http://hl7.org/fhir/SubscriptionTopic.notificationShape.resource'));
    for item in obj.complexes('http://hl7.org/fhir/SubscriptionTopic.notificationShape.include') do
      value.includeList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/SubscriptionTopic.notificationShape.revInclude') do
      value.revIncludeList.Add(parseString(item));
end;

procedure TFHIRTurtleComposer.ComposeSubscriptionTopicNotificationShape(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubscriptionTopicNotificationShape; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubscriptionTopicNotificationShape');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeUri(this, 'SubscriptionTopic.notificationShape', 'resource', value.resourceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.includeList.Count - 1 do
      ComposeString(this, 'SubscriptionTopic.notificationShape', 'include', value.includeList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.revIncludeList.Count - 1 do
      ComposeString(this, 'SubscriptionTopic.notificationShape', 'revInclude', value.revIncludeList[i], false, i);
end;

function TFHIRTurtleParser.ParseSubscriptionTopic(obj : TTurtleComplex) : TFhirSubscriptionTopic;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubscriptionTopic.create;
  try
    ParseSubscriptionTopicProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubscriptionTopicProperties(obj : TTurtleComplex; value : TFhirSubscriptionTopic);
var
  item : TTurtleComplex;
begin
    ParseCanonicalResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/SubscriptionTopic.url'));
    for item in obj.complexes('http://hl7.org/fhir/SubscriptionTopic.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/SubscriptionTopic.version'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/SubscriptionTopic.title'));
    for item in obj.complexes('http://hl7.org/fhir/SubscriptionTopic.derivedFrom') do
      value.derivedFromList.Add(parseCanonical(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/SubscriptionTopic.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/SubscriptionTopic.experimental'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/SubscriptionTopic.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/SubscriptionTopic.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/SubscriptionTopic.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/SubscriptionTopic.description'));
    for item in obj.complexes('http://hl7.org/fhir/SubscriptionTopic.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/SubscriptionTopic.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/SubscriptionTopic.purpose'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/SubscriptionTopic.copyright'));
    value.copyrightLabelElement := ParseString(obj.complex('http://hl7.org/fhir/SubscriptionTopic.copyrightLabel'));
    value.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/SubscriptionTopic.approvalDate'));
    value.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/SubscriptionTopic.lastReviewDate'));
    value.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/SubscriptionTopic.effectivePeriod'));
    for item in obj.complexes('http://hl7.org/fhir/SubscriptionTopic.resourceTrigger') do
      value.resourceTriggerList.Add(parseSubscriptionTopicResourceTrigger(item));
    for item in obj.complexes('http://hl7.org/fhir/SubscriptionTopic.eventTrigger') do
      value.eventTriggerList.Add(parseSubscriptionTopicEventTrigger(item));
    for item in obj.complexes('http://hl7.org/fhir/SubscriptionTopic.canFilterBy') do
      value.canFilterByList.Add(parseSubscriptionTopicCanFilterBy(item));
    for item in obj.complexes('http://hl7.org/fhir/SubscriptionTopic.notificationShape') do
      value.notificationShapeList.Add(parseSubscriptionTopicNotificationShape(item));
end;

procedure TFHIRTurtleComposer.ComposeSubscriptionTopic(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubscriptionTopic; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubscriptionTopic');
  end;
  composeCanonicalResource(this, '', name, value, false, index);
  ComposeUri(this, 'SubscriptionTopic', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'SubscriptionTopic', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubscriptionTopic', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubscriptionTopic', 'title', value.titleElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.derivedFromList.Count - 1 do
      ComposeCanonical(this, 'SubscriptionTopic', 'derivedFrom', value.derivedFromList[i], false, i);
  ComposeEnum(this, 'SubscriptionTopic', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'SubscriptionTopic', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'SubscriptionTopic', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubscriptionTopic', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'SubscriptionTopic', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'SubscriptionTopic', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'SubscriptionTopic', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'SubscriptionTopic', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'SubscriptionTopic', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'SubscriptionTopic', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'SubscriptionTopic', 'copyrightLabel', value.copyrightLabelElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'SubscriptionTopic', 'approvalDate', value.approvalDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'SubscriptionTopic', 'lastReviewDate', value.lastReviewDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'SubscriptionTopic', 'effectivePeriod', value.effectivePeriodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.resourceTriggerList.Count - 1 do
      ComposeSubscriptionTopicResourceTrigger(this, 'SubscriptionTopic', 'resourceTrigger', value.resourceTriggerList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.eventTriggerList.Count - 1 do
      ComposeSubscriptionTopicEventTrigger(this, 'SubscriptionTopic', 'eventTrigger', value.eventTriggerList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.canFilterByList.Count - 1 do
      ComposeSubscriptionTopicCanFilterBy(this, 'SubscriptionTopic', 'canFilterBy', value.canFilterByList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.notificationShapeList.Count - 1 do
      ComposeSubscriptionTopicNotificationShape(this, 'SubscriptionTopic', 'notificationShape', value.notificationShapeList[i], false, i);
end;

{$ENDIF FHIR_SUBSCRIPTIONTOPIC}
{$IFDEF FHIR_SUBSTANCE}
function TFHIRTurtleParser.ParseSubstanceIngredient(obj : TTurtleComplex) : TFhirSubstanceIngredient;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceIngredient.create;
  try
    ParseSubstanceIngredientProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceIngredientProperties(obj : TTurtleComplex; value : TFhirSubstanceIngredient);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.quantity := ParseRatio(obj.complex('http://hl7.org/fhir/Substance.ingredient.quantity'));
    if obj.has('substanceCodeableConcept', item) then
      value.substance := parseCodeableConcept(item);
    if obj.has('substanceReference', item) {a3} then
      value.substance := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeSubstanceIngredient(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceIngredient; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceIngredient');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(this, 'Substance.ingredient', 'quantity', value.quantityElement, false, -1);
  if (value.substance is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Substance.ingredient', 'substanceCodeableConcept', TFhirCodeableConcept(value.substance), false, -1)
  else if (value.substance is TFhirReference) {2} then
    ComposeReference(this, 'Substance.ingredient', 'substanceReference', TFhirReference(value.substance), false,-1);
end;

function TFHIRTurtleParser.ParseSubstance(obj : TTurtleComplex) : TFhirSubstance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstance.create;
  try
    ParseSubstanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceProperties(obj : TTurtleComplex; value : TFhirSubstance);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Substance.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.instanceElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Substance.instance'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Substance.status'), CODES_TFhirFHIRSubstanceStatusEnum, SYSTEMS_TFhirFHIRSubstanceStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/Substance.category') do
      value.categoryList.Add(parseCodeableConcept(item));
    value.code := ParseCodeableReference(obj.complex('http://hl7.org/fhir/Substance.code'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Substance.description'));
    value.expiryElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Substance.expiry'));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Substance.quantity'));
    for item in obj.complexes('http://hl7.org/fhir/Substance.ingredient') do
      value.ingredientList.Add(parseSubstanceIngredient(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstance(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Substance');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Substance', 'identifier', value.identifierList[i], false, i);
  ComposeBoolean(this, 'Substance', 'instance', value.instanceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Substance', 'status', value.statusElement, CODES_TFhirFHIRSubstanceStatusEnum, SYSTEMS_TFhirFHIRSubstanceStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Substance', 'category', value.categoryList[i], false, i);
  ComposeCodeableReference(this, 'Substance', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Substance', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Substance', 'expiry', value.expiryElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'Substance', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.ingredientList.Count - 1 do
      ComposeSubstanceIngredient(this, 'Substance', 'ingredient', value.ingredientList[i], false, i);
end;

{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCEDEFINITION}
function TFHIRTurtleParser.ParseSubstanceDefinitionMoiety(obj : TTurtleComplex) : TFhirSubstanceDefinitionMoiety;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceDefinitionMoiety.create;
  try
    ParseSubstanceDefinitionMoietyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceDefinitionMoietyProperties(obj : TTurtleComplex; value : TFhirSubstanceDefinitionMoiety);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceDefinition.moiety.role'));
    value.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/SubstanceDefinition.moiety.identifier'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceDefinition.moiety.name'));
    value.stereochemistry := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceDefinition.moiety.stereochemistry'));
    value.opticalActivity := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceDefinition.moiety.opticalActivity'));
    value.molecularFormulaElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceDefinition.moiety.molecularFormula'));
    if obj.has('amountQuantity', item) then
      value.amount := parseQuantity(item);
    if obj.has('amountString', item) then
      value.amount := parseString(item);
    value.measurementType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceDefinition.moiety.measurementType'));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceDefinitionMoiety(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceDefinitionMoiety; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceDefinitionMoiety');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceDefinition.moiety', 'role', value.roleElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'SubstanceDefinition.moiety', 'identifier', value.identifierElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceDefinition.moiety', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceDefinition.moiety', 'stereochemistry', value.stereochemistryElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceDefinition.moiety', 'opticalActivity', value.opticalActivityElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceDefinition.moiety', 'molecularFormula', value.molecularFormulaElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.amount is TFhirQuantity) {6} then
    ComposeQuantity(this, 'SubstanceDefinition.moiety', 'amountQuantity', TFhirQuantity(value.amount), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.amount is TFhirString) {6} then
    ComposeString(this, 'SubstanceDefinition.moiety', 'amountString', TFhirString(value.amount), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceDefinition.moiety', 'measurementType', value.measurementTypeElement, false, -1);
end;

function TFHIRTurtleParser.ParseSubstanceDefinitionProperty(obj : TTurtleComplex) : TFhirSubstanceDefinitionProperty;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceDefinitionProperty.create;
  try
    ParseSubstanceDefinitionPropertyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceDefinitionPropertyProperties(obj : TTurtleComplex; value : TFhirSubstanceDefinitionProperty);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceDefinition.property.type'));
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueAttachment', item) then
      value.value := parseAttachment(item);
    if obj.has('valueDate', item) then
      value.value := parseDate(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
end;

procedure TFHIRTurtleComposer.ComposeSubstanceDefinitionProperty(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceDefinitionProperty; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceDefinitionProperty');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'SubstanceDefinition.property', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'SubstanceDefinition.property', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'SubstanceDefinition.property', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'SubstanceDefinition.property', 'valueAttachment', TFhirAttachment(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirDate) {6} then
    ComposeDate(this, 'SubstanceDefinition.property', 'valueDate', TFhirDate(value.value), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'SubstanceDefinition.property', 'valueBoolean', TFhirBoolean(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseSubstanceDefinitionMolecularWeight(obj : TTurtleComplex) : TFhirSubstanceDefinitionMolecularWeight;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceDefinitionMolecularWeight.create;
  try
    ParseSubstanceDefinitionMolecularWeightProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceDefinitionMolecularWeightProperties(obj : TTurtleComplex; value : TFhirSubstanceDefinitionMolecularWeight);
begin
    ParseBackboneElementProperties(obj, value);
    value.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceDefinition.molecularWeight.method'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceDefinition.molecularWeight.type'));
    value.amount := ParseQuantity(obj.complex('http://hl7.org/fhir/SubstanceDefinition.molecularWeight.amount'));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceDefinitionMolecularWeight(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceDefinitionMolecularWeight; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceDefinitionMolecularWeight');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceDefinition.molecularWeight', 'method', value.methodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceDefinition.molecularWeight', 'type', value.type_Element, false, -1);
  ComposeQuantity(this, 'SubstanceDefinition.molecularWeight', 'amount', value.amountElement, false, -1);
end;

function TFHIRTurtleParser.ParseSubstanceDefinitionStructure(obj : TTurtleComplex) : TFhirSubstanceDefinitionStructure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceDefinitionStructure.create;
  try
    ParseSubstanceDefinitionStructureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceDefinitionStructureProperties(obj : TTurtleComplex; value : TFhirSubstanceDefinitionStructure);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.stereochemistry := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceDefinition.structure.stereochemistry'));
    value.opticalActivity := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceDefinition.structure.opticalActivity'));
    value.molecularFormulaElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceDefinition.structure.molecularFormula'));
    value.molecularFormulaByMoietyElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceDefinition.structure.molecularFormulaByMoiety'));
    value.molecularWeight := ParseSubstanceDefinitionMolecularWeight(obj.complex('http://hl7.org/fhir/SubstanceDefinition.structure.molecularWeight'));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.structure.technique') do
      value.techniqueList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.structure.sourceDocument') do
      value.sourceDocumentList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.structure.representation') do
      value.representationList.Add(parseSubstanceDefinitionStructureRepresentation(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceDefinitionStructure(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceDefinitionStructure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceDefinitionStructure');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceDefinition.structure', 'stereochemistry', value.stereochemistryElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceDefinition.structure', 'opticalActivity', value.opticalActivityElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceDefinition.structure', 'molecularFormula', value.molecularFormulaElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceDefinition.structure', 'molecularFormulaByMoiety', value.molecularFormulaByMoietyElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceDefinitionMolecularWeight(this, 'SubstanceDefinition.structure', 'molecularWeight', value.molecularWeightElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.techniqueList.Count - 1 do
      ComposeCodeableConcept(this, 'SubstanceDefinition.structure', 'technique', value.techniqueList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.sourceDocumentList.Count - 1 do
      ComposeReference(this, 'SubstanceDefinition.structure', 'sourceDocument', value.sourceDocumentList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.representationList.Count - 1 do
      ComposeSubstanceDefinitionStructureRepresentation(this, 'SubstanceDefinition.structure', 'representation', value.representationList[i], false, i);
end;

function TFHIRTurtleParser.ParseSubstanceDefinitionStructureRepresentation(obj : TTurtleComplex) : TFhirSubstanceDefinitionStructureRepresentation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceDefinitionStructureRepresentation.create;
  try
    ParseSubstanceDefinitionStructureRepresentationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceDefinitionStructureRepresentationProperties(obj : TTurtleComplex; value : TFhirSubstanceDefinitionStructureRepresentation);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceDefinition.structure.representation.type'));
    value.representationElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceDefinition.structure.representation.representation'));
    value.format := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceDefinition.structure.representation.format'));
    value.document := ParseReference(obj.complex('http://hl7.org/fhir/SubstanceDefinition.structure.representation.document'));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceDefinitionStructureRepresentation(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceDefinitionStructureRepresentation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceDefinitionStructureRepresentation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceDefinition.structure.representation', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceDefinition.structure.representation', 'representation', value.representationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceDefinition.structure.representation', 'format', value.formatElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'SubstanceDefinition.structure.representation', 'document', value.documentElement, false, -1);
end;

function TFHIRTurtleParser.ParseSubstanceDefinitionCode(obj : TTurtleComplex) : TFhirSubstanceDefinitionCode;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceDefinitionCode.create;
  try
    ParseSubstanceDefinitionCodeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceDefinitionCodeProperties(obj : TTurtleComplex; value : TFhirSubstanceDefinitionCode);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceDefinition.code.code'));
    value.status := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceDefinition.code.status'));
    value.statusDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/SubstanceDefinition.code.statusDate'));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.code.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.code.source') do
      value.sourceList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceDefinitionCode(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceDefinitionCode; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceDefinitionCode');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceDefinition.code', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceDefinition.code', 'status', value.statusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'SubstanceDefinition.code', 'statusDate', value.statusDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'SubstanceDefinition.code', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.sourceList.Count - 1 do
      ComposeReference(this, 'SubstanceDefinition.code', 'source', value.sourceList[i], false, i);
end;

function TFHIRTurtleParser.ParseSubstanceDefinitionName(obj : TTurtleComplex) : TFhirSubstanceDefinitionName;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceDefinitionName.create;
  try
    ParseSubstanceDefinitionNameProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceDefinitionNameProperties(obj : TTurtleComplex; value : TFhirSubstanceDefinitionName);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceDefinition.name.name'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceDefinition.name.type'));
    value.status := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceDefinition.name.status'));
    value.preferredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/SubstanceDefinition.name.preferred'));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.name.language') do
      value.languageList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.name.domain') do
      value.domainList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.name.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.name.synonym') do
      value.synonymList.Add(parseSubstanceDefinitionName(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.name.translation') do
      value.translationList.Add(parseSubstanceDefinitionName(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.name.official') do
      value.officialList.Add(parseSubstanceDefinitionNameOfficial(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.name.source') do
      value.sourceList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceDefinitionName(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceDefinitionName; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceDefinitionName');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'SubstanceDefinition.name', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceDefinition.name', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceDefinition.name', 'status', value.statusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'SubstanceDefinition.name', 'preferred', value.preferredElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.languageList.Count - 1 do
      ComposeCodeableConcept(this, 'SubstanceDefinition.name', 'language', value.languageList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.domainList.Count - 1 do
      ComposeCodeableConcept(this, 'SubstanceDefinition.name', 'domain', value.domainList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'SubstanceDefinition.name', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.synonymList.Count - 1 do
      ComposeSubstanceDefinitionName(this, 'SubstanceDefinition.name', 'synonym', value.synonymList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.translationList.Count - 1 do
      ComposeSubstanceDefinitionName(this, 'SubstanceDefinition.name', 'translation', value.translationList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.officialList.Count - 1 do
      ComposeSubstanceDefinitionNameOfficial(this, 'SubstanceDefinition.name', 'official', value.officialList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.sourceList.Count - 1 do
      ComposeReference(this, 'SubstanceDefinition.name', 'source', value.sourceList[i], false, i);
end;

function TFHIRTurtleParser.ParseSubstanceDefinitionNameOfficial(obj : TTurtleComplex) : TFhirSubstanceDefinitionNameOfficial;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceDefinitionNameOfficial.create;
  try
    ParseSubstanceDefinitionNameOfficialProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceDefinitionNameOfficialProperties(obj : TTurtleComplex; value : TFhirSubstanceDefinitionNameOfficial);
begin
    ParseBackboneElementProperties(obj, value);
    value.authority := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceDefinition.name.official.authority'));
    value.status := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceDefinition.name.official.status'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/SubstanceDefinition.name.official.date'));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceDefinitionNameOfficial(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceDefinitionNameOfficial; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceDefinitionNameOfficial');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceDefinition.name.official', 'authority', value.authorityElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceDefinition.name.official', 'status', value.statusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'SubstanceDefinition.name.official', 'date', value.dateElement, false, -1);
end;

function TFHIRTurtleParser.ParseSubstanceDefinitionRelationship(obj : TTurtleComplex) : TFhirSubstanceDefinitionRelationship;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceDefinitionRelationship.create;
  try
    ParseSubstanceDefinitionRelationshipProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceDefinitionRelationshipProperties(obj : TTurtleComplex; value : TFhirSubstanceDefinitionRelationship);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    if obj.has('substanceDefinitionReference', item) {a3} then
      value.substanceDefinition := ParseReference(item);
    if obj.has('substanceDefinitionCodeableConcept', item) then
      value.substanceDefinition := parseCodeableConcept(item);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceDefinition.relationship.type'));
    value.isDefiningElement := ParseBoolean(obj.complex('http://hl7.org/fhir/SubstanceDefinition.relationship.isDefining'));
    if obj.has('amountQuantity', item) then
      value.amount := parseQuantity(item);
    if obj.has('amountRatio', item) then
      value.amount := parseRatio(item);
    if obj.has('amountString', item) then
      value.amount := parseString(item);
    value.ratioHighLimitAmount := ParseRatio(obj.complex('http://hl7.org/fhir/SubstanceDefinition.relationship.ratioHighLimitAmount'));
    value.comparator := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceDefinition.relationship.comparator'));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.relationship.source') do
      value.sourceList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceDefinitionRelationship(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceDefinitionRelationship; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceDefinitionRelationship');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.substanceDefinition is TFhirReference) {2} then
    ComposeReference(this, 'SubstanceDefinition.relationship', 'substanceDefinitionReference', TFhirReference(value.substanceDefinition), false,-1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.substanceDefinition is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'SubstanceDefinition.relationship', 'substanceDefinitionCodeableConcept', TFhirCodeableConcept(value.substanceDefinition), false, -1);
  ComposeCodeableConcept(this, 'SubstanceDefinition.relationship', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'SubstanceDefinition.relationship', 'isDefining', value.isDefiningElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.amount is TFhirQuantity) {6} then
    ComposeQuantity(this, 'SubstanceDefinition.relationship', 'amountQuantity', TFhirQuantity(value.amount), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.amount is TFhirRatio) {6} then
    ComposeRatio(this, 'SubstanceDefinition.relationship', 'amountRatio', TFhirRatio(value.amount), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.amount is TFhirString) {6} then
    ComposeString(this, 'SubstanceDefinition.relationship', 'amountString', TFhirString(value.amount), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(this, 'SubstanceDefinition.relationship', 'ratioHighLimitAmount', value.ratioHighLimitAmountElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceDefinition.relationship', 'comparator', value.comparatorElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.sourceList.Count - 1 do
      ComposeReference(this, 'SubstanceDefinition.relationship', 'source', value.sourceList[i], false, i);
end;

function TFHIRTurtleParser.ParseSubstanceDefinitionSourceMaterial(obj : TTurtleComplex) : TFhirSubstanceDefinitionSourceMaterial;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceDefinitionSourceMaterial.create;
  try
    ParseSubstanceDefinitionSourceMaterialProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceDefinitionSourceMaterialProperties(obj : TTurtleComplex; value : TFhirSubstanceDefinitionSourceMaterial);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceDefinition.sourceMaterial.type'));
    value.genus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceDefinition.sourceMaterial.genus'));
    value.species := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceDefinition.sourceMaterial.species'));
    value.part := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceDefinition.sourceMaterial.part'));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.sourceMaterial.countryOfOrigin') do
      value.countryOfOriginList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceDefinitionSourceMaterial(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceDefinitionSourceMaterial; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceDefinitionSourceMaterial');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceDefinition.sourceMaterial', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceDefinition.sourceMaterial', 'genus', value.genusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceDefinition.sourceMaterial', 'species', value.speciesElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceDefinition.sourceMaterial', 'part', value.partElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.countryOfOriginList.Count - 1 do
      ComposeCodeableConcept(this, 'SubstanceDefinition.sourceMaterial', 'countryOfOrigin', value.countryOfOriginList[i], false, i);
end;

function TFHIRTurtleParser.ParseSubstanceDefinition(obj : TTurtleComplex) : TFhirSubstanceDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceDefinition.create;
  try
    ParseSubstanceDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceDefinitionProperties(obj : TTurtleComplex; value : TFhirSubstanceDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceDefinition.version'));
    value.status := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceDefinition.status'));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.classification') do
      value.classificationList.Add(parseCodeableConcept(item));
    value.domain := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceDefinition.domain'));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.grade') do
      value.gradeList.Add(parseCodeableConcept(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/SubstanceDefinition.description'));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.informationSource') do
      value.informationSourceList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.manufacturer') do
      value.manufacturerList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.supplier') do
      value.supplierList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.moiety') do
      value.moietyList.Add(parseSubstanceDefinitionMoiety(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.property') do
      value.property_List.Add(parseSubstanceDefinitionProperty(item));
    value.referenceInformation := ParseReference(obj.complex('http://hl7.org/fhir/SubstanceDefinition.referenceInformation'));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.molecularWeight') do
      value.molecularWeightList.Add(parseSubstanceDefinitionMolecularWeight(item));
    value.structure := ParseSubstanceDefinitionStructure(obj.complex('http://hl7.org/fhir/SubstanceDefinition.structure'));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.code') do
      value.codeList.Add(parseSubstanceDefinitionCode(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.name') do
      value.nameList.Add(parseSubstanceDefinitionName(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceDefinition.relationship') do
      value.relationshipList.Add(parseSubstanceDefinitionRelationship(item));
    value.nucleicAcid := ParseReference(obj.complex('http://hl7.org/fhir/SubstanceDefinition.nucleicAcid'));
    value.polymer := ParseReference(obj.complex('http://hl7.org/fhir/SubstanceDefinition.polymer'));
    value.protein := ParseReference(obj.complex('http://hl7.org/fhir/SubstanceDefinition.protein'));
    value.sourceMaterial := ParseSubstanceDefinitionSourceMaterial(obj.complex('http://hl7.org/fhir/SubstanceDefinition.sourceMaterial'));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceDefinition(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceDefinition');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'SubstanceDefinition', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceDefinition', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceDefinition', 'status', value.statusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.classificationList.Count - 1 do
      ComposeCodeableConcept(this, 'SubstanceDefinition', 'classification', value.classificationList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceDefinition', 'domain', value.domainElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.gradeList.Count - 1 do
      ComposeCodeableConcept(this, 'SubstanceDefinition', 'grade', value.gradeList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'SubstanceDefinition', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.informationSourceList.Count - 1 do
      ComposeReference(this, 'SubstanceDefinition', 'informationSource', value.informationSourceList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'SubstanceDefinition', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.manufacturerList.Count - 1 do
      ComposeReference(this, 'SubstanceDefinition', 'manufacturer', value.manufacturerList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.supplierList.Count - 1 do
      ComposeReference(this, 'SubstanceDefinition', 'supplier', value.supplierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.moietyList.Count - 1 do
      ComposeSubstanceDefinitionMoiety(this, 'SubstanceDefinition', 'moiety', value.moietyList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeSubstanceDefinitionProperty(this, 'SubstanceDefinition', 'property', value.property_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'SubstanceDefinition', 'referenceInformation', value.referenceInformationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.molecularWeightList.Count - 1 do
      ComposeSubstanceDefinitionMolecularWeight(this, 'SubstanceDefinition', 'molecularWeight', value.molecularWeightList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceDefinitionStructure(this, 'SubstanceDefinition', 'structure', value.structureElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.codeList.Count - 1 do
      ComposeSubstanceDefinitionCode(this, 'SubstanceDefinition', 'code', value.codeList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.nameList.Count - 1 do
      ComposeSubstanceDefinitionName(this, 'SubstanceDefinition', 'name', value.nameList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.relationshipList.Count - 1 do
      ComposeSubstanceDefinitionRelationship(this, 'SubstanceDefinition', 'relationship', value.relationshipList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'SubstanceDefinition', 'nucleicAcid', value.nucleicAcidElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'SubstanceDefinition', 'polymer', value.polymerElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'SubstanceDefinition', 'protein', value.proteinElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceDefinitionSourceMaterial(this, 'SubstanceDefinition', 'sourceMaterial', value.sourceMaterialElement, false, -1);
end;

{$ENDIF FHIR_SUBSTANCEDEFINITION}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
function TFHIRTurtleParser.ParseSubstanceNucleicAcidSubunit(obj : TTurtleComplex) : TFhirSubstanceNucleicAcidSubunit;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceNucleicAcidSubunit.create;
  try
    ParseSubstanceNucleicAcidSubunitProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceNucleicAcidSubunitProperties(obj : TTurtleComplex; value : TFhirSubstanceNucleicAcidSubunit);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.subunitElement := ParseInteger(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.subunit'));
    value.sequenceElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.sequence'));
    value.lengthElement := ParseInteger(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.length'));
    value.sequenceAttachment := ParseAttachment(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.sequenceAttachment'));
    value.fivePrime := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.fivePrime'));
    value.threePrime := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.threePrime'));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.linkage') do
      value.linkageList.Add(parseSubstanceNucleicAcidSubunitLinkage(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.sugar') do
      value.sugarList.Add(parseSubstanceNucleicAcidSubunitSugar(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceNucleicAcidSubunit(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceNucleicAcidSubunit; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceNucleicAcidSubunit');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'SubstanceNucleicAcid.subunit', 'subunit', value.subunitElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceNucleicAcid.subunit', 'sequence', value.sequenceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'SubstanceNucleicAcid.subunit', 'length', value.lengthElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAttachment(this, 'SubstanceNucleicAcid.subunit', 'sequenceAttachment', value.sequenceAttachmentElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceNucleicAcid.subunit', 'fivePrime', value.fivePrimeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceNucleicAcid.subunit', 'threePrime', value.threePrimeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.linkageList.Count - 1 do
      ComposeSubstanceNucleicAcidSubunitLinkage(this, 'SubstanceNucleicAcid.subunit', 'linkage', value.linkageList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.sugarList.Count - 1 do
      ComposeSubstanceNucleicAcidSubunitSugar(this, 'SubstanceNucleicAcid.subunit', 'sugar', value.sugarList[i], false, i);
end;

function TFHIRTurtleParser.ParseSubstanceNucleicAcidSubunitLinkage(obj : TTurtleComplex) : TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceNucleicAcidSubunitLinkage.create;
  try
    ParseSubstanceNucleicAcidSubunitLinkageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceNucleicAcidSubunitLinkageProperties(obj : TTurtleComplex; value : TFhirSubstanceNucleicAcidSubunitLinkage);
begin
    ParseBackboneElementProperties(obj, value);
    value.connectivityElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.linkage.connectivity'));
    value.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.linkage.identifier'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.linkage.name'));
    value.residueSiteElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.linkage.residueSite'));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceNucleicAcidSubunitLinkage(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceNucleicAcidSubunitLinkage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceNucleicAcidSubunitLinkage');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceNucleicAcid.subunit.linkage', 'connectivity', value.connectivityElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'SubstanceNucleicAcid.subunit.linkage', 'identifier', value.identifierElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceNucleicAcid.subunit.linkage', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceNucleicAcid.subunit.linkage', 'residueSite', value.residueSiteElement, false, -1);
end;

function TFHIRTurtleParser.ParseSubstanceNucleicAcidSubunitSugar(obj : TTurtleComplex) : TFhirSubstanceNucleicAcidSubunitSugar;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceNucleicAcidSubunitSugar.create;
  try
    ParseSubstanceNucleicAcidSubunitSugarProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceNucleicAcidSubunitSugarProperties(obj : TTurtleComplex; value : TFhirSubstanceNucleicAcidSubunitSugar);
begin
    ParseBackboneElementProperties(obj, value);
    value.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.sugar.identifier'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.sugar.name'));
    value.residueSiteElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.sugar.residueSite'));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceNucleicAcidSubunitSugar(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceNucleicAcidSubunitSugar; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceNucleicAcidSubunitSugar');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'SubstanceNucleicAcid.subunit.sugar', 'identifier', value.identifierElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceNucleicAcid.subunit.sugar', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceNucleicAcid.subunit.sugar', 'residueSite', value.residueSiteElement, false, -1);
end;

function TFHIRTurtleParser.ParseSubstanceNucleicAcid(obj : TTurtleComplex) : TFhirSubstanceNucleicAcid;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceNucleicAcid.create;
  try
    ParseSubstanceNucleicAcidProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceNucleicAcidProperties(obj : TTurtleComplex; value : TFhirSubstanceNucleicAcid);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    value.sequenceType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.sequenceType'));
    value.numberOfSubunitsElement := ParseInteger(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.numberOfSubunits'));
    value.areaOfHybridisationElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.areaOfHybridisation'));
    value.oligoNucleotideType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.oligoNucleotideType'));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceNucleicAcid.subunit') do
      value.subunitList.Add(parseSubstanceNucleicAcidSubunit(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceNucleicAcid(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceNucleicAcid; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceNucleicAcid');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceNucleicAcid', 'sequenceType', value.sequenceTypeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'SubstanceNucleicAcid', 'numberOfSubunits', value.numberOfSubunitsElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceNucleicAcid', 'areaOfHybridisation', value.areaOfHybridisationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceNucleicAcid', 'oligoNucleotideType', value.oligoNucleotideTypeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.subunitList.Count - 1 do
      ComposeSubstanceNucleicAcidSubunit(this, 'SubstanceNucleicAcid', 'subunit', value.subunitList[i], false, i);
end;

{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
function TFHIRTurtleParser.ParseSubstancePolymerMonomerSet(obj : TTurtleComplex) : TFhirSubstancePolymerMonomerSet;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstancePolymerMonomerSet.create;
  try
    ParseSubstancePolymerMonomerSetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstancePolymerMonomerSetProperties(obj : TTurtleComplex; value : TFhirSubstancePolymerMonomerSet);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.ratioType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstancePolymer.monomerSet.ratioType'));
    for item in obj.complexes('http://hl7.org/fhir/SubstancePolymer.monomerSet.startingMaterial') do
      value.startingMaterialList.Add(parseSubstancePolymerMonomerSetStartingMaterial(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstancePolymerMonomerSet(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstancePolymerMonomerSet; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstancePolymerMonomerSet');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstancePolymer.monomerSet', 'ratioType', value.ratioTypeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.startingMaterialList.Count - 1 do
      ComposeSubstancePolymerMonomerSetStartingMaterial(this, 'SubstancePolymer.monomerSet', 'startingMaterial', value.startingMaterialList[i], false, i);
end;

function TFHIRTurtleParser.ParseSubstancePolymerMonomerSetStartingMaterial(obj : TTurtleComplex) : TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstancePolymerMonomerSetStartingMaterial.create;
  try
    ParseSubstancePolymerMonomerSetStartingMaterialProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstancePolymerMonomerSetStartingMaterialProperties(obj : TTurtleComplex; value : TFhirSubstancePolymerMonomerSetStartingMaterial);
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstancePolymer.monomerSet.startingMaterial.code'));
    value.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstancePolymer.monomerSet.startingMaterial.category'));
    value.isDefiningElement := ParseBoolean(obj.complex('http://hl7.org/fhir/SubstancePolymer.monomerSet.startingMaterial.isDefining'));
    value.amount := ParseQuantity(obj.complex('http://hl7.org/fhir/SubstancePolymer.monomerSet.startingMaterial.amount'));
end;

procedure TFHIRTurtleComposer.ComposeSubstancePolymerMonomerSetStartingMaterial(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstancePolymerMonomerSetStartingMaterial; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstancePolymerMonomerSetStartingMaterial');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstancePolymer.monomerSet.startingMaterial', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstancePolymer.monomerSet.startingMaterial', 'category', value.categoryElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'SubstancePolymer.monomerSet.startingMaterial', 'isDefining', value.isDefiningElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'SubstancePolymer.monomerSet.startingMaterial', 'amount', value.amountElement, false, -1);
end;

function TFHIRTurtleParser.ParseSubstancePolymerRepeat(obj : TTurtleComplex) : TFhirSubstancePolymerRepeat;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstancePolymerRepeat.create;
  try
    ParseSubstancePolymerRepeatProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstancePolymerRepeatProperties(obj : TTurtleComplex; value : TFhirSubstancePolymerRepeat);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.averageMolecularFormulaElement := ParseString(obj.complex('http://hl7.org/fhir/SubstancePolymer.repeat.averageMolecularFormula'));
    value.repeatUnitAmountType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnitAmountType'));
    for item in obj.complexes('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnit') do
      value.repeatUnitList.Add(parseSubstancePolymerRepeatRepeatUnit(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstancePolymerRepeat(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstancePolymerRepeat; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstancePolymerRepeat');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstancePolymer.repeat', 'averageMolecularFormula', value.averageMolecularFormulaElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstancePolymer.repeat', 'repeatUnitAmountType', value.repeatUnitAmountTypeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.repeatUnitList.Count - 1 do
      ComposeSubstancePolymerRepeatRepeatUnit(this, 'SubstancePolymer.repeat', 'repeatUnit', value.repeatUnitList[i], false, i);
end;

function TFHIRTurtleParser.ParseSubstancePolymerRepeatRepeatUnit(obj : TTurtleComplex) : TFhirSubstancePolymerRepeatRepeatUnit;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstancePolymerRepeatRepeatUnit.create;
  try
    ParseSubstancePolymerRepeatRepeatUnitProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstancePolymerRepeatRepeatUnitProperties(obj : TTurtleComplex; value : TFhirSubstancePolymerRepeatRepeatUnit);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.unit_Element := ParseString(obj.complex('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnit.unit'));
    value.orientation := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnit.orientation'));
    value.amountElement := ParseInteger(obj.complex('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnit.amount'));
    for item in obj.complexes('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation') do
      value.degreeOfPolymerisationList.Add(parseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnit.structuralRepresentation') do
      value.structuralRepresentationList.Add(parseSubstancePolymerRepeatRepeatUnitStructuralRepresentation(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstancePolymerRepeatRepeatUnit(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstancePolymerRepeatRepeatUnit; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstancePolymerRepeatRepeatUnit');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstancePolymer.repeat.repeatUnit', 'unit', value.unit_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstancePolymer.repeat.repeatUnit', 'orientation', value.orientationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'SubstancePolymer.repeat.repeatUnit', 'amount', value.amountElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.degreeOfPolymerisationList.Count - 1 do
      ComposeSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(this, 'SubstancePolymer.repeat.repeatUnit', 'degreeOfPolymerisation', value.degreeOfPolymerisationList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.structuralRepresentationList.Count - 1 do
      ComposeSubstancePolymerRepeatRepeatUnitStructuralRepresentation(this, 'SubstancePolymer.repeat.repeatUnit', 'structuralRepresentation', value.structuralRepresentationList[i], false, i);
end;

function TFHIRTurtleParser.ParseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(obj : TTurtleComplex) : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.create;
  try
    ParseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationProperties(obj : TTurtleComplex; value : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation.type'));
    value.averageElement := ParseInteger(obj.complex('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation.average'));
    value.lowElement := ParseInteger(obj.complex('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation.low'));
    value.highElement := ParseInteger(obj.complex('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation.high'));
end;

procedure TFHIRTurtleComposer.ComposeSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation', 'average', value.averageElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation', 'low', value.lowElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation', 'high', value.highElement, false, -1);
end;

function TFHIRTurtleParser.ParseSubstancePolymerRepeatRepeatUnitStructuralRepresentation(obj : TTurtleComplex) : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.create;
  try
    ParseSubstancePolymerRepeatRepeatUnitStructuralRepresentationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstancePolymerRepeatRepeatUnitStructuralRepresentationProperties(obj : TTurtleComplex; value : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnit.structuralRepresentation.type'));
    value.representationElement := ParseString(obj.complex('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnit.structuralRepresentation.representation'));
    value.format := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnit.structuralRepresentation.format'));
    value.attachment := ParseAttachment(obj.complex('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnit.structuralRepresentation.attachment'));
end;

procedure TFHIRTurtleComposer.ComposeSubstancePolymerRepeatRepeatUnitStructuralRepresentation(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstancePolymerRepeatRepeatUnitStructuralRepresentation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstancePolymer.repeat.repeatUnit.structuralRepresentation', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstancePolymer.repeat.repeatUnit.structuralRepresentation', 'representation', value.representationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstancePolymer.repeat.repeatUnit.structuralRepresentation', 'format', value.formatElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAttachment(this, 'SubstancePolymer.repeat.repeatUnit.structuralRepresentation', 'attachment', value.attachmentElement, false, -1);
end;

function TFHIRTurtleParser.ParseSubstancePolymer(obj : TTurtleComplex) : TFhirSubstancePolymer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstancePolymer.create;
  try
    ParseSubstancePolymerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstancePolymerProperties(obj : TTurtleComplex; value : TFhirSubstancePolymer);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    value.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/SubstancePolymer.identifier'));
    value.class_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstancePolymer.class'));
    value.geometry := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstancePolymer.geometry'));
    for item in obj.complexes('http://hl7.org/fhir/SubstancePolymer.copolymerConnectivity') do
      value.copolymerConnectivityList.Add(parseCodeableConcept(item));
    value.modificationElement := ParseString(obj.complex('http://hl7.org/fhir/SubstancePolymer.modification'));
    for item in obj.complexes('http://hl7.org/fhir/SubstancePolymer.monomerSet') do
      value.monomerSetList.Add(parseSubstancePolymerMonomerSet(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstancePolymer.repeat') do
      value.repeat_List.Add(parseSubstancePolymerRepeat(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstancePolymer(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstancePolymer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstancePolymer');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'SubstancePolymer', 'identifier', value.identifierElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstancePolymer', 'class', value.class_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstancePolymer', 'geometry', value.geometryElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.copolymerConnectivityList.Count - 1 do
      ComposeCodeableConcept(this, 'SubstancePolymer', 'copolymerConnectivity', value.copolymerConnectivityList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstancePolymer', 'modification', value.modificationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.monomerSetList.Count - 1 do
      ComposeSubstancePolymerMonomerSet(this, 'SubstancePolymer', 'monomerSet', value.monomerSetList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.repeat_List.Count - 1 do
      ComposeSubstancePolymerRepeat(this, 'SubstancePolymer', 'repeat', value.repeat_List[i], false, i);
end;

{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
function TFHIRTurtleParser.ParseSubstanceProteinSubunit(obj : TTurtleComplex) : TFhirSubstanceProteinSubunit;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceProteinSubunit.create;
  try
    ParseSubstanceProteinSubunitProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceProteinSubunitProperties(obj : TTurtleComplex; value : TFhirSubstanceProteinSubunit);
begin
    ParseBackboneElementProperties(obj, value);
    value.subunitElement := ParseInteger(obj.complex('http://hl7.org/fhir/SubstanceProtein.subunit.subunit'));
    value.sequenceElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceProtein.subunit.sequence'));
    value.lengthElement := ParseInteger(obj.complex('http://hl7.org/fhir/SubstanceProtein.subunit.length'));
    value.sequenceAttachment := ParseAttachment(obj.complex('http://hl7.org/fhir/SubstanceProtein.subunit.sequenceAttachment'));
    value.nTerminalModificationId := ParseIdentifier(obj.complex('http://hl7.org/fhir/SubstanceProtein.subunit.nTerminalModificationId'));
    value.nTerminalModificationElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceProtein.subunit.nTerminalModification'));
    value.cTerminalModificationId := ParseIdentifier(obj.complex('http://hl7.org/fhir/SubstanceProtein.subunit.cTerminalModificationId'));
    value.cTerminalModificationElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceProtein.subunit.cTerminalModification'));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceProteinSubunit(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceProteinSubunit; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceProteinSubunit');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'SubstanceProtein.subunit', 'subunit', value.subunitElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceProtein.subunit', 'sequence', value.sequenceElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'SubstanceProtein.subunit', 'length', value.lengthElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAttachment(this, 'SubstanceProtein.subunit', 'sequenceAttachment', value.sequenceAttachmentElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'SubstanceProtein.subunit', 'nTerminalModificationId', value.nTerminalModificationIdElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceProtein.subunit', 'nTerminalModification', value.nTerminalModificationElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'SubstanceProtein.subunit', 'cTerminalModificationId', value.cTerminalModificationIdElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceProtein.subunit', 'cTerminalModification', value.cTerminalModificationElement, false, -1);
end;

function TFHIRTurtleParser.ParseSubstanceProtein(obj : TTurtleComplex) : TFhirSubstanceProtein;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceProtein.create;
  try
    ParseSubstanceProteinProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceProteinProperties(obj : TTurtleComplex; value : TFhirSubstanceProtein);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    value.sequenceType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceProtein.sequenceType'));
    value.numberOfSubunitsElement := ParseInteger(obj.complex('http://hl7.org/fhir/SubstanceProtein.numberOfSubunits'));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceProtein.disulfideLinkage') do
      value.disulfideLinkageList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceProtein.subunit') do
      value.subunitList.Add(parseSubstanceProteinSubunit(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceProtein(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceProtein; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceProtein');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceProtein', 'sequenceType', value.sequenceTypeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'SubstanceProtein', 'numberOfSubunits', value.numberOfSubunitsElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.disulfideLinkageList.Count - 1 do
      ComposeString(this, 'SubstanceProtein', 'disulfideLinkage', value.disulfideLinkageList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.subunitList.Count - 1 do
      ComposeSubstanceProteinSubunit(this, 'SubstanceProtein', 'subunit', value.subunitList[i], false, i);
end;

{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
function TFHIRTurtleParser.ParseSubstanceReferenceInformationGene(obj : TTurtleComplex) : TFhirSubstanceReferenceInformationGene;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceReferenceInformationGene.create;
  try
    ParseSubstanceReferenceInformationGeneProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceReferenceInformationGeneProperties(obj : TTurtleComplex; value : TFhirSubstanceReferenceInformationGene);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.geneSequenceOrigin := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceReferenceInformation.gene.geneSequenceOrigin'));
    value.gene := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceReferenceInformation.gene.gene'));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceReferenceInformation.gene.source') do
      value.sourceList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceReferenceInformationGene(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceReferenceInformationGene; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceReferenceInformationGene');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceReferenceInformation.gene', 'geneSequenceOrigin', value.geneSequenceOriginElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceReferenceInformation.gene', 'gene', value.geneElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.sourceList.Count - 1 do
      ComposeReference(this, 'SubstanceReferenceInformation.gene', 'source', value.sourceList[i], false, i);
end;

function TFHIRTurtleParser.ParseSubstanceReferenceInformationGeneElement(obj : TTurtleComplex) : TFhirSubstanceReferenceInformationGeneElement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceReferenceInformationGeneElement.create;
  try
    ParseSubstanceReferenceInformationGeneElementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceReferenceInformationGeneElementProperties(obj : TTurtleComplex; value : TFhirSubstanceReferenceInformationGeneElement);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceReferenceInformation.geneElement.type'));
    value.element := ParseIdentifier(obj.complex('http://hl7.org/fhir/SubstanceReferenceInformation.geneElement.element'));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceReferenceInformation.geneElement.source') do
      value.sourceList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceReferenceInformationGeneElement(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceReferenceInformationGeneElement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceReferenceInformationGeneElement');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceReferenceInformation.geneElement', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'SubstanceReferenceInformation.geneElement', 'element', value.elementElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.sourceList.Count - 1 do
      ComposeReference(this, 'SubstanceReferenceInformation.geneElement', 'source', value.sourceList[i], false, i);
end;

function TFHIRTurtleParser.ParseSubstanceReferenceInformationTarget(obj : TTurtleComplex) : TFhirSubstanceReferenceInformationTarget;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceReferenceInformationTarget.create;
  try
    ParseSubstanceReferenceInformationTargetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceReferenceInformationTargetProperties(obj : TTurtleComplex; value : TFhirSubstanceReferenceInformationTarget);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.target := ParseIdentifier(obj.complex('http://hl7.org/fhir/SubstanceReferenceInformation.target.target'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceReferenceInformation.target.type'));
    value.interaction := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceReferenceInformation.target.interaction'));
    value.organism := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceReferenceInformation.target.organism'));
    value.organismType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceReferenceInformation.target.organismType'));
    if obj.has('amountQuantity', item) then
      value.amount := parseQuantity(item);
    if obj.has('amountRange', item) then
      value.amount := parseRange(item);
    if obj.has('amountString', item) then
      value.amount := parseString(item);
    value.amountType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceReferenceInformation.target.amountType'));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceReferenceInformation.target.source') do
      value.sourceList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceReferenceInformationTarget(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceReferenceInformationTarget; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceReferenceInformationTarget');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'SubstanceReferenceInformation.target', 'target', value.targetElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceReferenceInformation.target', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceReferenceInformation.target', 'interaction', value.interactionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceReferenceInformation.target', 'organism', value.organismElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceReferenceInformation.target', 'organismType', value.organismTypeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.amount is TFhirQuantity) {6} then
    ComposeQuantity(this, 'SubstanceReferenceInformation.target', 'amountQuantity', TFhirQuantity(value.amount), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.amount is TFhirRange) {6} then
    ComposeRange(this, 'SubstanceReferenceInformation.target', 'amountRange', TFhirRange(value.amount), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.amount is TFhirString) {6} then
    ComposeString(this, 'SubstanceReferenceInformation.target', 'amountString', TFhirString(value.amount), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceReferenceInformation.target', 'amountType', value.amountTypeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.sourceList.Count - 1 do
      ComposeReference(this, 'SubstanceReferenceInformation.target', 'source', value.sourceList[i], false, i);
end;

function TFHIRTurtleParser.ParseSubstanceReferenceInformation(obj : TTurtleComplex) : TFhirSubstanceReferenceInformation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceReferenceInformation.create;
  try
    ParseSubstanceReferenceInformationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceReferenceInformationProperties(obj : TTurtleComplex; value : TFhirSubstanceReferenceInformation);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    value.commentElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceReferenceInformation.comment'));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceReferenceInformation.gene') do
      value.geneList.Add(parseSubstanceReferenceInformationGene(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceReferenceInformation.geneElement') do
      value.geneElementList.Add(parseSubstanceReferenceInformationGeneElement(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceReferenceInformation.target') do
      value.targetList.Add(parseSubstanceReferenceInformationTarget(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceReferenceInformation(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceReferenceInformation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceReferenceInformation');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceReferenceInformation', 'comment', value.commentElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.geneList.Count - 1 do
      ComposeSubstanceReferenceInformationGene(this, 'SubstanceReferenceInformation', 'gene', value.geneList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.geneElementList.Count - 1 do
      ComposeSubstanceReferenceInformationGeneElement(this, 'SubstanceReferenceInformation', 'geneElement', value.geneElementList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.targetList.Count - 1 do
      ComposeSubstanceReferenceInformationTarget(this, 'SubstanceReferenceInformation', 'target', value.targetList[i], false, i);
end;

{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
function TFHIRTurtleParser.ParseSubstanceSourceMaterialFractionDescription(obj : TTurtleComplex) : TFhirSubstanceSourceMaterialFractionDescription;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceSourceMaterialFractionDescription.create;
  try
    ParseSubstanceSourceMaterialFractionDescriptionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceSourceMaterialFractionDescriptionProperties(obj : TTurtleComplex; value : TFhirSubstanceSourceMaterialFractionDescription);
begin
    ParseBackboneElementProperties(obj, value);
    value.fractionElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.fractionDescription.fraction'));
    value.materialType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.fractionDescription.materialType'));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceSourceMaterialFractionDescription(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceSourceMaterialFractionDescription; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceSourceMaterialFractionDescription');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceSourceMaterial.fractionDescription', 'fraction', value.fractionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.fractionDescription', 'materialType', value.materialTypeElement, false, -1);
end;

function TFHIRTurtleParser.ParseSubstanceSourceMaterialOrganism(obj : TTurtleComplex) : TFhirSubstanceSourceMaterialOrganism;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceSourceMaterialOrganism.create;
  try
    ParseSubstanceSourceMaterialOrganismProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceSourceMaterialOrganismProperties(obj : TTurtleComplex; value : TFhirSubstanceSourceMaterialOrganism);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.family := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.family'));
    value.genus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.genus'));
    value.species := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.species'));
    value.intraspecificType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.intraspecificType'));
    value.intraspecificDescriptionElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.intraspecificDescription'));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSourceMaterial.organism.author') do
      value.authorList.Add(parseSubstanceSourceMaterialOrganismAuthor(item));
    value.hybrid := ParseSubstanceSourceMaterialOrganismHybrid(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.hybrid'));
    value.organismGeneral := ParseSubstanceSourceMaterialOrganismOrganismGeneral(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.organismGeneral'));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceSourceMaterialOrganism(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceSourceMaterialOrganism; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceSourceMaterialOrganism');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.organism', 'family', value.familyElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.organism', 'genus', value.genusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.organism', 'species', value.speciesElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.organism', 'intraspecificType', value.intraspecificTypeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceSourceMaterial.organism', 'intraspecificDescription', value.intraspecificDescriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeSubstanceSourceMaterialOrganismAuthor(this, 'SubstanceSourceMaterial.organism', 'author', value.authorList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceSourceMaterialOrganismHybrid(this, 'SubstanceSourceMaterial.organism', 'hybrid', value.hybridElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceSourceMaterialOrganismOrganismGeneral(this, 'SubstanceSourceMaterial.organism', 'organismGeneral', value.organismGeneralElement, false, -1);
end;

function TFHIRTurtleParser.ParseSubstanceSourceMaterialOrganismAuthor(obj : TTurtleComplex) : TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceSourceMaterialOrganismAuthor.create;
  try
    ParseSubstanceSourceMaterialOrganismAuthorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceSourceMaterialOrganismAuthorProperties(obj : TTurtleComplex; value : TFhirSubstanceSourceMaterialOrganismAuthor);
begin
    ParseBackboneElementProperties(obj, value);
    value.authorType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.author.authorType'));
    value.authorDescriptionElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.author.authorDescription'));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceSourceMaterialOrganismAuthor(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceSourceMaterialOrganismAuthor; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceSourceMaterialOrganismAuthor');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.organism.author', 'authorType', value.authorTypeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceSourceMaterial.organism.author', 'authorDescription', value.authorDescriptionElement, false, -1);
end;

function TFHIRTurtleParser.ParseSubstanceSourceMaterialOrganismHybrid(obj : TTurtleComplex) : TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceSourceMaterialOrganismHybrid.create;
  try
    ParseSubstanceSourceMaterialOrganismHybridProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceSourceMaterialOrganismHybridProperties(obj : TTurtleComplex; value : TFhirSubstanceSourceMaterialOrganismHybrid);
begin
    ParseBackboneElementProperties(obj, value);
    value.maternalOrganismIdElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.hybrid.maternalOrganismId'));
    value.maternalOrganismNameElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.hybrid.maternalOrganismName'));
    value.paternalOrganismIdElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.hybrid.paternalOrganismId'));
    value.paternalOrganismNameElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.hybrid.paternalOrganismName'));
    value.hybridType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.hybrid.hybridType'));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceSourceMaterialOrganismHybrid(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceSourceMaterialOrganismHybrid; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceSourceMaterialOrganismHybrid');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceSourceMaterial.organism.hybrid', 'maternalOrganismId', value.maternalOrganismIdElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceSourceMaterial.organism.hybrid', 'maternalOrganismName', value.maternalOrganismNameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceSourceMaterial.organism.hybrid', 'paternalOrganismId', value.paternalOrganismIdElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceSourceMaterial.organism.hybrid', 'paternalOrganismName', value.paternalOrganismNameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.organism.hybrid', 'hybridType', value.hybridTypeElement, false, -1);
end;

function TFHIRTurtleParser.ParseSubstanceSourceMaterialOrganismOrganismGeneral(obj : TTurtleComplex) : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral.create;
  try
    ParseSubstanceSourceMaterialOrganismOrganismGeneralProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceSourceMaterialOrganismOrganismGeneralProperties(obj : TTurtleComplex; value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
begin
    ParseBackboneElementProperties(obj, value);
    value.kingdom := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.organismGeneral.kingdom'));
    value.phylum := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.organismGeneral.phylum'));
    value.class_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.organismGeneral.class'));
    value.order := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.organismGeneral.order'));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceSourceMaterialOrganismOrganismGeneral(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceSourceMaterialOrganismOrganismGeneral');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.organism.organismGeneral', 'kingdom', value.kingdomElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.organism.organismGeneral', 'phylum', value.phylumElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.organism.organismGeneral', 'class', value.class_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.organism.organismGeneral', 'order', value.orderElement, false, -1);
end;

function TFHIRTurtleParser.ParseSubstanceSourceMaterialPartDescription(obj : TTurtleComplex) : TFhirSubstanceSourceMaterialPartDescription;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceSourceMaterialPartDescription.create;
  try
    ParseSubstanceSourceMaterialPartDescriptionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceSourceMaterialPartDescriptionProperties(obj : TTurtleComplex; value : TFhirSubstanceSourceMaterialPartDescription);
begin
    ParseBackboneElementProperties(obj, value);
    value.part := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.partDescription.part'));
    value.partLocation := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.partDescription.partLocation'));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceSourceMaterialPartDescription(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceSourceMaterialPartDescription; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceSourceMaterialPartDescription');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.partDescription', 'part', value.partElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.partDescription', 'partLocation', value.partLocationElement, false, -1);
end;

function TFHIRTurtleParser.ParseSubstanceSourceMaterial(obj : TTurtleComplex) : TFhirSubstanceSourceMaterial;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceSourceMaterial.create;
  try
    ParseSubstanceSourceMaterialProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceSourceMaterialProperties(obj : TTurtleComplex; value : TFhirSubstanceSourceMaterial);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    value.sourceMaterialClass := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.sourceMaterialClass'));
    value.sourceMaterialType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.sourceMaterialType'));
    value.sourceMaterialState := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.sourceMaterialState'));
    value.organismId := ParseIdentifier(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organismId'));
    value.organismNameElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organismName'));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSourceMaterial.parentSubstanceId') do
      value.parentSubstanceIdList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSourceMaterial.parentSubstanceName') do
      value.parentSubstanceNameList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSourceMaterial.countryOfOrigin') do
      value.countryOfOriginList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSourceMaterial.geographicalLocation') do
      value.geographicalLocationList.Add(parseString(item));
    value.developmentStage := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.developmentStage'));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSourceMaterial.fractionDescription') do
      value.fractionDescriptionList.Add(parseSubstanceSourceMaterialFractionDescription(item));
    value.organism := ParseSubstanceSourceMaterialOrganism(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism'));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSourceMaterial.partDescription') do
      value.partDescriptionList.Add(parseSubstanceSourceMaterialPartDescription(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceSourceMaterial(parent :  TTurtleComplex; parentType, name : String; value : TFhirSubstanceSourceMaterial; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceSourceMaterial');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial', 'sourceMaterialClass', value.sourceMaterialClassElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial', 'sourceMaterialType', value.sourceMaterialTypeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial', 'sourceMaterialState', value.sourceMaterialStateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'SubstanceSourceMaterial', 'organismId', value.organismIdElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceSourceMaterial', 'organismName', value.organismNameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.parentSubstanceIdList.Count - 1 do
      ComposeIdentifier(this, 'SubstanceSourceMaterial', 'parentSubstanceId', value.parentSubstanceIdList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.parentSubstanceNameList.Count - 1 do
      ComposeString(this, 'SubstanceSourceMaterial', 'parentSubstanceName', value.parentSubstanceNameList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.countryOfOriginList.Count - 1 do
      ComposeCodeableConcept(this, 'SubstanceSourceMaterial', 'countryOfOrigin', value.countryOfOriginList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.geographicalLocationList.Count - 1 do
      ComposeString(this, 'SubstanceSourceMaterial', 'geographicalLocation', value.geographicalLocationList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial', 'developmentStage', value.developmentStageElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.fractionDescriptionList.Count - 1 do
      ComposeSubstanceSourceMaterialFractionDescription(this, 'SubstanceSourceMaterial', 'fractionDescription', value.fractionDescriptionList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceSourceMaterialOrganism(this, 'SubstanceSourceMaterial', 'organism', value.organismElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partDescriptionList.Count - 1 do
      ComposeSubstanceSourceMaterialPartDescription(this, 'SubstanceSourceMaterial', 'partDescription', value.partDescriptionList[i], false, i);
end;

{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUPPLYDELIVERY}
function TFHIRTurtleParser.ParseSupplyDeliverySuppliedItem(obj : TTurtleComplex) : TFhirSupplyDeliverySuppliedItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSupplyDeliverySuppliedItem.create;
  try
    ParseSupplyDeliverySuppliedItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSupplyDeliverySuppliedItemProperties(obj : TTurtleComplex; value : TFhirSupplyDeliverySuppliedItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/SupplyDelivery.suppliedItem.quantity'));
    if obj.has('itemCodeableConcept', item) then
      value.item := parseCodeableConcept(item);
    if obj.has('itemReference', item) {a3} then
      value.item := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeSupplyDeliverySuppliedItem(parent :  TTurtleComplex; parentType, name : String; value : TFhirSupplyDeliverySuppliedItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SupplyDeliverySuppliedItem');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'SupplyDelivery.suppliedItem', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'SupplyDelivery.suppliedItem', 'itemCodeableConcept', TFhirCodeableConcept(value.item), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.item is TFhirReference) {2} then
    ComposeReference(this, 'SupplyDelivery.suppliedItem', 'itemReference', TFhirReference(value.item), false,-1);
end;

function TFHIRTurtleParser.ParseSupplyDelivery(obj : TTurtleComplex) : TFhirSupplyDelivery;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSupplyDelivery.create;
  try
    ParseSupplyDeliveryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSupplyDeliveryProperties(obj : TTurtleComplex; value : TFhirSupplyDelivery);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/SupplyDelivery.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/SupplyDelivery.basedOn') do
      value.basedOnList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/SupplyDelivery.partOf') do
      value.partOfList.Add(parseReference(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/SupplyDelivery.status'), CODES_TFhirSupplyDeliveryStatusEnum, SYSTEMS_TFhirSupplyDeliveryStatusEnum);
    value.patient := ParseReference(obj.complex('http://hl7.org/fhir/SupplyDelivery.patient'));
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SupplyDelivery.type'));
    for item in obj.complexes('http://hl7.org/fhir/SupplyDelivery.suppliedItem') do
      value.suppliedItemList.Add(parseSupplyDeliverySuppliedItem(item));
    if obj.has('occurrencePeriod', item) then
      value.occurrence := parsePeriod(item);
    if obj.has('occurrenceTiming', item) then
      value.occurrence := parseTiming(item);
    if obj.has('occurrenceDateTime', item) then
      value.occurrence := parseDateTime(item);
    value.supplier := ParseReference(obj.complex('http://hl7.org/fhir/SupplyDelivery.supplier'));
    value.destination := ParseReference(obj.complex('http://hl7.org/fhir/SupplyDelivery.destination'));
    for item in obj.complexes('http://hl7.org/fhir/SupplyDelivery.receiver') do
      value.receiverList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeSupplyDelivery(parent :  TTurtleComplex; parentType, name : String; value : TFhirSupplyDelivery; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SupplyDelivery');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'SupplyDelivery', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'SupplyDelivery', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(this, 'SupplyDelivery', 'partOf', value.partOfList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'SupplyDelivery', 'status', value.statusElement, CODES_TFhirSupplyDeliveryStatusEnum, SYSTEMS_TFhirSupplyDeliveryStatusEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'SupplyDelivery', 'patient', value.patientElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'SupplyDelivery', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.suppliedItemList.Count - 1 do
      ComposeSupplyDeliverySuppliedItem(this, 'SupplyDelivery', 'suppliedItem', value.suppliedItemList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'SupplyDelivery', 'occurrencePeriod', TFhirPeriod(value.occurrence), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirTiming) {6} then
    ComposeTiming(this, 'SupplyDelivery', 'occurrenceTiming', TFhirTiming(value.occurrence), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'SupplyDelivery', 'occurrenceDateTime', TFhirDateTime(value.occurrence), false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'SupplyDelivery', 'supplier', value.supplierElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'SupplyDelivery', 'destination', value.destinationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.receiverList.Count - 1 do
      ComposeReference(this, 'SupplyDelivery', 'receiver', value.receiverList[i], false, i);
end;

{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
function TFHIRTurtleParser.ParseSupplyRequestParameter(obj : TTurtleComplex) : TFhirSupplyRequestParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSupplyRequestParameter.create;
  try
    ParseSupplyRequestParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSupplyRequestParameterProperties(obj : TTurtleComplex; value : TFhirSupplyRequestParameter);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SupplyRequest.parameter.code'));
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueRange', item) then
      value.value := parseRange(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
end;

procedure TFHIRTurtleComposer.ComposeSupplyRequestParameter(parent :  TTurtleComplex; parentType, name : String; value : TFhirSupplyRequestParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SupplyRequestParameter');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'SupplyRequest.parameter', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'SupplyRequest.parameter', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'SupplyRequest.parameter', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirRange) {6} then
    ComposeRange(this, 'SupplyRequest.parameter', 'valueRange', TFhirRange(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'SupplyRequest.parameter', 'valueBoolean', TFhirBoolean(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseSupplyRequest(obj : TTurtleComplex) : TFhirSupplyRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSupplyRequest.create;
  try
    ParseSupplyRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSupplyRequestProperties(obj : TTurtleComplex; value : TFhirSupplyRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/SupplyRequest.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/SupplyRequest.status'), CODES_TFhirSupplyRequestStatusEnum, SYSTEMS_TFhirSupplyRequestStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/SupplyRequest.basedOn') do
      value.basedOnList.Add(parseReference(item));
    value.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SupplyRequest.category'));
    value.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/SupplyRequest.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    value.item := ParseCodeableReference(obj.complex('http://hl7.org/fhir/SupplyRequest.item'));
    value.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/SupplyRequest.quantity'));
    for item in obj.complexes('http://hl7.org/fhir/SupplyRequest.parameter') do
      value.parameterList.Add(parseSupplyRequestParameter(item));
    if obj.has('occurrencePeriod', item) then
      value.occurrence := parsePeriod(item);
    if obj.has('occurrenceTiming', item) then
      value.occurrence := parseTiming(item);
    if obj.has('occurrenceDateTime', item) then
      value.occurrence := parseDateTime(item);
    value.authoredOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/SupplyRequest.authoredOn'));
    value.requester := ParseReference(obj.complex('http://hl7.org/fhir/SupplyRequest.requester'));
    for item in obj.complexes('http://hl7.org/fhir/SupplyRequest.supplier') do
      value.supplierList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/SupplyRequest.reason') do
      value.reasonList.Add(parseCodeableReference(item));
    value.deliverFrom := ParseReference(obj.complex('http://hl7.org/fhir/SupplyRequest.deliverFrom'));
    value.deliverTo := ParseReference(obj.complex('http://hl7.org/fhir/SupplyRequest.deliverTo'));
end;

procedure TFHIRTurtleComposer.ComposeSupplyRequest(parent :  TTurtleComplex; parentType, name : String; value : TFhirSupplyRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SupplyRequest');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'SupplyRequest', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'SupplyRequest', 'status', value.statusElement, CODES_TFhirSupplyRequestStatusEnum, SYSTEMS_TFhirSupplyRequestStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'SupplyRequest', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SupplyRequest', 'category', value.categoryElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'SupplyRequest', 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);
  ComposeCodeableReference(this, 'SupplyRequest', 'item', value.itemElement, false, -1);
  ComposeQuantity(this, 'SupplyRequest', 'quantity', value.quantityElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.parameterList.Count - 1 do
      ComposeSupplyRequestParameter(this, 'SupplyRequest', 'parameter', value.parameterList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'SupplyRequest', 'occurrencePeriod', TFhirPeriod(value.occurrence), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirTiming) {6} then
    ComposeTiming(this, 'SupplyRequest', 'occurrenceTiming', TFhirTiming(value.occurrence), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'SupplyRequest', 'occurrenceDateTime', TFhirDateTime(value.occurrence), false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'SupplyRequest', 'authoredOn', value.authoredOnElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'SupplyRequest', 'requester', value.requesterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.supplierList.Count - 1 do
      ComposeReference(this, 'SupplyRequest', 'supplier', value.supplierList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(this, 'SupplyRequest', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'SupplyRequest', 'deliverFrom', value.deliverFromElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'SupplyRequest', 'deliverTo', value.deliverToElement, false, -1);
end;

{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
function TFHIRTurtleParser.ParseTaskRestriction(obj : TTurtleComplex) : TFhirTaskRestriction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTaskRestriction.create;
  try
    ParseTaskRestrictionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTaskRestrictionProperties(obj : TTurtleComplex; value : TFhirTaskRestriction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.repetitionsElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Task.restriction.repetitions'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Task.restriction.period'));
    for item in obj.complexes('http://hl7.org/fhir/Task.restriction.recipient') do
      value.recipientList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeTaskRestriction(parent :  TTurtleComplex; parentType, name : String; value : TFhirTaskRestriction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TaskRestriction');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'Task.restriction', 'repetitions', value.repetitionsElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Task.restriction', 'period', value.periodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.recipientList.Count - 1 do
      ComposeReference(this, 'Task.restriction', 'recipient', value.recipientList[i], false, i);
end;

function TFHIRTurtleParser.ParseTaskInput(obj : TTurtleComplex) : TFhirTaskInput;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTaskInput.create;
  try
    ParseTaskInputProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTaskInputProperties(obj : TTurtleComplex; value : TFhirTaskInput);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Task.input.type'));
    if obj.has('valueCanonical', item) then
      value.value := parseCanonical(item);
    if obj.has('valueCode', item) then
      value.value := parseCode(item);
    if obj.has('valueId', item) then
      value.value := parseId(item);
    if obj.has('valueMarkdown', item) then
      value.value := parseMarkdown(item);
    if obj.has('valueOid', item) then
      value.value := parseOid(item);
    if obj.has('valuePositiveInt', item) then
      value.value := parsePositiveInt(item);
    if obj.has('valueUnsignedInt', item) then
      value.value := parseUnsignedInt(item);
    if obj.has('valueUrl', item) then
      value.value := parseUrl(item);
    if obj.has('valueUuid', item) then
      value.value := parseUuid(item);
    if obj.has('valueAddress', item) then
      value.value := parseAddress(item);
    if obj.has('valueAge', item) then
      value.value := parseAge(item);
    if obj.has('valueAnnotation', item) then
      value.value := parseAnnotation(item);
    if obj.has('valueAttachment', item) then
      value.value := parseAttachment(item);
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueCodeableReference', item) then
      value.value := parseCodeableReference(item);
    if obj.has('valueCoding', item) then
      value.value := parseCoding(item);
    if obj.has('valueContactPoint', item) then
      value.value := parseContactPoint(item);
    if obj.has('valueCount', item) then
      value.value := parseCount(item);
    if obj.has('valueDistance', item) then
      value.value := parseDistance(item);
    if obj.has('valueDuration', item) then
      value.value := parseDuration(item);
    if obj.has('valueHumanName', item) then
      value.value := parseHumanName(item);
    if obj.has('valueIdentifier', item) then
      value.value := parseIdentifier(item);
    if obj.has('valueMoney', item) then
      value.value := parseMoney(item);
    if obj.has('valuePeriod', item) then
      value.value := parsePeriod(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueRange', item) then
      value.value := parseRange(item);
    if obj.has('valueRatio', item) then
      value.value := parseRatio(item);
    if obj.has('valueRatioRange', item) then
      value.value := parseRatioRange(item);
    if obj.has('valueReference', item) then
      value.value := parseReference(item);
    if obj.has('valueSampledData', item) then
      value.value := parseSampledData(item);
    if obj.has('valueSignature', item) then
      value.value := parseSignature(item);
    if obj.has('valueTiming', item) then
      value.value := parseTiming(item);
    if obj.has('valueContactDetail', item) then
      value.value := parseContactDetail(item);
    if obj.has('valueDataRequirement', item) then
      value.value := parseDataRequirement(item);
    if obj.has('valueExpression', item) then
      value.value := parseExpression(item);
    if obj.has('valueParameterDefinition', item) then
      value.value := parseParameterDefinition(item);
    if obj.has('valueRelatedArtifact', item) then
      value.value := parseRelatedArtifact(item);
    if obj.has('valueTriggerDefinition', item) then
      value.value := parseTriggerDefinition(item);
    if obj.has('valueUsageContext', item) then
      value.value := parseUsageContext(item);
    if obj.has('valueAvailability', item) then
      value.value := parseAvailability(item);
    if obj.has('valueExtendedContactDetail', item) then
      value.value := parseExtendedContactDetail(item);
    if obj.has('valueDosage', item) then
      value.value := parseDosage(item);
    if obj.has('valueMeta', item) then
      value.value := parseMeta(item);
    if obj.has('valueBase64Binary', item) then
      value.value := parseBase64Binary(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    if obj.has('valueDate', item) then
      value.value := parseDate(item);
    if obj.has('valueDateTime', item) then
      value.value := parseDateTime(item);
    if obj.has('valueDecimal', item) then
      value.value := parseDecimal(item);
    if obj.has('valueInstant', item) then
      value.value := parseInstant(item);
    if obj.has('valueInteger', item) then
      value.value := parseInteger(item);
    if obj.has('valueInteger64', item) then
      value.value := parseInteger64(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    if obj.has('valueTime', item) then
      value.value := parseTime(item);
    if obj.has('valueUri', item) then
      value.value := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeTaskInput(parent :  TTurtleComplex; parentType, name : String; value : TFhirTaskInput; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TaskInput');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'Task.input', 'type', value.type_Element, false, -1);
  if (value.value is TFhirCanonical) {6} then
    ComposeCanonical(this, 'Task.input', 'valueCanonical', TFhirCanonical(value.value), false, -1)
  else if (value.value is TFhirCode) {6} then
    ComposeCode(this, 'Task.input', 'valueCode', TFhirCode(value.value), false, -1)
  else if (value.value is TFhirId) {6} then
    ComposeId(this, 'Task.input', 'valueId', TFhirId(value.value), false, -1)
  else if (value.value is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'Task.input', 'valueMarkdown', TFhirMarkdown(value.value), false, -1)
  else if (value.value is TFhirOid) {6} then
    ComposeOid(this, 'Task.input', 'valueOid', TFhirOid(value.value), false, -1)
  else if (value.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'Task.input', 'valuePositiveInt', TFhirPositiveInt(value.value), false, -1)
  else if (value.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'Task.input', 'valueUnsignedInt', TFhirUnsignedInt(value.value), false, -1)
  else if (value.value is TFhirUrl) {6} then
    ComposeUrl(this, 'Task.input', 'valueUrl', TFhirUrl(value.value), false, -1)
  else if (value.value is TFhirUuid) {6} then
    ComposeUuid(this, 'Task.input', 'valueUuid', TFhirUuid(value.value), false, -1)
  else if (value.value is TFhirAddress) {6} then
    ComposeAddress(this, 'Task.input', 'valueAddress', TFhirAddress(value.value), false, -1)
  else if (value.value is TFhirAge) {6} then
    ComposeAge(this, 'Task.input', 'valueAge', TFhirAge(value.value), false, -1)
  else if (value.value is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'Task.input', 'valueAnnotation', TFhirAnnotation(value.value), false, -1)
  else if (value.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Task.input', 'valueAttachment', TFhirAttachment(value.value), false, -1)
  else if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Task.input', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (value.value is TFhirCodeableReference) {6} then
    ComposeCodeableReference(this, 'Task.input', 'valueCodeableReference', TFhirCodeableReference(value.value), false, -1)
  else if (value.value is TFhirCoding) {6} then
    ComposeCoding(this, 'Task.input', 'valueCoding', TFhirCoding(value.value), false, -1)
  else if (value.value is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'Task.input', 'valueContactPoint', TFhirContactPoint(value.value), false, -1)
  else if (value.value is TFhirCount) {6} then
    ComposeCount(this, 'Task.input', 'valueCount', TFhirCount(value.value), false, -1)
  else if (value.value is TFhirDistance) {6} then
    ComposeDistance(this, 'Task.input', 'valueDistance', TFhirDistance(value.value), false, -1)
  else if (value.value is TFhirDuration) {6} then
    ComposeDuration(this, 'Task.input', 'valueDuration', TFhirDuration(value.value), false, -1)
  else if (value.value is TFhirHumanName) {6} then
    ComposeHumanName(this, 'Task.input', 'valueHumanName', TFhirHumanName(value.value), false, -1)
  else if (value.value is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'Task.input', 'valueIdentifier', TFhirIdentifier(value.value), false, -1)
  else if (value.value is TFhirMoney) {6} then
    ComposeMoney(this, 'Task.input', 'valueMoney', TFhirMoney(value.value), false, -1)
  else if (value.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'Task.input', 'valuePeriod', TFhirPeriod(value.value), false, -1)
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Task.input', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (value.value is TFhirRange) {6} then
    ComposeRange(this, 'Task.input', 'valueRange', TFhirRange(value.value), false, -1)
  else if (value.value is TFhirRatio) {6} then
    ComposeRatio(this, 'Task.input', 'valueRatio', TFhirRatio(value.value), false, -1)
  else if (value.value is TFhirRatioRange) {6} then
    ComposeRatioRange(this, 'Task.input', 'valueRatioRange', TFhirRatioRange(value.value), false, -1)
  else if (value.value is TFhirReference) {6} then
    ComposeReference(this, 'Task.input', 'valueReference', TFhirReference(value.value), false, -1)
  else if (value.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'Task.input', 'valueSampledData', TFhirSampledData(value.value), false, -1)
  else if (value.value is TFhirSignature) {6} then
    ComposeSignature(this, 'Task.input', 'valueSignature', TFhirSignature(value.value), false, -1)
  else if (value.value is TFhirTiming) {6} then
    ComposeTiming(this, 'Task.input', 'valueTiming', TFhirTiming(value.value), false, -1)
  else if (value.value is TFhirContactDetail) {6} then
    ComposeContactDetail(this, 'Task.input', 'valueContactDetail', TFhirContactDetail(value.value), false, -1)
  else if (value.value is TFhirDataRequirement) {6} then
    ComposeDataRequirement(this, 'Task.input', 'valueDataRequirement', TFhirDataRequirement(value.value), false, -1)
  else if (value.value is TFhirExpression) {6} then
    ComposeExpression(this, 'Task.input', 'valueExpression', TFhirExpression(value.value), false, -1)
  else if (value.value is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(this, 'Task.input', 'valueParameterDefinition', TFhirParameterDefinition(value.value), false, -1)
  else if (value.value is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(this, 'Task.input', 'valueRelatedArtifact', TFhirRelatedArtifact(value.value), false, -1)
  else if (value.value is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(this, 'Task.input', 'valueTriggerDefinition', TFhirTriggerDefinition(value.value), false, -1)
  else if (value.value is TFhirUsageContext) {6} then
    ComposeUsageContext(this, 'Task.input', 'valueUsageContext', TFhirUsageContext(value.value), false, -1)
  else if (value.value is TFhirAvailability) {6} then
    ComposeAvailability(this, 'Task.input', 'valueAvailability', TFhirAvailability(value.value), false, -1)
  else if (value.value is TFhirExtendedContactDetail) {6} then
    ComposeExtendedContactDetail(this, 'Task.input', 'valueExtendedContactDetail', TFhirExtendedContactDetail(value.value), false, -1)
  else if (value.value is TFhirDosage) {6} then
    ComposeDosage(this, 'Task.input', 'valueDosage', TFhirDosage(value.value), false, -1)
  else if (value.value is TFhirMeta) {6} then
    ComposeMeta(this, 'Task.input', 'valueMeta', TFhirMeta(value.value), false, -1)
  else if (value.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'Task.input', 'valueBase64Binary', TFhirBase64Binary(value.value), false, -1)
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Task.input', 'valueBoolean', TFhirBoolean(value.value), false, -1)
  else if (value.value is TFhirDate) {6} then
    ComposeDate(this, 'Task.input', 'valueDate', TFhirDate(value.value), false, -1)
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Task.input', 'valueDateTime', TFhirDateTime(value.value), false, -1)
  else if (value.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'Task.input', 'valueDecimal', TFhirDecimal(value.value), false, -1)
  else if (value.value is TFhirInstant) {6} then
    ComposeInstant(this, 'Task.input', 'valueInstant', TFhirInstant(value.value), false, -1)
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Task.input', 'valueInteger', TFhirInteger(value.value), false, -1)
  else if (value.value is TFhirInteger64) {6} then
    ComposeInteger64(this, 'Task.input', 'valueInteger64', TFhirInteger64(value.value), false, -1)
  else if (value.value is TFhirString) {6} then
    ComposeString(this, 'Task.input', 'valueString', TFhirString(value.value), false, -1)
  else if (value.value is TFhirTime) {6} then
    ComposeTime(this, 'Task.input', 'valueTime', TFhirTime(value.value), false, -1)
  else if (value.value is TFhirUri) {6} then
    ComposeUri(this, 'Task.input', 'valueUri', TFhirUri(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseTaskOutput(obj : TTurtleComplex) : TFhirTaskOutput;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTaskOutput.create;
  try
    ParseTaskOutputProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTaskOutputProperties(obj : TTurtleComplex; value : TFhirTaskOutput);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Task.output.type'));
    if obj.has('valueCanonical', item) then
      value.value := parseCanonical(item);
    if obj.has('valueCode', item) then
      value.value := parseCode(item);
    if obj.has('valueId', item) then
      value.value := parseId(item);
    if obj.has('valueMarkdown', item) then
      value.value := parseMarkdown(item);
    if obj.has('valueOid', item) then
      value.value := parseOid(item);
    if obj.has('valuePositiveInt', item) then
      value.value := parsePositiveInt(item);
    if obj.has('valueUnsignedInt', item) then
      value.value := parseUnsignedInt(item);
    if obj.has('valueUrl', item) then
      value.value := parseUrl(item);
    if obj.has('valueUuid', item) then
      value.value := parseUuid(item);
    if obj.has('valueAddress', item) then
      value.value := parseAddress(item);
    if obj.has('valueAge', item) then
      value.value := parseAge(item);
    if obj.has('valueAnnotation', item) then
      value.value := parseAnnotation(item);
    if obj.has('valueAttachment', item) then
      value.value := parseAttachment(item);
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueCodeableReference', item) then
      value.value := parseCodeableReference(item);
    if obj.has('valueCoding', item) then
      value.value := parseCoding(item);
    if obj.has('valueContactPoint', item) then
      value.value := parseContactPoint(item);
    if obj.has('valueCount', item) then
      value.value := parseCount(item);
    if obj.has('valueDistance', item) then
      value.value := parseDistance(item);
    if obj.has('valueDuration', item) then
      value.value := parseDuration(item);
    if obj.has('valueHumanName', item) then
      value.value := parseHumanName(item);
    if obj.has('valueIdentifier', item) then
      value.value := parseIdentifier(item);
    if obj.has('valueMoney', item) then
      value.value := parseMoney(item);
    if obj.has('valuePeriod', item) then
      value.value := parsePeriod(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueRange', item) then
      value.value := parseRange(item);
    if obj.has('valueRatio', item) then
      value.value := parseRatio(item);
    if obj.has('valueRatioRange', item) then
      value.value := parseRatioRange(item);
    if obj.has('valueReference', item) then
      value.value := parseReference(item);
    if obj.has('valueSampledData', item) then
      value.value := parseSampledData(item);
    if obj.has('valueSignature', item) then
      value.value := parseSignature(item);
    if obj.has('valueTiming', item) then
      value.value := parseTiming(item);
    if obj.has('valueContactDetail', item) then
      value.value := parseContactDetail(item);
    if obj.has('valueDataRequirement', item) then
      value.value := parseDataRequirement(item);
    if obj.has('valueExpression', item) then
      value.value := parseExpression(item);
    if obj.has('valueParameterDefinition', item) then
      value.value := parseParameterDefinition(item);
    if obj.has('valueRelatedArtifact', item) then
      value.value := parseRelatedArtifact(item);
    if obj.has('valueTriggerDefinition', item) then
      value.value := parseTriggerDefinition(item);
    if obj.has('valueUsageContext', item) then
      value.value := parseUsageContext(item);
    if obj.has('valueAvailability', item) then
      value.value := parseAvailability(item);
    if obj.has('valueExtendedContactDetail', item) then
      value.value := parseExtendedContactDetail(item);
    if obj.has('valueDosage', item) then
      value.value := parseDosage(item);
    if obj.has('valueMeta', item) then
      value.value := parseMeta(item);
    if obj.has('valueBase64Binary', item) then
      value.value := parseBase64Binary(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    if obj.has('valueDate', item) then
      value.value := parseDate(item);
    if obj.has('valueDateTime', item) then
      value.value := parseDateTime(item);
    if obj.has('valueDecimal', item) then
      value.value := parseDecimal(item);
    if obj.has('valueInstant', item) then
      value.value := parseInstant(item);
    if obj.has('valueInteger', item) then
      value.value := parseInteger(item);
    if obj.has('valueInteger64', item) then
      value.value := parseInteger64(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    if obj.has('valueTime', item) then
      value.value := parseTime(item);
    if obj.has('valueUri', item) then
      value.value := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeTaskOutput(parent :  TTurtleComplex; parentType, name : String; value : TFhirTaskOutput; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TaskOutput');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'Task.output', 'type', value.type_Element, false, -1);
  if (value.value is TFhirCanonical) {6} then
    ComposeCanonical(this, 'Task.output', 'valueCanonical', TFhirCanonical(value.value), false, -1)
  else if (value.value is TFhirCode) {6} then
    ComposeCode(this, 'Task.output', 'valueCode', TFhirCode(value.value), false, -1)
  else if (value.value is TFhirId) {6} then
    ComposeId(this, 'Task.output', 'valueId', TFhirId(value.value), false, -1)
  else if (value.value is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'Task.output', 'valueMarkdown', TFhirMarkdown(value.value), false, -1)
  else if (value.value is TFhirOid) {6} then
    ComposeOid(this, 'Task.output', 'valueOid', TFhirOid(value.value), false, -1)
  else if (value.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'Task.output', 'valuePositiveInt', TFhirPositiveInt(value.value), false, -1)
  else if (value.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'Task.output', 'valueUnsignedInt', TFhirUnsignedInt(value.value), false, -1)
  else if (value.value is TFhirUrl) {6} then
    ComposeUrl(this, 'Task.output', 'valueUrl', TFhirUrl(value.value), false, -1)
  else if (value.value is TFhirUuid) {6} then
    ComposeUuid(this, 'Task.output', 'valueUuid', TFhirUuid(value.value), false, -1)
  else if (value.value is TFhirAddress) {6} then
    ComposeAddress(this, 'Task.output', 'valueAddress', TFhirAddress(value.value), false, -1)
  else if (value.value is TFhirAge) {6} then
    ComposeAge(this, 'Task.output', 'valueAge', TFhirAge(value.value), false, -1)
  else if (value.value is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'Task.output', 'valueAnnotation', TFhirAnnotation(value.value), false, -1)
  else if (value.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Task.output', 'valueAttachment', TFhirAttachment(value.value), false, -1)
  else if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Task.output', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (value.value is TFhirCodeableReference) {6} then
    ComposeCodeableReference(this, 'Task.output', 'valueCodeableReference', TFhirCodeableReference(value.value), false, -1)
  else if (value.value is TFhirCoding) {6} then
    ComposeCoding(this, 'Task.output', 'valueCoding', TFhirCoding(value.value), false, -1)
  else if (value.value is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'Task.output', 'valueContactPoint', TFhirContactPoint(value.value), false, -1)
  else if (value.value is TFhirCount) {6} then
    ComposeCount(this, 'Task.output', 'valueCount', TFhirCount(value.value), false, -1)
  else if (value.value is TFhirDistance) {6} then
    ComposeDistance(this, 'Task.output', 'valueDistance', TFhirDistance(value.value), false, -1)
  else if (value.value is TFhirDuration) {6} then
    ComposeDuration(this, 'Task.output', 'valueDuration', TFhirDuration(value.value), false, -1)
  else if (value.value is TFhirHumanName) {6} then
    ComposeHumanName(this, 'Task.output', 'valueHumanName', TFhirHumanName(value.value), false, -1)
  else if (value.value is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'Task.output', 'valueIdentifier', TFhirIdentifier(value.value), false, -1)
  else if (value.value is TFhirMoney) {6} then
    ComposeMoney(this, 'Task.output', 'valueMoney', TFhirMoney(value.value), false, -1)
  else if (value.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'Task.output', 'valuePeriod', TFhirPeriod(value.value), false, -1)
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Task.output', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (value.value is TFhirRange) {6} then
    ComposeRange(this, 'Task.output', 'valueRange', TFhirRange(value.value), false, -1)
  else if (value.value is TFhirRatio) {6} then
    ComposeRatio(this, 'Task.output', 'valueRatio', TFhirRatio(value.value), false, -1)
  else if (value.value is TFhirRatioRange) {6} then
    ComposeRatioRange(this, 'Task.output', 'valueRatioRange', TFhirRatioRange(value.value), false, -1)
  else if (value.value is TFhirReference) {6} then
    ComposeReference(this, 'Task.output', 'valueReference', TFhirReference(value.value), false, -1)
  else if (value.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'Task.output', 'valueSampledData', TFhirSampledData(value.value), false, -1)
  else if (value.value is TFhirSignature) {6} then
    ComposeSignature(this, 'Task.output', 'valueSignature', TFhirSignature(value.value), false, -1)
  else if (value.value is TFhirTiming) {6} then
    ComposeTiming(this, 'Task.output', 'valueTiming', TFhirTiming(value.value), false, -1)
  else if (value.value is TFhirContactDetail) {6} then
    ComposeContactDetail(this, 'Task.output', 'valueContactDetail', TFhirContactDetail(value.value), false, -1)
  else if (value.value is TFhirDataRequirement) {6} then
    ComposeDataRequirement(this, 'Task.output', 'valueDataRequirement', TFhirDataRequirement(value.value), false, -1)
  else if (value.value is TFhirExpression) {6} then
    ComposeExpression(this, 'Task.output', 'valueExpression', TFhirExpression(value.value), false, -1)
  else if (value.value is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(this, 'Task.output', 'valueParameterDefinition', TFhirParameterDefinition(value.value), false, -1)
  else if (value.value is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(this, 'Task.output', 'valueRelatedArtifact', TFhirRelatedArtifact(value.value), false, -1)
  else if (value.value is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(this, 'Task.output', 'valueTriggerDefinition', TFhirTriggerDefinition(value.value), false, -1)
  else if (value.value is TFhirUsageContext) {6} then
    ComposeUsageContext(this, 'Task.output', 'valueUsageContext', TFhirUsageContext(value.value), false, -1)
  else if (value.value is TFhirAvailability) {6} then
    ComposeAvailability(this, 'Task.output', 'valueAvailability', TFhirAvailability(value.value), false, -1)
  else if (value.value is TFhirExtendedContactDetail) {6} then
    ComposeExtendedContactDetail(this, 'Task.output', 'valueExtendedContactDetail', TFhirExtendedContactDetail(value.value), false, -1)
  else if (value.value is TFhirDosage) {6} then
    ComposeDosage(this, 'Task.output', 'valueDosage', TFhirDosage(value.value), false, -1)
  else if (value.value is TFhirMeta) {6} then
    ComposeMeta(this, 'Task.output', 'valueMeta', TFhirMeta(value.value), false, -1)
  else if (value.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'Task.output', 'valueBase64Binary', TFhirBase64Binary(value.value), false, -1)
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Task.output', 'valueBoolean', TFhirBoolean(value.value), false, -1)
  else if (value.value is TFhirDate) {6} then
    ComposeDate(this, 'Task.output', 'valueDate', TFhirDate(value.value), false, -1)
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Task.output', 'valueDateTime', TFhirDateTime(value.value), false, -1)
  else if (value.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'Task.output', 'valueDecimal', TFhirDecimal(value.value), false, -1)
  else if (value.value is TFhirInstant) {6} then
    ComposeInstant(this, 'Task.output', 'valueInstant', TFhirInstant(value.value), false, -1)
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Task.output', 'valueInteger', TFhirInteger(value.value), false, -1)
  else if (value.value is TFhirInteger64) {6} then
    ComposeInteger64(this, 'Task.output', 'valueInteger64', TFhirInteger64(value.value), false, -1)
  else if (value.value is TFhirString) {6} then
    ComposeString(this, 'Task.output', 'valueString', TFhirString(value.value), false, -1)
  else if (value.value is TFhirTime) {6} then
    ComposeTime(this, 'Task.output', 'valueTime', TFhirTime(value.value), false, -1)
  else if (value.value is TFhirUri) {6} then
    ComposeUri(this, 'Task.output', 'valueUri', TFhirUri(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseTask(obj : TTurtleComplex) : TFhirTask;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTask.create;
  try
    ParseTaskProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTaskProperties(obj : TTurtleComplex; value : TFhirTask);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Task.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.instantiatesCanonicalElement := ParseCanonical(obj.complex('http://hl7.org/fhir/Task.instantiatesCanonical'));
    value.instantiatesUriElement := ParseUri(obj.complex('http://hl7.org/fhir/Task.instantiatesUri'));
    for item in obj.complexes('http://hl7.org/fhir/Task.basedOn') do
      value.basedOnList.Add(parseReference(item));
    value.groupIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Task.groupIdentifier'));
    for item in obj.complexes('http://hl7.org/fhir/Task.partOf') do
      value.partOfList.Add(parseReference(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Task.status'), CODES_TFhirTaskStatusEnum, SYSTEMS_TFhirTaskStatusEnum);
    value.statusReason := ParseCodeableReference(obj.complex('http://hl7.org/fhir/Task.statusReason'));
    value.businessStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Task.businessStatus'));
    value.intentElement := ParseEnum(obj.complex('http://hl7.org/fhir/Task.intent'), CODES_TFhirTaskIntentEnum, SYSTEMS_TFhirTaskIntentEnum);
    value.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/Task.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    value.doNotPerformElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Task.doNotPerform'));
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Task.code'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Task.description'));
    value.focus := ParseReference(obj.complex('http://hl7.org/fhir/Task.focus'));
    value.for_ := ParseReference(obj.complex('http://hl7.org/fhir/Task.for'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/Task.encounter'));
    value.requestedPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Task.requestedPeriod'));
    value.executionPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Task.executionPeriod'));
    value.authoredOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Task.authoredOn'));
    value.lastModifiedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Task.lastModified'));
    value.requester := ParseReference(obj.complex('http://hl7.org/fhir/Task.requester'));
    for item in obj.complexes('http://hl7.org/fhir/Task.requestedPerformer') do
      value.requestedPerformerList.Add(parseCodeableReference(item));
    value.owner := ParseReference(obj.complex('http://hl7.org/fhir/Task.owner'));
    value.location := ParseReference(obj.complex('http://hl7.org/fhir/Task.location'));
    for item in obj.complexes('http://hl7.org/fhir/Task.reason') do
      value.reasonList.Add(parseCodeableReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Task.insurance') do
      value.insuranceList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Task.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/Task.relevantHistory') do
      value.relevantHistoryList.Add(parseReference(item));
    value.restriction := ParseTaskRestriction(obj.complex('http://hl7.org/fhir/Task.restriction'));
    for item in obj.complexes('http://hl7.org/fhir/Task.input') do
      value.inputList.Add(parseTaskInput(item));
    for item in obj.complexes('http://hl7.org/fhir/Task.output') do
      value.outputList.Add(parseTaskOutput(item));
end;

procedure TFHIRTurtleComposer.ComposeTask(parent :  TTurtleComplex; parentType, name : String; value : TFhirTask; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Task');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Task', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(this, 'Task', 'instantiatesCanonical', value.instantiatesCanonicalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'Task', 'instantiatesUri', value.instantiatesUriElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'Task', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'Task', 'groupIdentifier', value.groupIdentifierElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(this, 'Task', 'partOf', value.partOfList[i], false, i);
  ComposeEnum(this, 'Task', 'status', value.statusElement, CODES_TFhirTaskStatusEnum, SYSTEMS_TFhirTaskStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableReference(this, 'Task', 'statusReason', value.statusReasonElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Task', 'businessStatus', value.businessStatusElement, false, -1);
  ComposeEnum(this, 'Task', 'intent', value.intentElement, CODES_TFhirTaskIntentEnum, SYSTEMS_TFhirTaskIntentEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Task', 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'Task', 'doNotPerform', value.doNotPerformElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Task', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Task', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Task', 'focus', value.focusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Task', 'for', value.for_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Task', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Task', 'requestedPeriod', value.requestedPeriodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Task', 'executionPeriod', value.executionPeriodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Task', 'authoredOn', value.authoredOnElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Task', 'lastModified', value.lastModifiedElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Task', 'requester', value.requesterElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.requestedPerformerList.Count - 1 do
      ComposeCodeableReference(this, 'Task', 'requestedPerformer', value.requestedPerformerList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Task', 'owner', value.ownerElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Task', 'location', value.locationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reasonList.Count - 1 do
      ComposeCodeableReference(this, 'Task', 'reason', value.reasonList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.insuranceList.Count - 1 do
      ComposeReference(this, 'Task', 'insurance', value.insuranceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'Task', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relevantHistoryList.Count - 1 do
      ComposeReference(this, 'Task', 'relevantHistory', value.relevantHistoryList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeTaskRestriction(this, 'Task', 'restriction', value.restrictionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.inputList.Count - 1 do
      ComposeTaskInput(this, 'Task', 'input', value.inputList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.outputList.Count - 1 do
      ComposeTaskOutput(this, 'Task', 'output', value.outputList[i], false, i);
end;

{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
function TFHIRTurtleParser.ParseTerminologyCapabilitiesSoftware(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesSoftware;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTerminologyCapabilitiesSoftware.create;
  try
    ParseTerminologyCapabilitiesSoftwareProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTerminologyCapabilitiesSoftwareProperties(obj : TTurtleComplex; value : TFhirTerminologyCapabilitiesSoftware);
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.software.name'));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.software.version'));
end;

procedure TFHIRTurtleComposer.ComposeTerminologyCapabilitiesSoftware(parent :  TTurtleComplex; parentType, name : String; value : TFhirTerminologyCapabilitiesSoftware; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TerminologyCapabilitiesSoftware');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'TerminologyCapabilities.software', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'TerminologyCapabilities.software', 'version', value.versionElement, false, -1);
end;

function TFHIRTurtleParser.ParseTerminologyCapabilitiesImplementation(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesImplementation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTerminologyCapabilitiesImplementation.create;
  try
    ParseTerminologyCapabilitiesImplementationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTerminologyCapabilitiesImplementationProperties(obj : TTurtleComplex; value : TFhirTerminologyCapabilitiesImplementation);
begin
    ParseBackboneElementProperties(obj, value);
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.implementation.description'));
    value.urlElement := ParseUrl(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.implementation.url'));
end;

procedure TFHIRTurtleComposer.ComposeTerminologyCapabilitiesImplementation(parent :  TTurtleComplex; parentType, name : String; value : TFhirTerminologyCapabilitiesImplementation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TerminologyCapabilitiesImplementation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'TerminologyCapabilities.implementation', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrl(this, 'TerminologyCapabilities.implementation', 'url', value.urlElement, false, -1);
end;

function TFHIRTurtleParser.ParseTerminologyCapabilitiesCodeSystem(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesCodeSystem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTerminologyCapabilitiesCodeSystem.create;
  try
    ParseTerminologyCapabilitiesCodeSystemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTerminologyCapabilitiesCodeSystemProperties(obj : TTurtleComplex; value : TFhirTerminologyCapabilitiesCodeSystem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.uriElement := ParseCanonical(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.codeSystem.uri'));
    for item in obj.complexes('http://hl7.org/fhir/TerminologyCapabilities.codeSystem.version') do
      value.versionList.Add(parseTerminologyCapabilitiesCodeSystemVersion(item));
    value.contentElement := ParseCode(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.codeSystem.content'));
    value.subsumptionElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.codeSystem.subsumption'));
end;

procedure TFHIRTurtleComposer.ComposeTerminologyCapabilitiesCodeSystem(parent :  TTurtleComplex; parentType, name : String; value : TFhirTerminologyCapabilitiesCodeSystem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TerminologyCapabilitiesCodeSystem');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'TerminologyCapabilities.codeSystem', 'uri', value.uriElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.versionList.Count - 1 do
      ComposeTerminologyCapabilitiesCodeSystemVersion(this, 'TerminologyCapabilities.codeSystem', 'version', value.versionList[i], false, i);
  ComposeCode(this, 'TerminologyCapabilities.codeSystem', 'content', value.contentElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TerminologyCapabilities.codeSystem', 'subsumption', value.subsumptionElement, false, -1);
end;

function TFHIRTurtleParser.ParseTerminologyCapabilitiesCodeSystemVersion(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesCodeSystemVersion;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTerminologyCapabilitiesCodeSystemVersion.create;
  try
    ParseTerminologyCapabilitiesCodeSystemVersionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTerminologyCapabilitiesCodeSystemVersionProperties(obj : TTurtleComplex; value : TFhirTerminologyCapabilitiesCodeSystemVersion);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.codeElement := ParseString(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.codeSystem.version.code'));
    value.isDefaultElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.codeSystem.version.isDefault'));
    value.compositionalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.codeSystem.version.compositional'));
    for item in obj.complexes('http://hl7.org/fhir/TerminologyCapabilities.codeSystem.version.language') do
      value.language.Add(parseEnum(item, CODES_TFhirCommonLanguagesEnum, SYSTEMS_TFhirCommonLanguagesEnum));
    for item in obj.complexes('http://hl7.org/fhir/TerminologyCapabilities.codeSystem.version.filter') do
      value.filterList.Add(parseTerminologyCapabilitiesCodeSystemVersionFilter(item));
    for item in obj.complexes('http://hl7.org/fhir/TerminologyCapabilities.codeSystem.version.property') do
      value.property_List.Add(parseCode(item));
end;

procedure TFHIRTurtleComposer.ComposeTerminologyCapabilitiesCodeSystemVersion(parent :  TTurtleComplex; parentType, name : String; value : TFhirTerminologyCapabilitiesCodeSystemVersion; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TerminologyCapabilitiesCodeSystemVersion');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'TerminologyCapabilities.codeSystem.version', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'TerminologyCapabilities.codeSystem.version', 'isDefault', value.isDefaultElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TerminologyCapabilities.codeSystem.version', 'compositional', value.compositionalElement, false, -1);
  for i := 0 to value.language.Count - 1 do
      ComposeEnum(this, 'TerminologyCapabilities.codeSystem.version', 'language', value.language[i], CODES_TFhirCommonLanguagesEnum, SYSTEMS_TFhirCommonLanguagesEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.language.Count - 1 do
      ComposeEnum(this, 'TerminologyCapabilities.codeSystem.version', 'language', value.language[i], CODES_TFhirCommonLanguagesEnum, SYSTEMS_TFhirCommonLanguagesEnum, false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.filterList.Count - 1 do
      ComposeTerminologyCapabilitiesCodeSystemVersionFilter(this, 'TerminologyCapabilities.codeSystem.version', 'filter', value.filterList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeCode(this, 'TerminologyCapabilities.codeSystem.version', 'property', value.property_List[i], false, i);
end;

function TFHIRTurtleParser.ParseTerminologyCapabilitiesCodeSystemVersionFilter(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesCodeSystemVersionFilter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTerminologyCapabilitiesCodeSystemVersionFilter.create;
  try
    ParseTerminologyCapabilitiesCodeSystemVersionFilterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTerminologyCapabilitiesCodeSystemVersionFilterProperties(obj : TTurtleComplex; value : TFhirTerminologyCapabilitiesCodeSystemVersionFilter);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.codeSystem.version.filter.code'));
    for item in obj.complexes('http://hl7.org/fhir/TerminologyCapabilities.codeSystem.version.filter.op') do
      value.opList.Add(parseCode(item));
end;

procedure TFHIRTurtleComposer.ComposeTerminologyCapabilitiesCodeSystemVersionFilter(parent :  TTurtleComplex; parentType, name : String; value : TFhirTerminologyCapabilitiesCodeSystemVersionFilter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TerminologyCapabilitiesCodeSystemVersionFilter');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCode(this, 'TerminologyCapabilities.codeSystem.version.filter', 'code', value.codeElement, false, -1);
  for i := 0 to value.opList.Count - 1 do
      ComposeCode(this, 'TerminologyCapabilities.codeSystem.version.filter', 'op', value.opList[i], false, i);
end;

function TFHIRTurtleParser.ParseTerminologyCapabilitiesExpansion(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesExpansion;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTerminologyCapabilitiesExpansion.create;
  try
    ParseTerminologyCapabilitiesExpansionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTerminologyCapabilitiesExpansionProperties(obj : TTurtleComplex; value : TFhirTerminologyCapabilitiesExpansion);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.hierarchicalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.expansion.hierarchical'));
    value.pagingElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.expansion.paging'));
    value.incompleteElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.expansion.incomplete'));
    for item in obj.complexes('http://hl7.org/fhir/TerminologyCapabilities.expansion.parameter') do
      value.parameterList.Add(parseTerminologyCapabilitiesExpansionParameter(item));
    value.textFilterElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.expansion.textFilter'));
end;

procedure TFHIRTurtleComposer.ComposeTerminologyCapabilitiesExpansion(parent :  TTurtleComplex; parentType, name : String; value : TFhirTerminologyCapabilitiesExpansion; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TerminologyCapabilitiesExpansion');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TerminologyCapabilities.expansion', 'hierarchical', value.hierarchicalElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TerminologyCapabilities.expansion', 'paging', value.pagingElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TerminologyCapabilities.expansion', 'incomplete', value.incompleteElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.parameterList.Count - 1 do
      ComposeTerminologyCapabilitiesExpansionParameter(this, 'TerminologyCapabilities.expansion', 'parameter', value.parameterList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'TerminologyCapabilities.expansion', 'textFilter', value.textFilterElement, false, -1);
end;

function TFHIRTurtleParser.ParseTerminologyCapabilitiesExpansionParameter(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesExpansionParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTerminologyCapabilitiesExpansionParameter.create;
  try
    ParseTerminologyCapabilitiesExpansionParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTerminologyCapabilitiesExpansionParameterProperties(obj : TTurtleComplex; value : TFhirTerminologyCapabilitiesExpansionParameter);
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseCode(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.expansion.parameter.name'));
    value.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.expansion.parameter.documentation'));
end;

procedure TFHIRTurtleComposer.ComposeTerminologyCapabilitiesExpansionParameter(parent :  TTurtleComplex; parentType, name : String; value : TFhirTerminologyCapabilitiesExpansionParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TerminologyCapabilitiesExpansionParameter');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCode(this, 'TerminologyCapabilities.expansion.parameter', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TerminologyCapabilities.expansion.parameter', 'documentation', value.documentationElement, false, -1);
end;

function TFHIRTurtleParser.ParseTerminologyCapabilitiesValidateCode(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesValidateCode;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTerminologyCapabilitiesValidateCode.create;
  try
    ParseTerminologyCapabilitiesValidateCodeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTerminologyCapabilitiesValidateCodeProperties(obj : TTurtleComplex; value : TFhirTerminologyCapabilitiesValidateCode);
begin
    ParseBackboneElementProperties(obj, value);
    value.translationsElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.validateCode.translations'));
end;

procedure TFHIRTurtleComposer.ComposeTerminologyCapabilitiesValidateCode(parent :  TTurtleComplex; parentType, name : String; value : TFhirTerminologyCapabilitiesValidateCode; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TerminologyCapabilitiesValidateCode');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeBoolean(this, 'TerminologyCapabilities.validateCode', 'translations', value.translationsElement, false, -1);
end;

function TFHIRTurtleParser.ParseTerminologyCapabilitiesTranslation(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesTranslation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTerminologyCapabilitiesTranslation.create;
  try
    ParseTerminologyCapabilitiesTranslationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTerminologyCapabilitiesTranslationProperties(obj : TTurtleComplex; value : TFhirTerminologyCapabilitiesTranslation);
begin
    ParseBackboneElementProperties(obj, value);
    value.needsMapElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.translation.needsMap'));
end;

procedure TFHIRTurtleComposer.ComposeTerminologyCapabilitiesTranslation(parent :  TTurtleComplex; parentType, name : String; value : TFhirTerminologyCapabilitiesTranslation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TerminologyCapabilitiesTranslation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeBoolean(this, 'TerminologyCapabilities.translation', 'needsMap', value.needsMapElement, false, -1);
end;

function TFHIRTurtleParser.ParseTerminologyCapabilitiesClosure(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesClosure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTerminologyCapabilitiesClosure.create;
  try
    ParseTerminologyCapabilitiesClosureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTerminologyCapabilitiesClosureProperties(obj : TTurtleComplex; value : TFhirTerminologyCapabilitiesClosure);
begin
    ParseBackboneElementProperties(obj, value);
    value.translationElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.closure.translation'));
end;

procedure TFHIRTurtleComposer.ComposeTerminologyCapabilitiesClosure(parent :  TTurtleComplex; parentType, name : String; value : TFhirTerminologyCapabilitiesClosure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TerminologyCapabilitiesClosure');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TerminologyCapabilities.closure', 'translation', value.translationElement, false, -1);
end;

function TFHIRTurtleParser.ParseTerminologyCapabilities(obj : TTurtleComplex) : TFhirTerminologyCapabilities;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTerminologyCapabilities.create;
  try
    ParseTerminologyCapabilitiesProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTerminologyCapabilitiesProperties(obj : TTurtleComplex; value : TFhirTerminologyCapabilities);
var
  item : TTurtleComplex;
begin
    ParseCanonicalResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.url'));
    for item in obj.complexes('http://hl7.org/fhir/TerminologyCapabilities.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.version'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.title'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.experimental'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/TerminologyCapabilities.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.description'));
    for item in obj.complexes('http://hl7.org/fhir/TerminologyCapabilities.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/TerminologyCapabilities.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.purpose'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.copyright'));
    value.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.kind'), CODES_TFhirCapabilityStatementKindEnum, SYSTEMS_TFhirCapabilityStatementKindEnum);
    value.software := ParseTerminologyCapabilitiesSoftware(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.software'));
    value.implementation_ := ParseTerminologyCapabilitiesImplementation(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.implementation'));
    value.lockedDateElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.lockedDate'));
    for item in obj.complexes('http://hl7.org/fhir/TerminologyCapabilities.codeSystem') do
      value.codeSystemList.Add(parseTerminologyCapabilitiesCodeSystem(item));
    value.expansion := ParseTerminologyCapabilitiesExpansion(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.expansion'));
    value.codeSearchElement := ParseEnum(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.codeSearch'), CODES_TFhirCodeSearchSupportEnum, SYSTEMS_TFhirCodeSearchSupportEnum);
    value.validateCode := ParseTerminologyCapabilitiesValidateCode(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.validateCode'));
    value.translation := ParseTerminologyCapabilitiesTranslation(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.translation'));
    value.closure := ParseTerminologyCapabilitiesClosure(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.closure'));
end;

procedure TFHIRTurtleComposer.ComposeTerminologyCapabilities(parent :  TTurtleComplex; parentType, name : String; value : TFhirTerminologyCapabilities; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TerminologyCapabilities');
  end;
  composeCanonicalResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'TerminologyCapabilities', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'TerminologyCapabilities', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'TerminologyCapabilities', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'TerminologyCapabilities', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'TerminologyCapabilities', 'title', value.titleElement, false, -1);
  ComposeEnum(this, 'TerminologyCapabilities', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'TerminologyCapabilities', 'experimental', value.experimentalElement, false, -1);
  ComposeDateTime(this, 'TerminologyCapabilities', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'TerminologyCapabilities', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'TerminologyCapabilities', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'TerminologyCapabilities', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'TerminologyCapabilities', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'TerminologyCapabilities', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'TerminologyCapabilities', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMarkdown(this, 'TerminologyCapabilities', 'copyright', value.copyrightElement, false, -1);
  ComposeEnum(this, 'TerminologyCapabilities', 'kind', value.kindElement, CODES_TFhirCapabilityStatementKindEnum, SYSTEMS_TFhirCapabilityStatementKindEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTerminologyCapabilitiesSoftware(this, 'TerminologyCapabilities', 'software', value.softwareElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTerminologyCapabilitiesImplementation(this, 'TerminologyCapabilities', 'implementation', value.implementation_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'TerminologyCapabilities', 'lockedDate', value.lockedDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.codeSystemList.Count - 1 do
      ComposeTerminologyCapabilitiesCodeSystem(this, 'TerminologyCapabilities', 'codeSystem', value.codeSystemList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeTerminologyCapabilitiesExpansion(this, 'TerminologyCapabilities', 'expansion', value.expansionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'TerminologyCapabilities', 'codeSearch', value.codeSearchElement, CODES_TFhirCodeSearchSupportEnum, SYSTEMS_TFhirCodeSearchSupportEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeTerminologyCapabilitiesValidateCode(this, 'TerminologyCapabilities', 'validateCode', value.validateCodeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeTerminologyCapabilitiesTranslation(this, 'TerminologyCapabilities', 'translation', value.translationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeTerminologyCapabilitiesClosure(this, 'TerminologyCapabilities', 'closure', value.closureElement, false, -1);
end;

{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTREPORT}
function TFHIRTurtleParser.ParseTestReportParticipant(obj : TTurtleComplex) : TFhirTestReportParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportParticipant.create;
  try
    ParseTestReportParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportParticipantProperties(obj : TTurtleComplex; value : TFhirTestReportParticipant);
begin
    ParseBackboneElementProperties(obj, value);
    value.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/TestReport.participant.type'), CODES_TFhirTestReportParticipantTypeEnum, SYSTEMS_TFhirTestReportParticipantTypeEnum);
    value.uriElement := ParseUri(obj.complex('http://hl7.org/fhir/TestReport.participant.uri'));
    value.displayElement := ParseString(obj.complex('http://hl7.org/fhir/TestReport.participant.display'));
end;

procedure TFHIRTurtleComposer.ComposeTestReportParticipant(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestReportParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportParticipant');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'TestReport.participant', 'type', value.type_Element, CODES_TFhirTestReportParticipantTypeEnum, SYSTEMS_TFhirTestReportParticipantTypeEnum, false, -1);
  ComposeUri(this, 'TestReport.participant', 'uri', value.uriElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestReport.participant', 'display', value.displayElement, false, -1);
end;

function TFHIRTurtleParser.ParseTestReportSetup(obj : TTurtleComplex) : TFhirTestReportSetup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportSetup.create;
  try
    ParseTestReportSetupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportSetupProperties(obj : TTurtleComplex; value : TFhirTestReportSetup);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/TestReport.setup.action') do
      value.actionList.Add(parseTestReportSetupAction(item));
end;

procedure TFHIRTurtleComposer.ComposeTestReportSetup(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestReportSetup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportSetup');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  for i := 0 to value.actionList.Count - 1 do
      ComposeTestReportSetupAction(this, 'TestReport.setup', 'action', value.actionList[i], false, i);
end;

function TFHIRTurtleParser.ParseTestReportSetupAction(obj : TTurtleComplex) : TFhirTestReportSetupAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportSetupAction.create;
  try
    ParseTestReportSetupActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportSetupActionProperties(obj : TTurtleComplex; value : TFhirTestReportSetupAction);
begin
    ParseBackboneElementProperties(obj, value);
    value.operation := ParseTestReportSetupActionOperation(obj.complex('http://hl7.org/fhir/TestReport.setup.action.operation'));
    value.assert := ParseTestReportSetupActionAssert(obj.complex('http://hl7.org/fhir/TestReport.setup.action.assert'));
end;

procedure TFHIRTurtleComposer.ComposeTestReportSetupAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestReportSetupAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportSetupAction');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetupActionOperation(this, 'TestReport.setup.action', 'operation', value.operationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetupActionAssert(this, 'TestReport.setup.action', 'assert', value.assertElement, false, -1);
end;

function TFHIRTurtleParser.ParseTestReportSetupActionOperation(obj : TTurtleComplex) : TFhirTestReportSetupActionOperation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportSetupActionOperation.create;
  try
    ParseTestReportSetupActionOperationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportSetupActionOperationProperties(obj : TTurtleComplex; value : TFhirTestReportSetupActionOperation);
begin
    ParseBackboneElementProperties(obj, value);
    value.resultElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestReport.setup.action.operation.result'), CODES_TFhirTestReportActionResultEnum, SYSTEMS_TFhirTestReportActionResultEnum);
    value.messageElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/TestReport.setup.action.operation.message'));
    value.detailElement := ParseUri(obj.complex('http://hl7.org/fhir/TestReport.setup.action.operation.detail'));
end;

procedure TFHIRTurtleComposer.ComposeTestReportSetupActionOperation(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestReportSetupActionOperation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportSetupActionOperation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'TestReport.setup.action.operation', 'result', value.resultElement, CODES_TFhirTestReportActionResultEnum, SYSTEMS_TFhirTestReportActionResultEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'TestReport.setup.action.operation', 'message', value.messageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'TestReport.setup.action.operation', 'detail', value.detailElement, false, -1);
end;

function TFHIRTurtleParser.ParseTestReportSetupActionAssert(obj : TTurtleComplex) : TFhirTestReportSetupActionAssert;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportSetupActionAssert.create;
  try
    ParseTestReportSetupActionAssertProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportSetupActionAssertProperties(obj : TTurtleComplex; value : TFhirTestReportSetupActionAssert);
begin
    ParseBackboneElementProperties(obj, value);
    value.resultElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestReport.setup.action.assert.result'), CODES_TFhirTestReportActionResultEnum, SYSTEMS_TFhirTestReportActionResultEnum);
    value.messageElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/TestReport.setup.action.assert.message'));
    value.detailElement := ParseString(obj.complex('http://hl7.org/fhir/TestReport.setup.action.assert.detail'));
end;

procedure TFHIRTurtleComposer.ComposeTestReportSetupActionAssert(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestReportSetupActionAssert; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportSetupActionAssert');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeEnum(this, 'TestReport.setup.action.assert', 'result', value.resultElement, CODES_TFhirTestReportActionResultEnum, SYSTEMS_TFhirTestReportActionResultEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'TestReport.setup.action.assert', 'message', value.messageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestReport.setup.action.assert', 'detail', value.detailElement, false, -1);
end;

function TFHIRTurtleParser.ParseTestReportTest(obj : TTurtleComplex) : TFhirTestReportTest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportTest.create;
  try
    ParseTestReportTestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportTestProperties(obj : TTurtleComplex; value : TFhirTestReportTest);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TestReport.test.name'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestReport.test.description'));
    for item in obj.complexes('http://hl7.org/fhir/TestReport.test.action') do
      value.actionList.Add(parseTestReportTestAction(item));
end;

procedure TFHIRTurtleComposer.ComposeTestReportTest(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestReportTest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportTest');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestReport.test', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestReport.test', 'description', value.descriptionElement, false, -1);
  for i := 0 to value.actionList.Count - 1 do
      ComposeTestReportTestAction(this, 'TestReport.test', 'action', value.actionList[i], false, i);
end;

function TFHIRTurtleParser.ParseTestReportTestAction(obj : TTurtleComplex) : TFhirTestReportTestAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportTestAction.create;
  try
    ParseTestReportTestActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportTestActionProperties(obj : TTurtleComplex; value : TFhirTestReportTestAction);
begin
    ParseBackboneElementProperties(obj, value);
    value.operation := ParseTestReportSetupActionOperation(obj.complex('http://hl7.org/fhir/TestReport.test.action.operation'));
    value.assert := ParseTestReportSetupActionAssert(obj.complex('http://hl7.org/fhir/TestReport.test.action.assert'));
end;

procedure TFHIRTurtleComposer.ComposeTestReportTestAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestReportTestAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportTestAction');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetupActionOperation(this, 'TestReport.test.action', 'operation', value.operationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetupActionAssert(this, 'TestReport.test.action', 'assert', value.assertElement, false, -1);
end;

function TFHIRTurtleParser.ParseTestReportTeardown(obj : TTurtleComplex) : TFhirTestReportTeardown;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportTeardown.create;
  try
    ParseTestReportTeardownProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportTeardownProperties(obj : TTurtleComplex; value : TFhirTestReportTeardown);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/TestReport.teardown.action') do
      value.actionList.Add(parseTestReportTeardownAction(item));
end;

procedure TFHIRTurtleComposer.ComposeTestReportTeardown(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestReportTeardown; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportTeardown');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  for i := 0 to value.actionList.Count - 1 do
      ComposeTestReportTeardownAction(this, 'TestReport.teardown', 'action', value.actionList[i], false, i);
end;

function TFHIRTurtleParser.ParseTestReportTeardownAction(obj : TTurtleComplex) : TFhirTestReportTeardownAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportTeardownAction.create;
  try
    ParseTestReportTeardownActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportTeardownActionProperties(obj : TTurtleComplex; value : TFhirTestReportTeardownAction);
begin
    ParseBackboneElementProperties(obj, value);
    value.operation := ParseTestReportSetupActionOperation(obj.complex('http://hl7.org/fhir/TestReport.teardown.action.operation'));
end;

procedure TFHIRTurtleComposer.ComposeTestReportTeardownAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestReportTeardownAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportTeardownAction');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeTestReportSetupActionOperation(this, 'TestReport.teardown.action', 'operation', value.operationElement, false, -1);
end;

function TFHIRTurtleParser.ParseTestReport(obj : TTurtleComplex) : TFhirTestReport;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReport.create;
  try
    ParseTestReportProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportProperties(obj : TTurtleComplex; value : TFhirTestReport);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    value.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/TestReport.identifier'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TestReport.name'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestReport.status'), CODES_TFhirTestReportStatusEnum, SYSTEMS_TFhirTestReportStatusEnum);
    value.testScriptElement := ParseCanonical(obj.complex('http://hl7.org/fhir/TestReport.testScript'));
    value.resultElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestReport.result'), CODES_TFhirTestReportResultEnum, SYSTEMS_TFhirTestReportResultEnum);
    value.scoreElement := ParseDecimal(obj.complex('http://hl7.org/fhir/TestReport.score'));
    value.testerElement := ParseString(obj.complex('http://hl7.org/fhir/TestReport.tester'));
    value.issuedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/TestReport.issued'));
    for item in obj.complexes('http://hl7.org/fhir/TestReport.participant') do
      value.participantList.Add(parseTestReportParticipant(item));
    value.setup := ParseTestReportSetup(obj.complex('http://hl7.org/fhir/TestReport.setup'));
    for item in obj.complexes('http://hl7.org/fhir/TestReport.test') do
      value.testList.Add(parseTestReportTest(item));
    value.teardown := ParseTestReportTeardown(obj.complex('http://hl7.org/fhir/TestReport.teardown'));
end;

procedure TFHIRTurtleComposer.ComposeTestReport(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestReport; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReport');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'TestReport', 'identifier', value.identifierElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'TestReport', 'name', value.nameElement, false, -1);
  ComposeEnum(this, 'TestReport', 'status', value.statusElement, CODES_TFhirTestReportStatusEnum, SYSTEMS_TFhirTestReportStatusEnum, false, -1);
  ComposeCanonical(this, 'TestReport', 'testScript', value.testScriptElement, false, -1);
  ComposeEnum(this, 'TestReport', 'result', value.resultElement, CODES_TFhirTestReportResultEnum, SYSTEMS_TFhirTestReportResultEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'TestReport', 'score', value.scoreElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'TestReport', 'tester', value.testerElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'TestReport', 'issued', value.issuedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.participantList.Count - 1 do
      ComposeTestReportParticipant(this, 'TestReport', 'participant', value.participantList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetup(this, 'TestReport', 'setup', value.setupElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.testList.Count - 1 do
      ComposeTestReportTest(this, 'TestReport', 'test', value.testList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportTeardown(this, 'TestReport', 'teardown', value.teardownElement, false, -1);
end;

{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
function TFHIRTurtleParser.ParseTestScriptOrigin(obj : TTurtleComplex) : TFhirTestScriptOrigin;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptOrigin.create;
  try
    ParseTestScriptOriginProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptOriginProperties(obj : TTurtleComplex; value : TFhirTestScriptOrigin);
begin
    ParseBackboneElementProperties(obj, value);
    value.indexElement := ParseInteger(obj.complex('http://hl7.org/fhir/TestScript.origin.index'));
    value.profile := ParseCoding(obj.complex('http://hl7.org/fhir/TestScript.origin.profile'));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptOrigin(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptOrigin; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptOrigin');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeInteger(this, 'TestScript.origin', 'index', value.indexElement, false, -1);
  ComposeCoding(this, 'TestScript.origin', 'profile', value.profileElement, false, -1);
end;

function TFHIRTurtleParser.ParseTestScriptDestination(obj : TTurtleComplex) : TFhirTestScriptDestination;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptDestination.create;
  try
    ParseTestScriptDestinationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptDestinationProperties(obj : TTurtleComplex; value : TFhirTestScriptDestination);
begin
    ParseBackboneElementProperties(obj, value);
    value.indexElement := ParseInteger(obj.complex('http://hl7.org/fhir/TestScript.destination.index'));
    value.profile := ParseCoding(obj.complex('http://hl7.org/fhir/TestScript.destination.profile'));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptDestination(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptDestination; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptDestination');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeInteger(this, 'TestScript.destination', 'index', value.indexElement, false, -1);
  ComposeCoding(this, 'TestScript.destination', 'profile', value.profileElement, false, -1);
end;

function TFHIRTurtleParser.ParseTestScriptMetadata(obj : TTurtleComplex) : TFhirTestScriptMetadata;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptMetadata.create;
  try
    ParseTestScriptMetadataProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptMetadataProperties(obj : TTurtleComplex; value : TFhirTestScriptMetadata);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/TestScript.metadata.link') do
      value.link_List.Add(parseTestScriptMetadataLink(item));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.metadata.capability') do
      value.capabilityList.Add(parseTestScriptMetadataCapability(item));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptMetadata(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptMetadata; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptMetadata');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.link_List.Count - 1 do
      ComposeTestScriptMetadataLink(this, 'TestScript.metadata', 'link', value.link_List[i], false, i);
  for i := 0 to value.capabilityList.Count - 1 do
      ComposeTestScriptMetadataCapability(this, 'TestScript.metadata', 'capability', value.capabilityList[i], false, i);
end;

function TFHIRTurtleParser.ParseTestScriptMetadataLink(obj : TTurtleComplex) : TFhirTestScriptMetadataLink;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptMetadataLink.create;
  try
    ParseTestScriptMetadataLinkProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptMetadataLinkProperties(obj : TTurtleComplex; value : TFhirTestScriptMetadataLink);
begin
    ParseBackboneElementProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/TestScript.metadata.link.url'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.metadata.link.description'));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptMetadataLink(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptMetadataLink; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptMetadataLink');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeUri(this, 'TestScript.metadata.link', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.metadata.link', 'description', value.descriptionElement, false, -1);
end;

function TFHIRTurtleParser.ParseTestScriptMetadataCapability(obj : TTurtleComplex) : TFhirTestScriptMetadataCapability;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptMetadataCapability.create;
  try
    ParseTestScriptMetadataCapabilityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptMetadataCapabilityProperties(obj : TTurtleComplex; value : TFhirTestScriptMetadataCapability);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.requiredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.metadata.capability.required'));
    value.validatedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.metadata.capability.validated'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.metadata.capability.description'));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.metadata.capability.origin') do
      value.originList.Add(parseInteger(item));
    value.destinationElement := ParseInteger(obj.complex('http://hl7.org/fhir/TestScript.metadata.capability.destination'));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.metadata.capability.link') do
      value.link_List.Add(parseUri(item));
    value.capabilitiesElement := ParseCanonical(obj.complex('http://hl7.org/fhir/TestScript.metadata.capability.capabilities'));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptMetadataCapability(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptMetadataCapability; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptMetadataCapability');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeBoolean(this, 'TestScript.metadata.capability', 'required', value.requiredElement, false, -1);
  ComposeBoolean(this, 'TestScript.metadata.capability', 'validated', value.validatedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.metadata.capability', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.originList.Count - 1 do
      ComposeInteger(this, 'TestScript.metadata.capability', 'origin', value.originList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'TestScript.metadata.capability', 'destination', value.destinationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.link_List.Count - 1 do
      ComposeUri(this, 'TestScript.metadata.capability', 'link', value.link_List[i], false, i);
  ComposeCanonical(this, 'TestScript.metadata.capability', 'capabilities', value.capabilitiesElement, false, -1);
end;

function TFHIRTurtleParser.ParseTestScriptScope(obj : TTurtleComplex) : TFhirTestScriptScope;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptScope.create;
  try
    ParseTestScriptScopeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptScopeProperties(obj : TTurtleComplex; value : TFhirTestScriptScope);
begin
    ParseBackboneElementProperties(obj, value);
    value.artifactElement := ParseCanonical(obj.complex('http://hl7.org/fhir/TestScript.scope.artifact'));
    value.conformance := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/TestScript.scope.conformance'));
    value.phase := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/TestScript.scope.phase'));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptScope(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptScope; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptScope');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCanonical(this, 'TestScript.scope', 'artifact', value.artifactElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'TestScript.scope', 'conformance', value.conformanceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'TestScript.scope', 'phase', value.phaseElement, false, -1);
end;

function TFHIRTurtleParser.ParseTestScriptFixture(obj : TTurtleComplex) : TFhirTestScriptFixture;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptFixture.create;
  try
    ParseTestScriptFixtureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptFixtureProperties(obj : TTurtleComplex; value : TFhirTestScriptFixture);
begin
    ParseBackboneElementProperties(obj, value);
    value.autocreateElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.fixture.autocreate'));
    value.autodeleteElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.fixture.autodelete'));
    value.resource := ParseReference(obj.complex('http://hl7.org/fhir/TestScript.fixture.resource'));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptFixture(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptFixture; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptFixture');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeBoolean(this, 'TestScript.fixture', 'autocreate', value.autocreateElement, false, -1);
  ComposeBoolean(this, 'TestScript.fixture', 'autodelete', value.autodeleteElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'TestScript.fixture', 'resource', value.resourceElement, false, -1);
end;

function TFHIRTurtleParser.ParseTestScriptVariable(obj : TTurtleComplex) : TFhirTestScriptVariable;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptVariable.create;
  try
    ParseTestScriptVariableProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptVariableProperties(obj : TTurtleComplex; value : TFhirTestScriptVariable);
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.variable.name'));
    value.defaultValueElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.variable.defaultValue'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.variable.description'));
    value.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.variable.expression'));
    value.headerFieldElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.variable.headerField'));
    value.hintElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.variable.hint'));
    value.pathElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.variable.path'));
    value.sourceIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.variable.sourceId'));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptVariable(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptVariable; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptVariable');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'TestScript.variable', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.variable', 'defaultValue', value.defaultValueElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.variable', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.variable', 'expression', value.expressionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.variable', 'headerField', value.headerFieldElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.variable', 'hint', value.hintElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.variable', 'path', value.pathElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.variable', 'sourceId', value.sourceIdElement, false, -1);
end;

function TFHIRTurtleParser.ParseTestScriptSetup(obj : TTurtleComplex) : TFhirTestScriptSetup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptSetup.create;
  try
    ParseTestScriptSetupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptSetupProperties(obj : TTurtleComplex; value : TFhirTestScriptSetup);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/TestScript.setup.action') do
      value.actionList.Add(parseTestScriptSetupAction(item));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptSetup(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptSetup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptSetup');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  for i := 0 to value.actionList.Count - 1 do
      ComposeTestScriptSetupAction(this, 'TestScript.setup', 'action', value.actionList[i], false, i);
end;

function TFHIRTurtleParser.ParseTestScriptSetupAction(obj : TTurtleComplex) : TFhirTestScriptSetupAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptSetupAction.create;
  try
    ParseTestScriptSetupActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptSetupActionProperties(obj : TTurtleComplex; value : TFhirTestScriptSetupAction);
begin
    ParseBackboneElementProperties(obj, value);
    value.operation := ParseTestScriptSetupActionOperation(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation'));
    value.assert := ParseTestScriptSetupActionAssert(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert'));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptSetupAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptSetupAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptSetupAction');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(this, 'TestScript.setup.action', 'operation', value.operationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssert(this, 'TestScript.setup.action', 'assert', value.assertElement, false, -1);
end;

function TFHIRTurtleParser.ParseTestScriptSetupActionOperation(obj : TTurtleComplex) : TFhirTestScriptSetupActionOperation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptSetupActionOperation.create;
  try
    ParseTestScriptSetupActionOperationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptSetupActionOperationProperties(obj : TTurtleComplex; value : TFhirTestScriptSetupActionOperation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.type'));
    value.resourceElement := ParseUri(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.resource'));
    value.label_Element := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.label'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.description'));
    value.acceptElement := ParseCode(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.accept'));
    value.contentTypeElement := ParseCode(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.contentType'));
    value.destinationElement := ParseInteger(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.destination'));
    value.encodeRequestUrlElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.encodeRequestUrl'));
    value.methodElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.method'), CODES_TFhirTestScriptRequestMethodCodeEnum, SYSTEMS_TFhirTestScriptRequestMethodCodeEnum);
    value.originElement := ParseInteger(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.origin'));
    value.paramsElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.params'));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.setup.action.operation.requestHeader') do
      value.requestHeaderList.Add(parseTestScriptSetupActionOperationRequestHeader(item));
    value.requestIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.requestId'));
    value.responseIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.responseId'));
    value.sourceIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.sourceId'));
    value.targetIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.targetId'));
    value.urlElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.url'));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptSetupActionOperation(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptSetupActionOperation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptSetupActionOperation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'TestScript.setup.action.operation', 'type', value.type_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'TestScript.setup.action.operation', 'resource', value.resourceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.operation', 'label', value.label_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.operation', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'TestScript.setup.action.operation', 'accept', value.acceptElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'TestScript.setup.action.operation', 'contentType', value.contentTypeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'TestScript.setup.action.operation', 'destination', value.destinationElement, false, -1);
  ComposeBoolean(this, 'TestScript.setup.action.operation', 'encodeRequestUrl', value.encodeRequestUrlElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'TestScript.setup.action.operation', 'method', value.methodElement, CODES_TFhirTestScriptRequestMethodCodeEnum, SYSTEMS_TFhirTestScriptRequestMethodCodeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'TestScript.setup.action.operation', 'origin', value.originElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.operation', 'params', value.paramsElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.requestHeaderList.Count - 1 do
      ComposeTestScriptSetupActionOperationRequestHeader(this, 'TestScript.setup.action.operation', 'requestHeader', value.requestHeaderList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.setup.action.operation', 'requestId', value.requestIdElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.setup.action.operation', 'responseId', value.responseIdElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.setup.action.operation', 'sourceId', value.sourceIdElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.setup.action.operation', 'targetId', value.targetIdElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.operation', 'url', value.urlElement, false, -1);
end;

function TFHIRTurtleParser.ParseTestScriptSetupActionOperationRequestHeader(obj : TTurtleComplex) : TFhirTestScriptSetupActionOperationRequestHeader;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptSetupActionOperationRequestHeader.create;
  try
    ParseTestScriptSetupActionOperationRequestHeaderProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptSetupActionOperationRequestHeaderProperties(obj : TTurtleComplex; value : TFhirTestScriptSetupActionOperationRequestHeader);
begin
    ParseBackboneElementProperties(obj, value);
    value.fieldElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.requestHeader.field'));
    value.valueElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.requestHeader.value'));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptSetupActionOperationRequestHeader(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptSetupActionOperationRequestHeader; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptSetupActionOperationRequestHeader');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'TestScript.setup.action.operation.requestHeader', 'field', value.fieldElement, false, -1);
  ComposeString(this, 'TestScript.setup.action.operation.requestHeader', 'value', value.valueElement, false, -1);
end;

function TFHIRTurtleParser.ParseTestScriptSetupActionAssert(obj : TTurtleComplex) : TFhirTestScriptSetupActionAssert;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptSetupActionAssert.create;
  try
    ParseTestScriptSetupActionAssertProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptSetupActionAssertProperties(obj : TTurtleComplex; value : TFhirTestScriptSetupActionAssert);
begin
    ParseBackboneElementProperties(obj, value);
    value.label_Element := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.label'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.description'));
    value.directionElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.direction'), CODES_TFhirAssertionDirectionTypeEnum, SYSTEMS_TFhirAssertionDirectionTypeEnum);
    value.compareToSourceIdElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.compareToSourceId'));
    value.compareToSourceExpressionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.compareToSourceExpression'));
    value.compareToSourcePathElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.compareToSourcePath'));
    value.contentTypeElement := ParseCode(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.contentType'));
    value.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.expression'));
    value.headerFieldElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.headerField'));
    value.minimumIdElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.minimumId'));
    value.navigationLinksElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.navigationLinks'));
    value.operatorElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.operator'), CODES_TFhirAssertionOperatorTypeEnum, SYSTEMS_TFhirAssertionOperatorTypeEnum);
    value.pathElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.path'));
    value.requestMethodElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.requestMethod'), CODES_TFhirTestScriptRequestMethodCodeEnum, SYSTEMS_TFhirTestScriptRequestMethodCodeEnum);
    value.requestURLElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.requestURL'));
    value.resourceElement := ParseUri(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.resource'));
    value.responseElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.response'), CODES_TFhirAssertionResponseTypesEnum, SYSTEMS_TFhirAssertionResponseTypesEnum);
    value.responseCodeElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.responseCode'));
    value.sourceIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.sourceId'));
    value.stopTestOnFailElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.stopTestOnFail'));
    value.validateProfileIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.validateProfileId'));
    value.valueElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.value'));
    value.warningOnlyElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.warningOnly'));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptSetupActionAssert(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptSetupActionAssert; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptSetupActionAssert');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'label', value.label_Element, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'TestScript.setup.action.assert', 'direction', value.directionElement, CODES_TFhirAssertionDirectionTypeEnum, SYSTEMS_TFhirAssertionDirectionTypeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'compareToSourceId', value.compareToSourceIdElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'compareToSourceExpression', value.compareToSourceExpressionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'compareToSourcePath', value.compareToSourcePathElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'TestScript.setup.action.assert', 'contentType', value.contentTypeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'expression', value.expressionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'headerField', value.headerFieldElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'minimumId', value.minimumIdElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TestScript.setup.action.assert', 'navigationLinks', value.navigationLinksElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'TestScript.setup.action.assert', 'operator', value.operatorElement, CODES_TFhirAssertionOperatorTypeEnum, SYSTEMS_TFhirAssertionOperatorTypeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'path', value.pathElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'TestScript.setup.action.assert', 'requestMethod', value.requestMethodElement, CODES_TFhirTestScriptRequestMethodCodeEnum, SYSTEMS_TFhirTestScriptRequestMethodCodeEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'requestURL', value.requestURLElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'TestScript.setup.action.assert', 'resource', value.resourceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'TestScript.setup.action.assert', 'response', value.responseElement, CODES_TFhirAssertionResponseTypesEnum, SYSTEMS_TFhirAssertionResponseTypesEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'responseCode', value.responseCodeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.setup.action.assert', 'sourceId', value.sourceIdElement, false, -1);
  ComposeBoolean(this, 'TestScript.setup.action.assert', 'stopTestOnFail', value.stopTestOnFailElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.setup.action.assert', 'validateProfileId', value.validateProfileIdElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'value', value.valueElement, false, -1);
  ComposeBoolean(this, 'TestScript.setup.action.assert', 'warningOnly', value.warningOnlyElement, false, -1);
end;

function TFHIRTurtleParser.ParseTestScriptTest(obj : TTurtleComplex) : TFhirTestScriptTest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptTest.create;
  try
    ParseTestScriptTestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptTestProperties(obj : TTurtleComplex; value : TFhirTestScriptTest);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.test.name'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.test.description'));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.test.action') do
      value.actionList.Add(parseTestScriptTestAction(item));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptTest(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptTest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptTest');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.test', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.test', 'description', value.descriptionElement, false, -1);
  for i := 0 to value.actionList.Count - 1 do
      ComposeTestScriptTestAction(this, 'TestScript.test', 'action', value.actionList[i], false, i);
end;

function TFHIRTurtleParser.ParseTestScriptTestAction(obj : TTurtleComplex) : TFhirTestScriptTestAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptTestAction.create;
  try
    ParseTestScriptTestActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptTestActionProperties(obj : TTurtleComplex; value : TFhirTestScriptTestAction);
begin
    ParseBackboneElementProperties(obj, value);
    value.operation := ParseTestScriptSetupActionOperation(obj.complex('http://hl7.org/fhir/TestScript.test.action.operation'));
    value.assert := ParseTestScriptSetupActionAssert(obj.complex('http://hl7.org/fhir/TestScript.test.action.assert'));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptTestAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptTestAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptTestAction');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(this, 'TestScript.test.action', 'operation', value.operationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssert(this, 'TestScript.test.action', 'assert', value.assertElement, false, -1);
end;

function TFHIRTurtleParser.ParseTestScriptTeardown(obj : TTurtleComplex) : TFhirTestScriptTeardown;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptTeardown.create;
  try
    ParseTestScriptTeardownProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptTeardownProperties(obj : TTurtleComplex; value : TFhirTestScriptTeardown);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/TestScript.teardown.action') do
      value.actionList.Add(parseTestScriptTeardownAction(item));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptTeardown(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptTeardown; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptTeardown');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  for i := 0 to value.actionList.Count - 1 do
      ComposeTestScriptTeardownAction(this, 'TestScript.teardown', 'action', value.actionList[i], false, i);
end;

function TFHIRTurtleParser.ParseTestScriptTeardownAction(obj : TTurtleComplex) : TFhirTestScriptTeardownAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptTeardownAction.create;
  try
    ParseTestScriptTeardownActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptTeardownActionProperties(obj : TTurtleComplex; value : TFhirTestScriptTeardownAction);
begin
    ParseBackboneElementProperties(obj, value);
    value.operation := ParseTestScriptSetupActionOperation(obj.complex('http://hl7.org/fhir/TestScript.teardown.action.operation'));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptTeardownAction(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScriptTeardownAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptTeardownAction');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeTestScriptSetupActionOperation(this, 'TestScript.teardown.action', 'operation', value.operationElement, false, -1);
end;

function TFHIRTurtleParser.ParseTestScript(obj : TTurtleComplex) : TFhirTestScript;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScript.create;
  try
    ParseTestScriptProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptProperties(obj : TTurtleComplex; value : TFhirTestScript);
var
  item : TTurtleComplex;
begin
    ParseCanonicalResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/TestScript.url'));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.version'));
    if obj.has('versionAlgorithmCoding', item) then
      value.versionAlgorithm := parseCoding(item);
    if obj.has('versionAlgorithmString', item) then
      value.versionAlgorithm := parseString(item);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.title'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.experimental'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/TestScript.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/TestScript.description'));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/TestScript.purpose'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/TestScript.copyright'));
    value.copyrightLabelElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.copyrightLabel'));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.origin') do
      value.originList.Add(parseTestScriptOrigin(item));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.destination') do
      value.destinationList.Add(parseTestScriptDestination(item));
    value.metadata := ParseTestScriptMetadata(obj.complex('http://hl7.org/fhir/TestScript.metadata'));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.scope') do
      value.scopeList.Add(parseTestScriptScope(item));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.fixture') do
      value.fixtureList.Add(parseTestScriptFixture(item));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.profile') do
      value.profileList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.variable') do
      value.variableList.Add(parseTestScriptVariable(item));
    value.setup := ParseTestScriptSetup(obj.complex('http://hl7.org/fhir/TestScript.setup'));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.test') do
      value.testList.Add(parseTestScriptTest(item));
    value.teardown := ParseTestScriptTeardown(obj.complex('http://hl7.org/fhir/TestScript.teardown'));
end;

procedure TFHIRTurtleComposer.ComposeTestScript(parent :  TTurtleComplex; parentType, name : String; value : TFhirTestScript; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScript');
  end;
  composeCanonicalResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'TestScript', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'TestScript', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'TestScript', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirCoding) {6} then
    ComposeCoding(this, 'TestScript', 'versionAlgorithmCoding', TFhirCoding(value.versionAlgorithm), false, -1)
  else if (SummaryOption in [soFull, soSummary, soData]) and (value.versionAlgorithm is TFhirString) {6} then
    ComposeString(this, 'TestScript', 'versionAlgorithmString', TFhirString(value.versionAlgorithm), false, -1);
  ComposeString(this, 'TestScript', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'TestScript', 'title', value.titleElement, false, -1);
  ComposeEnum(this, 'TestScript', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'TestScript', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'TestScript', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'TestScript', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'TestScript', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'TestScript', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'TestScript', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'TestScript', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'TestScript', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'TestScript', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript', 'copyrightLabel', value.copyrightLabelElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.originList.Count - 1 do
      ComposeTestScriptOrigin(this, 'TestScript', 'origin', value.originList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.destinationList.Count - 1 do
      ComposeTestScriptDestination(this, 'TestScript', 'destination', value.destinationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptMetadata(this, 'TestScript', 'metadata', value.metadataElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.scopeList.Count - 1 do
      ComposeTestScriptScope(this, 'TestScript', 'scope', value.scopeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.fixtureList.Count - 1 do
      ComposeTestScriptFixture(this, 'TestScript', 'fixture', value.fixtureList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.profileList.Count - 1 do
      ComposeReference(this, 'TestScript', 'profile', value.profileList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.variableList.Count - 1 do
      ComposeTestScriptVariable(this, 'TestScript', 'variable', value.variableList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetup(this, 'TestScript', 'setup', value.setupElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.testList.Count - 1 do
      ComposeTestScriptTest(this, 'TestScript', 'test', value.testList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptTeardown(this, 'TestScript', 'teardown', value.teardownElement, false, -1);
end;

{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_TRANSPORT}
function TFHIRTurtleParser.ParseTransportRestriction(obj : TTurtleComplex) : TFhirTransportRestriction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTransportRestriction.create;
  try
    ParseTransportRestrictionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTransportRestrictionProperties(obj : TTurtleComplex; value : TFhirTransportRestriction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.repetitionsElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Transport.restriction.repetitions'));
    value.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Transport.restriction.period'));
    for item in obj.complexes('http://hl7.org/fhir/Transport.restriction.recipient') do
      value.recipientList.Add(parseReference(item));
end;

procedure TFHIRTurtleComposer.ComposeTransportRestriction(parent :  TTurtleComplex; parentType, name : String; value : TFhirTransportRestriction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TransportRestriction');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'Transport.restriction', 'repetitions', value.repetitionsElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Transport.restriction', 'period', value.periodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.recipientList.Count - 1 do
      ComposeReference(this, 'Transport.restriction', 'recipient', value.recipientList[i], false, i);
end;

function TFHIRTurtleParser.ParseTransportInput(obj : TTurtleComplex) : TFhirTransportInput;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTransportInput.create;
  try
    ParseTransportInputProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTransportInputProperties(obj : TTurtleComplex; value : TFhirTransportInput);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Transport.input.type'));
    if obj.has('valueCanonical', item) then
      value.value := parseCanonical(item);
    if obj.has('valueCode', item) then
      value.value := parseCode(item);
    if obj.has('valueId', item) then
      value.value := parseId(item);
    if obj.has('valueMarkdown', item) then
      value.value := parseMarkdown(item);
    if obj.has('valueOid', item) then
      value.value := parseOid(item);
    if obj.has('valuePositiveInt', item) then
      value.value := parsePositiveInt(item);
    if obj.has('valueUnsignedInt', item) then
      value.value := parseUnsignedInt(item);
    if obj.has('valueUrl', item) then
      value.value := parseUrl(item);
    if obj.has('valueUuid', item) then
      value.value := parseUuid(item);
    if obj.has('valueAddress', item) then
      value.value := parseAddress(item);
    if obj.has('valueAge', item) then
      value.value := parseAge(item);
    if obj.has('valueAnnotation', item) then
      value.value := parseAnnotation(item);
    if obj.has('valueAttachment', item) then
      value.value := parseAttachment(item);
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueCodeableReference', item) then
      value.value := parseCodeableReference(item);
    if obj.has('valueCoding', item) then
      value.value := parseCoding(item);
    if obj.has('valueContactPoint', item) then
      value.value := parseContactPoint(item);
    if obj.has('valueCount', item) then
      value.value := parseCount(item);
    if obj.has('valueDistance', item) then
      value.value := parseDistance(item);
    if obj.has('valueDuration', item) then
      value.value := parseDuration(item);
    if obj.has('valueHumanName', item) then
      value.value := parseHumanName(item);
    if obj.has('valueIdentifier', item) then
      value.value := parseIdentifier(item);
    if obj.has('valueMoney', item) then
      value.value := parseMoney(item);
    if obj.has('valuePeriod', item) then
      value.value := parsePeriod(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueRange', item) then
      value.value := parseRange(item);
    if obj.has('valueRatio', item) then
      value.value := parseRatio(item);
    if obj.has('valueRatioRange', item) then
      value.value := parseRatioRange(item);
    if obj.has('valueReference', item) then
      value.value := parseReference(item);
    if obj.has('valueSampledData', item) then
      value.value := parseSampledData(item);
    if obj.has('valueSignature', item) then
      value.value := parseSignature(item);
    if obj.has('valueTiming', item) then
      value.value := parseTiming(item);
    if obj.has('valueContactDetail', item) then
      value.value := parseContactDetail(item);
    if obj.has('valueDataRequirement', item) then
      value.value := parseDataRequirement(item);
    if obj.has('valueExpression', item) then
      value.value := parseExpression(item);
    if obj.has('valueParameterDefinition', item) then
      value.value := parseParameterDefinition(item);
    if obj.has('valueRelatedArtifact', item) then
      value.value := parseRelatedArtifact(item);
    if obj.has('valueTriggerDefinition', item) then
      value.value := parseTriggerDefinition(item);
    if obj.has('valueUsageContext', item) then
      value.value := parseUsageContext(item);
    if obj.has('valueAvailability', item) then
      value.value := parseAvailability(item);
    if obj.has('valueExtendedContactDetail', item) then
      value.value := parseExtendedContactDetail(item);
    if obj.has('valueDosage', item) then
      value.value := parseDosage(item);
    if obj.has('valueMeta', item) then
      value.value := parseMeta(item);
    if obj.has('valueBase64Binary', item) then
      value.value := parseBase64Binary(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    if obj.has('valueDate', item) then
      value.value := parseDate(item);
    if obj.has('valueDateTime', item) then
      value.value := parseDateTime(item);
    if obj.has('valueDecimal', item) then
      value.value := parseDecimal(item);
    if obj.has('valueInstant', item) then
      value.value := parseInstant(item);
    if obj.has('valueInteger', item) then
      value.value := parseInteger(item);
    if obj.has('valueInteger64', item) then
      value.value := parseInteger64(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    if obj.has('valueTime', item) then
      value.value := parseTime(item);
    if obj.has('valueUri', item) then
      value.value := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeTransportInput(parent :  TTurtleComplex; parentType, name : String; value : TFhirTransportInput; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TransportInput');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'Transport.input', 'type', value.type_Element, false, -1);
  if (value.value is TFhirCanonical) {6} then
    ComposeCanonical(this, 'Transport.input', 'valueCanonical', TFhirCanonical(value.value), false, -1)
  else if (value.value is TFhirCode) {6} then
    ComposeCode(this, 'Transport.input', 'valueCode', TFhirCode(value.value), false, -1)
  else if (value.value is TFhirId) {6} then
    ComposeId(this, 'Transport.input', 'valueId', TFhirId(value.value), false, -1)
  else if (value.value is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'Transport.input', 'valueMarkdown', TFhirMarkdown(value.value), false, -1)
  else if (value.value is TFhirOid) {6} then
    ComposeOid(this, 'Transport.input', 'valueOid', TFhirOid(value.value), false, -1)
  else if (value.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'Transport.input', 'valuePositiveInt', TFhirPositiveInt(value.value), false, -1)
  else if (value.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'Transport.input', 'valueUnsignedInt', TFhirUnsignedInt(value.value), false, -1)
  else if (value.value is TFhirUrl) {6} then
    ComposeUrl(this, 'Transport.input', 'valueUrl', TFhirUrl(value.value), false, -1)
  else if (value.value is TFhirUuid) {6} then
    ComposeUuid(this, 'Transport.input', 'valueUuid', TFhirUuid(value.value), false, -1)
  else if (value.value is TFhirAddress) {6} then
    ComposeAddress(this, 'Transport.input', 'valueAddress', TFhirAddress(value.value), false, -1)
  else if (value.value is TFhirAge) {6} then
    ComposeAge(this, 'Transport.input', 'valueAge', TFhirAge(value.value), false, -1)
  else if (value.value is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'Transport.input', 'valueAnnotation', TFhirAnnotation(value.value), false, -1)
  else if (value.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Transport.input', 'valueAttachment', TFhirAttachment(value.value), false, -1)
  else if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Transport.input', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (value.value is TFhirCodeableReference) {6} then
    ComposeCodeableReference(this, 'Transport.input', 'valueCodeableReference', TFhirCodeableReference(value.value), false, -1)
  else if (value.value is TFhirCoding) {6} then
    ComposeCoding(this, 'Transport.input', 'valueCoding', TFhirCoding(value.value), false, -1)
  else if (value.value is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'Transport.input', 'valueContactPoint', TFhirContactPoint(value.value), false, -1)
  else if (value.value is TFhirCount) {6} then
    ComposeCount(this, 'Transport.input', 'valueCount', TFhirCount(value.value), false, -1)
  else if (value.value is TFhirDistance) {6} then
    ComposeDistance(this, 'Transport.input', 'valueDistance', TFhirDistance(value.value), false, -1)
  else if (value.value is TFhirDuration) {6} then
    ComposeDuration(this, 'Transport.input', 'valueDuration', TFhirDuration(value.value), false, -1)
  else if (value.value is TFhirHumanName) {6} then
    ComposeHumanName(this, 'Transport.input', 'valueHumanName', TFhirHumanName(value.value), false, -1)
  else if (value.value is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'Transport.input', 'valueIdentifier', TFhirIdentifier(value.value), false, -1)
  else if (value.value is TFhirMoney) {6} then
    ComposeMoney(this, 'Transport.input', 'valueMoney', TFhirMoney(value.value), false, -1)
  else if (value.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'Transport.input', 'valuePeriod', TFhirPeriod(value.value), false, -1)
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Transport.input', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (value.value is TFhirRange) {6} then
    ComposeRange(this, 'Transport.input', 'valueRange', TFhirRange(value.value), false, -1)
  else if (value.value is TFhirRatio) {6} then
    ComposeRatio(this, 'Transport.input', 'valueRatio', TFhirRatio(value.value), false, -1)
  else if (value.value is TFhirRatioRange) {6} then
    ComposeRatioRange(this, 'Transport.input', 'valueRatioRange', TFhirRatioRange(value.value), false, -1)
  else if (value.value is TFhirReference) {6} then
    ComposeReference(this, 'Transport.input', 'valueReference', TFhirReference(value.value), false, -1)
  else if (value.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'Transport.input', 'valueSampledData', TFhirSampledData(value.value), false, -1)
  else if (value.value is TFhirSignature) {6} then
    ComposeSignature(this, 'Transport.input', 'valueSignature', TFhirSignature(value.value), false, -1)
  else if (value.value is TFhirTiming) {6} then
    ComposeTiming(this, 'Transport.input', 'valueTiming', TFhirTiming(value.value), false, -1)
  else if (value.value is TFhirContactDetail) {6} then
    ComposeContactDetail(this, 'Transport.input', 'valueContactDetail', TFhirContactDetail(value.value), false, -1)
  else if (value.value is TFhirDataRequirement) {6} then
    ComposeDataRequirement(this, 'Transport.input', 'valueDataRequirement', TFhirDataRequirement(value.value), false, -1)
  else if (value.value is TFhirExpression) {6} then
    ComposeExpression(this, 'Transport.input', 'valueExpression', TFhirExpression(value.value), false, -1)
  else if (value.value is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(this, 'Transport.input', 'valueParameterDefinition', TFhirParameterDefinition(value.value), false, -1)
  else if (value.value is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(this, 'Transport.input', 'valueRelatedArtifact', TFhirRelatedArtifact(value.value), false, -1)
  else if (value.value is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(this, 'Transport.input', 'valueTriggerDefinition', TFhirTriggerDefinition(value.value), false, -1)
  else if (value.value is TFhirUsageContext) {6} then
    ComposeUsageContext(this, 'Transport.input', 'valueUsageContext', TFhirUsageContext(value.value), false, -1)
  else if (value.value is TFhirAvailability) {6} then
    ComposeAvailability(this, 'Transport.input', 'valueAvailability', TFhirAvailability(value.value), false, -1)
  else if (value.value is TFhirExtendedContactDetail) {6} then
    ComposeExtendedContactDetail(this, 'Transport.input', 'valueExtendedContactDetail', TFhirExtendedContactDetail(value.value), false, -1)
  else if (value.value is TFhirDosage) {6} then
    ComposeDosage(this, 'Transport.input', 'valueDosage', TFhirDosage(value.value), false, -1)
  else if (value.value is TFhirMeta) {6} then
    ComposeMeta(this, 'Transport.input', 'valueMeta', TFhirMeta(value.value), false, -1)
  else if (value.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'Transport.input', 'valueBase64Binary', TFhirBase64Binary(value.value), false, -1)
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Transport.input', 'valueBoolean', TFhirBoolean(value.value), false, -1)
  else if (value.value is TFhirDate) {6} then
    ComposeDate(this, 'Transport.input', 'valueDate', TFhirDate(value.value), false, -1)
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Transport.input', 'valueDateTime', TFhirDateTime(value.value), false, -1)
  else if (value.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'Transport.input', 'valueDecimal', TFhirDecimal(value.value), false, -1)
  else if (value.value is TFhirInstant) {6} then
    ComposeInstant(this, 'Transport.input', 'valueInstant', TFhirInstant(value.value), false, -1)
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Transport.input', 'valueInteger', TFhirInteger(value.value), false, -1)
  else if (value.value is TFhirInteger64) {6} then
    ComposeInteger64(this, 'Transport.input', 'valueInteger64', TFhirInteger64(value.value), false, -1)
  else if (value.value is TFhirString) {6} then
    ComposeString(this, 'Transport.input', 'valueString', TFhirString(value.value), false, -1)
  else if (value.value is TFhirTime) {6} then
    ComposeTime(this, 'Transport.input', 'valueTime', TFhirTime(value.value), false, -1)
  else if (value.value is TFhirUri) {6} then
    ComposeUri(this, 'Transport.input', 'valueUri', TFhirUri(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseTransportOutput(obj : TTurtleComplex) : TFhirTransportOutput;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTransportOutput.create;
  try
    ParseTransportOutputProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTransportOutputProperties(obj : TTurtleComplex; value : TFhirTransportOutput);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Transport.output.type'));
    if obj.has('valueCanonical', item) then
      value.value := parseCanonical(item);
    if obj.has('valueCode', item) then
      value.value := parseCode(item);
    if obj.has('valueId', item) then
      value.value := parseId(item);
    if obj.has('valueMarkdown', item) then
      value.value := parseMarkdown(item);
    if obj.has('valueOid', item) then
      value.value := parseOid(item);
    if obj.has('valuePositiveInt', item) then
      value.value := parsePositiveInt(item);
    if obj.has('valueUnsignedInt', item) then
      value.value := parseUnsignedInt(item);
    if obj.has('valueUrl', item) then
      value.value := parseUrl(item);
    if obj.has('valueUuid', item) then
      value.value := parseUuid(item);
    if obj.has('valueAddress', item) then
      value.value := parseAddress(item);
    if obj.has('valueAge', item) then
      value.value := parseAge(item);
    if obj.has('valueAnnotation', item) then
      value.value := parseAnnotation(item);
    if obj.has('valueAttachment', item) then
      value.value := parseAttachment(item);
    if obj.has('valueCodeableConcept', item) then
      value.value := parseCodeableConcept(item);
    if obj.has('valueCodeableReference', item) then
      value.value := parseCodeableReference(item);
    if obj.has('valueCoding', item) then
      value.value := parseCoding(item);
    if obj.has('valueContactPoint', item) then
      value.value := parseContactPoint(item);
    if obj.has('valueCount', item) then
      value.value := parseCount(item);
    if obj.has('valueDistance', item) then
      value.value := parseDistance(item);
    if obj.has('valueDuration', item) then
      value.value := parseDuration(item);
    if obj.has('valueHumanName', item) then
      value.value := parseHumanName(item);
    if obj.has('valueIdentifier', item) then
      value.value := parseIdentifier(item);
    if obj.has('valueMoney', item) then
      value.value := parseMoney(item);
    if obj.has('valuePeriod', item) then
      value.value := parsePeriod(item);
    if obj.has('valueQuantity', item) then
      value.value := parseQuantity(item);
    if obj.has('valueRange', item) then
      value.value := parseRange(item);
    if obj.has('valueRatio', item) then
      value.value := parseRatio(item);
    if obj.has('valueRatioRange', item) then
      value.value := parseRatioRange(item);
    if obj.has('valueReference', item) then
      value.value := parseReference(item);
    if obj.has('valueSampledData', item) then
      value.value := parseSampledData(item);
    if obj.has('valueSignature', item) then
      value.value := parseSignature(item);
    if obj.has('valueTiming', item) then
      value.value := parseTiming(item);
    if obj.has('valueContactDetail', item) then
      value.value := parseContactDetail(item);
    if obj.has('valueDataRequirement', item) then
      value.value := parseDataRequirement(item);
    if obj.has('valueExpression', item) then
      value.value := parseExpression(item);
    if obj.has('valueParameterDefinition', item) then
      value.value := parseParameterDefinition(item);
    if obj.has('valueRelatedArtifact', item) then
      value.value := parseRelatedArtifact(item);
    if obj.has('valueTriggerDefinition', item) then
      value.value := parseTriggerDefinition(item);
    if obj.has('valueUsageContext', item) then
      value.value := parseUsageContext(item);
    if obj.has('valueAvailability', item) then
      value.value := parseAvailability(item);
    if obj.has('valueExtendedContactDetail', item) then
      value.value := parseExtendedContactDetail(item);
    if obj.has('valueDosage', item) then
      value.value := parseDosage(item);
    if obj.has('valueMeta', item) then
      value.value := parseMeta(item);
    if obj.has('valueBase64Binary', item) then
      value.value := parseBase64Binary(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    if obj.has('valueDate', item) then
      value.value := parseDate(item);
    if obj.has('valueDateTime', item) then
      value.value := parseDateTime(item);
    if obj.has('valueDecimal', item) then
      value.value := parseDecimal(item);
    if obj.has('valueInstant', item) then
      value.value := parseInstant(item);
    if obj.has('valueInteger', item) then
      value.value := parseInteger(item);
    if obj.has('valueInteger64', item) then
      value.value := parseInteger64(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    if obj.has('valueTime', item) then
      value.value := parseTime(item);
    if obj.has('valueUri', item) then
      value.value := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeTransportOutput(parent :  TTurtleComplex; parentType, name : String; value : TFhirTransportOutput; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TransportOutput');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'Transport.output', 'type', value.type_Element, false, -1);
  if (value.value is TFhirCanonical) {6} then
    ComposeCanonical(this, 'Transport.output', 'valueCanonical', TFhirCanonical(value.value), false, -1)
  else if (value.value is TFhirCode) {6} then
    ComposeCode(this, 'Transport.output', 'valueCode', TFhirCode(value.value), false, -1)
  else if (value.value is TFhirId) {6} then
    ComposeId(this, 'Transport.output', 'valueId', TFhirId(value.value), false, -1)
  else if (value.value is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'Transport.output', 'valueMarkdown', TFhirMarkdown(value.value), false, -1)
  else if (value.value is TFhirOid) {6} then
    ComposeOid(this, 'Transport.output', 'valueOid', TFhirOid(value.value), false, -1)
  else if (value.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'Transport.output', 'valuePositiveInt', TFhirPositiveInt(value.value), false, -1)
  else if (value.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'Transport.output', 'valueUnsignedInt', TFhirUnsignedInt(value.value), false, -1)
  else if (value.value is TFhirUrl) {6} then
    ComposeUrl(this, 'Transport.output', 'valueUrl', TFhirUrl(value.value), false, -1)
  else if (value.value is TFhirUuid) {6} then
    ComposeUuid(this, 'Transport.output', 'valueUuid', TFhirUuid(value.value), false, -1)
  else if (value.value is TFhirAddress) {6} then
    ComposeAddress(this, 'Transport.output', 'valueAddress', TFhirAddress(value.value), false, -1)
  else if (value.value is TFhirAge) {6} then
    ComposeAge(this, 'Transport.output', 'valueAge', TFhirAge(value.value), false, -1)
  else if (value.value is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'Transport.output', 'valueAnnotation', TFhirAnnotation(value.value), false, -1)
  else if (value.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Transport.output', 'valueAttachment', TFhirAttachment(value.value), false, -1)
  else if (value.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Transport.output', 'valueCodeableConcept', TFhirCodeableConcept(value.value), false, -1)
  else if (value.value is TFhirCodeableReference) {6} then
    ComposeCodeableReference(this, 'Transport.output', 'valueCodeableReference', TFhirCodeableReference(value.value), false, -1)
  else if (value.value is TFhirCoding) {6} then
    ComposeCoding(this, 'Transport.output', 'valueCoding', TFhirCoding(value.value), false, -1)
  else if (value.value is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'Transport.output', 'valueContactPoint', TFhirContactPoint(value.value), false, -1)
  else if (value.value is TFhirCount) {6} then
    ComposeCount(this, 'Transport.output', 'valueCount', TFhirCount(value.value), false, -1)
  else if (value.value is TFhirDistance) {6} then
    ComposeDistance(this, 'Transport.output', 'valueDistance', TFhirDistance(value.value), false, -1)
  else if (value.value is TFhirDuration) {6} then
    ComposeDuration(this, 'Transport.output', 'valueDuration', TFhirDuration(value.value), false, -1)
  else if (value.value is TFhirHumanName) {6} then
    ComposeHumanName(this, 'Transport.output', 'valueHumanName', TFhirHumanName(value.value), false, -1)
  else if (value.value is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'Transport.output', 'valueIdentifier', TFhirIdentifier(value.value), false, -1)
  else if (value.value is TFhirMoney) {6} then
    ComposeMoney(this, 'Transport.output', 'valueMoney', TFhirMoney(value.value), false, -1)
  else if (value.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'Transport.output', 'valuePeriod', TFhirPeriod(value.value), false, -1)
  else if (value.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Transport.output', 'valueQuantity', TFhirQuantity(value.value), false, -1)
  else if (value.value is TFhirRange) {6} then
    ComposeRange(this, 'Transport.output', 'valueRange', TFhirRange(value.value), false, -1)
  else if (value.value is TFhirRatio) {6} then
    ComposeRatio(this, 'Transport.output', 'valueRatio', TFhirRatio(value.value), false, -1)
  else if (value.value is TFhirRatioRange) {6} then
    ComposeRatioRange(this, 'Transport.output', 'valueRatioRange', TFhirRatioRange(value.value), false, -1)
  else if (value.value is TFhirReference) {6} then
    ComposeReference(this, 'Transport.output', 'valueReference', TFhirReference(value.value), false, -1)
  else if (value.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'Transport.output', 'valueSampledData', TFhirSampledData(value.value), false, -1)
  else if (value.value is TFhirSignature) {6} then
    ComposeSignature(this, 'Transport.output', 'valueSignature', TFhirSignature(value.value), false, -1)
  else if (value.value is TFhirTiming) {6} then
    ComposeTiming(this, 'Transport.output', 'valueTiming', TFhirTiming(value.value), false, -1)
  else if (value.value is TFhirContactDetail) {6} then
    ComposeContactDetail(this, 'Transport.output', 'valueContactDetail', TFhirContactDetail(value.value), false, -1)
  else if (value.value is TFhirDataRequirement) {6} then
    ComposeDataRequirement(this, 'Transport.output', 'valueDataRequirement', TFhirDataRequirement(value.value), false, -1)
  else if (value.value is TFhirExpression) {6} then
    ComposeExpression(this, 'Transport.output', 'valueExpression', TFhirExpression(value.value), false, -1)
  else if (value.value is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(this, 'Transport.output', 'valueParameterDefinition', TFhirParameterDefinition(value.value), false, -1)
  else if (value.value is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(this, 'Transport.output', 'valueRelatedArtifact', TFhirRelatedArtifact(value.value), false, -1)
  else if (value.value is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(this, 'Transport.output', 'valueTriggerDefinition', TFhirTriggerDefinition(value.value), false, -1)
  else if (value.value is TFhirUsageContext) {6} then
    ComposeUsageContext(this, 'Transport.output', 'valueUsageContext', TFhirUsageContext(value.value), false, -1)
  else if (value.value is TFhirAvailability) {6} then
    ComposeAvailability(this, 'Transport.output', 'valueAvailability', TFhirAvailability(value.value), false, -1)
  else if (value.value is TFhirExtendedContactDetail) {6} then
    ComposeExtendedContactDetail(this, 'Transport.output', 'valueExtendedContactDetail', TFhirExtendedContactDetail(value.value), false, -1)
  else if (value.value is TFhirDosage) {6} then
    ComposeDosage(this, 'Transport.output', 'valueDosage', TFhirDosage(value.value), false, -1)
  else if (value.value is TFhirMeta) {6} then
    ComposeMeta(this, 'Transport.output', 'valueMeta', TFhirMeta(value.value), false, -1)
  else if (value.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'Transport.output', 'valueBase64Binary', TFhirBase64Binary(value.value), false, -1)
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Transport.output', 'valueBoolean', TFhirBoolean(value.value), false, -1)
  else if (value.value is TFhirDate) {6} then
    ComposeDate(this, 'Transport.output', 'valueDate', TFhirDate(value.value), false, -1)
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Transport.output', 'valueDateTime', TFhirDateTime(value.value), false, -1)
  else if (value.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'Transport.output', 'valueDecimal', TFhirDecimal(value.value), false, -1)
  else if (value.value is TFhirInstant) {6} then
    ComposeInstant(this, 'Transport.output', 'valueInstant', TFhirInstant(value.value), false, -1)
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Transport.output', 'valueInteger', TFhirInteger(value.value), false, -1)
  else if (value.value is TFhirInteger64) {6} then
    ComposeInteger64(this, 'Transport.output', 'valueInteger64', TFhirInteger64(value.value), false, -1)
  else if (value.value is TFhirString) {6} then
    ComposeString(this, 'Transport.output', 'valueString', TFhirString(value.value), false, -1)
  else if (value.value is TFhirTime) {6} then
    ComposeTime(this, 'Transport.output', 'valueTime', TFhirTime(value.value), false, -1)
  else if (value.value is TFhirUri) {6} then
    ComposeUri(this, 'Transport.output', 'valueUri', TFhirUri(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseTransport(obj : TTurtleComplex) : TFhirTransport;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTransport.create;
  try
    ParseTransportProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTransportProperties(obj : TTurtleComplex; value : TFhirTransport);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/Transport.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.instantiatesCanonicalElement := ParseCanonical(obj.complex('http://hl7.org/fhir/Transport.instantiatesCanonical'));
    value.instantiatesUriElement := ParseUri(obj.complex('http://hl7.org/fhir/Transport.instantiatesUri'));
    for item in obj.complexes('http://hl7.org/fhir/Transport.basedOn') do
      value.basedOnList.Add(parseReference(item));
    value.groupIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Transport.groupIdentifier'));
    for item in obj.complexes('http://hl7.org/fhir/Transport.partOf') do
      value.partOfList.Add(parseReference(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Transport.status'), CODES_TFhirTransportStatusEnum, SYSTEMS_TFhirTransportStatusEnum);
    value.statusReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Transport.statusReason'));
    value.intentElement := ParseEnum(obj.complex('http://hl7.org/fhir/Transport.intent'), CODES_TFhirTransportIntentEnum, SYSTEMS_TFhirTransportIntentEnum);
    value.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/Transport.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    value.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Transport.code'));
    value.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Transport.description'));
    value.focus := ParseReference(obj.complex('http://hl7.org/fhir/Transport.focus'));
    value.for_ := ParseReference(obj.complex('http://hl7.org/fhir/Transport.for'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/Transport.encounter'));
    value.completionTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Transport.completionTime'));
    value.authoredOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Transport.authoredOn'));
    value.lastModifiedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Transport.lastModified'));
    value.requester := ParseReference(obj.complex('http://hl7.org/fhir/Transport.requester'));
    for item in obj.complexes('http://hl7.org/fhir/Transport.performerType') do
      value.performerTypeList.Add(parseCodeableConcept(item));
    value.owner := ParseReference(obj.complex('http://hl7.org/fhir/Transport.owner'));
    value.location := ParseReference(obj.complex('http://hl7.org/fhir/Transport.location'));
    value.reasonCode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Transport.reasonCode'));
    value.reasonReference := ParseReference(obj.complex('http://hl7.org/fhir/Transport.reasonReference'));
    for item in obj.complexes('http://hl7.org/fhir/Transport.insurance') do
      value.insuranceList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/Transport.note') do
      value.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/Transport.relevantHistory') do
      value.relevantHistoryList.Add(parseReference(item));
    value.restriction := ParseTransportRestriction(obj.complex('http://hl7.org/fhir/Transport.restriction'));
    for item in obj.complexes('http://hl7.org/fhir/Transport.input') do
      value.inputList.Add(parseTransportInput(item));
    for item in obj.complexes('http://hl7.org/fhir/Transport.output') do
      value.outputList.Add(parseTransportOutput(item));
    value.requestedLocation := ParseReference(obj.complex('http://hl7.org/fhir/Transport.requestedLocation'));
    value.currentLocation := ParseReference(obj.complex('http://hl7.org/fhir/Transport.currentLocation'));
    value.history := ParseReference(obj.complex('http://hl7.org/fhir/Transport.history'));
end;

procedure TFHIRTurtleComposer.ComposeTransport(parent :  TTurtleComplex; parentType, name : String; value : TFhirTransport; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Transport');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Transport', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(this, 'Transport', 'instantiatesCanonical', value.instantiatesCanonicalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'Transport', 'instantiatesUri', value.instantiatesUriElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.basedOnList.Count - 1 do
      ComposeReference(this, 'Transport', 'basedOn', value.basedOnList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'Transport', 'groupIdentifier', value.groupIdentifierElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.partOfList.Count - 1 do
      ComposeReference(this, 'Transport', 'partOf', value.partOfList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Transport', 'status', value.statusElement, CODES_TFhirTransportStatusEnum, SYSTEMS_TFhirTransportStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Transport', 'statusReason', value.statusReasonElement, false, -1);
  ComposeEnum(this, 'Transport', 'intent', value.intentElement, CODES_TFhirTransportIntentEnum, SYSTEMS_TFhirTransportIntentEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Transport', 'priority', value.priorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Transport', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Transport', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Transport', 'focus', value.focusElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Transport', 'for', value.for_Element, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Transport', 'encounter', value.encounterElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Transport', 'completionTime', value.completionTimeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Transport', 'authoredOn', value.authoredOnElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Transport', 'lastModified', value.lastModifiedElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Transport', 'requester', value.requesterElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.performerTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Transport', 'performerType', value.performerTypeList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Transport', 'owner', value.ownerElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'Transport', 'location', value.locationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Transport', 'reasonCode', value.reasonCodeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Transport', 'reasonReference', value.reasonReferenceElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.insuranceList.Count - 1 do
      ComposeReference(this, 'Transport', 'insurance', value.insuranceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'Transport', 'note', value.noteList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relevantHistoryList.Count - 1 do
      ComposeReference(this, 'Transport', 'relevantHistory', value.relevantHistoryList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeTransportRestriction(this, 'Transport', 'restriction', value.restrictionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.inputList.Count - 1 do
      ComposeTransportInput(this, 'Transport', 'input', value.inputList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.outputList.Count - 1 do
      ComposeTransportOutput(this, 'Transport', 'output', value.outputList[i], false, i);
  ComposeReference(this, 'Transport', 'requestedLocation', value.requestedLocationElement, false, -1);
  ComposeReference(this, 'Transport', 'currentLocation', value.currentLocationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'Transport', 'history', value.historyElement, false, -1);
end;

{$ENDIF FHIR_TRANSPORT}
{$IFDEF FHIR_VALUESET}
function TFHIRTurtleParser.ParseValueSetCompose(obj : TTurtleComplex) : TFhirValueSetCompose;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetCompose.create;
  try
    ParseValueSetComposeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetComposeProperties(obj : TTurtleComplex; value : TFhirValueSetCompose);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.lockedDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ValueSet.compose.lockedDate'));
    value.inactiveElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ValueSet.compose.inactive'));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.include') do
      value.includeList.Add(parseValueSetComposeInclude(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.exclude') do
      value.excludeList.Add(parseValueSetComposeInclude(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.property') do
      value.property_List.Add(parseString(item));
end;

procedure TFHIRTurtleComposer.ComposeValueSetCompose(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSetCompose; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetCompose');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'ValueSet.compose', 'lockedDate', value.lockedDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ValueSet.compose', 'inactive', value.inactiveElement, false, -1);
  for i := 0 to value.includeList.Count - 1 do
      ComposeValueSetComposeInclude(this, 'ValueSet.compose', 'include', value.includeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.excludeList.Count - 1 do
      ComposeValueSetComposeInclude(this, 'ValueSet.compose', 'exclude', value.excludeList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeString(this, 'ValueSet.compose', 'property', value.property_List[i], false, i);
end;

function TFHIRTurtleParser.ParseValueSetComposeInclude(obj : TTurtleComplex) : TFhirValueSetComposeInclude;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetComposeInclude.create;
  try
    ParseValueSetComposeIncludeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetComposeIncludeProperties(obj : TTurtleComplex; value : TFhirValueSetComposeInclude);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.systemElement := ParseUri(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.system'));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.version'));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.include.concept') do
      value.conceptList.Add(parseValueSetComposeIncludeConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.include.filter') do
      value.filterList.Add(parseValueSetComposeIncludeFilter(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.include.valueSet') do
      value.valueSetList.Add(parseCanonical(item));
    value.copyrightElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.copyright'));
end;

procedure TFHIRTurtleComposer.ComposeValueSetComposeInclude(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSetComposeInclude; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetComposeInclude');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ValueSet.compose.include', 'system', value.systemElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ValueSet.compose.include', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.conceptList.Count - 1 do
      ComposeValueSetComposeIncludeConcept(this, 'ValueSet.compose.include', 'concept', value.conceptList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.filterList.Count - 1 do
      ComposeValueSetComposeIncludeFilter(this, 'ValueSet.compose.include', 'filter', value.filterList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.valueSetList.Count - 1 do
      ComposeCanonical(this, 'ValueSet.compose.include', 'valueSet', value.valueSetList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSet.compose.include', 'copyright', value.copyrightElement, false, -1);
end;

function TFHIRTurtleParser.ParseValueSetComposeIncludeConcept(obj : TTurtleComplex) : TFhirValueSetComposeIncludeConcept;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetComposeIncludeConcept.create;
  try
    ParseValueSetComposeIncludeConceptProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetComposeIncludeConceptProperties(obj : TTurtleComplex; value : TFhirValueSetComposeIncludeConcept);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.concept.code'));
    value.displayElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.concept.display'));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.include.concept.designation') do
      value.designationList.Add(parseValueSetComposeIncludeConceptDesignation(item));
end;

procedure TFHIRTurtleComposer.ComposeValueSetComposeIncludeConcept(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSetComposeIncludeConcept; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetComposeIncludeConcept');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCode(this, 'ValueSet.compose.include.concept', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSet.compose.include.concept', 'display', value.displayElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.designationList.Count - 1 do
      ComposeValueSetComposeIncludeConceptDesignation(this, 'ValueSet.compose.include.concept', 'designation', value.designationList[i], false, i);
end;

function TFHIRTurtleParser.ParseValueSetComposeIncludeConceptDesignation(obj : TTurtleComplex) : TFhirValueSetComposeIncludeConceptDesignation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetComposeIncludeConceptDesignation.create;
  try
    ParseValueSetComposeIncludeConceptDesignationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetComposeIncludeConceptDesignationProperties(obj : TTurtleComplex; value : TFhirValueSetComposeIncludeConceptDesignation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.languageElement := ParseCode(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.concept.designation.language'));
    value.use := ParseCoding(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.concept.designation.use'));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.include.concept.designation.additionalUse') do
      value.additionalUseList.Add(parseCoding(item));
    value.valueElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.concept.designation.value'));
end;

procedure TFHIRTurtleComposer.ComposeValueSetComposeIncludeConceptDesignation(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSetComposeIncludeConceptDesignation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetComposeIncludeConceptDesignation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ValueSet.compose.include.concept.designation', 'language', value.languageElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'ValueSet.compose.include.concept.designation', 'use', value.useElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.additionalUseList.Count - 1 do
      ComposeCoding(this, 'ValueSet.compose.include.concept.designation', 'additionalUse', value.additionalUseList[i], false, i);
  ComposeString(this, 'ValueSet.compose.include.concept.designation', 'value', value.valueElement, false, -1);
end;

function TFHIRTurtleParser.ParseValueSetComposeIncludeFilter(obj : TTurtleComplex) : TFhirValueSetComposeIncludeFilter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    ParseValueSetComposeIncludeFilterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetComposeIncludeFilterProperties(obj : TTurtleComplex; value : TFhirValueSetComposeIncludeFilter);
begin
    ParseBackboneElementProperties(obj, value);
    value.property_Element := ParseCode(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.filter.property'));
    value.opElement := ParseEnum(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.filter.op'), CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum);
    value.valueElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.filter.value'));
end;

procedure TFHIRTurtleComposer.ComposeValueSetComposeIncludeFilter(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSetComposeIncludeFilter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetComposeIncludeFilter');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCode(this, 'ValueSet.compose.include.filter', 'property', value.property_Element, false, -1);
  ComposeEnum(this, 'ValueSet.compose.include.filter', 'op', value.opElement, CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum, false, -1);
  ComposeString(this, 'ValueSet.compose.include.filter', 'value', value.valueElement, false, -1);
end;

function TFHIRTurtleParser.ParseValueSetExpansion(obj : TTurtleComplex) : TFhirValueSetExpansion;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetExpansion.create;
  try
    ParseValueSetExpansionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetExpansionProperties(obj : TTurtleComplex; value : TFhirValueSetExpansion);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.identifierElement := ParseUri(obj.complex('http://hl7.org/fhir/ValueSet.expansion.identifier'));
    value.nextElement := ParseUri(obj.complex('http://hl7.org/fhir/ValueSet.expansion.next'));
    value.timestampElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ValueSet.expansion.timestamp'));
    value.totalElement := ParseInteger(obj.complex('http://hl7.org/fhir/ValueSet.expansion.total'));
    value.offsetElement := ParseInteger(obj.complex('http://hl7.org/fhir/ValueSet.expansion.offset'));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.expansion.parameter') do
      value.parameterList.Add(parseValueSetExpansionParameter(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.expansion.property') do
      value.property_List.Add(parseValueSetExpansionProperty(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.expansion.contains') do
      value.containsList.Add(parseValueSetExpansionContains(item));
end;

procedure TFHIRTurtleComposer.ComposeValueSetExpansion(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSetExpansion; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetExpansion');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ValueSet.expansion', 'identifier', value.identifierElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ValueSet.expansion', 'next', value.nextElement, false, -1);
  ComposeDateTime(this, 'ValueSet.expansion', 'timestamp', value.timestampElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'ValueSet.expansion', 'total', value.totalElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'ValueSet.expansion', 'offset', value.offsetElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.parameterList.Count - 1 do
      ComposeValueSetExpansionParameter(this, 'ValueSet.expansion', 'parameter', value.parameterList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeValueSetExpansionProperty(this, 'ValueSet.expansion', 'property', value.property_List[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.containsList.Count - 1 do
      ComposeValueSetExpansionContains(this, 'ValueSet.expansion', 'contains', value.containsList[i], false, i);
end;

function TFHIRTurtleParser.ParseValueSetExpansionParameter(obj : TTurtleComplex) : TFhirValueSetExpansionParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetExpansionParameter.create;
  try
    ParseValueSetExpansionParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetExpansionParameterProperties(obj : TTurtleComplex; value : TFhirValueSetExpansionParameter);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.expansion.parameter.name'));
    if obj.has('valueCode', item) then
      value.value := parseCode(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    if obj.has('valueInteger', item) then
      value.value := parseInteger(item);
    if obj.has('valueDecimal', item) then
      value.value := parseDecimal(item);
    if obj.has('valueUri', item) then
      value.value := parseUri(item);
    if obj.has('valueDateTime', item) then
      value.value := parseDateTime(item);
end;

procedure TFHIRTurtleComposer.ComposeValueSetExpansionParameter(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSetExpansionParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetExpansionParameter');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeString(this, 'ValueSet.expansion.parameter', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soData]) and (value.value is TFhirCode) {6} then
    ComposeCode(this, 'ValueSet.expansion.parameter', 'valueCode', TFhirCode(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirString) {6} then
    ComposeString(this, 'ValueSet.expansion.parameter', 'valueString', TFhirString(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ValueSet.expansion.parameter', 'valueBoolean', TFhirBoolean(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirInteger) {6} then
    ComposeInteger(this, 'ValueSet.expansion.parameter', 'valueInteger', TFhirInteger(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ValueSet.expansion.parameter', 'valueDecimal', TFhirDecimal(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirUri) {6} then
    ComposeUri(this, 'ValueSet.expansion.parameter', 'valueUri', TFhirUri(value.value), false, -1)
  else if (SummaryOption in [soFull, soData]) and (value.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ValueSet.expansion.parameter', 'valueDateTime', TFhirDateTime(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseValueSetExpansionProperty(obj : TTurtleComplex) : TFhirValueSetExpansionProperty;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetExpansionProperty.create;
  try
    ParseValueSetExpansionPropertyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetExpansionPropertyProperties(obj : TTurtleComplex; value : TFhirValueSetExpansionProperty);
begin
    ParseBackboneElementProperties(obj, value);
    value.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ValueSet.expansion.property.code'));
    value.uriElement := ParseUri(obj.complex('http://hl7.org/fhir/ValueSet.expansion.property.uri'));
end;

procedure TFHIRTurtleComposer.ComposeValueSetExpansionProperty(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSetExpansionProperty; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetExpansionProperty');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCode(this, 'ValueSet.expansion.property', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ValueSet.expansion.property', 'uri', value.uriElement, false, -1);
end;

function TFHIRTurtleParser.ParseValueSetExpansionContains(obj : TTurtleComplex) : TFhirValueSetExpansionContains;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetExpansionContains.create;
  try
    ParseValueSetExpansionContainsProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetExpansionContainsProperties(obj : TTurtleComplex; value : TFhirValueSetExpansionContains);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.systemElement := ParseUri(obj.complex('http://hl7.org/fhir/ValueSet.expansion.contains.system'));
    value.abstractElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ValueSet.expansion.contains.abstract'));
    value.inactiveElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ValueSet.expansion.contains.inactive'));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.expansion.contains.version'));
    value.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ValueSet.expansion.contains.code'));
    value.displayElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.expansion.contains.display'));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.expansion.contains.designation') do
      value.designationList.Add(parseValueSetComposeIncludeConceptDesignation(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.expansion.contains.property') do
      value.property_List.Add(parseValueSetExpansionContainsProperty(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.expansion.contains.contains') do
      value.containsList.Add(parseValueSetExpansionContains(item));
end;

procedure TFHIRTurtleComposer.ComposeValueSetExpansionContains(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSetExpansionContains; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetExpansionContains');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ValueSet.expansion.contains', 'system', value.systemElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ValueSet.expansion.contains', 'abstract', value.abstractElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ValueSet.expansion.contains', 'inactive', value.inactiveElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSet.expansion.contains', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ValueSet.expansion.contains', 'code', value.codeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSet.expansion.contains', 'display', value.displayElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.designationList.Count - 1 do
      ComposeValueSetComposeIncludeConceptDesignation(this, 'ValueSet.expansion.contains', 'designation', value.designationList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.property_List.Count - 1 do
      ComposeValueSetExpansionContainsProperty(this, 'ValueSet.expansion.contains', 'property', value.property_List[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.containsList.Count - 1 do
      ComposeValueSetExpansionContains(this, 'ValueSet.expansion.contains', 'contains', value.containsList[i], false, i);
end;

function TFHIRTurtleParser.ParseValueSetExpansionContainsProperty(obj : TTurtleComplex) : TFhirValueSetExpansionContainsProperty;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetExpansionContainsProperty.create;
  try
    ParseValueSetExpansionContainsPropertyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetExpansionContainsPropertyProperties(obj : TTurtleComplex; value : TFhirValueSetExpansionContainsProperty);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ValueSet.expansion.contains.property.code'));
    if obj.has('valueCode', item) then
      value.value := parseCode(item);
    if obj.has('valueCoding', item) then
      value.value := parseCoding(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    if obj.has('valueInteger', item) then
      value.value := parseInteger(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    if obj.has('valueDateTime', item) then
      value.value := parseDateTime(item);
    if obj.has('valueDecimal', item) then
      value.value := parseDecimal(item);
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.expansion.contains.property.subProperty') do
      value.subPropertyList.Add(parseValueSetExpansionContainsPropertySubProperty(item));
end;

procedure TFHIRTurtleComposer.ComposeValueSetExpansionContainsProperty(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSetExpansionContainsProperty; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetExpansionContainsProperty');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCode(this, 'ValueSet.expansion.contains.property', 'code', value.codeElement, false, -1);
  if (value.value is TFhirCode) {6} then
    ComposeCode(this, 'ValueSet.expansion.contains.property', 'valueCode', TFhirCode(value.value), false, -1)
  else if (value.value is TFhirCoding) {6} then
    ComposeCoding(this, 'ValueSet.expansion.contains.property', 'valueCoding', TFhirCoding(value.value), false, -1)
  else if (value.value is TFhirString) {6} then
    ComposeString(this, 'ValueSet.expansion.contains.property', 'valueString', TFhirString(value.value), false, -1)
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(this, 'ValueSet.expansion.contains.property', 'valueInteger', TFhirInteger(value.value), false, -1)
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ValueSet.expansion.contains.property', 'valueBoolean', TFhirBoolean(value.value), false, -1)
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ValueSet.expansion.contains.property', 'valueDateTime', TFhirDateTime(value.value), false, -1)
  else if (value.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ValueSet.expansion.contains.property', 'valueDecimal', TFhirDecimal(value.value), false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.subPropertyList.Count - 1 do
      ComposeValueSetExpansionContainsPropertySubProperty(this, 'ValueSet.expansion.contains.property', 'subProperty', value.subPropertyList[i], false, i);
end;

function TFHIRTurtleParser.ParseValueSetExpansionContainsPropertySubProperty(obj : TTurtleComplex) : TFhirValueSetExpansionContainsPropertySubProperty;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetExpansionContainsPropertySubProperty.create;
  try
    ParseValueSetExpansionContainsPropertySubPropertyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetExpansionContainsPropertySubPropertyProperties(obj : TTurtleComplex; value : TFhirValueSetExpansionContainsPropertySubProperty);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ValueSet.expansion.contains.property.subProperty.code'));
    if obj.has('valueCode', item) then
      value.value := parseCode(item);
    if obj.has('valueCoding', item) then
      value.value := parseCoding(item);
    if obj.has('valueString', item) then
      value.value := parseString(item);
    if obj.has('valueInteger', item) then
      value.value := parseInteger(item);
    if obj.has('valueBoolean', item) then
      value.value := parseBoolean(item);
    if obj.has('valueDateTime', item) then
      value.value := parseDateTime(item);
    if obj.has('valueDecimal', item) then
      value.value := parseDecimal(item);
end;

procedure TFHIRTurtleComposer.ComposeValueSetExpansionContainsPropertySubProperty(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSetExpansionContainsPropertySubProperty; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetExpansionContainsPropertySubProperty');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCode(this, 'ValueSet.expansion.contains.property.subProperty', 'code', value.codeElement, false, -1);
  if (value.value is TFhirCode) {6} then
    ComposeCode(this, 'ValueSet.expansion.contains.property.subProperty', 'valueCode', TFhirCode(value.value), false, -1)
  else if (value.value is TFhirCoding) {6} then
    ComposeCoding(this, 'ValueSet.expansion.contains.property.subProperty', 'valueCoding', TFhirCoding(value.value), false, -1)
  else if (value.value is TFhirString) {6} then
    ComposeString(this, 'ValueSet.expansion.contains.property.subProperty', 'valueString', TFhirString(value.value), false, -1)
  else if (value.value is TFhirInteger) {6} then
    ComposeInteger(this, 'ValueSet.expansion.contains.property.subProperty', 'valueInteger', TFhirInteger(value.value), false, -1)
  else if (value.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ValueSet.expansion.contains.property.subProperty', 'valueBoolean', TFhirBoolean(value.value), false, -1)
  else if (value.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ValueSet.expansion.contains.property.subProperty', 'valueDateTime', TFhirDateTime(value.value), false, -1)
  else if (value.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ValueSet.expansion.contains.property.subProperty', 'valueDecimal', TFhirDecimal(value.value), false, -1);
end;

function TFHIRTurtleParser.ParseValueSetScope(obj : TTurtleComplex) : TFhirValueSetScope;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetScope.create;
  try
    ParseValueSetScopeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetScopeProperties(obj : TTurtleComplex; value : TFhirValueSetScope);
begin
    ParseBackboneElementProperties(obj, value);
    value.inclusionCriteriaElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.scope.inclusionCriteria'));
    value.exclusionCriteriaElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.scope.exclusionCriteria'));
end;

procedure TFHIRTurtleComposer.ComposeValueSetScope(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSetScope; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetScope');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSet.scope', 'inclusionCriteria', value.inclusionCriteriaElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSet.scope', 'exclusionCriteria', value.exclusionCriteriaElement, false, -1);
end;

function TFHIRTurtleParser.ParseValueSet(obj : TTurtleComplex) : TFhirValueSet;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSet.create;
  try
    ParseValueSetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetProperties(obj : TTurtleComplex; value : TFhirValueSet);
var
  item : TTurtleComplex;
begin
    ParseMetadataResourceProperties(obj, value);
    value.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ValueSet.url'));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.version'));
    value.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.name'));
    value.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.title'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ValueSet.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    value.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ValueSet.experimental'));
    value.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ValueSet.date'));
    value.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.publisher'));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.contact') do
      value.contactList.Add(parseContactDetail(item));
    value.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ValueSet.description'));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.useContext') do
      value.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.jurisdiction') do
      value.jurisdictionList.Add(parseCodeableConcept(item));
    value.immutableElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ValueSet.immutable'));
    value.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ValueSet.purpose'));
    value.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ValueSet.copyright'));
    value.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ValueSet.approvalDate'));
    value.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ValueSet.lastReviewDate'));
    value.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/ValueSet.effectivePeriod'));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.topic') do
      value.topicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.author') do
      value.authorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.editor') do
      value.editorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.reviewer') do
      value.reviewerList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.endorser') do
      value.endorserList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.relatedArtifact') do
      value.relatedArtifactList.Add(parseRelatedArtifact(item));
    value.compose := ParseValueSetCompose(obj.complex('http://hl7.org/fhir/ValueSet.compose'));
    value.expansion := ParseValueSetExpansion(obj.complex('http://hl7.org/fhir/ValueSet.expansion'));
    value.scope := ParseValueSetScope(obj.complex('http://hl7.org/fhir/ValueSet.scope'));
end;

procedure TFHIRTurtleComposer.ComposeValueSet(parent :  TTurtleComplex; parentType, name : String; value : TFhirValueSet; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSet');
  end;
  composeMetadataResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ValueSet', 'url', value.urlElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ValueSet', 'identifier', value.identifierList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ValueSet', 'version', value.versionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ValueSet', 'name', value.nameElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ValueSet', 'title', value.titleElement, false, -1);
  ComposeEnum(this, 'ValueSet', 'status', value.statusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ValueSet', 'experimental', value.experimentalElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ValueSet', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ValueSet', 'publisher', value.publisherElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.contactList.Count - 1 do
      ComposeContactDetail(this, 'ValueSet', 'contact', value.contactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ValueSet', 'description', value.descriptionElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.useContextList.Count - 1 do
      ComposeUsageContext(this, 'ValueSet', 'useContext', value.useContextList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'ValueSet', 'jurisdiction', value.jurisdictionList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ValueSet', 'immutable', value.immutableElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ValueSet', 'purpose', value.purposeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ValueSet', 'copyright', value.copyrightElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'ValueSet', 'approvalDate', value.approvalDateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'ValueSet', 'lastReviewDate', value.lastReviewDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'ValueSet', 'effectivePeriod', value.effectivePeriodElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.topicList.Count - 1 do
      ComposeCodeableConcept(this, 'ValueSet', 'topic', value.topicList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.authorList.Count - 1 do
      ComposeContactDetail(this, 'ValueSet', 'author', value.authorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.editorList.Count - 1 do
      ComposeContactDetail(this, 'ValueSet', 'editor', value.editorList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.reviewerList.Count - 1 do
      ComposeContactDetail(this, 'ValueSet', 'reviewer', value.reviewerList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.endorserList.Count - 1 do
      ComposeContactDetail(this, 'ValueSet', 'endorser', value.endorserList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'ValueSet', 'relatedArtifact', value.relatedArtifactList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeValueSetCompose(this, 'ValueSet', 'compose', value.composeElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeValueSetExpansion(this, 'ValueSet', 'expansion', value.expansionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeValueSetScope(this, 'ValueSet', 'scope', value.scopeElement, false, -1);
end;

{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VERIFICATIONRESULT}
function TFHIRTurtleParser.ParseVerificationResultPrimarySource(obj : TTurtleComplex) : TFhirVerificationResultPrimarySource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirVerificationResultPrimarySource.create;
  try
    ParseVerificationResultPrimarySourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseVerificationResultPrimarySourceProperties(obj : TTurtleComplex; value : TFhirVerificationResultPrimarySource);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.who := ParseReference(obj.complex('http://hl7.org/fhir/VerificationResult.primarySource.who'));
    for item in obj.complexes('http://hl7.org/fhir/VerificationResult.primarySource.type') do
      value.type_List.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/VerificationResult.primarySource.communicationMethod') do
      value.communicationMethodList.Add(parseCodeableConcept(item));
    value.validationStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/VerificationResult.primarySource.validationStatus'));
    value.validationDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/VerificationResult.primarySource.validationDate'));
    value.canPushUpdates := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/VerificationResult.primarySource.canPushUpdates'));
    for item in obj.complexes('http://hl7.org/fhir/VerificationResult.primarySource.pushTypeAvailable') do
      value.pushTypeAvailableList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeVerificationResultPrimarySource(parent :  TTurtleComplex; parentType, name : String; value : TFhirVerificationResultPrimarySource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:VerificationResultPrimarySource');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'VerificationResult.primarySource', 'who', value.whoElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'VerificationResult.primarySource', 'type', value.type_List[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.communicationMethodList.Count - 1 do
      ComposeCodeableConcept(this, 'VerificationResult.primarySource', 'communicationMethod', value.communicationMethodList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'VerificationResult.primarySource', 'validationStatus', value.validationStatusElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'VerificationResult.primarySource', 'validationDate', value.validationDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'VerificationResult.primarySource', 'canPushUpdates', value.canPushUpdatesElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.pushTypeAvailableList.Count - 1 do
      ComposeCodeableConcept(this, 'VerificationResult.primarySource', 'pushTypeAvailable', value.pushTypeAvailableList[i], false, i);
end;

function TFHIRTurtleParser.ParseVerificationResultAttestation(obj : TTurtleComplex) : TFhirVerificationResultAttestation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirVerificationResultAttestation.create;
  try
    ParseVerificationResultAttestationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseVerificationResultAttestationProperties(obj : TTurtleComplex; value : TFhirVerificationResultAttestation);
begin
    ParseBackboneElementProperties(obj, value);
    value.who := ParseReference(obj.complex('http://hl7.org/fhir/VerificationResult.attestation.who'));
    value.onBehalfOf := ParseReference(obj.complex('http://hl7.org/fhir/VerificationResult.attestation.onBehalfOf'));
    value.communicationMethod := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/VerificationResult.attestation.communicationMethod'));
    value.dateElement := ParseDate(obj.complex('http://hl7.org/fhir/VerificationResult.attestation.date'));
    value.sourceIdentityCertificateElement := ParseString(obj.complex('http://hl7.org/fhir/VerificationResult.attestation.sourceIdentityCertificate'));
    value.proxyIdentityCertificateElement := ParseString(obj.complex('http://hl7.org/fhir/VerificationResult.attestation.proxyIdentityCertificate'));
    value.proxySignature := ParseSignature(obj.complex('http://hl7.org/fhir/VerificationResult.attestation.proxySignature'));
    value.sourceSignature := ParseSignature(obj.complex('http://hl7.org/fhir/VerificationResult.attestation.sourceSignature'));
end;

procedure TFHIRTurtleComposer.ComposeVerificationResultAttestation(parent :  TTurtleComplex; parentType, name : String; value : TFhirVerificationResultAttestation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:VerificationResultAttestation');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'VerificationResult.attestation', 'who', value.whoElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference(this, 'VerificationResult.attestation', 'onBehalfOf', value.onBehalfOfElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'VerificationResult.attestation', 'communicationMethod', value.communicationMethodElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'VerificationResult.attestation', 'date', value.dateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'VerificationResult.attestation', 'sourceIdentityCertificate', value.sourceIdentityCertificateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'VerificationResult.attestation', 'proxyIdentityCertificate', value.proxyIdentityCertificateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeSignature(this, 'VerificationResult.attestation', 'proxySignature', value.proxySignatureElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeSignature(this, 'VerificationResult.attestation', 'sourceSignature', value.sourceSignatureElement, false, -1);
end;

function TFHIRTurtleParser.ParseVerificationResultValidator(obj : TTurtleComplex) : TFhirVerificationResultValidator;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirVerificationResultValidator.create;
  try
    ParseVerificationResultValidatorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseVerificationResultValidatorProperties(obj : TTurtleComplex; value : TFhirVerificationResultValidator);
begin
    ParseBackboneElementProperties(obj, value);
    value.organization := ParseReference(obj.complex('http://hl7.org/fhir/VerificationResult.validator.organization'));
    value.identityCertificateElement := ParseString(obj.complex('http://hl7.org/fhir/VerificationResult.validator.identityCertificate'));
    value.attestationSignature := ParseSignature(obj.complex('http://hl7.org/fhir/VerificationResult.validator.attestationSignature'));
end;

procedure TFHIRTurtleComposer.ComposeVerificationResultValidator(parent :  TTurtleComplex; parentType, name : String; value : TFhirVerificationResultValidator; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:VerificationResultValidator');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeReference(this, 'VerificationResult.validator', 'organization', value.organizationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'VerificationResult.validator', 'identityCertificate', value.identityCertificateElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeSignature(this, 'VerificationResult.validator', 'attestationSignature', value.attestationSignatureElement, false, -1);
end;

function TFHIRTurtleParser.ParseVerificationResult(obj : TTurtleComplex) : TFhirVerificationResult;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirVerificationResult.create;
  try
    ParseVerificationResultProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseVerificationResultProperties(obj : TTurtleComplex; value : TFhirVerificationResult);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/VerificationResult.target') do
      value.targetList.Add(parseReference(item));
    for item in obj.complexes('http://hl7.org/fhir/VerificationResult.targetLocation') do
      value.targetLocationList.Add(parseString(item));
    value.need := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/VerificationResult.need'));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/VerificationResult.status'), CODES_TFhirStatusEnum, SYSTEMS_TFhirStatusEnum);
    value.statusDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/VerificationResult.statusDate'));
    value.validationType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/VerificationResult.validationType'));
    for item in obj.complexes('http://hl7.org/fhir/VerificationResult.validationProcess') do
      value.validationProcessList.Add(parseCodeableConcept(item));
    value.frequency := ParseTiming(obj.complex('http://hl7.org/fhir/VerificationResult.frequency'));
    value.lastPerformedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/VerificationResult.lastPerformed'));
    value.nextScheduledElement := ParseDate(obj.complex('http://hl7.org/fhir/VerificationResult.nextScheduled'));
    value.failureAction := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/VerificationResult.failureAction'));
    for item in obj.complexes('http://hl7.org/fhir/VerificationResult.primarySource') do
      value.primarySourceList.Add(parseVerificationResultPrimarySource(item));
    value.attestation := ParseVerificationResultAttestation(obj.complex('http://hl7.org/fhir/VerificationResult.attestation'));
    for item in obj.complexes('http://hl7.org/fhir/VerificationResult.validator') do
      value.validatorList.Add(parseVerificationResultValidator(item));
end;

procedure TFHIRTurtleComposer.ComposeVerificationResult(parent :  TTurtleComplex; parentType, name : String; value : TFhirVerificationResult; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:VerificationResult');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.targetList.Count - 1 do
      ComposeReference(this, 'VerificationResult', 'target', value.targetList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.targetLocationList.Count - 1 do
      ComposeString(this, 'VerificationResult', 'targetLocation', value.targetLocationList[i], false, i);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'VerificationResult', 'need', value.needElement, false, -1);
  ComposeEnum(this, 'VerificationResult', 'status', value.statusElement, CODES_TFhirStatusEnum, SYSTEMS_TFhirStatusEnum, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'VerificationResult', 'statusDate', value.statusDateElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'VerificationResult', 'validationType', value.validationTypeElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to value.validationProcessList.Count - 1 do
      ComposeCodeableConcept(this, 'VerificationResult', 'validationProcess', value.validationProcessList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeTiming(this, 'VerificationResult', 'frequency', value.frequencyElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'VerificationResult', 'lastPerformed', value.lastPerformedElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'VerificationResult', 'nextScheduled', value.nextScheduledElement, false, -1);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'VerificationResult', 'failureAction', value.failureActionElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.primarySourceList.Count - 1 do
      ComposeVerificationResultPrimarySource(this, 'VerificationResult', 'primarySource', value.primarySourceList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeVerificationResultAttestation(this, 'VerificationResult', 'attestation', value.attestationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.validatorList.Count - 1 do
      ComposeVerificationResultValidator(this, 'VerificationResult', 'validator', value.validatorList[i], false, i);
end;

{$ENDIF FHIR_VERIFICATIONRESULT}
{$IFDEF FHIR_VISIONPRESCRIPTION}
function TFHIRTurtleParser.ParseVisionPrescriptionLensSpecification(obj : TTurtleComplex) : TFhirVisionPrescriptionLensSpecification;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirVisionPrescriptionLensSpecification.create;
  try
    ParseVisionPrescriptionLensSpecificationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseVisionPrescriptionLensSpecificationProperties(obj : TTurtleComplex; value : TFhirVisionPrescriptionLensSpecification);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, value);
    value.product := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.product'));
    value.eyeElement := ParseEnum(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.eye'), CODES_TFhirVisionEyesEnum, SYSTEMS_TFhirVisionEyesEnum);
    value.sphereElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.sphere'));
    value.cylinderElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.cylinder'));
    value.axisElement := ParseInteger(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.axis'));
    for item in obj.complexes('http://hl7.org/fhir/VisionPrescription.lensSpecification.prism') do
      value.prismList.Add(parseVisionPrescriptionLensSpecificationPrism(item));
    value.addElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.add'));
    value.powerElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.power'));
    value.backCurveElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.backCurve'));
    value.diameterElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.diameter'));
    value.duration := ParseQuantity(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.duration'));
    value.colorElement := ParseString(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.color'));
    value.brandElement := ParseString(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.brand'));
    for item in obj.complexes('http://hl7.org/fhir/VisionPrescription.lensSpecification.note') do
      value.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeVisionPrescriptionLensSpecification(parent :  TTurtleComplex; parentType, name : String; value : TFhirVisionPrescriptionLensSpecification; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:VisionPrescriptionLensSpecification');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeCodeableConcept(this, 'VisionPrescription.lensSpecification', 'product', value.productElement, false, -1);
  ComposeEnum(this, 'VisionPrescription.lensSpecification', 'eye', value.eyeElement, CODES_TFhirVisionEyesEnum, SYSTEMS_TFhirVisionEyesEnum, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'VisionPrescription.lensSpecification', 'sphere', value.sphereElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'VisionPrescription.lensSpecification', 'cylinder', value.cylinderElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'VisionPrescription.lensSpecification', 'axis', value.axisElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.prismList.Count - 1 do
      ComposeVisionPrescriptionLensSpecificationPrism(this, 'VisionPrescription.lensSpecification', 'prism', value.prismList[i], false, i);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'VisionPrescription.lensSpecification', 'add', value.addElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'VisionPrescription.lensSpecification', 'power', value.powerElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'VisionPrescription.lensSpecification', 'backCurve', value.backCurveElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'VisionPrescription.lensSpecification', 'diameter', value.diameterElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'VisionPrescription.lensSpecification', 'duration', value.durationElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'VisionPrescription.lensSpecification', 'color', value.colorElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'VisionPrescription.lensSpecification', 'brand', value.brandElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.noteList.Count - 1 do
      ComposeAnnotation(this, 'VisionPrescription.lensSpecification', 'note', value.noteList[i], false, i);
end;

function TFHIRTurtleParser.ParseVisionPrescriptionLensSpecificationPrism(obj : TTurtleComplex) : TFhirVisionPrescriptionLensSpecificationPrism;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirVisionPrescriptionLensSpecificationPrism.create;
  try
    ParseVisionPrescriptionLensSpecificationPrismProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseVisionPrescriptionLensSpecificationPrismProperties(obj : TTurtleComplex; value : TFhirVisionPrescriptionLensSpecificationPrism);
begin
    ParseBackboneElementProperties(obj, value);
    value.amountElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.prism.amount'));
    value.baseElement := ParseEnum(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.prism.base'), CODES_TFhirVisionBaseEnum, SYSTEMS_TFhirVisionBaseEnum);
end;

procedure TFHIRTurtleComposer.ComposeVisionPrescriptionLensSpecificationPrism(parent :  TTurtleComplex; parentType, name : String; value : TFhirVisionPrescriptionLensSpecificationPrism; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:VisionPrescriptionLensSpecificationPrism');
  end;
  composeBackboneElement(this, '', name, value, false, index);
  ComposeDecimal(this, 'VisionPrescription.lensSpecification.prism', 'amount', value.amountElement, false, -1);
  ComposeEnum(this, 'VisionPrescription.lensSpecification.prism', 'base', value.baseElement, CODES_TFhirVisionBaseEnum, SYSTEMS_TFhirVisionBaseEnum, false, -1);
end;

function TFHIRTurtleParser.ParseVisionPrescription(obj : TTurtleComplex) : TFhirVisionPrescription;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirVisionPrescription.create;
  try
    ParseVisionPrescriptionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseVisionPrescriptionProperties(obj : TTurtleComplex; value : TFhirVisionPrescription);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, value);
    for item in obj.complexes('http://hl7.org/fhir/VisionPrescription.identifier') do
      value.identifierList.Add(parseIdentifier(item));
    value.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/VisionPrescription.status'), CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum);
    value.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/VisionPrescription.created'));
    value.patient := ParseReference(obj.complex('http://hl7.org/fhir/VisionPrescription.patient'));
    value.encounter := ParseReference(obj.complex('http://hl7.org/fhir/VisionPrescription.encounter'));
    value.dateWrittenElement := ParseDateTime(obj.complex('http://hl7.org/fhir/VisionPrescription.dateWritten'));
    value.prescriber := ParseReference(obj.complex('http://hl7.org/fhir/VisionPrescription.prescriber'));
    for item in obj.complexes('http://hl7.org/fhir/VisionPrescription.lensSpecification') do
      value.lensSpecificationList.Add(parseVisionPrescriptionLensSpecification(item));
end;

procedure TFHIRTurtleComposer.ComposeVisionPrescription(parent :  TTurtleComplex; parentType, name : String; value : TFhirVisionPrescription; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (value = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:VisionPrescription');
  end;
  composeDomainResource(this, '', name, value, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to value.identifierList.Count - 1 do
      ComposeIdentifier(this, 'VisionPrescription', 'identifier', value.identifierList[i], false, i);
  ComposeEnum(this, 'VisionPrescription', 'status', value.statusElement, CODES_TFhirFinancialResourceStatusCodesEnum, SYSTEMS_TFhirFinancialResourceStatusCodesEnum, false, -1);
  ComposeDateTime(this, 'VisionPrescription', 'created', value.createdElement, false, -1);
  ComposeReference(this, 'VisionPrescription', 'patient', value.patientElement, false, -1);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference(this, 'VisionPrescription', 'encounter', value.encounterElement, false, -1);
  ComposeDateTime(this, 'VisionPrescription', 'dateWritten', value.dateWrittenElement, false, -1);
  ComposeReference(this, 'VisionPrescription', 'prescriber', value.prescriberElement, false, -1);
  for i := 0 to value.lensSpecificationList.Count - 1 do
      ComposeVisionPrescriptionLensSpecification(this, 'VisionPrescription', 'lensSpecification', value.lensSpecificationList[i], false, i);
end;

{$ENDIF FHIR_VISIONPRESCRIPTION}


function TFHIRTurtleParser.ParseFragment(obj : TTurtleComplex; type_ : String) : TFHIRObject;
begin
  if (obj = nil) then
    Raise ERdfException.Create('error - object is nil')
  else if SameText(type_, 'Address') then
    result := parseAddress(obj)
  else if SameText(type_, 'Annotation') then
    result := parseAnnotation(obj)
  else if SameText(type_, 'Attachment') then
    result := parseAttachment(obj)
  else if SameText(type_, 'Availability') then
    result := parseAvailability(obj)
  else if SameText(type_, 'CodeableConcept') then
    result := parseCodeableConcept(obj)
  else if SameText(type_, 'CodeableReference') then
    result := parseCodeableReference(obj)
  else if SameText(type_, 'Coding') then
    result := parseCoding(obj)
  else if SameText(type_, 'ContactDetail') then
    result := parseContactDetail(obj)
  else if SameText(type_, 'ContactPoint') then
    result := parseContactPoint(obj)
  else if SameText(type_, 'Contributor') then
    result := parseContributor(obj)
  else if SameText(type_, 'DataRequirement') then
    result := parseDataRequirement(obj)
  else if SameText(type_, 'Expression') then
    result := parseExpression(obj)
  else if SameText(type_, 'ExtendedContactDetail') then
    result := parseExtendedContactDetail(obj)
  else if SameText(type_, 'Extension') then
    result := parseExtension(obj)
  else if SameText(type_, 'HumanName') then
    result := parseHumanName(obj)
  else if SameText(type_, 'Identifier') then
    result := parseIdentifier(obj)
  else if SameText(type_, 'Meta') then
    result := parseMeta(obj)
  else if SameText(type_, 'MonetaryComponent') then
    result := parseMonetaryComponent(obj)
  else if SameText(type_, 'Money') then
    result := parseMoney(obj)
  else if SameText(type_, 'Narrative') then
    result := parseNarrative(obj)
  else if SameText(type_, 'ParameterDefinition') then
    result := parseParameterDefinition(obj)
  else if SameText(type_, 'Period') then
    result := parsePeriod(obj)
  else if SameText(type_, 'Quantity') then
    result := parseQuantity(obj)
  else if SameText(type_, 'Range') then
    result := parseRange(obj)
  else if SameText(type_, 'Ratio') then
    result := parseRatio(obj)
  else if SameText(type_, 'RatioRange') then
    result := parseRatioRange(obj)
  else if SameText(type_, 'Reference') then
    result := parseReference(obj)
  else if SameText(type_, 'RelatedArtifact') then
    result := parseRelatedArtifact(obj)
  else if SameText(type_, 'SampledData') then
    result := parseSampledData(obj)
  else if SameText(type_, 'Signature') then
    result := parseSignature(obj)
  else if SameText(type_, 'TriggerDefinition') then
    result := parseTriggerDefinition(obj)
  else if SameText(type_, 'UsageContext') then
    result := parseUsageContext(obj)
  else if SameText(type_, 'VirtualServiceDetail') then
    result := parseVirtualServiceDetail(obj)
  else if SameText(type_, 'Age') then
    result := parseAge(obj)
  else if SameText(type_, 'Count') then
    result := parseCount(obj)
  else if SameText(type_, 'Distance') then
    result := parseDistance(obj)
  else if SameText(type_, 'Dosage') then
    result := parseDosage(obj)
  else if SameText(type_, 'Duration') then
    result := parseDuration(obj)
  else if SameText(type_, 'ElementDefinition') then
    result := parseElementDefinition(obj)
  else if SameText(type_, 'MarketingStatus') then
    result := parseMarketingStatus(obj)
  else if SameText(type_, 'Population') then
    result := parsePopulation(obj)
  else if SameText(type_, 'ProductShelfLife') then
    result := parseProductShelfLife(obj)
  else if SameText(type_, 'Timing') then
    result := parseTiming(obj)
{$IFDEF FHIR_ACCOUNT}
  else if SameText(type_, 'Account') then
    result := parseAccount(obj)
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
  else if SameText(type_, 'ActivityDefinition') then
    result := parseActivityDefinition(obj)
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ACTORDEFINITION}
  else if SameText(type_, 'ActorDefinition') then
    result := parseActorDefinition(obj)
{$ENDIF FHIR_ACTORDEFINITION}
{$IFDEF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
  else if SameText(type_, 'AdministrableProductDefinition') then
    result := parseAdministrableProductDefinition(obj)
{$ENDIF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
  else if SameText(type_, 'AdverseEvent') then
    result := parseAdverseEvent(obj)
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  else if SameText(type_, 'AllergyIntolerance') then
    result := parseAllergyIntolerance(obj)
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  else if SameText(type_, 'Appointment') then
    result := parseAppointment(obj)
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  else if SameText(type_, 'AppointmentResponse') then
    result := parseAppointmentResponse(obj)
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_ARTIFACTASSESSMENT}
  else if SameText(type_, 'ArtifactAssessment') then
    result := parseArtifactAssessment(obj)
{$ENDIF FHIR_ARTIFACTASSESSMENT}
{$IFDEF FHIR_AUDITEVENT}
  else if SameText(type_, 'AuditEvent') then
    result := parseAuditEvent(obj)
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  else if SameText(type_, 'Basic') then
    result := parseBasic(obj)
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  else if SameText(type_, 'Binary') then
    result := parseBinary(obj)
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
  else if SameText(type_, 'BiologicallyDerivedProduct') then
    result := parseBiologicallyDerivedProduct(obj)
{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
  else if SameText(type_, 'BodyStructure') then
    result := parseBodyStructure(obj)
{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_BUNDLE}
  else if SameText(type_, 'Bundle') then
    result := parseBundle(obj)
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
  else if SameText(type_, 'CapabilityStatement') then
    result := parseCapabilityStatement(obj)
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
  else if SameText(type_, 'CarePlan') then
    result := parseCarePlan(obj)
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
  else if SameText(type_, 'CareTeam') then
    result := parseCareTeam(obj)
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CHARGEITEM}
  else if SameText(type_, 'ChargeItem') then
    result := parseChargeItem(obj)
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
  else if SameText(type_, 'ChargeItemDefinition') then
    result := parseChargeItemDefinition(obj)
{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CITATION}
  else if SameText(type_, 'Citation') then
    result := parseCitation(obj)
{$ENDIF FHIR_CITATION}
{$IFDEF FHIR_CLAIM}
  else if SameText(type_, 'Claim') then
    result := parseClaim(obj)
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  else if SameText(type_, 'ClaimResponse') then
    result := parseClaimResponse(obj)
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  else if SameText(type_, 'ClinicalImpression') then
    result := parseClinicalImpression(obj)
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CLINICALUSEDEFINITION}
  else if SameText(type_, 'ClinicalUseDefinition') then
    result := parseClinicalUseDefinition(obj)
{$ENDIF FHIR_CLINICALUSEDEFINITION}
{$IFDEF FHIR_CODESYSTEM}
  else if SameText(type_, 'CodeSystem') then
    result := parseCodeSystem(obj)
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
  else if SameText(type_, 'Communication') then
    result := parseCommunication(obj)
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  else if SameText(type_, 'CommunicationRequest') then
    result := parseCommunicationRequest(obj)
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
  else if SameText(type_, 'CompartmentDefinition') then
    result := parseCompartmentDefinition(obj)
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
  else if SameText(type_, 'Composition') then
    result := parseComposition(obj)
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  else if SameText(type_, 'ConceptMap') then
    result := parseConceptMap(obj)
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  else if SameText(type_, 'Condition') then
    result := parseCondition(obj)
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONDITIONDEFINITION}
  else if SameText(type_, 'ConditionDefinition') then
    result := parseConditionDefinition(obj)
{$ENDIF FHIR_CONDITIONDEFINITION}
{$IFDEF FHIR_CONSENT}
  else if SameText(type_, 'Consent') then
    result := parseConsent(obj)
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
  else if SameText(type_, 'Contract') then
    result := parseContract(obj)
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  else if SameText(type_, 'Coverage') then
    result := parseCoverage(obj)
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
  else if SameText(type_, 'CoverageEligibilityRequest') then
    result := parseCoverageEligibilityRequest(obj)
{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
  else if SameText(type_, 'CoverageEligibilityResponse') then
    result := parseCoverageEligibilityResponse(obj)
{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_DETECTEDISSUE}
  else if SameText(type_, 'DetectedIssue') then
    result := parseDetectedIssue(obj)
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  else if SameText(type_, 'Device') then
    result := parseDevice(obj)
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
  else if SameText(type_, 'DeviceDefinition') then
    result := parseDeviceDefinition(obj)
{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEDISPENSE}
  else if SameText(type_, 'DeviceDispense') then
    result := parseDeviceDispense(obj)
{$ENDIF FHIR_DEVICEDISPENSE}
{$IFDEF FHIR_DEVICEMETRIC}
  else if SameText(type_, 'DeviceMetric') then
    result := parseDeviceMetric(obj)
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
  else if SameText(type_, 'DeviceRequest') then
    result := parseDeviceRequest(obj)
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSAGE}
  else if SameText(type_, 'DeviceUsage') then
    result := parseDeviceUsage(obj)
{$ENDIF FHIR_DEVICEUSAGE}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  else if SameText(type_, 'DiagnosticReport') then
    result := parseDiagnosticReport(obj)
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  else if SameText(type_, 'DocumentManifest') then
    result := parseDocumentManifest(obj)
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  else if SameText(type_, 'DocumentReference') then
    result := parseDocumentReference(obj)
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ENCOUNTER}
  else if SameText(type_, 'Encounter') then
    result := parseEncounter(obj)
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
  else if SameText(type_, 'Endpoint') then
    result := parseEndpoint(obj)
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  else if SameText(type_, 'EnrollmentRequest') then
    result := parseEnrollmentRequest(obj)
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  else if SameText(type_, 'EnrollmentResponse') then
    result := parseEnrollmentResponse(obj)
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  else if SameText(type_, 'EpisodeOfCare') then
    result := parseEpisodeOfCare(obj)
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EVENTDEFINITION}
  else if SameText(type_, 'EventDefinition') then
    result := parseEventDefinition(obj)
{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EVIDENCE}
  else if SameText(type_, 'Evidence') then
    result := parseEvidence(obj)
{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEREPORT}
  else if SameText(type_, 'EvidenceReport') then
    result := parseEvidenceReport(obj)
{$ENDIF FHIR_EVIDENCEREPORT}
{$IFDEF FHIR_EVIDENCEVARIABLE}
  else if SameText(type_, 'EvidenceVariable') then
    result := parseEvidenceVariable(obj)
{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_EXAMPLESCENARIO}
  else if SameText(type_, 'ExampleScenario') then
    result := parseExampleScenario(obj)
{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  else if SameText(type_, 'ExplanationOfBenefit') then
    result := parseExplanationOfBenefit(obj)
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  else if SameText(type_, 'FamilyMemberHistory') then
    result := parseFamilyMemberHistory(obj)
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  else if SameText(type_, 'Flag') then
    result := parseFlag(obj)
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_FORMULARYITEM}
  else if SameText(type_, 'FormularyItem') then
    result := parseFormularyItem(obj)
{$ENDIF FHIR_FORMULARYITEM}
{$IFDEF FHIR_GENOMICSTUDY}
  else if SameText(type_, 'GenomicStudy') then
    result := parseGenomicStudy(obj)
{$ENDIF FHIR_GENOMICSTUDY}
{$IFDEF FHIR_GOAL}
  else if SameText(type_, 'Goal') then
    result := parseGoal(obj)
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
  else if SameText(type_, 'GraphDefinition') then
    result := parseGraphDefinition(obj)
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
  else if SameText(type_, 'Group') then
    result := parseGroup(obj)
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
  else if SameText(type_, 'GuidanceResponse') then
    result := parseGuidanceResponse(obj)
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
  else if SameText(type_, 'HealthcareService') then
    result := parseHealthcareService(obj)
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGSELECTION}
  else if SameText(type_, 'ImagingSelection') then
    result := parseImagingSelection(obj)
{$ENDIF FHIR_IMAGINGSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
  else if SameText(type_, 'ImagingStudy') then
    result := parseImagingStudy(obj)
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  else if SameText(type_, 'Immunization') then
    result := parseImmunization(obj)
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
  else if SameText(type_, 'ImmunizationEvaluation') then
    result := parseImmunizationEvaluation(obj)
{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  else if SameText(type_, 'ImmunizationRecommendation') then
    result := parseImmunizationRecommendation(obj)
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  else if SameText(type_, 'ImplementationGuide') then
    result := parseImplementationGuide(obj)
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_INGREDIENT}
  else if SameText(type_, 'Ingredient') then
    result := parseIngredient(obj)
{$ENDIF FHIR_INGREDIENT}
{$IFDEF FHIR_INSURANCEPLAN}
  else if SameText(type_, 'InsurancePlan') then
    result := parseInsurancePlan(obj)
{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVENTORYREPORT}
  else if SameText(type_, 'InventoryReport') then
    result := parseInventoryReport(obj)
{$ENDIF FHIR_INVENTORYREPORT}
{$IFDEF FHIR_INVOICE}
  else if SameText(type_, 'Invoice') then
    result := parseInvoice(obj)
{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_LIBRARY}
  else if SameText(type_, 'Library') then
    result := parseLibrary(obj)
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
  else if SameText(type_, 'Linkage') then
    result := parseLinkage(obj)
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
  else if SameText(type_, 'List') then
    result := parseList(obj)
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  else if SameText(type_, 'Location') then
    result := parseLocation(obj)
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MANUFACTUREDITEMDEFINITION}
  else if SameText(type_, 'ManufacturedItemDefinition') then
    result := parseManufacturedItemDefinition(obj)
{$ENDIF FHIR_MANUFACTUREDITEMDEFINITION}
{$IFDEF FHIR_MEASURE}
  else if SameText(type_, 'Measure') then
    result := parseMeasure(obj)
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
  else if SameText(type_, 'MeasureReport') then
    result := parseMeasureReport(obj)
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDICATION}
  else if SameText(type_, 'Medication') then
    result := parseMedication(obj)
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  else if SameText(type_, 'MedicationAdministration') then
    result := parseMedicationAdministration(obj)
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  else if SameText(type_, 'MedicationDispense') then
    result := parseMedicationDispense(obj)
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
  else if SameText(type_, 'MedicationKnowledge') then
    result := parseMedicationKnowledge(obj)
{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICATIONREQUEST}
  else if SameText(type_, 'MedicationRequest') then
    result := parseMedicationRequest(obj)
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONUSAGE}
  else if SameText(type_, 'MedicationUsage') then
    result := parseMedicationUsage(obj)
{$ENDIF FHIR_MEDICATIONUSAGE}
{$IFDEF FHIR_MEDICINALPRODUCTDEFINITION}
  else if SameText(type_, 'MedicinalProductDefinition') then
    result := parseMedicinalProductDefinition(obj)
{$ENDIF FHIR_MEDICINALPRODUCTDEFINITION}
{$IFDEF FHIR_MESSAGEDEFINITION}
  else if SameText(type_, 'MessageDefinition') then
    result := parseMessageDefinition(obj)
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
  else if SameText(type_, 'MessageHeader') then
    result := parseMessageHeader(obj)
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_MOLECULARSEQUENCE}
  else if SameText(type_, 'MolecularSequence') then
    result := parseMolecularSequence(obj)
{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NAMINGSYSTEM}
  else if SameText(type_, 'NamingSystem') then
    result := parseNamingSystem(obj)
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONINTAKE}
  else if SameText(type_, 'NutritionIntake') then
    result := parseNutritionIntake(obj)
{$ENDIF FHIR_NUTRITIONINTAKE}
{$IFDEF FHIR_NUTRITIONORDER}
  else if SameText(type_, 'NutritionOrder') then
    result := parseNutritionOrder(obj)
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_NUTRITIONPRODUCT}
  else if SameText(type_, 'NutritionProduct') then
    result := parseNutritionProduct(obj)
{$ENDIF FHIR_NUTRITIONPRODUCT}
{$IFDEF FHIR_OBSERVATION}
  else if SameText(type_, 'Observation') then
    result := parseObservation(obj)
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
  else if SameText(type_, 'ObservationDefinition') then
    result := parseObservationDefinition(obj)
{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  else if SameText(type_, 'OperationDefinition') then
    result := parseOperationDefinition(obj)
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  else if SameText(type_, 'OperationOutcome') then
    result := parseOperationOutcome(obj)
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
  else if SameText(type_, 'Organization') then
    result := parseOrganization(obj)
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
  else if SameText(type_, 'OrganizationAffiliation') then
    result := parseOrganizationAffiliation(obj)
{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PACKAGEDPRODUCTDEFINITION}
  else if SameText(type_, 'PackagedProductDefinition') then
    result := parsePackagedProductDefinition(obj)
{$ENDIF FHIR_PACKAGEDPRODUCTDEFINITION}
{$IFDEF FHIR_PARAMETERS}
  else if SameText(type_, 'Parameters') then
    result := parseParameters(obj)
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_PATIENT}
  else if SameText(type_, 'Patient') then
    result := parsePatient(obj)
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  else if SameText(type_, 'PaymentNotice') then
    result := parsePaymentNotice(obj)
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  else if SameText(type_, 'PaymentReconciliation') then
    result := parsePaymentReconciliation(obj)
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERMISSION}
  else if SameText(type_, 'Permission') then
    result := parsePermission(obj)
{$ENDIF FHIR_PERMISSION}
{$IFDEF FHIR_PERSON}
  else if SameText(type_, 'Person') then
    result := parsePerson(obj)
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
  else if SameText(type_, 'PlanDefinition') then
    result := parsePlanDefinition(obj)
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
  else if SameText(type_, 'Practitioner') then
    result := parsePractitioner(obj)
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
  else if SameText(type_, 'PractitionerRole') then
    result := parsePractitionerRole(obj)
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
  else if SameText(type_, 'Procedure') then
    result := parseProcedure(obj)
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROVENANCE}
  else if SameText(type_, 'Provenance') then
    result := parseProvenance(obj)
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  else if SameText(type_, 'Questionnaire') then
    result := parseQuestionnaire(obj)
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  else if SameText(type_, 'QuestionnaireResponse') then
    result := parseQuestionnaireResponse(obj)
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REGULATEDAUTHORIZATION}
  else if SameText(type_, 'RegulatedAuthorization') then
    result := parseRegulatedAuthorization(obj)
{$ENDIF FHIR_REGULATEDAUTHORIZATION}
{$IFDEF FHIR_RELATEDPERSON}
  else if SameText(type_, 'RelatedPerson') then
    result := parseRelatedPerson(obj)
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
  else if SameText(type_, 'RequestGroup') then
    result := parseRequestGroup(obj)
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_REQUESTORCHESTRATION}
  else if SameText(type_, 'RequestOrchestration') then
    result := parseRequestOrchestration(obj)
{$ENDIF FHIR_REQUESTORCHESTRATION}
{$IFDEF FHIR_REQUIREMENTS}
  else if SameText(type_, 'Requirements') then
    result := parseRequirements(obj)
{$ENDIF FHIR_REQUIREMENTS}
{$IFDEF FHIR_RESEARCHSTUDY}
  else if SameText(type_, 'ResearchStudy') then
    result := parseResearchStudy(obj)
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
  else if SameText(type_, 'ResearchSubject') then
    result := parseResearchSubject(obj)
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
  else if SameText(type_, 'RiskAssessment') then
    result := parseRiskAssessment(obj)
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
  else if SameText(type_, 'Schedule') then
    result := parseSchedule(obj)
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  else if SameText(type_, 'SearchParameter') then
    result := parseSearchParameter(obj)
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEREQUEST}
  else if SameText(type_, 'ServiceRequest') then
    result := parseServiceRequest(obj)
{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SLOT}
  else if SameText(type_, 'Slot') then
    result := parseSlot(obj)
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  else if SameText(type_, 'Specimen') then
    result := parseSpecimen(obj)
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SPECIMENDEFINITION}
  else if SameText(type_, 'SpecimenDefinition') then
    result := parseSpecimenDefinition(obj)
{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  else if SameText(type_, 'StructureDefinition') then
    result := parseStructureDefinition(obj)
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
  else if SameText(type_, 'StructureMap') then
    result := parseStructureMap(obj)
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
  else if SameText(type_, 'Subscription') then
    result := parseSubscription(obj)
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSCRIPTIONSTATUS}
  else if SameText(type_, 'SubscriptionStatus') then
    result := parseSubscriptionStatus(obj)
{$ENDIF FHIR_SUBSCRIPTIONSTATUS}
{$IFDEF FHIR_SUBSCRIPTIONTOPIC}
  else if SameText(type_, 'SubscriptionTopic') then
    result := parseSubscriptionTopic(obj)
{$ENDIF FHIR_SUBSCRIPTIONTOPIC}
{$IFDEF FHIR_SUBSTANCE}
  else if SameText(type_, 'Substance') then
    result := parseSubstance(obj)
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCEDEFINITION}
  else if SameText(type_, 'SubstanceDefinition') then
    result := parseSubstanceDefinition(obj)
{$ENDIF FHIR_SUBSTANCEDEFINITION}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
  else if SameText(type_, 'SubstanceNucleicAcid') then
    result := parseSubstanceNucleicAcid(obj)
{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
  else if SameText(type_, 'SubstancePolymer') then
    result := parseSubstancePolymer(obj)
{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
  else if SameText(type_, 'SubstanceProtein') then
    result := parseSubstanceProtein(obj)
{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
  else if SameText(type_, 'SubstanceReferenceInformation') then
    result := parseSubstanceReferenceInformation(obj)
{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
  else if SameText(type_, 'SubstanceSourceMaterial') then
    result := parseSubstanceSourceMaterial(obj)
{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUPPLYDELIVERY}
  else if SameText(type_, 'SupplyDelivery') then
    result := parseSupplyDelivery(obj)
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  else if SameText(type_, 'SupplyRequest') then
    result := parseSupplyRequest(obj)
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
  else if SameText(type_, 'Task') then
    result := parseTask(obj)
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
  else if SameText(type_, 'TerminologyCapabilities') then
    result := parseTerminologyCapabilities(obj)
{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTREPORT}
  else if SameText(type_, 'TestReport') then
    result := parseTestReport(obj)
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
  else if SameText(type_, 'TestScript') then
    result := parseTestScript(obj)
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_TRANSPORT}
  else if SameText(type_, 'Transport') then
    result := parseTransport(obj)
{$ENDIF FHIR_TRANSPORT}
{$IFDEF FHIR_VALUESET}
  else if SameText(type_, 'ValueSet') then
    result := parseValueSet(obj)
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VERIFICATIONRESULT}
  else if SameText(type_, 'VerificationResult') then
    result := parseVerificationResult(obj)
{$ENDIF FHIR_VERIFICATIONRESULT}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  else if SameText(type_, 'VisionPrescription') then
    result := parseVisionPrescription(obj)
{$ENDIF FHIR_VISIONPRESCRIPTION}

  else
    raise ERdfException.create('error: the element '+type_+' is not a valid fragment name');
end;

function TFHIRTurtleParser.ParseDataType(obj : TTurtleComplex; name : String; type_ : TFHIRDataTypeClass) : TFHIRDataType;
begin
  if (obj = nil) then
    Raise ERdfException.Create('error - object is nil')
  else if (type_ = TFhirAddress) then
    result := parseAddress(obj)
  else if (type_ = TFhirAnnotation) then
    result := parseAnnotation(obj)
  else if (type_ = TFhirAttachment) then
    result := parseAttachment(obj)
  else if (type_ = TFhirAvailability) then
    result := parseAvailability(obj)
  else if (type_ = TFhirCodeableConcept) then
    result := parseCodeableConcept(obj)
  else if (type_ = TFhirCodeableReference) then
    result := parseCodeableReference(obj)
  else if (type_ = TFhirCoding) then
    result := parseCoding(obj)
  else if (type_ = TFhirContactDetail) then
    result := parseContactDetail(obj)
  else if (type_ = TFhirContactPoint) then
    result := parseContactPoint(obj)
  else if (type_ = TFhirContributor) then
    result := parseContributor(obj)
  else if (type_ = TFhirDataRequirement) then
    result := parseDataRequirement(obj)
  else if (type_ = TFhirExpression) then
    result := parseExpression(obj)
  else if (type_ = TFhirExtendedContactDetail) then
    result := parseExtendedContactDetail(obj)
  else if (type_ = TFhirExtension) then
    result := parseExtension(obj)
  else if (type_ = TFhirHumanName) then
    result := parseHumanName(obj)
  else if (type_ = TFhirIdentifier) then
    result := parseIdentifier(obj)
  else if (type_ = TFhirMeta) then
    result := parseMeta(obj)
  else if (type_ = TFhirMonetaryComponent) then
    result := parseMonetaryComponent(obj)
  else if (type_ = TFhirMoney) then
    result := parseMoney(obj)
  else if (type_ = TFhirNarrative) then
    result := parseNarrative(obj)
  else if (type_ = TFhirParameterDefinition) then
    result := parseParameterDefinition(obj)
  else if (type_ = TFhirPeriod) then
    result := parsePeriod(obj)
  else if (type_ = TFhirQuantity) then
    result := parseQuantity(obj)
  else if (type_ = TFhirRange) then
    result := parseRange(obj)
  else if (type_ = TFhirRatio) then
    result := parseRatio(obj)
  else if (type_ = TFhirRatioRange) then
    result := parseRatioRange(obj)
  else if (type_ = TFhirReference) then
    result := parseReference(obj)
  else if (type_ = TFhirRelatedArtifact) then
    result := parseRelatedArtifact(obj)
  else if (type_ = TFhirSampledData) then
    result := parseSampledData(obj)
  else if (type_ = TFhirSignature) then
    result := parseSignature(obj)
  else if (type_ = TFhirTriggerDefinition) then
    result := parseTriggerDefinition(obj)
  else if (type_ = TFhirUsageContext) then
    result := parseUsageContext(obj)
  else if (type_ = TFhirVirtualServiceDetail) then
    result := parseVirtualServiceDetail(obj)
  else if (type_ = TFhirAge) then
    result := parseAge(obj)
  else if (type_ = TFhirCount) then
    result := parseCount(obj)
  else if (type_ = TFhirDistance) then
    result := parseDistance(obj)
  else if (type_ = TFhirDosage) then
    result := parseDosage(obj)
  else if (type_ = TFhirDuration) then
    result := parseDuration(obj)
  else if (type_ = TFhirElementDefinition) then
    result := parseElementDefinition(obj)
  else if (type_ = TFhirMarketingStatus) then
    result := parseMarketingStatus(obj)
  else if (type_ = TFhirPopulation) then
    result := parsePopulation(obj)
  else if (type_ = TFhirProductShelfLife) then
    result := parseProductShelfLife(obj)
  else if (type_ = TFhirTiming) then
    result := parseTiming(obj)

  else
    raise ERdfException.create('Unknown Type');
end;

procedure TFHIRTurtleComposer.ComposeResource(parent : TTurtleComplex; resource : TFhirResource);
var
  this : TTurtleComplex;
begin
  if (resource = nil) Then
    Raise ERdfException.Create('error - resource is nil');
  this := parent;
  Case resource.ResourceType of
{$IFDEF FHIR_ACCOUNT}
    frtAccount: ComposeAccount(this, '', 'Account', TFhirAccount(resource), true, -1);
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
    frtActivityDefinition: ComposeActivityDefinition(this, '', 'ActivityDefinition', TFhirActivityDefinition(resource), true, -1);
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ACTORDEFINITION}
    frtActorDefinition: ComposeActorDefinition(this, '', 'ActorDefinition', TFhirActorDefinition(resource), true, -1);
{$ENDIF FHIR_ACTORDEFINITION}
{$IFDEF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
    frtAdministrableProductDefinition: ComposeAdministrableProductDefinition(this, '', 'AdministrableProductDefinition', TFhirAdministrableProductDefinition(resource), true, -1);
{$ENDIF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
    frtAdverseEvent: ComposeAdverseEvent(this, '', 'AdverseEvent', TFhirAdverseEvent(resource), true, -1);
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
    frtAllergyIntolerance: ComposeAllergyIntolerance(this, '', 'AllergyIntolerance', TFhirAllergyIntolerance(resource), true, -1);
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
    frtAppointment: ComposeAppointment(this, '', 'Appointment', TFhirAppointment(resource), true, -1);
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
    frtAppointmentResponse: ComposeAppointmentResponse(this, '', 'AppointmentResponse', TFhirAppointmentResponse(resource), true, -1);
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_ARTIFACTASSESSMENT}
    frtArtifactAssessment: ComposeArtifactAssessment(this, '', 'ArtifactAssessment', TFhirArtifactAssessment(resource), true, -1);
{$ENDIF FHIR_ARTIFACTASSESSMENT}
{$IFDEF FHIR_AUDITEVENT}
    frtAuditEvent: ComposeAuditEvent(this, '', 'AuditEvent', TFhirAuditEvent(resource), true, -1);
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
    frtBasic: ComposeBasic(this, '', 'Basic', TFhirBasic(resource), true, -1);
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
    frtBinary: ComposeBinary(this, '', 'Binary', TFhirBinary(resource), true, -1);
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
    frtBiologicallyDerivedProduct: ComposeBiologicallyDerivedProduct(this, '', 'BiologicallyDerivedProduct', TFhirBiologicallyDerivedProduct(resource), true, -1);
{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
    frtBodyStructure: ComposeBodyStructure(this, '', 'BodyStructure', TFhirBodyStructure(resource), true, -1);
{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_BUNDLE}
    frtBundle: ComposeBundle(this, '', 'Bundle', TFhirBundle(resource), true, -1);
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
    frtCapabilityStatement: ComposeCapabilityStatement(this, '', 'CapabilityStatement', TFhirCapabilityStatement(resource), true, -1);
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
    frtCarePlan: ComposeCarePlan(this, '', 'CarePlan', TFhirCarePlan(resource), true, -1);
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
    frtCareTeam: ComposeCareTeam(this, '', 'CareTeam', TFhirCareTeam(resource), true, -1);
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CHARGEITEM}
    frtChargeItem: ComposeChargeItem(this, '', 'ChargeItem', TFhirChargeItem(resource), true, -1);
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
    frtChargeItemDefinition: ComposeChargeItemDefinition(this, '', 'ChargeItemDefinition', TFhirChargeItemDefinition(resource), true, -1);
{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CITATION}
    frtCitation: ComposeCitation(this, '', 'Citation', TFhirCitation(resource), true, -1);
{$ENDIF FHIR_CITATION}
{$IFDEF FHIR_CLAIM}
    frtClaim: ComposeClaim(this, '', 'Claim', TFhirClaim(resource), true, -1);
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
    frtClaimResponse: ComposeClaimResponse(this, '', 'ClaimResponse', TFhirClaimResponse(resource), true, -1);
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
    frtClinicalImpression: ComposeClinicalImpression(this, '', 'ClinicalImpression', TFhirClinicalImpression(resource), true, -1);
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CLINICALUSEDEFINITION}
    frtClinicalUseDefinition: ComposeClinicalUseDefinition(this, '', 'ClinicalUseDefinition', TFhirClinicalUseDefinition(resource), true, -1);
{$ENDIF FHIR_CLINICALUSEDEFINITION}
{$IFDEF FHIR_CODESYSTEM}
    frtCodeSystem: ComposeCodeSystem(this, '', 'CodeSystem', TFhirCodeSystem(resource), true, -1);
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
    frtCommunication: ComposeCommunication(this, '', 'Communication', TFhirCommunication(resource), true, -1);
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
    frtCommunicationRequest: ComposeCommunicationRequest(this, '', 'CommunicationRequest', TFhirCommunicationRequest(resource), true, -1);
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
    frtCompartmentDefinition: ComposeCompartmentDefinition(this, '', 'CompartmentDefinition', TFhirCompartmentDefinition(resource), true, -1);
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
    frtComposition: ComposeComposition(this, '', 'Composition', TFhirComposition(resource), true, -1);
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
    frtConceptMap: ComposeConceptMap(this, '', 'ConceptMap', TFhirConceptMap(resource), true, -1);
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
    frtCondition: ComposeCondition(this, '', 'Condition', TFhirCondition(resource), true, -1);
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONDITIONDEFINITION}
    frtConditionDefinition: ComposeConditionDefinition(this, '', 'ConditionDefinition', TFhirConditionDefinition(resource), true, -1);
{$ENDIF FHIR_CONDITIONDEFINITION}
{$IFDEF FHIR_CONSENT}
    frtConsent: ComposeConsent(this, '', 'Consent', TFhirConsent(resource), true, -1);
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
    frtContract: ComposeContract(this, '', 'Contract', TFhirContract(resource), true, -1);
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
    frtCoverage: ComposeCoverage(this, '', 'Coverage', TFhirCoverage(resource), true, -1);
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
    frtCoverageEligibilityRequest: ComposeCoverageEligibilityRequest(this, '', 'CoverageEligibilityRequest', TFhirCoverageEligibilityRequest(resource), true, -1);
{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
    frtCoverageEligibilityResponse: ComposeCoverageEligibilityResponse(this, '', 'CoverageEligibilityResponse', TFhirCoverageEligibilityResponse(resource), true, -1);
{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_DETECTEDISSUE}
    frtDetectedIssue: ComposeDetectedIssue(this, '', 'DetectedIssue', TFhirDetectedIssue(resource), true, -1);
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
    frtDevice: ComposeDevice(this, '', 'Device', TFhirDevice(resource), true, -1);
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
    frtDeviceDefinition: ComposeDeviceDefinition(this, '', 'DeviceDefinition', TFhirDeviceDefinition(resource), true, -1);
{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEDISPENSE}
    frtDeviceDispense: ComposeDeviceDispense(this, '', 'DeviceDispense', TFhirDeviceDispense(resource), true, -1);
{$ENDIF FHIR_DEVICEDISPENSE}
{$IFDEF FHIR_DEVICEMETRIC}
    frtDeviceMetric: ComposeDeviceMetric(this, '', 'DeviceMetric', TFhirDeviceMetric(resource), true, -1);
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
    frtDeviceRequest: ComposeDeviceRequest(this, '', 'DeviceRequest', TFhirDeviceRequest(resource), true, -1);
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSAGE}
    frtDeviceUsage: ComposeDeviceUsage(this, '', 'DeviceUsage', TFhirDeviceUsage(resource), true, -1);
{$ENDIF FHIR_DEVICEUSAGE}
{$IFDEF FHIR_DIAGNOSTICREPORT}
    frtDiagnosticReport: ComposeDiagnosticReport(this, '', 'DiagnosticReport', TFhirDiagnosticReport(resource), true, -1);
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
    frtDocumentManifest: ComposeDocumentManifest(this, '', 'DocumentManifest', TFhirDocumentManifest(resource), true, -1);
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
    frtDocumentReference: ComposeDocumentReference(this, '', 'DocumentReference', TFhirDocumentReference(resource), true, -1);
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ENCOUNTER}
    frtEncounter: ComposeEncounter(this, '', 'Encounter', TFhirEncounter(resource), true, -1);
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
    frtEndpoint: ComposeEndpoint(this, '', 'Endpoint', TFhirEndpoint(resource), true, -1);
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
    frtEnrollmentRequest: ComposeEnrollmentRequest(this, '', 'EnrollmentRequest', TFhirEnrollmentRequest(resource), true, -1);
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
    frtEnrollmentResponse: ComposeEnrollmentResponse(this, '', 'EnrollmentResponse', TFhirEnrollmentResponse(resource), true, -1);
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
    frtEpisodeOfCare: ComposeEpisodeOfCare(this, '', 'EpisodeOfCare', TFhirEpisodeOfCare(resource), true, -1);
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EVENTDEFINITION}
    frtEventDefinition: ComposeEventDefinition(this, '', 'EventDefinition', TFhirEventDefinition(resource), true, -1);
{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EVIDENCE}
    frtEvidence: ComposeEvidence(this, '', 'Evidence', TFhirEvidence(resource), true, -1);
{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEREPORT}
    frtEvidenceReport: ComposeEvidenceReport(this, '', 'EvidenceReport', TFhirEvidenceReport(resource), true, -1);
{$ENDIF FHIR_EVIDENCEREPORT}
{$IFDEF FHIR_EVIDENCEVARIABLE}
    frtEvidenceVariable: ComposeEvidenceVariable(this, '', 'EvidenceVariable', TFhirEvidenceVariable(resource), true, -1);
{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_EXAMPLESCENARIO}
    frtExampleScenario: ComposeExampleScenario(this, '', 'ExampleScenario', TFhirExampleScenario(resource), true, -1);
{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
    frtExplanationOfBenefit: ComposeExplanationOfBenefit(this, '', 'ExplanationOfBenefit', TFhirExplanationOfBenefit(resource), true, -1);
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
    frtFamilyMemberHistory: ComposeFamilyMemberHistory(this, '', 'FamilyMemberHistory', TFhirFamilyMemberHistory(resource), true, -1);
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
    frtFlag: ComposeFlag(this, '', 'Flag', TFhirFlag(resource), true, -1);
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_FORMULARYITEM}
    frtFormularyItem: ComposeFormularyItem(this, '', 'FormularyItem', TFhirFormularyItem(resource), true, -1);
{$ENDIF FHIR_FORMULARYITEM}
{$IFDEF FHIR_GENOMICSTUDY}
    frtGenomicStudy: ComposeGenomicStudy(this, '', 'GenomicStudy', TFhirGenomicStudy(resource), true, -1);
{$ENDIF FHIR_GENOMICSTUDY}
{$IFDEF FHIR_GOAL}
    frtGoal: ComposeGoal(this, '', 'Goal', TFhirGoal(resource), true, -1);
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
    frtGraphDefinition: ComposeGraphDefinition(this, '', 'GraphDefinition', TFhirGraphDefinition(resource), true, -1);
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
    frtGroup: ComposeGroup(this, '', 'Group', TFhirGroup(resource), true, -1);
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
    frtGuidanceResponse: ComposeGuidanceResponse(this, '', 'GuidanceResponse', TFhirGuidanceResponse(resource), true, -1);
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
    frtHealthcareService: ComposeHealthcareService(this, '', 'HealthcareService', TFhirHealthcareService(resource), true, -1);
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGSELECTION}
    frtImagingSelection: ComposeImagingSelection(this, '', 'ImagingSelection', TFhirImagingSelection(resource), true, -1);
{$ENDIF FHIR_IMAGINGSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
    frtImagingStudy: ComposeImagingStudy(this, '', 'ImagingStudy', TFhirImagingStudy(resource), true, -1);
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
    frtImmunization: ComposeImmunization(this, '', 'Immunization', TFhirImmunization(resource), true, -1);
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
    frtImmunizationEvaluation: ComposeImmunizationEvaluation(this, '', 'ImmunizationEvaluation', TFhirImmunizationEvaluation(resource), true, -1);
{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
    frtImmunizationRecommendation: ComposeImmunizationRecommendation(this, '', 'ImmunizationRecommendation', TFhirImmunizationRecommendation(resource), true, -1);
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
    frtImplementationGuide: ComposeImplementationGuide(this, '', 'ImplementationGuide', TFhirImplementationGuide(resource), true, -1);
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_INGREDIENT}
    frtIngredient: ComposeIngredient(this, '', 'Ingredient', TFhirIngredient(resource), true, -1);
{$ENDIF FHIR_INGREDIENT}
{$IFDEF FHIR_INSURANCEPLAN}
    frtInsurancePlan: ComposeInsurancePlan(this, '', 'InsurancePlan', TFhirInsurancePlan(resource), true, -1);
{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVENTORYREPORT}
    frtInventoryReport: ComposeInventoryReport(this, '', 'InventoryReport', TFhirInventoryReport(resource), true, -1);
{$ENDIF FHIR_INVENTORYREPORT}
{$IFDEF FHIR_INVOICE}
    frtInvoice: ComposeInvoice(this, '', 'Invoice', TFhirInvoice(resource), true, -1);
{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_LIBRARY}
    frtLibrary: ComposeLibrary(this, '', 'Library', TFhirLibrary(resource), true, -1);
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
    frtLinkage: ComposeLinkage(this, '', 'Linkage', TFhirLinkage(resource), true, -1);
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
    frtList: ComposeList(this, '', 'List', TFhirList(resource), true, -1);
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
    frtLocation: ComposeLocation(this, '', 'Location', TFhirLocation(resource), true, -1);
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MANUFACTUREDITEMDEFINITION}
    frtManufacturedItemDefinition: ComposeManufacturedItemDefinition(this, '', 'ManufacturedItemDefinition', TFhirManufacturedItemDefinition(resource), true, -1);
{$ENDIF FHIR_MANUFACTUREDITEMDEFINITION}
{$IFDEF FHIR_MEASURE}
    frtMeasure: ComposeMeasure(this, '', 'Measure', TFhirMeasure(resource), true, -1);
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
    frtMeasureReport: ComposeMeasureReport(this, '', 'MeasureReport', TFhirMeasureReport(resource), true, -1);
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDICATION}
    frtMedication: ComposeMedication(this, '', 'Medication', TFhirMedication(resource), true, -1);
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
    frtMedicationAdministration: ComposeMedicationAdministration(this, '', 'MedicationAdministration', TFhirMedicationAdministration(resource), true, -1);
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
    frtMedicationDispense: ComposeMedicationDispense(this, '', 'MedicationDispense', TFhirMedicationDispense(resource), true, -1);
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
    frtMedicationKnowledge: ComposeMedicationKnowledge(this, '', 'MedicationKnowledge', TFhirMedicationKnowledge(resource), true, -1);
{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICATIONREQUEST}
    frtMedicationRequest: ComposeMedicationRequest(this, '', 'MedicationRequest', TFhirMedicationRequest(resource), true, -1);
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONUSAGE}
    frtMedicationUsage: ComposeMedicationUsage(this, '', 'MedicationUsage', TFhirMedicationUsage(resource), true, -1);
{$ENDIF FHIR_MEDICATIONUSAGE}
{$IFDEF FHIR_MEDICINALPRODUCTDEFINITION}
    frtMedicinalProductDefinition: ComposeMedicinalProductDefinition(this, '', 'MedicinalProductDefinition', TFhirMedicinalProductDefinition(resource), true, -1);
{$ENDIF FHIR_MEDICINALPRODUCTDEFINITION}
{$IFDEF FHIR_MESSAGEDEFINITION}
    frtMessageDefinition: ComposeMessageDefinition(this, '', 'MessageDefinition', TFhirMessageDefinition(resource), true, -1);
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
    frtMessageHeader: ComposeMessageHeader(this, '', 'MessageHeader', TFhirMessageHeader(resource), true, -1);
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_MOLECULARSEQUENCE}
    frtMolecularSequence: ComposeMolecularSequence(this, '', 'MolecularSequence', TFhirMolecularSequence(resource), true, -1);
{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NAMINGSYSTEM}
    frtNamingSystem: ComposeNamingSystem(this, '', 'NamingSystem', TFhirNamingSystem(resource), true, -1);
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONINTAKE}
    frtNutritionIntake: ComposeNutritionIntake(this, '', 'NutritionIntake', TFhirNutritionIntake(resource), true, -1);
{$ENDIF FHIR_NUTRITIONINTAKE}
{$IFDEF FHIR_NUTRITIONORDER}
    frtNutritionOrder: ComposeNutritionOrder(this, '', 'NutritionOrder', TFhirNutritionOrder(resource), true, -1);
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_NUTRITIONPRODUCT}
    frtNutritionProduct: ComposeNutritionProduct(this, '', 'NutritionProduct', TFhirNutritionProduct(resource), true, -1);
{$ENDIF FHIR_NUTRITIONPRODUCT}
{$IFDEF FHIR_OBSERVATION}
    frtObservation: ComposeObservation(this, '', 'Observation', TFhirObservation(resource), true, -1);
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
    frtObservationDefinition: ComposeObservationDefinition(this, '', 'ObservationDefinition', TFhirObservationDefinition(resource), true, -1);
{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
    frtOperationDefinition: ComposeOperationDefinition(this, '', 'OperationDefinition', TFhirOperationDefinition(resource), true, -1);
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
    frtOperationOutcome: ComposeOperationOutcome(this, '', 'OperationOutcome', TFhirOperationOutcome(resource), true, -1);
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
    frtOrganization: ComposeOrganization(this, '', 'Organization', TFhirOrganization(resource), true, -1);
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
    frtOrganizationAffiliation: ComposeOrganizationAffiliation(this, '', 'OrganizationAffiliation', TFhirOrganizationAffiliation(resource), true, -1);
{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PACKAGEDPRODUCTDEFINITION}
    frtPackagedProductDefinition: ComposePackagedProductDefinition(this, '', 'PackagedProductDefinition', TFhirPackagedProductDefinition(resource), true, -1);
{$ENDIF FHIR_PACKAGEDPRODUCTDEFINITION}
{$IFDEF FHIR_PARAMETERS}
    frtParameters: ComposeParameters(this, '', 'Parameters', TFhirParameters(resource), true, -1);
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_PATIENT}
    frtPatient: ComposePatient(this, '', 'Patient', TFhirPatient(resource), true, -1);
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
    frtPaymentNotice: ComposePaymentNotice(this, '', 'PaymentNotice', TFhirPaymentNotice(resource), true, -1);
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
    frtPaymentReconciliation: ComposePaymentReconciliation(this, '', 'PaymentReconciliation', TFhirPaymentReconciliation(resource), true, -1);
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERMISSION}
    frtPermission: ComposePermission(this, '', 'Permission', TFhirPermission(resource), true, -1);
{$ENDIF FHIR_PERMISSION}
{$IFDEF FHIR_PERSON}
    frtPerson: ComposePerson(this, '', 'Person', TFhirPerson(resource), true, -1);
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
    frtPlanDefinition: ComposePlanDefinition(this, '', 'PlanDefinition', TFhirPlanDefinition(resource), true, -1);
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
    frtPractitioner: ComposePractitioner(this, '', 'Practitioner', TFhirPractitioner(resource), true, -1);
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
    frtPractitionerRole: ComposePractitionerRole(this, '', 'PractitionerRole', TFhirPractitionerRole(resource), true, -1);
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
    frtProcedure: ComposeProcedure(this, '', 'Procedure', TFhirProcedure(resource), true, -1);
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROVENANCE}
    frtProvenance: ComposeProvenance(this, '', 'Provenance', TFhirProvenance(resource), true, -1);
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
    frtQuestionnaire: ComposeQuestionnaire(this, '', 'Questionnaire', TFhirQuestionnaire(resource), true, -1);
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
    frtQuestionnaireResponse: ComposeQuestionnaireResponse(this, '', 'QuestionnaireResponse', TFhirQuestionnaireResponse(resource), true, -1);
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REGULATEDAUTHORIZATION}
    frtRegulatedAuthorization: ComposeRegulatedAuthorization(this, '', 'RegulatedAuthorization', TFhirRegulatedAuthorization(resource), true, -1);
{$ENDIF FHIR_REGULATEDAUTHORIZATION}
{$IFDEF FHIR_RELATEDPERSON}
    frtRelatedPerson: ComposeRelatedPerson(this, '', 'RelatedPerson', TFhirRelatedPerson(resource), true, -1);
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
    frtRequestGroup: ComposeRequestGroup(this, '', 'RequestGroup', TFhirRequestGroup(resource), true, -1);
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_REQUESTORCHESTRATION}
    frtRequestOrchestration: ComposeRequestOrchestration(this, '', 'RequestOrchestration', TFhirRequestOrchestration(resource), true, -1);
{$ENDIF FHIR_REQUESTORCHESTRATION}
{$IFDEF FHIR_REQUIREMENTS}
    frtRequirements: ComposeRequirements(this, '', 'Requirements', TFhirRequirements(resource), true, -1);
{$ENDIF FHIR_REQUIREMENTS}
{$IFDEF FHIR_RESEARCHSTUDY}
    frtResearchStudy: ComposeResearchStudy(this, '', 'ResearchStudy', TFhirResearchStudy(resource), true, -1);
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
    frtResearchSubject: ComposeResearchSubject(this, '', 'ResearchSubject', TFhirResearchSubject(resource), true, -1);
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
    frtRiskAssessment: ComposeRiskAssessment(this, '', 'RiskAssessment', TFhirRiskAssessment(resource), true, -1);
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
    frtSchedule: ComposeSchedule(this, '', 'Schedule', TFhirSchedule(resource), true, -1);
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
    frtSearchParameter: ComposeSearchParameter(this, '', 'SearchParameter', TFhirSearchParameter(resource), true, -1);
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEREQUEST}
    frtServiceRequest: ComposeServiceRequest(this, '', 'ServiceRequest', TFhirServiceRequest(resource), true, -1);
{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SLOT}
    frtSlot: ComposeSlot(this, '', 'Slot', TFhirSlot(resource), true, -1);
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
    frtSpecimen: ComposeSpecimen(this, '', 'Specimen', TFhirSpecimen(resource), true, -1);
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SPECIMENDEFINITION}
    frtSpecimenDefinition: ComposeSpecimenDefinition(this, '', 'SpecimenDefinition', TFhirSpecimenDefinition(resource), true, -1);
{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
    frtStructureDefinition: ComposeStructureDefinition(this, '', 'StructureDefinition', TFhirStructureDefinition(resource), true, -1);
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
    frtStructureMap: ComposeStructureMap(this, '', 'StructureMap', TFhirStructureMap(resource), true, -1);
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
    frtSubscription: ComposeSubscription(this, '', 'Subscription', TFhirSubscription(resource), true, -1);
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSCRIPTIONSTATUS}
    frtSubscriptionStatus: ComposeSubscriptionStatus(this, '', 'SubscriptionStatus', TFhirSubscriptionStatus(resource), true, -1);
{$ENDIF FHIR_SUBSCRIPTIONSTATUS}
{$IFDEF FHIR_SUBSCRIPTIONTOPIC}
    frtSubscriptionTopic: ComposeSubscriptionTopic(this, '', 'SubscriptionTopic', TFhirSubscriptionTopic(resource), true, -1);
{$ENDIF FHIR_SUBSCRIPTIONTOPIC}
{$IFDEF FHIR_SUBSTANCE}
    frtSubstance: ComposeSubstance(this, '', 'Substance', TFhirSubstance(resource), true, -1);
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCEDEFINITION}
    frtSubstanceDefinition: ComposeSubstanceDefinition(this, '', 'SubstanceDefinition', TFhirSubstanceDefinition(resource), true, -1);
{$ENDIF FHIR_SUBSTANCEDEFINITION}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
    frtSubstanceNucleicAcid: ComposeSubstanceNucleicAcid(this, '', 'SubstanceNucleicAcid', TFhirSubstanceNucleicAcid(resource), true, -1);
{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
    frtSubstancePolymer: ComposeSubstancePolymer(this, '', 'SubstancePolymer', TFhirSubstancePolymer(resource), true, -1);
{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
    frtSubstanceProtein: ComposeSubstanceProtein(this, '', 'SubstanceProtein', TFhirSubstanceProtein(resource), true, -1);
{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
    frtSubstanceReferenceInformation: ComposeSubstanceReferenceInformation(this, '', 'SubstanceReferenceInformation', TFhirSubstanceReferenceInformation(resource), true, -1);
{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
    frtSubstanceSourceMaterial: ComposeSubstanceSourceMaterial(this, '', 'SubstanceSourceMaterial', TFhirSubstanceSourceMaterial(resource), true, -1);
{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUPPLYDELIVERY}
    frtSupplyDelivery: ComposeSupplyDelivery(this, '', 'SupplyDelivery', TFhirSupplyDelivery(resource), true, -1);
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
    frtSupplyRequest: ComposeSupplyRequest(this, '', 'SupplyRequest', TFhirSupplyRequest(resource), true, -1);
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
    frtTask: ComposeTask(this, '', 'Task', TFhirTask(resource), true, -1);
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
    frtTerminologyCapabilities: ComposeTerminologyCapabilities(this, '', 'TerminologyCapabilities', TFhirTerminologyCapabilities(resource), true, -1);
{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTREPORT}
    frtTestReport: ComposeTestReport(this, '', 'TestReport', TFhirTestReport(resource), true, -1);
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
    frtTestScript: ComposeTestScript(this, '', 'TestScript', TFhirTestScript(resource), true, -1);
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_TRANSPORT}
    frtTransport: ComposeTransport(this, '', 'Transport', TFhirTransport(resource), true, -1);
{$ENDIF FHIR_TRANSPORT}
{$IFDEF FHIR_VALUESET}
    frtValueSet: ComposeValueSet(this, '', 'ValueSet', TFhirValueSet(resource), true, -1);
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VERIFICATIONRESULT}
    frtVerificationResult: ComposeVerificationResult(this, '', 'VerificationResult', TFhirVerificationResult(resource), true, -1);
{$ENDIF FHIR_VERIFICATIONRESULT}
{$IFDEF FHIR_VISIONPRESCRIPTION}
    frtVisionPrescription: ComposeVisionPrescription(this, '', 'VisionPrescription', TFhirVisionPrescription(resource), true, -1);
{$ENDIF FHIR_VISIONPRESCRIPTION}

  else
    raise ERdfException.create('Internal error: the resource type '+CODES_TFhirResourceType[resource.ResourceType]+' is not a valid resource type');
  end;
end;

function TFHIRTurtleParser.ParseResource(obj : TTurtleComplex) : TFhirResource;
var
  s : String;
begin
  s := rdfsType(obj);
  if (s = '') then
    Raise ERdfException.Create('error - object has no type')
{$IFDEF FHIR_ACCOUNT}
  else if s = 'Account' Then
    result := ParseAccount(obj) 
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
  else if s = 'ActivityDefinition' Then
    result := ParseActivityDefinition(obj) 
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ACTORDEFINITION}
  else if s = 'ActorDefinition' Then
    result := ParseActorDefinition(obj) 
{$ENDIF FHIR_ACTORDEFINITION}
{$IFDEF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
  else if s = 'AdministrableProductDefinition' Then
    result := ParseAdministrableProductDefinition(obj) 
{$ENDIF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
  else if s = 'AdverseEvent' Then
    result := ParseAdverseEvent(obj) 
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  else if s = 'AllergyIntolerance' Then
    result := ParseAllergyIntolerance(obj) 
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  else if s = 'Appointment' Then
    result := ParseAppointment(obj) 
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  else if s = 'AppointmentResponse' Then
    result := ParseAppointmentResponse(obj) 
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_ARTIFACTASSESSMENT}
  else if s = 'ArtifactAssessment' Then
    result := ParseArtifactAssessment(obj) 
{$ENDIF FHIR_ARTIFACTASSESSMENT}
{$IFDEF FHIR_AUDITEVENT}
  else if s = 'AuditEvent' Then
    result := ParseAuditEvent(obj) 
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  else if s = 'Basic' Then
    result := ParseBasic(obj) 
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  else if s = 'Binary' Then
    result := ParseBinary(obj) 
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
  else if s = 'BiologicallyDerivedProduct' Then
    result := ParseBiologicallyDerivedProduct(obj) 
{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
  else if s = 'BodyStructure' Then
    result := ParseBodyStructure(obj) 
{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_BUNDLE}
  else if s = 'Bundle' Then
    result := ParseBundle(obj) 
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
  else if s = 'CapabilityStatement' Then
    result := ParseCapabilityStatement(obj) 
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
  else if s = 'CarePlan' Then
    result := ParseCarePlan(obj) 
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
  else if s = 'CareTeam' Then
    result := ParseCareTeam(obj) 
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CHARGEITEM}
  else if s = 'ChargeItem' Then
    result := ParseChargeItem(obj) 
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
  else if s = 'ChargeItemDefinition' Then
    result := ParseChargeItemDefinition(obj) 
{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CITATION}
  else if s = 'Citation' Then
    result := ParseCitation(obj) 
{$ENDIF FHIR_CITATION}
{$IFDEF FHIR_CLAIM}
  else if s = 'Claim' Then
    result := ParseClaim(obj) 
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  else if s = 'ClaimResponse' Then
    result := ParseClaimResponse(obj) 
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  else if s = 'ClinicalImpression' Then
    result := ParseClinicalImpression(obj) 
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CLINICALUSEDEFINITION}
  else if s = 'ClinicalUseDefinition' Then
    result := ParseClinicalUseDefinition(obj) 
{$ENDIF FHIR_CLINICALUSEDEFINITION}
{$IFDEF FHIR_CODESYSTEM}
  else if s = 'CodeSystem' Then
    result := ParseCodeSystem(obj) 
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
  else if s = 'Communication' Then
    result := ParseCommunication(obj) 
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  else if s = 'CommunicationRequest' Then
    result := ParseCommunicationRequest(obj) 
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
  else if s = 'CompartmentDefinition' Then
    result := ParseCompartmentDefinition(obj) 
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
  else if s = 'Composition' Then
    result := ParseComposition(obj) 
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  else if s = 'ConceptMap' Then
    result := ParseConceptMap(obj) 
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  else if s = 'Condition' Then
    result := ParseCondition(obj) 
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONDITIONDEFINITION}
  else if s = 'ConditionDefinition' Then
    result := ParseConditionDefinition(obj) 
{$ENDIF FHIR_CONDITIONDEFINITION}
{$IFDEF FHIR_CONSENT}
  else if s = 'Consent' Then
    result := ParseConsent(obj) 
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
  else if s = 'Contract' Then
    result := ParseContract(obj) 
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  else if s = 'Coverage' Then
    result := ParseCoverage(obj) 
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
  else if s = 'CoverageEligibilityRequest' Then
    result := ParseCoverageEligibilityRequest(obj) 
{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
  else if s = 'CoverageEligibilityResponse' Then
    result := ParseCoverageEligibilityResponse(obj) 
{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_DETECTEDISSUE}
  else if s = 'DetectedIssue' Then
    result := ParseDetectedIssue(obj) 
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  else if s = 'Device' Then
    result := ParseDevice(obj) 
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
  else if s = 'DeviceDefinition' Then
    result := ParseDeviceDefinition(obj) 
{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEDISPENSE}
  else if s = 'DeviceDispense' Then
    result := ParseDeviceDispense(obj) 
{$ENDIF FHIR_DEVICEDISPENSE}
{$IFDEF FHIR_DEVICEMETRIC}
  else if s = 'DeviceMetric' Then
    result := ParseDeviceMetric(obj) 
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
  else if s = 'DeviceRequest' Then
    result := ParseDeviceRequest(obj) 
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSAGE}
  else if s = 'DeviceUsage' Then
    result := ParseDeviceUsage(obj) 
{$ENDIF FHIR_DEVICEUSAGE}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  else if s = 'DiagnosticReport' Then
    result := ParseDiagnosticReport(obj) 
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  else if s = 'DocumentManifest' Then
    result := ParseDocumentManifest(obj) 
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  else if s = 'DocumentReference' Then
    result := ParseDocumentReference(obj) 
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ENCOUNTER}
  else if s = 'Encounter' Then
    result := ParseEncounter(obj) 
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
  else if s = 'Endpoint' Then
    result := ParseEndpoint(obj) 
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  else if s = 'EnrollmentRequest' Then
    result := ParseEnrollmentRequest(obj) 
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  else if s = 'EnrollmentResponse' Then
    result := ParseEnrollmentResponse(obj) 
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  else if s = 'EpisodeOfCare' Then
    result := ParseEpisodeOfCare(obj) 
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EVENTDEFINITION}
  else if s = 'EventDefinition' Then
    result := ParseEventDefinition(obj) 
{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EVIDENCE}
  else if s = 'Evidence' Then
    result := ParseEvidence(obj) 
{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEREPORT}
  else if s = 'EvidenceReport' Then
    result := ParseEvidenceReport(obj) 
{$ENDIF FHIR_EVIDENCEREPORT}
{$IFDEF FHIR_EVIDENCEVARIABLE}
  else if s = 'EvidenceVariable' Then
    result := ParseEvidenceVariable(obj) 
{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_EXAMPLESCENARIO}
  else if s = 'ExampleScenario' Then
    result := ParseExampleScenario(obj) 
{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  else if s = 'ExplanationOfBenefit' Then
    result := ParseExplanationOfBenefit(obj) 
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  else if s = 'FamilyMemberHistory' Then
    result := ParseFamilyMemberHistory(obj) 
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  else if s = 'Flag' Then
    result := ParseFlag(obj) 
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_FORMULARYITEM}
  else if s = 'FormularyItem' Then
    result := ParseFormularyItem(obj) 
{$ENDIF FHIR_FORMULARYITEM}
{$IFDEF FHIR_GENOMICSTUDY}
  else if s = 'GenomicStudy' Then
    result := ParseGenomicStudy(obj) 
{$ENDIF FHIR_GENOMICSTUDY}
{$IFDEF FHIR_GOAL}
  else if s = 'Goal' Then
    result := ParseGoal(obj) 
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
  else if s = 'GraphDefinition' Then
    result := ParseGraphDefinition(obj) 
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
  else if s = 'Group' Then
    result := ParseGroup(obj) 
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
  else if s = 'GuidanceResponse' Then
    result := ParseGuidanceResponse(obj) 
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
  else if s = 'HealthcareService' Then
    result := ParseHealthcareService(obj) 
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGSELECTION}
  else if s = 'ImagingSelection' Then
    result := ParseImagingSelection(obj) 
{$ENDIF FHIR_IMAGINGSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
  else if s = 'ImagingStudy' Then
    result := ParseImagingStudy(obj) 
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  else if s = 'Immunization' Then
    result := ParseImmunization(obj) 
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
  else if s = 'ImmunizationEvaluation' Then
    result := ParseImmunizationEvaluation(obj) 
{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  else if s = 'ImmunizationRecommendation' Then
    result := ParseImmunizationRecommendation(obj) 
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  else if s = 'ImplementationGuide' Then
    result := ParseImplementationGuide(obj) 
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_INGREDIENT}
  else if s = 'Ingredient' Then
    result := ParseIngredient(obj) 
{$ENDIF FHIR_INGREDIENT}
{$IFDEF FHIR_INSURANCEPLAN}
  else if s = 'InsurancePlan' Then
    result := ParseInsurancePlan(obj) 
{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVENTORYREPORT}
  else if s = 'InventoryReport' Then
    result := ParseInventoryReport(obj) 
{$ENDIF FHIR_INVENTORYREPORT}
{$IFDEF FHIR_INVOICE}
  else if s = 'Invoice' Then
    result := ParseInvoice(obj) 
{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_LIBRARY}
  else if s = 'Library' Then
    result := ParseLibrary(obj) 
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
  else if s = 'Linkage' Then
    result := ParseLinkage(obj) 
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
  else if s = 'List' Then
    result := ParseList(obj) 
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  else if s = 'Location' Then
    result := ParseLocation(obj) 
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MANUFACTUREDITEMDEFINITION}
  else if s = 'ManufacturedItemDefinition' Then
    result := ParseManufacturedItemDefinition(obj) 
{$ENDIF FHIR_MANUFACTUREDITEMDEFINITION}
{$IFDEF FHIR_MEASURE}
  else if s = 'Measure' Then
    result := ParseMeasure(obj) 
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
  else if s = 'MeasureReport' Then
    result := ParseMeasureReport(obj) 
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDICATION}
  else if s = 'Medication' Then
    result := ParseMedication(obj) 
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  else if s = 'MedicationAdministration' Then
    result := ParseMedicationAdministration(obj) 
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  else if s = 'MedicationDispense' Then
    result := ParseMedicationDispense(obj) 
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
  else if s = 'MedicationKnowledge' Then
    result := ParseMedicationKnowledge(obj) 
{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICATIONREQUEST}
  else if s = 'MedicationRequest' Then
    result := ParseMedicationRequest(obj) 
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONUSAGE}
  else if s = 'MedicationUsage' Then
    result := ParseMedicationUsage(obj) 
{$ENDIF FHIR_MEDICATIONUSAGE}
{$IFDEF FHIR_MEDICINALPRODUCTDEFINITION}
  else if s = 'MedicinalProductDefinition' Then
    result := ParseMedicinalProductDefinition(obj) 
{$ENDIF FHIR_MEDICINALPRODUCTDEFINITION}
{$IFDEF FHIR_MESSAGEDEFINITION}
  else if s = 'MessageDefinition' Then
    result := ParseMessageDefinition(obj) 
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
  else if s = 'MessageHeader' Then
    result := ParseMessageHeader(obj) 
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_MOLECULARSEQUENCE}
  else if s = 'MolecularSequence' Then
    result := ParseMolecularSequence(obj) 
{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NAMINGSYSTEM}
  else if s = 'NamingSystem' Then
    result := ParseNamingSystem(obj) 
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONINTAKE}
  else if s = 'NutritionIntake' Then
    result := ParseNutritionIntake(obj) 
{$ENDIF FHIR_NUTRITIONINTAKE}
{$IFDEF FHIR_NUTRITIONORDER}
  else if s = 'NutritionOrder' Then
    result := ParseNutritionOrder(obj) 
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_NUTRITIONPRODUCT}
  else if s = 'NutritionProduct' Then
    result := ParseNutritionProduct(obj) 
{$ENDIF FHIR_NUTRITIONPRODUCT}
{$IFDEF FHIR_OBSERVATION}
  else if s = 'Observation' Then
    result := ParseObservation(obj) 
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
  else if s = 'ObservationDefinition' Then
    result := ParseObservationDefinition(obj) 
{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  else if s = 'OperationDefinition' Then
    result := ParseOperationDefinition(obj) 
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  else if s = 'OperationOutcome' Then
    result := ParseOperationOutcome(obj) 
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
  else if s = 'Organization' Then
    result := ParseOrganization(obj) 
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
  else if s = 'OrganizationAffiliation' Then
    result := ParseOrganizationAffiliation(obj) 
{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PACKAGEDPRODUCTDEFINITION}
  else if s = 'PackagedProductDefinition' Then
    result := ParsePackagedProductDefinition(obj) 
{$ENDIF FHIR_PACKAGEDPRODUCTDEFINITION}
{$IFDEF FHIR_PARAMETERS}
  else if s = 'Parameters' Then
    result := ParseParameters(obj) 
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_PATIENT}
  else if s = 'Patient' Then
    result := ParsePatient(obj) 
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  else if s = 'PaymentNotice' Then
    result := ParsePaymentNotice(obj) 
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  else if s = 'PaymentReconciliation' Then
    result := ParsePaymentReconciliation(obj) 
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERMISSION}
  else if s = 'Permission' Then
    result := ParsePermission(obj) 
{$ENDIF FHIR_PERMISSION}
{$IFDEF FHIR_PERSON}
  else if s = 'Person' Then
    result := ParsePerson(obj) 
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
  else if s = 'PlanDefinition' Then
    result := ParsePlanDefinition(obj) 
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
  else if s = 'Practitioner' Then
    result := ParsePractitioner(obj) 
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
  else if s = 'PractitionerRole' Then
    result := ParsePractitionerRole(obj) 
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
  else if s = 'Procedure' Then
    result := ParseProcedure(obj) 
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROVENANCE}
  else if s = 'Provenance' Then
    result := ParseProvenance(obj) 
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  else if s = 'Questionnaire' Then
    result := ParseQuestionnaire(obj) 
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  else if s = 'QuestionnaireResponse' Then
    result := ParseQuestionnaireResponse(obj) 
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REGULATEDAUTHORIZATION}
  else if s = 'RegulatedAuthorization' Then
    result := ParseRegulatedAuthorization(obj) 
{$ENDIF FHIR_REGULATEDAUTHORIZATION}
{$IFDEF FHIR_RELATEDPERSON}
  else if s = 'RelatedPerson' Then
    result := ParseRelatedPerson(obj) 
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
  else if s = 'RequestGroup' Then
    result := ParseRequestGroup(obj) 
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_REQUESTORCHESTRATION}
  else if s = 'RequestOrchestration' Then
    result := ParseRequestOrchestration(obj) 
{$ENDIF FHIR_REQUESTORCHESTRATION}
{$IFDEF FHIR_REQUIREMENTS}
  else if s = 'Requirements' Then
    result := ParseRequirements(obj) 
{$ENDIF FHIR_REQUIREMENTS}
{$IFDEF FHIR_RESEARCHSTUDY}
  else if s = 'ResearchStudy' Then
    result := ParseResearchStudy(obj) 
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
  else if s = 'ResearchSubject' Then
    result := ParseResearchSubject(obj) 
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
  else if s = 'RiskAssessment' Then
    result := ParseRiskAssessment(obj) 
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
  else if s = 'Schedule' Then
    result := ParseSchedule(obj) 
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  else if s = 'SearchParameter' Then
    result := ParseSearchParameter(obj) 
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEREQUEST}
  else if s = 'ServiceRequest' Then
    result := ParseServiceRequest(obj) 
{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SLOT}
  else if s = 'Slot' Then
    result := ParseSlot(obj) 
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  else if s = 'Specimen' Then
    result := ParseSpecimen(obj) 
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SPECIMENDEFINITION}
  else if s = 'SpecimenDefinition' Then
    result := ParseSpecimenDefinition(obj) 
{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  else if s = 'StructureDefinition' Then
    result := ParseStructureDefinition(obj) 
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
  else if s = 'StructureMap' Then
    result := ParseStructureMap(obj) 
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
  else if s = 'Subscription' Then
    result := ParseSubscription(obj) 
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSCRIPTIONSTATUS}
  else if s = 'SubscriptionStatus' Then
    result := ParseSubscriptionStatus(obj) 
{$ENDIF FHIR_SUBSCRIPTIONSTATUS}
{$IFDEF FHIR_SUBSCRIPTIONTOPIC}
  else if s = 'SubscriptionTopic' Then
    result := ParseSubscriptionTopic(obj) 
{$ENDIF FHIR_SUBSCRIPTIONTOPIC}
{$IFDEF FHIR_SUBSTANCE}
  else if s = 'Substance' Then
    result := ParseSubstance(obj) 
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCEDEFINITION}
  else if s = 'SubstanceDefinition' Then
    result := ParseSubstanceDefinition(obj) 
{$ENDIF FHIR_SUBSTANCEDEFINITION}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
  else if s = 'SubstanceNucleicAcid' Then
    result := ParseSubstanceNucleicAcid(obj) 
{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
  else if s = 'SubstancePolymer' Then
    result := ParseSubstancePolymer(obj) 
{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
  else if s = 'SubstanceProtein' Then
    result := ParseSubstanceProtein(obj) 
{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
  else if s = 'SubstanceReferenceInformation' Then
    result := ParseSubstanceReferenceInformation(obj) 
{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
  else if s = 'SubstanceSourceMaterial' Then
    result := ParseSubstanceSourceMaterial(obj) 
{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUPPLYDELIVERY}
  else if s = 'SupplyDelivery' Then
    result := ParseSupplyDelivery(obj) 
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  else if s = 'SupplyRequest' Then
    result := ParseSupplyRequest(obj) 
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
  else if s = 'Task' Then
    result := ParseTask(obj) 
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
  else if s = 'TerminologyCapabilities' Then
    result := ParseTerminologyCapabilities(obj) 
{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTREPORT}
  else if s = 'TestReport' Then
    result := ParseTestReport(obj) 
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
  else if s = 'TestScript' Then
    result := ParseTestScript(obj) 
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_TRANSPORT}
  else if s = 'Transport' Then
    result := ParseTransport(obj) 
{$ENDIF FHIR_TRANSPORT}
{$IFDEF FHIR_VALUESET}
  else if s = 'ValueSet' Then
    result := ParseValueSet(obj) 
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VERIFICATIONRESULT}
  else if s = 'VerificationResult' Then
    result := ParseVerificationResult(obj) 
{$ENDIF FHIR_VERIFICATIONRESULT}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  else if s = 'VisionPrescription' Then
    result := ParseVisionPrescription(obj) 
{$ENDIF FHIR_VISIONPRESCRIPTION}

  else
    raise ERdfException.create('error: the element '+s+' is not a valid resource name');
end;

end.

