unit fhir5_resources_other;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
}

{$i fhir.inc}
{$i fhir5.inc}

interface

// Generated on Thu, Nov 10, 2022 for FHIR v5.0.0



uses
  SysUtils, Classes, 
  fsl_base, fsl_utilities, fsl_stream, 
  fhir_objects, fhir_utilities,  
  fhir5_base, fhir5_enums, fhir5_types, fhir5_resources_base, fhir5_resources_canonical;



type
{$IFDEF FHIR_ACTIVITYDEFINITION}
  TFhirActivityDefinitionParticipant = class;
  TFhirActivityDefinitionParticipantList = class;
  TFhirActivityDefinitionDynamicValue = class;
  TFhirActivityDefinitionDynamicValueList = class;
  TFhirActivityDefinition = class;
  TFhirActivityDefinitionList = class;
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ARTIFACTASSESSMENT}
  TFhirArtifactAssessmentContent = class;
  TFhirArtifactAssessmentContentList = class;
  TFhirArtifactAssessment = class;
  TFhirArtifactAssessmentList = class;
{$ENDIF FHIR_ARTIFACTASSESSMENT}
{$IFDEF FHIR_AUDITEVENT}
  TFhirAuditEventOutcome = class;
  TFhirAuditEventOutcomeList = class;
  TFhirAuditEventAgent = class;
  TFhirAuditEventAgentList = class;
  TFhirAuditEventSource = class;
  TFhirAuditEventSourceList = class;
  TFhirAuditEventEntity = class;
  TFhirAuditEventEntityList = class;
  TFhirAuditEventEntityDetail = class;
  TFhirAuditEventEntityDetailList = class;
  TFhirAuditEvent = class;
  TFhirAuditEventList = class;
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BINARY}
  TFhirBinary = class;
  TFhirBinaryList = class;
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BUNDLE}
  TFhirBundleLink = class;
  TFhirBundleLinkList = class;
  TFhirBundleEntry = class;
  TFhirBundleEntryList = class;
  TFhirBundleEntrySearch = class;
  TFhirBundleEntrySearchList = class;
  TFhirBundleEntryRequest = class;
  TFhirBundleEntryRequestList = class;
  TFhirBundleEntryResponse = class;
  TFhirBundleEntryResponseList = class;
  TFhirBundle = class;
  TFhirBundleList = class;
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CONSENT}
  TFhirConsentPolicyBasis = class;
  TFhirConsentPolicyBasisList = class;
  TFhirConsentVerification = class;
  TFhirConsentVerificationList = class;
  TFhirConsentProvision = class;
  TFhirConsentProvisionList = class;
  TFhirConsentProvisionActor = class;
  TFhirConsentProvisionActorList = class;
  TFhirConsentProvisionData = class;
  TFhirConsentProvisionDataList = class;
  TFhirConsent = class;
  TFhirConsentList = class;
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
  TFhirContractContentDefinition = class;
  TFhirContractContentDefinitionList = class;
  TFhirContractTerm = class;
  TFhirContractTermList = class;
  TFhirContractTermSecurityLabel = class;
  TFhirContractTermSecurityLabelList = class;
  TFhirContractTermOffer = class;
  TFhirContractTermOfferList = class;
  TFhirContractTermOfferParty = class;
  TFhirContractTermOfferPartyList = class;
  TFhirContractTermOfferAnswer = class;
  TFhirContractTermOfferAnswerList = class;
  TFhirContractTermAsset = class;
  TFhirContractTermAssetList = class;
  TFhirContractTermAssetContext = class;
  TFhirContractTermAssetContextList = class;
  TFhirContractTermAssetValuedItem = class;
  TFhirContractTermAssetValuedItemList = class;
  TFhirContractTermAction = class;
  TFhirContractTermActionList = class;
  TFhirContractTermActionSubject = class;
  TFhirContractTermActionSubjectList = class;
  TFhirContractSigner = class;
  TFhirContractSignerList = class;
  TFhirContractFriendly = class;
  TFhirContractFriendlyList = class;
  TFhirContractLegal = class;
  TFhirContractLegalList = class;
  TFhirContractRule = class;
  TFhirContractRuleList = class;
  TFhirContract = class;
  TFhirContractList = class;
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_EVIDENCE}
  TFhirEvidenceVariableDefinition = class;
  TFhirEvidenceVariableDefinitionList = class;
  TFhirEvidenceStatistic = class;
  TFhirEvidenceStatisticList = class;
  TFhirEvidenceStatisticSampleSize = class;
  TFhirEvidenceStatisticSampleSizeList = class;
  TFhirEvidenceStatisticAttributeEstimate = class;
  TFhirEvidenceStatisticAttributeEstimateList = class;
  TFhirEvidenceStatisticModelCharacteristic = class;
  TFhirEvidenceStatisticModelCharacteristicList = class;
  TFhirEvidenceStatisticModelCharacteristicVariable = class;
  TFhirEvidenceStatisticModelCharacteristicVariableList = class;
  TFhirEvidenceCertainty = class;
  TFhirEvidenceCertaintyList = class;
  TFhirEvidence = class;
  TFhirEvidenceList = class;
{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEREPORT}
  TFhirEvidenceReportSubject = class;
  TFhirEvidenceReportSubjectList = class;
  TFhirEvidenceReportSubjectCharacteristic = class;
  TFhirEvidenceReportSubjectCharacteristicList = class;
  TFhirEvidenceReportRelatesTo = class;
  TFhirEvidenceReportRelatesToList = class;
  TFhirEvidenceReportRelatesToTarget = class;
  TFhirEvidenceReportRelatesToTargetList = class;
  TFhirEvidenceReportSection = class;
  TFhirEvidenceReportSectionList = class;
  TFhirEvidenceReport = class;
  TFhirEvidenceReportList = class;
{$ENDIF FHIR_EVIDENCEREPORT}
{$IFDEF FHIR_EVIDENCEVARIABLE}
  TFhirEvidenceVariableCharacteristic = class;
  TFhirEvidenceVariableCharacteristicList = class;
  TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue = class;
  TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList = class;
  TFhirEvidenceVariableCharacteristicDefinitionByCombination = class;
  TFhirEvidenceVariableCharacteristicDefinitionByCombinationList = class;
  TFhirEvidenceVariableCharacteristicTimeFromEvent = class;
  TFhirEvidenceVariableCharacteristicTimeFromEventList = class;
  TFhirEvidenceVariableCategory = class;
  TFhirEvidenceVariableCategoryList = class;
  TFhirEvidenceVariable = class;
  TFhirEvidenceVariableList = class;
{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_GUIDANCERESPONSE}
  TFhirGuidanceResponse = class;
  TFhirGuidanceResponseList = class;
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_INVENTORYREPORT}
  TFhirInventoryReportInventoryListing = class;
  TFhirInventoryReportInventoryListingList = class;
  TFhirInventoryReportInventoryListingItems = class;
  TFhirInventoryReportInventoryListingItemsList = class;
  TFhirInventoryReport = class;
  TFhirInventoryReportList = class;
{$ENDIF FHIR_INVENTORYREPORT}
{$IFDEF FHIR_LINKAGE}
  TFhirLinkageItem = class;
  TFhirLinkageItemList = class;
  TFhirLinkage = class;
  TFhirLinkageList = class;
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
  TFhirListEntry = class;
  TFhirListEntryList = class;
  TFhirList = class;
  TFhirListList = class;
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_MEASUREREPORT}
  TFhirMeasureReportGroup = class;
  TFhirMeasureReportGroupList = class;
  TFhirMeasureReportGroupPopulation = class;
  TFhirMeasureReportGroupPopulationList = class;
  TFhirMeasureReportGroupStratifier = class;
  TFhirMeasureReportGroupStratifierList = class;
  TFhirMeasureReportGroupStratifierStratum = class;
  TFhirMeasureReportGroupStratifierStratumList = class;
  TFhirMeasureReportGroupStratifierStratumComponent = class;
  TFhirMeasureReportGroupStratifierStratumComponentList = class;
  TFhirMeasureReportGroupStratifierStratumPopulation = class;
  TFhirMeasureReportGroupStratifierStratumPopulationList = class;
  TFhirMeasureReport = class;
  TFhirMeasureReportList = class;
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MESSAGEHEADER}
  TFhirMessageHeaderDestination = class;
  TFhirMessageHeaderDestinationList = class;
  TFhirMessageHeaderSource = class;
  TFhirMessageHeaderSourceList = class;
  TFhirMessageHeaderResponse = class;
  TFhirMessageHeaderResponseList = class;
  TFhirMessageHeader = class;
  TFhirMessageHeaderList = class;
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_OPERATIONOUTCOME}
  TFhirOperationOutcomeIssue = class;
  TFhirOperationOutcomeIssueList = class;
  TFhirOperationOutcome = class;
  TFhirOperationOutcomeList = class;
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_PARAMETERS}
  TFhirParametersParameter = class;
  TFhirParametersParameterList = class;
  TFhirParameters = class;
  TFhirParametersList = class;
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_PERMISSION}
  TFhirPermissionJustification = class;
  TFhirPermissionJustificationList = class;
  TFhirPermissionRule = class;
  TFhirPermissionRuleList = class;
  TFhirPermissionRuleData = class;
  TFhirPermissionRuleDataList = class;
  TFhirPermissionRuleDataResource = class;
  TFhirPermissionRuleDataResourceList = class;
  TFhirPermissionRuleActivity = class;
  TFhirPermissionRuleActivityList = class;
  TFhirPermission = class;
  TFhirPermissionList = class;
{$ENDIF FHIR_PERMISSION}
{$IFDEF FHIR_PLANDEFINITION}
  TFhirPlanDefinitionGoal = class;
  TFhirPlanDefinitionGoalList = class;
  TFhirPlanDefinitionGoalTarget = class;
  TFhirPlanDefinitionGoalTargetList = class;
  TFhirPlanDefinitionActor = class;
  TFhirPlanDefinitionActorList = class;
  TFhirPlanDefinitionActorOption = class;
  TFhirPlanDefinitionActorOptionList = class;
  TFhirPlanDefinitionAction = class;
  TFhirPlanDefinitionActionList = class;
  TFhirPlanDefinitionActionCondition = class;
  TFhirPlanDefinitionActionConditionList = class;
  TFhirPlanDefinitionActionInput = class;
  TFhirPlanDefinitionActionInputList = class;
  TFhirPlanDefinitionActionOutput = class;
  TFhirPlanDefinitionActionOutputList = class;
  TFhirPlanDefinitionActionRelatedAction = class;
  TFhirPlanDefinitionActionRelatedActionList = class;
  TFhirPlanDefinitionActionParticipant = class;
  TFhirPlanDefinitionActionParticipantList = class;
  TFhirPlanDefinitionActionDynamicValue = class;
  TFhirPlanDefinitionActionDynamicValueList = class;
  TFhirPlanDefinition = class;
  TFhirPlanDefinitionList = class;
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PROVENANCE}
  TFhirProvenanceAgent = class;
  TFhirProvenanceAgentList = class;
  TFhirProvenanceEntity = class;
  TFhirProvenanceEntityList = class;
  TFhirProvenance = class;
  TFhirProvenanceList = class;
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  TFhirQuestionnaireResponseItem = class;
  TFhirQuestionnaireResponseItemList = class;
  TFhirQuestionnaireResponseItemAnswer = class;
  TFhirQuestionnaireResponseItemAnswerList = class;
  TFhirQuestionnaireResponse = class;
  TFhirQuestionnaireResponseList = class;
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REQUESTGROUP}
  TFhirRequestGroupAction = class;
  TFhirRequestGroupActionList = class;
  TFhirRequestGroupActionCondition = class;
  TFhirRequestGroupActionConditionList = class;
  TFhirRequestGroupActionRelatedAction = class;
  TFhirRequestGroupActionRelatedActionList = class;
  TFhirRequestGroupActionParticipant = class;
  TFhirRequestGroupActionParticipantList = class;
  TFhirRequestGroup = class;
  TFhirRequestGroupList = class;
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_REQUESTORCHESTRATION}
  TFhirRequestOrchestrationAction = class;
  TFhirRequestOrchestrationActionList = class;
  TFhirRequestOrchestrationActionCondition = class;
  TFhirRequestOrchestrationActionConditionList = class;
  TFhirRequestOrchestrationActionInput = class;
  TFhirRequestOrchestrationActionInputList = class;
  TFhirRequestOrchestrationActionOutput = class;
  TFhirRequestOrchestrationActionOutputList = class;
  TFhirRequestOrchestrationActionRelatedAction = class;
  TFhirRequestOrchestrationActionRelatedActionList = class;
  TFhirRequestOrchestrationActionParticipant = class;
  TFhirRequestOrchestrationActionParticipantList = class;
  TFhirRequestOrchestrationActionDynamicValue = class;
  TFhirRequestOrchestrationActionDynamicValueList = class;
  TFhirRequestOrchestration = class;
  TFhirRequestOrchestrationList = class;
{$ENDIF FHIR_REQUESTORCHESTRATION}
{$IFDEF FHIR_RESEARCHSTUDY}
  TFhirResearchStudyLabel = class;
  TFhirResearchStudyLabelList = class;
  TFhirResearchStudyFocus = class;
  TFhirResearchStudyFocusList = class;
  TFhirResearchStudyAssociatedParty = class;
  TFhirResearchStudyAssociatedPartyList = class;
  TFhirResearchStudyProgressStatus = class;
  TFhirResearchStudyProgressStatusList = class;
  TFhirResearchStudyRecruitment = class;
  TFhirResearchStudyRecruitmentList = class;
  TFhirResearchStudyComparisonGroup = class;
  TFhirResearchStudyComparisonGroupList = class;
  TFhirResearchStudyObjective = class;
  TFhirResearchStudyObjectiveList = class;
  TFhirResearchStudyOutcomeMeasure = class;
  TFhirResearchStudyOutcomeMeasureList = class;
  TFhirResearchStudyWebLocation = class;
  TFhirResearchStudyWebLocationList = class;
  TFhirResearchStudy = class;
  TFhirResearchStudyList = class;
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
  TFhirResearchSubjectProgress = class;
  TFhirResearchSubjectProgressList = class;
  TFhirResearchSubject = class;
  TFhirResearchSubjectList = class;
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_SUBSCRIPTION}
  TFhirSubscriptionFilterBy = class;
  TFhirSubscriptionFilterByList = class;
  TFhirSubscription = class;
  TFhirSubscriptionList = class;
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSCRIPTIONSTATUS}
  TFhirSubscriptionStatusNotificationEvent = class;
  TFhirSubscriptionStatusNotificationEventList = class;
  TFhirSubscriptionStatus = class;
  TFhirSubscriptionStatusList = class;
{$ENDIF FHIR_SUBSCRIPTIONSTATUS}
{$IFDEF FHIR_SUBSCRIPTIONTOPIC}
  TFhirSubscriptionTopicResourceTrigger = class;
  TFhirSubscriptionTopicResourceTriggerList = class;
  TFhirSubscriptionTopicResourceTriggerQueryCriteria = class;
  TFhirSubscriptionTopicResourceTriggerQueryCriteriaList = class;
  TFhirSubscriptionTopicEventTrigger = class;
  TFhirSubscriptionTopicEventTriggerList = class;
  TFhirSubscriptionTopicCanFilterBy = class;
  TFhirSubscriptionTopicCanFilterByList = class;
  TFhirSubscriptionTopicNotificationShape = class;
  TFhirSubscriptionTopicNotificationShapeList = class;
  TFhirSubscriptionTopic = class;
  TFhirSubscriptionTopicList = class;
{$ENDIF FHIR_SUBSCRIPTIONTOPIC}
{$IFDEF FHIR_TASK}
  TFhirTaskRestriction = class;
  TFhirTaskRestrictionList = class;
  TFhirTaskInput = class;
  TFhirTaskInputList = class;
  TFhirTaskOutput = class;
  TFhirTaskOutputList = class;
  TFhirTask = class;
  TFhirTaskList = class;
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TESTREPORT}
  TFhirTestReportParticipant = class;
  TFhirTestReportParticipantList = class;
  TFhirTestReportSetup = class;
  TFhirTestReportSetupList = class;
  TFhirTestReportSetupAction = class;
  TFhirTestReportSetupActionList = class;
  TFhirTestReportSetupActionOperation = class;
  TFhirTestReportSetupActionOperationList = class;
  TFhirTestReportSetupActionAssert = class;
  TFhirTestReportSetupActionAssertList = class;
  TFhirTestReportTest = class;
  TFhirTestReportTestList = class;
  TFhirTestReportTestAction = class;
  TFhirTestReportTestActionList = class;
  TFhirTestReportTeardown = class;
  TFhirTestReportTeardownList = class;
  TFhirTestReportTeardownAction = class;
  TFhirTestReportTeardownActionList = class;
  TFhirTestReport = class;
  TFhirTestReportList = class;
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_VERIFICATIONRESULT}
  TFhirVerificationResultPrimarySource = class;
  TFhirVerificationResultPrimarySourceList = class;
  TFhirVerificationResultAttestation = class;
  TFhirVerificationResultAttestationList = class;
  TFhirVerificationResultValidator = class;
  TFhirVerificationResultValidatorList = class;
  TFhirVerificationResult = class;
  TFhirVerificationResultList = class;
{$ENDIF FHIR_VERIFICATIONRESULT}




{$IFDEF FHIR_ACTIVITYDEFINITION}
  // Indicates who should participate in performing the action described.
  TFhirActivityDefinitionParticipant = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FTypeCanonical : TFhirCanonical;
    FTypeReference : TFhirReference;
    FRole : TFhirCodeableConcept;
    FFunction_ : TFhirCodeableConcept;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirActionParticipantTypeEnum;
    procedure SetType_ST(value : TFhirActionParticipantTypeEnum);
    procedure SetTypeCanonical(value : TFhirCanonical);
    function GetTypeCanonicalST : String;
    procedure SetTypeCanonicalST(value : String);
    procedure SetTypeReference(value : TFhirReference);
    procedure SetRole(value : TFhirCodeableConcept);
    procedure SetFunction_(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirActivityDefinitionParticipant; overload;
    function Clone : TFhirActivityDefinitionParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of participant in the action.
    property type_ : TFhirActionParticipantTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The type of participant in the action.
    property typeCanonical : String read GetTypeCanonicalST write SetTypeCanonicalST;
    // The type of participant in the action.
    property typeCanonicalElement : TFhirCanonical read FTypeCanonical write SetTypeCanonical;

    // Typed access to The type of participant in the action. (defined for API consistency)
    property typeReference : TFhirReference read FTypeReference write SetTypeReference;
    // The type of participant in the action.
    property typeReferenceElement : TFhirReference read FTypeReference write SetTypeReference;

    // Typed access to The role the participant should play in performing the described action. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // The role the participant should play in performing the described action.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to Indicates how the actor will be involved in the action - author, reviewer, witness, etc. (defined for API consistency)
    property function_ : TFhirCodeableConcept read FFunction_ write SetFunction_;
    // Indicates how the actor will be involved in the action - author, reviewer, witness, etc.
    property function_Element : TFhirCodeableConcept read FFunction_ write SetFunction_;

  end;

  TFhirActivityDefinitionParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirActivityDefinitionParticipantList;
    function GetCurrent : TFhirActivityDefinitionParticipant;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirActivityDefinitionParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirActivityDefinitionParticipant read GetCurrent;
  end;

  TFhirActivityDefinitionParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirActivityDefinitionParticipant;
    procedure SetItemN(index : Integer; value : TFhirActivityDefinitionParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirActivityDefinitionParticipantList; overload;
    function Clone : TFhirActivityDefinitionParticipantList; overload;
    function GetEnumerator : TFhirActivityDefinitionParticipantListEnumerator;
    
    //  Add a FhirActivityDefinitionParticipant to the end of the list.
    function Append : TFhirActivityDefinitionParticipant;
    
    // Add an already existing FhirActivityDefinitionParticipant to the end of the list.
    function AddItem(value : TFhirActivityDefinitionParticipant) : TFhirActivityDefinitionParticipant; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirActivityDefinitionParticipant) : Integer;
    
    // Insert FhirActivityDefinitionParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirActivityDefinitionParticipant;
    
    // Insert an existing FhirActivityDefinitionParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirActivityDefinitionParticipant);
    
    // Get the iIndexth FhirActivityDefinitionParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirActivityDefinitionParticipant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirActivityDefinitionParticipant;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirActivityDefinitionParticipants[index : Integer] : TFhirActivityDefinitionParticipant read GetItemN write SetItemN; default;
  End;

  // Dynamic values that will be evaluated to produce values for elements of the resulting resource. For example, if the dosage of a medication must be computed based on the patient's weight, a dynamic value would be used to specify an expression that calculated the weight, and the path on the request resource that would contain the result.
  TFhirActivityDefinitionDynamicValue = class (TFhirBackboneElement)
  protected
    FPath : TFhirString;
    FExpression : TFhirExpression;
    procedure SetPath(value : TFhirString);
    function GetPathST : String;
    procedure SetPathST(value : String);
    procedure SetExpression(value : TFhirExpression);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirActivityDefinitionDynamicValue; overload;
    function Clone : TFhirActivityDefinitionDynamicValue; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The path to the element to be customized. This is the path on the resource that will hold the result of the calculation defined by the expression. The specified path SHALL be a FHIRPath resolveable on the specified target type of the ActivityDefinition, and SHALL consist only of identifiers, constant indexers, and a restricted subset of functions. The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](fhirpath.html#simple) for full details).
    property path : String read GetPathST write SetPathST;
    // The path to the element to be customized. This is the path on the resource that will hold the result of the calculation defined by the expression. The specified path SHALL be a FHIRPath resolveable on the specified target type of the ActivityDefinition, and SHALL consist only of identifiers, constant indexers, and a restricted subset of functions. The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](fhirpath.html#simple) for full details).
    property pathElement : TFhirString read FPath write SetPath;

    // Typed access to An expression specifying the value of the customized element. (defined for API consistency)
    property expression : TFhirExpression read FExpression write SetExpression;
    // An expression specifying the value of the customized element.
    property expressionElement : TFhirExpression read FExpression write SetExpression;

  end;

  TFhirActivityDefinitionDynamicValueListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirActivityDefinitionDynamicValueList;
    function GetCurrent : TFhirActivityDefinitionDynamicValue;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirActivityDefinitionDynamicValueList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirActivityDefinitionDynamicValue read GetCurrent;
  end;

  TFhirActivityDefinitionDynamicValueList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirActivityDefinitionDynamicValue;
    procedure SetItemN(index : Integer; value : TFhirActivityDefinitionDynamicValue);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirActivityDefinitionDynamicValueList; overload;
    function Clone : TFhirActivityDefinitionDynamicValueList; overload;
    function GetEnumerator : TFhirActivityDefinitionDynamicValueListEnumerator;
    
    //  Add a FhirActivityDefinitionDynamicValue to the end of the list.
    function Append : TFhirActivityDefinitionDynamicValue;
    
    // Add an already existing FhirActivityDefinitionDynamicValue to the end of the list.
    function AddItem(value : TFhirActivityDefinitionDynamicValue) : TFhirActivityDefinitionDynamicValue; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirActivityDefinitionDynamicValue) : Integer;
    
    // Insert FhirActivityDefinitionDynamicValue before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirActivityDefinitionDynamicValue;
    
    // Insert an existing FhirActivityDefinitionDynamicValue before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirActivityDefinitionDynamicValue);
    
    // Get the iIndexth FhirActivityDefinitionDynamicValue. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirActivityDefinitionDynamicValue);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirActivityDefinitionDynamicValue;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirActivityDefinitionDynamicValues[index : Integer] : TFhirActivityDefinitionDynamicValue read GetItemN write SetItemN; default;
  End;

  // This resource allows for the definition of some activity to be performed, independent of a particular patient, practitioner, or other performance context.
  TFhirActivityDefinition = class (TFhirMetadataResource)
  protected
    FSubtitle : TFhirString;
    FSubject : TFhirDataType;
    FUsage : TFhirString;
    Flibrary_List : TFhirCanonicalList;
    FKind : TFhirEnum;
    FProfile : TFhirCanonical;
    FCode : TFhirCodeableConcept;
    FIntent : TFhirEnum;
    FPriority : TFhirEnum;
    FDoNotPerform : TFhirBoolean;
    FTiming : TFhirDataType;
    FAsNeeded : TFhirDataType;
    FLocation : TFhirCodeableReference;
    FparticipantList : TFhirActivityDefinitionParticipantList;
    FProduct : TFhirDataType;
    FQuantity : TFhirQuantity;
    FdosageList : TFhirDosageList;
    FbodySiteList : TFhirCodeableConceptList;
    FspecimenRequirementList : TFhirCanonicalList;
    FobservationRequirementList : TFhirCanonicalList;
    FobservationResultRequirementList : TFhirCanonicalList;
    FTransform : TFhirCanonical;
    FdynamicValueList : TFhirActivityDefinitionDynamicValueList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetSubtitle(value : TFhirString);
    function GetSubtitleST : String;
    procedure SetSubtitleST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetSubject(value : TFhirDataType);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetUsage(value : TFhirString);
    function GetUsageST : String;
    procedure SetUsageST(value : String);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    procedure SetApprovalDate(value : TFhirDate);
    function GetApprovalDateST : TFslDateTime;
    procedure SetApprovalDateST(value : TFslDateTime);
    procedure SetLastReviewDate(value : TFhirDate);
    function GetLastReviewDateST : TFslDateTime;
    procedure SetLastReviewDateST(value : TFslDateTime);
    procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetTopicList : TFhirCodeableConceptList;
    function GetHasTopicList : Boolean;
    function GetAuthorList : TFhirContactDetailList;
    function GetHasAuthorList : Boolean;
    function GetEditorList : TFhirContactDetailList;
    function GetHasEditorList : Boolean;
    function GetReviewerList : TFhirContactDetailList;
    function GetHasReviewerList : Boolean;
    function GetEndorserList : TFhirContactDetailList;
    function GetHasEndorserList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    function GetLibrary_List : TFhirCanonicalList;
    function GetHasLibrary_List : Boolean;
    procedure SetKind(value : TFhirEnum);
    function GetKindST : TFhirRequestResourceTypesEnum;
    procedure SetKindST(value : TFhirRequestResourceTypesEnum);
    procedure SetProfile(value : TFhirCanonical);
    function GetProfileST : String;
    procedure SetProfileST(value : String);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetIntent(value : TFhirEnum);
    function GetIntentST : TFhirRequestIntentEnum;
    procedure SetIntentST(value : TFhirRequestIntentEnum);
    procedure SetPriority(value : TFhirEnum);
    function GetPriorityST : TFhirRequestPriorityEnum;
    procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    procedure SetDoNotPerform(value : TFhirBoolean);
    function GetDoNotPerformST : Boolean;
    procedure SetDoNotPerformST(value : Boolean);
    procedure SetTiming(value : TFhirDataType);
    procedure SetAsNeeded(value : TFhirDataType);
    procedure SetLocation(value : TFhirCodeableReference);
    function GetParticipantList : TFhirActivityDefinitionParticipantList;
    function GetHasParticipantList : Boolean;
    procedure SetProduct(value : TFhirDataType);
    procedure SetQuantity(value : TFhirQuantity);
    function GetDosageList : TFhirDosageList;
    function GetHasDosageList : Boolean;
    function GetBodySiteList : TFhirCodeableConceptList;
    function GetHasBodySiteList : Boolean;
    function GetSpecimenRequirementList : TFhirCanonicalList;
    function GetHasSpecimenRequirementList : Boolean;
    function GetObservationRequirementList : TFhirCanonicalList;
    function GetHasObservationRequirementList : Boolean;
    function GetObservationResultRequirementList : TFhirCanonicalList;
    function GetHasObservationResultRequirementList : Boolean;
    procedure SetTransform(value : TFhirCanonical);
    function GetTransformST : String;
    procedure SetTransformST(value : String);
    function GetDynamicValueList : TFhirActivityDefinitionDynamicValueList;
    function GetHasDynamicValueList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirActivityDefinition; overload;
    function Clone : TFhirActivityDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this activity definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which an authoritative instance of this activity definition is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the activity definition is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this activity definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which an authoritative instance of this activity definition is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the activity definition is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this activity definition when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the activity definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the activity definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active assets.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the activity definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the activity definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active assets.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the activity definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the activity definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the activity definition.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the activity definition.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to An explanatory or alternate title for the activity definition giving additional information about its content.
    property subtitle : String read GetSubtitleST write SetSubtitleST;
    // An explanatory or alternate title for the activity definition giving additional information about its content.
    property subtitleElement : TFhirString read FSubtitle write SetSubtitle;

    // The status of this activity definition. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this activity definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this activity definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to A code, group definition, or canonical reference that describes  or identifies the intended subject of the activity being defined.  Canonical references are allowed to support the definition of protocols for drug and substance quality specifications, and is allowed to reference a MedicinalProductDefinition, SubstanceDefinition, AdministrableProductDefinition, ManufacturedItemDefinition, or PackagedProductDefinition resource. (defined for API consistency)
    property subject : TFhirDataType read FSubject write SetSubject;
    // A code, group definition, or canonical reference that describes  or identifies the intended subject of the activity being defined.  Canonical references are allowed to support the definition of protocols for drug and substance quality specifications, and is allowed to reference a MedicinalProductDefinition, SubstanceDefinition, AdministrableProductDefinition, ManufacturedItemDefinition, or PackagedProductDefinition resource.
    property subjectElement : TFhirDataType read FSubject write SetSubject;

    // Typed access to The date  (and optionally time) when the activity definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the activity definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the activity definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the activity definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual responsible for the release and ongoing maintenance of the activity definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual responsible for the release and ongoing maintenance of the activity definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the activity definition from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the activity definition from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate activity definition instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the activity definition is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explanation of why this activity definition is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this activity definition is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A detailed description of how the activity definition is used from a clinical perspective.
    property usage : String read GetUsageST write SetUsageST;
    // A detailed description of how the activity definition is used from a clinical perspective.
    property usageElement : TFhirString read FUsage write SetUsage;

    // Typed access to A copyright statement relating to the activity definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the activity definition.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the activity definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the activity definition.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the activity definition content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the activity definition content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // Descriptive topics related to the content of the activity. Topics provide a high-level categorization of the activity that can be useful for filtering and searching.
    property topicList : TFhirCodeableConceptList read GetTopicList;
    property hasTopicList : boolean read GetHasTopicList;

    // An individiual or organization primarily involved in the creation and maintenance of the content.
    property authorList : TFhirContactDetailList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // An individual or organization primarily responsible for internal coherence of the content.
    property editorList : TFhirContactDetailList read GetEditorList;
    property hasEditorList : boolean read GetHasEditorList;

    // An individual or organization primarily responsible for review of some aspect of the content.
    property reviewerList : TFhirContactDetailList read GetReviewerList;
    property hasReviewerList : boolean read GetHasReviewerList;

    // An individual or organization responsible for officially endorsing the content for use in some setting.
    property endorserList : TFhirContactDetailList read GetEndorserList;
    property hasEndorserList : boolean read GetHasEndorserList;

    // Related artifacts such as additional documentation, justification, or bibliographic references.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // A reference to a Library resource containing any formal logic used by the activity definition.
    property library_List : TFhirCanonicalList read GetLibrary_List;
    property hasLibrary_List : boolean read GetHasLibrary_List;

    // A description of the kind of resource the activity definition is representing. For example, a MedicationRequest, a ServiceRequest, or a CommunicationRequest. Typically, but not always, this is a Request resource.
    property kind : TFhirRequestResourceTypesEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    // Typed access to A profile to which the target of the activity definition is expected to conform.
    property profile : String read GetProfileST write SetProfileST;
    // A profile to which the target of the activity definition is expected to conform.
    property profileElement : TFhirCanonical read FProfile write SetProfile;

    // Typed access to Detailed description of the type of activity; e.g. What lab test, what procedure, what kind of encounter. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Detailed description of the type of activity; e.g. What lab test, what procedure, what kind of encounter.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Indicates the level of authority/intentionality associated with the activity and where the request should fit into the workflow chain.
    property intent : TFhirRequestIntentEnum read GetIntentST write SetIntentST;
    property intentElement : TFhirEnum read FIntent write SetIntent;

    // Indicates how quickly the activity  should be addressed with respect to other requests.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // Typed access to Set this to true if the definition is to indicate that a particular activity should NOT be performed. If true, this element should be interpreted to reinforce a negative coding. For example NPO as a code with a doNotPerform of true would still indicate to NOT perform the action.
    property doNotPerform : Boolean read GetDoNotPerformST write SetDoNotPerformST;
    // Set this to true if the definition is to indicate that a particular activity should NOT be performed. If true, this element should be interpreted to reinforce a negative coding. For example NPO as a code with a doNotPerform of true would still indicate to NOT perform the action.
    property doNotPerformElement : TFhirBoolean read FDoNotPerform write SetDoNotPerform;

    // Typed access to The timing or frequency upon which the described activity is to occur. (defined for API consistency)
    property timing : TFhirDataType read FTiming write SetTiming;
    // The timing or frequency upon which the described activity is to occur.
    property timingElement : TFhirDataType read FTiming write SetTiming;

    // Typed access to If a CodeableConcept is present, it indicates the pre-condition for performing the service.  For example "pain", "on flare-up", etc. (defined for API consistency)
    property asNeeded : TFhirDataType read FAsNeeded write SetAsNeeded;
    // If a CodeableConcept is present, it indicates the pre-condition for performing the service.  For example "pain", "on flare-up", etc.
    property asNeededElement : TFhirDataType read FAsNeeded write SetAsNeeded;

    // Typed access to Identifies the facility where the activity will occur; e.g. home, hospital, specific clinic, etc. (defined for API consistency)
    property location : TFhirCodeableReference read FLocation write SetLocation;
    // Identifies the facility where the activity will occur; e.g. home, hospital, specific clinic, etc.
    property locationElement : TFhirCodeableReference read FLocation write SetLocation;

    // Indicates who should participate in performing the action described.
    property participantList : TFhirActivityDefinitionParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // Typed access to Identifies the food, drug or other product being consumed or supplied in the activity. (defined for API consistency)
    property product : TFhirDataType read FProduct write SetProduct;
    // Identifies the food, drug or other product being consumed or supplied in the activity.
    property productElement : TFhirDataType read FProduct write SetProduct;

    // Typed access to Identifies the quantity expected to be consumed at once (per dose, per meal, etc.). (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // Identifies the quantity expected to be consumed at once (per dose, per meal, etc.).
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Provides detailed dosage instructions in the same way that they are described for MedicationRequest resources.
    property dosageList : TFhirDosageList read GetDosageList;
    property hasDosageList : boolean read GetHasDosageList;

    // Indicates the sites on the subject's body where the procedure should be performed (I.e. the target sites).
    property bodySiteList : TFhirCodeableConceptList read GetBodySiteList;
    property hasBodySiteList : boolean read GetHasBodySiteList;

    // Defines specimen requirements for the action to be performed, such as required specimens for a lab test.
    property specimenRequirementList : TFhirCanonicalList read GetSpecimenRequirementList;
    property hasSpecimenRequirementList : boolean read GetHasSpecimenRequirementList;

    // Defines observation requirements for the action to be performed, such as body weight or surface area.
    property observationRequirementList : TFhirCanonicalList read GetObservationRequirementList;
    property hasObservationRequirementList : boolean read GetHasObservationRequirementList;

    // Defines the observations that are expected to be produced by the action.
    property observationResultRequirementList : TFhirCanonicalList read GetObservationResultRequirementList;
    property hasObservationResultRequirementList : boolean read GetHasObservationResultRequirementList;

    // Typed access to A reference to a StructureMap resource that defines a transform that can be executed to produce the intent resource using the ActivityDefinition instance as the input.
    property transform : String read GetTransformST write SetTransformST;
    // A reference to a StructureMap resource that defines a transform that can be executed to produce the intent resource using the ActivityDefinition instance as the input.
    property transformElement : TFhirCanonical read FTransform write SetTransform;

    // Dynamic values that will be evaluated to produce values for elements of the resulting resource. For example, if the dosage of a medication must be computed based on the patient's weight, a dynamic value would be used to specify an expression that calculated the weight, and the path on the request resource that would contain the result.
    property dynamicValueList : TFhirActivityDefinitionDynamicValueList read GetDynamicValueList;
    property hasDynamicValueList : boolean read GetHasDynamicValueList;

  end;

  TFhirActivityDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirActivityDefinitionList;
    function GetCurrent : TFhirActivityDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirActivityDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirActivityDefinition read GetCurrent;
  end;

  TFhirActivityDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirActivityDefinition;
    procedure SetItemN(index : Integer; value : TFhirActivityDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirActivityDefinitionList; overload;
    function Clone : TFhirActivityDefinitionList; overload;
    function GetEnumerator : TFhirActivityDefinitionListEnumerator;
    
    //  Add a FhirActivityDefinition to the end of the list.
    function Append : TFhirActivityDefinition;
    
    // Add an already existing FhirActivityDefinition to the end of the list.
    function AddItem(value : TFhirActivityDefinition) : TFhirActivityDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirActivityDefinition) : Integer;
    
    // Insert FhirActivityDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirActivityDefinition;
    
    // Insert an existing FhirActivityDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirActivityDefinition);
    
    // Get the iIndexth FhirActivityDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirActivityDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirActivityDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirActivityDefinitions[index : Integer] : TFhirActivityDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ARTIFACTASSESSMENT}
  // A component comment, classifier, or rating of the artifact.
  TFhirArtifactAssessmentContent = class (TFhirBackboneElement)
  protected
    FInformationType : TFhirEnum;
    FSummary : TFhirMarkdown;
    FType_ : TFhirCodeableConcept;
    FclassifierList : TFhirCodeableConceptList;
    FAuthor : TFhirReference;
    FpathList : TFhirUriList;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    FFreeToShare : TFhirBoolean;
    FcomponentList : TFhirArtifactAssessmentContentList;
    procedure SetInformationType(value : TFhirEnum);
    function GetInformationTypeST : TFhirArtifactAssessmentInformationTypeEnum;
    procedure SetInformationTypeST(value : TFhirArtifactAssessmentInformationTypeEnum);
    procedure SetSummary(value : TFhirMarkdown);
    function GetSummaryST : String;
    procedure SetSummaryST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
    function GetClassifierList : TFhirCodeableConceptList;
    function GetHasClassifierList : Boolean;
    procedure SetAuthor(value : TFhirReference);
    function GetPathList : TFhirUriList;
    function GetHasPathList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    procedure SetFreeToShare(value : TFhirBoolean);
    function GetFreeToShareST : Boolean;
    procedure SetFreeToShareST(value : Boolean);
    function GetComponentList : TFhirArtifactAssessmentContentList;
    function GetHasComponentList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirArtifactAssessmentContent; overload;
    function Clone : TFhirArtifactAssessmentContent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of information this component of the content represents.
    property informationType : TFhirArtifactAssessmentInformationTypeEnum read GetInformationTypeST write SetInformationTypeST;
    property informationTypeElement : TFhirEnum read FInformationType write SetInformationType;

    // Typed access to A brief summary of the content of this component.
    property summary : String read GetSummaryST write SetSummaryST;
    // A brief summary of the content of this component.
    property summaryElement : TFhirMarkdown read FSummary write SetSummary;

    // Typed access to Indicates what type of content this component represents. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Indicates what type of content this component represents.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Represents a rating, classifier, or assessment of the artifact.
    property classifierList : TFhirCodeableConceptList read GetClassifierList;
    property hasClassifierList : boolean read GetHasClassifierList;

    // Typed access to Indicates who or what authored the content. (defined for API consistency)
    property author : TFhirReference read FAuthor write SetAuthor;
    // Indicates who or what authored the content.
    property authorElement : TFhirReference read FAuthor write SetAuthor;

    // A URI that points to what the comment is about, such as a line of text in the CQL, or a specific element in a resource.
    property pathList : TFhirUriList read GetPathList;
    property hasPathList : boolean read GetHasPathList;

    // Additional related artifacts that provide supporting documentation, additional evidence, or further information related to the content.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // Typed access to Acceptable to publicly share the comment, classifier or rating.
    property freeToShare : Boolean read GetFreeToShareST write SetFreeToShareST;
    // Acceptable to publicly share the comment, classifier or rating.
    property freeToShareElement : TFhirBoolean read FFreeToShare write SetFreeToShare;

    // If the informationType is container, the components of the content.
    property componentList : TFhirArtifactAssessmentContentList read GetComponentList;
    property hasComponentList : boolean read GetHasComponentList;

  end;

  TFhirArtifactAssessmentContentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirArtifactAssessmentContentList;
    function GetCurrent : TFhirArtifactAssessmentContent;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirArtifactAssessmentContentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirArtifactAssessmentContent read GetCurrent;
  end;

  TFhirArtifactAssessmentContentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirArtifactAssessmentContent;
    procedure SetItemN(index : Integer; value : TFhirArtifactAssessmentContent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirArtifactAssessmentContentList; overload;
    function Clone : TFhirArtifactAssessmentContentList; overload;
    function GetEnumerator : TFhirArtifactAssessmentContentListEnumerator;
    
    //  Add a FhirArtifactAssessmentContent to the end of the list.
    function Append : TFhirArtifactAssessmentContent;
    
    // Add an already existing FhirArtifactAssessmentContent to the end of the list.
    function AddItem(value : TFhirArtifactAssessmentContent) : TFhirArtifactAssessmentContent; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirArtifactAssessmentContent) : Integer;
    
    // Insert FhirArtifactAssessmentContent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirArtifactAssessmentContent;
    
    // Insert an existing FhirArtifactAssessmentContent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirArtifactAssessmentContent);
    
    // Get the iIndexth FhirArtifactAssessmentContent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirArtifactAssessmentContent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirArtifactAssessmentContent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirArtifactAssessmentContents[index : Integer] : TFhirArtifactAssessmentContent read GetItemN write SetItemN; default;
  End;

  // This Resource provides one or more comments, classifiers or ratings about a Resource and supports attribution and rights management metadata for the added content.
  TFhirArtifactAssessment = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FCiteAs : TFhirDataType;
    FDate : TFhirDateTime;
    FCopyright : TFhirMarkdown;
    FApprovalDate : TFhirDate;
    FLastReviewDate : TFhirDate;
    FArtifact : TFhirDataType;
    FcontentList : TFhirArtifactAssessmentContentList;
    FWorkflowStatus : TFhirEnum;
    FDisposition : TFhirEnum;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetCiteAs(value : TFhirDataType);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    procedure SetApprovalDate(value : TFhirDate);
    function GetApprovalDateST : TFslDateTime;
    procedure SetApprovalDateST(value : TFslDateTime);
    procedure SetLastReviewDate(value : TFhirDate);
    function GetLastReviewDateST : TFslDateTime;
    procedure SetLastReviewDateST(value : TFslDateTime);
    procedure SetArtifact(value : TFhirDataType);
    function GetContentList : TFhirArtifactAssessmentContentList;
    function GetHasContentList : Boolean;
    procedure SetWorkflowStatus(value : TFhirEnum);
    function GetWorkflowStatusST : TFhirArtifactAssessmentWorkflowStatusEnum;
    procedure SetWorkflowStatusST(value : TFhirArtifactAssessmentWorkflowStatusEnum);
    procedure SetDisposition(value : TFhirEnum);
    function GetDispositionST : TFhirArtifactAssessmentDispositionEnum;
    procedure SetDispositionST(value : TFhirArtifactAssessmentDispositionEnum);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirArtifactAssessment; overload;
    function Clone : TFhirArtifactAssessment; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A formal identifier that is used to identify this artifact assessment when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Display of or reference to the bibliographic citation of the comment, classifier, or rating. (defined for API consistency)
    property citeAs : TFhirDataType read FCiteAs write SetCiteAs;
    // Display of or reference to the bibliographic citation of the comment, classifier, or rating.
    property citeAsElement : TFhirDataType read FCiteAs write SetCiteAs;

    // Typed access to The date  (and optionally time) when the artifact assessment was published. The date must change when the disposition changes and it must change if the workflow status code changes. In addition, it should change when the substantive content of the artifact assessment changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the artifact assessment was published. The date must change when the disposition changes and it must change if the workflow status code changes. In addition, it should change when the substantive content of the artifact assessment changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to A copyright statement relating to the artifact assessment and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the artifact assessment.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the artifact assessment and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the artifact assessment.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to A reference to a resource, canonical resource, or non-FHIR resource which the comment or assessment is about. (defined for API consistency)
    property artifact : TFhirDataType read FArtifact write SetArtifact;
    // A reference to a resource, canonical resource, or non-FHIR resource which the comment or assessment is about.
    property artifactElement : TFhirDataType read FArtifact write SetArtifact;

    // A component comment, classifier, or rating of the artifact.
    property contentList : TFhirArtifactAssessmentContentList read GetContentList;
    property hasContentList : boolean read GetHasContentList;

    // Indicates the workflow status of the comment or change request.
    property workflowStatus : TFhirArtifactAssessmentWorkflowStatusEnum read GetWorkflowStatusST write SetWorkflowStatusST;
    property workflowStatusElement : TFhirEnum read FWorkflowStatus write SetWorkflowStatus;

    // Indicates the disposition of the responsible party to the comment or change request.
    property disposition : TFhirArtifactAssessmentDispositionEnum read GetDispositionST write SetDispositionST;
    property dispositionElement : TFhirEnum read FDisposition write SetDisposition;

  end;

  TFhirArtifactAssessmentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirArtifactAssessmentList;
    function GetCurrent : TFhirArtifactAssessment;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirArtifactAssessmentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirArtifactAssessment read GetCurrent;
  end;

  TFhirArtifactAssessmentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirArtifactAssessment;
    procedure SetItemN(index : Integer; value : TFhirArtifactAssessment);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirArtifactAssessmentList; overload;
    function Clone : TFhirArtifactAssessmentList; overload;
    function GetEnumerator : TFhirArtifactAssessmentListEnumerator;
    
    //  Add a FhirArtifactAssessment to the end of the list.
    function Append : TFhirArtifactAssessment;
    
    // Add an already existing FhirArtifactAssessment to the end of the list.
    function AddItem(value : TFhirArtifactAssessment) : TFhirArtifactAssessment; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirArtifactAssessment) : Integer;
    
    // Insert FhirArtifactAssessment before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirArtifactAssessment;
    
    // Insert an existing FhirArtifactAssessment before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirArtifactAssessment);
    
    // Get the iIndexth FhirArtifactAssessment. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirArtifactAssessment);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirArtifactAssessment;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirArtifactAssessments[index : Integer] : TFhirArtifactAssessment read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ARTIFACTASSESSMENT}
{$IFDEF FHIR_AUDITEVENT}
  // Indicates whether the event succeeded or failed. A free text descripiton can be given in outcome.text.
  TFhirAuditEventOutcome = class (TFhirBackboneElement)
  protected
    FCode : TFhirCoding;
    FdetailList : TFhirCodeableConceptList;
    procedure SetCode(value : TFhirCoding);
    function GetDetailList : TFhirCodeableConceptList;
    function GetHasDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventOutcome; overload;
    function Clone : TFhirAuditEventOutcome; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates whether the event succeeded or failed. (defined for API consistency)
    property code : TFhirCoding read FCode write SetCode;
    // Indicates whether the event succeeded or failed.
    property codeElement : TFhirCoding read FCode write SetCode;

    // Additional details about the error. This may be a text description of the error or a system code that identifies the error.
    property detailList : TFhirCodeableConceptList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirAuditEventOutcomeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventOutcomeList;
    function GetCurrent : TFhirAuditEventOutcome;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventOutcomeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventOutcome read GetCurrent;
  end;

  TFhirAuditEventOutcomeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAuditEventOutcome;
    procedure SetItemN(index : Integer; value : TFhirAuditEventOutcome);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAuditEventOutcomeList; overload;
    function Clone : TFhirAuditEventOutcomeList; overload;
    function GetEnumerator : TFhirAuditEventOutcomeListEnumerator;
    
    //  Add a FhirAuditEventOutcome to the end of the list.
    function Append : TFhirAuditEventOutcome;
    
    // Add an already existing FhirAuditEventOutcome to the end of the list.
    function AddItem(value : TFhirAuditEventOutcome) : TFhirAuditEventOutcome; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventOutcome) : Integer;
    
    // Insert FhirAuditEventOutcome before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventOutcome;
    
    // Insert an existing FhirAuditEventOutcome before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventOutcome);
    
    // Get the iIndexth FhirAuditEventOutcome. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventOutcome);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventOutcome;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAuditEventOutcomes[index : Integer] : TFhirAuditEventOutcome read GetItemN write SetItemN; default;
  End;

  // An actor taking an active role in the event or activity that is logged.
  TFhirAuditEventAgent = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FroleList : TFhirCodeableConceptList;
    FWho : TFhirReference;
    FRequestor : TFhirBoolean;
    FLocation : TFhirReference;
    FpolicyList : TFhirUriList;
    FNetwork : TFhirDataType;
    FauthorizationList : TFhirCodeableConceptList;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetRoleList : TFhirCodeableConceptList;
    function GetHasRoleList : Boolean;
    procedure SetWho(value : TFhirReference);
    procedure SetRequestor(value : TFhirBoolean);
    function GetRequestorST : Boolean;
    procedure SetRequestorST(value : Boolean);
    procedure SetLocation(value : TFhirReference);
    function GetPolicyList : TFhirUriList;
    function GetHasPolicyList : Boolean;
    procedure SetNetwork(value : TFhirDataType);
    function GetAuthorizationList : TFhirCodeableConceptList;
    function GetHasAuthorizationList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventAgent; overload;
    function Clone : TFhirAuditEventAgent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The Functional Role of the user when performing the event. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The Functional Role of the user when performing the event.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // The structural roles of the agent indicating the agent's competency. The security role enabling the agent with respect to the activity.
    property roleList : TFhirCodeableConceptList read GetRoleList;
    property hasRoleList : boolean read GetHasRoleList;

    // Typed access to Reference to who this agent is that was involved in the event. (defined for API consistency)
    property who : TFhirReference read FWho write SetWho;
    // Reference to who this agent is that was involved in the event.
    property whoElement : TFhirReference read FWho write SetWho;

    // Typed access to Indicator that the user is or is not the requestor, or initiator, for the event being audited.
    property requestor : Boolean read GetRequestorST write SetRequestorST;
    // Indicator that the user is or is not the requestor, or initiator, for the event being audited.
    property requestorElement : TFhirBoolean read FRequestor write SetRequestor;

    // Typed access to Where the agent location is known, the agent location when the event occurred. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // Where the agent location is known, the agent location when the event occurred.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // Where the policy(ies) are known that authorized the agent participation in the event. Typically, a single activity may have multiple applicable policies, such as patient consent, guarantor funding, etc. The policy would also indicate the security token used.
    property policyList : TFhirUriList read GetPolicyList;
    property hasPolicyList : boolean read GetHasPolicyList;

    // Typed access to When the event utilizes a network there should be an agent describing the local system, and an agent describing remote system, with the network interface details. (defined for API consistency)
    property network : TFhirDataType read FNetwork write SetNetwork;
    // When the event utilizes a network there should be an agent describing the local system, and an agent describing remote system, with the network interface details.
    property networkElement : TFhirDataType read FNetwork write SetNetwork;

    // The authorization (e.g., PurposeOfUse) that was used during the event being recorded.
    property authorizationList : TFhirCodeableConceptList read GetAuthorizationList;
    property hasAuthorizationList : boolean read GetHasAuthorizationList;

  end;

  TFhirAuditEventAgentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventAgentList;
    function GetCurrent : TFhirAuditEventAgent;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventAgentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventAgent read GetCurrent;
  end;

  TFhirAuditEventAgentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAuditEventAgent;
    procedure SetItemN(index : Integer; value : TFhirAuditEventAgent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAuditEventAgentList; overload;
    function Clone : TFhirAuditEventAgentList; overload;
    function GetEnumerator : TFhirAuditEventAgentListEnumerator;
    
    //  Add a FhirAuditEventAgent to the end of the list.
    function Append : TFhirAuditEventAgent;
    
    // Add an already existing FhirAuditEventAgent to the end of the list.
    function AddItem(value : TFhirAuditEventAgent) : TFhirAuditEventAgent; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventAgent) : Integer;
    
    // Insert FhirAuditEventAgent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventAgent;
    
    // Insert an existing FhirAuditEventAgent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventAgent);
    
    // Get the iIndexth FhirAuditEventAgent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventAgent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventAgent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAuditEventAgents[index : Integer] : TFhirAuditEventAgent read GetItemN write SetItemN; default;
  End;

  // The actor that is reporting the event.
  TFhirAuditEventSource = class (TFhirBackboneElement)
  protected
    FSite : TFhirReference;
    FObserver : TFhirReference;
    Ftype_List : TFhirCodeableConceptList;
    procedure SetSite(value : TFhirReference);
    procedure SetObserver(value : TFhirReference);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventSource; overload;
    function Clone : TFhirAuditEventSource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Logical source location within the healthcare enterprise network.  For example, a hospital or other provider location within a multi-entity provider group. (defined for API consistency)
    property site : TFhirReference read FSite write SetSite;
    // Logical source location within the healthcare enterprise network.  For example, a hospital or other provider location within a multi-entity provider group.
    property siteElement : TFhirReference read FSite write SetSite;

    // Typed access to Identifier of the source where the event was detected. (defined for API consistency)
    property observer : TFhirReference read FObserver write SetObserver;
    // Identifier of the source where the event was detected.
    property observerElement : TFhirReference read FObserver write SetObserver;

    // Code specifying the type of source where event originated.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

  end;

  TFhirAuditEventSourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventSourceList;
    function GetCurrent : TFhirAuditEventSource;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventSourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventSource read GetCurrent;
  end;

  TFhirAuditEventSourceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAuditEventSource;
    procedure SetItemN(index : Integer; value : TFhirAuditEventSource);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAuditEventSourceList; overload;
    function Clone : TFhirAuditEventSourceList; overload;
    function GetEnumerator : TFhirAuditEventSourceListEnumerator;
    
    //  Add a FhirAuditEventSource to the end of the list.
    function Append : TFhirAuditEventSource;
    
    // Add an already existing FhirAuditEventSource to the end of the list.
    function AddItem(value : TFhirAuditEventSource) : TFhirAuditEventSource; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventSource) : Integer;
    
    // Insert FhirAuditEventSource before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventSource;
    
    // Insert an existing FhirAuditEventSource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventSource);
    
    // Get the iIndexth FhirAuditEventSource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventSource);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventSource;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAuditEventSources[index : Integer] : TFhirAuditEventSource read GetItemN write SetItemN; default;
  End;

  // Specific instances of data or objects that have been accessed.
  TFhirAuditEventEntity = class (TFhirBackboneElement)
  protected
    FWhat : TFhirReference;
    FRole : TFhirCodeableConcept;
    FsecurityLabelList : TFhirCodeableConceptList;
    FQuery : TFhirBase64Binary;
    FdetailList : TFhirAuditEventEntityDetailList;
    FagentList : TFhirAuditEventAgentList;
    procedure SetWhat(value : TFhirReference);
    procedure SetRole(value : TFhirCodeableConcept);
    function GetSecurityLabelList : TFhirCodeableConceptList;
    function GetHasSecurityLabelList : Boolean;
    procedure SetQuery(value : TFhirBase64Binary);
    function GetQueryST : TBytes;
    procedure SetQueryST(value : TBytes);
    function GetDetailList : TFhirAuditEventEntityDetailList;
    function GetHasDetailList : Boolean;
    function GetAgentList : TFhirAuditEventAgentList;
    function GetHasAgentList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventEntity; overload;
    function Clone : TFhirAuditEventEntity; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifies a specific instance of the entity. The reference should be version specific. This is allowed to be a Parameters resource. (defined for API consistency)
    property what : TFhirReference read FWhat write SetWhat;
    // Identifies a specific instance of the entity. The reference should be version specific. This is allowed to be a Parameters resource.
    property whatElement : TFhirReference read FWhat write SetWhat;

    // Typed access to Code representing the role the entity played in the event being audited. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // Code representing the role the entity played in the event being audited.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Security labels for the identified entity.
    property securityLabelList : TFhirCodeableConceptList read GetSecurityLabelList;
    property hasSecurityLabelList : boolean read GetHasSecurityLabelList;

    // Typed access to The query parameters for a query-type entities.
    property query : TBytes read GetQueryST write SetQueryST;
    // The query parameters for a query-type entities.
    property queryElement : TFhirBase64Binary read FQuery write SetQuery;

    // Tagged value pairs for conveying additional information about the entity.
    property detailList : TFhirAuditEventEntityDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

    // The entity is attributed to an agent to express the agent's responsibility for that entity in the activity. This is most used to indicate when persistence media (the entity) are used by an agent. For example when importing data from a device, the device would be described in an entity, and the user importing data from that media would be indicated as the entity.agent.
    property agentList : TFhirAuditEventAgentList read GetAgentList;
    property hasAgentList : boolean read GetHasAgentList;

  end;

  TFhirAuditEventEntityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventEntityList;
    function GetCurrent : TFhirAuditEventEntity;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventEntityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventEntity read GetCurrent;
  end;

  TFhirAuditEventEntityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAuditEventEntity;
    procedure SetItemN(index : Integer; value : TFhirAuditEventEntity);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAuditEventEntityList; overload;
    function Clone : TFhirAuditEventEntityList; overload;
    function GetEnumerator : TFhirAuditEventEntityListEnumerator;
    
    //  Add a FhirAuditEventEntity to the end of the list.
    function Append : TFhirAuditEventEntity;
    
    // Add an already existing FhirAuditEventEntity to the end of the list.
    function AddItem(value : TFhirAuditEventEntity) : TFhirAuditEventEntity; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventEntity) : Integer;
    
    // Insert FhirAuditEventEntity before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventEntity;
    
    // Insert an existing FhirAuditEventEntity before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventEntity);
    
    // Get the iIndexth FhirAuditEventEntity. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventEntity);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventEntity;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAuditEventEntities[index : Integer] : TFhirAuditEventEntity read GetItemN write SetItemN; default;
  End;

  // Tagged value pairs for conveying additional information about the entity.
  TFhirAuditEventEntityDetail = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventEntityDetail; overload;
    function Clone : TFhirAuditEventEntityDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of extra detail provided in the value. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of extra detail provided in the value.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The  value of the extra detail. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The  value of the extra detail.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirAuditEventEntityDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventEntityDetailList;
    function GetCurrent : TFhirAuditEventEntityDetail;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventEntityDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventEntityDetail read GetCurrent;
  end;

  TFhirAuditEventEntityDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAuditEventEntityDetail;
    procedure SetItemN(index : Integer; value : TFhirAuditEventEntityDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAuditEventEntityDetailList; overload;
    function Clone : TFhirAuditEventEntityDetailList; overload;
    function GetEnumerator : TFhirAuditEventEntityDetailListEnumerator;
    
    //  Add a FhirAuditEventEntityDetail to the end of the list.
    function Append : TFhirAuditEventEntityDetail;
    
    // Add an already existing FhirAuditEventEntityDetail to the end of the list.
    function AddItem(value : TFhirAuditEventEntityDetail) : TFhirAuditEventEntityDetail; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventEntityDetail) : Integer;
    
    // Insert FhirAuditEventEntityDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventEntityDetail;
    
    // Insert an existing FhirAuditEventEntityDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventEntityDetail);
    
    // Get the iIndexth FhirAuditEventEntityDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventEntityDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventEntityDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAuditEventEntityDetails[index : Integer] : TFhirAuditEventEntityDetail read GetItemN write SetItemN; default;
  End;

  // A record of an event relevant for purposes such as operations, privacy, security, maintenance, and performance analysis.
  TFhirAuditEvent = class (TFhirDomainResource)
  protected
    FcategoryList : TFhirCodeableConceptList;
    FCode : TFhirCodeableConcept;
    FAction : TFhirEnum;
    FSeverity : TFhirEnum;
    FOccurred : TFhirDataType;
    FRecorded : TFhirInstant;
    FOutcome : TFhirAuditEventOutcome;
    FauthorizationList : TFhirCodeableConceptList;
    FbasedOnList : TFhirReferenceList;
    FPatient : TFhirReference;
    FEncounter : TFhirReference;
    FagentList : TFhirAuditEventAgentList;
    FSource : TFhirAuditEventSource;
    FentityList : TFhirAuditEventEntityList;
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetAction(value : TFhirEnum);
    function GetActionST : TFhirAuditEventActionEnum;
    procedure SetActionST(value : TFhirAuditEventActionEnum);
    procedure SetSeverity(value : TFhirEnum);
    function GetSeverityST : TFhirAuditEventSeverityEnum;
    procedure SetSeverityST(value : TFhirAuditEventSeverityEnum);
    procedure SetOccurred(value : TFhirDataType);
    procedure SetRecorded(value : TFhirInstant);
    function GetRecordedST : TFslDateTime;
    procedure SetRecordedST(value : TFslDateTime);
    procedure SetOutcome(value : TFhirAuditEventOutcome);
    function GetAuthorizationList : TFhirCodeableConceptList;
    function GetHasAuthorizationList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    procedure SetPatient(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    function GetAgentList : TFhirAuditEventAgentList;
    function GetHasAgentList : Boolean;
    procedure SetSource(value : TFhirAuditEventSource);
    function GetEntityList : TFhirAuditEventEntityList;
    function GetHasEntityList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEvent; overload;
    function Clone : TFhirAuditEvent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Classification of the type of event.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to Describes what happened. The most specific code for the event. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Describes what happened. The most specific code for the event.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Indicator for type of action performed during the event that generated the audit.
    property action : TFhirAuditEventActionEnum read GetActionST write SetActionST;
    property actionElement : TFhirEnum read FAction write SetAction;

    // Indicates and enables segmentation of various severity including debugging from critical.
    property severity : TFhirAuditEventSeverityEnum read GetSeverityST write SetSeverityST;
    property severityElement : TFhirEnum read FSeverity write SetSeverity;

    // Typed access to The time or period during which the activity occurred. (defined for API consistency)
    property occurred : TFhirDataType read FOccurred write SetOccurred;
    // The time or period during which the activity occurred.
    property occurredElement : TFhirDataType read FOccurred write SetOccurred;

    // Typed access to The time when the event was recorded.
    property recorded : TFslDateTime read GetRecordedST write SetRecordedST;
    // The time when the event was recorded.
    property recordedElement : TFhirInstant read FRecorded write SetRecorded;

    // Typed access to Indicates whether the event succeeded or failed. A free text descripiton can be given in outcome.text. (defined for API consistency)
    property outcome : TFhirAuditEventOutcome read FOutcome write SetOutcome;
    // Indicates whether the event succeeded or failed. A free text descripiton can be given in outcome.text.
    property outcomeElement : TFhirAuditEventOutcome read FOutcome write SetOutcome;

    // The authorization (e.g., PurposeOfUse) that was used during the event being recorded.
    property authorizationList : TFhirCodeableConceptList read GetAuthorizationList;
    property hasAuthorizationList : boolean read GetHasAuthorizationList;

    // Allows tracing of authorizatino for the events and tracking whether proposals/recommendations were acted upon.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Typed access to The patient element is available to enable deterministic tracking of activities that involve the patient as the subject of the data used in an activity. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The patient element is available to enable deterministic tracking of activities that involve the patient as the subject of the data used in an activity.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to This will typically be the encounter the event occurred, but some events may be initiated prior to or after the official completion of an encounter but still be tied to the context of the encounter (e.g. pre-admission lab tests). (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // This will typically be the encounter the event occurred, but some events may be initiated prior to or after the official completion of an encounter but still be tied to the context of the encounter (e.g. pre-admission lab tests).
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // An actor taking an active role in the event or activity that is logged.
    property agentList : TFhirAuditEventAgentList read GetAgentList;
    property hasAgentList : boolean read GetHasAgentList;

    // Typed access to The actor that is reporting the event. (defined for API consistency)
    property source : TFhirAuditEventSource read FSource write SetSource;
    // The actor that is reporting the event.
    property sourceElement : TFhirAuditEventSource read FSource write SetSource;

    // Specific instances of data or objects that have been accessed.
    property entityList : TFhirAuditEventEntityList read GetEntityList;
    property hasEntityList : boolean read GetHasEntityList;

  end;

  TFhirAuditEventListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventList;
    function GetCurrent : TFhirAuditEvent;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEvent read GetCurrent;
  end;

  TFhirAuditEventList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAuditEvent;
    procedure SetItemN(index : Integer; value : TFhirAuditEvent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAuditEventList; overload;
    function Clone : TFhirAuditEventList; overload;
    function GetEnumerator : TFhirAuditEventListEnumerator;
    
    //  Add a FhirAuditEvent to the end of the list.
    function Append : TFhirAuditEvent;
    
    // Add an already existing FhirAuditEvent to the end of the list.
    function AddItem(value : TFhirAuditEvent) : TFhirAuditEvent; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEvent) : Integer;
    
    // Insert FhirAuditEvent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEvent;
    
    // Insert an existing FhirAuditEvent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEvent);
    
    // Get the iIndexth FhirAuditEvent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEvent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEvent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAuditEvents[index : Integer] : TFhirAuditEvent read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BINARY}
  // A resource that represents the data of a single raw artifact as digital content accessible in its native format.  A Binary resource can contain any content, whether text, image, pdf, zip archive, etc.
  TFhirBinary = class (TFhirResource)
  protected
    FContentType : TFhirCode;
    FSecurityContext : TFhirReference;
    FData : TFhirBase64Binary;
    procedure SetContentType(value : TFhirCode);
    function GetContentTypeST : String;
    procedure SetContentTypeST(value : String);
    procedure SetSecurityContext(value : TFhirReference);
    procedure SetData(value : TFhirBase64Binary);
    function GetDataST : TBytes;
    procedure SetDataST(value : TBytes);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBinary; overload;
    function Clone : TFhirBinary; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to MimeType of the binary content represented as a standard MimeType (BCP 13).
    property contentType : String read GetContentTypeST write SetContentTypeST;
    // MimeType of the binary content represented as a standard MimeType (BCP 13).
    property contentTypeElement : TFhirCode read FContentType write SetContentType;

    // Typed access to This element identifies another resource that can be used as a proxy of the security sensitivity to use when deciding and enforcing access control rules for the Binary resource. Given that the Binary resource contains very few elements that can be used to determine the sensitivity of the data and relationships to individuals, the referenced resource stands in as a proxy equivalent for this purpose. This referenced resource may be related to the Binary (e.g. DocumentReference), or may be some non-related Resource purely as a security proxy. E.g. to identify that the binary resource relates to a patient, and access should only be granted to applications that have access to the patient. (defined for API consistency)
    property securityContext : TFhirReference read FSecurityContext write SetSecurityContext;
    // This element identifies another resource that can be used as a proxy of the security sensitivity to use when deciding and enforcing access control rules for the Binary resource. Given that the Binary resource contains very few elements that can be used to determine the sensitivity of the data and relationships to individuals, the referenced resource stands in as a proxy equivalent for this purpose. This referenced resource may be related to the Binary (e.g. DocumentReference), or may be some non-related Resource purely as a security proxy. E.g. to identify that the binary resource relates to a patient, and access should only be granted to applications that have access to the patient.
    property securityContextElement : TFhirReference read FSecurityContext write SetSecurityContext;

    // Typed access to The actual content, base64 encoded.
    property data : TBytes read GetDataST write SetDataST;
    // The actual content, base64 encoded.
    property dataElement : TFhirBase64Binary read FData write SetData;

  end;

  TFhirBinaryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBinaryList;
    function GetCurrent : TFhirBinary;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBinaryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBinary read GetCurrent;
  end;

  TFhirBinaryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBinary;
    procedure SetItemN(index : Integer; value : TFhirBinary);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBinaryList; overload;
    function Clone : TFhirBinaryList; overload;
    function GetEnumerator : TFhirBinaryListEnumerator;
    
    //  Add a FhirBinary to the end of the list.
    function Append : TFhirBinary;
    
    // Add an already existing FhirBinary to the end of the list.
    function AddItem(value : TFhirBinary) : TFhirBinary; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBinary) : Integer;
    
    // Insert FhirBinary before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBinary;
    
    // Insert an existing FhirBinary before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBinary);
    
    // Get the iIndexth FhirBinary. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBinary);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBinary;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBinaries[index : Integer] : TFhirBinary read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BUNDLE}
  // A series of links that provide context to this bundle.
  TFhirBundleLink = class (TFhirBackboneElement)
  protected
    FRelation : TFhirEnum;
    FUrl : TFhirUri;
    procedure SetRelation(value : TFhirEnum);
    function GetRelationST : TFhirLinkRelationTypesEnum;
    procedure SetRelationST(value : TFhirLinkRelationTypesEnum);
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundleLink; overload;
    function Clone : TFhirBundleLink; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A name which details the functional use for this link - see [http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1](http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1).
    property relation : TFhirLinkRelationTypesEnum read GetRelationST write SetRelationST;
    property relationElement : TFhirEnum read FRelation write SetRelation;

    // Typed access to The reference details for the link.
    property url : String read GetUrlST write SetUrlST;
    // The reference details for the link.
    property urlElement : TFhirUri read FUrl write SetUrl;

  end;

  TFhirBundleLinkListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleLinkList;
    function GetCurrent : TFhirBundleLink;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBundleLinkList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundleLink read GetCurrent;
  end;

  TFhirBundleLinkList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBundleLink;
    procedure SetItemN(index : Integer; value : TFhirBundleLink);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBundleLinkList; overload;
    function Clone : TFhirBundleLinkList; overload;
    function GetEnumerator : TFhirBundleLinkListEnumerator;
    
    //  Add a FhirBundleLink to the end of the list.
    function Append : TFhirBundleLink;
    
    // Add an already existing FhirBundleLink to the end of the list.
    function AddItem(value : TFhirBundleLink) : TFhirBundleLink; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundleLink) : Integer;
    
    // Insert FhirBundleLink before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundleLink;
    
    // Insert an existing FhirBundleLink before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundleLink);
    
    // Get the iIndexth FhirBundleLink. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundleLink);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBundleLink;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBundleLinks[index : Integer] : TFhirBundleLink read GetItemN write SetItemN; default;
  End;

  // An entry in a bundle resource - will either contain a resource or information about a resource (transactions and history only).
  TFhirBundleEntry = class (TFhirBackboneElement)
  protected
    Flink_List : TFhirBundleLinkList;
    FFullUrl : TFhirUri;
    FResource : TFhirResource;
    FSearch : TFhirBundleEntrySearch;
    FRequest : TFhirBundleEntryRequest;
    FResponse : TFhirBundleEntryResponse;
    function GetLink_List : TFhirBundleLinkList;
    function GetHasLink_List : Boolean;
    procedure SetFullUrl(value : TFhirUri);
    function GetFullUrlST : String;
    procedure SetFullUrlST(value : String);
    procedure SetResource(value : TFhirResource);
    procedure SetSearch(value : TFhirBundleEntrySearch);
    procedure SetRequest(value : TFhirBundleEntryRequest);
    procedure SetResponse(value : TFhirBundleEntryResponse);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundleEntry; overload;
    function Clone : TFhirBundleEntry; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A series of links that provide context to this entry.
    property link_List : TFhirBundleLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

    // Typed access to The Absolute URL for the resource.  The fullUrl SHALL NOT disagree with the id in the resource - i.e. if the fullUrl is not a urn:uuid, the URL shall be version-independent URL consistent with the Resource.id. The fullUrl is a version independent reference to the resource. Even when not required, fullUrl MAY be set to a urn:uuid to allow referencing entries in a transaction. The fullUrl can be an arbitrary URI and is not limited to urn:uuid, urn:oid, http, and https. The fullUrl element SHALL have a value except when:  * invoking a create * invoking or responding to an operation where the body is not a single identified resource * invoking or returning the results of a search or history operation.
    property fullUrl : String read GetFullUrlST write SetFullUrlST;
    // The Absolute URL for the resource.  The fullUrl SHALL NOT disagree with the id in the resource - i.e. if the fullUrl is not a urn:uuid, the URL shall be version-independent URL consistent with the Resource.id. The fullUrl is a version independent reference to the resource. Even when not required, fullUrl MAY be set to a urn:uuid to allow referencing entries in a transaction. The fullUrl can be an arbitrary URI and is not limited to urn:uuid, urn:oid, http, and https. The fullUrl element SHALL have a value except when:  * invoking a create * invoking or responding to an operation where the body is not a single identified resource * invoking or returning the results of a search or history operation.
    property fullUrlElement : TFhirUri read FFullUrl write SetFullUrl;

    // Typed access to The Resource for the entry. The purpose/meaning of the resource is determined by the Bundle.type. This is allowed to be a Parameters resource if and only if it is referenced by something else within the Bundle that provides context/meaning. (defined for API consistency)
    property resource : TFhirResource read FResource write SetResource;
    // The Resource for the entry. The purpose/meaning of the resource is determined by the Bundle.type. This is allowed to be a Parameters resource if and only if it is referenced by something else within the Bundle that provides context/meaning.
    property resourceElement : TFhirResource read FResource write SetResource;

    // Typed access to Information about the search process that lead to the creation of this entry. (defined for API consistency)
    property search : TFhirBundleEntrySearch read FSearch write SetSearch;
    // Information about the search process that lead to the creation of this entry.
    property searchElement : TFhirBundleEntrySearch read FSearch write SetSearch;

    // Typed access to Additional information about how this entry should be processed as part of a transaction or batch.  For history, it shows how the entry was processed to create the version contained in the entry. (defined for API consistency)
    property request : TFhirBundleEntryRequest read FRequest write SetRequest;
    // Additional information about how this entry should be processed as part of a transaction or batch.  For history, it shows how the entry was processed to create the version contained in the entry.
    property requestElement : TFhirBundleEntryRequest read FRequest write SetRequest;

    // Typed access to Indicates the results of processing the corresponding 'request' entry in the batch or transaction being responded to or what the results of an operation where when returning history. (defined for API consistency)
    property response : TFhirBundleEntryResponse read FResponse write SetResponse;
    // Indicates the results of processing the corresponding 'request' entry in the batch or transaction being responded to or what the results of an operation where when returning history.
    property responseElement : TFhirBundleEntryResponse read FResponse write SetResponse;

  end;

  TFhirBundleEntryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleEntryList;
    function GetCurrent : TFhirBundleEntry;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBundleEntryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundleEntry read GetCurrent;
  end;

  TFhirBundleEntryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBundleEntry;
    procedure SetItemN(index : Integer; value : TFhirBundleEntry);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBundleEntryList; overload;
    function Clone : TFhirBundleEntryList; overload;
    function GetEnumerator : TFhirBundleEntryListEnumerator;
    
    //  Add a FhirBundleEntry to the end of the list.
    function Append : TFhirBundleEntry;
    
    // Add an already existing FhirBundleEntry to the end of the list.
    function AddItem(value : TFhirBundleEntry) : TFhirBundleEntry; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundleEntry) : Integer;
    
    // Insert FhirBundleEntry before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundleEntry;
    
    // Insert an existing FhirBundleEntry before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundleEntry);
    
    // Get the iIndexth FhirBundleEntry. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundleEntry);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBundleEntry;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBundleEntries[index : Integer] : TFhirBundleEntry read GetItemN write SetItemN; default;
  End;

  // Information about the search process that lead to the creation of this entry.
  TFhirBundleEntrySearch = class (TFhirBackboneElement)
  protected
    FMode : TFhirEnum;
    FScore : TFhirDecimal;
    procedure SetMode(value : TFhirEnum);
    function GetModeST : TFhirSearchEntryModeEnum;
    procedure SetModeST(value : TFhirSearchEntryModeEnum);
    procedure SetScore(value : TFhirDecimal);
    function GetScoreST : String;
    procedure SetScoreST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundleEntrySearch; overload;
    function Clone : TFhirBundleEntrySearch; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Why this entry is in the result set - whether it's included as a match or because of an _include requirement, or to convey information or warning information about the search process.
    property mode : TFhirSearchEntryModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to When searching, the server's search ranking score for the entry.
    property score : String read GetScoreST write SetScoreST;
    // When searching, the server's search ranking score for the entry.
    property scoreElement : TFhirDecimal read FScore write SetScore;

  end;

  TFhirBundleEntrySearchListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleEntrySearchList;
    function GetCurrent : TFhirBundleEntrySearch;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBundleEntrySearchList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundleEntrySearch read GetCurrent;
  end;

  TFhirBundleEntrySearchList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBundleEntrySearch;
    procedure SetItemN(index : Integer; value : TFhirBundleEntrySearch);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBundleEntrySearchList; overload;
    function Clone : TFhirBundleEntrySearchList; overload;
    function GetEnumerator : TFhirBundleEntrySearchListEnumerator;
    
    //  Add a FhirBundleEntrySearch to the end of the list.
    function Append : TFhirBundleEntrySearch;
    
    // Add an already existing FhirBundleEntrySearch to the end of the list.
    function AddItem(value : TFhirBundleEntrySearch) : TFhirBundleEntrySearch; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundleEntrySearch) : Integer;
    
    // Insert FhirBundleEntrySearch before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundleEntrySearch;
    
    // Insert an existing FhirBundleEntrySearch before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundleEntrySearch);
    
    // Get the iIndexth FhirBundleEntrySearch. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundleEntrySearch);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBundleEntrySearch;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBundleEntrySearches[index : Integer] : TFhirBundleEntrySearch read GetItemN write SetItemN; default;
  End;

  // Additional information about how this entry should be processed as part of a transaction or batch.  For history, it shows how the entry was processed to create the version contained in the entry.
  TFhirBundleEntryRequest = class (TFhirBackboneElement)
  protected
    FMethod : TFhirEnum;
    FUrl : TFhirUri;
    FIfNoneMatch : TFhirString;
    FIfModifiedSince : TFhirInstant;
    FIfMatch : TFhirString;
    FIfNoneExist : TFhirString;
    procedure SetMethod(value : TFhirEnum);
    function GetMethodST : TFhirHTTPVerbEnum;
    procedure SetMethodST(value : TFhirHTTPVerbEnum);
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    procedure SetIfNoneMatch(value : TFhirString);
    function GetIfNoneMatchST : String;
    procedure SetIfNoneMatchST(value : String);
    procedure SetIfModifiedSince(value : TFhirInstant);
    function GetIfModifiedSinceST : TFslDateTime;
    procedure SetIfModifiedSinceST(value : TFslDateTime);
    procedure SetIfMatch(value : TFhirString);
    function GetIfMatchST : String;
    procedure SetIfMatchST(value : String);
    procedure SetIfNoneExist(value : TFhirString);
    function GetIfNoneExistST : String;
    procedure SetIfNoneExistST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundleEntryRequest; overload;
    function Clone : TFhirBundleEntryRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // In a transaction or batch, this is the HTTP action to be executed for this entry. In a history bundle, this indicates the HTTP action that occurred.
    property method : TFhirHTTPVerbEnum read GetMethodST write SetMethodST;
    property methodElement : TFhirEnum read FMethod write SetMethod;

    // Typed access to The URL for this entry, relative to the root (the address to which the request is posted).
    property url : String read GetUrlST write SetUrlST;
    // The URL for this entry, relative to the root (the address to which the request is posted).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to If the ETag values match, return a 304 Not Modified status. See the API documentation for ["Conditional Read"](http.html#cread).
    property ifNoneMatch : String read GetIfNoneMatchST write SetIfNoneMatchST;
    // If the ETag values match, return a 304 Not Modified status. See the API documentation for ["Conditional Read"](http.html#cread).
    property ifNoneMatchElement : TFhirString read FIfNoneMatch write SetIfNoneMatch;

    // Typed access to Only perform the operation if the last updated date matches. See the API documentation for ["Conditional Read"](http.html#cread).
    property ifModifiedSince : TFslDateTime read GetIfModifiedSinceST write SetIfModifiedSinceST;
    // Only perform the operation if the last updated date matches. See the API documentation for ["Conditional Read"](http.html#cread).
    property ifModifiedSinceElement : TFhirInstant read FIfModifiedSince write SetIfModifiedSince;

    // Typed access to Only perform the operation if the Etag value matches. For more information, see the API section ["Managing Resource Contention"](http.html#concurrency).
    property ifMatch : String read GetIfMatchST write SetIfMatchST;
    // Only perform the operation if the Etag value matches. For more information, see the API section ["Managing Resource Contention"](http.html#concurrency).
    property ifMatchElement : TFhirString read FIfMatch write SetIfMatch;

    // Typed access to Instruct the server not to perform the create if a specified resource already exists. For further information, see the API documentation for ["Conditional Create"](http.html#ccreate). This is just the query portion of the URL - what follows the "?" (not including the "?").
    property ifNoneExist : String read GetIfNoneExistST write SetIfNoneExistST;
    // Instruct the server not to perform the create if a specified resource already exists. For further information, see the API documentation for ["Conditional Create"](http.html#ccreate). This is just the query portion of the URL - what follows the "?" (not including the "?").
    property ifNoneExistElement : TFhirString read FIfNoneExist write SetIfNoneExist;

  end;

  TFhirBundleEntryRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleEntryRequestList;
    function GetCurrent : TFhirBundleEntryRequest;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBundleEntryRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundleEntryRequest read GetCurrent;
  end;

  TFhirBundleEntryRequestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBundleEntryRequest;
    procedure SetItemN(index : Integer; value : TFhirBundleEntryRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBundleEntryRequestList; overload;
    function Clone : TFhirBundleEntryRequestList; overload;
    function GetEnumerator : TFhirBundleEntryRequestListEnumerator;
    
    //  Add a FhirBundleEntryRequest to the end of the list.
    function Append : TFhirBundleEntryRequest;
    
    // Add an already existing FhirBundleEntryRequest to the end of the list.
    function AddItem(value : TFhirBundleEntryRequest) : TFhirBundleEntryRequest; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundleEntryRequest) : Integer;
    
    // Insert FhirBundleEntryRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundleEntryRequest;
    
    // Insert an existing FhirBundleEntryRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundleEntryRequest);
    
    // Get the iIndexth FhirBundleEntryRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundleEntryRequest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBundleEntryRequest;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBundleEntryRequests[index : Integer] : TFhirBundleEntryRequest read GetItemN write SetItemN; default;
  End;

  // Indicates the results of processing the corresponding 'request' entry in the batch or transaction being responded to or what the results of an operation where when returning history.
  TFhirBundleEntryResponse = class (TFhirBackboneElement)
  protected
    FStatus : TFhirString;
    FLocation : TFhirUri;
    FEtag : TFhirString;
    FLastModified : TFhirInstant;
    FOutcome : TFhirResource;
    procedure SetStatus(value : TFhirString);
    function GetStatusST : String;
    procedure SetStatusST(value : String);
    procedure SetLocation(value : TFhirUri);
    function GetLocationST : String;
    procedure SetLocationST(value : String);
    procedure SetEtag(value : TFhirString);
    function GetEtagST : String;
    procedure SetEtagST(value : String);
    procedure SetLastModified(value : TFhirInstant);
    function GetLastModifiedST : TFslDateTime;
    procedure SetLastModifiedST(value : TFslDateTime);
    procedure SetOutcome(value : TFhirResource);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundleEntryResponse; overload;
    function Clone : TFhirBundleEntryResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The status code returned by processing this entry. The status SHALL start with a 3 digit HTTP code (e.g. 404) and may contain the standard HTTP description associated with the status code.
    property status : String read GetStatusST write SetStatusST;
    // The status code returned by processing this entry. The status SHALL start with a 3 digit HTTP code (e.g. 404) and may contain the standard HTTP description associated with the status code.
    property statusElement : TFhirString read FStatus write SetStatus;

    // Typed access to The location header created by processing this operation, populated if the operation returns a location.
    property location : String read GetLocationST write SetLocationST;
    // The location header created by processing this operation, populated if the operation returns a location.
    property locationElement : TFhirUri read FLocation write SetLocation;

    // Typed access to The Etag for the resource, if the operation for the entry produced a versioned resource (see [Resource Metadata and Versioning](http.html#versioning) and [Managing Resource Contention](http.html#concurrency)).
    property etag : String read GetEtagST write SetEtagST;
    // The Etag for the resource, if the operation for the entry produced a versioned resource (see [Resource Metadata and Versioning](http.html#versioning) and [Managing Resource Contention](http.html#concurrency)).
    property etagElement : TFhirString read FEtag write SetEtag;

    // Typed access to The date/time that the resource was modified on the server.
    property lastModified : TFslDateTime read GetLastModifiedST write SetLastModifiedST;
    // The date/time that the resource was modified on the server.
    property lastModifiedElement : TFhirInstant read FLastModified write SetLastModified;

    // Typed access to An OperationOutcome containing hints and warnings produced as part of processing this entry in a batch or transaction. (defined for API consistency)
    property outcome : TFhirResource read FOutcome write SetOutcome;
    // An OperationOutcome containing hints and warnings produced as part of processing this entry in a batch or transaction.
    property outcomeElement : TFhirResource read FOutcome write SetOutcome;

  end;

  TFhirBundleEntryResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleEntryResponseList;
    function GetCurrent : TFhirBundleEntryResponse;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBundleEntryResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundleEntryResponse read GetCurrent;
  end;

  TFhirBundleEntryResponseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBundleEntryResponse;
    procedure SetItemN(index : Integer; value : TFhirBundleEntryResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBundleEntryResponseList; overload;
    function Clone : TFhirBundleEntryResponseList; overload;
    function GetEnumerator : TFhirBundleEntryResponseListEnumerator;
    
    //  Add a FhirBundleEntryResponse to the end of the list.
    function Append : TFhirBundleEntryResponse;
    
    // Add an already existing FhirBundleEntryResponse to the end of the list.
    function AddItem(value : TFhirBundleEntryResponse) : TFhirBundleEntryResponse; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundleEntryResponse) : Integer;
    
    // Insert FhirBundleEntryResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundleEntryResponse;
    
    // Insert an existing FhirBundleEntryResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundleEntryResponse);
    
    // Get the iIndexth FhirBundleEntryResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundleEntryResponse);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBundleEntryResponse;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBundleEntryResponses[index : Integer] : TFhirBundleEntryResponse read GetItemN write SetItemN; default;
  End;

  // A container for a collection of resources.
  TFhirBundle = class (TFhirResource)
  protected
    FIdentifier : TFhirIdentifier;
    FType_ : TFhirEnum;
    FTimestamp : TFhirInstant;
    FTotal : TFhirUnsignedInt;
    Flink_List : TFhirBundleLinkList;
    FentryList : TFhirBundleEntryList;
    FSignature : TFhirSignature;
    FIssues : TFhirResource;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirBundleTypeEnum;
    procedure SetType_ST(value : TFhirBundleTypeEnum);
    procedure SetTimestamp(value : TFhirInstant);
    function GetTimestampST : TFslDateTime;
    procedure SetTimestampST(value : TFslDateTime);
    procedure SetTotal(value : TFhirUnsignedInt);
    function GetTotalST : String;
    procedure SetTotalST(value : String);
    function GetLink_List : TFhirBundleLinkList;
    function GetHasLink_List : Boolean;
    function GetEntryList : TFhirBundleEntryList;
    function GetHasEntryList : Boolean;
    procedure SetSignature(value : TFhirSignature);
    procedure SetIssues(value : TFhirResource);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundle; overload;
    function Clone : TFhirBundle; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A persistent identifier for the bundle that won't change as a bundle is copied from server to server. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // A persistent identifier for the bundle that won't change as a bundle is copied from server to server.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Indicates the purpose of this bundle - how it is intended to be used.
    property type_ : TFhirBundleTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The date/time that the bundle was assembled - i.e. when the resources were placed in the bundle.
    property timestamp : TFslDateTime read GetTimestampST write SetTimestampST;
    // The date/time that the bundle was assembled - i.e. when the resources were placed in the bundle.
    property timestampElement : TFhirInstant read FTimestamp write SetTimestamp;

    // Typed access to If a set of search matches, this is the (potentially estimated) total number of entries of type 'match' across all pages in the search.  It does not include search.mode = 'include' or 'outcome' entries and it does not provide a count of the number of entries in the Bundle.
    property total : String read GetTotalST write SetTotalST;
    // If a set of search matches, this is the (potentially estimated) total number of entries of type 'match' across all pages in the search.  It does not include search.mode = 'include' or 'outcome' entries and it does not provide a count of the number of entries in the Bundle.
    property totalElement : TFhirUnsignedInt read FTotal write SetTotal;

    // A series of links that provide context to this bundle.
    property link_List : TFhirBundleLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

    // An entry in a bundle resource - will either contain a resource or information about a resource (transactions and history only).
    property entryList : TFhirBundleEntryList read GetEntryList;
    property hasEntryList : boolean read GetHasEntryList;

    // Typed access to Digital Signature - base64 encoded. XML-DSig or a JWS. (defined for API consistency)
    property signature : TFhirSignature read FSignature write SetSignature;
    // Digital Signature - base64 encoded. XML-DSig or a JWS.
    property signatureElement : TFhirSignature read FSignature write SetSignature;

    // Typed access to Captures issues and warnings that relate to the construction of the Bundle and the content within it. (defined for API consistency)
    property issues : TFhirResource read FIssues write SetIssues;
    // Captures issues and warnings that relate to the construction of the Bundle and the content within it.
    property issuesElement : TFhirResource read FIssues write SetIssues;

  end;

  TFhirBundleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleList;
    function GetCurrent : TFhirBundle;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBundleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundle read GetCurrent;
  end;

  TFhirBundleList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBundle;
    procedure SetItemN(index : Integer; value : TFhirBundle);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBundleList; overload;
    function Clone : TFhirBundleList; overload;
    function GetEnumerator : TFhirBundleListEnumerator;
    
    //  Add a FhirBundle to the end of the list.
    function Append : TFhirBundle;
    
    // Add an already existing FhirBundle to the end of the list.
    function AddItem(value : TFhirBundle) : TFhirBundle; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundle) : Integer;
    
    // Insert FhirBundle before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundle;
    
    // Insert an existing FhirBundle before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundle);
    
    // Get the iIndexth FhirBundle. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundle);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBundle;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBundles[index : Integer] : TFhirBundle read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CONSENT}
  // A Reference or URL used to uniquely identify the policy the organization will enforce for this Consent. This Reference or URL should be specific to the version of the policy and should be dereferencable to a computable policy of some form.
  TFhirConsentPolicyBasis = class (TFhirBackboneElement)
  protected
    FReference : TFhirReference;
    FUrl : TFhirUrl;
    procedure SetReference(value : TFhirReference);
    procedure SetUrl(value : TFhirUrl);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConsentPolicyBasis; overload;
    function Clone : TFhirConsentPolicyBasis; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A Reference that identifies the policy the organization will enforce for this Consent. (defined for API consistency)
    property reference : TFhirReference read FReference write SetReference;
    // A Reference that identifies the policy the organization will enforce for this Consent.
    property referenceElement : TFhirReference read FReference write SetReference;

    // Typed access to A URL that links to a computable version of the policy the organization will enforce for this Consent.
    property url : String read GetUrlST write SetUrlST;
    // A URL that links to a computable version of the policy the organization will enforce for this Consent.
    property urlElement : TFhirUrl read FUrl write SetUrl;

  end;

  TFhirConsentPolicyBasisListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConsentPolicyBasisList;
    function GetCurrent : TFhirConsentPolicyBasis;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirConsentPolicyBasisList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConsentPolicyBasis read GetCurrent;
  end;

  TFhirConsentPolicyBasisList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConsentPolicyBasis;
    procedure SetItemN(index : Integer; value : TFhirConsentPolicyBasis);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirConsentPolicyBasisList; overload;
    function Clone : TFhirConsentPolicyBasisList; overload;
    function GetEnumerator : TFhirConsentPolicyBasisListEnumerator;
    
    //  Add a FhirConsentPolicyBasis to the end of the list.
    function Append : TFhirConsentPolicyBasis;
    
    // Add an already existing FhirConsentPolicyBasis to the end of the list.
    function AddItem(value : TFhirConsentPolicyBasis) : TFhirConsentPolicyBasis; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConsentPolicyBasis) : Integer;
    
    // Insert FhirConsentPolicyBasis before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConsentPolicyBasis;
    
    // Insert an existing FhirConsentPolicyBasis before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConsentPolicyBasis);
    
    // Get the iIndexth FhirConsentPolicyBasis. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConsentPolicyBasis);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConsentPolicyBasis;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirConsentPolicyBases[index : Integer] : TFhirConsentPolicyBasis read GetItemN write SetItemN; default;
  End;

  // Whether a treatment instruction (e.g. artificial respiration: yes or no) was verified with the patient, his/her family or another authorized person.
  TFhirConsentVerification = class (TFhirBackboneElement)
  protected
    FVerified : TFhirBoolean;
    FVerificationType : TFhirCodeableConcept;
    FVerifiedBy : TFhirReference;
    FVerifiedWith : TFhirReference;
    FverificationDateList : TFhirDateTimeList;
    procedure SetVerified(value : TFhirBoolean);
    function GetVerifiedST : Boolean;
    procedure SetVerifiedST(value : Boolean);
    procedure SetVerificationType(value : TFhirCodeableConcept);
    procedure SetVerifiedBy(value : TFhirReference);
    procedure SetVerifiedWith(value : TFhirReference);
    function GetVerificationDateList : TFhirDateTimeList;
    function GetHasVerificationDateList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConsentVerification; overload;
    function Clone : TFhirConsentVerification; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Has the instruction been verified.
    property verified : Boolean read GetVerifiedST write SetVerifiedST;
    // Has the instruction been verified.
    property verifiedElement : TFhirBoolean read FVerified write SetVerified;

    // Typed access to Extensible list of verification type starting with verification and re-validation. (defined for API consistency)
    property verificationType : TFhirCodeableConcept read FVerificationType write SetVerificationType;
    // Extensible list of verification type starting with verification and re-validation.
    property verificationTypeElement : TFhirCodeableConcept read FVerificationType write SetVerificationType;

    // Typed access to The person who conducted the verification/validation of the Grantor decision. (defined for API consistency)
    property verifiedBy : TFhirReference read FVerifiedBy write SetVerifiedBy;
    // The person who conducted the verification/validation of the Grantor decision.
    property verifiedByElement : TFhirReference read FVerifiedBy write SetVerifiedBy;

    // Typed access to Who verified the instruction (Patient, Relative or other Authorized Person). (defined for API consistency)
    property verifiedWith : TFhirReference read FVerifiedWith write SetVerifiedWith;
    // Who verified the instruction (Patient, Relative or other Authorized Person).
    property verifiedWithElement : TFhirReference read FVerifiedWith write SetVerifiedWith;

    // Date(s) verification was collected.
    property verificationDateList : TFhirDateTimeList read GetVerificationDateList;
    property hasVerificationDateList : boolean read GetHasVerificationDateList;

  end;

  TFhirConsentVerificationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConsentVerificationList;
    function GetCurrent : TFhirConsentVerification;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirConsentVerificationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConsentVerification read GetCurrent;
  end;

  TFhirConsentVerificationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConsentVerification;
    procedure SetItemN(index : Integer; value : TFhirConsentVerification);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirConsentVerificationList; overload;
    function Clone : TFhirConsentVerificationList; overload;
    function GetEnumerator : TFhirConsentVerificationListEnumerator;
    
    //  Add a FhirConsentVerification to the end of the list.
    function Append : TFhirConsentVerification;
    
    // Add an already existing FhirConsentVerification to the end of the list.
    function AddItem(value : TFhirConsentVerification) : TFhirConsentVerification; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConsentVerification) : Integer;
    
    // Insert FhirConsentVerification before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConsentVerification;
    
    // Insert an existing FhirConsentVerification before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConsentVerification);
    
    // Get the iIndexth FhirConsentVerification. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConsentVerification);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConsentVerification;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirConsentVerifications[index : Integer] : TFhirConsentVerification read GetItemN write SetItemN; default;
  End;

  // An exception to the base policy of this consent. An exception can be an addition or removal of access permissions.
  TFhirConsentProvision = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FPeriod : TFhirPeriod;
    FactorList : TFhirConsentProvisionActorList;
    FactionList : TFhirCodeableConceptList;
    FsecurityLabelList : TFhirCodingList;
    FpurposeList : TFhirCodingList;
    Fclass_List : TFhirCodingList;
    FcodeList : TFhirCodeableConceptList;
    FDataPeriod : TFhirPeriod;
    FdataList : TFhirConsentProvisionDataList;
    FExpression : TFhirExpression;
    FprovisionList : TFhirConsentProvisionList;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirConsentProvisionTypeEnum;
    procedure SetType_ST(value : TFhirConsentProvisionTypeEnum);
    procedure SetPeriod(value : TFhirPeriod);
    function GetActorList : TFhirConsentProvisionActorList;
    function GetHasActorList : Boolean;
    function GetActionList : TFhirCodeableConceptList;
    function GetHasActionList : Boolean;
    function GetSecurityLabelList : TFhirCodingList;
    function GetHasSecurityLabelList : Boolean;
    function GetPurposeList : TFhirCodingList;
    function GetHasPurposeList : Boolean;
    function GetClass_List : TFhirCodingList;
    function GetHasClass_List : Boolean;
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    procedure SetDataPeriod(value : TFhirPeriod);
    function GetDataList : TFhirConsentProvisionDataList;
    function GetHasDataList : Boolean;
    procedure SetExpression(value : TFhirExpression);
    function GetProvisionList : TFhirConsentProvisionList;
    function GetHasProvisionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConsentProvision; overload;
    function Clone : TFhirConsentProvision; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Action  to take - permit or deny - when the rule conditions are met.  Not permitted in root rule, required in all nested rules.
    property type_ : TFhirConsentProvisionTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The timeframe in this rule is valid. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The timeframe in this rule is valid.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Who or what is controlled by this rule. Use group to identify a set of actors by some property they share (e.g. 'admitting officers').
    property actorList : TFhirConsentProvisionActorList read GetActorList;
    property hasActorList : boolean read GetHasActorList;

    // Actions controlled by this Rule.
    property actionList : TFhirCodeableConceptList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

    // A security label, comprised of 0..* security label fields (Privacy tags), which define which resources are controlled by this exception.
    property securityLabelList : TFhirCodingList read GetSecurityLabelList;
    property hasSecurityLabelList : boolean read GetHasSecurityLabelList;

    // The context of the activities a user is taking - why the user is accessing the data - that are controlled by this rule.
    property purposeList : TFhirCodingList read GetPurposeList;
    property hasPurposeList : boolean read GetHasPurposeList;

    // The class of information covered by this rule. The type can be a FHIR resource type, a profile on a type, or a CDA document, or some other type that indicates what sort of information the consent relates to.
    property class_List : TFhirCodingList read GetClass_List;
    property hasClass_List : boolean read GetHasClass_List;

    // If this code is found in an instance, then the rule applies.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Typed access to Clinical or Operational Relevant period of time that bounds the data controlled by this rule. (defined for API consistency)
    property dataPeriod : TFhirPeriod read FDataPeriod write SetDataPeriod;
    // Clinical or Operational Relevant period of time that bounds the data controlled by this rule.
    property dataPeriodElement : TFhirPeriod read FDataPeriod write SetDataPeriod;

    // The resources controlled by this rule if specific resources are referenced.
    property dataList : TFhirConsentProvisionDataList read GetDataList;
    property hasDataList : boolean read GetHasDataList;

    // Typed access to A computable (FHIRPath or other) definition of what is controlled by this consent. (defined for API consistency)
    property expression : TFhirExpression read FExpression write SetExpression;
    // A computable (FHIRPath or other) definition of what is controlled by this consent.
    property expressionElement : TFhirExpression read FExpression write SetExpression;

    // Rules which provide exceptions to the base rule or subrules.
    property provisionList : TFhirConsentProvisionList read GetProvisionList;
    property hasProvisionList : boolean read GetHasProvisionList;

  end;

  TFhirConsentProvisionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConsentProvisionList;
    function GetCurrent : TFhirConsentProvision;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirConsentProvisionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConsentProvision read GetCurrent;
  end;

  TFhirConsentProvisionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConsentProvision;
    procedure SetItemN(index : Integer; value : TFhirConsentProvision);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirConsentProvisionList; overload;
    function Clone : TFhirConsentProvisionList; overload;
    function GetEnumerator : TFhirConsentProvisionListEnumerator;
    
    //  Add a FhirConsentProvision to the end of the list.
    function Append : TFhirConsentProvision;
    
    // Add an already existing FhirConsentProvision to the end of the list.
    function AddItem(value : TFhirConsentProvision) : TFhirConsentProvision; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConsentProvision) : Integer;
    
    // Insert FhirConsentProvision before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConsentProvision;
    
    // Insert an existing FhirConsentProvision before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConsentProvision);
    
    // Get the iIndexth FhirConsentProvision. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConsentProvision);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConsentProvision;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirConsentProvisions[index : Integer] : TFhirConsentProvision read GetItemN write SetItemN; default;
  End;

  // Who or what is controlled by this rule. Use group to identify a set of actors by some property they share (e.g. 'admitting officers').
  TFhirConsentProvisionActor = class (TFhirBackboneElement)
  protected
    FRole : TFhirCodeableConcept;
    FReference : TFhirReference;
    procedure SetRole(value : TFhirCodeableConcept);
    procedure SetReference(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConsentProvisionActor; overload;
    function Clone : TFhirConsentProvisionActor; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to How the individual is involved in the resources content that is described in the exception. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // How the individual is involved in the resources content that is described in the exception.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to The resource that identifies the actor. To identify actors by type, use group to identify a set of actors by some property they share (e.g. 'admitting officers'). (defined for API consistency)
    property reference : TFhirReference read FReference write SetReference;
    // The resource that identifies the actor. To identify actors by type, use group to identify a set of actors by some property they share (e.g. 'admitting officers').
    property referenceElement : TFhirReference read FReference write SetReference;

  end;

  TFhirConsentProvisionActorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConsentProvisionActorList;
    function GetCurrent : TFhirConsentProvisionActor;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirConsentProvisionActorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConsentProvisionActor read GetCurrent;
  end;

  TFhirConsentProvisionActorList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConsentProvisionActor;
    procedure SetItemN(index : Integer; value : TFhirConsentProvisionActor);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirConsentProvisionActorList; overload;
    function Clone : TFhirConsentProvisionActorList; overload;
    function GetEnumerator : TFhirConsentProvisionActorListEnumerator;
    
    //  Add a FhirConsentProvisionActor to the end of the list.
    function Append : TFhirConsentProvisionActor;
    
    // Add an already existing FhirConsentProvisionActor to the end of the list.
    function AddItem(value : TFhirConsentProvisionActor) : TFhirConsentProvisionActor; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConsentProvisionActor) : Integer;
    
    // Insert FhirConsentProvisionActor before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConsentProvisionActor;
    
    // Insert an existing FhirConsentProvisionActor before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConsentProvisionActor);
    
    // Get the iIndexth FhirConsentProvisionActor. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConsentProvisionActor);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConsentProvisionActor;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirConsentProvisionActors[index : Integer] : TFhirConsentProvisionActor read GetItemN write SetItemN; default;
  End;

  // The resources controlled by this rule if specific resources are referenced.
  TFhirConsentProvisionData = class (TFhirBackboneElement)
  protected
    FMeaning : TFhirEnum;
    FReference : TFhirReference;
    procedure SetMeaning(value : TFhirEnum);
    function GetMeaningST : TFhirConsentDataMeaningEnum;
    procedure SetMeaningST(value : TFhirConsentDataMeaningEnum);
    procedure SetReference(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConsentProvisionData; overload;
    function Clone : TFhirConsentProvisionData; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // How the resource reference is interpreted when testing consent restrictions.
    property meaning : TFhirConsentDataMeaningEnum read GetMeaningST write SetMeaningST;
    property meaningElement : TFhirEnum read FMeaning write SetMeaning;

    // Typed access to A reference to a specific resource that defines which resources are covered by this consent. (defined for API consistency)
    property reference : TFhirReference read FReference write SetReference;
    // A reference to a specific resource that defines which resources are covered by this consent.
    property referenceElement : TFhirReference read FReference write SetReference;

  end;

  TFhirConsentProvisionDataListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConsentProvisionDataList;
    function GetCurrent : TFhirConsentProvisionData;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirConsentProvisionDataList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConsentProvisionData read GetCurrent;
  end;

  TFhirConsentProvisionDataList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConsentProvisionData;
    procedure SetItemN(index : Integer; value : TFhirConsentProvisionData);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirConsentProvisionDataList; overload;
    function Clone : TFhirConsentProvisionDataList; overload;
    function GetEnumerator : TFhirConsentProvisionDataListEnumerator;
    
    //  Add a FhirConsentProvisionData to the end of the list.
    function Append : TFhirConsentProvisionData;
    
    // Add an already existing FhirConsentProvisionData to the end of the list.
    function AddItem(value : TFhirConsentProvisionData) : TFhirConsentProvisionData; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConsentProvisionData) : Integer;
    
    // Insert FhirConsentProvisionData before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConsentProvisionData;
    
    // Insert an existing FhirConsentProvisionData before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConsentProvisionData);
    
    // Get the iIndexth FhirConsentProvisionData. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConsentProvisionData);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConsentProvisionData;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirConsentProvisionData[index : Integer] : TFhirConsentProvisionData read GetItemN write SetItemN; default;
  End;

  // A record of a healthcare consumer’s  choices  or choices made on their behalf by a third party, which permits or denies identified recipient(s) or recipient role(s) to perform one or more actions within a given policy context, for specific purposes and periods of time.
  TFhirConsent = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FSubject : TFhirReference;
    FDateTime : TFhirDateTime;
    FgrantorList : TFhirReferenceList;
    FgranteeList : TFhirReferenceList;
    FmanagerList : TFhirReferenceList;
    FcontrollerList : TFhirReferenceList;
    FsourceAttachmentList : TFhirAttachmentList;
    FsourceReferenceList : TFhirReferenceList;
    FregulatoryBasisList : TFhirCodeableConceptList;
    FPolicyBasis : TFhirConsentPolicyBasis;
    FpolicyTextList : TFhirReferenceList;
    FverificationList : TFhirConsentVerificationList;
    FProvision : TFhirConsentProvision;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirConsentStateEnum;
    procedure SetStatusST(value : TFhirConsentStateEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetSubject(value : TFhirReference);
    procedure SetDateTime(value : TFhirDateTime);
    function GetDateTimeST : TFslDateTime;
    procedure SetDateTimeST(value : TFslDateTime);
    function GetGrantorList : TFhirReferenceList;
    function GetHasGrantorList : Boolean;
    function GetGranteeList : TFhirReferenceList;
    function GetHasGranteeList : Boolean;
    function GetManagerList : TFhirReferenceList;
    function GetHasManagerList : Boolean;
    function GetControllerList : TFhirReferenceList;
    function GetHasControllerList : Boolean;
    function GetSourceAttachmentList : TFhirAttachmentList;
    function GetHasSourceAttachmentList : Boolean;
    function GetSourceReferenceList : TFhirReferenceList;
    function GetHasSourceReferenceList : Boolean;
    function GetRegulatoryBasisList : TFhirCodeableConceptList;
    function GetHasRegulatoryBasisList : Boolean;
    procedure SetPolicyBasis(value : TFhirConsentPolicyBasis);
    function GetPolicyTextList : TFhirReferenceList;
    function GetHasPolicyTextList : Boolean;
    function GetVerificationList : TFhirConsentVerificationList;
    function GetHasVerificationList : Boolean;
    procedure SetProvision(value : TFhirConsentProvision);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConsent; overload;
    function Clone : TFhirConsent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique identifier for this copy of the Consent Statement.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Indicates the current state of this Consent resource.
    property status : TFhirConsentStateEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // A classification of the type of consents found in the statement. This element supports indexing and retrieval of consent statements.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to The patient/healthcare practitioner or group of persons to whom this consent applies. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The patient/healthcare practitioner or group of persons to whom this consent applies.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to Date and time the consent instance was agreed to.
    property dateTime : TFslDateTime read GetDateTimeST write SetDateTimeST;
    // Date and time the consent instance was agreed to.
    property dateTimeElement : TFhirDateTime read FDateTime write SetDateTime;

    // The entity responsible for granting the rights listed in a Consent Directive.
    property grantorList : TFhirReferenceList read GetGrantorList;
    property hasGrantorList : boolean read GetHasGrantorList;

    // The entity responsible for complying with the Consent Directive, including any obligations or limitations on authorizations and enforcement of prohibitions.
    property granteeList : TFhirReferenceList read GetGranteeList;
    property hasGranteeList : boolean read GetHasGranteeList;

    // The actor that manages the consent through its lifecycle.
    property managerList : TFhirReferenceList read GetManagerList;
    property hasManagerList : boolean read GetHasManagerList;

    // The actor that controls/enforces the access according to the consent.
    property controllerList : TFhirReferenceList read GetControllerList;
    property hasControllerList : boolean read GetHasControllerList;

    // The source on which this consent statement is based. The source might be a scanned original paper form.
    property sourceAttachmentList : TFhirAttachmentList read GetSourceAttachmentList;
    property hasSourceAttachmentList : boolean read GetHasSourceAttachmentList;

    // A reference to a consent that links back to such a source, a reference to a document repository (e.g. XDS) that stores the original consent document.
    property sourceReferenceList : TFhirReferenceList read GetSourceReferenceList;
    property hasSourceReferenceList : boolean read GetHasSourceReferenceList;

    // A set of codes that indicate the regulatory basis (if any) that this consent supports.
    property regulatoryBasisList : TFhirCodeableConceptList read GetRegulatoryBasisList;
    property hasRegulatoryBasisList : boolean read GetHasRegulatoryBasisList;

    // Typed access to A Reference or URL used to uniquely identify the policy the organization will enforce for this Consent. This Reference or URL should be specific to the version of the policy and should be dereferencable to a computable policy of some form. (defined for API consistency)
    property policyBasis : TFhirConsentPolicyBasis read FPolicyBasis write SetPolicyBasis;
    // A Reference or URL used to uniquely identify the policy the organization will enforce for this Consent. This Reference or URL should be specific to the version of the policy and should be dereferencable to a computable policy of some form.
    property policyBasisElement : TFhirConsentPolicyBasis read FPolicyBasis write SetPolicyBasis;

    // A Reference to the human readable policy explaining the basis for the Consent.
    property policyTextList : TFhirReferenceList read GetPolicyTextList;
    property hasPolicyTextList : boolean read GetHasPolicyTextList;

    // Whether a treatment instruction (e.g. artificial respiration: yes or no) was verified with the patient, his/her family or another authorized person.
    property verificationList : TFhirConsentVerificationList read GetVerificationList;
    property hasVerificationList : boolean read GetHasVerificationList;

    // Typed access to An exception to the base policy of this consent. An exception can be an addition or removal of access permissions. (defined for API consistency)
    property provision : TFhirConsentProvision read FProvision write SetProvision;
    // An exception to the base policy of this consent. An exception can be an addition or removal of access permissions.
    property provisionElement : TFhirConsentProvision read FProvision write SetProvision;

  end;

  TFhirConsentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConsentList;
    function GetCurrent : TFhirConsent;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirConsentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConsent read GetCurrent;
  end;

  TFhirConsentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConsent;
    procedure SetItemN(index : Integer; value : TFhirConsent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirConsentList; overload;
    function Clone : TFhirConsentList; overload;
    function GetEnumerator : TFhirConsentListEnumerator;
    
    //  Add a FhirConsent to the end of the list.
    function Append : TFhirConsent;
    
    // Add an already existing FhirConsent to the end of the list.
    function AddItem(value : TFhirConsent) : TFhirConsent; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConsent) : Integer;
    
    // Insert FhirConsent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConsent;
    
    // Insert an existing FhirConsent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConsent);
    
    // Get the iIndexth FhirConsent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConsent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConsent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirConsents[index : Integer] : TFhirConsent read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
  // Precusory content developed with a focus and intent of supporting the formation a Contract instance, which may be associated with and transformable into a Contract.
  TFhirContractContentDefinition = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FSubType : TFhirCodeableConcept;
    FPublisher : TFhirReference;
    FPublicationDate : TFhirDateTime;
    FPublicationStatus : TFhirEnum;
    FCopyright : TFhirMarkdown;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSubType(value : TFhirCodeableConcept);
    procedure SetPublisher(value : TFhirReference);
    procedure SetPublicationDate(value : TFhirDateTime);
    function GetPublicationDateST : TFslDateTime;
    procedure SetPublicationDateST(value : TFslDateTime);
    procedure SetPublicationStatus(value : TFhirEnum);
    function GetPublicationStatusST : TFhirContractResourcePublicationStatusCodesEnum;
    procedure SetPublicationStatusST(value : TFhirContractResourcePublicationStatusCodesEnum);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractContentDefinition; overload;
    function Clone : TFhirContractContentDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Precusory content structure and use, i.e., a boilerplate, template, application for a contract such as an insurance policy or benefits under a program, e.g., workers compensation. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Precusory content structure and use, i.e., a boilerplate, template, application for a contract such as an insurance policy or benefits under a program, e.g., workers compensation.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Detailed Precusory content type. (defined for API consistency)
    property subType : TFhirCodeableConcept read FSubType write SetSubType;
    // Detailed Precusory content type.
    property subTypeElement : TFhirCodeableConcept read FSubType write SetSubType;

    // Typed access to The  individual or organization that published the Contract precursor content. (defined for API consistency)
    property publisher : TFhirReference read FPublisher write SetPublisher;
    // The  individual or organization that published the Contract precursor content.
    property publisherElement : TFhirReference read FPublisher write SetPublisher;

    // Typed access to The date (and optionally time) when the contract was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the contract changes.
    property publicationDate : TFslDateTime read GetPublicationDateST write SetPublicationDateST;
    // The date (and optionally time) when the contract was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the contract changes.
    property publicationDateElement : TFhirDateTime read FPublicationDate write SetPublicationDate;

    // amended | appended | cancelled | disputed | entered-in-error | executable +.
    property publicationStatus : TFhirContractResourcePublicationStatusCodesEnum read GetPublicationStatusST write SetPublicationStatusST;
    property publicationStatusElement : TFhirEnum read FPublicationStatus write SetPublicationStatus;

    // Typed access to A copyright statement relating to Contract precursor content. Copyright statements are generally legal restrictions on the use and publishing of the Contract precursor content.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to Contract precursor content. Copyright statements are generally legal restrictions on the use and publishing of the Contract precursor content.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

  end;

  TFhirContractContentDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractContentDefinitionList;
    function GetCurrent : TFhirContractContentDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractContentDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractContentDefinition read GetCurrent;
  end;

  TFhirContractContentDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractContentDefinition;
    procedure SetItemN(index : Integer; value : TFhirContractContentDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractContentDefinitionList; overload;
    function Clone : TFhirContractContentDefinitionList; overload;
    function GetEnumerator : TFhirContractContentDefinitionListEnumerator;
    
    //  Add a FhirContractContentDefinition to the end of the list.
    function Append : TFhirContractContentDefinition;
    
    // Add an already existing FhirContractContentDefinition to the end of the list.
    function AddItem(value : TFhirContractContentDefinition) : TFhirContractContentDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractContentDefinition) : Integer;
    
    // Insert FhirContractContentDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractContentDefinition;
    
    // Insert an existing FhirContractContentDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractContentDefinition);
    
    // Get the iIndexth FhirContractContentDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractContentDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractContentDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractContentDefinitions[index : Integer] : TFhirContractContentDefinition read GetItemN write SetItemN; default;
  End;

  // One or more Contract Provisions, which may be related and conveyed as a group, and may contain nested groups.
  TFhirContractTerm = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FIssued : TFhirDateTime;
    FApplies : TFhirPeriod;
    FTopic : TFhirDataType;
    FType_ : TFhirCodeableConcept;
    FSubType : TFhirCodeableConcept;
    FText : TFhirString;
    FsecurityLabelList : TFhirContractTermSecurityLabelList;
    FOffer : TFhirContractTermOffer;
    FassetList : TFhirContractTermAssetList;
    FactionList : TFhirContractTermActionList;
    FgroupList : TFhirContractTermList;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetIssued(value : TFhirDateTime);
    function GetIssuedST : TFslDateTime;
    procedure SetIssuedST(value : TFslDateTime);
    procedure SetApplies(value : TFhirPeriod);
    procedure SetTopic(value : TFhirDataType);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSubType(value : TFhirCodeableConcept);
    procedure SetText(value : TFhirString);
    function GetTextST : String;
    procedure SetTextST(value : String);
    function GetSecurityLabelList : TFhirContractTermSecurityLabelList;
    function GetHasSecurityLabelList : Boolean;
    procedure SetOffer(value : TFhirContractTermOffer);
    function GetAssetList : TFhirContractTermAssetList;
    function GetHasAssetList : Boolean;
    function GetActionList : TFhirContractTermActionList;
    function GetHasActionList : Boolean;
    function GetGroupList : TFhirContractTermList;
    function GetHasGroupList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTerm; overload;
    function Clone : TFhirContractTerm; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Unique identifier for this particular Contract Provision. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Unique identifier for this particular Contract Provision.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to When this Contract Provision was issued.
    property issued : TFslDateTime read GetIssuedST write SetIssuedST;
    // When this Contract Provision was issued.
    property issuedElement : TFhirDateTime read FIssued write SetIssued;

    // Typed access to Relevant time or time-period when this Contract Provision is applicable. (defined for API consistency)
    property applies : TFhirPeriod read FApplies write SetApplies;
    // Relevant time or time-period when this Contract Provision is applicable.
    property appliesElement : TFhirPeriod read FApplies write SetApplies;

    // Typed access to The entity that the term applies to. (defined for API consistency)
    property topic : TFhirDataType read FTopic write SetTopic;
    // The entity that the term applies to.
    property topicElement : TFhirDataType read FTopic write SetTopic;

    // Typed access to A legal clause or condition contained within a contract that requires one or both parties to perform a particular requirement by some specified time or prevents one or both parties from performing a particular requirement by some specified time. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A legal clause or condition contained within a contract that requires one or both parties to perform a particular requirement by some specified time or prevents one or both parties from performing a particular requirement by some specified time.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A specialized legal clause or condition based on overarching contract type. (defined for API consistency)
    property subType : TFhirCodeableConcept read FSubType write SetSubType;
    // A specialized legal clause or condition based on overarching contract type.
    property subTypeElement : TFhirCodeableConcept read FSubType write SetSubType;

    // Typed access to Statement of a provision in a policy or a contract.
    property text : String read GetTextST write SetTextST;
    // Statement of a provision in a policy or a contract.
    property textElement : TFhirString read FText write SetText;

    // Security labels that protect the handling of information about the term and its elements, which may be specifically identified..
    property securityLabelList : TFhirContractTermSecurityLabelList read GetSecurityLabelList;
    property hasSecurityLabelList : boolean read GetHasSecurityLabelList;

    // Typed access to The matter of concern in the context of this provision of the agrement. (defined for API consistency)
    property offer : TFhirContractTermOffer read FOffer write SetOffer;
    // The matter of concern in the context of this provision of the agrement.
    property offerElement : TFhirContractTermOffer read FOffer write SetOffer;

    // Contract Term Asset List.
    property assetList : TFhirContractTermAssetList read GetAssetList;
    property hasAssetList : boolean read GetHasAssetList;

    // An actor taking a role in an activity for which it can be assigned some degree of responsibility for the activity taking place.
    property actionList : TFhirContractTermActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

    // Nested group of Contract Provisions.
    property groupList : TFhirContractTermList read GetGroupList;
    property hasGroupList : boolean read GetHasGroupList;

  end;

  TFhirContractTermListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermList;
    function GetCurrent : TFhirContractTerm;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractTermList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTerm read GetCurrent;
  end;

  TFhirContractTermList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractTerm;
    procedure SetItemN(index : Integer; value : TFhirContractTerm);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractTermList; overload;
    function Clone : TFhirContractTermList; overload;
    function GetEnumerator : TFhirContractTermListEnumerator;
    
    //  Add a FhirContractTerm to the end of the list.
    function Append : TFhirContractTerm;
    
    // Add an already existing FhirContractTerm to the end of the list.
    function AddItem(value : TFhirContractTerm) : TFhirContractTerm; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTerm) : Integer;
    
    // Insert FhirContractTerm before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTerm;
    
    // Insert an existing FhirContractTerm before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTerm);
    
    // Get the iIndexth FhirContractTerm. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTerm);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTerm;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractTerms[index : Integer] : TFhirContractTerm read GetItemN write SetItemN; default;
  End;

  // Security labels that protect the handling of information about the term and its elements, which may be specifically identified..
  TFhirContractTermSecurityLabel = class (TFhirBackboneElement)
  protected
    FnumberList : TFhirUnsignedIntList;
    FClassification : TFhirCoding;
    FcategoryList : TFhirCodingList;
    FcontrolList : TFhirCodingList;
    function GetNumberList : TFhirUnsignedIntList;
    function GetHasNumberList : Boolean;
    procedure SetClassification(value : TFhirCoding);
    function GetCategoryList : TFhirCodingList;
    function GetHasCategoryList : Boolean;
    function GetControlList : TFhirCodingList;
    function GetHasControlList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermSecurityLabel; overload;
    function Clone : TFhirContractTermSecurityLabel; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Number used to link this term or term element to the applicable Security Label.
    property numberList : TFhirUnsignedIntList read GetNumberList;
    property hasNumberList : boolean read GetHasNumberList;

    // Typed access to Security label privacy tag that species the level of confidentiality protection required for this term and/or term elements. (defined for API consistency)
    property classification : TFhirCoding read FClassification write SetClassification;
    // Security label privacy tag that species the level of confidentiality protection required for this term and/or term elements.
    property classificationElement : TFhirCoding read FClassification write SetClassification;

    // Security label privacy tag that species the applicable privacy and security policies governing this term and/or term elements.
    property categoryList : TFhirCodingList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Security label privacy tag that species the manner in which term and/or term elements are to be protected.
    property controlList : TFhirCodingList read GetControlList;
    property hasControlList : boolean read GetHasControlList;

  end;

  TFhirContractTermSecurityLabelListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermSecurityLabelList;
    function GetCurrent : TFhirContractTermSecurityLabel;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractTermSecurityLabelList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermSecurityLabel read GetCurrent;
  end;

  TFhirContractTermSecurityLabelList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractTermSecurityLabel;
    procedure SetItemN(index : Integer; value : TFhirContractTermSecurityLabel);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractTermSecurityLabelList; overload;
    function Clone : TFhirContractTermSecurityLabelList; overload;
    function GetEnumerator : TFhirContractTermSecurityLabelListEnumerator;
    
    //  Add a FhirContractTermSecurityLabel to the end of the list.
    function Append : TFhirContractTermSecurityLabel;
    
    // Add an already existing FhirContractTermSecurityLabel to the end of the list.
    function AddItem(value : TFhirContractTermSecurityLabel) : TFhirContractTermSecurityLabel; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermSecurityLabel) : Integer;
    
    // Insert FhirContractTermSecurityLabel before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermSecurityLabel;
    
    // Insert an existing FhirContractTermSecurityLabel before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermSecurityLabel);
    
    // Get the iIndexth FhirContractTermSecurityLabel. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermSecurityLabel);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermSecurityLabel;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractTermSecurityLabels[index : Integer] : TFhirContractTermSecurityLabel read GetItemN write SetItemN; default;
  End;

  // The matter of concern in the context of this provision of the agrement.
  TFhirContractTermOffer = class (TFhirBackboneElement)
  protected
    FidentifierList : TFhirIdentifierList;
    FpartyList : TFhirContractTermOfferPartyList;
    FTopic : TFhirReference;
    FType_ : TFhirCodeableConcept;
    FDecision : TFhirCodeableConcept;
    FdecisionModeList : TFhirCodeableConceptList;
    FanswerList : TFhirContractTermOfferAnswerList;
    FText : TFhirString;
    FlinkIdList : TFhirStringList;
    FsecurityLabelNumberList : TFhirUnsignedIntList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetPartyList : TFhirContractTermOfferPartyList;
    function GetHasPartyList : Boolean;
    procedure SetTopic(value : TFhirReference);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetDecision(value : TFhirCodeableConcept);
    function GetDecisionModeList : TFhirCodeableConceptList;
    function GetHasDecisionModeList : Boolean;
    function GetAnswerList : TFhirContractTermOfferAnswerList;
    function GetHasAnswerList : Boolean;
    procedure SetText(value : TFhirString);
    function GetTextST : String;
    procedure SetTextST(value : String);
    function GetLinkIdList : TFhirStringList;
    function GetHasLinkIdList : Boolean;
    function GetSecurityLabelNumberList : TFhirUnsignedIntList;
    function GetHasSecurityLabelNumberList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermOffer; overload;
    function Clone : TFhirContractTermOffer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique identifier for this particular Contract Provision.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Offer Recipient.
    property partyList : TFhirContractTermOfferPartyList read GetPartyList;
    property hasPartyList : boolean read GetHasPartyList;

    // Typed access to The owner of an asset has the residual control rights over the asset: the right to decide all usages of the asset in any way not inconsistent with a prior contract, custom, or law (Hart, 1995, p. 30). (defined for API consistency)
    property topic : TFhirReference read FTopic write SetTopic;
    // The owner of an asset has the residual control rights over the asset: the right to decide all usages of the asset in any way not inconsistent with a prior contract, custom, or law (Hart, 1995, p. 30).
    property topicElement : TFhirReference read FTopic write SetTopic;

    // Typed access to Type of Contract Provision such as specific requirements, purposes for actions, obligations, prohibitions, e.g. life time maximum benefit. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of Contract Provision such as specific requirements, purposes for actions, obligations, prohibitions, e.g. life time maximum benefit.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Type of choice made by accepting party with respect to an offer made by an offeror/ grantee. (defined for API consistency)
    property decision : TFhirCodeableConcept read FDecision write SetDecision;
    // Type of choice made by accepting party with respect to an offer made by an offeror/ grantee.
    property decisionElement : TFhirCodeableConcept read FDecision write SetDecision;

    // How the decision about a Contract was conveyed.
    property decisionModeList : TFhirCodeableConceptList read GetDecisionModeList;
    property hasDecisionModeList : boolean read GetHasDecisionModeList;

    // Response to offer text.
    property answerList : TFhirContractTermOfferAnswerList read GetAnswerList;
    property hasAnswerList : boolean read GetHasAnswerList;

    // Typed access to Human readable form of this Contract Offer.
    property text : String read GetTextST write SetTextST;
    // Human readable form of this Contract Offer.
    property textElement : TFhirString read FText write SetText;

    // The id of the clause or question text of the offer in the referenced questionnaire/response.
    property linkIdList : TFhirStringList read GetLinkIdList;
    property hasLinkIdList : boolean read GetHasLinkIdList;

    // Security labels that protects the offer.
    property securityLabelNumberList : TFhirUnsignedIntList read GetSecurityLabelNumberList;
    property hasSecurityLabelNumberList : boolean read GetHasSecurityLabelNumberList;

  end;

  TFhirContractTermOfferListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermOfferList;
    function GetCurrent : TFhirContractTermOffer;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractTermOfferList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermOffer read GetCurrent;
  end;

  TFhirContractTermOfferList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractTermOffer;
    procedure SetItemN(index : Integer; value : TFhirContractTermOffer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractTermOfferList; overload;
    function Clone : TFhirContractTermOfferList; overload;
    function GetEnumerator : TFhirContractTermOfferListEnumerator;
    
    //  Add a FhirContractTermOffer to the end of the list.
    function Append : TFhirContractTermOffer;
    
    // Add an already existing FhirContractTermOffer to the end of the list.
    function AddItem(value : TFhirContractTermOffer) : TFhirContractTermOffer; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermOffer) : Integer;
    
    // Insert FhirContractTermOffer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermOffer;
    
    // Insert an existing FhirContractTermOffer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermOffer);
    
    // Get the iIndexth FhirContractTermOffer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermOffer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermOffer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractTermOffers[index : Integer] : TFhirContractTermOffer read GetItemN write SetItemN; default;
  End;

  // Offer Recipient.
  TFhirContractTermOfferParty = class (TFhirBackboneElement)
  protected
    FreferenceList : TFhirReferenceList;
    FRole : TFhirCodeableConcept;
    function GetReferenceList : TFhirReferenceList;
    function GetHasReferenceList : Boolean;
    procedure SetRole(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermOfferParty; overload;
    function Clone : TFhirContractTermOfferParty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Participant in the offer.
    property referenceList : TFhirReferenceList read GetReferenceList;
    property hasReferenceList : boolean read GetHasReferenceList;

    // Typed access to How the party participates in the offer. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // How the party participates in the offer.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

  end;

  TFhirContractTermOfferPartyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermOfferPartyList;
    function GetCurrent : TFhirContractTermOfferParty;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractTermOfferPartyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermOfferParty read GetCurrent;
  end;

  TFhirContractTermOfferPartyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractTermOfferParty;
    procedure SetItemN(index : Integer; value : TFhirContractTermOfferParty);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractTermOfferPartyList; overload;
    function Clone : TFhirContractTermOfferPartyList; overload;
    function GetEnumerator : TFhirContractTermOfferPartyListEnumerator;
    
    //  Add a FhirContractTermOfferParty to the end of the list.
    function Append : TFhirContractTermOfferParty;
    
    // Add an already existing FhirContractTermOfferParty to the end of the list.
    function AddItem(value : TFhirContractTermOfferParty) : TFhirContractTermOfferParty; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermOfferParty) : Integer;
    
    // Insert FhirContractTermOfferParty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermOfferParty;
    
    // Insert an existing FhirContractTermOfferParty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermOfferParty);
    
    // Get the iIndexth FhirContractTermOfferParty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermOfferParty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermOfferParty;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractTermOfferParties[index : Integer] : TFhirContractTermOfferParty read GetItemN write SetItemN; default;
  End;

  // Response to offer text.
  TFhirContractTermOfferAnswer = class (TFhirBackboneElement)
  protected
    FValue : TFhirDataType;
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermOfferAnswer; overload;
    function Clone : TFhirContractTermOfferAnswer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirContractTermOfferAnswerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermOfferAnswerList;
    function GetCurrent : TFhirContractTermOfferAnswer;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractTermOfferAnswerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermOfferAnswer read GetCurrent;
  end;

  TFhirContractTermOfferAnswerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractTermOfferAnswer;
    procedure SetItemN(index : Integer; value : TFhirContractTermOfferAnswer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractTermOfferAnswerList; overload;
    function Clone : TFhirContractTermOfferAnswerList; overload;
    function GetEnumerator : TFhirContractTermOfferAnswerListEnumerator;
    
    //  Add a FhirContractTermOfferAnswer to the end of the list.
    function Append : TFhirContractTermOfferAnswer;
    
    // Add an already existing FhirContractTermOfferAnswer to the end of the list.
    function AddItem(value : TFhirContractTermOfferAnswer) : TFhirContractTermOfferAnswer; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermOfferAnswer) : Integer;
    
    // Insert FhirContractTermOfferAnswer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermOfferAnswer;
    
    // Insert an existing FhirContractTermOfferAnswer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermOfferAnswer);
    
    // Get the iIndexth FhirContractTermOfferAnswer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermOfferAnswer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermOfferAnswer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractTermOfferAnswers[index : Integer] : TFhirContractTermOfferAnswer read GetItemN write SetItemN; default;
  End;

  // Contract Term Asset List.
  TFhirContractTermAsset = class (TFhirBackboneElement)
  protected
    FScope : TFhirCodeableConcept;
    Ftype_List : TFhirCodeableConceptList;
    FtypeReferenceList : TFhirReferenceList;
    FsubtypeList : TFhirCodeableConceptList;
    FRelationship : TFhirCoding;
    FcontextList : TFhirContractTermAssetContextList;
    FCondition : TFhirString;
    FperiodTypeList : TFhirCodeableConceptList;
    FperiodList : TFhirPeriodList;
    FusePeriodList : TFhirPeriodList;
    FText : TFhirString;
    FlinkIdList : TFhirStringList;
    FanswerList : TFhirContractTermOfferAnswerList;
    FsecurityLabelNumberList : TFhirUnsignedIntList;
    FvaluedItemList : TFhirContractTermAssetValuedItemList;
    procedure SetScope(value : TFhirCodeableConcept);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    function GetTypeReferenceList : TFhirReferenceList;
    function GetHasTypeReferenceList : Boolean;
    function GetSubtypeList : TFhirCodeableConceptList;
    function GetHasSubtypeList : Boolean;
    procedure SetRelationship(value : TFhirCoding);
    function GetContextList : TFhirContractTermAssetContextList;
    function GetHasContextList : Boolean;
    procedure SetCondition(value : TFhirString);
    function GetConditionST : String;
    procedure SetConditionST(value : String);
    function GetPeriodTypeList : TFhirCodeableConceptList;
    function GetHasPeriodTypeList : Boolean;
    function GetPeriodList : TFhirPeriodList;
    function GetHasPeriodList : Boolean;
    function GetUsePeriodList : TFhirPeriodList;
    function GetHasUsePeriodList : Boolean;
    procedure SetText(value : TFhirString);
    function GetTextST : String;
    procedure SetTextST(value : String);
    function GetLinkIdList : TFhirStringList;
    function GetHasLinkIdList : Boolean;
    function GetAnswerList : TFhirContractTermOfferAnswerList;
    function GetHasAnswerList : Boolean;
    function GetSecurityLabelNumberList : TFhirUnsignedIntList;
    function GetHasSecurityLabelNumberList : Boolean;
    function GetValuedItemList : TFhirContractTermAssetValuedItemList;
    function GetHasValuedItemList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermAsset; overload;
    function Clone : TFhirContractTermAsset; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Differentiates the kind of the asset . (defined for API consistency)
    property scope : TFhirCodeableConcept read FScope write SetScope;
    // Differentiates the kind of the asset .
    property scopeElement : TFhirCodeableConcept read FScope write SetScope;

    // Target entity type about which the term may be concerned.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Associated entities.
    property typeReferenceList : TFhirReferenceList read GetTypeReferenceList;
    property hasTypeReferenceList : boolean read GetHasTypeReferenceList;

    // May be a subtype or part of an offered asset.
    property subtypeList : TFhirCodeableConceptList read GetSubtypeList;
    property hasSubtypeList : boolean read GetHasSubtypeList;

    // Typed access to Specifies the applicability of the term to an asset resource instance, and instances it refers to orinstances that refer to it, and/or are owned by the offeree. (defined for API consistency)
    property relationship : TFhirCoding read FRelationship write SetRelationship;
    // Specifies the applicability of the term to an asset resource instance, and instances it refers to orinstances that refer to it, and/or are owned by the offeree.
    property relationshipElement : TFhirCoding read FRelationship write SetRelationship;

    // Circumstance of the asset.
    property contextList : TFhirContractTermAssetContextList read GetContextList;
    property hasContextList : boolean read GetHasContextList;

    // Typed access to Description of the quality and completeness of the asset that imay be a factor in its valuation.
    property condition : String read GetConditionST write SetConditionST;
    // Description of the quality and completeness of the asset that imay be a factor in its valuation.
    property conditionElement : TFhirString read FCondition write SetCondition;

    // Type of Asset availability for use or ownership.
    property periodTypeList : TFhirCodeableConceptList read GetPeriodTypeList;
    property hasPeriodTypeList : boolean read GetHasPeriodTypeList;

    // Asset relevant contractual time period.
    property periodList : TFhirPeriodList read GetPeriodList;
    property hasPeriodList : boolean read GetHasPeriodList;

    // Time period of asset use.
    property usePeriodList : TFhirPeriodList read GetUsePeriodList;
    property hasUsePeriodList : boolean read GetHasUsePeriodList;

    // Typed access to Clause or question text (Prose Object) concerning the asset in a linked form, such as a QuestionnaireResponse used in the formation of the contract.
    property text : String read GetTextST write SetTextST;
    // Clause or question text (Prose Object) concerning the asset in a linked form, such as a QuestionnaireResponse used in the formation of the contract.
    property textElement : TFhirString read FText write SetText;

    // Id [identifier??] of the clause or question text about the asset in the referenced form or QuestionnaireResponse.
    property linkIdList : TFhirStringList read GetLinkIdList;
    property hasLinkIdList : boolean read GetHasLinkIdList;

    // Response to assets.
    property answerList : TFhirContractTermOfferAnswerList read GetAnswerList;
    property hasAnswerList : boolean read GetHasAnswerList;

    // Security labels that protects the asset.
    property securityLabelNumberList : TFhirUnsignedIntList read GetSecurityLabelNumberList;
    property hasSecurityLabelNumberList : boolean read GetHasSecurityLabelNumberList;

    // Contract Valued Item List.
    property valuedItemList : TFhirContractTermAssetValuedItemList read GetValuedItemList;
    property hasValuedItemList : boolean read GetHasValuedItemList;

  end;

  TFhirContractTermAssetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermAssetList;
    function GetCurrent : TFhirContractTermAsset;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractTermAssetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermAsset read GetCurrent;
  end;

  TFhirContractTermAssetList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractTermAsset;
    procedure SetItemN(index : Integer; value : TFhirContractTermAsset);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractTermAssetList; overload;
    function Clone : TFhirContractTermAssetList; overload;
    function GetEnumerator : TFhirContractTermAssetListEnumerator;
    
    //  Add a FhirContractTermAsset to the end of the list.
    function Append : TFhirContractTermAsset;
    
    // Add an already existing FhirContractTermAsset to the end of the list.
    function AddItem(value : TFhirContractTermAsset) : TFhirContractTermAsset; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermAsset) : Integer;
    
    // Insert FhirContractTermAsset before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermAsset;
    
    // Insert an existing FhirContractTermAsset before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermAsset);
    
    // Get the iIndexth FhirContractTermAsset. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermAsset);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermAsset;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractTermAssets[index : Integer] : TFhirContractTermAsset read GetItemN write SetItemN; default;
  End;

  // Circumstance of the asset.
  TFhirContractTermAssetContext = class (TFhirBackboneElement)
  protected
    FReference : TFhirReference;
    FcodeList : TFhirCodeableConceptList;
    FText : TFhirString;
    procedure SetReference(value : TFhirReference);
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    procedure SetText(value : TFhirString);
    function GetTextST : String;
    procedure SetTextST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermAssetContext; overload;
    function Clone : TFhirContractTermAssetContext; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Asset context reference may include the creator, custodian, or owning Person or Organization (e.g., bank, repository),  location held, e.g., building,  jurisdiction. (defined for API consistency)
    property reference : TFhirReference read FReference write SetReference;
    // Asset context reference may include the creator, custodian, or owning Person or Organization (e.g., bank, repository),  location held, e.g., building,  jurisdiction.
    property referenceElement : TFhirReference read FReference write SetReference;

    // Coded representation of the context generally or of the Referenced entity, such as the asset holder type or location.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Typed access to Context description.
    property text : String read GetTextST write SetTextST;
    // Context description.
    property textElement : TFhirString read FText write SetText;

  end;

  TFhirContractTermAssetContextListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermAssetContextList;
    function GetCurrent : TFhirContractTermAssetContext;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractTermAssetContextList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermAssetContext read GetCurrent;
  end;

  TFhirContractTermAssetContextList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractTermAssetContext;
    procedure SetItemN(index : Integer; value : TFhirContractTermAssetContext);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractTermAssetContextList; overload;
    function Clone : TFhirContractTermAssetContextList; overload;
    function GetEnumerator : TFhirContractTermAssetContextListEnumerator;
    
    //  Add a FhirContractTermAssetContext to the end of the list.
    function Append : TFhirContractTermAssetContext;
    
    // Add an already existing FhirContractTermAssetContext to the end of the list.
    function AddItem(value : TFhirContractTermAssetContext) : TFhirContractTermAssetContext; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermAssetContext) : Integer;
    
    // Insert FhirContractTermAssetContext before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermAssetContext;
    
    // Insert an existing FhirContractTermAssetContext before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermAssetContext);
    
    // Get the iIndexth FhirContractTermAssetContext. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermAssetContext);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermAssetContext;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractTermAssetContexts[index : Integer] : TFhirContractTermAssetContext read GetItemN write SetItemN; default;
  End;

  // Contract Valued Item List.
  TFhirContractTermAssetValuedItem = class (TFhirBackboneElement)
  protected
    FEntity : TFhirDataType;
    FIdentifier : TFhirIdentifier;
    FEffectiveTime : TFhirDateTime;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FPoints : TFhirDecimal;
    FNet : TFhirMoney;
    FPayment : TFhirString;
    FPaymentDate : TFhirDateTime;
    FResponsible : TFhirReference;
    FRecipient : TFhirReference;
    FlinkIdList : TFhirStringList;
    FsecurityLabelNumberList : TFhirUnsignedIntList;
    procedure SetEntity(value : TFhirDataType);
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetEffectiveTime(value : TFhirDateTime);
    function GetEffectiveTimeST : TFslDateTime;
    procedure SetEffectiveTimeST(value : TFslDateTime);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetPoints(value : TFhirDecimal);
    function GetPointsST : String;
    procedure SetPointsST(value : String);
    procedure SetNet(value : TFhirMoney);
    procedure SetPayment(value : TFhirString);
    function GetPaymentST : String;
    procedure SetPaymentST(value : String);
    procedure SetPaymentDate(value : TFhirDateTime);
    function GetPaymentDateST : TFslDateTime;
    procedure SetPaymentDateST(value : TFslDateTime);
    procedure SetResponsible(value : TFhirReference);
    procedure SetRecipient(value : TFhirReference);
    function GetLinkIdList : TFhirStringList;
    function GetHasLinkIdList : Boolean;
    function GetSecurityLabelNumberList : TFhirUnsignedIntList;
    function GetHasSecurityLabelNumberList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermAssetValuedItem; overload;
    function Clone : TFhirContractTermAssetValuedItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Specific type of Contract Valued Item that may be priced. (defined for API consistency)
    property entity : TFhirDataType read FEntity write SetEntity;
    // Specific type of Contract Valued Item that may be priced.
    property entityElement : TFhirDataType read FEntity write SetEntity;

    // Typed access to Identifies a Contract Valued Item instance. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifies a Contract Valued Item instance.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Indicates the time during which this Contract ValuedItem information is effective.
    property effectiveTime : TFslDateTime read GetEffectiveTimeST write SetEffectiveTimeST;
    // Indicates the time during which this Contract ValuedItem information is effective.
    property effectiveTimeElement : TFhirDateTime read FEffectiveTime write SetEffectiveTime;

    // Typed access to Specifies the units by which the Contract Valued Item is measured or counted, and quantifies the countable or measurable Contract Valued Item instances. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // Specifies the units by which the Contract Valued Item is measured or counted, and quantifies the countable or measurable Contract Valued Item instances.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to A Contract Valued Item unit valuation measure. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // A Contract Valued Item unit valuation measure.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of the Contract Valued Item delivered. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of the Contract Valued Item delivered. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the Contract Valued Item delivered. The concept of Points allows for assignment of point values for a Contract Valued Item, such that a monetary amount can be assigned to each point.
    property points : String read GetPointsST write SetPointsST;
    // An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the Contract Valued Item delivered. The concept of Points allows for assignment of point values for a Contract Valued Item, such that a monetary amount can be assigned to each point.
    property pointsElement : TFhirDecimal read FPoints write SetPoints;

    // Typed access to Expresses the product of the Contract Valued Item unitQuantity and the unitPriceAmt. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // Expresses the product of the Contract Valued Item unitQuantity and the unitPriceAmt. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
    property netElement : TFhirMoney read FNet write SetNet;

    // Typed access to Terms of valuation.
    property payment : String read GetPaymentST write SetPaymentST;
    // Terms of valuation.
    property paymentElement : TFhirString read FPayment write SetPayment;

    // Typed access to When payment is due.
    property paymentDate : TFslDateTime read GetPaymentDateST write SetPaymentDateST;
    // When payment is due.
    property paymentDateElement : TFhirDateTime read FPaymentDate write SetPaymentDate;

    // Typed access to Who will make payment. (defined for API consistency)
    property responsible : TFhirReference read FResponsible write SetResponsible;
    // Who will make payment.
    property responsibleElement : TFhirReference read FResponsible write SetResponsible;

    // Typed access to Who will receive payment. (defined for API consistency)
    property recipient : TFhirReference read FRecipient write SetRecipient;
    // Who will receive payment.
    property recipientElement : TFhirReference read FRecipient write SetRecipient;

    // Id  of the clause or question text related to the context of this valuedItem in the referenced form or QuestionnaireResponse.
    property linkIdList : TFhirStringList read GetLinkIdList;
    property hasLinkIdList : boolean read GetHasLinkIdList;

    // A set of security labels that define which terms are controlled by this condition.
    property securityLabelNumberList : TFhirUnsignedIntList read GetSecurityLabelNumberList;
    property hasSecurityLabelNumberList : boolean read GetHasSecurityLabelNumberList;

  end;

  TFhirContractTermAssetValuedItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermAssetValuedItemList;
    function GetCurrent : TFhirContractTermAssetValuedItem;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractTermAssetValuedItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermAssetValuedItem read GetCurrent;
  end;

  TFhirContractTermAssetValuedItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractTermAssetValuedItem;
    procedure SetItemN(index : Integer; value : TFhirContractTermAssetValuedItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractTermAssetValuedItemList; overload;
    function Clone : TFhirContractTermAssetValuedItemList; overload;
    function GetEnumerator : TFhirContractTermAssetValuedItemListEnumerator;
    
    //  Add a FhirContractTermAssetValuedItem to the end of the list.
    function Append : TFhirContractTermAssetValuedItem;
    
    // Add an already existing FhirContractTermAssetValuedItem to the end of the list.
    function AddItem(value : TFhirContractTermAssetValuedItem) : TFhirContractTermAssetValuedItem; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermAssetValuedItem) : Integer;
    
    // Insert FhirContractTermAssetValuedItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermAssetValuedItem;
    
    // Insert an existing FhirContractTermAssetValuedItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermAssetValuedItem);
    
    // Get the iIndexth FhirContractTermAssetValuedItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermAssetValuedItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermAssetValuedItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractTermAssetValuedItems[index : Integer] : TFhirContractTermAssetValuedItem read GetItemN write SetItemN; default;
  End;

  // An actor taking a role in an activity for which it can be assigned some degree of responsibility for the activity taking place.
  TFhirContractTermAction = class (TFhirBackboneElement)
  protected
    FDoNotPerform : TFhirBoolean;
    FType_ : TFhirCodeableConcept;
    FsubjectList : TFhirContractTermActionSubjectList;
    FIntent : TFhirCodeableConcept;
    FlinkIdList : TFhirStringList;
    FStatus : TFhirCodeableConcept;
    FContext : TFhirReference;
    FcontextLinkIdList : TFhirStringList;
    FOccurrence : TFhirDataType;
    FrequesterList : TFhirReferenceList;
    FrequesterLinkIdList : TFhirStringList;
    FperformerTypeList : TFhirCodeableConceptList;
    FPerformerRole : TFhirCodeableConcept;
    FPerformer : TFhirReference;
    FperformerLinkIdList : TFhirStringList;
    FreasonList : TFhirCodeableReferenceList;
    FreasonLinkIdList : TFhirStringList;
    FnoteList : TFhirAnnotationList;
    FsecurityLabelNumberList : TFhirUnsignedIntList;
    procedure SetDoNotPerform(value : TFhirBoolean);
    function GetDoNotPerformST : Boolean;
    procedure SetDoNotPerformST(value : Boolean);
    procedure SetType_(value : TFhirCodeableConcept);
    function GetSubjectList : TFhirContractTermActionSubjectList;
    function GetHasSubjectList : Boolean;
    procedure SetIntent(value : TFhirCodeableConcept);
    function GetLinkIdList : TFhirStringList;
    function GetHasLinkIdList : Boolean;
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetContext(value : TFhirReference);
    function GetContextLinkIdList : TFhirStringList;
    function GetHasContextLinkIdList : Boolean;
    procedure SetOccurrence(value : TFhirDataType);
    function GetRequesterList : TFhirReferenceList;
    function GetHasRequesterList : Boolean;
    function GetRequesterLinkIdList : TFhirStringList;
    function GetHasRequesterLinkIdList : Boolean;
    function GetPerformerTypeList : TFhirCodeableConceptList;
    function GetHasPerformerTypeList : Boolean;
    procedure SetPerformerRole(value : TFhirCodeableConcept);
    procedure SetPerformer(value : TFhirReference);
    function GetPerformerLinkIdList : TFhirStringList;
    function GetHasPerformerLinkIdList : Boolean;
    function GetReasonList : TFhirCodeableReferenceList;
    function GetHasReasonList : Boolean;
    function GetReasonLinkIdList : TFhirStringList;
    function GetHasReasonLinkIdList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetSecurityLabelNumberList : TFhirUnsignedIntList;
    function GetHasSecurityLabelNumberList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermAction; overload;
    function Clone : TFhirContractTermAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to True if the term prohibits the  action.
    property doNotPerform : Boolean read GetDoNotPerformST write SetDoNotPerformST;
    // True if the term prohibits the  action.
    property doNotPerformElement : TFhirBoolean read FDoNotPerform write SetDoNotPerform;

    // Typed access to Activity or service obligation to be done or not done, performed or not performed, effectuated or not by this Contract term. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Activity or service obligation to be done or not done, performed or not performed, effectuated or not by this Contract term.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Entity of the action.
    property subjectList : TFhirContractTermActionSubjectList read GetSubjectList;
    property hasSubjectList : boolean read GetHasSubjectList;

    // Typed access to Reason or purpose for the action stipulated by this Contract Provision. (defined for API consistency)
    property intent : TFhirCodeableConcept read FIntent write SetIntent;
    // Reason or purpose for the action stipulated by this Contract Provision.
    property intentElement : TFhirCodeableConcept read FIntent write SetIntent;

    // Id [identifier??] of the clause or question text related to this action in the referenced form or QuestionnaireResponse.
    property linkIdList : TFhirStringList read GetLinkIdList;
    property hasLinkIdList : boolean read GetHasLinkIdList;

    // Typed access to Current state of the term action. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // Current state of the term action.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to Encounter or Episode with primary association to specified term activity. (defined for API consistency)
    property context : TFhirReference read FContext write SetContext;
    // Encounter or Episode with primary association to specified term activity.
    property contextElement : TFhirReference read FContext write SetContext;

    // Id [identifier??] of the clause or question text related to the requester of this action in the referenced form or QuestionnaireResponse.
    property contextLinkIdList : TFhirStringList read GetContextLinkIdList;
    property hasContextLinkIdList : boolean read GetHasContextLinkIdList;

    // Typed access to When action happens. (defined for API consistency)
    property occurrence : TFhirDataType read FOccurrence write SetOccurrence;
    // When action happens.
    property occurrenceElement : TFhirDataType read FOccurrence write SetOccurrence;

    // Who or what initiated the action and has responsibility for its activation.
    property requesterList : TFhirReferenceList read GetRequesterList;
    property hasRequesterList : boolean read GetHasRequesterList;

    // Id [identifier??] of the clause or question text related to the requester of this action in the referenced form or QuestionnaireResponse.
    property requesterLinkIdList : TFhirStringList read GetRequesterLinkIdList;
    property hasRequesterLinkIdList : boolean read GetHasRequesterLinkIdList;

    // The type of individual that is desired or required to perform or not perform the action.
    property performerTypeList : TFhirCodeableConceptList read GetPerformerTypeList;
    property hasPerformerTypeList : boolean read GetHasPerformerTypeList;

    // Typed access to The type of role or competency of an individual desired or required to perform or not perform the action. (defined for API consistency)
    property performerRole : TFhirCodeableConcept read FPerformerRole write SetPerformerRole;
    // The type of role or competency of an individual desired or required to perform or not perform the action.
    property performerRoleElement : TFhirCodeableConcept read FPerformerRole write SetPerformerRole;

    // Typed access to Indicates who or what is being asked to perform (or not perform) the ction. (defined for API consistency)
    property performer : TFhirReference read FPerformer write SetPerformer;
    // Indicates who or what is being asked to perform (or not perform) the ction.
    property performerElement : TFhirReference read FPerformer write SetPerformer;

    // Id [identifier??] of the clause or question text related to the reason type or reference of this  action in the referenced form or QuestionnaireResponse.
    property performerLinkIdList : TFhirStringList read GetPerformerLinkIdList;
    property hasPerformerLinkIdList : boolean read GetHasPerformerLinkIdList;

    // Rationale for the action to be performed or not performed. Describes why the action is permitted or prohibited. Either a coded concept, or another resource whose existence justifies permitting or not permitting this action.
    property reasonList : TFhirCodeableReferenceList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Id [identifier??] of the clause or question text related to the reason type or reference of this  action in the referenced form or QuestionnaireResponse.
    property reasonLinkIdList : TFhirStringList read GetReasonLinkIdList;
    property hasReasonLinkIdList : boolean read GetHasReasonLinkIdList;

    // Comments made about the term action made by the requester, performer, subject or other participants.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Security labels that protects the action.
    property securityLabelNumberList : TFhirUnsignedIntList read GetSecurityLabelNumberList;
    property hasSecurityLabelNumberList : boolean read GetHasSecurityLabelNumberList;

  end;

  TFhirContractTermActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermActionList;
    function GetCurrent : TFhirContractTermAction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractTermActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermAction read GetCurrent;
  end;

  TFhirContractTermActionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractTermAction;
    procedure SetItemN(index : Integer; value : TFhirContractTermAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractTermActionList; overload;
    function Clone : TFhirContractTermActionList; overload;
    function GetEnumerator : TFhirContractTermActionListEnumerator;
    
    //  Add a FhirContractTermAction to the end of the list.
    function Append : TFhirContractTermAction;
    
    // Add an already existing FhirContractTermAction to the end of the list.
    function AddItem(value : TFhirContractTermAction) : TFhirContractTermAction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermAction) : Integer;
    
    // Insert FhirContractTermAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermAction;
    
    // Insert an existing FhirContractTermAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermAction);
    
    // Get the iIndexth FhirContractTermAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermAction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractTermActions[index : Integer] : TFhirContractTermAction read GetItemN write SetItemN; default;
  End;

  // Entity of the action.
  TFhirContractTermActionSubject = class (TFhirBackboneElement)
  protected
    FreferenceList : TFhirReferenceList;
    FRole : TFhirCodeableConcept;
    function GetReferenceList : TFhirReferenceList;
    function GetHasReferenceList : Boolean;
    procedure SetRole(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermActionSubject; overload;
    function Clone : TFhirContractTermActionSubject; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The entity the action is performed or not performed on or for.
    property referenceList : TFhirReferenceList read GetReferenceList;
    property hasReferenceList : boolean read GetHasReferenceList;

    // Typed access to Role type of agent assigned roles in this Contract. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // Role type of agent assigned roles in this Contract.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

  end;

  TFhirContractTermActionSubjectListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermActionSubjectList;
    function GetCurrent : TFhirContractTermActionSubject;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractTermActionSubjectList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermActionSubject read GetCurrent;
  end;

  TFhirContractTermActionSubjectList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractTermActionSubject;
    procedure SetItemN(index : Integer; value : TFhirContractTermActionSubject);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractTermActionSubjectList; overload;
    function Clone : TFhirContractTermActionSubjectList; overload;
    function GetEnumerator : TFhirContractTermActionSubjectListEnumerator;
    
    //  Add a FhirContractTermActionSubject to the end of the list.
    function Append : TFhirContractTermActionSubject;
    
    // Add an already existing FhirContractTermActionSubject to the end of the list.
    function AddItem(value : TFhirContractTermActionSubject) : TFhirContractTermActionSubject; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermActionSubject) : Integer;
    
    // Insert FhirContractTermActionSubject before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermActionSubject;
    
    // Insert an existing FhirContractTermActionSubject before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermActionSubject);
    
    // Get the iIndexth FhirContractTermActionSubject. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermActionSubject);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermActionSubject;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractTermActionSubjects[index : Integer] : TFhirContractTermActionSubject read GetItemN write SetItemN; default;
  End;

  // Parties with legal standing in the Contract, including the principal parties, the grantor(s) and grantee(s), which are any person or organization bound by the contract, and any ancillary parties, which facilitate the execution of the contract such as a notary or witness.
  TFhirContractSigner = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCoding;
    FParty : TFhirReference;
    FsignatureList : TFhirSignatureList;
    procedure SetType_(value : TFhirCoding);
    procedure SetParty(value : TFhirReference);
    function GetSignatureList : TFhirSignatureList;
    function GetHasSignatureList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractSigner; overload;
    function Clone : TFhirContractSigner; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Role of this Contract signer, e.g. notary, grantee. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // Role of this Contract signer, e.g. notary, grantee.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Typed access to Party which is a signator to this Contract. (defined for API consistency)
    property party : TFhirReference read FParty write SetParty;
    // Party which is a signator to this Contract.
    property partyElement : TFhirReference read FParty write SetParty;

    // Legally binding Contract DSIG signature contents in Base64.
    property signatureList : TFhirSignatureList read GetSignatureList;
    property hasSignatureList : boolean read GetHasSignatureList;

  end;

  TFhirContractSignerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractSignerList;
    function GetCurrent : TFhirContractSigner;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractSignerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractSigner read GetCurrent;
  end;

  TFhirContractSignerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractSigner;
    procedure SetItemN(index : Integer; value : TFhirContractSigner);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractSignerList; overload;
    function Clone : TFhirContractSignerList; overload;
    function GetEnumerator : TFhirContractSignerListEnumerator;
    
    //  Add a FhirContractSigner to the end of the list.
    function Append : TFhirContractSigner;
    
    // Add an already existing FhirContractSigner to the end of the list.
    function AddItem(value : TFhirContractSigner) : TFhirContractSigner; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractSigner) : Integer;
    
    // Insert FhirContractSigner before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractSigner;
    
    // Insert an existing FhirContractSigner before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractSigner);
    
    // Get the iIndexth FhirContractSigner. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractSigner);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractSigner;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractSigners[index : Integer] : TFhirContractSigner read GetItemN write SetItemN; default;
  End;

  // The "patient friendly language" versionof the Contract in whole or in parts. "Patient friendly language" means the representation of the Contract and Contract Provisions in a manner that is readily accessible and understandable by a layperson in accordance with best practices for communication styles that ensure that those agreeing to or signing the Contract understand the roles, actions, obligations, responsibilities, and implication of the agreement.
  TFhirContractFriendly = class (TFhirBackboneElement)
  protected
    FContent : TFhirDataType;
    procedure SetContent(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractFriendly; overload;
    function Clone : TFhirContractFriendly; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Human readable rendering of this Contract in a format and representation intended to enhance comprehension and ensure understandability. (defined for API consistency)
    property content : TFhirDataType read FContent write SetContent;
    // Human readable rendering of this Contract in a format and representation intended to enhance comprehension and ensure understandability.
    property contentElement : TFhirDataType read FContent write SetContent;

  end;

  TFhirContractFriendlyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractFriendlyList;
    function GetCurrent : TFhirContractFriendly;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractFriendlyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractFriendly read GetCurrent;
  end;

  TFhirContractFriendlyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractFriendly;
    procedure SetItemN(index : Integer; value : TFhirContractFriendly);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractFriendlyList; overload;
    function Clone : TFhirContractFriendlyList; overload;
    function GetEnumerator : TFhirContractFriendlyListEnumerator;
    
    //  Add a FhirContractFriendly to the end of the list.
    function Append : TFhirContractFriendly;
    
    // Add an already existing FhirContractFriendly to the end of the list.
    function AddItem(value : TFhirContractFriendly) : TFhirContractFriendly; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractFriendly) : Integer;
    
    // Insert FhirContractFriendly before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractFriendly;
    
    // Insert an existing FhirContractFriendly before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractFriendly);
    
    // Get the iIndexth FhirContractFriendly. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractFriendly);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractFriendly;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractFriendlies[index : Integer] : TFhirContractFriendly read GetItemN write SetItemN; default;
  End;

  // List of Legal expressions or representations of this Contract.
  TFhirContractLegal = class (TFhirBackboneElement)
  protected
    FContent : TFhirDataType;
    procedure SetContent(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractLegal; overload;
    function Clone : TFhirContractLegal; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Contract legal text in human renderable form. (defined for API consistency)
    property content : TFhirDataType read FContent write SetContent;
    // Contract legal text in human renderable form.
    property contentElement : TFhirDataType read FContent write SetContent;

  end;

  TFhirContractLegalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractLegalList;
    function GetCurrent : TFhirContractLegal;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractLegalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractLegal read GetCurrent;
  end;

  TFhirContractLegalList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractLegal;
    procedure SetItemN(index : Integer; value : TFhirContractLegal);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractLegalList; overload;
    function Clone : TFhirContractLegalList; overload;
    function GetEnumerator : TFhirContractLegalListEnumerator;
    
    //  Add a FhirContractLegal to the end of the list.
    function Append : TFhirContractLegal;
    
    // Add an already existing FhirContractLegal to the end of the list.
    function AddItem(value : TFhirContractLegal) : TFhirContractLegal; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractLegal) : Integer;
    
    // Insert FhirContractLegal before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractLegal;
    
    // Insert an existing FhirContractLegal before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractLegal);
    
    // Get the iIndexth FhirContractLegal. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractLegal);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractLegal;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractLegals[index : Integer] : TFhirContractLegal read GetItemN write SetItemN; default;
  End;

  // List of Computable Policy Rule Language Representations of this Contract.
  TFhirContractRule = class (TFhirBackboneElement)
  protected
    FContent : TFhirDataType;
    procedure SetContent(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractRule; overload;
    function Clone : TFhirContractRule; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Computable Contract conveyed using a policy rule language (e.g. XACML, DKAL, SecPal). (defined for API consistency)
    property content : TFhirDataType read FContent write SetContent;
    // Computable Contract conveyed using a policy rule language (e.g. XACML, DKAL, SecPal).
    property contentElement : TFhirDataType read FContent write SetContent;

  end;

  TFhirContractRuleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractRuleList;
    function GetCurrent : TFhirContractRule;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractRuleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractRule read GetCurrent;
  end;

  TFhirContractRuleList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractRule;
    procedure SetItemN(index : Integer; value : TFhirContractRule);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractRuleList; overload;
    function Clone : TFhirContractRuleList; overload;
    function GetEnumerator : TFhirContractRuleListEnumerator;
    
    //  Add a FhirContractRule to the end of the list.
    function Append : TFhirContractRule;
    
    // Add an already existing FhirContractRule to the end of the list.
    function AddItem(value : TFhirContractRule) : TFhirContractRule; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractRule) : Integer;
    
    // Insert FhirContractRule before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractRule;
    
    // Insert an existing FhirContractRule before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractRule);
    
    // Get the iIndexth FhirContractRule. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractRule);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractRule;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractRules[index : Integer] : TFhirContractRule read GetItemN write SetItemN; default;
  End;

  // Legally enforceable, formally recorded unilateral or bilateral directive i.e., a policy or agreement.
  TFhirContract = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FUrl : TFhirUri;
    FVersion : TFhirString;
    FStatus : TFhirEnum;
    FLegalState : TFhirCodeableConcept;
    FInstantiatesCanonical : TFhirReference;
    FInstantiatesUri : TFhirUri;
    FContentDerivative : TFhirCodeableConcept;
    FIssued : TFhirDateTime;
    FApplies : TFhirPeriod;
    FExpirationType : TFhirCodeableConcept;
    FsubjectList : TFhirReferenceList;
    FauthorityList : TFhirReferenceList;
    FdomainList : TFhirReferenceList;
    FsiteList : TFhirReferenceList;
    FName : TFhirString;
    FTitle : TFhirString;
    FSubtitle : TFhirString;
    FaliasList : TFhirStringList;
    FAuthor : TFhirReference;
    FScope : TFhirCodeableConcept;
    FTopic : TFhirDataType;
    FType_ : TFhirCodeableConcept;
    FsubTypeList : TFhirCodeableConceptList;
    FContentDefinition : TFhirContractContentDefinition;
    FtermList : TFhirContractTermList;
    FsupportingInfoList : TFhirReferenceList;
    FrelevantHistoryList : TFhirReferenceList;
    FsignerList : TFhirContractSignerList;
    FfriendlyList : TFhirContractFriendlyList;
    FlegalList : TFhirContractLegalList;
    FruleList : TFhirContractRuleList;
    FLegallyBinding : TFhirDataType;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirContractResourceStatusCodesEnum;
    procedure SetStatusST(value : TFhirContractResourceStatusCodesEnum);
    procedure SetLegalState(value : TFhirCodeableConcept);
    procedure SetInstantiatesCanonical(value : TFhirReference);
    procedure SetInstantiatesUri(value : TFhirUri);
    function GetInstantiatesUriST : String;
    procedure SetInstantiatesUriST(value : String);
    procedure SetContentDerivative(value : TFhirCodeableConcept);
    procedure SetIssued(value : TFhirDateTime);
    function GetIssuedST : TFslDateTime;
    procedure SetIssuedST(value : TFslDateTime);
    procedure SetApplies(value : TFhirPeriod);
    procedure SetExpirationType(value : TFhirCodeableConcept);
    function GetSubjectList : TFhirReferenceList;
    function GetHasSubjectList : Boolean;
    function GetAuthorityList : TFhirReferenceList;
    function GetHasAuthorityList : Boolean;
    function GetDomainList : TFhirReferenceList;
    function GetHasDomainList : Boolean;
    function GetSiteList : TFhirReferenceList;
    function GetHasSiteList : Boolean;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetSubtitle(value : TFhirString);
    function GetSubtitleST : String;
    procedure SetSubtitleST(value : String);
    function GetAliasList : TFhirStringList;
    function GetHasAliasList : Boolean;
    procedure SetAuthor(value : TFhirReference);
    procedure SetScope(value : TFhirCodeableConcept);
    procedure SetTopic(value : TFhirDataType);
    procedure SetType_(value : TFhirCodeableConcept);
    function GetSubTypeList : TFhirCodeableConceptList;
    function GetHasSubTypeList : Boolean;
    procedure SetContentDefinition(value : TFhirContractContentDefinition);
    function GetTermList : TFhirContractTermList;
    function GetHasTermList : Boolean;
    function GetSupportingInfoList : TFhirReferenceList;
    function GetHasSupportingInfoList : Boolean;
    function GetRelevantHistoryList : TFhirReferenceList;
    function GetHasRelevantHistoryList : Boolean;
    function GetSignerList : TFhirContractSignerList;
    function GetHasSignerList : Boolean;
    function GetFriendlyList : TFhirContractFriendlyList;
    function GetHasFriendlyList : Boolean;
    function GetLegalList : TFhirContractLegalList;
    function GetHasLegalList : Boolean;
    function GetRuleList : TFhirContractRuleList;
    function GetHasRuleList : Boolean;
    procedure SetLegallyBinding(value : TFhirDataType);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContract; overload;
    function Clone : TFhirContract; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique identifier for this Contract or a derivative that references a Source Contract.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Canonical identifier for this contract, represented as a URI (globally unique).
    property url : String read GetUrlST write SetUrlST;
    // Canonical identifier for this contract, represented as a URI (globally unique).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to An edition identifier used for business purposes to label business significant variants.
    property version : String read GetVersionST write SetVersionST;
    // An edition identifier used for business purposes to label business significant variants.
    property versionElement : TFhirString read FVersion write SetVersion;

    // The status of the resource instance.
    property status : TFhirContractResourceStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Legal states of the formation of a legal instrument, which is a formally executed written document that can be formally attributed to its author, records and formally expresses a legally enforceable act, process, or contractual duty, obligation, or right, and therefore evidences that act, process, or agreement. (defined for API consistency)
    property legalState : TFhirCodeableConcept read FLegalState write SetLegalState;
    // Legal states of the formation of a legal instrument, which is a formally executed written document that can be formally attributed to its author, records and formally expresses a legally enforceable act, process, or contractual duty, obligation, or right, and therefore evidences that act, process, or agreement.
    property legalStateElement : TFhirCodeableConcept read FLegalState write SetLegalState;

    // Typed access to The URL pointing to a FHIR-defined Contract Definition that is adhered to in whole or part by this Contract. (defined for API consistency)
    property instantiatesCanonical : TFhirReference read FInstantiatesCanonical write SetInstantiatesCanonical;
    // The URL pointing to a FHIR-defined Contract Definition that is adhered to in whole or part by this Contract.
    property instantiatesCanonicalElement : TFhirReference read FInstantiatesCanonical write SetInstantiatesCanonical;

    // Typed access to The URL pointing to an externally maintained definition that is adhered to in whole or in part by this Contract.
    property instantiatesUri : String read GetInstantiatesUriST write SetInstantiatesUriST;
    // The URL pointing to an externally maintained definition that is adhered to in whole or in part by this Contract.
    property instantiatesUriElement : TFhirUri read FInstantiatesUri write SetInstantiatesUri;

    // Typed access to The minimal content derived from the basal information source at a specific stage in its lifecycle. (defined for API consistency)
    property contentDerivative : TFhirCodeableConcept read FContentDerivative write SetContentDerivative;
    // The minimal content derived from the basal information source at a specific stage in its lifecycle.
    property contentDerivativeElement : TFhirCodeableConcept read FContentDerivative write SetContentDerivative;

    // Typed access to When this  Contract was issued.
    property issued : TFslDateTime read GetIssuedST write SetIssuedST;
    // When this  Contract was issued.
    property issuedElement : TFhirDateTime read FIssued write SetIssued;

    // Typed access to Relevant time or time-period when this Contract is applicable. (defined for API consistency)
    property applies : TFhirPeriod read FApplies write SetApplies;
    // Relevant time or time-period when this Contract is applicable.
    property appliesElement : TFhirPeriod read FApplies write SetApplies;

    // Typed access to Event resulting in discontinuation or termination of this Contract instance by one or more parties to the contract. (defined for API consistency)
    property expirationType : TFhirCodeableConcept read FExpirationType write SetExpirationType;
    // Event resulting in discontinuation or termination of this Contract instance by one or more parties to the contract.
    property expirationTypeElement : TFhirCodeableConcept read FExpirationType write SetExpirationType;

    // The target entity impacted by or of interest to parties to the agreement.
    property subjectList : TFhirReferenceList read GetSubjectList;
    property hasSubjectList : boolean read GetHasSubjectList;

    // A formally or informally recognized grouping of people, principals, organizations, or jurisdictions formed for the purpose of achieving some form of collective action such as the promulgation, administration and enforcement of contracts and policies.
    property authorityList : TFhirReferenceList read GetAuthorityList;
    property hasAuthorityList : boolean read GetHasAuthorityList;

    // Recognized governance framework or system operating with a circumscribed scope in accordance with specified principles, policies, processes or procedures for managing rights, actions, or behaviors of parties or principals relative to resources.
    property domainList : TFhirReferenceList read GetDomainList;
    property hasDomainList : boolean read GetHasDomainList;

    // Sites in which the contract is complied with,  exercised, or in force.
    property siteList : TFhirReferenceList read GetSiteList;
    property hasSiteList : boolean read GetHasSiteList;

    // Typed access to A natural language name identifying this Contract definition, derivative, or instance in any legal state. Provides additional information about its content. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying this Contract definition, derivative, or instance in any legal state. Provides additional information about its content. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for this Contract definition, derivative, or instance in any legal state.t giving additional information about its content.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for this Contract definition, derivative, or instance in any legal state.t giving additional information about its content.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to An explanatory or alternate user-friendly title for this Contract definition, derivative, or instance in any legal state.t giving additional information about its content.
    property subtitle : String read GetSubtitleST write SetSubtitleST;
    // An explanatory or alternate user-friendly title for this Contract definition, derivative, or instance in any legal state.t giving additional information about its content.
    property subtitleElement : TFhirString read FSubtitle write SetSubtitle;

    // Alternative representation of the title for this Contract definition, derivative, or instance in any legal state., e.g., a domain specific contract number related to legislation.
    property aliasList : TFhirStringList read GetAliasList;
    property hasAliasList : boolean read GetHasAliasList;

    // Typed access to The individual or organization that authored the Contract definition, derivative, or instance in any legal state. (defined for API consistency)
    property author : TFhirReference read FAuthor write SetAuthor;
    // The individual or organization that authored the Contract definition, derivative, or instance in any legal state.
    property authorElement : TFhirReference read FAuthor write SetAuthor;

    // Typed access to A selector of legal concerns for this Contract definition, derivative, or instance in any legal state. (defined for API consistency)
    property scope : TFhirCodeableConcept read FScope write SetScope;
    // A selector of legal concerns for this Contract definition, derivative, or instance in any legal state.
    property scopeElement : TFhirCodeableConcept read FScope write SetScope;

    // Typed access to Narrows the range of legal concerns to focus on the achievement of specific contractual objectives. (defined for API consistency)
    property topic : TFhirDataType read FTopic write SetTopic;
    // Narrows the range of legal concerns to focus on the achievement of specific contractual objectives.
    property topicElement : TFhirDataType read FTopic write SetTopic;

    // Typed access to A high-level category for the legal instrument, whether constructed as a Contract definition, derivative, or instance in any legal state.  Provides additional information about its content within the context of the Contract's scope to distinguish the kinds of systems that would be interested in the contract. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A high-level category for the legal instrument, whether constructed as a Contract definition, derivative, or instance in any legal state.  Provides additional information about its content within the context of the Contract's scope to distinguish the kinds of systems that would be interested in the contract.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Sub-category for the Contract that distinguishes the kinds of systems that would be interested in the Contract within the context of the Contract's scope.
    property subTypeList : TFhirCodeableConceptList read GetSubTypeList;
    property hasSubTypeList : boolean read GetHasSubTypeList;

    // Typed access to Precusory content developed with a focus and intent of supporting the formation a Contract instance, which may be associated with and transformable into a Contract. (defined for API consistency)
    property contentDefinition : TFhirContractContentDefinition read FContentDefinition write SetContentDefinition;
    // Precusory content developed with a focus and intent of supporting the formation a Contract instance, which may be associated with and transformable into a Contract.
    property contentDefinitionElement : TFhirContractContentDefinition read FContentDefinition write SetContentDefinition;

    // One or more Contract Provisions, which may be related and conveyed as a group, and may contain nested groups.
    property termList : TFhirContractTermList read GetTermList;
    property hasTermList : boolean read GetHasTermList;

    // Information that may be needed by/relevant to the performer in their execution of this term action.
    property supportingInfoList : TFhirReferenceList read GetSupportingInfoList;
    property hasSupportingInfoList : boolean read GetHasSupportingInfoList;

    // Links to Provenance records for past versions of this Contract definition, derivative, or instance, which identify key state transitions or updates that are likely to be relevant to a user looking at the current version of the Contract.  The Provence.entity indicates the target that was changed in the update. http://build.fhir.org/provenance-definitions.html#Provenance.entity.
    property relevantHistoryList : TFhirReferenceList read GetRelevantHistoryList;
    property hasRelevantHistoryList : boolean read GetHasRelevantHistoryList;

    // Parties with legal standing in the Contract, including the principal parties, the grantor(s) and grantee(s), which are any person or organization bound by the contract, and any ancillary parties, which facilitate the execution of the contract such as a notary or witness.
    property signerList : TFhirContractSignerList read GetSignerList;
    property hasSignerList : boolean read GetHasSignerList;

    // The "patient friendly language" versionof the Contract in whole or in parts. "Patient friendly language" means the representation of the Contract and Contract Provisions in a manner that is readily accessible and understandable by a layperson in accordance with best practices for communication styles that ensure that those agreeing to or signing the Contract understand the roles, actions, obligations, responsibilities, and implication of the agreement.
    property friendlyList : TFhirContractFriendlyList read GetFriendlyList;
    property hasFriendlyList : boolean read GetHasFriendlyList;

    // List of Legal expressions or representations of this Contract.
    property legalList : TFhirContractLegalList read GetLegalList;
    property hasLegalList : boolean read GetHasLegalList;

    // List of Computable Policy Rule Language Representations of this Contract.
    property ruleList : TFhirContractRuleList read GetRuleList;
    property hasRuleList : boolean read GetHasRuleList;

    // Typed access to Legally binding Contract: This is the signed and legally recognized representation of the Contract, which is considered the "source of truth" and which would be the basis for legal action related to enforcement of this Contract. (defined for API consistency)
    property legallyBinding : TFhirDataType read FLegallyBinding write SetLegallyBinding;
    // Legally binding Contract: This is the signed and legally recognized representation of the Contract, which is considered the "source of truth" and which would be the basis for legal action related to enforcement of this Contract.
    property legallyBindingElement : TFhirDataType read FLegallyBinding write SetLegallyBinding;

  end;

  TFhirContractListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractList;
    function GetCurrent : TFhirContract;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContract read GetCurrent;
  end;

  TFhirContractList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContract;
    procedure SetItemN(index : Integer; value : TFhirContract);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractList; overload;
    function Clone : TFhirContractList; overload;
    function GetEnumerator : TFhirContractListEnumerator;
    
    //  Add a FhirContract to the end of the list.
    function Append : TFhirContract;
    
    // Add an already existing FhirContract to the end of the list.
    function AddItem(value : TFhirContract) : TFhirContract; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContract) : Integer;
    
    // Insert FhirContract before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContract;
    
    // Insert an existing FhirContract before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContract);
    
    // Get the iIndexth FhirContract. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContract);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContract;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContracts[index : Integer] : TFhirContract read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_EVIDENCE}
  // Evidence variable such as population, exposure, or outcome.
  TFhirEvidenceVariableDefinition = class (TFhirBackboneElement)
  protected
    FDescription : TFhirMarkdown;
    FnoteList : TFhirAnnotationList;
    FVariableRole : TFhirCodeableConcept;
    FObserved : TFhirReference;
    FIntended : TFhirReference;
    FDirectnessMatch : TFhirCodeableConcept;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetVariableRole(value : TFhirCodeableConcept);
    procedure SetObserved(value : TFhirReference);
    procedure SetIntended(value : TFhirReference);
    procedure SetDirectnessMatch(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceVariableDefinition; overload;
    function Clone : TFhirEvidenceVariableDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A text description or summary of the variable.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A text description or summary of the variable.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Footnotes and/or explanatory notes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to population | subpopulation | exposure | referenceExposure | measuredVariable | confounder. (defined for API consistency)
    property variableRole : TFhirCodeableConcept read FVariableRole write SetVariableRole;
    // population | subpopulation | exposure | referenceExposure | measuredVariable | confounder.
    property variableRoleElement : TFhirCodeableConcept read FVariableRole write SetVariableRole;

    // Typed access to Definition of the actual variable related to the statistic(s). (defined for API consistency)
    property observed : TFhirReference read FObserved write SetObserved;
    // Definition of the actual variable related to the statistic(s).
    property observedElement : TFhirReference read FObserved write SetObserved;

    // Typed access to Definition of the intended variable related to the Evidence. (defined for API consistency)
    property intended : TFhirReference read FIntended write SetIntended;
    // Definition of the intended variable related to the Evidence.
    property intendedElement : TFhirReference read FIntended write SetIntended;

    // Typed access to Indication of quality of match between intended variable to actual variable. (defined for API consistency)
    property directnessMatch : TFhirCodeableConcept read FDirectnessMatch write SetDirectnessMatch;
    // Indication of quality of match between intended variable to actual variable.
    property directnessMatchElement : TFhirCodeableConcept read FDirectnessMatch write SetDirectnessMatch;

  end;

  TFhirEvidenceVariableDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceVariableDefinitionList;
    function GetCurrent : TFhirEvidenceVariableDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceVariableDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceVariableDefinition read GetCurrent;
  end;

  TFhirEvidenceVariableDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceVariableDefinition;
    procedure SetItemN(index : Integer; value : TFhirEvidenceVariableDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceVariableDefinitionList; overload;
    function Clone : TFhirEvidenceVariableDefinitionList; overload;
    function GetEnumerator : TFhirEvidenceVariableDefinitionListEnumerator;
    
    //  Add a FhirEvidenceVariableDefinition to the end of the list.
    function Append : TFhirEvidenceVariableDefinition;
    
    // Add an already existing FhirEvidenceVariableDefinition to the end of the list.
    function AddItem(value : TFhirEvidenceVariableDefinition) : TFhirEvidenceVariableDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceVariableDefinition) : Integer;
    
    // Insert FhirEvidenceVariableDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceVariableDefinition;
    
    // Insert an existing FhirEvidenceVariableDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceVariableDefinition);
    
    // Get the iIndexth FhirEvidenceVariableDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceVariableDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceVariableDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceVariableDefinitions[index : Integer] : TFhirEvidenceVariableDefinition read GetItemN write SetItemN; default;
  End;

  // Values and parameters for a single statistic.
  TFhirEvidenceStatistic = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FnoteList : TFhirAnnotationList;
    FStatisticType : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FNumberOfEvents : TFhirUnsignedInt;
    FNumberAffected : TFhirUnsignedInt;
    FSampleSize : TFhirEvidenceStatisticSampleSize;
    FattributeEstimateList : TFhirEvidenceStatisticAttributeEstimateList;
    FmodelCharacteristicList : TFhirEvidenceStatisticModelCharacteristicList;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetStatisticType(value : TFhirCodeableConcept);
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetNumberOfEvents(value : TFhirUnsignedInt);
    function GetNumberOfEventsST : String;
    procedure SetNumberOfEventsST(value : String);
    procedure SetNumberAffected(value : TFhirUnsignedInt);
    function GetNumberAffectedST : String;
    procedure SetNumberAffectedST(value : String);
    procedure SetSampleSize(value : TFhirEvidenceStatisticSampleSize);
    function GetAttributeEstimateList : TFhirEvidenceStatisticAttributeEstimateList;
    function GetHasAttributeEstimateList : Boolean;
    function GetModelCharacteristicList : TFhirEvidenceStatisticModelCharacteristicList;
    function GetHasModelCharacteristicList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceStatistic; overload;
    function Clone : TFhirEvidenceStatistic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A description of the content value of the statistic.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A description of the content value of the statistic.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Footnotes and/or explanatory notes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to Type of statistic, e.g., relative risk. (defined for API consistency)
    property statisticType : TFhirCodeableConcept read FStatisticType write SetStatisticType;
    // Type of statistic, e.g., relative risk.
    property statisticTypeElement : TFhirCodeableConcept read FStatisticType write SetStatisticType;

    // Typed access to When the measured variable is handled categorically, the category element is used to define which category the statistic is reporting. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // When the measured variable is handled categorically, the category element is used to define which category the statistic is reporting.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Statistic value. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // Statistic value.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The number of events associated with the statistic, where the unit of analysis is different from numberAffected, sampleSize.knownDataCount and sampleSize.numberOfParticipants.
    property numberOfEvents : String read GetNumberOfEventsST write SetNumberOfEventsST;
    // The number of events associated with the statistic, where the unit of analysis is different from numberAffected, sampleSize.knownDataCount and sampleSize.numberOfParticipants.
    property numberOfEventsElement : TFhirUnsignedInt read FNumberOfEvents write SetNumberOfEvents;

    // Typed access to The number of participants affected where the unit of analysis is the same as sampleSize.knownDataCount and sampleSize.numberOfParticipants.
    property numberAffected : String read GetNumberAffectedST write SetNumberAffectedST;
    // The number of participants affected where the unit of analysis is the same as sampleSize.knownDataCount and sampleSize.numberOfParticipants.
    property numberAffectedElement : TFhirUnsignedInt read FNumberAffected write SetNumberAffected;

    // Typed access to Number of samples in the statistic. (defined for API consistency)
    property sampleSize : TFhirEvidenceStatisticSampleSize read FSampleSize write SetSampleSize;
    // Number of samples in the statistic.
    property sampleSizeElement : TFhirEvidenceStatisticSampleSize read FSampleSize write SetSampleSize;

    // A statistical attribute of the statistic such as a measure of heterogeneity.
    property attributeEstimateList : TFhirEvidenceStatisticAttributeEstimateList read GetAttributeEstimateList;
    property hasAttributeEstimateList : boolean read GetHasAttributeEstimateList;

    // A component of the method to generate the statistic.
    property modelCharacteristicList : TFhirEvidenceStatisticModelCharacteristicList read GetModelCharacteristicList;
    property hasModelCharacteristicList : boolean read GetHasModelCharacteristicList;

  end;

  TFhirEvidenceStatisticListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceStatisticList;
    function GetCurrent : TFhirEvidenceStatistic;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceStatisticList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceStatistic read GetCurrent;
  end;

  TFhirEvidenceStatisticList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceStatistic;
    procedure SetItemN(index : Integer; value : TFhirEvidenceStatistic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceStatisticList; overload;
    function Clone : TFhirEvidenceStatisticList; overload;
    function GetEnumerator : TFhirEvidenceStatisticListEnumerator;
    
    //  Add a FhirEvidenceStatistic to the end of the list.
    function Append : TFhirEvidenceStatistic;
    
    // Add an already existing FhirEvidenceStatistic to the end of the list.
    function AddItem(value : TFhirEvidenceStatistic) : TFhirEvidenceStatistic; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceStatistic) : Integer;
    
    // Insert FhirEvidenceStatistic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceStatistic;
    
    // Insert an existing FhirEvidenceStatistic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceStatistic);
    
    // Get the iIndexth FhirEvidenceStatistic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceStatistic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceStatistic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceStatistics[index : Integer] : TFhirEvidenceStatistic read GetItemN write SetItemN; default;
  End;

  // Number of samples in the statistic.
  TFhirEvidenceStatisticSampleSize = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FnoteList : TFhirAnnotationList;
    FNumberOfStudies : TFhirUnsignedInt;
    FNumberOfParticipants : TFhirUnsignedInt;
    FKnownDataCount : TFhirUnsignedInt;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetNumberOfStudies(value : TFhirUnsignedInt);
    function GetNumberOfStudiesST : String;
    procedure SetNumberOfStudiesST(value : String);
    procedure SetNumberOfParticipants(value : TFhirUnsignedInt);
    function GetNumberOfParticipantsST : String;
    procedure SetNumberOfParticipantsST(value : String);
    procedure SetKnownDataCount(value : TFhirUnsignedInt);
    function GetKnownDataCountST : String;
    procedure SetKnownDataCountST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceStatisticSampleSize; overload;
    function Clone : TFhirEvidenceStatisticSampleSize; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Human-readable summary of population sample size.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Human-readable summary of population sample size.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Footnote or explanatory note about the sample size.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to Number of participants in the population.
    property numberOfStudies : String read GetNumberOfStudiesST write SetNumberOfStudiesST;
    // Number of participants in the population.
    property numberOfStudiesElement : TFhirUnsignedInt read FNumberOfStudies write SetNumberOfStudies;

    // Typed access to A human-readable string to clarify or explain concepts about the sample size.
    property numberOfParticipants : String read GetNumberOfParticipantsST write SetNumberOfParticipantsST;
    // A human-readable string to clarify or explain concepts about the sample size.
    property numberOfParticipantsElement : TFhirUnsignedInt read FNumberOfParticipants write SetNumberOfParticipants;

    // Typed access to Number of participants with known results for measured variables.
    property knownDataCount : String read GetKnownDataCountST write SetKnownDataCountST;
    // Number of participants with known results for measured variables.
    property knownDataCountElement : TFhirUnsignedInt read FKnownDataCount write SetKnownDataCount;

  end;

  TFhirEvidenceStatisticSampleSizeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceStatisticSampleSizeList;
    function GetCurrent : TFhirEvidenceStatisticSampleSize;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceStatisticSampleSizeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceStatisticSampleSize read GetCurrent;
  end;

  TFhirEvidenceStatisticSampleSizeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceStatisticSampleSize;
    procedure SetItemN(index : Integer; value : TFhirEvidenceStatisticSampleSize);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceStatisticSampleSizeList; overload;
    function Clone : TFhirEvidenceStatisticSampleSizeList; overload;
    function GetEnumerator : TFhirEvidenceStatisticSampleSizeListEnumerator;
    
    //  Add a FhirEvidenceStatisticSampleSize to the end of the list.
    function Append : TFhirEvidenceStatisticSampleSize;
    
    // Add an already existing FhirEvidenceStatisticSampleSize to the end of the list.
    function AddItem(value : TFhirEvidenceStatisticSampleSize) : TFhirEvidenceStatisticSampleSize; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceStatisticSampleSize) : Integer;
    
    // Insert FhirEvidenceStatisticSampleSize before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceStatisticSampleSize;
    
    // Insert an existing FhirEvidenceStatisticSampleSize before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceStatisticSampleSize);
    
    // Get the iIndexth FhirEvidenceStatisticSampleSize. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceStatisticSampleSize);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceStatisticSampleSize;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceStatisticSampleSizes[index : Integer] : TFhirEvidenceStatisticSampleSize read GetItemN write SetItemN; default;
  End;

  // A statistical attribute of the statistic such as a measure of heterogeneity.
  TFhirEvidenceStatisticAttributeEstimate = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FnoteList : TFhirAnnotationList;
    FType_ : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FLevel : TFhirDecimal;
    FRange : TFhirRange;
    FattributeEstimateList : TFhirEvidenceStatisticAttributeEstimateList;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetLevel(value : TFhirDecimal);
    function GetLevelST : String;
    procedure SetLevelST(value : String);
    procedure SetRange(value : TFhirRange);
    function GetAttributeEstimateList : TFhirEvidenceStatisticAttributeEstimateList;
    function GetHasAttributeEstimateList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceStatisticAttributeEstimate; overload;
    function Clone : TFhirEvidenceStatisticAttributeEstimate; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Human-readable summary of the estimate.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Human-readable summary of the estimate.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Footnote or explanatory note about the estimate.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to The type of attribute estimate, e.g., confidence interval or p value. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of attribute estimate, e.g., confidence interval or p value.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The singular quantity of the attribute estimate, for attribute estimates represented as single values; also used to report unit of measure. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The singular quantity of the attribute estimate, for attribute estimates represented as single values; also used to report unit of measure.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to Use 95 for a 95% confidence interval.
    property level : String read GetLevelST write SetLevelST;
    // Use 95 for a 95% confidence interval.
    property levelElement : TFhirDecimal read FLevel write SetLevel;

    // Typed access to Lower bound of confidence interval. (defined for API consistency)
    property range : TFhirRange read FRange write SetRange;
    // Lower bound of confidence interval.
    property rangeElement : TFhirRange read FRange write SetRange;

    // A nested attribute estimate; which is the attribute estimate of an attribute estimate.
    property attributeEstimateList : TFhirEvidenceStatisticAttributeEstimateList read GetAttributeEstimateList;
    property hasAttributeEstimateList : boolean read GetHasAttributeEstimateList;

  end;

  TFhirEvidenceStatisticAttributeEstimateListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceStatisticAttributeEstimateList;
    function GetCurrent : TFhirEvidenceStatisticAttributeEstimate;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceStatisticAttributeEstimateList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceStatisticAttributeEstimate read GetCurrent;
  end;

  TFhirEvidenceStatisticAttributeEstimateList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceStatisticAttributeEstimate;
    procedure SetItemN(index : Integer; value : TFhirEvidenceStatisticAttributeEstimate);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceStatisticAttributeEstimateList; overload;
    function Clone : TFhirEvidenceStatisticAttributeEstimateList; overload;
    function GetEnumerator : TFhirEvidenceStatisticAttributeEstimateListEnumerator;
    
    //  Add a FhirEvidenceStatisticAttributeEstimate to the end of the list.
    function Append : TFhirEvidenceStatisticAttributeEstimate;
    
    // Add an already existing FhirEvidenceStatisticAttributeEstimate to the end of the list.
    function AddItem(value : TFhirEvidenceStatisticAttributeEstimate) : TFhirEvidenceStatisticAttributeEstimate; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceStatisticAttributeEstimate) : Integer;
    
    // Insert FhirEvidenceStatisticAttributeEstimate before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceStatisticAttributeEstimate;
    
    // Insert an existing FhirEvidenceStatisticAttributeEstimate before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceStatisticAttributeEstimate);
    
    // Get the iIndexth FhirEvidenceStatisticAttributeEstimate. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceStatisticAttributeEstimate);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceStatisticAttributeEstimate;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceStatisticAttributeEstimates[index : Integer] : TFhirEvidenceStatisticAttributeEstimate read GetItemN write SetItemN; default;
  End;

  // A component of the method to generate the statistic.
  TFhirEvidenceStatisticModelCharacteristic = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FValue : TFhirQuantity;
    FvariableList : TFhirEvidenceStatisticModelCharacteristicVariableList;
    FattributeEstimateList : TFhirEvidenceStatisticAttributeEstimateList;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirQuantity);
    function GetVariableList : TFhirEvidenceStatisticModelCharacteristicVariableList;
    function GetHasVariableList : Boolean;
    function GetAttributeEstimateList : TFhirEvidenceStatisticAttributeEstimateList;
    function GetHasAttributeEstimateList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceStatisticModelCharacteristic; overload;
    function Clone : TFhirEvidenceStatisticModelCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Description of a component of the method to generate the statistic. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Description of a component of the method to generate the statistic.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Further specification of the quantified value of the component of the method to generate the statistic. (defined for API consistency)
    property value : TFhirQuantity read FValue write SetValue;
    // Further specification of the quantified value of the component of the method to generate the statistic.
    property valueElement : TFhirQuantity read FValue write SetValue;

    // A variable adjusted for in the adjusted analysis.
    property variableList : TFhirEvidenceStatisticModelCharacteristicVariableList read GetVariableList;
    property hasVariableList : boolean read GetHasVariableList;

    // An attribute of the statistic used as a model characteristic.
    property attributeEstimateList : TFhirEvidenceStatisticAttributeEstimateList read GetAttributeEstimateList;
    property hasAttributeEstimateList : boolean read GetHasAttributeEstimateList;

  end;

  TFhirEvidenceStatisticModelCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceStatisticModelCharacteristicList;
    function GetCurrent : TFhirEvidenceStatisticModelCharacteristic;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceStatisticModelCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceStatisticModelCharacteristic read GetCurrent;
  end;

  TFhirEvidenceStatisticModelCharacteristicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceStatisticModelCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirEvidenceStatisticModelCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceStatisticModelCharacteristicList; overload;
    function Clone : TFhirEvidenceStatisticModelCharacteristicList; overload;
    function GetEnumerator : TFhirEvidenceStatisticModelCharacteristicListEnumerator;
    
    //  Add a FhirEvidenceStatisticModelCharacteristic to the end of the list.
    function Append : TFhirEvidenceStatisticModelCharacteristic;
    
    // Add an already existing FhirEvidenceStatisticModelCharacteristic to the end of the list.
    function AddItem(value : TFhirEvidenceStatisticModelCharacteristic) : TFhirEvidenceStatisticModelCharacteristic; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceStatisticModelCharacteristic) : Integer;
    
    // Insert FhirEvidenceStatisticModelCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceStatisticModelCharacteristic;
    
    // Insert an existing FhirEvidenceStatisticModelCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceStatisticModelCharacteristic);
    
    // Get the iIndexth FhirEvidenceStatisticModelCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceStatisticModelCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceStatisticModelCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceStatisticModelCharacteristics[index : Integer] : TFhirEvidenceStatisticModelCharacteristic read GetItemN write SetItemN; default;
  End;

  // A variable adjusted for in the adjusted analysis.
  TFhirEvidenceStatisticModelCharacteristicVariable = class (TFhirBackboneElement)
  protected
    FVariableDefinition : TFhirReference;
    FHandling : TFhirEnum;
    FvalueCategoryList : TFhirCodeableConceptList;
    FvalueQuantityList : TFhirQuantityList;
    FvalueRangeList : TFhirRangeList;
    procedure SetVariableDefinition(value : TFhirReference);
    procedure SetHandling(value : TFhirEnum);
    function GetHandlingST : TFhirEvidenceVariableHandlingEnum;
    procedure SetHandlingST(value : TFhirEvidenceVariableHandlingEnum);
    function GetValueCategoryList : TFhirCodeableConceptList;
    function GetHasValueCategoryList : Boolean;
    function GetValueQuantityList : TFhirQuantityList;
    function GetHasValueQuantityList : Boolean;
    function GetValueRangeList : TFhirRangeList;
    function GetHasValueRangeList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceStatisticModelCharacteristicVariable; overload;
    function Clone : TFhirEvidenceStatisticModelCharacteristicVariable; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Description of the variable. (defined for API consistency)
    property variableDefinition : TFhirReference read FVariableDefinition write SetVariableDefinition;
    // Description of the variable.
    property variableDefinitionElement : TFhirReference read FVariableDefinition write SetVariableDefinition;

    // How the variable is classified for use in adjusted analysis.
    property handling : TFhirEvidenceVariableHandlingEnum read GetHandlingST write SetHandlingST;
    property handlingElement : TFhirEnum read FHandling write SetHandling;

    // Description for grouping of ordinal or polychotomous variables.
    property valueCategoryList : TFhirCodeableConceptList read GetValueCategoryList;
    property hasValueCategoryList : boolean read GetHasValueCategoryList;

    // Discrete value for grouping of ordinal or polychotomous variables.
    property valueQuantityList : TFhirQuantityList read GetValueQuantityList;
    property hasValueQuantityList : boolean read GetHasValueQuantityList;

    // Range of values for grouping of ordinal or polychotomous variables.
    property valueRangeList : TFhirRangeList read GetValueRangeList;
    property hasValueRangeList : boolean read GetHasValueRangeList;

  end;

  TFhirEvidenceStatisticModelCharacteristicVariableListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceStatisticModelCharacteristicVariableList;
    function GetCurrent : TFhirEvidenceStatisticModelCharacteristicVariable;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceStatisticModelCharacteristicVariableList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceStatisticModelCharacteristicVariable read GetCurrent;
  end;

  TFhirEvidenceStatisticModelCharacteristicVariableList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceStatisticModelCharacteristicVariable;
    procedure SetItemN(index : Integer; value : TFhirEvidenceStatisticModelCharacteristicVariable);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceStatisticModelCharacteristicVariableList; overload;
    function Clone : TFhirEvidenceStatisticModelCharacteristicVariableList; overload;
    function GetEnumerator : TFhirEvidenceStatisticModelCharacteristicVariableListEnumerator;
    
    //  Add a FhirEvidenceStatisticModelCharacteristicVariable to the end of the list.
    function Append : TFhirEvidenceStatisticModelCharacteristicVariable;
    
    // Add an already existing FhirEvidenceStatisticModelCharacteristicVariable to the end of the list.
    function AddItem(value : TFhirEvidenceStatisticModelCharacteristicVariable) : TFhirEvidenceStatisticModelCharacteristicVariable; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceStatisticModelCharacteristicVariable) : Integer;
    
    // Insert FhirEvidenceStatisticModelCharacteristicVariable before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceStatisticModelCharacteristicVariable;
    
    // Insert an existing FhirEvidenceStatisticModelCharacteristicVariable before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceStatisticModelCharacteristicVariable);
    
    // Get the iIndexth FhirEvidenceStatisticModelCharacteristicVariable. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceStatisticModelCharacteristicVariable);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceStatisticModelCharacteristicVariable;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceStatisticModelCharacteristicVariables[index : Integer] : TFhirEvidenceStatisticModelCharacteristicVariable read GetItemN write SetItemN; default;
  End;

  // Assessment of certainty, confidence in the estimates, or quality of the evidence.
  TFhirEvidenceCertainty = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FnoteList : TFhirAnnotationList;
    FType_ : TFhirCodeableConcept;
    FRating : TFhirCodeableConcept;
    FRater : TFhirString;
    FsubcomponentList : TFhirEvidenceCertaintyList;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetRating(value : TFhirCodeableConcept);
    procedure SetRater(value : TFhirString);
    function GetRaterST : String;
    procedure SetRaterST(value : String);
    function GetSubcomponentList : TFhirEvidenceCertaintyList;
    function GetHasSubcomponentList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceCertainty; overload;
    function Clone : TFhirEvidenceCertainty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Textual description of certainty.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Textual description of certainty.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Footnotes and/or explanatory notes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to Aspect of certainty being rated. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Aspect of certainty being rated.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Assessment or judgement of the aspect. (defined for API consistency)
    property rating : TFhirCodeableConcept read FRating write SetRating;
    // Assessment or judgement of the aspect.
    property ratingElement : TFhirCodeableConcept read FRating write SetRating;

    // Typed access to Individual or group who did the rating.
    property rater : String read GetRaterST write SetRaterST;
    // Individual or group who did the rating.
    property raterElement : TFhirString read FRater write SetRater;

    // A domain or subdomain of certainty.
    property subcomponentList : TFhirEvidenceCertaintyList read GetSubcomponentList;
    property hasSubcomponentList : boolean read GetHasSubcomponentList;

  end;

  TFhirEvidenceCertaintyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceCertaintyList;
    function GetCurrent : TFhirEvidenceCertainty;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceCertaintyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceCertainty read GetCurrent;
  end;

  TFhirEvidenceCertaintyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceCertainty;
    procedure SetItemN(index : Integer; value : TFhirEvidenceCertainty);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceCertaintyList; overload;
    function Clone : TFhirEvidenceCertaintyList; overload;
    function GetEnumerator : TFhirEvidenceCertaintyListEnumerator;
    
    //  Add a FhirEvidenceCertainty to the end of the list.
    function Append : TFhirEvidenceCertainty;
    
    // Add an already existing FhirEvidenceCertainty to the end of the list.
    function AddItem(value : TFhirEvidenceCertainty) : TFhirEvidenceCertainty; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceCertainty) : Integer;
    
    // Insert FhirEvidenceCertainty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceCertainty;
    
    // Insert an existing FhirEvidenceCertainty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceCertainty);
    
    // Get the iIndexth FhirEvidenceCertainty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceCertainty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceCertainty;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceCertainties[index : Integer] : TFhirEvidenceCertainty read GetItemN write SetItemN; default;
  End;

  // The Evidence Resource provides a machine-interpretable expression of an evidence concept including the evidence variables (e.g., population, exposures/interventions, comparators, outcomes, measured variables, confounding variables), the statistics, and the certainty of this evidence.
  TFhirEvidence = class (TFhirMetadataResource)
  protected
    FCiteAs : TFhirDataType;
    FAssertion : TFhirMarkdown;
    FnoteList : TFhirAnnotationList;
    FvariableDefinitionList : TFhirEvidenceVariableDefinitionList;
    FSynthesisType : TFhirCodeableConcept;
    FstudyDesignList : TFhirCodeableConceptList;
    FstatisticList : TFhirEvidenceStatisticList;
    FcertaintyList : TFhirEvidenceCertaintyList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetCiteAs(value : TFhirDataType);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    procedure SetApprovalDate(value : TFhirDate);
    function GetApprovalDateST : TFslDateTime;
    procedure SetApprovalDateST(value : TFslDateTime);
    procedure SetLastReviewDate(value : TFhirDate);
    function GetLastReviewDateST : TFslDateTime;
    procedure SetLastReviewDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    function GetAuthorList : TFhirContactDetailList;
    function GetHasAuthorList : Boolean;
    function GetEditorList : TFhirContactDetailList;
    function GetHasEditorList : Boolean;
    function GetReviewerList : TFhirContactDetailList;
    function GetHasReviewerList : Boolean;
    function GetEndorserList : TFhirContactDetailList;
    function GetHasEndorserList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetAssertion(value : TFhirMarkdown);
    function GetAssertionST : String;
    procedure SetAssertionST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetVariableDefinitionList : TFhirEvidenceVariableDefinitionList;
    function GetHasVariableDefinitionList : Boolean;
    procedure SetSynthesisType(value : TFhirCodeableConcept);
    function GetStudyDesignList : TFhirCodeableConceptList;
    function GetHasStudyDesignList : Boolean;
    function GetStatisticList : TFhirEvidenceStatisticList;
    function GetHasStatisticList : Boolean;
    function GetCertaintyList : TFhirEvidenceCertaintyList;
    function GetHasCertaintyList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidence; overload;
    function Clone : TFhirEvidence; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this evidence when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which an authoritative instance of this summary is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the summary is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this evidence when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which an authoritative instance of this summary is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the summary is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this summary when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the summary when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the summary author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the summary when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the summary author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the evidence. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the evidence. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the summary.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the summary.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to Citation Resource or display of suggested citation for this evidence. (defined for API consistency)
    property citeAs : TFhirDataType read FCiteAs write SetCiteAs;
    // Citation Resource or display of suggested citation for this evidence.
    property citeAsElement : TFhirDataType read FCiteAs write SetCiteAs;

    // The status of this summary. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this resource is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this resource is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the summary was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the summary changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the summary was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the summary changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate evidence instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The name of the organization or individual responsible for the release and ongoing maintenance of the evidence.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual responsible for the release and ongoing maintenance of the evidence.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // An individiual, organization, or device primarily involved in the creation and maintenance of the content.
    property authorList : TFhirContactDetailList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // An individiual, organization, or device primarily responsible for internal coherence of the content.
    property editorList : TFhirContactDetailList read GetEditorList;
    property hasEditorList : boolean read GetHasEditorList;

    // An individiual, organization, or device primarily responsible for review of some aspect of the content.
    property reviewerList : TFhirContactDetailList read GetReviewerList;
    property hasReviewerList : boolean read GetHasReviewerList;

    // An individiual, organization, or device responsible for officially endorsing the content for use in some setting.
    property endorserList : TFhirContactDetailList read GetEndorserList;
    property hasEndorserList : boolean read GetHasEndorserList;

    // Link or citation to artifact associated with the summary.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // Typed access to A free text natural language description of the evidence from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the evidence from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to Declarative description of the Evidence.
    property assertion : String read GetAssertionST write SetAssertionST;
    // Declarative description of the Evidence.
    property assertionElement : TFhirMarkdown read FAssertion write SetAssertion;

    // Footnotes and/or explanatory notes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Evidence variable such as population, exposure, or outcome.
    property variableDefinitionList : TFhirEvidenceVariableDefinitionList read GetVariableDefinitionList;
    property hasVariableDefinitionList : boolean read GetHasVariableDefinitionList;

    // Typed access to The method to combine studies. (defined for API consistency)
    property synthesisType : TFhirCodeableConcept read FSynthesisType write SetSynthesisType;
    // The method to combine studies.
    property synthesisTypeElement : TFhirCodeableConcept read FSynthesisType write SetSynthesisType;

    // The design of the study that produced this evidence. The design is described with any number of study design characteristics.
    property studyDesignList : TFhirCodeableConceptList read GetStudyDesignList;
    property hasStudyDesignList : boolean read GetHasStudyDesignList;

    // Values and parameters for a single statistic.
    property statisticList : TFhirEvidenceStatisticList read GetStatisticList;
    property hasStatisticList : boolean read GetHasStatisticList;

    // Assessment of certainty, confidence in the estimates, or quality of the evidence.
    property certaintyList : TFhirEvidenceCertaintyList read GetCertaintyList;
    property hasCertaintyList : boolean read GetHasCertaintyList;

  end;

  TFhirEvidenceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceList;
    function GetCurrent : TFhirEvidence;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidence read GetCurrent;
  end;

  TFhirEvidenceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidence;
    procedure SetItemN(index : Integer; value : TFhirEvidence);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceList; overload;
    function Clone : TFhirEvidenceList; overload;
    function GetEnumerator : TFhirEvidenceListEnumerator;
    
    //  Add a FhirEvidence to the end of the list.
    function Append : TFhirEvidence;
    
    // Add an already existing FhirEvidence to the end of the list.
    function AddItem(value : TFhirEvidence) : TFhirEvidence; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidence) : Integer;
    
    // Insert FhirEvidence before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidence;
    
    // Insert an existing FhirEvidence before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidence);
    
    // Get the iIndexth FhirEvidence. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidence);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidence;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidences[index : Integer] : TFhirEvidence read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEREPORT}
  // Specifies the subject or focus of the report. Answers "What is this report about?".
  TFhirEvidenceReportSubject = class (TFhirBackboneElement)
  protected
    FcharacteristicList : TFhirEvidenceReportSubjectCharacteristicList;
    FnoteList : TFhirAnnotationList;
    function GetCharacteristicList : TFhirEvidenceReportSubjectCharacteristicList;
    function GetHasCharacteristicList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceReportSubject; overload;
    function Clone : TFhirEvidenceReportSubject; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Characteristic.
    property characteristicList : TFhirEvidenceReportSubjectCharacteristicList read GetCharacteristicList;
    property hasCharacteristicList : boolean read GetHasCharacteristicList;

    // Used for general notes and annotations not coded elsewhere.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirEvidenceReportSubjectListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceReportSubjectList;
    function GetCurrent : TFhirEvidenceReportSubject;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceReportSubjectList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceReportSubject read GetCurrent;
  end;

  TFhirEvidenceReportSubjectList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceReportSubject;
    procedure SetItemN(index : Integer; value : TFhirEvidenceReportSubject);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceReportSubjectList; overload;
    function Clone : TFhirEvidenceReportSubjectList; overload;
    function GetEnumerator : TFhirEvidenceReportSubjectListEnumerator;
    
    //  Add a FhirEvidenceReportSubject to the end of the list.
    function Append : TFhirEvidenceReportSubject;
    
    // Add an already existing FhirEvidenceReportSubject to the end of the list.
    function AddItem(value : TFhirEvidenceReportSubject) : TFhirEvidenceReportSubject; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceReportSubject) : Integer;
    
    // Insert FhirEvidenceReportSubject before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceReportSubject;
    
    // Insert an existing FhirEvidenceReportSubject before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceReportSubject);
    
    // Get the iIndexth FhirEvidenceReportSubject. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceReportSubject);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceReportSubject;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceReportSubjects[index : Integer] : TFhirEvidenceReportSubject read GetItemN write SetItemN; default;
  End;

  // Characteristic.
  TFhirEvidenceReportSubjectCharacteristic = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FValue : TFhirDataType;
    FExclude : TFhirBoolean;
    FPeriod : TFhirPeriod;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
    procedure SetExclude(value : TFhirBoolean);
    function GetExcludeST : Boolean;
    procedure SetExcludeST(value : Boolean);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceReportSubjectCharacteristic; overload;
    function Clone : TFhirEvidenceReportSubjectCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Characteristic code. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Characteristic code.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Characteristic value. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // Characteristic value.
    property valueElement : TFhirDataType read FValue write SetValue;

    // Typed access to Is used to express not the characteristic.
    property exclude : Boolean read GetExcludeST write SetExcludeST;
    // Is used to express not the characteristic.
    property excludeElement : TFhirBoolean read FExclude write SetExclude;

    // Typed access to Timeframe for the characteristic. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Timeframe for the characteristic.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirEvidenceReportSubjectCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceReportSubjectCharacteristicList;
    function GetCurrent : TFhirEvidenceReportSubjectCharacteristic;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceReportSubjectCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceReportSubjectCharacteristic read GetCurrent;
  end;

  TFhirEvidenceReportSubjectCharacteristicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceReportSubjectCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirEvidenceReportSubjectCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceReportSubjectCharacteristicList; overload;
    function Clone : TFhirEvidenceReportSubjectCharacteristicList; overload;
    function GetEnumerator : TFhirEvidenceReportSubjectCharacteristicListEnumerator;
    
    //  Add a FhirEvidenceReportSubjectCharacteristic to the end of the list.
    function Append : TFhirEvidenceReportSubjectCharacteristic;
    
    // Add an already existing FhirEvidenceReportSubjectCharacteristic to the end of the list.
    function AddItem(value : TFhirEvidenceReportSubjectCharacteristic) : TFhirEvidenceReportSubjectCharacteristic; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceReportSubjectCharacteristic) : Integer;
    
    // Insert FhirEvidenceReportSubjectCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceReportSubjectCharacteristic;
    
    // Insert an existing FhirEvidenceReportSubjectCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceReportSubjectCharacteristic);
    
    // Get the iIndexth FhirEvidenceReportSubjectCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceReportSubjectCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceReportSubjectCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceReportSubjectCharacteristics[index : Integer] : TFhirEvidenceReportSubjectCharacteristic read GetItemN write SetItemN; default;
  End;

  // Relationships that this composition has with other compositions or documents that already exist.
  TFhirEvidenceReportRelatesTo = class (TFhirBackboneElement)
  protected
    FCode : TFhirEnum;
    FTarget : TFhirEvidenceReportRelatesToTarget;
    procedure SetCode(value : TFhirEnum);
    function GetCodeST : TFhirReportRelationshipTypeEnum;
    procedure SetCodeST(value : TFhirReportRelationshipTypeEnum);
    procedure SetTarget(value : TFhirEvidenceReportRelatesToTarget);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceReportRelatesTo; overload;
    function Clone : TFhirEvidenceReportRelatesTo; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of relationship that this composition has with anther composition or document.
    property code : TFhirReportRelationshipTypeEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to The target composition/document of this relationship. (defined for API consistency)
    property target : TFhirEvidenceReportRelatesToTarget read FTarget write SetTarget;
    // The target composition/document of this relationship.
    property targetElement : TFhirEvidenceReportRelatesToTarget read FTarget write SetTarget;

  end;

  TFhirEvidenceReportRelatesToListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceReportRelatesToList;
    function GetCurrent : TFhirEvidenceReportRelatesTo;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceReportRelatesToList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceReportRelatesTo read GetCurrent;
  end;

  TFhirEvidenceReportRelatesToList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceReportRelatesTo;
    procedure SetItemN(index : Integer; value : TFhirEvidenceReportRelatesTo);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceReportRelatesToList; overload;
    function Clone : TFhirEvidenceReportRelatesToList; overload;
    function GetEnumerator : TFhirEvidenceReportRelatesToListEnumerator;
    
    //  Add a FhirEvidenceReportRelatesTo to the end of the list.
    function Append : TFhirEvidenceReportRelatesTo;
    
    // Add an already existing FhirEvidenceReportRelatesTo to the end of the list.
    function AddItem(value : TFhirEvidenceReportRelatesTo) : TFhirEvidenceReportRelatesTo; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceReportRelatesTo) : Integer;
    
    // Insert FhirEvidenceReportRelatesTo before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceReportRelatesTo;
    
    // Insert an existing FhirEvidenceReportRelatesTo before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceReportRelatesTo);
    
    // Get the iIndexth FhirEvidenceReportRelatesTo. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceReportRelatesTo);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceReportRelatesTo;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceReportRelatesTos[index : Integer] : TFhirEvidenceReportRelatesTo read GetItemN write SetItemN; default;
  End;

  // The target composition/document of this relationship.
  TFhirEvidenceReportRelatesToTarget = class (TFhirBackboneElement)
  protected
    FUrl : TFhirUri;
    FIdentifier : TFhirIdentifier;
    FDisplay : TFhirMarkdown;
    FResource : TFhirReference;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetDisplay(value : TFhirMarkdown);
    function GetDisplayST : String;
    procedure SetDisplayST(value : String);
    procedure SetResource(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceReportRelatesToTarget; overload;
    function Clone : TFhirEvidenceReportRelatesToTarget; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Target of the relationship URL.
    property url : String read GetUrlST write SetUrlST;
    // Target of the relationship URL.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to Target of the relationship Identifier. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Target of the relationship Identifier.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Target of the relationship Display.
    property display : String read GetDisplayST write SetDisplayST;
    // Target of the relationship Display.
    property displayElement : TFhirMarkdown read FDisplay write SetDisplay;

    // Typed access to Target of the relationship Resource reference. (defined for API consistency)
    property resource : TFhirReference read FResource write SetResource;
    // Target of the relationship Resource reference.
    property resourceElement : TFhirReference read FResource write SetResource;

  end;

  TFhirEvidenceReportRelatesToTargetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceReportRelatesToTargetList;
    function GetCurrent : TFhirEvidenceReportRelatesToTarget;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceReportRelatesToTargetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceReportRelatesToTarget read GetCurrent;
  end;

  TFhirEvidenceReportRelatesToTargetList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceReportRelatesToTarget;
    procedure SetItemN(index : Integer; value : TFhirEvidenceReportRelatesToTarget);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceReportRelatesToTargetList; overload;
    function Clone : TFhirEvidenceReportRelatesToTargetList; overload;
    function GetEnumerator : TFhirEvidenceReportRelatesToTargetListEnumerator;
    
    //  Add a FhirEvidenceReportRelatesToTarget to the end of the list.
    function Append : TFhirEvidenceReportRelatesToTarget;
    
    // Add an already existing FhirEvidenceReportRelatesToTarget to the end of the list.
    function AddItem(value : TFhirEvidenceReportRelatesToTarget) : TFhirEvidenceReportRelatesToTarget; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceReportRelatesToTarget) : Integer;
    
    // Insert FhirEvidenceReportRelatesToTarget before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceReportRelatesToTarget;
    
    // Insert an existing FhirEvidenceReportRelatesToTarget before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceReportRelatesToTarget);
    
    // Get the iIndexth FhirEvidenceReportRelatesToTarget. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceReportRelatesToTarget);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceReportRelatesToTarget;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceReportRelatesToTargets[index : Integer] : TFhirEvidenceReportRelatesToTarget read GetItemN write SetItemN; default;
  End;

  // The root of the sections that make up the composition.
  TFhirEvidenceReportSection = class (TFhirBackboneElement)
  protected
    FTitle : TFhirString;
    FFocus : TFhirCodeableConcept;
    FFocusReference : TFhirReference;
    FauthorList : TFhirReferenceList;
    FText : TFhirNarrative;
    FMode : TFhirEnum;
    FOrderedBy : TFhirCodeableConcept;
    FentryClassifierList : TFhirCodeableConceptList;
    FentryReferenceList : TFhirReferenceList;
    FentryQuantityList : TFhirQuantityList;
    FEmptyReason : TFhirCodeableConcept;
    FsectionList : TFhirEvidenceReportSectionList;
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetFocus(value : TFhirCodeableConcept);
    procedure SetFocusReference(value : TFhirReference);
    function GetAuthorList : TFhirReferenceList;
    function GetHasAuthorList : Boolean;
    procedure SetText(value : TFhirNarrative);
    procedure SetMode(value : TFhirEnum);
    function GetModeST : TFhirListModeEnum;
    procedure SetModeST(value : TFhirListModeEnum);
    procedure SetOrderedBy(value : TFhirCodeableConcept);
    function GetEntryClassifierList : TFhirCodeableConceptList;
    function GetHasEntryClassifierList : Boolean;
    function GetEntryReferenceList : TFhirReferenceList;
    function GetHasEntryReferenceList : Boolean;
    function GetEntryQuantityList : TFhirQuantityList;
    function GetHasEntryQuantityList : Boolean;
    procedure SetEmptyReason(value : TFhirCodeableConcept);
    function GetSectionList : TFhirEvidenceReportSectionList;
    function GetHasSectionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceReportSection; overload;
    function Clone : TFhirEvidenceReportSection; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The label for this particular section.  This will be part of the rendered content for the document, and is often used to build a table of contents.
    property title : String read GetTitleST write SetTitleST;
    // The label for this particular section.  This will be part of the rendered content for the document, and is often used to build a table of contents.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to A code identifying the kind of content contained within the section. This should be consistent with the section title. (defined for API consistency)
    property focus : TFhirCodeableConcept read FFocus write SetFocus;
    // A code identifying the kind of content contained within the section. This should be consistent with the section title.
    property focusElement : TFhirCodeableConcept read FFocus write SetFocus;

    // Typed access to A definitional Resource identifying the kind of content contained within the section. This should be consistent with the section title. (defined for API consistency)
    property focusReference : TFhirReference read FFocusReference write SetFocusReference;
    // A definitional Resource identifying the kind of content contained within the section. This should be consistent with the section title.
    property focusReferenceElement : TFhirReference read FFocusReference write SetFocusReference;

    // Identifies who is responsible for the information in this section, not necessarily who typed it in.
    property authorList : TFhirReferenceList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // Typed access to A human-readable narrative that contains the attested content of the section, used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is peferred to contain sufficient detail to make it acceptable for a human to just read the narrative. (defined for API consistency)
    property text : TFhirNarrative read FText write SetText;
    // A human-readable narrative that contains the attested content of the section, used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is peferred to contain sufficient detail to make it acceptable for a human to just read the narrative.
    property textElement : TFhirNarrative read FText write SetText;

    // How the entry list was prepared - whether it is a working list that is suitable for being maintained on an ongoing basis, or if it represents a snapshot of a list of items from another source, or whether it is a prepared list where items may be marked as added, modified or deleted.
    property mode : TFhirListModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to Specifies the order applied to the items in the section entries. (defined for API consistency)
    property orderedBy : TFhirCodeableConcept read FOrderedBy write SetOrderedBy;
    // Specifies the order applied to the items in the section entries.
    property orderedByElement : TFhirCodeableConcept read FOrderedBy write SetOrderedBy;

    // Specifies any type of classification of the evidence report.
    property entryClassifierList : TFhirCodeableConceptList read GetEntryClassifierList;
    property hasEntryClassifierList : boolean read GetHasEntryClassifierList;

    // A reference to the actual resource from which the narrative in the section is derived.
    property entryReferenceList : TFhirReferenceList read GetEntryReferenceList;
    property hasEntryReferenceList : boolean read GetHasEntryReferenceList;

    // Quantity as content.
    property entryQuantityList : TFhirQuantityList read GetEntryQuantityList;
    property hasEntryQuantityList : boolean read GetHasEntryQuantityList;

    // Typed access to If the section is empty, why the list is empty. An empty section typically has some text explaining the empty reason. (defined for API consistency)
    property emptyReason : TFhirCodeableConcept read FEmptyReason write SetEmptyReason;
    // If the section is empty, why the list is empty. An empty section typically has some text explaining the empty reason.
    property emptyReasonElement : TFhirCodeableConcept read FEmptyReason write SetEmptyReason;

    // A nested sub-section within this section.
    property sectionList : TFhirEvidenceReportSectionList read GetSectionList;
    property hasSectionList : boolean read GetHasSectionList;

  end;

  TFhirEvidenceReportSectionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceReportSectionList;
    function GetCurrent : TFhirEvidenceReportSection;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceReportSectionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceReportSection read GetCurrent;
  end;

  TFhirEvidenceReportSectionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceReportSection;
    procedure SetItemN(index : Integer; value : TFhirEvidenceReportSection);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceReportSectionList; overload;
    function Clone : TFhirEvidenceReportSectionList; overload;
    function GetEnumerator : TFhirEvidenceReportSectionListEnumerator;
    
    //  Add a FhirEvidenceReportSection to the end of the list.
    function Append : TFhirEvidenceReportSection;
    
    // Add an already existing FhirEvidenceReportSection to the end of the list.
    function AddItem(value : TFhirEvidenceReportSection) : TFhirEvidenceReportSection; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceReportSection) : Integer;
    
    // Insert FhirEvidenceReportSection before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceReportSection;
    
    // Insert an existing FhirEvidenceReportSection before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceReportSection);
    
    // Get the iIndexth FhirEvidenceReportSection. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceReportSection);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceReportSection;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceReportSections[index : Integer] : TFhirEvidenceReportSection read GetItemN write SetItemN; default;
  End;

  // The EvidenceReport Resource is a specialized container for a collection of resources and codeable concepts, adapted to support compositions of Evidence, EvidenceVariable, and Citation resources and related concepts.
  TFhirEvidenceReport = class (TFhirMetadataResource)
  protected
    FrelatedIdentifierList : TFhirIdentifierList;
    FCiteAs : TFhirDataType;
    FType_ : TFhirCodeableConcept;
    FnoteList : TFhirAnnotationList;
    FSubject : TFhirEvidenceReportSubject;
    FrelatesToList : TFhirEvidenceReportRelatesToList;
    FsectionList : TFhirEvidenceReportSectionList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetRelatedIdentifierList : TFhirIdentifierList;
    function GetHasRelatedIdentifierList : Boolean;
    procedure SetCiteAs(value : TFhirDataType);
    procedure SetType_(value : TFhirCodeableConcept);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    procedure SetSubject(value : TFhirEvidenceReportSubject);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    function GetAuthorList : TFhirContactDetailList;
    function GetHasAuthorList : Boolean;
    function GetEditorList : TFhirContactDetailList;
    function GetHasEditorList : Boolean;
    function GetReviewerList : TFhirContactDetailList;
    function GetHasReviewerList : Boolean;
    function GetEndorserList : TFhirContactDetailList;
    function GetHasEndorserList : Boolean;
    function GetRelatesToList : TFhirEvidenceReportRelatesToList;
    function GetHasRelatesToList : Boolean;
    function GetSectionList : TFhirEvidenceReportSectionList;
    function GetHasSectionList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceReport; overload;
    function Clone : TFhirEvidenceReport; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this EvidenceReport when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which an authoritative instance of this summary is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the summary is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this EvidenceReport when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which an authoritative instance of this summary is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the summary is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // The status of this summary. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate evidence report instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A formal identifier that is used to identify this EvidenceReport when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A formal identifier that is used to identify things closely related to this EvidenceReport.
    property relatedIdentifierList : TFhirIdentifierList read GetRelatedIdentifierList;
    property hasRelatedIdentifierList : boolean read GetHasRelatedIdentifierList;

    // Typed access to Citation Resource or display of suggested citation for this report. (defined for API consistency)
    property citeAs : TFhirDataType read FCiteAs write SetCiteAs;
    // Citation Resource or display of suggested citation for this report.
    property citeAsElement : TFhirDataType read FCiteAs write SetCiteAs;

    // Typed access to Specifies the kind of report, such as grouping of classifiers, search results, or human-compiled expression. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Specifies the kind of report, such as grouping of classifiers, search results, or human-compiled expression.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Used for footnotes and annotations.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Link, description or reference to artifact associated with the report.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // Typed access to Specifies the subject or focus of the report. Answers "What is this report about?". (defined for API consistency)
    property subject : TFhirEvidenceReportSubject read FSubject write SetSubject;
    // Specifies the subject or focus of the report. Answers "What is this report about?".
    property subjectElement : TFhirEvidenceReportSubject read FSubject write SetSubject;

    // Typed access to The name of the organization or individual responsible for the release and ongoing maintenance of the evidence report.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual responsible for the release and ongoing maintenance of the evidence report.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // An individiual, organization, or device primarily involved in the creation and maintenance of the content.
    property authorList : TFhirContactDetailList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // An individiual, organization, or device primarily responsible for internal coherence of the content.
    property editorList : TFhirContactDetailList read GetEditorList;
    property hasEditorList : boolean read GetHasEditorList;

    // An individiual, organization, or device primarily responsible for review of some aspect of the content.
    property reviewerList : TFhirContactDetailList read GetReviewerList;
    property hasReviewerList : boolean read GetHasReviewerList;

    // An individiual, organization, or device responsible for officially endorsing the content for use in some setting.
    property endorserList : TFhirContactDetailList read GetEndorserList;
    property hasEndorserList : boolean read GetHasEndorserList;

    // Relationships that this composition has with other compositions or documents that already exist.
    property relatesToList : TFhirEvidenceReportRelatesToList read GetRelatesToList;
    property hasRelatesToList : boolean read GetHasRelatesToList;

    // The root of the sections that make up the composition.
    property sectionList : TFhirEvidenceReportSectionList read GetSectionList;
    property hasSectionList : boolean read GetHasSectionList;

  end;

  TFhirEvidenceReportListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceReportList;
    function GetCurrent : TFhirEvidenceReport;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceReportList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceReport read GetCurrent;
  end;

  TFhirEvidenceReportList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceReport;
    procedure SetItemN(index : Integer; value : TFhirEvidenceReport);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceReportList; overload;
    function Clone : TFhirEvidenceReportList; overload;
    function GetEnumerator : TFhirEvidenceReportListEnumerator;
    
    //  Add a FhirEvidenceReport to the end of the list.
    function Append : TFhirEvidenceReport;
    
    // Add an already existing FhirEvidenceReport to the end of the list.
    function AddItem(value : TFhirEvidenceReport) : TFhirEvidenceReport; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceReport) : Integer;
    
    // Insert FhirEvidenceReport before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceReport;
    
    // Insert an existing FhirEvidenceReport before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceReport);
    
    // Get the iIndexth FhirEvidenceReport. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceReport);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceReport;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceReports[index : Integer] : TFhirEvidenceReport read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_EVIDENCEREPORT}
{$IFDEF FHIR_EVIDENCEVARIABLE}
  // A defining factor of the EvidenceVariable. Multiple characteristics are applied with "and" semantics.
  TFhirEvidenceVariableCharacteristic = class (TFhirBackboneElement)
  protected
    FLinkId : TFhirId;
    FDescription : TFhirString;
    FnoteList : TFhirAnnotationList;
    FExclude : TFhirBoolean;
    FDefinitionReference : TFhirReference;
    FDefinitionCanonical : TFhirCanonical;
    FDefinitionCodeableConcept : TFhirCodeableConcept;
    FDefinitionExpression : TFhirExpression;
    FDefinitionId : TFhirId;
    FDefinitionByTypeAndValue : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue;
    FDefinitionByCombination : TFhirEvidenceVariableCharacteristicDefinitionByCombination;
    FtimeFromEventList : TFhirEvidenceVariableCharacteristicTimeFromEventList;
    procedure SetLinkId(value : TFhirId);
    function GetLinkIdST : String;
    procedure SetLinkIdST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetExclude(value : TFhirBoolean);
    function GetExcludeST : Boolean;
    procedure SetExcludeST(value : Boolean);
    procedure SetDefinitionReference(value : TFhirReference);
    procedure SetDefinitionCanonical(value : TFhirCanonical);
    function GetDefinitionCanonicalST : String;
    procedure SetDefinitionCanonicalST(value : String);
    procedure SetDefinitionCodeableConcept(value : TFhirCodeableConcept);
    procedure SetDefinitionExpression(value : TFhirExpression);
    procedure SetDefinitionId(value : TFhirId);
    function GetDefinitionIdST : String;
    procedure SetDefinitionIdST(value : String);
    procedure SetDefinitionByTypeAndValue(value : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue);
    procedure SetDefinitionByCombination(value : TFhirEvidenceVariableCharacteristicDefinitionByCombination);
    function GetTimeFromEventList : TFhirEvidenceVariableCharacteristicTimeFromEventList;
    function GetHasTimeFromEventList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceVariableCharacteristic; overload;
    function Clone : TFhirEvidenceVariableCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Label used for when a characteristic refers to another characteristic.
    property linkId : String read GetLinkIdST write SetLinkIdST;
    // Label used for when a characteristic refers to another characteristic.
    property linkIdElement : TFhirId read FLinkId write SetLinkId;

    // Typed access to A short, natural language description of the characteristic that could be used to communicate the criteria to an end-user.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A short, natural language description of the characteristic that could be used to communicate the criteria to an end-user.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // A human-readable string to clarify or explain concepts about the characteristic.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to When true, this characteristic is an exclusion criterion. In other words, not matching this characteristic definition is equivalent to meeting this criterion.
    property exclude : Boolean read GetExcludeST write SetExcludeST;
    // When true, this characteristic is an exclusion criterion. In other words, not matching this characteristic definition is equivalent to meeting this criterion.
    property excludeElement : TFhirBoolean read FExclude write SetExclude;

    // Typed access to Defines the characteristic using a Reference. (defined for API consistency)
    property definitionReference : TFhirReference read FDefinitionReference write SetDefinitionReference;
    // Defines the characteristic using a Reference.
    property definitionReferenceElement : TFhirReference read FDefinitionReference write SetDefinitionReference;

    // Typed access to Defines the characteristic using Canonical.
    property definitionCanonical : String read GetDefinitionCanonicalST write SetDefinitionCanonicalST;
    // Defines the characteristic using Canonical.
    property definitionCanonicalElement : TFhirCanonical read FDefinitionCanonical write SetDefinitionCanonical;

    // Typed access to Defines the characteristic using CodeableConcept. (defined for API consistency)
    property definitionCodeableConcept : TFhirCodeableConcept read FDefinitionCodeableConcept write SetDefinitionCodeableConcept;
    // Defines the characteristic using CodeableConcept.
    property definitionCodeableConceptElement : TFhirCodeableConcept read FDefinitionCodeableConcept write SetDefinitionCodeableConcept;

    // Typed access to Defines the characteristic using Expression. (defined for API consistency)
    property definitionExpression : TFhirExpression read FDefinitionExpression write SetDefinitionExpression;
    // Defines the characteristic using Expression.
    property definitionExpressionElement : TFhirExpression read FDefinitionExpression write SetDefinitionExpression;

    // Typed access to Defines the characteristic using id.
    property definitionId : String read GetDefinitionIdST write SetDefinitionIdST;
    // Defines the characteristic using id.
    property definitionIdElement : TFhirId read FDefinitionId write SetDefinitionId;

    // Typed access to Defines the characteristic using both a type and value[x] elements. (defined for API consistency)
    property definitionByTypeAndValue : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue read FDefinitionByTypeAndValue write SetDefinitionByTypeAndValue;
    // Defines the characteristic using both a type and value[x] elements.
    property definitionByTypeAndValueElement : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue read FDefinitionByTypeAndValue write SetDefinitionByTypeAndValue;

    // Typed access to Defines the characteristic as a combination of two or more characteristics. (defined for API consistency)
    property definitionByCombination : TFhirEvidenceVariableCharacteristicDefinitionByCombination read FDefinitionByCombination write SetDefinitionByCombination;
    // Defines the characteristic as a combination of two or more characteristics.
    property definitionByCombinationElement : TFhirEvidenceVariableCharacteristicDefinitionByCombination read FDefinitionByCombination write SetDefinitionByCombination;

    // Observation time from study specified event.
    property timeFromEventList : TFhirEvidenceVariableCharacteristicTimeFromEventList read GetTimeFromEventList;
    property hasTimeFromEventList : boolean read GetHasTimeFromEventList;

  end;

  TFhirEvidenceVariableCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceVariableCharacteristicList;
    function GetCurrent : TFhirEvidenceVariableCharacteristic;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceVariableCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceVariableCharacteristic read GetCurrent;
  end;

  TFhirEvidenceVariableCharacteristicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceVariableCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirEvidenceVariableCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceVariableCharacteristicList; overload;
    function Clone : TFhirEvidenceVariableCharacteristicList; overload;
    function GetEnumerator : TFhirEvidenceVariableCharacteristicListEnumerator;
    
    //  Add a FhirEvidenceVariableCharacteristic to the end of the list.
    function Append : TFhirEvidenceVariableCharacteristic;
    
    // Add an already existing FhirEvidenceVariableCharacteristic to the end of the list.
    function AddItem(value : TFhirEvidenceVariableCharacteristic) : TFhirEvidenceVariableCharacteristic; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceVariableCharacteristic) : Integer;
    
    // Insert FhirEvidenceVariableCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceVariableCharacteristic;
    
    // Insert an existing FhirEvidenceVariableCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceVariableCharacteristic);
    
    // Get the iIndexth FhirEvidenceVariableCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceVariableCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceVariableCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceVariableCharacteristics[index : Integer] : TFhirEvidenceVariableCharacteristic read GetItemN write SetItemN; default;
  End;

  // Defines the characteristic using both a type and value[x] elements.
  TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FmethodList : TFhirCodeableConceptList;
    FDevice : TFhirReference;
    FValue : TFhirDataType;
    FOffset : TFhirCodeableConcept;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetMethodList : TFhirCodeableConceptList;
    function GetHasMethodList : Boolean;
    procedure SetDevice(value : TFhirReference);
    procedure SetValue(value : TFhirDataType);
    procedure SetOffset(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue; overload;
    function Clone : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Used to express the type of characteristic. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Used to express the type of characteristic.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Method for how the characteristic value was determined.
    property methodList : TFhirCodeableConceptList read GetMethodList;
    property hasMethodList : boolean read GetHasMethodList;

    // Typed access to Device used for determining characteristic. (defined for API consistency)
    property device : TFhirReference read FDevice write SetDevice;
    // Device used for determining characteristic.
    property deviceElement : TFhirReference read FDevice write SetDevice;

    // Typed access to Defines the characteristic when paired with characteristic.type. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // Defines the characteristic when paired with characteristic.type.
    property valueElement : TFhirDataType read FValue write SetValue;

    // Typed access to Defines the reference point for comparison when valueQuantity is not compared to zero. (defined for API consistency)
    property offset : TFhirCodeableConcept read FOffset write SetOffset;
    // Defines the reference point for comparison when valueQuantity is not compared to zero.
    property offsetElement : TFhirCodeableConcept read FOffset write SetOffset;

  end;

  TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList;
    function GetCurrent : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue read GetCurrent;
  end;

  TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue;
    procedure SetItemN(index : Integer; value : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList; overload;
    function Clone : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList; overload;
    function GetEnumerator : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueListEnumerator;
    
    //  Add a FhirEvidenceVariableCharacteristicDefinitionByTypeAndValue to the end of the list.
    function Append : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue;
    
    // Add an already existing FhirEvidenceVariableCharacteristicDefinitionByTypeAndValue to the end of the list.
    function AddItem(value : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue) : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue) : Integer;
    
    // Insert FhirEvidenceVariableCharacteristicDefinitionByTypeAndValue before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue;
    
    // Insert an existing FhirEvidenceVariableCharacteristicDefinitionByTypeAndValue before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue);
    
    // Get the iIndexth FhirEvidenceVariableCharacteristicDefinitionByTypeAndValue. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceVariableCharacteristicDefinitionByTypeAndValues[index : Integer] : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue read GetItemN write SetItemN; default;
  End;

  // Defines the characteristic as a combination of two or more characteristics.
  TFhirEvidenceVariableCharacteristicDefinitionByCombination = class (TFhirBackboneElement)
  protected
    FCode : TFhirEnum;
    FThreshold : TFhirPositiveInt;
    FcharacteristicList : TFhirEvidenceVariableCharacteristicList;
    procedure SetCode(value : TFhirEnum);
    function GetCodeST : TFhirCharacteristicCombinationEnum;
    procedure SetCodeST(value : TFhirCharacteristicCombinationEnum);
    procedure SetThreshold(value : TFhirPositiveInt);
    function GetThresholdST : String;
    procedure SetThresholdST(value : String);
    function GetCharacteristicList : TFhirEvidenceVariableCharacteristicList;
    function GetHasCharacteristicList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceVariableCharacteristicDefinitionByCombination; overload;
    function Clone : TFhirEvidenceVariableCharacteristicDefinitionByCombination; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Used to specify if two or more characteristics are combined with OR or AND.
    property code : TFhirCharacteristicCombinationEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to Provides the value of "n" when "at-least" or "at-most" codes are used.
    property threshold : String read GetThresholdST write SetThresholdST;
    // Provides the value of "n" when "at-least" or "at-most" codes are used.
    property thresholdElement : TFhirPositiveInt read FThreshold write SetThreshold;

    // A defining factor of the characteristic.
    property characteristicList : TFhirEvidenceVariableCharacteristicList read GetCharacteristicList;
    property hasCharacteristicList : boolean read GetHasCharacteristicList;

  end;

  TFhirEvidenceVariableCharacteristicDefinitionByCombinationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceVariableCharacteristicDefinitionByCombinationList;
    function GetCurrent : TFhirEvidenceVariableCharacteristicDefinitionByCombination;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceVariableCharacteristicDefinitionByCombinationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceVariableCharacteristicDefinitionByCombination read GetCurrent;
  end;

  TFhirEvidenceVariableCharacteristicDefinitionByCombinationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceVariableCharacteristicDefinitionByCombination;
    procedure SetItemN(index : Integer; value : TFhirEvidenceVariableCharacteristicDefinitionByCombination);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceVariableCharacteristicDefinitionByCombinationList; overload;
    function Clone : TFhirEvidenceVariableCharacteristicDefinitionByCombinationList; overload;
    function GetEnumerator : TFhirEvidenceVariableCharacteristicDefinitionByCombinationListEnumerator;
    
    //  Add a FhirEvidenceVariableCharacteristicDefinitionByCombination to the end of the list.
    function Append : TFhirEvidenceVariableCharacteristicDefinitionByCombination;
    
    // Add an already existing FhirEvidenceVariableCharacteristicDefinitionByCombination to the end of the list.
    function AddItem(value : TFhirEvidenceVariableCharacteristicDefinitionByCombination) : TFhirEvidenceVariableCharacteristicDefinitionByCombination; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceVariableCharacteristicDefinitionByCombination) : Integer;
    
    // Insert FhirEvidenceVariableCharacteristicDefinitionByCombination before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceVariableCharacteristicDefinitionByCombination;
    
    // Insert an existing FhirEvidenceVariableCharacteristicDefinitionByCombination before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceVariableCharacteristicDefinitionByCombination);
    
    // Get the iIndexth FhirEvidenceVariableCharacteristicDefinitionByCombination. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceVariableCharacteristicDefinitionByCombination);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceVariableCharacteristicDefinitionByCombination;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceVariableCharacteristicDefinitionByCombinations[index : Integer] : TFhirEvidenceVariableCharacteristicDefinitionByCombination read GetItemN write SetItemN; default;
  End;

  // Observation time from study specified event.
  TFhirEvidenceVariableCharacteristicTimeFromEvent = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FnoteList : TFhirAnnotationList;
    FEvent : TFhirDataType;
    FQuantity : TFhirQuantity;
    FRange : TFhirRange;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetEvent(value : TFhirDataType);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetRange(value : TFhirRange);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceVariableCharacteristicTimeFromEvent; overload;
    function Clone : TFhirEvidenceVariableCharacteristicTimeFromEvent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Human readable description.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Human readable description.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // A human-readable string to clarify or explain concepts about the timeFromEvent.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to The event used as a base point (reference point) in time. (defined for API consistency)
    property event : TFhirDataType read FEvent write SetEvent;
    // The event used as a base point (reference point) in time.
    property eventElement : TFhirDataType read FEvent write SetEvent;

    // Typed access to Used to express the observation at a defined amount of time after the study start. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // Used to express the observation at a defined amount of time after the study start.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to Used to express the observation within a period after the study start. (defined for API consistency)
    property range : TFhirRange read FRange write SetRange;
    // Used to express the observation within a period after the study start.
    property rangeElement : TFhirRange read FRange write SetRange;

  end;

  TFhirEvidenceVariableCharacteristicTimeFromEventListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceVariableCharacteristicTimeFromEventList;
    function GetCurrent : TFhirEvidenceVariableCharacteristicTimeFromEvent;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceVariableCharacteristicTimeFromEventList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceVariableCharacteristicTimeFromEvent read GetCurrent;
  end;

  TFhirEvidenceVariableCharacteristicTimeFromEventList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceVariableCharacteristicTimeFromEvent;
    procedure SetItemN(index : Integer; value : TFhirEvidenceVariableCharacteristicTimeFromEvent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceVariableCharacteristicTimeFromEventList; overload;
    function Clone : TFhirEvidenceVariableCharacteristicTimeFromEventList; overload;
    function GetEnumerator : TFhirEvidenceVariableCharacteristicTimeFromEventListEnumerator;
    
    //  Add a FhirEvidenceVariableCharacteristicTimeFromEvent to the end of the list.
    function Append : TFhirEvidenceVariableCharacteristicTimeFromEvent;
    
    // Add an already existing FhirEvidenceVariableCharacteristicTimeFromEvent to the end of the list.
    function AddItem(value : TFhirEvidenceVariableCharacteristicTimeFromEvent) : TFhirEvidenceVariableCharacteristicTimeFromEvent; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceVariableCharacteristicTimeFromEvent) : Integer;
    
    // Insert FhirEvidenceVariableCharacteristicTimeFromEvent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceVariableCharacteristicTimeFromEvent;
    
    // Insert an existing FhirEvidenceVariableCharacteristicTimeFromEvent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceVariableCharacteristicTimeFromEvent);
    
    // Get the iIndexth FhirEvidenceVariableCharacteristicTimeFromEvent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceVariableCharacteristicTimeFromEvent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceVariableCharacteristicTimeFromEvent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceVariableCharacteristicTimeFromEvents[index : Integer] : TFhirEvidenceVariableCharacteristicTimeFromEvent read GetItemN write SetItemN; default;
  End;

  // A grouping for ordinal or polychotomous variables.
  TFhirEvidenceVariableCategory = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FValue : TFhirDataType;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceVariableCategory; overload;
    function Clone : TFhirEvidenceVariableCategory; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Description of the grouping.
    property name : String read GetNameST write SetNameST;
    // Description of the grouping.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Definition of the grouping. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // Definition of the grouping.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirEvidenceVariableCategoryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceVariableCategoryList;
    function GetCurrent : TFhirEvidenceVariableCategory;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceVariableCategoryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceVariableCategory read GetCurrent;
  end;

  TFhirEvidenceVariableCategoryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceVariableCategory;
    procedure SetItemN(index : Integer; value : TFhirEvidenceVariableCategory);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceVariableCategoryList; overload;
    function Clone : TFhirEvidenceVariableCategoryList; overload;
    function GetEnumerator : TFhirEvidenceVariableCategoryListEnumerator;
    
    //  Add a FhirEvidenceVariableCategory to the end of the list.
    function Append : TFhirEvidenceVariableCategory;
    
    // Add an already existing FhirEvidenceVariableCategory to the end of the list.
    function AddItem(value : TFhirEvidenceVariableCategory) : TFhirEvidenceVariableCategory; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceVariableCategory) : Integer;
    
    // Insert FhirEvidenceVariableCategory before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceVariableCategory;
    
    // Insert an existing FhirEvidenceVariableCategory before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceVariableCategory);
    
    // Get the iIndexth FhirEvidenceVariableCategory. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceVariableCategory);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceVariableCategory;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceVariableCategories[index : Integer] : TFhirEvidenceVariableCategory read GetItemN write SetItemN; default;
  End;

  // The EvidenceVariable resource describes an element that knowledge (Evidence) is about.
  TFhirEvidenceVariable = class (TFhirMetadataResource)
  protected
    FShortTitle : TFhirString;
    FSubtitle : TFhirString;
    FnoteList : TFhirAnnotationList;
    FActual : TFhirBoolean;
    FcharacteristicList : TFhirEvidenceVariableCharacteristicList;
    FHandling : TFhirEnum;
    FcategoryList : TFhirEvidenceVariableCategoryList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetShortTitle(value : TFhirString);
    function GetShortTitleST : String;
    procedure SetShortTitleST(value : String);
    procedure SetSubtitle(value : TFhirString);
    function GetSubtitleST : String;
    procedure SetSubtitleST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    procedure SetApprovalDate(value : TFhirDate);
    function GetApprovalDateST : TFslDateTime;
    procedure SetApprovalDateST(value : TFslDateTime);
    procedure SetLastReviewDate(value : TFhirDate);
    function GetLastReviewDateST : TFslDateTime;
    procedure SetLastReviewDateST(value : TFslDateTime);
    procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetAuthorList : TFhirContactDetailList;
    function GetHasAuthorList : Boolean;
    function GetEditorList : TFhirContactDetailList;
    function GetHasEditorList : Boolean;
    function GetReviewerList : TFhirContactDetailList;
    function GetHasReviewerList : Boolean;
    function GetEndorserList : TFhirContactDetailList;
    function GetHasEndorserList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    procedure SetActual(value : TFhirBoolean);
    function GetActualST : Boolean;
    procedure SetActualST(value : Boolean);
    function GetCharacteristicList : TFhirEvidenceVariableCharacteristicList;
    function GetHasCharacteristicList : Boolean;
    procedure SetHandling(value : TFhirEnum);
    function GetHandlingST : TFhirEvidenceVariableHandlingEnum;
    procedure SetHandlingST(value : TFhirEvidenceVariableHandlingEnum);
    function GetCategoryList : TFhirEvidenceVariableCategoryList;
    function GetHasCategoryList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceVariable; overload;
    function Clone : TFhirEvidenceVariable; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this evidence variable when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which an authoritative instance of this evidence variable is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the evidence variable is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this evidence variable when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which an authoritative instance of this evidence variable is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the evidence variable is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this evidence variable when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the evidence variable when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the evidence variable author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the evidence variable when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the evidence variable author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the evidence variable. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the evidence variable. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the evidence variable.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the evidence variable.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to The short title provides an alternate title for use in informal descriptive contexts where the full, formal title is not necessary.
    property shortTitle : String read GetShortTitleST write SetShortTitleST;
    // The short title provides an alternate title for use in informal descriptive contexts where the full, formal title is not necessary.
    property shortTitleElement : TFhirString read FShortTitle write SetShortTitle;

    // Typed access to An explanatory or alternate title for the EvidenceVariable giving additional information about its content.
    property subtitle : String read GetSubtitleST write SetSubtitleST;
    // An explanatory or alternate title for the EvidenceVariable giving additional information about its content.
    property subtitleElement : TFhirString read FSubtitle write SetSubtitle;

    // The status of this evidence variable. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this resource is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this resource is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the evidence variable was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the evidence variable changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the evidence variable was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the evidence variable changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual responsible for the release and ongoing maintenance of the evidence variable.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual responsible for the release and ongoing maintenance of the evidence variable.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the evidence variable from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the evidence variable from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // A human-readable string to clarify or explain concepts about the resource.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate evidence variable instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // Typed access to A copyright statement relating to the resource and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the resource.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the resource and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the resource.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the resource content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the resource content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // An individiual or organization primarily involved in the creation and maintenance of the content.
    property authorList : TFhirContactDetailList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // An individual or organization primarily responsible for internal coherence of the content.
    property editorList : TFhirContactDetailList read GetEditorList;
    property hasEditorList : boolean read GetHasEditorList;

    // An individual or organization primarily responsible for review of some aspect of the content.
    property reviewerList : TFhirContactDetailList read GetReviewerList;
    property hasReviewerList : boolean read GetHasReviewerList;

    // An individual or organization responsible for officially endorsing the content for use in some setting.
    property endorserList : TFhirContactDetailList read GetEndorserList;
    property hasEndorserList : boolean read GetHasEndorserList;

    // Related artifacts such as additional documentation, justification, or bibliographic references.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // Typed access to True if the actual variable measured, false if a conceptual representation of the intended variable.
    property actual : Boolean read GetActualST write SetActualST;
    // True if the actual variable measured, false if a conceptual representation of the intended variable.
    property actualElement : TFhirBoolean read FActual write SetActual;

    // A defining factor of the EvidenceVariable. Multiple characteristics are applied with "and" semantics.
    property characteristicList : TFhirEvidenceVariableCharacteristicList read GetCharacteristicList;
    property hasCharacteristicList : boolean read GetHasCharacteristicList;

    // The method of handling in statistical analysis.
    property handling : TFhirEvidenceVariableHandlingEnum read GetHandlingST write SetHandlingST;
    property handlingElement : TFhirEnum read FHandling write SetHandling;

    // A grouping for ordinal or polychotomous variables.
    property categoryList : TFhirEvidenceVariableCategoryList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

  end;

  TFhirEvidenceVariableListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceVariableList;
    function GetCurrent : TFhirEvidenceVariable;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceVariableList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceVariable read GetCurrent;
  end;

  TFhirEvidenceVariableList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceVariable;
    procedure SetItemN(index : Integer; value : TFhirEvidenceVariable);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceVariableList; overload;
    function Clone : TFhirEvidenceVariableList; overload;
    function GetEnumerator : TFhirEvidenceVariableListEnumerator;
    
    //  Add a FhirEvidenceVariable to the end of the list.
    function Append : TFhirEvidenceVariable;
    
    // Add an already existing FhirEvidenceVariable to the end of the list.
    function AddItem(value : TFhirEvidenceVariable) : TFhirEvidenceVariable; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceVariable) : Integer;
    
    // Insert FhirEvidenceVariable before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceVariable;
    
    // Insert an existing FhirEvidenceVariable before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceVariable);
    
    // Get the iIndexth FhirEvidenceVariable. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceVariable);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceVariable;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceVariables[index : Integer] : TFhirEvidenceVariable read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_GUIDANCERESPONSE}
  // A guidance response is the formal response to a guidance request, including any output parameters returned by the evaluation, as well as the description of any proposed actions to be taken.
  TFhirGuidanceResponse = class (TFhirDomainResource)
  protected
    FRequestIdentifier : TFhirIdentifier;
    FidentifierList : TFhirIdentifierList;
    FModule : TFhirDataType;
    FStatus : TFhirEnum;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FOccurrenceDateTime : TFhirDateTime;
    FPerformer : TFhirReference;
    FreasonList : TFhirCodeableReferenceList;
    FnoteList : TFhirAnnotationList;
    FevaluationMessageList : TFhirReferenceList;
    FOutputParameters : TFhirReference;
    FResult : TFhirReference;
    FdataRequirementList : TFhirDataRequirementList;
    procedure SetRequestIdentifier(value : TFhirIdentifier);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetModule(value : TFhirDataType);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirGuidanceResponseStatusEnum;
    procedure SetStatusST(value : TFhirGuidanceResponseStatusEnum);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetOccurrenceDateTime(value : TFhirDateTime);
    function GetOccurrenceDateTimeST : TFslDateTime;
    procedure SetOccurrenceDateTimeST(value : TFslDateTime);
    procedure SetPerformer(value : TFhirReference);
    function GetReasonList : TFhirCodeableReferenceList;
    function GetHasReasonList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetEvaluationMessageList : TFhirReferenceList;
    function GetHasEvaluationMessageList : Boolean;
    procedure SetOutputParameters(value : TFhirReference);
    procedure SetResult(value : TFhirReference);
    function GetDataRequirementList : TFhirDataRequirementList;
    function GetHasDataRequirementList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGuidanceResponse; overload;
    function Clone : TFhirGuidanceResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The identifier of the request associated with this response. If an identifier was given as part of the request, it will be reproduced here to enable the requester to more easily identify the response in a multi-request scenario. (defined for API consistency)
    property requestIdentifier : TFhirIdentifier read FRequestIdentifier write SetRequestIdentifier;
    // The identifier of the request associated with this response. If an identifier was given as part of the request, it will be reproduced here to enable the requester to more easily identify the response in a multi-request scenario.
    property requestIdentifierElement : TFhirIdentifier read FRequestIdentifier write SetRequestIdentifier;

    // Allows a service to provide  unique, business identifiers for the response.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to An identifier, CodeableConcept or canonical reference to the guidance that was requested. (defined for API consistency)
    property module : TFhirDataType read FModule write SetModule;
    // An identifier, CodeableConcept or canonical reference to the guidance that was requested.
    property moduleElement : TFhirDataType read FModule write SetModule;

    // The status of the response. If the evaluation is completed successfully, the status will indicate success. However, in order to complete the evaluation, the engine may require more information. In this case, the status will be data-required, and the response will contain a description of the additional required information. If the evaluation completed successfully, but the engine determines that a potentially more accurate response could be provided if more data was available, the status will be data-requested, and the response will contain a description of the additional requested information.
    property status : TFhirGuidanceResponseStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The patient for which the request was processed. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The patient for which the request was processed.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The encounter during which this response was created or to which the creation of this record is tightly associated. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The encounter during which this response was created or to which the creation of this record is tightly associated.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to Indicates when the guidance response was processed.
    property occurrenceDateTime : TFslDateTime read GetOccurrenceDateTimeST write SetOccurrenceDateTimeST;
    // Indicates when the guidance response was processed.
    property occurrenceDateTimeElement : TFhirDateTime read FOccurrenceDateTime write SetOccurrenceDateTime;

    // Typed access to Provides a reference to the device that performed the guidance. (defined for API consistency)
    property performer : TFhirReference read FPerformer write SetPerformer;
    // Provides a reference to the device that performed the guidance.
    property performerElement : TFhirReference read FPerformer write SetPerformer;

    // Describes the reason for the guidance response in coded or textual form, or Indicates the reason the request was initiated. This is typically provided as a parameter to the evaluation and echoed by the service, although for some use cases, such as subscription- or event-based scenarios, it may provide an indication of the cause for the response.
    property reasonList : TFhirCodeableReferenceList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Provides a mechanism to communicate additional information about the response.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Messages resulting from the evaluation of the artifact or artifacts. As part of evaluating the request, the engine may produce informational or warning messages. These messages will be provided by this element.
    property evaluationMessageList : TFhirReferenceList read GetEvaluationMessageList;
    property hasEvaluationMessageList : boolean read GetHasEvaluationMessageList;

    // Typed access to The output parameters of the evaluation, if any. Many modules will result in the return of specific resources such as procedure or communication requests that are returned as part of the operation result. However, modules may define specific outputs that would be returned as the result of the evaluation, and these would be returned in this element. (defined for API consistency)
    property outputParameters : TFhirReference read FOutputParameters write SetOutputParameters;
    // The output parameters of the evaluation, if any. Many modules will result in the return of specific resources such as procedure or communication requests that are returned as part of the operation result. However, modules may define specific outputs that would be returned as the result of the evaluation, and these would be returned in this element.
    property outputParametersElement : TFhirReference read FOutputParameters write SetOutputParameters;

    // Typed access to The actions, if any, produced by the evaluation of the artifact. (defined for API consistency)
    property result : TFhirReference read FResult write SetResult;
    // The actions, if any, produced by the evaluation of the artifact.
    property resultElement : TFhirReference read FResult write SetResult;

    // If the evaluation could not be completed due to lack of information, or additional information would potentially result in a more accurate response, this element will a description of the data required in order to proceed with the evaluation. A subsequent request to the service should include this data.
    property dataRequirementList : TFhirDataRequirementList read GetDataRequirementList;
    property hasDataRequirementList : boolean read GetHasDataRequirementList;

  end;

  TFhirGuidanceResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGuidanceResponseList;
    function GetCurrent : TFhirGuidanceResponse;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirGuidanceResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGuidanceResponse read GetCurrent;
  end;

  TFhirGuidanceResponseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirGuidanceResponse;
    procedure SetItemN(index : Integer; value : TFhirGuidanceResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirGuidanceResponseList; overload;
    function Clone : TFhirGuidanceResponseList; overload;
    function GetEnumerator : TFhirGuidanceResponseListEnumerator;
    
    //  Add a FhirGuidanceResponse to the end of the list.
    function Append : TFhirGuidanceResponse;
    
    // Add an already existing FhirGuidanceResponse to the end of the list.
    function AddItem(value : TFhirGuidanceResponse) : TFhirGuidanceResponse; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGuidanceResponse) : Integer;
    
    // Insert FhirGuidanceResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGuidanceResponse;
    
    // Insert an existing FhirGuidanceResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGuidanceResponse);
    
    // Get the iIndexth FhirGuidanceResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGuidanceResponse);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirGuidanceResponse;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirGuidanceResponses[index : Integer] : TFhirGuidanceResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_INVENTORYREPORT}
  // An inventory listing section (grouped by any of the attributes).
  TFhirInventoryReportInventoryListing = class (TFhirBackboneElement)
  protected
    FLocation : TFhirReference;
    FItemStatus : TFhirCodeableConcept;
    FCountingDateTime : TFhirDateTime;
    FitemsList : TFhirInventoryReportInventoryListingItemsList;
    procedure SetLocation(value : TFhirReference);
    procedure SetItemStatus(value : TFhirCodeableConcept);
    procedure SetCountingDateTime(value : TFhirDateTime);
    function GetCountingDateTimeST : TFslDateTime;
    procedure SetCountingDateTimeST(value : TFslDateTime);
    function GetItemsList : TFhirInventoryReportInventoryListingItemsList;
    function GetHasItemsList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInventoryReportInventoryListing; overload;
    function Clone : TFhirInventoryReportInventoryListing; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Location of the inventory items. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // Location of the inventory items.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // Typed access to The status of the items. (defined for API consistency)
    property itemStatus : TFhirCodeableConcept read FItemStatus write SetItemStatus;
    // The status of the items.
    property itemStatusElement : TFhirCodeableConcept read FItemStatus write SetItemStatus;

    // Typed access to The date and time when the items were counted.
    property countingDateTime : TFslDateTime read GetCountingDateTimeST write SetCountingDateTimeST;
    // The date and time when the items were counted.
    property countingDateTimeElement : TFhirDateTime read FCountingDateTime write SetCountingDateTime;

    // The item or items in this listing.
    property itemsList : TFhirInventoryReportInventoryListingItemsList read GetItemsList;
    property hasItemsList : boolean read GetHasItemsList;

  end;

  TFhirInventoryReportInventoryListingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInventoryReportInventoryListingList;
    function GetCurrent : TFhirInventoryReportInventoryListing;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirInventoryReportInventoryListingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInventoryReportInventoryListing read GetCurrent;
  end;

  TFhirInventoryReportInventoryListingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInventoryReportInventoryListing;
    procedure SetItemN(index : Integer; value : TFhirInventoryReportInventoryListing);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInventoryReportInventoryListingList; overload;
    function Clone : TFhirInventoryReportInventoryListingList; overload;
    function GetEnumerator : TFhirInventoryReportInventoryListingListEnumerator;
    
    //  Add a FhirInventoryReportInventoryListing to the end of the list.
    function Append : TFhirInventoryReportInventoryListing;
    
    // Add an already existing FhirInventoryReportInventoryListing to the end of the list.
    function AddItem(value : TFhirInventoryReportInventoryListing) : TFhirInventoryReportInventoryListing; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInventoryReportInventoryListing) : Integer;
    
    // Insert FhirInventoryReportInventoryListing before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInventoryReportInventoryListing;
    
    // Insert an existing FhirInventoryReportInventoryListing before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInventoryReportInventoryListing);
    
    // Get the iIndexth FhirInventoryReportInventoryListing. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInventoryReportInventoryListing);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInventoryReportInventoryListing;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInventoryReportInventoryListings[index : Integer] : TFhirInventoryReportInventoryListing read GetItemN write SetItemN; default;
  End;

  // The item or items in this listing.
  TFhirInventoryReportInventoryListingItems = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FItem : TFhirCodeableReference;
    FLot : TFhirString;
    FSerial : TFhirString;
    FExpiry : TFhirDateTime;
    FManufacturingDate : TFhirDateTime;
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetItem(value : TFhirCodeableReference);
    procedure SetLot(value : TFhirString);
    function GetLotST : String;
    procedure SetLotST(value : String);
    procedure SetSerial(value : TFhirString);
    function GetSerialST : String;
    procedure SetSerialST(value : String);
    procedure SetExpiry(value : TFhirDateTime);
    function GetExpiryST : TFslDateTime;
    procedure SetExpiryST(value : TFslDateTime);
    procedure SetManufacturingDate(value : TFhirDateTime);
    function GetManufacturingDateST : TFslDateTime;
    procedure SetManufacturingDateST(value : TFslDateTime);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInventoryReportInventoryListingItems; overload;
    function Clone : TFhirInventoryReportInventoryListingItems; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The category of the item or items. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // The category of the item or items.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to The quantity of the item or items. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The quantity of the item or items.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The code or reference to the item type. (defined for API consistency)
    property item : TFhirCodeableReference read FItem write SetItem;
    // The code or reference to the item type.
    property itemElement : TFhirCodeableReference read FItem write SetItem;

    // Typed access to The lot number of the item or items.
    property lot : String read GetLotST write SetLotST;
    // The lot number of the item or items.
    property lotElement : TFhirString read FLot write SetLot;

    // Typed access to The serial number of the item.
    property serial : String read GetSerialST write SetSerialST;
    // The serial number of the item.
    property serialElement : TFhirString read FSerial write SetSerial;

    // Typed access to The expiry date of the item or items.
    property expiry : TFslDateTime read GetExpiryST write SetExpiryST;
    // The expiry date of the item or items.
    property expiryElement : TFhirDateTime read FExpiry write SetExpiry;

    // Typed access to The manufacturingDate of the item or items.
    property manufacturingDate : TFslDateTime read GetManufacturingDateST write SetManufacturingDateST;
    // The manufacturingDate of the item or items.
    property manufacturingDateElement : TFhirDateTime read FManufacturingDate write SetManufacturingDate;

  end;

  TFhirInventoryReportInventoryListingItemsListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInventoryReportInventoryListingItemsList;
    function GetCurrent : TFhirInventoryReportInventoryListingItems;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirInventoryReportInventoryListingItemsList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInventoryReportInventoryListingItems read GetCurrent;
  end;

  TFhirInventoryReportInventoryListingItemsList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInventoryReportInventoryListingItems;
    procedure SetItemN(index : Integer; value : TFhirInventoryReportInventoryListingItems);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInventoryReportInventoryListingItemsList; overload;
    function Clone : TFhirInventoryReportInventoryListingItemsList; overload;
    function GetEnumerator : TFhirInventoryReportInventoryListingItemsListEnumerator;
    
    //  Add a FhirInventoryReportInventoryListingItems to the end of the list.
    function Append : TFhirInventoryReportInventoryListingItems;
    
    // Add an already existing FhirInventoryReportInventoryListingItems to the end of the list.
    function AddItem(value : TFhirInventoryReportInventoryListingItems) : TFhirInventoryReportInventoryListingItems; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInventoryReportInventoryListingItems) : Integer;
    
    // Insert FhirInventoryReportInventoryListingItems before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInventoryReportInventoryListingItems;
    
    // Insert an existing FhirInventoryReportInventoryListingItems before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInventoryReportInventoryListingItems);
    
    // Get the iIndexth FhirInventoryReportInventoryListingItems. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInventoryReportInventoryListingItems);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInventoryReportInventoryListingItems;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInventoryReportInventoryListingItems[index : Integer] : TFhirInventoryReportInventoryListingItems read GetItemN write SetItemN; default;
  End;

  // A report of inventory or stock items.
  TFhirInventoryReport = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FCountType : TFhirEnum;
    FOperationType : TFhirCodeableConcept;
    FOperationTypeReason : TFhirCodeableConcept;
    FReportedDateTime : TFhirDateTime;
    FReporter : TFhirReference;
    FReportingPeriod : TFhirPeriod;
    FinventoryListingList : TFhirInventoryReportInventoryListingList;
    FNote : TFhirAnnotation;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirInventoryReportStatusEnum;
    procedure SetStatusST(value : TFhirInventoryReportStatusEnum);
    procedure SetCountType(value : TFhirEnum);
    function GetCountTypeST : TFhirInventoryCountTypeEnum;
    procedure SetCountTypeST(value : TFhirInventoryCountTypeEnum);
    procedure SetOperationType(value : TFhirCodeableConcept);
    procedure SetOperationTypeReason(value : TFhirCodeableConcept);
    procedure SetReportedDateTime(value : TFhirDateTime);
    function GetReportedDateTimeST : TFslDateTime;
    procedure SetReportedDateTimeST(value : TFslDateTime);
    procedure SetReporter(value : TFhirReference);
    procedure SetReportingPeriod(value : TFhirPeriod);
    function GetInventoryListingList : TFhirInventoryReportInventoryListingList;
    function GetHasInventoryListingList : Boolean;
    procedure SetNote(value : TFhirAnnotation);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInventoryReport; overload;
    function Clone : TFhirInventoryReport; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers for the InventoryReport.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the inventory check or notification - whether this is draft (e.g. the report is still pending some updates) or active.
    property status : TFhirInventoryReportStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Whether the report is about the current inventory count (snapshot) or a differential change in inventory (change).
    property countType : TFhirInventoryCountTypeEnum read GetCountTypeST write SetCountTypeST;
    property countTypeElement : TFhirEnum read FCountType write SetCountType;

    // Typed access to What type of operation is being performed - addition or subtraction. (defined for API consistency)
    property operationType : TFhirCodeableConcept read FOperationType write SetOperationType;
    // What type of operation is being performed - addition or subtraction.
    property operationTypeElement : TFhirCodeableConcept read FOperationType write SetOperationType;

    // Typed access to The reason for this count - regular count, ad-hoc count, new arrivals, etc. (defined for API consistency)
    property operationTypeReason : TFhirCodeableConcept read FOperationTypeReason write SetOperationTypeReason;
    // The reason for this count - regular count, ad-hoc count, new arrivals, etc.
    property operationTypeReasonElement : TFhirCodeableConcept read FOperationTypeReason write SetOperationTypeReason;

    // Typed access to When the report has been submitted.
    property reportedDateTime : TFslDateTime read GetReportedDateTimeST write SetReportedDateTimeST;
    // When the report has been submitted.
    property reportedDateTimeElement : TFhirDateTime read FReportedDateTime write SetReportedDateTime;

    // Typed access to Who submits the report. (defined for API consistency)
    property reporter : TFhirReference read FReporter write SetReporter;
    // Who submits the report.
    property reporterElement : TFhirReference read FReporter write SetReporter;

    // Typed access to The period the report refers to. (defined for API consistency)
    property reportingPeriod : TFhirPeriod read FReportingPeriod write SetReportingPeriod;
    // The period the report refers to.
    property reportingPeriodElement : TFhirPeriod read FReportingPeriod write SetReportingPeriod;

    // An inventory listing section (grouped by any of the attributes).
    property inventoryListingList : TFhirInventoryReportInventoryListingList read GetInventoryListingList;
    property hasInventoryListingList : boolean read GetHasInventoryListingList;

    // Typed access to A note associated with the InventoryReport. (defined for API consistency)
    property note : TFhirAnnotation read FNote write SetNote;
    // A note associated with the InventoryReport.
    property noteElement : TFhirAnnotation read FNote write SetNote;

  end;

  TFhirInventoryReportListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInventoryReportList;
    function GetCurrent : TFhirInventoryReport;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirInventoryReportList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInventoryReport read GetCurrent;
  end;

  TFhirInventoryReportList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInventoryReport;
    procedure SetItemN(index : Integer; value : TFhirInventoryReport);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInventoryReportList; overload;
    function Clone : TFhirInventoryReportList; overload;
    function GetEnumerator : TFhirInventoryReportListEnumerator;
    
    //  Add a FhirInventoryReport to the end of the list.
    function Append : TFhirInventoryReport;
    
    // Add an already existing FhirInventoryReport to the end of the list.
    function AddItem(value : TFhirInventoryReport) : TFhirInventoryReport; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInventoryReport) : Integer;
    
    // Insert FhirInventoryReport before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInventoryReport;
    
    // Insert an existing FhirInventoryReport before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInventoryReport);
    
    // Get the iIndexth FhirInventoryReport. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInventoryReport);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInventoryReport;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInventoryReports[index : Integer] : TFhirInventoryReport read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_INVENTORYREPORT}
{$IFDEF FHIR_LINKAGE}
  // Identifies which record considered as the reference to the same real-world occurrence as well as how the items should be evaluated within the collection of linked items.
  TFhirLinkageItem = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FResource : TFhirReference;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirLinkageTypeEnum;
    procedure SetType_ST(value : TFhirLinkageTypeEnum);
    procedure SetResource(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirLinkageItem; overload;
    function Clone : TFhirLinkageItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Distinguishes which item is "source of truth" (if any) and which items are no longer considered to be current representations.
    property type_ : TFhirLinkageTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The resource instance being linked as part of the group. (defined for API consistency)
    property resource : TFhirReference read FResource write SetResource;
    // The resource instance being linked as part of the group.
    property resourceElement : TFhirReference read FResource write SetResource;

  end;

  TFhirLinkageItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirLinkageItemList;
    function GetCurrent : TFhirLinkageItem;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirLinkageItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirLinkageItem read GetCurrent;
  end;

  TFhirLinkageItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirLinkageItem;
    procedure SetItemN(index : Integer; value : TFhirLinkageItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirLinkageItemList; overload;
    function Clone : TFhirLinkageItemList; overload;
    function GetEnumerator : TFhirLinkageItemListEnumerator;
    
    //  Add a FhirLinkageItem to the end of the list.
    function Append : TFhirLinkageItem;
    
    // Add an already existing FhirLinkageItem to the end of the list.
    function AddItem(value : TFhirLinkageItem) : TFhirLinkageItem; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirLinkageItem) : Integer;
    
    // Insert FhirLinkageItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirLinkageItem;
    
    // Insert an existing FhirLinkageItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirLinkageItem);
    
    // Get the iIndexth FhirLinkageItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirLinkageItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirLinkageItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirLinkageItems[index : Integer] : TFhirLinkageItem read GetItemN write SetItemN; default;
  End;

  // Identifies two or more records (resource instances) that refer to the same real-world "occurrence".
  TFhirLinkage = class (TFhirDomainResource)
  protected
    FActive : TFhirBoolean;
    FAuthor : TFhirReference;
    FitemList : TFhirLinkageItemList;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    procedure SetAuthor(value : TFhirReference);
    function GetItemList : TFhirLinkageItemList;
    function GetHasItemList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirLinkage; overload;
    function Clone : TFhirLinkage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates whether the asserted set of linkages are considered to be "in effect".
    property active : Boolean read GetActiveST write SetActiveST;
    // Indicates whether the asserted set of linkages are considered to be "in effect".
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Typed access to Identifies the user or organization responsible for asserting the linkages as well as the user or organization who establishes the context in which the nature of each linkage is evaluated. (defined for API consistency)
    property author : TFhirReference read FAuthor write SetAuthor;
    // Identifies the user or organization responsible for asserting the linkages as well as the user or organization who establishes the context in which the nature of each linkage is evaluated.
    property authorElement : TFhirReference read FAuthor write SetAuthor;

    // Identifies which record considered as the reference to the same real-world occurrence as well as how the items should be evaluated within the collection of linked items.
    property itemList : TFhirLinkageItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirLinkageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirLinkageList;
    function GetCurrent : TFhirLinkage;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirLinkageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirLinkage read GetCurrent;
  end;

  TFhirLinkageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirLinkage;
    procedure SetItemN(index : Integer; value : TFhirLinkage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirLinkageList; overload;
    function Clone : TFhirLinkageList; overload;
    function GetEnumerator : TFhirLinkageListEnumerator;
    
    //  Add a FhirLinkage to the end of the list.
    function Append : TFhirLinkage;
    
    // Add an already existing FhirLinkage to the end of the list.
    function AddItem(value : TFhirLinkage) : TFhirLinkage; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirLinkage) : Integer;
    
    // Insert FhirLinkage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirLinkage;
    
    // Insert an existing FhirLinkage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirLinkage);
    
    // Get the iIndexth FhirLinkage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirLinkage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirLinkage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirLinkages[index : Integer] : TFhirLinkage read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
  // Entries in this list.
  TFhirListEntry = class (TFhirBackboneElement)
  protected
    FFlag : TFhirCodeableConcept;
    FDeleted : TFhirBoolean;
    FDate : TFhirDateTime;
    FItem : TFhirReference;
    procedure SetFlag(value : TFhirCodeableConcept);
    procedure SetDeleted(value : TFhirBoolean);
    function GetDeletedST : Boolean;
    procedure SetDeletedST(value : Boolean);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetItem(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirListEntry; overload;
    function Clone : TFhirListEntry; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The flag allows the system constructing the list to indicate the role and significance of the item in the list. (defined for API consistency)
    property flag : TFhirCodeableConcept read FFlag write SetFlag;
    // The flag allows the system constructing the list to indicate the role and significance of the item in the list.
    property flagElement : TFhirCodeableConcept read FFlag write SetFlag;

    // Typed access to True if this item is marked as deleted in the list.
    property deleted : Boolean read GetDeletedST write SetDeletedST;
    // True if this item is marked as deleted in the list.
    property deletedElement : TFhirBoolean read FDeleted write SetDeleted;

    // Typed access to When this item was added to the list.
    property date : TFslDateTime read GetDateST write SetDateST;
    // When this item was added to the list.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to A reference to the actual resource from which data was derived. (defined for API consistency)
    property item : TFhirReference read FItem write SetItem;
    // A reference to the actual resource from which data was derived.
    property itemElement : TFhirReference read FItem write SetItem;

  end;

  TFhirListEntryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirListEntryList;
    function GetCurrent : TFhirListEntry;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirListEntryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirListEntry read GetCurrent;
  end;

  TFhirListEntryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirListEntry;
    procedure SetItemN(index : Integer; value : TFhirListEntry);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirListEntryList; overload;
    function Clone : TFhirListEntryList; overload;
    function GetEnumerator : TFhirListEntryListEnumerator;
    
    //  Add a FhirListEntry to the end of the list.
    function Append : TFhirListEntry;
    
    // Add an already existing FhirListEntry to the end of the list.
    function AddItem(value : TFhirListEntry) : TFhirListEntry; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirListEntry) : Integer;
    
    // Insert FhirListEntry before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirListEntry;
    
    // Insert an existing FhirListEntry before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirListEntry);
    
    // Get the iIndexth FhirListEntry. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirListEntry);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirListEntry;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirListEntries[index : Integer] : TFhirListEntry read GetItemN write SetItemN; default;
  End;

  // A List is a curated collection of resources, for things such as problem lists, allergy lists, facility list, organization list, etc.
  TFhirList = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FMode : TFhirEnum;
    FTitle : TFhirString;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FDate : TFhirDateTime;
    FSource : TFhirReference;
    FOrderedBy : TFhirCodeableConcept;
    FnoteList : TFhirAnnotationList;
    FentryList : TFhirListEntryList;
    FEmptyReason : TFhirCodeableConcept;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirListStatusEnum;
    procedure SetStatusST(value : TFhirListStatusEnum);
    procedure SetMode(value : TFhirEnum);
    function GetModeST : TFhirListModeEnum;
    procedure SetModeST(value : TFhirListModeEnum);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetSource(value : TFhirReference);
    procedure SetOrderedBy(value : TFhirCodeableConcept);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetEntryList : TFhirListEntryList;
    function GetHasEntryList : Boolean;
    procedure SetEmptyReason(value : TFhirCodeableConcept);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirList; overload;
    function Clone : TFhirList; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier for the List assigned for business purposes outside the context of FHIR.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Indicates the current state of this list.
    property status : TFhirListStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // How this list was prepared - whether it is a working list that is suitable for being maintained on an ongoing basis, or if it represents a snapshot of a list of items from another source, or whether it is a prepared list where items may be marked as added, modified or deleted.
    property mode : TFhirListModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to A label for the list assigned by the author.
    property title : String read GetTitleST write SetTitleST;
    // A label for the list assigned by the author.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to This code defines the purpose of the list - why it was created. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // This code defines the purpose of the list - why it was created.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The common subject (or patient) of the resources that are in the list if there is one. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The common subject (or patient) of the resources that are in the list if there is one.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The encounter that is the context in which this list was created. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The encounter that is the context in which this list was created.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to Date list was last reviewed/revised and determined to be 'current'.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date list was last reviewed/revised and determined to be 'current'.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The entity responsible for deciding what the contents of the list were. Where the list was created by a human, this is the same as the author of the list. (defined for API consistency)
    property source : TFhirReference read FSource write SetSource;
    // The entity responsible for deciding what the contents of the list were. Where the list was created by a human, this is the same as the author of the list.
    property sourceElement : TFhirReference read FSource write SetSource;

    // Typed access to What order applies to the items in the list. (defined for API consistency)
    property orderedBy : TFhirCodeableConcept read FOrderedBy write SetOrderedBy;
    // What order applies to the items in the list.
    property orderedByElement : TFhirCodeableConcept read FOrderedBy write SetOrderedBy;

    // Comments that apply to the overall list.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Entries in this list.
    property entryList : TFhirListEntryList read GetEntryList;
    property hasEntryList : boolean read GetHasEntryList;

    // Typed access to If the list is empty, why the list is empty. (defined for API consistency)
    property emptyReason : TFhirCodeableConcept read FEmptyReason write SetEmptyReason;
    // If the list is empty, why the list is empty.
    property emptyReasonElement : TFhirCodeableConcept read FEmptyReason write SetEmptyReason;

  end;

  TFhirListListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirListList;
    function GetCurrent : TFhirList;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirListList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirList read GetCurrent;
  end;

  TFhirListList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirList;
    procedure SetItemN(index : Integer; value : TFhirList);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirListList; overload;
    function Clone : TFhirListList; overload;
    function GetEnumerator : TFhirListListEnumerator;
    
    //  Add a FhirList to the end of the list.
    function Append : TFhirList;
    
    // Add an already existing FhirList to the end of the list.
    function AddItem(value : TFhirList) : TFhirList; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirList) : Integer;
    
    // Insert FhirList before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirList;
    
    // Insert an existing FhirList before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirList);
    
    // Get the iIndexth FhirList. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirList);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirList;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirLists[index : Integer] : TFhirList read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_LIST}
{$IFDEF FHIR_MEASUREREPORT}
  // The results of the calculation, one for each population group in the measure.
  TFhirMeasureReportGroup = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FpopulationList : TFhirMeasureReportGroupPopulationList;
    FMeasureScore : TFhirDataType;
    FstratifierList : TFhirMeasureReportGroupStratifierList;
    procedure SetCode(value : TFhirCodeableConcept);
    function GetPopulationList : TFhirMeasureReportGroupPopulationList;
    function GetHasPopulationList : Boolean;
    procedure SetMeasureScore(value : TFhirDataType);
    function GetStratifierList : TFhirMeasureReportGroupStratifierList;
    function GetHasStratifierList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReportGroup; overload;
    function Clone : TFhirMeasureReportGroup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The meaning of the population group as defined in the measure definition. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The meaning of the population group as defined in the measure definition.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // The populations that make up the population group, one for each type of population appropriate for the measure.
    property populationList : TFhirMeasureReportGroupPopulationList read GetPopulationList;
    property hasPopulationList : boolean read GetHasPopulationList;

    // Typed access to The measure score for this population group, calculated as appropriate for the measure type and scoring method, and based on the contents of the populations defined in the group. (defined for API consistency)
    property measureScore : TFhirDataType read FMeasureScore write SetMeasureScore;
    // The measure score for this population group, calculated as appropriate for the measure type and scoring method, and based on the contents of the populations defined in the group.
    property measureScoreElement : TFhirDataType read FMeasureScore write SetMeasureScore;

    // When a measure includes multiple stratifiers, there will be a stratifier group for each stratifier defined by the measure.
    property stratifierList : TFhirMeasureReportGroupStratifierList read GetStratifierList;
    property hasStratifierList : boolean read GetHasStratifierList;

  end;

  TFhirMeasureReportGroupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportGroupList;
    function GetCurrent : TFhirMeasureReportGroup;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportGroupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReportGroup read GetCurrent;
  end;

  TFhirMeasureReportGroupList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMeasureReportGroup;
    procedure SetItemN(index : Integer; value : TFhirMeasureReportGroup);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMeasureReportGroupList; overload;
    function Clone : TFhirMeasureReportGroupList; overload;
    function GetEnumerator : TFhirMeasureReportGroupListEnumerator;
    
    //  Add a FhirMeasureReportGroup to the end of the list.
    function Append : TFhirMeasureReportGroup;
    
    // Add an already existing FhirMeasureReportGroup to the end of the list.
    function AddItem(value : TFhirMeasureReportGroup) : TFhirMeasureReportGroup; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReportGroup) : Integer;
    
    // Insert FhirMeasureReportGroup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReportGroup;
    
    // Insert an existing FhirMeasureReportGroup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReportGroup);
    
    // Get the iIndexth FhirMeasureReportGroup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReportGroup);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReportGroup;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMeasureReportGroups[index : Integer] : TFhirMeasureReportGroup read GetItemN write SetItemN; default;
  End;

  // The populations that make up the population group, one for each type of population appropriate for the measure.
  TFhirMeasureReportGroupPopulation = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FCount : TFhirInteger;
    FSubjectResults : TFhirReference;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetCount(value : TFhirInteger);
    function GetCountST : String;
    procedure SetCountST(value : String);
    procedure SetSubjectResults(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReportGroupPopulation; overload;
    function Clone : TFhirMeasureReportGroupPopulation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of the population. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The type of the population.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The number of members of the population.
    property count : String read GetCountST write SetCountST;
    // The number of members of the population.
    property countElement : TFhirInteger read FCount write SetCount;

    // Typed access to This element refers to a List of subject level MeasureReport resources, one for each subject in this population. (defined for API consistency)
    property subjectResults : TFhirReference read FSubjectResults write SetSubjectResults;
    // This element refers to a List of subject level MeasureReport resources, one for each subject in this population.
    property subjectResultsElement : TFhirReference read FSubjectResults write SetSubjectResults;

  end;

  TFhirMeasureReportGroupPopulationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportGroupPopulationList;
    function GetCurrent : TFhirMeasureReportGroupPopulation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportGroupPopulationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReportGroupPopulation read GetCurrent;
  end;

  TFhirMeasureReportGroupPopulationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMeasureReportGroupPopulation;
    procedure SetItemN(index : Integer; value : TFhirMeasureReportGroupPopulation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMeasureReportGroupPopulationList; overload;
    function Clone : TFhirMeasureReportGroupPopulationList; overload;
    function GetEnumerator : TFhirMeasureReportGroupPopulationListEnumerator;
    
    //  Add a FhirMeasureReportGroupPopulation to the end of the list.
    function Append : TFhirMeasureReportGroupPopulation;
    
    // Add an already existing FhirMeasureReportGroupPopulation to the end of the list.
    function AddItem(value : TFhirMeasureReportGroupPopulation) : TFhirMeasureReportGroupPopulation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReportGroupPopulation) : Integer;
    
    // Insert FhirMeasureReportGroupPopulation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReportGroupPopulation;
    
    // Insert an existing FhirMeasureReportGroupPopulation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReportGroupPopulation);
    
    // Get the iIndexth FhirMeasureReportGroupPopulation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReportGroupPopulation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReportGroupPopulation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMeasureReportGroupPopulations[index : Integer] : TFhirMeasureReportGroupPopulation read GetItemN write SetItemN; default;
  End;

  // When a measure includes multiple stratifiers, there will be a stratifier group for each stratifier defined by the measure.
  TFhirMeasureReportGroupStratifier = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FstratumList : TFhirMeasureReportGroupStratifierStratumList;
    procedure SetCode(value : TFhirCodeableConcept);
    function GetStratumList : TFhirMeasureReportGroupStratifierStratumList;
    function GetHasStratumList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReportGroupStratifier; overload;
    function Clone : TFhirMeasureReportGroupStratifier; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The meaning of this stratifier, as defined in the measure definition. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The meaning of this stratifier, as defined in the measure definition.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // This element contains the results for a single stratum within the stratifier. For example, when stratifying on administrative gender, there will be four strata, one for each possible gender value.
    property stratumList : TFhirMeasureReportGroupStratifierStratumList read GetStratumList;
    property hasStratumList : boolean read GetHasStratumList;

  end;

  TFhirMeasureReportGroupStratifierListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportGroupStratifierList;
    function GetCurrent : TFhirMeasureReportGroupStratifier;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportGroupStratifierList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReportGroupStratifier read GetCurrent;
  end;

  TFhirMeasureReportGroupStratifierList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMeasureReportGroupStratifier;
    procedure SetItemN(index : Integer; value : TFhirMeasureReportGroupStratifier);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMeasureReportGroupStratifierList; overload;
    function Clone : TFhirMeasureReportGroupStratifierList; overload;
    function GetEnumerator : TFhirMeasureReportGroupStratifierListEnumerator;
    
    //  Add a FhirMeasureReportGroupStratifier to the end of the list.
    function Append : TFhirMeasureReportGroupStratifier;
    
    // Add an already existing FhirMeasureReportGroupStratifier to the end of the list.
    function AddItem(value : TFhirMeasureReportGroupStratifier) : TFhirMeasureReportGroupStratifier; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReportGroupStratifier) : Integer;
    
    // Insert FhirMeasureReportGroupStratifier before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReportGroupStratifier;
    
    // Insert an existing FhirMeasureReportGroupStratifier before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReportGroupStratifier);
    
    // Get the iIndexth FhirMeasureReportGroupStratifier. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReportGroupStratifier);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReportGroupStratifier;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMeasureReportGroupStratifiers[index : Integer] : TFhirMeasureReportGroupStratifier read GetItemN write SetItemN; default;
  End;

  // This element contains the results for a single stratum within the stratifier. For example, when stratifying on administrative gender, there will be four strata, one for each possible gender value.
  TFhirMeasureReportGroupStratifierStratum = class (TFhirBackboneElement)
  protected
    FValue : TFhirDataType;
    FcomponentList : TFhirMeasureReportGroupStratifierStratumComponentList;
    FpopulationList : TFhirMeasureReportGroupStratifierStratumPopulationList;
    FMeasureScore : TFhirDataType;
    procedure SetValue(value : TFhirDataType);
    function GetComponentList : TFhirMeasureReportGroupStratifierStratumComponentList;
    function GetHasComponentList : Boolean;
    function GetPopulationList : TFhirMeasureReportGroupStratifierStratumPopulationList;
    function GetHasPopulationList : Boolean;
    procedure SetMeasureScore(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReportGroupStratifierStratum; overload;
    function Clone : TFhirMeasureReportGroupStratifierStratum; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The value for this stratum, expressed as a CodeableConcept. When defining stratifiers on complex values, the value must be rendered such that the value for each stratum within the stratifier is unique. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The value for this stratum, expressed as a CodeableConcept. When defining stratifiers on complex values, the value must be rendered such that the value for each stratum within the stratifier is unique.
    property valueElement : TFhirDataType read FValue write SetValue;

    // A stratifier component value.
    property componentList : TFhirMeasureReportGroupStratifierStratumComponentList read GetComponentList;
    property hasComponentList : boolean read GetHasComponentList;

    // The populations that make up the stratum, one for each type of population appropriate to the measure.
    property populationList : TFhirMeasureReportGroupStratifierStratumPopulationList read GetPopulationList;
    property hasPopulationList : boolean read GetHasPopulationList;

    // Typed access to The measure score for this stratum, calculated as appropriate for the measure type and scoring method, and based on only the members of this stratum. (defined for API consistency)
    property measureScore : TFhirDataType read FMeasureScore write SetMeasureScore;
    // The measure score for this stratum, calculated as appropriate for the measure type and scoring method, and based on only the members of this stratum.
    property measureScoreElement : TFhirDataType read FMeasureScore write SetMeasureScore;

  end;

  TFhirMeasureReportGroupStratifierStratumListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportGroupStratifierStratumList;
    function GetCurrent : TFhirMeasureReportGroupStratifierStratum;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportGroupStratifierStratumList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReportGroupStratifierStratum read GetCurrent;
  end;

  TFhirMeasureReportGroupStratifierStratumList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMeasureReportGroupStratifierStratum;
    procedure SetItemN(index : Integer; value : TFhirMeasureReportGroupStratifierStratum);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMeasureReportGroupStratifierStratumList; overload;
    function Clone : TFhirMeasureReportGroupStratifierStratumList; overload;
    function GetEnumerator : TFhirMeasureReportGroupStratifierStratumListEnumerator;
    
    //  Add a FhirMeasureReportGroupStratifierStratum to the end of the list.
    function Append : TFhirMeasureReportGroupStratifierStratum;
    
    // Add an already existing FhirMeasureReportGroupStratifierStratum to the end of the list.
    function AddItem(value : TFhirMeasureReportGroupStratifierStratum) : TFhirMeasureReportGroupStratifierStratum; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReportGroupStratifierStratum) : Integer;
    
    // Insert FhirMeasureReportGroupStratifierStratum before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReportGroupStratifierStratum;
    
    // Insert an existing FhirMeasureReportGroupStratifierStratum before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReportGroupStratifierStratum);
    
    // Get the iIndexth FhirMeasureReportGroupStratifierStratum. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReportGroupStratifierStratum);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReportGroupStratifierStratum;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMeasureReportGroupStratifierStrata[index : Integer] : TFhirMeasureReportGroupStratifierStratum read GetItemN write SetItemN; default;
  End;

  // A stratifier component value.
  TFhirMeasureReportGroupStratifierStratumComponent = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReportGroupStratifierStratumComponent; overload;
    function Clone : TFhirMeasureReportGroupStratifierStratumComponent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The code for the stratum component value. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The code for the stratum component value.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The stratum component value. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The stratum component value.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirMeasureReportGroupStratifierStratumComponentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportGroupStratifierStratumComponentList;
    function GetCurrent : TFhirMeasureReportGroupStratifierStratumComponent;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportGroupStratifierStratumComponentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReportGroupStratifierStratumComponent read GetCurrent;
  end;

  TFhirMeasureReportGroupStratifierStratumComponentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMeasureReportGroupStratifierStratumComponent;
    procedure SetItemN(index : Integer; value : TFhirMeasureReportGroupStratifierStratumComponent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMeasureReportGroupStratifierStratumComponentList; overload;
    function Clone : TFhirMeasureReportGroupStratifierStratumComponentList; overload;
    function GetEnumerator : TFhirMeasureReportGroupStratifierStratumComponentListEnumerator;
    
    //  Add a FhirMeasureReportGroupStratifierStratumComponent to the end of the list.
    function Append : TFhirMeasureReportGroupStratifierStratumComponent;
    
    // Add an already existing FhirMeasureReportGroupStratifierStratumComponent to the end of the list.
    function AddItem(value : TFhirMeasureReportGroupStratifierStratumComponent) : TFhirMeasureReportGroupStratifierStratumComponent; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReportGroupStratifierStratumComponent) : Integer;
    
    // Insert FhirMeasureReportGroupStratifierStratumComponent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReportGroupStratifierStratumComponent;
    
    // Insert an existing FhirMeasureReportGroupStratifierStratumComponent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReportGroupStratifierStratumComponent);
    
    // Get the iIndexth FhirMeasureReportGroupStratifierStratumComponent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReportGroupStratifierStratumComponent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReportGroupStratifierStratumComponent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMeasureReportGroupStratifierStratumComponents[index : Integer] : TFhirMeasureReportGroupStratifierStratumComponent read GetItemN write SetItemN; default;
  End;

  // The populations that make up the stratum, one for each type of population appropriate to the measure.
  TFhirMeasureReportGroupStratifierStratumPopulation = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FCount : TFhirInteger;
    FSubjectResults : TFhirReference;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetCount(value : TFhirInteger);
    function GetCountST : String;
    procedure SetCountST(value : String);
    procedure SetSubjectResults(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReportGroupStratifierStratumPopulation; overload;
    function Clone : TFhirMeasureReportGroupStratifierStratumPopulation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of the population. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The type of the population.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The number of members of the population in this stratum.
    property count : String read GetCountST write SetCountST;
    // The number of members of the population in this stratum.
    property countElement : TFhirInteger read FCount write SetCount;

    // Typed access to This element refers to a List of subject level MeasureReport resources, one for each subject in this population in this stratum. (defined for API consistency)
    property subjectResults : TFhirReference read FSubjectResults write SetSubjectResults;
    // This element refers to a List of subject level MeasureReport resources, one for each subject in this population in this stratum.
    property subjectResultsElement : TFhirReference read FSubjectResults write SetSubjectResults;

  end;

  TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportGroupStratifierStratumPopulationList;
    function GetCurrent : TFhirMeasureReportGroupStratifierStratumPopulation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportGroupStratifierStratumPopulationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReportGroupStratifierStratumPopulation read GetCurrent;
  end;

  TFhirMeasureReportGroupStratifierStratumPopulationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMeasureReportGroupStratifierStratumPopulation;
    procedure SetItemN(index : Integer; value : TFhirMeasureReportGroupStratifierStratumPopulation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMeasureReportGroupStratifierStratumPopulationList; overload;
    function Clone : TFhirMeasureReportGroupStratifierStratumPopulationList; overload;
    function GetEnumerator : TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator;
    
    //  Add a FhirMeasureReportGroupStratifierStratumPopulation to the end of the list.
    function Append : TFhirMeasureReportGroupStratifierStratumPopulation;
    
    // Add an already existing FhirMeasureReportGroupStratifierStratumPopulation to the end of the list.
    function AddItem(value : TFhirMeasureReportGroupStratifierStratumPopulation) : TFhirMeasureReportGroupStratifierStratumPopulation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReportGroupStratifierStratumPopulation) : Integer;
    
    // Insert FhirMeasureReportGroupStratifierStratumPopulation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReportGroupStratifierStratumPopulation;
    
    // Insert an existing FhirMeasureReportGroupStratifierStratumPopulation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReportGroupStratifierStratumPopulation);
    
    // Get the iIndexth FhirMeasureReportGroupStratifierStratumPopulation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReportGroupStratifierStratumPopulation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReportGroupStratifierStratumPopulation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMeasureReportGroupStratifierStratumPopulations[index : Integer] : TFhirMeasureReportGroupStratifierStratumPopulation read GetItemN write SetItemN; default;
  End;

  // The MeasureReport resource contains the results of the calculation of a measure; and optionally a reference to the resources involved in that calculation.
  TFhirMeasureReport = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirEnum;
    FDataUpdateType : TFhirEnum;
    FMeasure : TFhirCanonical;
    FSubject : TFhirReference;
    FDate : TFhirDateTime;
    FReporter : TFhirReference;
    FReportingVendor : TFhirReference;
    FLocation : TFhirReference;
    FPeriod : TFhirPeriod;
    FInputParameters : TFhirReference;
    FScoring : TFhirCodeableConcept;
    FImprovementNotation : TFhirCodeableConcept;
    FgroupList : TFhirMeasureReportGroupList;
    FevaluatedResourceList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirMeasureReportStatusEnum;
    procedure SetStatusST(value : TFhirMeasureReportStatusEnum);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirMeasureReportTypeEnum;
    procedure SetType_ST(value : TFhirMeasureReportTypeEnum);
    procedure SetDataUpdateType(value : TFhirEnum);
    function GetDataUpdateTypeST : TFhirSubmitDataUpdateTypeEnum;
    procedure SetDataUpdateTypeST(value : TFhirSubmitDataUpdateTypeEnum);
    procedure SetMeasure(value : TFhirCanonical);
    function GetMeasureST : String;
    procedure SetMeasureST(value : String);
    procedure SetSubject(value : TFhirReference);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetReporter(value : TFhirReference);
    procedure SetReportingVendor(value : TFhirReference);
    procedure SetLocation(value : TFhirReference);
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetInputParameters(value : TFhirReference);
    procedure SetScoring(value : TFhirCodeableConcept);
    procedure SetImprovementNotation(value : TFhirCodeableConcept);
    function GetGroupList : TFhirMeasureReportGroupList;
    function GetHasGroupList : Boolean;
    function GetEvaluatedResourceList : TFhirReferenceList;
    function GetHasEvaluatedResourceList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReport; overload;
    function Clone : TFhirMeasureReport; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A formal identifier that is used to identify this MeasureReport when it is represented in other formats or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The MeasureReport status. No data will be available until the MeasureReport status is complete.
    property status : TFhirMeasureReportStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The type of measure report. This may be an individual report, which provides the score for the measure for an individual member of the population; a subject-listing, which returns the list of members that meet the various criteria in the measure; a summary report, which returns a population count for each of the criteria in the measure; or a data-collection, which enables the MeasureReport to be used to exchange the data-of-interest for a quality measure.
    property type_ : TFhirMeasureReportTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Indicates whether the data submitted in an data-exchange report represents a snapshot or incremental update. A snapshot update replaces all previously submitted data for the receiver, whereas an incremental update represents only updated and/or changed data and should be applied as a differential update to the existing submitted data for the receiver.
    property dataUpdateType : TFhirSubmitDataUpdateTypeEnum read GetDataUpdateTypeST write SetDataUpdateTypeST;
    property dataUpdateTypeElement : TFhirEnum read FDataUpdateType write SetDataUpdateType;

    // Typed access to A reference to the Measure that was calculated to produce this report.
    property measure : String read GetMeasureST write SetMeasureST;
    // A reference to the Measure that was calculated to produce this report.
    property measureElement : TFhirCanonical read FMeasure write SetMeasure;

    // Typed access to Optional subject identifying the individual or individuals the report is for. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // Optional subject identifying the individual or individuals the report is for.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The date this measure report was generated.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date this measure report was generated.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The individual or organization that is reporting the data. (defined for API consistency)
    property reporter : TFhirReference read FReporter write SetReporter;
    // The individual or organization that is reporting the data.
    property reporterElement : TFhirReference read FReporter write SetReporter;

    // Typed access to A reference to the vendor who queried the data, calculated results and/or generated the report. The ‘reporting vendor’ is intended to represent the submitting entity when it is not the same as the reporting entity. This extension is used when the Receiver is interested in getting vendor information in the report. (defined for API consistency)
    property reportingVendor : TFhirReference read FReportingVendor write SetReportingVendor;
    // A reference to the vendor who queried the data, calculated results and/or generated the report. The ‘reporting vendor’ is intended to represent the submitting entity when it is not the same as the reporting entity. This extension is used when the Receiver is interested in getting vendor information in the report.
    property reportingVendorElement : TFhirReference read FReportingVendor write SetReportingVendor;

    // Typed access to A reference to the location for which the data is being reported. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // A reference to the location for which the data is being reported.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // Typed access to The reporting period for which the report was calculated. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The reporting period for which the report was calculated.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to A reference to a Parameters resource (typically represented using a contained resource) that represents any input parameters that were provided to the operation that generated the report. (defined for API consistency)
    property inputParameters : TFhirReference read FInputParameters write SetInputParameters;
    // A reference to a Parameters resource (typically represented using a contained resource) that represents any input parameters that were provided to the operation that generated the report.
    property inputParametersElement : TFhirReference read FInputParameters write SetInputParameters;

    // Typed access to Indicates how the calculation is performed for the measure, including proportion, ratio, continuous-variable, and cohort. The value set is extensible, allowing additional measure scoring types to be represented. It is expected to be the same as the scoring element on the referenced Measure. (defined for API consistency)
    property scoring : TFhirCodeableConcept read FScoring write SetScoring;
    // Indicates how the calculation is performed for the measure, including proportion, ratio, continuous-variable, and cohort. The value set is extensible, allowing additional measure scoring types to be represented. It is expected to be the same as the scoring element on the referenced Measure.
    property scoringElement : TFhirCodeableConcept read FScoring write SetScoring;

    // Typed access to Whether improvement in the measure is noted by an increase or decrease in the measure score. (defined for API consistency)
    property improvementNotation : TFhirCodeableConcept read FImprovementNotation write SetImprovementNotation;
    // Whether improvement in the measure is noted by an increase or decrease in the measure score.
    property improvementNotationElement : TFhirCodeableConcept read FImprovementNotation write SetImprovementNotation;

    // The results of the calculation, one for each population group in the measure.
    property groupList : TFhirMeasureReportGroupList read GetGroupList;
    property hasGroupList : boolean read GetHasGroupList;

    // A reference to a Resource that was used in the calculation of this measure.
    property evaluatedResourceList : TFhirReferenceList read GetEvaluatedResourceList;
    property hasEvaluatedResourceList : boolean read GetHasEvaluatedResourceList;

  end;

  TFhirMeasureReportListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportList;
    function GetCurrent : TFhirMeasureReport;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReport read GetCurrent;
  end;

  TFhirMeasureReportList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMeasureReport;
    procedure SetItemN(index : Integer; value : TFhirMeasureReport);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMeasureReportList; overload;
    function Clone : TFhirMeasureReportList; overload;
    function GetEnumerator : TFhirMeasureReportListEnumerator;
    
    //  Add a FhirMeasureReport to the end of the list.
    function Append : TFhirMeasureReport;
    
    // Add an already existing FhirMeasureReport to the end of the list.
    function AddItem(value : TFhirMeasureReport) : TFhirMeasureReport; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReport) : Integer;
    
    // Insert FhirMeasureReport before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReport;
    
    // Insert an existing FhirMeasureReport before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReport);
    
    // Get the iIndexth FhirMeasureReport. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReport);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReport;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMeasureReports[index : Integer] : TFhirMeasureReport read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MESSAGEHEADER}
  // The destination application which the message is intended for.
  TFhirMessageHeaderDestination = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FTarget : TFhirReference;
    FEndpoint : TFhirUrl;
    FReceiver : TFhirReference;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTarget(value : TFhirReference);
    procedure SetEndpoint(value : TFhirUrl);
    function GetEndpointST : String;
    procedure SetEndpointST(value : String);
    procedure SetReceiver(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageHeaderDestination; overload;
    function Clone : TFhirMessageHeaderDestination; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Human-readable name for the target system.
    property name : String read GetNameST write SetNameST;
    // Human-readable name for the target system.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Identifies the target end system in situations where the initial message transmission is to an intermediary system. (defined for API consistency)
    property target : TFhirReference read FTarget write SetTarget;
    // Identifies the target end system in situations where the initial message transmission is to an intermediary system.
    property targetElement : TFhirReference read FTarget write SetTarget;

    // Typed access to Indicates where the message should be routed to.
    property endpoint : String read GetEndpointST write SetEndpointST;
    // Indicates where the message should be routed to.
    property endpointElement : TFhirUrl read FEndpoint write SetEndpoint;

    // Typed access to Allows data conveyed by a message to be addressed to a particular person or department when routing to a specific application isn't sufficient. (defined for API consistency)
    property receiver : TFhirReference read FReceiver write SetReceiver;
    // Allows data conveyed by a message to be addressed to a particular person or department when routing to a specific application isn't sufficient.
    property receiverElement : TFhirReference read FReceiver write SetReceiver;

  end;

  TFhirMessageHeaderDestinationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageHeaderDestinationList;
    function GetCurrent : TFhirMessageHeaderDestination;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMessageHeaderDestinationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageHeaderDestination read GetCurrent;
  end;

  TFhirMessageHeaderDestinationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMessageHeaderDestination;
    procedure SetItemN(index : Integer; value : TFhirMessageHeaderDestination);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMessageHeaderDestinationList; overload;
    function Clone : TFhirMessageHeaderDestinationList; overload;
    function GetEnumerator : TFhirMessageHeaderDestinationListEnumerator;
    
    //  Add a FhirMessageHeaderDestination to the end of the list.
    function Append : TFhirMessageHeaderDestination;
    
    // Add an already existing FhirMessageHeaderDestination to the end of the list.
    function AddItem(value : TFhirMessageHeaderDestination) : TFhirMessageHeaderDestination; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageHeaderDestination) : Integer;
    
    // Insert FhirMessageHeaderDestination before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageHeaderDestination;
    
    // Insert an existing FhirMessageHeaderDestination before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageHeaderDestination);
    
    // Get the iIndexth FhirMessageHeaderDestination. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeaderDestination);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageHeaderDestination;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMessageHeaderDestinations[index : Integer] : TFhirMessageHeaderDestination read GetItemN write SetItemN; default;
  End;

  // The source application from which this message originated.
  TFhirMessageHeaderSource = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FSoftware : TFhirString;
    FVersion : TFhirString;
    FContact : TFhirContactPoint;
    FEndpoint : TFhirUrl;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetSoftware(value : TFhirString);
    function GetSoftwareST : String;
    procedure SetSoftwareST(value : String);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetContact(value : TFhirContactPoint);
    procedure SetEndpoint(value : TFhirUrl);
    function GetEndpointST : String;
    procedure SetEndpointST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageHeaderSource; overload;
    function Clone : TFhirMessageHeaderSource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Human-readable name for the source system.
    property name : String read GetNameST write SetNameST;
    // Human-readable name for the source system.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to May include configuration or other information useful in debugging.
    property software : String read GetSoftwareST write SetSoftwareST;
    // May include configuration or other information useful in debugging.
    property softwareElement : TFhirString read FSoftware write SetSoftware;

    // Typed access to Can convey versions of multiple systems in situations where a message passes through multiple hands.
    property version : String read GetVersionST write SetVersionST;
    // Can convey versions of multiple systems in situations where a message passes through multiple hands.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to An e-mail, phone, website or other contact point to use to resolve issues with message communications. (defined for API consistency)
    property contact : TFhirContactPoint read FContact write SetContact;
    // An e-mail, phone, website or other contact point to use to resolve issues with message communications.
    property contactElement : TFhirContactPoint read FContact write SetContact;

    // Typed access to Identifies the routing target to send acknowledgements to.
    property endpoint : String read GetEndpointST write SetEndpointST;
    // Identifies the routing target to send acknowledgements to.
    property endpointElement : TFhirUrl read FEndpoint write SetEndpoint;

  end;

  TFhirMessageHeaderSourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageHeaderSourceList;
    function GetCurrent : TFhirMessageHeaderSource;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMessageHeaderSourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageHeaderSource read GetCurrent;
  end;

  TFhirMessageHeaderSourceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMessageHeaderSource;
    procedure SetItemN(index : Integer; value : TFhirMessageHeaderSource);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMessageHeaderSourceList; overload;
    function Clone : TFhirMessageHeaderSourceList; overload;
    function GetEnumerator : TFhirMessageHeaderSourceListEnumerator;
    
    //  Add a FhirMessageHeaderSource to the end of the list.
    function Append : TFhirMessageHeaderSource;
    
    // Add an already existing FhirMessageHeaderSource to the end of the list.
    function AddItem(value : TFhirMessageHeaderSource) : TFhirMessageHeaderSource; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageHeaderSource) : Integer;
    
    // Insert FhirMessageHeaderSource before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageHeaderSource;
    
    // Insert an existing FhirMessageHeaderSource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageHeaderSource);
    
    // Get the iIndexth FhirMessageHeaderSource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeaderSource);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageHeaderSource;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMessageHeaderSources[index : Integer] : TFhirMessageHeaderSource read GetItemN write SetItemN; default;
  End;

  // Information about the message that this message is a response to.  Only present if this message is a response.
  TFhirMessageHeaderResponse = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FCode : TFhirEnum;
    FDetails : TFhirReference;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetCode(value : TFhirEnum);
    function GetCodeST : TFhirResponseTypeEnum;
    procedure SetCodeST(value : TFhirResponseTypeEnum);
    procedure SetDetails(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageHeaderResponse; overload;
    function Clone : TFhirMessageHeaderResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The MessageHeader.id of the message to which this message is a response. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // The MessageHeader.id of the message to which this message is a response.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Code that identifies the type of response to the message - whether it was successful or not, and whether it should be resent or not.
    property code : TFhirResponseTypeEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to Full details of any issues found in the message. (defined for API consistency)
    property details : TFhirReference read FDetails write SetDetails;
    // Full details of any issues found in the message.
    property detailsElement : TFhirReference read FDetails write SetDetails;

  end;

  TFhirMessageHeaderResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageHeaderResponseList;
    function GetCurrent : TFhirMessageHeaderResponse;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMessageHeaderResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageHeaderResponse read GetCurrent;
  end;

  TFhirMessageHeaderResponseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMessageHeaderResponse;
    procedure SetItemN(index : Integer; value : TFhirMessageHeaderResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMessageHeaderResponseList; overload;
    function Clone : TFhirMessageHeaderResponseList; overload;
    function GetEnumerator : TFhirMessageHeaderResponseListEnumerator;
    
    //  Add a FhirMessageHeaderResponse to the end of the list.
    function Append : TFhirMessageHeaderResponse;
    
    // Add an already existing FhirMessageHeaderResponse to the end of the list.
    function AddItem(value : TFhirMessageHeaderResponse) : TFhirMessageHeaderResponse; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageHeaderResponse) : Integer;
    
    // Insert FhirMessageHeaderResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageHeaderResponse;
    
    // Insert an existing FhirMessageHeaderResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageHeaderResponse);
    
    // Get the iIndexth FhirMessageHeaderResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeaderResponse);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageHeaderResponse;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMessageHeaderResponses[index : Integer] : TFhirMessageHeaderResponse read GetItemN write SetItemN; default;
  End;

  // The header for a message exchange that is either requesting or responding to an action.  The reference(s) that are the subject of the action as well as other information related to the action are typically transmitted in a bundle in which the MessageHeader resource instance is the first resource in the bundle.
  TFhirMessageHeader = class (TFhirDomainResource)
  protected
    FEvent : TFhirDataType;
    FdestinationList : TFhirMessageHeaderDestinationList;
    FSender : TFhirReference;
    FEnterer : TFhirReference;
    FAuthor : TFhirReference;
    FSource : TFhirMessageHeaderSource;
    FResponsible : TFhirReference;
    FReason : TFhirCodeableConcept;
    FResponse : TFhirMessageHeaderResponse;
    FfocusList : TFhirReferenceList;
    FDefinition : TFhirCanonical;
    procedure SetEvent(value : TFhirDataType);
    function GetDestinationList : TFhirMessageHeaderDestinationList;
    function GetHasDestinationList : Boolean;
    procedure SetSender(value : TFhirReference);
    procedure SetEnterer(value : TFhirReference);
    procedure SetAuthor(value : TFhirReference);
    procedure SetSource(value : TFhirMessageHeaderSource);
    procedure SetResponsible(value : TFhirReference);
    procedure SetReason(value : TFhirCodeableConcept);
    procedure SetResponse(value : TFhirMessageHeaderResponse);
    function GetFocusList : TFhirReferenceList;
    function GetHasFocusList : Boolean;
    procedure SetDefinition(value : TFhirCanonical);
    function GetDefinitionST : String;
    procedure SetDefinitionST(value : String);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageHeader; overload;
    function Clone : TFhirMessageHeader; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Code that identifies the event this message represents and connects it with its definition. Events defined as part of the FHIR specification have the system value "http://terminology.hl7.org/CodeSystem/message-events".  Alternatively a canonical uri to the EventDefinition. (defined for API consistency)
    property event : TFhirDataType read FEvent write SetEvent;
    // Code that identifies the event this message represents and connects it with its definition. Events defined as part of the FHIR specification have the system value "http://terminology.hl7.org/CodeSystem/message-events".  Alternatively a canonical uri to the EventDefinition.
    property eventElement : TFhirDataType read FEvent write SetEvent;

    // The destination application which the message is intended for.
    property destinationList : TFhirMessageHeaderDestinationList read GetDestinationList;
    property hasDestinationList : boolean read GetHasDestinationList;

    // Typed access to Identifies the sending system to allow the use of a trust relationship. (defined for API consistency)
    property sender : TFhirReference read FSender write SetSender;
    // Identifies the sending system to allow the use of a trust relationship.
    property senderElement : TFhirReference read FSender write SetSender;

    // Typed access to The person or device that performed the data entry leading to this message. When there is more than one candidate, pick the most proximal to the message. Can provide other enterers in extensions. (defined for API consistency)
    property enterer : TFhirReference read FEnterer write SetEnterer;
    // The person or device that performed the data entry leading to this message. When there is more than one candidate, pick the most proximal to the message. Can provide other enterers in extensions.
    property entererElement : TFhirReference read FEnterer write SetEnterer;

    // Typed access to The logical author of the message - the personor device that decided the described event should happen. When there is more than one candidate, pick the most proximal to the MessageHeader. Can provide other authors in extensions. (defined for API consistency)
    property author : TFhirReference read FAuthor write SetAuthor;
    // The logical author of the message - the personor device that decided the described event should happen. When there is more than one candidate, pick the most proximal to the MessageHeader. Can provide other authors in extensions.
    property authorElement : TFhirReference read FAuthor write SetAuthor;

    // Typed access to The source application from which this message originated. (defined for API consistency)
    property source : TFhirMessageHeaderSource read FSource write SetSource;
    // The source application from which this message originated.
    property sourceElement : TFhirMessageHeaderSource read FSource write SetSource;

    // Typed access to The person or organization that accepts overall responsibility for the contents of the message. The implication is that the message event happened under the policies of the responsible party. (defined for API consistency)
    property responsible : TFhirReference read FResponsible write SetResponsible;
    // The person or organization that accepts overall responsibility for the contents of the message. The implication is that the message event happened under the policies of the responsible party.
    property responsibleElement : TFhirReference read FResponsible write SetResponsible;

    // Typed access to Coded indication of the cause for the event - indicates  a reason for the occurrence of the event that is a focus of this message. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // Coded indication of the cause for the event - indicates  a reason for the occurrence of the event that is a focus of this message.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

    // Typed access to Information about the message that this message is a response to.  Only present if this message is a response. (defined for API consistency)
    property response : TFhirMessageHeaderResponse read FResponse write SetResponse;
    // Information about the message that this message is a response to.  Only present if this message is a response.
    property responseElement : TFhirMessageHeaderResponse read FResponse write SetResponse;

    // The actual data of the message - a reference to the root/focus class of the event. This is allowed to be a Parameters resource.
    property focusList : TFhirReferenceList read GetFocusList;
    property hasFocusList : boolean read GetHasFocusList;

    // Typed access to Permanent link to the MessageDefinition for this message.
    property definition : String read GetDefinitionST write SetDefinitionST;
    // Permanent link to the MessageDefinition for this message.
    property definitionElement : TFhirCanonical read FDefinition write SetDefinition;

  end;

  TFhirMessageHeaderListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageHeaderList;
    function GetCurrent : TFhirMessageHeader;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMessageHeaderList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageHeader read GetCurrent;
  end;

  TFhirMessageHeaderList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMessageHeader;
    procedure SetItemN(index : Integer; value : TFhirMessageHeader);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMessageHeaderList; overload;
    function Clone : TFhirMessageHeaderList; overload;
    function GetEnumerator : TFhirMessageHeaderListEnumerator;
    
    //  Add a FhirMessageHeader to the end of the list.
    function Append : TFhirMessageHeader;
    
    // Add an already existing FhirMessageHeader to the end of the list.
    function AddItem(value : TFhirMessageHeader) : TFhirMessageHeader; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageHeader) : Integer;
    
    // Insert FhirMessageHeader before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageHeader;
    
    // Insert an existing FhirMessageHeader before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageHeader);
    
    // Get the iIndexth FhirMessageHeader. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeader);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageHeader;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMessageHeaders[index : Integer] : TFhirMessageHeader read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_OPERATIONOUTCOME}
  // An error, warning, or information message that results from a system action.
  TFhirOperationOutcomeIssue = class (TFhirBackboneElement)
  protected
    FSeverity : TFhirEnum;
    FCode : TFhirEnum;
    FDetails : TFhirCodeableConcept;
    FDiagnostics : TFhirString;
    FlocationList : TFhirStringList;
    FexpressionList : TFhirStringList;
    procedure SetSeverity(value : TFhirEnum);
    function GetSeverityST : TFhirIssueSeverityEnum;
    procedure SetSeverityST(value : TFhirIssueSeverityEnum);
    procedure SetCode(value : TFhirEnum);
    function GetCodeST : TFhirIssueTypeEnum;
    procedure SetCodeST(value : TFhirIssueTypeEnum);
    procedure SetDetails(value : TFhirCodeableConcept);
    procedure SetDiagnostics(value : TFhirString);
    function GetDiagnosticsST : String;
    procedure SetDiagnosticsST(value : String);
    function GetLocationList : TFhirStringList;
    function GetHasLocationList : Boolean;
    function GetExpressionList : TFhirStringList;
    function GetHasExpressionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOperationOutcomeIssue; overload;
    function Clone : TFhirOperationOutcomeIssue; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Indicates whether the issue indicates a variation from successful processing.
    property severity : TFhirIssueSeverityEnum read GetSeverityST write SetSeverityST;
    property severityElement : TFhirEnum read FSeverity write SetSeverity;

    // Describes the type of the issue. The system that creates an OperationOutcome SHALL choose the most applicable code from the IssueType value set, and may additional provide its own code for the error in the details element.
    property code : TFhirIssueTypeEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to Additional details about the error. This may be a text description of the error or a system code that identifies the error. (defined for API consistency)
    property details : TFhirCodeableConcept read FDetails write SetDetails;
    // Additional details about the error. This may be a text description of the error or a system code that identifies the error.
    property detailsElement : TFhirCodeableConcept read FDetails write SetDetails;

    // Typed access to Additional diagnostic information about the issue.
    property diagnostics : String read GetDiagnosticsST write SetDiagnosticsST;
    // Additional diagnostic information about the issue.
    property diagnosticsElement : TFhirString read FDiagnostics write SetDiagnostics;

    // This element is deprecated because it is XML specific. It is replaced by issue.expression, which is format independent, and simpler to parse.   For resource issues, this will be a simple XPath limited to element names, repetition indicators and the default child accessor that identifies one of the elements in the resource that caused this issue to be raised.  For HTTP errors, will be "http." + the parameter name.
    property locationList : TFhirStringList read GetLocationList;
    property hasLocationList : boolean read GetHasLocationList;

    // A [simple subset of FHIRPath](fhirpath.html#simple) limited to element names, repetition indicators and the default child accessor that identifies one of the elements in the resource that caused this issue to be raised.
    property expressionList : TFhirStringList read GetExpressionList;
    property hasExpressionList : boolean read GetHasExpressionList;

  end;

  TFhirOperationOutcomeIssueListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOperationOutcomeIssueList;
    function GetCurrent : TFhirOperationOutcomeIssue;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirOperationOutcomeIssueList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOperationOutcomeIssue read GetCurrent;
  end;

  TFhirOperationOutcomeIssueList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOperationOutcomeIssue;
    procedure SetItemN(index : Integer; value : TFhirOperationOutcomeIssue);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirOperationOutcomeIssueList; overload;
    function Clone : TFhirOperationOutcomeIssueList; overload;
    function GetEnumerator : TFhirOperationOutcomeIssueListEnumerator;
    
    //  Add a FhirOperationOutcomeIssue to the end of the list.
    function Append : TFhirOperationOutcomeIssue;
    
    // Add an already existing FhirOperationOutcomeIssue to the end of the list.
    function AddItem(value : TFhirOperationOutcomeIssue) : TFhirOperationOutcomeIssue; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOperationOutcomeIssue) : Integer;
    
    // Insert FhirOperationOutcomeIssue before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOperationOutcomeIssue;
    
    // Insert an existing FhirOperationOutcomeIssue before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOperationOutcomeIssue);
    
    // Get the iIndexth FhirOperationOutcomeIssue. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOperationOutcomeIssue);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOperationOutcomeIssue;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirOperationOutcomeIssues[index : Integer] : TFhirOperationOutcomeIssue read GetItemN write SetItemN; default;
  End;

  // A collection of error, warning, or information messages that result from a system action.
  TFhirOperationOutcome = class (TFhirDomainResource)
  protected
    FissueList : TFhirOperationOutcomeIssueList;
    function GetIssueList : TFhirOperationOutcomeIssueList;
    function GetHasIssueList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOperationOutcome; overload;
    function Clone : TFhirOperationOutcome; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // An error, warning, or information message that results from a system action.
    property issueList : TFhirOperationOutcomeIssueList read GetIssueList;
    property hasIssueList : boolean read GetHasIssueList;

  end;

  TFhirOperationOutcomeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOperationOutcomeList;
    function GetCurrent : TFhirOperationOutcome;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirOperationOutcomeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOperationOutcome read GetCurrent;
  end;

  TFhirOperationOutcomeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOperationOutcome;
    procedure SetItemN(index : Integer; value : TFhirOperationOutcome);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirOperationOutcomeList; overload;
    function Clone : TFhirOperationOutcomeList; overload;
    function GetEnumerator : TFhirOperationOutcomeListEnumerator;
    
    //  Add a FhirOperationOutcome to the end of the list.
    function Append : TFhirOperationOutcome;
    
    // Add an already existing FhirOperationOutcome to the end of the list.
    function AddItem(value : TFhirOperationOutcome) : TFhirOperationOutcome; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOperationOutcome) : Integer;
    
    // Insert FhirOperationOutcome before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOperationOutcome;
    
    // Insert an existing FhirOperationOutcome before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOperationOutcome);
    
    // Get the iIndexth FhirOperationOutcome. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOperationOutcome);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOperationOutcome;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirOperationOutcomes[index : Integer] : TFhirOperationOutcome read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_PARAMETERS}
  // A parameter passed to or received from the operation.
  TFhirParametersParameter = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FValue : TFhirDataType;
    FResource : TFhirResource;
    FpartList : TFhirParametersParameterList;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetValue(value : TFhirDataType);
    procedure SetResource(value : TFhirResource);
    function GetPartList : TFhirParametersParameterList;
    function GetHasPartList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirParametersParameter; overload;
    function Clone : TFhirParametersParameter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of the parameter (reference to the operation definition).
    property name : String read GetNameST write SetNameST;
    // The name of the parameter (reference to the operation definition).
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Conveys the content if the parameter is a data type. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // Conveys the content if the parameter is a data type.
    property valueElement : TFhirDataType read FValue write SetValue;

    // Typed access to Conveys the content if the parameter is a whole resource. (defined for API consistency)
    property resource : TFhirResource read FResource write SetResource;
    // Conveys the content if the parameter is a whole resource.
    property resourceElement : TFhirResource read FResource write SetResource;

    // A named part of a multi-part parameter.
    property partList : TFhirParametersParameterList read GetPartList;
    property hasPartList : boolean read GetHasPartList;

  end;

  TFhirParametersParameterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirParametersParameterList;
    function GetCurrent : TFhirParametersParameter;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirParametersParameterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirParametersParameter read GetCurrent;
  end;

  TFhirParametersParameterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirParametersParameter;
    procedure SetItemN(index : Integer; value : TFhirParametersParameter);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirParametersParameterList; overload;
    function Clone : TFhirParametersParameterList; overload;
    function GetEnumerator : TFhirParametersParameterListEnumerator;
    
    //  Add a FhirParametersParameter to the end of the list.
    function Append : TFhirParametersParameter;
    
    // Add an already existing FhirParametersParameter to the end of the list.
    function AddItem(value : TFhirParametersParameter) : TFhirParametersParameter; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirParametersParameter) : Integer;
    
    // Insert FhirParametersParameter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirParametersParameter;
    
    // Insert an existing FhirParametersParameter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirParametersParameter);
    
    // Get the iIndexth FhirParametersParameter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirParametersParameter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirParametersParameter;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirParametersParameters[index : Integer] : TFhirParametersParameter read GetItemN write SetItemN; default;
  End;

  // This resource is used to pass information into and back from an operation (whether invoked directly from REST or within a messaging environment).  It is not persisted or allowed to be referenced by other resources.
  TFhirParameters = class (TFhirResource)
  protected
    FparameterList : TFhirParametersParameterList;
    function GetParameterList : TFhirParametersParameterList;
    function GetHasParameterList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirParameters; overload;
    function Clone : TFhirParameters; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A parameter passed to or received from the operation.
    property parameterList : TFhirParametersParameterList read GetParameterList;
    property hasParameterList : boolean read GetHasParameterList;

  end;

  TFhirParametersListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirParametersList;
    function GetCurrent : TFhirParameters;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirParametersList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirParameters read GetCurrent;
  end;

  TFhirParametersList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirParameters;
    procedure SetItemN(index : Integer; value : TFhirParameters);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirParametersList; overload;
    function Clone : TFhirParametersList; overload;
    function GetEnumerator : TFhirParametersListEnumerator;
    
    //  Add a FhirParameters to the end of the list.
    function Append : TFhirParameters;
    
    // Add an already existing FhirParameters to the end of the list.
    function AddItem(value : TFhirParameters) : TFhirParameters; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirParameters) : Integer;
    
    // Insert FhirParameters before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirParameters;
    
    // Insert an existing FhirParameters before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirParameters);
    
    // Get the iIndexth FhirParameters. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirParameters);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirParameters;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirParameters[index : Integer] : TFhirParameters read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_PERMISSION}
  // The asserted justification for using the data.
  TFhirPermissionJustification = class (TFhirBackboneElement)
  protected
    FbasisList : TFhirCodeableConceptList;
    FevidenceList : TFhirReferenceList;
    function GetBasisList : TFhirCodeableConceptList;
    function GetHasBasisList : Boolean;
    function GetEvidenceList : TFhirReferenceList;
    function GetHasEvidenceList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPermissionJustification; overload;
    function Clone : TFhirPermissionJustification; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // This would be a codeableconcept, or a coding, which can be constrained to , for example, the 6 grounds for processing in GDPR.
    property basisList : TFhirCodeableConceptList read GetBasisList;
    property hasBasisList : boolean read GetHasBasisList;

    // Justifing rational.
    property evidenceList : TFhirReferenceList read GetEvidenceList;
    property hasEvidenceList : boolean read GetHasEvidenceList;

  end;

  TFhirPermissionJustificationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPermissionJustificationList;
    function GetCurrent : TFhirPermissionJustification;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPermissionJustificationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPermissionJustification read GetCurrent;
  end;

  TFhirPermissionJustificationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPermissionJustification;
    procedure SetItemN(index : Integer; value : TFhirPermissionJustification);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPermissionJustificationList; overload;
    function Clone : TFhirPermissionJustificationList; overload;
    function GetEnumerator : TFhirPermissionJustificationListEnumerator;
    
    //  Add a FhirPermissionJustification to the end of the list.
    function Append : TFhirPermissionJustification;
    
    // Add an already existing FhirPermissionJustification to the end of the list.
    function AddItem(value : TFhirPermissionJustification) : TFhirPermissionJustification; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPermissionJustification) : Integer;
    
    // Insert FhirPermissionJustification before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPermissionJustification;
    
    // Insert an existing FhirPermissionJustification before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPermissionJustification);
    
    // Get the iIndexth FhirPermissionJustification. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPermissionJustification);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPermissionJustification;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPermissionJustifications[index : Integer] : TFhirPermissionJustification read GetItemN write SetItemN; default;
  End;

  // A set of rules.
  TFhirPermissionRule = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FdataList : TFhirPermissionRuleDataList;
    FactivityList : TFhirPermissionRuleActivityList;
    FlimitList : TFhirCodeableConceptList;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirConsentProvisionTypeEnum;
    procedure SetType_ST(value : TFhirConsentProvisionTypeEnum);
    function GetDataList : TFhirPermissionRuleDataList;
    function GetHasDataList : Boolean;
    function GetActivityList : TFhirPermissionRuleActivityList;
    function GetHasActivityList : Boolean;
    function GetLimitList : TFhirCodeableConceptList;
    function GetHasLimitList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPermissionRule; overload;
    function Clone : TFhirPermissionRule; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // deny | permit.
    property type_ : TFhirConsentProvisionTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // A description or definition of which activities are allowed to be done on the data.
    property dataList : TFhirPermissionRuleDataList read GetDataList;
    property hasDataList : boolean read GetHasDataList;

    // A description or definition of which activities are allowed to be done on the data.
    property activityList : TFhirPermissionRuleActivityList read GetActivityList;
    property hasActivityList : boolean read GetHasActivityList;

    // What limits apply to the use of the data.
    property limitList : TFhirCodeableConceptList read GetLimitList;
    property hasLimitList : boolean read GetHasLimitList;

  end;

  TFhirPermissionRuleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPermissionRuleList;
    function GetCurrent : TFhirPermissionRule;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPermissionRuleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPermissionRule read GetCurrent;
  end;

  TFhirPermissionRuleList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPermissionRule;
    procedure SetItemN(index : Integer; value : TFhirPermissionRule);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPermissionRuleList; overload;
    function Clone : TFhirPermissionRuleList; overload;
    function GetEnumerator : TFhirPermissionRuleListEnumerator;
    
    //  Add a FhirPermissionRule to the end of the list.
    function Append : TFhirPermissionRule;
    
    // Add an already existing FhirPermissionRule to the end of the list.
    function AddItem(value : TFhirPermissionRule) : TFhirPermissionRule; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPermissionRule) : Integer;
    
    // Insert FhirPermissionRule before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPermissionRule;
    
    // Insert an existing FhirPermissionRule before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPermissionRule);
    
    // Get the iIndexth FhirPermissionRule. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPermissionRule);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPermissionRule;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPermissionRules[index : Integer] : TFhirPermissionRule read GetItemN write SetItemN; default;
  End;

  // A description or definition of which activities are allowed to be done on the data.
  TFhirPermissionRuleData = class (TFhirBackboneElement)
  protected
    FresourceList : TFhirPermissionRuleDataResourceList;
    FsecurityList : TFhirCodingList;
    FperiodList : TFhirPeriodList;
    FExpression : TFhirExpression;
    function GetResourceList : TFhirPermissionRuleDataResourceList;
    function GetHasResourceList : Boolean;
    function GetSecurityList : TFhirCodingList;
    function GetHasSecurityList : Boolean;
    function GetPeriodList : TFhirPeriodList;
    function GetHasPeriodList : Boolean;
    procedure SetExpression(value : TFhirExpression);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPermissionRuleData; overload;
    function Clone : TFhirPermissionRuleData; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Explicit FHIR Resource references.
    property resourceList : TFhirPermissionRuleDataResourceList read GetResourceList;
    property hasResourceList : boolean read GetHasResourceList;

    // The data in scope are those with the given codes present in that data .meta.security element.
    property securityList : TFhirCodingList read GetSecurityList;
    property hasSecurityList : boolean read GetHasSecurityList;

    // Clinical or Operational Relevant period of time that bounds the data controlled by this rule.
    property periodList : TFhirPeriodList read GetPeriodList;
    property hasPeriodList : boolean read GetHasPeriodList;

    // Typed access to Used when other data selection elements are insufficient. (defined for API consistency)
    property expression : TFhirExpression read FExpression write SetExpression;
    // Used when other data selection elements are insufficient.
    property expressionElement : TFhirExpression read FExpression write SetExpression;

  end;

  TFhirPermissionRuleDataListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPermissionRuleDataList;
    function GetCurrent : TFhirPermissionRuleData;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPermissionRuleDataList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPermissionRuleData read GetCurrent;
  end;

  TFhirPermissionRuleDataList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPermissionRuleData;
    procedure SetItemN(index : Integer; value : TFhirPermissionRuleData);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPermissionRuleDataList; overload;
    function Clone : TFhirPermissionRuleDataList; overload;
    function GetEnumerator : TFhirPermissionRuleDataListEnumerator;
    
    //  Add a FhirPermissionRuleData to the end of the list.
    function Append : TFhirPermissionRuleData;
    
    // Add an already existing FhirPermissionRuleData to the end of the list.
    function AddItem(value : TFhirPermissionRuleData) : TFhirPermissionRuleData; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPermissionRuleData) : Integer;
    
    // Insert FhirPermissionRuleData before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPermissionRuleData;
    
    // Insert an existing FhirPermissionRuleData before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPermissionRuleData);
    
    // Get the iIndexth FhirPermissionRuleData. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPermissionRuleData);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPermissionRuleData;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPermissionRuleData[index : Integer] : TFhirPermissionRuleData read GetItemN write SetItemN; default;
  End;

  // Explicit FHIR Resource references.
  TFhirPermissionRuleDataResource = class (TFhirBackboneElement)
  protected
    FMeaning : TFhirEnum;
    FReference : TFhirReference;
    procedure SetMeaning(value : TFhirEnum);
    function GetMeaningST : TFhirConsentDataMeaningEnum;
    procedure SetMeaningST(value : TFhirConsentDataMeaningEnum);
    procedure SetReference(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPermissionRuleDataResource; overload;
    function Clone : TFhirPermissionRuleDataResource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // How the resource reference is interpreted when testing consent restrictions.
    property meaning : TFhirConsentDataMeaningEnum read GetMeaningST write SetMeaningST;
    property meaningElement : TFhirEnum read FMeaning write SetMeaning;

    // Typed access to A reference to a specific resource that defines which resources are covered by this consent. (defined for API consistency)
    property reference : TFhirReference read FReference write SetReference;
    // A reference to a specific resource that defines which resources are covered by this consent.
    property referenceElement : TFhirReference read FReference write SetReference;

  end;

  TFhirPermissionRuleDataResourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPermissionRuleDataResourceList;
    function GetCurrent : TFhirPermissionRuleDataResource;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPermissionRuleDataResourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPermissionRuleDataResource read GetCurrent;
  end;

  TFhirPermissionRuleDataResourceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPermissionRuleDataResource;
    procedure SetItemN(index : Integer; value : TFhirPermissionRuleDataResource);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPermissionRuleDataResourceList; overload;
    function Clone : TFhirPermissionRuleDataResourceList; overload;
    function GetEnumerator : TFhirPermissionRuleDataResourceListEnumerator;
    
    //  Add a FhirPermissionRuleDataResource to the end of the list.
    function Append : TFhirPermissionRuleDataResource;
    
    // Add an already existing FhirPermissionRuleDataResource to the end of the list.
    function AddItem(value : TFhirPermissionRuleDataResource) : TFhirPermissionRuleDataResource; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPermissionRuleDataResource) : Integer;
    
    // Insert FhirPermissionRuleDataResource before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPermissionRuleDataResource;
    
    // Insert an existing FhirPermissionRuleDataResource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPermissionRuleDataResource);
    
    // Get the iIndexth FhirPermissionRuleDataResource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPermissionRuleDataResource);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPermissionRuleDataResource;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPermissionRuleDataResources[index : Integer] : TFhirPermissionRuleDataResource read GetItemN write SetItemN; default;
  End;

  // A description or definition of which activities are allowed to be done on the data.
  TFhirPermissionRuleActivity = class (TFhirBackboneElement)
  protected
    FactorList : TFhirReferenceList;
    FactionList : TFhirCodeableConceptList;
    FpurposeList : TFhirCodeableConceptList;
    function GetActorList : TFhirReferenceList;
    function GetHasActorList : Boolean;
    function GetActionList : TFhirCodeableConceptList;
    function GetHasActionList : Boolean;
    function GetPurposeList : TFhirCodeableConceptList;
    function GetHasPurposeList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPermissionRuleActivity; overload;
    function Clone : TFhirPermissionRuleActivity; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The actor(s) authorized for the defined activity.
    property actorList : TFhirReferenceList read GetActorList;
    property hasActorList : boolean read GetHasActorList;

    // Actions controlled by this Rule.
    property actionList : TFhirCodeableConceptList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

    // The purpose for which the permission is given.
    property purposeList : TFhirCodeableConceptList read GetPurposeList;
    property hasPurposeList : boolean read GetHasPurposeList;

  end;

  TFhirPermissionRuleActivityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPermissionRuleActivityList;
    function GetCurrent : TFhirPermissionRuleActivity;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPermissionRuleActivityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPermissionRuleActivity read GetCurrent;
  end;

  TFhirPermissionRuleActivityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPermissionRuleActivity;
    procedure SetItemN(index : Integer; value : TFhirPermissionRuleActivity);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPermissionRuleActivityList; overload;
    function Clone : TFhirPermissionRuleActivityList; overload;
    function GetEnumerator : TFhirPermissionRuleActivityListEnumerator;
    
    //  Add a FhirPermissionRuleActivity to the end of the list.
    function Append : TFhirPermissionRuleActivity;
    
    // Add an already existing FhirPermissionRuleActivity to the end of the list.
    function AddItem(value : TFhirPermissionRuleActivity) : TFhirPermissionRuleActivity; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPermissionRuleActivity) : Integer;
    
    // Insert FhirPermissionRuleActivity before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPermissionRuleActivity;
    
    // Insert an existing FhirPermissionRuleActivity before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPermissionRuleActivity);
    
    // Get the iIndexth FhirPermissionRuleActivity. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPermissionRuleActivity);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPermissionRuleActivity;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPermissionRuleActivities[index : Integer] : TFhirPermissionRuleActivity read GetItemN write SetItemN; default;
  End;

  // Permission resource holds access rules for a given data and context.
  TFhirPermission = class (TFhirDomainResource)
  protected
    FStatus : TFhirEnum;
    FAsserter : TFhirReference;
    FdateList : TFhirDateTimeList;
    FValidity : TFhirPeriod;
    FJustification : TFhirPermissionJustification;
    FCombining : TFhirEnum;
    FruleList : TFhirPermissionRuleList;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPermissionStatusEnum;
    procedure SetStatusST(value : TFhirPermissionStatusEnum);
    procedure SetAsserter(value : TFhirReference);
    function GetDateList : TFhirDateTimeList;
    function GetHasDateList : Boolean;
    procedure SetValidity(value : TFhirPeriod);
    procedure SetJustification(value : TFhirPermissionJustification);
    procedure SetCombining(value : TFhirEnum);
    function GetCombiningST : TFhirPermissionRuleCombiningEnum;
    procedure SetCombiningST(value : TFhirPermissionRuleCombiningEnum);
    function GetRuleList : TFhirPermissionRuleList;
    function GetHasRuleList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPermission; overload;
    function Clone : TFhirPermission; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Status.
    property status : TFhirPermissionStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The person or entity that asserts the permission. (defined for API consistency)
    property asserter : TFhirReference read FAsserter write SetAsserter;
    // The person or entity that asserts the permission.
    property asserterElement : TFhirReference read FAsserter write SetAsserter;

    // The date that permission was asserted.
    property dateList : TFhirDateTimeList read GetDateList;
    property hasDateList : boolean read GetHasDateList;

    // Typed access to The period in which the permission is active. (defined for API consistency)
    property validity : TFhirPeriod read FValidity write SetValidity;
    // The period in which the permission is active.
    property validityElement : TFhirPeriod read FValidity write SetValidity;

    // Typed access to The asserted justification for using the data. (defined for API consistency)
    property justification : TFhirPermissionJustification read FJustification write SetJustification;
    // The asserted justification for using the data.
    property justificationElement : TFhirPermissionJustification read FJustification write SetJustification;

    // Defines a procedure for arriving at an access decision given the set of rules.
    property combining : TFhirPermissionRuleCombiningEnum read GetCombiningST write SetCombiningST;
    property combiningElement : TFhirEnum read FCombining write SetCombining;

    // A set of rules.
    property ruleList : TFhirPermissionRuleList read GetRuleList;
    property hasRuleList : boolean read GetHasRuleList;

  end;

  TFhirPermissionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPermissionList;
    function GetCurrent : TFhirPermission;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPermissionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPermission read GetCurrent;
  end;

  TFhirPermissionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPermission;
    procedure SetItemN(index : Integer; value : TFhirPermission);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPermissionList; overload;
    function Clone : TFhirPermissionList; overload;
    function GetEnumerator : TFhirPermissionListEnumerator;
    
    //  Add a FhirPermission to the end of the list.
    function Append : TFhirPermission;
    
    // Add an already existing FhirPermission to the end of the list.
    function AddItem(value : TFhirPermission) : TFhirPermission; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPermission) : Integer;
    
    // Insert FhirPermission before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPermission;
    
    // Insert an existing FhirPermission before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPermission);
    
    // Get the iIndexth FhirPermission. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPermission);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPermission;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPermissions[index : Integer] : TFhirPermission read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PERMISSION}
{$IFDEF FHIR_PLANDEFINITION}
  // A goal describes an expected outcome that activities within the plan are intended to achieve. For example, weight loss, restoring an activity of daily living, obtaining herd immunity via immunization, meeting a process improvement objective, meeting the acceptance criteria for a test as specified by a quality specification, etc.
  TFhirPlanDefinitionGoal = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FDescription : TFhirCodeableConcept;
    FPriority : TFhirCodeableConcept;
    FStart : TFhirCodeableConcept;
    FaddressesList : TFhirCodeableConceptList;
    FdocumentationList : TFhirRelatedArtifactList;
    FtargetList : TFhirPlanDefinitionGoalTargetList;
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetDescription(value : TFhirCodeableConcept);
    procedure SetPriority(value : TFhirCodeableConcept);
    procedure SetStart(value : TFhirCodeableConcept);
    function GetAddressesList : TFhirCodeableConceptList;
    function GetHasAddressesList : Boolean;
    function GetDocumentationList : TFhirRelatedArtifactList;
    function GetHasDocumentationList : Boolean;
    function GetTargetList : TFhirPlanDefinitionGoalTargetList;
    function GetHasTargetList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinitionGoal; overload;
    function Clone : TFhirPlanDefinitionGoal; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates a category the goal falls within. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Indicates a category the goal falls within.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Human-readable and/or coded description of a specific desired objective of care, such as "control blood pressure" or "negotiate an obstacle course" or "dance with child at wedding". (defined for API consistency)
    property description : TFhirCodeableConcept read FDescription write SetDescription;
    // Human-readable and/or coded description of a specific desired objective of care, such as "control blood pressure" or "negotiate an obstacle course" or "dance with child at wedding".
    property descriptionElement : TFhirCodeableConcept read FDescription write SetDescription;

    // Typed access to Identifies the expected level of importance associated with reaching/sustaining the defined goal. (defined for API consistency)
    property priority : TFhirCodeableConcept read FPriority write SetPriority;
    // Identifies the expected level of importance associated with reaching/sustaining the defined goal.
    property priorityElement : TFhirCodeableConcept read FPriority write SetPriority;

    // Typed access to The event after which the goal should begin being pursued. (defined for API consistency)
    property start : TFhirCodeableConcept read FStart write SetStart;
    // The event after which the goal should begin being pursued.
    property startElement : TFhirCodeableConcept read FStart write SetStart;

    // Identifies problems, conditions, issues, or concerns the goal is intended to address.
    property addressesList : TFhirCodeableConceptList read GetAddressesList;
    property hasAddressesList : boolean read GetHasAddressesList;

    // Didactic or other informational resources associated with the goal that provide further supporting information about the goal. Information resources can include inline text commentary and links to web resources.
    property documentationList : TFhirRelatedArtifactList read GetDocumentationList;
    property hasDocumentationList : boolean read GetHasDocumentationList;

    // Indicates what should be done and within what timeframe.
    property targetList : TFhirPlanDefinitionGoalTargetList read GetTargetList;
    property hasTargetList : boolean read GetHasTargetList;

  end;

  TFhirPlanDefinitionGoalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionGoalList;
    function GetCurrent : TFhirPlanDefinitionGoal;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionGoalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinitionGoal read GetCurrent;
  end;

  TFhirPlanDefinitionGoalList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPlanDefinitionGoal;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinitionGoal);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPlanDefinitionGoalList; overload;
    function Clone : TFhirPlanDefinitionGoalList; overload;
    function GetEnumerator : TFhirPlanDefinitionGoalListEnumerator;
    
    //  Add a FhirPlanDefinitionGoal to the end of the list.
    function Append : TFhirPlanDefinitionGoal;
    
    // Add an already existing FhirPlanDefinitionGoal to the end of the list.
    function AddItem(value : TFhirPlanDefinitionGoal) : TFhirPlanDefinitionGoal; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinitionGoal) : Integer;
    
    // Insert FhirPlanDefinitionGoal before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinitionGoal;
    
    // Insert an existing FhirPlanDefinitionGoal before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinitionGoal);
    
    // Get the iIndexth FhirPlanDefinitionGoal. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinitionGoal);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinitionGoal;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPlanDefinitionGoals[index : Integer] : TFhirPlanDefinitionGoal read GetItemN write SetItemN; default;
  End;

  // Indicates what should be done and within what timeframe.
  TFhirPlanDefinitionGoalTarget = class (TFhirBackboneElement)
  protected
    FMeasure : TFhirCodeableConcept;
    FDetail : TFhirDataType;
    FDue : TFhirDuration;
    procedure SetMeasure(value : TFhirCodeableConcept);
    procedure SetDetail(value : TFhirDataType);
    procedure SetDue(value : TFhirDuration);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinitionGoalTarget; overload;
    function Clone : TFhirPlanDefinitionGoalTarget; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The parameter whose value is to be tracked, e.g. body weight, blood pressure, or hemoglobin A1c level. (defined for API consistency)
    property measure : TFhirCodeableConcept read FMeasure write SetMeasure;
    // The parameter whose value is to be tracked, e.g. body weight, blood pressure, or hemoglobin A1c level.
    property measureElement : TFhirCodeableConcept read FMeasure write SetMeasure;

    // Typed access to The target value of the measure to be achieved to signify fulfillment of the goal, e.g. 150 pounds or 7.0%, or in the case of pharmaceutical quality - NMT 0.6%, Clear solution, etc. Either the high or low or both values of the range can be specified. When a low value is missing, it indicates that the goal is achieved at any value at or below the high value. Similarly, if the high value is missing, it indicates that the goal is achieved at any value at or above the low value. (defined for API consistency)
    property detail : TFhirDataType read FDetail write SetDetail;
    // The target value of the measure to be achieved to signify fulfillment of the goal, e.g. 150 pounds or 7.0%, or in the case of pharmaceutical quality - NMT 0.6%, Clear solution, etc. Either the high or low or both values of the range can be specified. When a low value is missing, it indicates that the goal is achieved at any value at or below the high value. Similarly, if the high value is missing, it indicates that the goal is achieved at any value at or above the low value.
    property detailElement : TFhirDataType read FDetail write SetDetail;

    // Typed access to Indicates the timeframe after the start of the goal in which the goal should be met. (defined for API consistency)
    property due : TFhirDuration read FDue write SetDue;
    // Indicates the timeframe after the start of the goal in which the goal should be met.
    property dueElement : TFhirDuration read FDue write SetDue;

  end;

  TFhirPlanDefinitionGoalTargetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionGoalTargetList;
    function GetCurrent : TFhirPlanDefinitionGoalTarget;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionGoalTargetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinitionGoalTarget read GetCurrent;
  end;

  TFhirPlanDefinitionGoalTargetList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPlanDefinitionGoalTarget;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinitionGoalTarget);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPlanDefinitionGoalTargetList; overload;
    function Clone : TFhirPlanDefinitionGoalTargetList; overload;
    function GetEnumerator : TFhirPlanDefinitionGoalTargetListEnumerator;
    
    //  Add a FhirPlanDefinitionGoalTarget to the end of the list.
    function Append : TFhirPlanDefinitionGoalTarget;
    
    // Add an already existing FhirPlanDefinitionGoalTarget to the end of the list.
    function AddItem(value : TFhirPlanDefinitionGoalTarget) : TFhirPlanDefinitionGoalTarget; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinitionGoalTarget) : Integer;
    
    // Insert FhirPlanDefinitionGoalTarget before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinitionGoalTarget;
    
    // Insert an existing FhirPlanDefinitionGoalTarget before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinitionGoalTarget);
    
    // Get the iIndexth FhirPlanDefinitionGoalTarget. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinitionGoalTarget);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinitionGoalTarget;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPlanDefinitionGoalTargets[index : Integer] : TFhirPlanDefinitionGoalTarget read GetItemN write SetItemN; default;
  End;

  // Actors represent the individuals or groups involved in the execution of the defined set of activities.
  TFhirPlanDefinitionActor = class (TFhirBackboneElement)
  protected
    FTitle : TFhirString;
    FDescription : TFhirMarkdown;
    FoptionList : TFhirPlanDefinitionActorOptionList;
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetOptionList : TFhirPlanDefinitionActorOptionList;
    function GetHasOptionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinitionActor; overload;
    function Clone : TFhirPlanDefinitionActor; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A descriptive label for the actor.
    property title : String read GetTitleST write SetTitleST;
    // A descriptive label for the actor.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to A description of how the actor fits into the overall actions of the plan definition.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A description of how the actor fits into the overall actions of the plan definition.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The characteristics of the candidates that could serve as the actor.
    property optionList : TFhirPlanDefinitionActorOptionList read GetOptionList;
    property hasOptionList : boolean read GetHasOptionList;

  end;

  TFhirPlanDefinitionActorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionActorList;
    function GetCurrent : TFhirPlanDefinitionActor;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionActorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinitionActor read GetCurrent;
  end;

  TFhirPlanDefinitionActorList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPlanDefinitionActor;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinitionActor);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPlanDefinitionActorList; overload;
    function Clone : TFhirPlanDefinitionActorList; overload;
    function GetEnumerator : TFhirPlanDefinitionActorListEnumerator;
    
    //  Add a FhirPlanDefinitionActor to the end of the list.
    function Append : TFhirPlanDefinitionActor;
    
    // Add an already existing FhirPlanDefinitionActor to the end of the list.
    function AddItem(value : TFhirPlanDefinitionActor) : TFhirPlanDefinitionActor; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinitionActor) : Integer;
    
    // Insert FhirPlanDefinitionActor before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinitionActor;
    
    // Insert an existing FhirPlanDefinitionActor before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinitionActor);
    
    // Get the iIndexth FhirPlanDefinitionActor. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinitionActor);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinitionActor;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPlanDefinitionActors[index : Integer] : TFhirPlanDefinitionActor read GetItemN write SetItemN; default;
  End;

  // The characteristics of the candidates that could serve as the actor.
  TFhirPlanDefinitionActorOption = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FTypeCanonical : TFhirCanonical;
    FTypeReference : TFhirReference;
    FRole : TFhirCodeableConcept;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirActionParticipantTypeEnum;
    procedure SetType_ST(value : TFhirActionParticipantTypeEnum);
    procedure SetTypeCanonical(value : TFhirCanonical);
    function GetTypeCanonicalST : String;
    procedure SetTypeCanonicalST(value : String);
    procedure SetTypeReference(value : TFhirReference);
    procedure SetRole(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinitionActorOption; overload;
    function Clone : TFhirPlanDefinitionActorOption; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of participant in the action.
    property type_ : TFhirActionParticipantTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The type of participant in the action.
    property typeCanonical : String read GetTypeCanonicalST write SetTypeCanonicalST;
    // The type of participant in the action.
    property typeCanonicalElement : TFhirCanonical read FTypeCanonical write SetTypeCanonical;

    // Typed access to The type of participant in the action. (defined for API consistency)
    property typeReference : TFhirReference read FTypeReference write SetTypeReference;
    // The type of participant in the action.
    property typeReferenceElement : TFhirReference read FTypeReference write SetTypeReference;

    // Typed access to The role the participant should play in performing the described action. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // The role the participant should play in performing the described action.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

  end;

  TFhirPlanDefinitionActorOptionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionActorOptionList;
    function GetCurrent : TFhirPlanDefinitionActorOption;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionActorOptionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinitionActorOption read GetCurrent;
  end;

  TFhirPlanDefinitionActorOptionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPlanDefinitionActorOption;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinitionActorOption);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPlanDefinitionActorOptionList; overload;
    function Clone : TFhirPlanDefinitionActorOptionList; overload;
    function GetEnumerator : TFhirPlanDefinitionActorOptionListEnumerator;
    
    //  Add a FhirPlanDefinitionActorOption to the end of the list.
    function Append : TFhirPlanDefinitionActorOption;
    
    // Add an already existing FhirPlanDefinitionActorOption to the end of the list.
    function AddItem(value : TFhirPlanDefinitionActorOption) : TFhirPlanDefinitionActorOption; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinitionActorOption) : Integer;
    
    // Insert FhirPlanDefinitionActorOption before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinitionActorOption;
    
    // Insert an existing FhirPlanDefinitionActorOption before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinitionActorOption);
    
    // Get the iIndexth FhirPlanDefinitionActorOption. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinitionActorOption);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinitionActorOption;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPlanDefinitionActorOptions[index : Integer] : TFhirPlanDefinitionActorOption read GetItemN write SetItemN; default;
  End;

  // An action or group of actions to be taken as part of the plan. For example, in clinical care, an action would be to prescribe a particular indicated medication, or perform a particular test as appropriate. In pharmaceutical quality, an action would be the test that needs to be performed on a drug product as defined in the quality specification.
  TFhirPlanDefinitionAction = class (TFhirBackboneElement)
  protected
    FLinkId : TFhirString;
    FPrefix : TFhirString;
    FTitle : TFhirString;
    FDescription : TFhirString;
    FTextEquivalent : TFhirString;
    FPriority : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FreasonList : TFhirCodeableConceptList;
    FdocumentationList : TFhirRelatedArtifactList;
    FgoalIdList : TFhirIdList;
    FSubject : TFhirDataType;
    FtriggerList : TFhirTriggerDefinitionList;
    FconditionList : TFhirPlanDefinitionActionConditionList;
    FinputList : TFhirPlanDefinitionActionInputList;
    FoutputList : TFhirPlanDefinitionActionOutputList;
    FrelatedActionList : TFhirPlanDefinitionActionRelatedActionList;
    FTiming : TFhirDataType;
    FLocation : TFhirCodeableReference;
    FparticipantList : TFhirPlanDefinitionActionParticipantList;
    FType_ : TFhirCodeableConcept;
    FGroupingBehavior : TFhirEnum;
    FSelectionBehavior : TFhirEnum;
    FRequiredBehavior : TFhirEnum;
    FPrecheckBehavior : TFhirEnum;
    FCardinalityBehavior : TFhirEnum;
    FDefinition : TFhirDataType;
    FTransform : TFhirCanonical;
    FdynamicValueList : TFhirPlanDefinitionActionDynamicValueList;
    FactionList : TFhirPlanDefinitionActionList;
    procedure SetLinkId(value : TFhirString);
    function GetLinkIdST : String;
    procedure SetLinkIdST(value : String);
    procedure SetPrefix(value : TFhirString);
    function GetPrefixST : String;
    procedure SetPrefixST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetTextEquivalent(value : TFhirString);
    function GetTextEquivalentST : String;
    procedure SetTextEquivalentST(value : String);
    procedure SetPriority(value : TFhirEnum);
    function GetPriorityST : TFhirRequestPriorityEnum;
    procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    procedure SetCode(value : TFhirCodeableConcept);
    function GetReasonList : TFhirCodeableConceptList;
    function GetHasReasonList : Boolean;
    function GetDocumentationList : TFhirRelatedArtifactList;
    function GetHasDocumentationList : Boolean;
    function GetGoalIdList : TFhirIdList;
    function GetHasGoalIdList : Boolean;
    procedure SetSubject(value : TFhirDataType);
    function GetTriggerList : TFhirTriggerDefinitionList;
    function GetHasTriggerList : Boolean;
    function GetConditionList : TFhirPlanDefinitionActionConditionList;
    function GetHasConditionList : Boolean;
    function GetInputList : TFhirPlanDefinitionActionInputList;
    function GetHasInputList : Boolean;
    function GetOutputList : TFhirPlanDefinitionActionOutputList;
    function GetHasOutputList : Boolean;
    function GetRelatedActionList : TFhirPlanDefinitionActionRelatedActionList;
    function GetHasRelatedActionList : Boolean;
    procedure SetTiming(value : TFhirDataType);
    procedure SetLocation(value : TFhirCodeableReference);
    function GetParticipantList : TFhirPlanDefinitionActionParticipantList;
    function GetHasParticipantList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetGroupingBehavior(value : TFhirEnum);
    function GetGroupingBehaviorST : TFhirActionGroupingBehaviorEnum;
    procedure SetGroupingBehaviorST(value : TFhirActionGroupingBehaviorEnum);
    procedure SetSelectionBehavior(value : TFhirEnum);
    function GetSelectionBehaviorST : TFhirActionSelectionBehaviorEnum;
    procedure SetSelectionBehaviorST(value : TFhirActionSelectionBehaviorEnum);
    procedure SetRequiredBehavior(value : TFhirEnum);
    function GetRequiredBehaviorST : TFhirActionRequiredBehaviorEnum;
    procedure SetRequiredBehaviorST(value : TFhirActionRequiredBehaviorEnum);
    procedure SetPrecheckBehavior(value : TFhirEnum);
    function GetPrecheckBehaviorST : TFhirActionPrecheckBehaviorEnum;
    procedure SetPrecheckBehaviorST(value : TFhirActionPrecheckBehaviorEnum);
    procedure SetCardinalityBehavior(value : TFhirEnum);
    function GetCardinalityBehaviorST : TFhirActionCardinalityBehaviorEnum;
    procedure SetCardinalityBehaviorST(value : TFhirActionCardinalityBehaviorEnum);
    procedure SetDefinition(value : TFhirDataType);
    procedure SetTransform(value : TFhirCanonical);
    function GetTransformST : String;
    procedure SetTransformST(value : String);
    function GetDynamicValueList : TFhirPlanDefinitionActionDynamicValueList;
    function GetHasDynamicValueList : Boolean;
    function GetActionList : TFhirPlanDefinitionActionList;
    function GetHasActionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinitionAction; overload;
    function Clone : TFhirPlanDefinitionAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An identifier that is unique within the PlanDefinition to allow linkage within the realized CarePlan and/or RequestOrchestration.
    property linkId : String read GetLinkIdST write SetLinkIdST;
    // An identifier that is unique within the PlanDefinition to allow linkage within the realized CarePlan and/or RequestOrchestration.
    property linkIdElement : TFhirString read FLinkId write SetLinkId;

    // Typed access to A user-visible prefix for the action. For example a section or item numbering such as 1. or A.
    property prefix : String read GetPrefixST write SetPrefixST;
    // A user-visible prefix for the action. For example a section or item numbering such as 1. or A.
    property prefixElement : TFhirString read FPrefix write SetPrefix;

    // Typed access to The textual description of the action displayed to a user. For example, when the action is a test to be performed, the title would be the title of the test such as Assay by HPLC.
    property title : String read GetTitleST write SetTitleST;
    // The textual description of the action displayed to a user. For example, when the action is a test to be performed, the title would be the title of the test such as Assay by HPLC.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to A brief description of the action used to provide a summary to display to the user.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A brief description of the action used to provide a summary to display to the user.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to A text equivalent of the action to be performed. This provides a human-interpretable description of the action when the definition is consumed by a system that might not be capable of interpreting it dynamically.
    property textEquivalent : String read GetTextEquivalentST write SetTextEquivalentST;
    // A text equivalent of the action to be performed. This provides a human-interpretable description of the action when the definition is consumed by a system that might not be capable of interpreting it dynamically.
    property textEquivalentElement : TFhirString read FTextEquivalent write SetTextEquivalent;

    // Indicates how quickly the action should be addressed with respect to other actions.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // Typed access to A code that provides a meaning, grouping, or classification for the action or action group. For example, a section may have a LOINC code for the section of a documentation template. In pharmaceutical quality, an action (Test) such as pH could be classified as a physical property. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that provides a meaning, grouping, or classification for the action or action group. For example, a section may have a LOINC code for the section of a documentation template. In pharmaceutical quality, an action (Test) such as pH could be classified as a physical property.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // A description of why this action is necessary or appropriate.
    property reasonList : TFhirCodeableConceptList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Didactic or other informational resources associated with the action that can be provided to the CDS recipient. Information resources can include inline text commentary and links to web resources.
    property documentationList : TFhirRelatedArtifactList read GetDocumentationList;
    property hasDocumentationList : boolean read GetHasDocumentationList;

    // Identifies goals that this action supports. The reference must be to a goal element defined within this plan definition. In pharmaceutical quality, a goal represents acceptance criteria (Goal) for a given action (Test), so the goalId would be the unique id of a defined goal element establishing the acceptance criteria for the action.
    property goalIdList : TFhirIdList read GetGoalIdList;
    property hasGoalIdList : boolean read GetHasGoalIdList;

    // Typed access to A code, group definition, or canonical reference that describes the intended subject of the action and its children, if any. Canonical references are allowed to support the definition of protocols for drug and substance quality specifications, and is allowed to reference a MedicinalProductDefinition, SubstanceDefinition, AdministrableProductDefinition, ManufacturedItemDefinition, or PackagedProductDefinition resource. (defined for API consistency)
    property subject : TFhirDataType read FSubject write SetSubject;
    // A code, group definition, or canonical reference that describes the intended subject of the action and its children, if any. Canonical references are allowed to support the definition of protocols for drug and substance quality specifications, and is allowed to reference a MedicinalProductDefinition, SubstanceDefinition, AdministrableProductDefinition, ManufacturedItemDefinition, or PackagedProductDefinition resource.
    property subjectElement : TFhirDataType read FSubject write SetSubject;

    // A description of when the action should be triggered. When multiple triggers are specified on an action, any triggering event invokes the action.
    property triggerList : TFhirTriggerDefinitionList read GetTriggerList;
    property hasTriggerList : boolean read GetHasTriggerList;

    // An expression that describes applicability criteria or start/stop conditions for the action.
    property conditionList : TFhirPlanDefinitionActionConditionList read GetConditionList;
    property hasConditionList : boolean read GetHasConditionList;

    // Defines input data requirements for the action.
    property inputList : TFhirPlanDefinitionActionInputList read GetInputList;
    property hasInputList : boolean read GetHasInputList;

    // Defines the outputs of the action, if any.
    property outputList : TFhirPlanDefinitionActionOutputList read GetOutputList;
    property hasOutputList : boolean read GetHasOutputList;

    // A relationship to another action such as "before" or "30-60 minutes after start of".
    property relatedActionList : TFhirPlanDefinitionActionRelatedActionList read GetRelatedActionList;
    property hasRelatedActionList : boolean read GetHasRelatedActionList;

    // Typed access to An optional value describing when the action should be performed. (defined for API consistency)
    property timing : TFhirDataType read FTiming write SetTiming;
    // An optional value describing when the action should be performed.
    property timingElement : TFhirDataType read FTiming write SetTiming;

    // Typed access to Identifies the facility where the action will occur; e.g. home, hospital, specific clinic, etc. (defined for API consistency)
    property location : TFhirCodeableReference read FLocation write SetLocation;
    // Identifies the facility where the action will occur; e.g. home, hospital, specific clinic, etc.
    property locationElement : TFhirCodeableReference read FLocation write SetLocation;

    // Indicates who should participate in performing the action described.
    property participantList : TFhirPlanDefinitionActionParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // Typed access to The type of action to perform (create, update, remove). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of action to perform (create, update, remove).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Defines the grouping behavior for the action and its children.
    property groupingBehavior : TFhirActionGroupingBehaviorEnum read GetGroupingBehaviorST write SetGroupingBehaviorST;
    property groupingBehaviorElement : TFhirEnum read FGroupingBehavior write SetGroupingBehavior;

    // Defines the selection behavior for the action and its children.
    property selectionBehavior : TFhirActionSelectionBehaviorEnum read GetSelectionBehaviorST write SetSelectionBehaviorST;
    property selectionBehaviorElement : TFhirEnum read FSelectionBehavior write SetSelectionBehavior;

    // Defines the required behavior for the action.
    property requiredBehavior : TFhirActionRequiredBehaviorEnum read GetRequiredBehaviorST write SetRequiredBehaviorST;
    property requiredBehaviorElement : TFhirEnum read FRequiredBehavior write SetRequiredBehavior;

    // Defines whether the action should usually be preselected.
    property precheckBehavior : TFhirActionPrecheckBehaviorEnum read GetPrecheckBehaviorST write SetPrecheckBehaviorST;
    property precheckBehaviorElement : TFhirEnum read FPrecheckBehavior write SetPrecheckBehavior;

    // Defines whether the action can be selected multiple times.
    property cardinalityBehavior : TFhirActionCardinalityBehaviorEnum read GetCardinalityBehaviorST write SetCardinalityBehaviorST;
    property cardinalityBehaviorElement : TFhirEnum read FCardinalityBehavior write SetCardinalityBehavior;

    // Typed access to A reference to an ActivityDefinition that describes the action to be taken in detail, a PlanDefinition that describes a series of actions to be taken, a Questionnaire that should be filled out, a SpecimenDefinition describing a specimen to be collected, or an ObservationDefinition that specifies what observation should be captured. (defined for API consistency)
    property definition : TFhirDataType read FDefinition write SetDefinition;
    // A reference to an ActivityDefinition that describes the action to be taken in detail, a PlanDefinition that describes a series of actions to be taken, a Questionnaire that should be filled out, a SpecimenDefinition describing a specimen to be collected, or an ObservationDefinition that specifies what observation should be captured.
    property definitionElement : TFhirDataType read FDefinition write SetDefinition;

    // Typed access to A reference to a StructureMap resource that defines a transform that can be executed to produce the intent resource using the ActivityDefinition instance as the input.
    property transform : String read GetTransformST write SetTransformST;
    // A reference to a StructureMap resource that defines a transform that can be executed to produce the intent resource using the ActivityDefinition instance as the input.
    property transformElement : TFhirCanonical read FTransform write SetTransform;

    // Customizations that should be applied to the statically defined resource. For example, if the dosage of a medication must be computed based on the patient's weight, a customization would be used to specify an expression that calculated the weight, and the path on the resource that would contain the result.
    property dynamicValueList : TFhirPlanDefinitionActionDynamicValueList read GetDynamicValueList;
    property hasDynamicValueList : boolean read GetHasDynamicValueList;

    // Sub actions that are contained within the action. The behavior of this action determines the functionality of the sub-actions. For example, a selection behavior of at-most-one indicates that of the sub-actions, at most one may be chosen as part of realizing the action definition.
    property actionList : TFhirPlanDefinitionActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirPlanDefinitionActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionActionList;
    function GetCurrent : TFhirPlanDefinitionAction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinitionAction read GetCurrent;
  end;

  TFhirPlanDefinitionActionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPlanDefinitionAction;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinitionAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPlanDefinitionActionList; overload;
    function Clone : TFhirPlanDefinitionActionList; overload;
    function GetEnumerator : TFhirPlanDefinitionActionListEnumerator;
    
    //  Add a FhirPlanDefinitionAction to the end of the list.
    function Append : TFhirPlanDefinitionAction;
    
    // Add an already existing FhirPlanDefinitionAction to the end of the list.
    function AddItem(value : TFhirPlanDefinitionAction) : TFhirPlanDefinitionAction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinitionAction) : Integer;
    
    // Insert FhirPlanDefinitionAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinitionAction;
    
    // Insert an existing FhirPlanDefinitionAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinitionAction);
    
    // Get the iIndexth FhirPlanDefinitionAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinitionAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinitionAction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPlanDefinitionActions[index : Integer] : TFhirPlanDefinitionAction read GetItemN write SetItemN; default;
  End;

  // An expression that describes applicability criteria or start/stop conditions for the action.
  TFhirPlanDefinitionActionCondition = class (TFhirBackboneElement)
  protected
    FKind : TFhirEnum;
    FExpression : TFhirExpression;
    procedure SetKind(value : TFhirEnum);
    function GetKindST : TFhirActionConditionKindEnum;
    procedure SetKindST(value : TFhirActionConditionKindEnum);
    procedure SetExpression(value : TFhirExpression);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinitionActionCondition; overload;
    function Clone : TFhirPlanDefinitionActionCondition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The kind of condition.
    property kind : TFhirActionConditionKindEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    // Typed access to An expression that returns true or false, indicating whether the condition is satisfied. (defined for API consistency)
    property expression : TFhirExpression read FExpression write SetExpression;
    // An expression that returns true or false, indicating whether the condition is satisfied.
    property expressionElement : TFhirExpression read FExpression write SetExpression;

  end;

  TFhirPlanDefinitionActionConditionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionActionConditionList;
    function GetCurrent : TFhirPlanDefinitionActionCondition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionActionConditionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinitionActionCondition read GetCurrent;
  end;

  TFhirPlanDefinitionActionConditionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPlanDefinitionActionCondition;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinitionActionCondition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPlanDefinitionActionConditionList; overload;
    function Clone : TFhirPlanDefinitionActionConditionList; overload;
    function GetEnumerator : TFhirPlanDefinitionActionConditionListEnumerator;
    
    //  Add a FhirPlanDefinitionActionCondition to the end of the list.
    function Append : TFhirPlanDefinitionActionCondition;
    
    // Add an already existing FhirPlanDefinitionActionCondition to the end of the list.
    function AddItem(value : TFhirPlanDefinitionActionCondition) : TFhirPlanDefinitionActionCondition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinitionActionCondition) : Integer;
    
    // Insert FhirPlanDefinitionActionCondition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinitionActionCondition;
    
    // Insert an existing FhirPlanDefinitionActionCondition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinitionActionCondition);
    
    // Get the iIndexth FhirPlanDefinitionActionCondition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinitionActionCondition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinitionActionCondition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPlanDefinitionActionConditions[index : Integer] : TFhirPlanDefinitionActionCondition read GetItemN write SetItemN; default;
  End;

  // Defines input data requirements for the action.
  TFhirPlanDefinitionActionInput = class (TFhirBackboneElement)
  protected
    FTitle : TFhirString;
    FRequirement : TFhirDataRequirement;
    FRelatedData : TFhirId;
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetRequirement(value : TFhirDataRequirement);
    procedure SetRelatedData(value : TFhirId);
    function GetRelatedDataST : String;
    procedure SetRelatedDataST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinitionActionInput; overload;
    function Clone : TFhirPlanDefinitionActionInput; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A human-readable label for the data requirement used to label data flows in BPMN or similar diagrams. Also provides a human readable label when rendering the data requirement that conveys its purpose to human readers.
    property title : String read GetTitleST write SetTitleST;
    // A human-readable label for the data requirement used to label data flows in BPMN or similar diagrams. Also provides a human readable label when rendering the data requirement that conveys its purpose to human readers.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to Defines the data that is to be provided as input to the action. (defined for API consistency)
    property requirement : TFhirDataRequirement read FRequirement write SetRequirement;
    // Defines the data that is to be provided as input to the action.
    property requirementElement : TFhirDataRequirement read FRequirement write SetRequirement;

    // Typed access to Points to an existing input or output element that provides data to this input.
    property relatedData : String read GetRelatedDataST write SetRelatedDataST;
    // Points to an existing input or output element that provides data to this input.
    property relatedDataElement : TFhirId read FRelatedData write SetRelatedData;

  end;

  TFhirPlanDefinitionActionInputListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionActionInputList;
    function GetCurrent : TFhirPlanDefinitionActionInput;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionActionInputList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinitionActionInput read GetCurrent;
  end;

  TFhirPlanDefinitionActionInputList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPlanDefinitionActionInput;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinitionActionInput);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPlanDefinitionActionInputList; overload;
    function Clone : TFhirPlanDefinitionActionInputList; overload;
    function GetEnumerator : TFhirPlanDefinitionActionInputListEnumerator;
    
    //  Add a FhirPlanDefinitionActionInput to the end of the list.
    function Append : TFhirPlanDefinitionActionInput;
    
    // Add an already existing FhirPlanDefinitionActionInput to the end of the list.
    function AddItem(value : TFhirPlanDefinitionActionInput) : TFhirPlanDefinitionActionInput; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinitionActionInput) : Integer;
    
    // Insert FhirPlanDefinitionActionInput before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinitionActionInput;
    
    // Insert an existing FhirPlanDefinitionActionInput before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinitionActionInput);
    
    // Get the iIndexth FhirPlanDefinitionActionInput. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinitionActionInput);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinitionActionInput;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPlanDefinitionActionInputs[index : Integer] : TFhirPlanDefinitionActionInput read GetItemN write SetItemN; default;
  End;

  // Defines the outputs of the action, if any.
  TFhirPlanDefinitionActionOutput = class (TFhirBackboneElement)
  protected
    FTitle : TFhirString;
    FRequirement : TFhirDataRequirement;
    FRelatedData : TFhirString;
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetRequirement(value : TFhirDataRequirement);
    procedure SetRelatedData(value : TFhirString);
    function GetRelatedDataST : String;
    procedure SetRelatedDataST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinitionActionOutput; overload;
    function Clone : TFhirPlanDefinitionActionOutput; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A human-readable label for the data requirement used to label data flows in BPMN or similar diagrams. Also provides a human readable label when rendering the data requirement that conveys its purpose to human readers.
    property title : String read GetTitleST write SetTitleST;
    // A human-readable label for the data requirement used to label data flows in BPMN or similar diagrams. Also provides a human readable label when rendering the data requirement that conveys its purpose to human readers.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to Defines the data that results as output from the action. (defined for API consistency)
    property requirement : TFhirDataRequirement read FRequirement write SetRequirement;
    // Defines the data that results as output from the action.
    property requirementElement : TFhirDataRequirement read FRequirement write SetRequirement;

    // Typed access to Points to an existing input or output element that is results as output from the action.
    property relatedData : String read GetRelatedDataST write SetRelatedDataST;
    // Points to an existing input or output element that is results as output from the action.
    property relatedDataElement : TFhirString read FRelatedData write SetRelatedData;

  end;

  TFhirPlanDefinitionActionOutputListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionActionOutputList;
    function GetCurrent : TFhirPlanDefinitionActionOutput;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionActionOutputList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinitionActionOutput read GetCurrent;
  end;

  TFhirPlanDefinitionActionOutputList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPlanDefinitionActionOutput;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinitionActionOutput);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPlanDefinitionActionOutputList; overload;
    function Clone : TFhirPlanDefinitionActionOutputList; overload;
    function GetEnumerator : TFhirPlanDefinitionActionOutputListEnumerator;
    
    //  Add a FhirPlanDefinitionActionOutput to the end of the list.
    function Append : TFhirPlanDefinitionActionOutput;
    
    // Add an already existing FhirPlanDefinitionActionOutput to the end of the list.
    function AddItem(value : TFhirPlanDefinitionActionOutput) : TFhirPlanDefinitionActionOutput; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinitionActionOutput) : Integer;
    
    // Insert FhirPlanDefinitionActionOutput before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinitionActionOutput;
    
    // Insert an existing FhirPlanDefinitionActionOutput before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinitionActionOutput);
    
    // Get the iIndexth FhirPlanDefinitionActionOutput. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinitionActionOutput);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinitionActionOutput;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPlanDefinitionActionOutputs[index : Integer] : TFhirPlanDefinitionActionOutput read GetItemN write SetItemN; default;
  End;

  // A relationship to another action such as "before" or "30-60 minutes after start of".
  TFhirPlanDefinitionActionRelatedAction = class (TFhirBackboneElement)
  protected
    FTargetId : TFhirId;
    FRelationship : TFhirEnum;
    FOffset : TFhirDataType;
    procedure SetTargetId(value : TFhirId);
    function GetTargetIdST : String;
    procedure SetTargetIdST(value : String);
    procedure SetRelationship(value : TFhirEnum);
    function GetRelationshipST : TFhirActionRelationshipTypeEnum;
    procedure SetRelationshipST(value : TFhirActionRelationshipTypeEnum);
    procedure SetOffset(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinitionActionRelatedAction; overload;
    function Clone : TFhirPlanDefinitionActionRelatedAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The element id of the target related action.
    property targetId : String read GetTargetIdST write SetTargetIdST;
    // The element id of the target related action.
    property targetIdElement : TFhirId read FTargetId write SetTargetId;

    // The relationship of this action to the related action.
    property relationship : TFhirActionRelationshipTypeEnum read GetRelationshipST write SetRelationshipST;
    property relationshipElement : TFhirEnum read FRelationship write SetRelationship;

    // Typed access to A duration or range of durations to apply to the relationship. For example, 30-60 minutes before. (defined for API consistency)
    property offset : TFhirDataType read FOffset write SetOffset;
    // A duration or range of durations to apply to the relationship. For example, 30-60 minutes before.
    property offsetElement : TFhirDataType read FOffset write SetOffset;

  end;

  TFhirPlanDefinitionActionRelatedActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionActionRelatedActionList;
    function GetCurrent : TFhirPlanDefinitionActionRelatedAction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionActionRelatedActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinitionActionRelatedAction read GetCurrent;
  end;

  TFhirPlanDefinitionActionRelatedActionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPlanDefinitionActionRelatedAction;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinitionActionRelatedAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPlanDefinitionActionRelatedActionList; overload;
    function Clone : TFhirPlanDefinitionActionRelatedActionList; overload;
    function GetEnumerator : TFhirPlanDefinitionActionRelatedActionListEnumerator;
    
    //  Add a FhirPlanDefinitionActionRelatedAction to the end of the list.
    function Append : TFhirPlanDefinitionActionRelatedAction;
    
    // Add an already existing FhirPlanDefinitionActionRelatedAction to the end of the list.
    function AddItem(value : TFhirPlanDefinitionActionRelatedAction) : TFhirPlanDefinitionActionRelatedAction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinitionActionRelatedAction) : Integer;
    
    // Insert FhirPlanDefinitionActionRelatedAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinitionActionRelatedAction;
    
    // Insert an existing FhirPlanDefinitionActionRelatedAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinitionActionRelatedAction);
    
    // Get the iIndexth FhirPlanDefinitionActionRelatedAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinitionActionRelatedAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinitionActionRelatedAction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPlanDefinitionActionRelatedActions[index : Integer] : TFhirPlanDefinitionActionRelatedAction read GetItemN write SetItemN; default;
  End;

  // Indicates who should participate in performing the action described.
  TFhirPlanDefinitionActionParticipant = class (TFhirBackboneElement)
  protected
    FActorId : TFhirString;
    FType_ : TFhirEnum;
    FTypeCanonical : TFhirCanonical;
    FTypeReference : TFhirReference;
    FRole : TFhirCodeableConcept;
    FFunction_ : TFhirCodeableConcept;
    procedure SetActorId(value : TFhirString);
    function GetActorIdST : String;
    procedure SetActorIdST(value : String);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirActionParticipantTypeEnum;
    procedure SetType_ST(value : TFhirActionParticipantTypeEnum);
    procedure SetTypeCanonical(value : TFhirCanonical);
    function GetTypeCanonicalST : String;
    procedure SetTypeCanonicalST(value : String);
    procedure SetTypeReference(value : TFhirReference);
    procedure SetRole(value : TFhirCodeableConcept);
    procedure SetFunction_(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinitionActionParticipant; overload;
    function Clone : TFhirPlanDefinitionActionParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A reference to the id element of the actor who will participate in this action.
    property actorId : String read GetActorIdST write SetActorIdST;
    // A reference to the id element of the actor who will participate in this action.
    property actorIdElement : TFhirString read FActorId write SetActorId;

    // The type of participant in the action.
    property type_ : TFhirActionParticipantTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The type of participant in the action.
    property typeCanonical : String read GetTypeCanonicalST write SetTypeCanonicalST;
    // The type of participant in the action.
    property typeCanonicalElement : TFhirCanonical read FTypeCanonical write SetTypeCanonical;

    // Typed access to The type of participant in the action. (defined for API consistency)
    property typeReference : TFhirReference read FTypeReference write SetTypeReference;
    // The type of participant in the action.
    property typeReferenceElement : TFhirReference read FTypeReference write SetTypeReference;

    // Typed access to The role the participant should play in performing the described action. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // The role the participant should play in performing the described action.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to Indicates how the actor will be involved in the action - author, reviewer, witness, etc. (defined for API consistency)
    property function_ : TFhirCodeableConcept read FFunction_ write SetFunction_;
    // Indicates how the actor will be involved in the action - author, reviewer, witness, etc.
    property function_Element : TFhirCodeableConcept read FFunction_ write SetFunction_;

  end;

  TFhirPlanDefinitionActionParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionActionParticipantList;
    function GetCurrent : TFhirPlanDefinitionActionParticipant;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionActionParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinitionActionParticipant read GetCurrent;
  end;

  TFhirPlanDefinitionActionParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPlanDefinitionActionParticipant;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinitionActionParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPlanDefinitionActionParticipantList; overload;
    function Clone : TFhirPlanDefinitionActionParticipantList; overload;
    function GetEnumerator : TFhirPlanDefinitionActionParticipantListEnumerator;
    
    //  Add a FhirPlanDefinitionActionParticipant to the end of the list.
    function Append : TFhirPlanDefinitionActionParticipant;
    
    // Add an already existing FhirPlanDefinitionActionParticipant to the end of the list.
    function AddItem(value : TFhirPlanDefinitionActionParticipant) : TFhirPlanDefinitionActionParticipant; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinitionActionParticipant) : Integer;
    
    // Insert FhirPlanDefinitionActionParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinitionActionParticipant;
    
    // Insert an existing FhirPlanDefinitionActionParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinitionActionParticipant);
    
    // Get the iIndexth FhirPlanDefinitionActionParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinitionActionParticipant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinitionActionParticipant;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPlanDefinitionActionParticipants[index : Integer] : TFhirPlanDefinitionActionParticipant read GetItemN write SetItemN; default;
  End;

  // Customizations that should be applied to the statically defined resource. For example, if the dosage of a medication must be computed based on the patient's weight, a customization would be used to specify an expression that calculated the weight, and the path on the resource that would contain the result.
  TFhirPlanDefinitionActionDynamicValue = class (TFhirBackboneElement)
  protected
    FPath : TFhirString;
    FExpression : TFhirExpression;
    procedure SetPath(value : TFhirString);
    function GetPathST : String;
    procedure SetPathST(value : String);
    procedure SetExpression(value : TFhirExpression);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinitionActionDynamicValue; overload;
    function Clone : TFhirPlanDefinitionActionDynamicValue; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The path to the element to be customized. This is the path on the resource that will hold the result of the calculation defined by the expression. The specified path SHALL be a FHIRPath resolveable on the specified target type of the ActivityDefinition, and SHALL consist only of identifiers, constant indexers, and a restricted subset of functions. The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](fhirpath.html#simple) for full details).
    property path : String read GetPathST write SetPathST;
    // The path to the element to be customized. This is the path on the resource that will hold the result of the calculation defined by the expression. The specified path SHALL be a FHIRPath resolveable on the specified target type of the ActivityDefinition, and SHALL consist only of identifiers, constant indexers, and a restricted subset of functions. The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](fhirpath.html#simple) for full details).
    property pathElement : TFhirString read FPath write SetPath;

    // Typed access to An expression specifying the value of the customized element. (defined for API consistency)
    property expression : TFhirExpression read FExpression write SetExpression;
    // An expression specifying the value of the customized element.
    property expressionElement : TFhirExpression read FExpression write SetExpression;

  end;

  TFhirPlanDefinitionActionDynamicValueListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionActionDynamicValueList;
    function GetCurrent : TFhirPlanDefinitionActionDynamicValue;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionActionDynamicValueList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinitionActionDynamicValue read GetCurrent;
  end;

  TFhirPlanDefinitionActionDynamicValueList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPlanDefinitionActionDynamicValue;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinitionActionDynamicValue);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPlanDefinitionActionDynamicValueList; overload;
    function Clone : TFhirPlanDefinitionActionDynamicValueList; overload;
    function GetEnumerator : TFhirPlanDefinitionActionDynamicValueListEnumerator;
    
    //  Add a FhirPlanDefinitionActionDynamicValue to the end of the list.
    function Append : TFhirPlanDefinitionActionDynamicValue;
    
    // Add an already existing FhirPlanDefinitionActionDynamicValue to the end of the list.
    function AddItem(value : TFhirPlanDefinitionActionDynamicValue) : TFhirPlanDefinitionActionDynamicValue; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinitionActionDynamicValue) : Integer;
    
    // Insert FhirPlanDefinitionActionDynamicValue before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinitionActionDynamicValue;
    
    // Insert an existing FhirPlanDefinitionActionDynamicValue before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinitionActionDynamicValue);
    
    // Get the iIndexth FhirPlanDefinitionActionDynamicValue. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinitionActionDynamicValue);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinitionActionDynamicValue;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPlanDefinitionActionDynamicValues[index : Integer] : TFhirPlanDefinitionActionDynamicValue read GetItemN write SetItemN; default;
  End;

  // This resource allows for the definition of various types of plans as a sharable, consumable, and executable artifact. The resource is general enough to support the description of a broad range of clinical and non-clinical artifacts such as clinical decision support rules, order sets, protocols, and drug quality specifications.
  TFhirPlanDefinition = class (TFhirMetadataResource)
  protected
    FSubtitle : TFhirString;
    FType_ : TFhirCodeableConcept;
    FSubject : TFhirDataType;
    FUsage : TFhirString;
    Flibrary_List : TFhirCanonicalList;
    FgoalList : TFhirPlanDefinitionGoalList;
    FactorList : TFhirPlanDefinitionActorList;
    FactionList : TFhirPlanDefinitionActionList;
    FAsNeeded : TFhirDataType;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetSubtitle(value : TFhirString);
    function GetSubtitleST : String;
    procedure SetSubtitleST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetSubject(value : TFhirDataType);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetUsage(value : TFhirString);
    function GetUsageST : String;
    procedure SetUsageST(value : String);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    procedure SetApprovalDate(value : TFhirDate);
    function GetApprovalDateST : TFslDateTime;
    procedure SetApprovalDateST(value : TFslDateTime);
    procedure SetLastReviewDate(value : TFhirDate);
    function GetLastReviewDateST : TFslDateTime;
    procedure SetLastReviewDateST(value : TFslDateTime);
    procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetTopicList : TFhirCodeableConceptList;
    function GetHasTopicList : Boolean;
    function GetAuthorList : TFhirContactDetailList;
    function GetHasAuthorList : Boolean;
    function GetEditorList : TFhirContactDetailList;
    function GetHasEditorList : Boolean;
    function GetReviewerList : TFhirContactDetailList;
    function GetHasReviewerList : Boolean;
    function GetEndorserList : TFhirContactDetailList;
    function GetHasEndorserList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    function GetLibrary_List : TFhirCanonicalList;
    function GetHasLibrary_List : Boolean;
    function GetGoalList : TFhirPlanDefinitionGoalList;
    function GetHasGoalList : Boolean;
    function GetActorList : TFhirPlanDefinitionActorList;
    function GetHasActorList : Boolean;
    function GetActionList : TFhirPlanDefinitionActionList;
    function GetHasActionList : Boolean;
    procedure SetAsNeeded(value : TFhirDataType);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinition; overload;
    function Clone : TFhirPlanDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this plan definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which an authoritative instance of this plan definition is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the plan definition is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this plan definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which an authoritative instance of this plan definition is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the plan definition is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this plan definition when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the plan definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the plan definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the plan definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the plan definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the plan definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the plan definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the plan definition.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the plan definition.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to An explanatory or alternate title for the plan definition giving additional information about its content.
    property subtitle : String read GetSubtitleST write SetSubtitleST;
    // An explanatory or alternate title for the plan definition giving additional information about its content.
    property subtitleElement : TFhirString read FSubtitle write SetSubtitle;

    // Typed access to A high-level category for the plan definition that distinguishes the kinds of systems that would be interested in the plan definition. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A high-level category for the plan definition that distinguishes the kinds of systems that would be interested in the plan definition.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // The status of this plan definition. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this plan definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this plan definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to A code, group definition, or canonical reference that describes  or identifies the intended subject of the plan definition. Canonical references are allowed to support the definition of protocols for drug and substance quality specifications, and is allowed to reference a MedicinalProductDefinition, SubstanceDefinition, AdministrableProductDefinition, ManufacturedItemDefinition, or PackagedProductDefinition resource. (defined for API consistency)
    property subject : TFhirDataType read FSubject write SetSubject;
    // A code, group definition, or canonical reference that describes  or identifies the intended subject of the plan definition. Canonical references are allowed to support the definition of protocols for drug and substance quality specifications, and is allowed to reference a MedicinalProductDefinition, SubstanceDefinition, AdministrableProductDefinition, ManufacturedItemDefinition, or PackagedProductDefinition resource.
    property subjectElement : TFhirDataType read FSubject write SetSubject;

    // Typed access to The date  (and optionally time) when the plan definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the plan definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the plan definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the plan definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual responsible for the release and ongoing maintenance of the plan definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual responsible for the release and ongoing maintenance of the plan definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the plan definition from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the plan definition from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate plan definition instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the plan definition is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explanation of why this plan definition is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this plan definition is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A detailed description of how the plan definition is used from a clinical perspective.
    property usage : String read GetUsageST write SetUsageST;
    // A detailed description of how the plan definition is used from a clinical perspective.
    property usageElement : TFhirString read FUsage write SetUsage;

    // Typed access to A copyright statement relating to the plan definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the plan definition.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the plan definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the plan definition.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the plan definition content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the plan definition content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // Descriptive topics related to the content of the plan definition. Topics provide a high-level categorization of the definition that can be useful for filtering and searching.
    property topicList : TFhirCodeableConceptList read GetTopicList;
    property hasTopicList : boolean read GetHasTopicList;

    // An individiual or organization primarily involved in the creation and maintenance of the content.
    property authorList : TFhirContactDetailList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // An individual or organization primarily responsible for internal coherence of the content.
    property editorList : TFhirContactDetailList read GetEditorList;
    property hasEditorList : boolean read GetHasEditorList;

    // An individual or organization primarily responsible for review of some aspect of the content.
    property reviewerList : TFhirContactDetailList read GetReviewerList;
    property hasReviewerList : boolean read GetHasReviewerList;

    // An individual or organization responsible for officially endorsing the content for use in some setting.
    property endorserList : TFhirContactDetailList read GetEndorserList;
    property hasEndorserList : boolean read GetHasEndorserList;

    // Related artifacts such as additional documentation, justification, or bibliographic references.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // A reference to a Library resource containing any formal logic used by the plan definition.
    property library_List : TFhirCanonicalList read GetLibrary_List;
    property hasLibrary_List : boolean read GetHasLibrary_List;

    // A goal describes an expected outcome that activities within the plan are intended to achieve. For example, weight loss, restoring an activity of daily living, obtaining herd immunity via immunization, meeting a process improvement objective, meeting the acceptance criteria for a test as specified by a quality specification, etc.
    property goalList : TFhirPlanDefinitionGoalList read GetGoalList;
    property hasGoalList : boolean read GetHasGoalList;

    // Actors represent the individuals or groups involved in the execution of the defined set of activities.
    property actorList : TFhirPlanDefinitionActorList read GetActorList;
    property hasActorList : boolean read GetHasActorList;

    // An action or group of actions to be taken as part of the plan. For example, in clinical care, an action would be to prescribe a particular indicated medication, or perform a particular test as appropriate. In pharmaceutical quality, an action would be the test that needs to be performed on a drug product as defined in the quality specification.
    property actionList : TFhirPlanDefinitionActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

    // Typed access to If a CodeableConcept is present, it indicates the pre-condition for performing the service.  For example "pain", "on flare-up", etc. (defined for API consistency)
    property asNeeded : TFhirDataType read FAsNeeded write SetAsNeeded;
    // If a CodeableConcept is present, it indicates the pre-condition for performing the service.  For example "pain", "on flare-up", etc.
    property asNeededElement : TFhirDataType read FAsNeeded write SetAsNeeded;

  end;

  TFhirPlanDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionList;
    function GetCurrent : TFhirPlanDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinition read GetCurrent;
  end;

  TFhirPlanDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPlanDefinition;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPlanDefinitionList; overload;
    function Clone : TFhirPlanDefinitionList; overload;
    function GetEnumerator : TFhirPlanDefinitionListEnumerator;
    
    //  Add a FhirPlanDefinition to the end of the list.
    function Append : TFhirPlanDefinition;
    
    // Add an already existing FhirPlanDefinition to the end of the list.
    function AddItem(value : TFhirPlanDefinition) : TFhirPlanDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinition) : Integer;
    
    // Insert FhirPlanDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinition;
    
    // Insert an existing FhirPlanDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinition);
    
    // Get the iIndexth FhirPlanDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPlanDefinitions[index : Integer] : TFhirPlanDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PROVENANCE}
  // An actor taking a role in an activity  for which it can be assigned some degree of responsibility for the activity taking place.
  TFhirProvenanceAgent = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FroleList : TFhirCodeableConceptList;
    FWho : TFhirReference;
    FOnBehalfOf : TFhirReference;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetRoleList : TFhirCodeableConceptList;
    function GetHasRoleList : Boolean;
    procedure SetWho(value : TFhirReference);
    procedure SetOnBehalfOf(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProvenanceAgent; overload;
    function Clone : TFhirProvenanceAgent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The Functional Role of the agent with respect to the activity. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The Functional Role of the agent with respect to the activity.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // The structural roles of the agent indicating the agent's competency. The security role enabling the agent with respect to the activity.
    property roleList : TFhirCodeableConceptList read GetRoleList;
    property hasRoleList : boolean read GetHasRoleList;

    // Typed access to Indicates who or what performed in the event. (defined for API consistency)
    property who : TFhirReference read FWho write SetWho;
    // Indicates who or what performed in the event.
    property whoElement : TFhirReference read FWho write SetWho;

    // Typed access to The agent that delegated authority to perform the activity performed by the agent.who element. (defined for API consistency)
    property onBehalfOf : TFhirReference read FOnBehalfOf write SetOnBehalfOf;
    // The agent that delegated authority to perform the activity performed by the agent.who element.
    property onBehalfOfElement : TFhirReference read FOnBehalfOf write SetOnBehalfOf;

  end;

  TFhirProvenanceAgentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProvenanceAgentList;
    function GetCurrent : TFhirProvenanceAgent;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirProvenanceAgentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProvenanceAgent read GetCurrent;
  end;

  TFhirProvenanceAgentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProvenanceAgent;
    procedure SetItemN(index : Integer; value : TFhirProvenanceAgent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirProvenanceAgentList; overload;
    function Clone : TFhirProvenanceAgentList; overload;
    function GetEnumerator : TFhirProvenanceAgentListEnumerator;
    
    //  Add a FhirProvenanceAgent to the end of the list.
    function Append : TFhirProvenanceAgent;
    
    // Add an already existing FhirProvenanceAgent to the end of the list.
    function AddItem(value : TFhirProvenanceAgent) : TFhirProvenanceAgent; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProvenanceAgent) : Integer;
    
    // Insert FhirProvenanceAgent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProvenanceAgent;
    
    // Insert an existing FhirProvenanceAgent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProvenanceAgent);
    
    // Get the iIndexth FhirProvenanceAgent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProvenanceAgent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirProvenanceAgent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirProvenanceAgents[index : Integer] : TFhirProvenanceAgent read GetItemN write SetItemN; default;
  End;

  // An entity used in this activity.
  TFhirProvenanceEntity = class (TFhirBackboneElement)
  protected
    FRole : TFhirEnum;
    FWhat : TFhirReference;
    FagentList : TFhirProvenanceAgentList;
    procedure SetRole(value : TFhirEnum);
    function GetRoleST : TFhirProvenanceEntityRoleEnum;
    procedure SetRoleST(value : TFhirProvenanceEntityRoleEnum);
    procedure SetWhat(value : TFhirReference);
    function GetAgentList : TFhirProvenanceAgentList;
    function GetHasAgentList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProvenanceEntity; overload;
    function Clone : TFhirProvenanceEntity; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // How the entity was used during the activity.
    property role : TFhirProvenanceEntityRoleEnum read GetRoleST write SetRoleST;
    property roleElement : TFhirEnum read FRole write SetRole;

    // Typed access to Identity of the  Entity used. May be a logical or physical uri and maybe absolute or relative. (defined for API consistency)
    property what : TFhirReference read FWhat write SetWhat;
    // Identity of the  Entity used. May be a logical or physical uri and maybe absolute or relative.
    property whatElement : TFhirReference read FWhat write SetWhat;

    // The entity is attributed to an agent to express the agent's responsibility for that entity, possibly along with other agents. This description can be understood as shorthand for saying that the agent was responsible for the activity which used the entity.
    property agentList : TFhirProvenanceAgentList read GetAgentList;
    property hasAgentList : boolean read GetHasAgentList;

  end;

  TFhirProvenanceEntityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProvenanceEntityList;
    function GetCurrent : TFhirProvenanceEntity;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirProvenanceEntityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProvenanceEntity read GetCurrent;
  end;

  TFhirProvenanceEntityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProvenanceEntity;
    procedure SetItemN(index : Integer; value : TFhirProvenanceEntity);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirProvenanceEntityList; overload;
    function Clone : TFhirProvenanceEntityList; overload;
    function GetEnumerator : TFhirProvenanceEntityListEnumerator;
    
    //  Add a FhirProvenanceEntity to the end of the list.
    function Append : TFhirProvenanceEntity;
    
    // Add an already existing FhirProvenanceEntity to the end of the list.
    function AddItem(value : TFhirProvenanceEntity) : TFhirProvenanceEntity; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProvenanceEntity) : Integer;
    
    // Insert FhirProvenanceEntity before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProvenanceEntity;
    
    // Insert an existing FhirProvenanceEntity before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProvenanceEntity);
    
    // Get the iIndexth FhirProvenanceEntity. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProvenanceEntity);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirProvenanceEntity;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirProvenanceEntities[index : Integer] : TFhirProvenanceEntity read GetItemN write SetItemN; default;
  End;

  // Provenance of a resource is a record that describes entities and processes involved in producing and delivering or otherwise influencing that resource. Provenance provides a critical foundation for assessing authenticity, enabling trust, and allowing reproducibility. Provenance assertions are a form of contextual metadata and can themselves become important records with their own provenance. Provenance statement indicates clinical significance in terms of confidence in authenticity, reliability, and trustworthiness, integrity, and stage in lifecycle (e.g. Document Completion - has the artifact been legally authenticated), all of which may impact security, privacy, and trust policies.
  TFhirProvenance = class (TFhirDomainResource)
  protected
    FtargetList : TFhirReferenceList;
    FOccurred : TFhirDataType;
    FRecorded : TFhirInstant;
    FpolicyList : TFhirUriList;
    FLocation : TFhirReference;
    FauthorizationList : TFhirCodeableReferenceList;
    FActivity : TFhirCodeableConcept;
    FbasedOnList : TFhirReferenceList;
    FPatient : TFhirReference;
    FEncounter : TFhirReference;
    FagentList : TFhirProvenanceAgentList;
    FentityList : TFhirProvenanceEntityList;
    FsignatureList : TFhirSignatureList;
    function GetTargetList : TFhirReferenceList;
    function GetHasTargetList : Boolean;
    procedure SetOccurred(value : TFhirDataType);
    procedure SetRecorded(value : TFhirInstant);
    function GetRecordedST : TFslDateTime;
    procedure SetRecordedST(value : TFslDateTime);
    function GetPolicyList : TFhirUriList;
    function GetHasPolicyList : Boolean;
    procedure SetLocation(value : TFhirReference);
    function GetAuthorizationList : TFhirCodeableReferenceList;
    function GetHasAuthorizationList : Boolean;
    procedure SetActivity(value : TFhirCodeableConcept);
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    procedure SetPatient(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    function GetAgentList : TFhirProvenanceAgentList;
    function GetHasAgentList : Boolean;
    function GetEntityList : TFhirProvenanceEntityList;
    function GetHasEntityList : Boolean;
    function GetSignatureList : TFhirSignatureList;
    function GetHasSignatureList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProvenance; overload;
    function Clone : TFhirProvenance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The Reference(s) that were generated or updated by  the activity described in this resource. A provenance can point to more than one target if multiple resources were created/updated by the same activity.
    property targetList : TFhirReferenceList read GetTargetList;
    property hasTargetList : boolean read GetHasTargetList;

    // Typed access to The period during which the activity occurred. (defined for API consistency)
    property occurred : TFhirDataType read FOccurred write SetOccurred;
    // The period during which the activity occurred.
    property occurredElement : TFhirDataType read FOccurred write SetOccurred;

    // Typed access to The instant of time at which the activity was recorded.
    property recorded : TFslDateTime read GetRecordedST write SetRecordedST;
    // The instant of time at which the activity was recorded.
    property recordedElement : TFhirInstant read FRecorded write SetRecorded;

    // Policy or plan the activity was defined by. Typically, a single activity may have multiple applicable policy documents, such as patient consent, guarantor funding, etc.
    property policyList : TFhirUriList read GetPolicyList;
    property hasPolicyList : boolean read GetHasPolicyList;

    // Typed access to Where the activity occurred, if relevant. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // Where the activity occurred, if relevant.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // The authorization (e.g., PurposeOfUse) that was used during the event being recorded.
    property authorizationList : TFhirCodeableReferenceList read GetAuthorizationList;
    property hasAuthorizationList : boolean read GetHasAuthorizationList;

    // Typed access to An activity is something that occurs over a period of time and acts upon or with entities; it may include consuming, processing, transforming, modifying, relocating, using, or generating entities. (defined for API consistency)
    property activity : TFhirCodeableConcept read FActivity write SetActivity;
    // An activity is something that occurs over a period of time and acts upon or with entities; it may include consuming, processing, transforming, modifying, relocating, using, or generating entities.
    property activityElement : TFhirCodeableConcept read FActivity write SetActivity;

    // Allows tracing of authorizatino for the events and tracking whether proposals/recommendations were acted upon.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Typed access to The patient element is available to enable deterministic tracking of activities that involve the patient as the subject of the data used in an activity. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The patient element is available to enable deterministic tracking of activities that involve the patient as the subject of the data used in an activity.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to This will typically be the encounter the event occurred, but some events may be initiated prior to or after the official completion of an encounter but still be tied to the context of the encounter (e.g. pre-admission lab tests). (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // This will typically be the encounter the event occurred, but some events may be initiated prior to or after the official completion of an encounter but still be tied to the context of the encounter (e.g. pre-admission lab tests).
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // An actor taking a role in an activity  for which it can be assigned some degree of responsibility for the activity taking place.
    property agentList : TFhirProvenanceAgentList read GetAgentList;
    property hasAgentList : boolean read GetHasAgentList;

    // An entity used in this activity.
    property entityList : TFhirProvenanceEntityList read GetEntityList;
    property hasEntityList : boolean read GetHasEntityList;

    // A digital signature on the target Reference(s). The signer should match a Provenance.agent. The purpose of the signature is indicated.
    property signatureList : TFhirSignatureList read GetSignatureList;
    property hasSignatureList : boolean read GetHasSignatureList;

  end;

  TFhirProvenanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProvenanceList;
    function GetCurrent : TFhirProvenance;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirProvenanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProvenance read GetCurrent;
  end;

  TFhirProvenanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProvenance;
    procedure SetItemN(index : Integer; value : TFhirProvenance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirProvenanceList; overload;
    function Clone : TFhirProvenanceList; overload;
    function GetEnumerator : TFhirProvenanceListEnumerator;
    
    //  Add a FhirProvenance to the end of the list.
    function Append : TFhirProvenance;
    
    // Add an already existing FhirProvenance to the end of the list.
    function AddItem(value : TFhirProvenance) : TFhirProvenance; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProvenance) : Integer;
    
    // Insert FhirProvenance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProvenance;
    
    // Insert an existing FhirProvenance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProvenance);
    
    // Get the iIndexth FhirProvenance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProvenance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirProvenance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirProvenances[index : Integer] : TFhirProvenance read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  // A group or question item from the original questionnaire for which answers are provided.
  TFhirQuestionnaireResponseItem = class (TFhirBackboneElement)
  protected
    FLinkId : TFhirString;
    FDefinition : TFhirUri;
    FText : TFhirString;
    FanswerList : TFhirQuestionnaireResponseItemAnswerList;
    FitemList : TFhirQuestionnaireResponseItemList;
    procedure SetLinkId(value : TFhirString);
    function GetLinkIdST : String;
    procedure SetLinkIdST(value : String);
    procedure SetDefinition(value : TFhirUri);
    function GetDefinitionST : String;
    procedure SetDefinitionST(value : String);
    procedure SetText(value : TFhirString);
    function GetTextST : String;
    procedure SetTextST(value : String);
    function GetAnswerList : TFhirQuestionnaireResponseItemAnswerList;
    function GetHasAnswerList : Boolean;
    function GetItemList : TFhirQuestionnaireResponseItemList;
    function GetHasItemList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuestionnaireResponseItem; overload;
    function Clone : TFhirQuestionnaireResponseItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The item from the Questionnaire that corresponds to this item in the QuestionnaireResponse resource.
    property linkId : String read GetLinkIdST write SetLinkIdST;
    // The item from the Questionnaire that corresponds to this item in the QuestionnaireResponse resource.
    property linkIdElement : TFhirString read FLinkId write SetLinkId;

    // Typed access to A reference to an [ElementDefinition](elementdefinition.html) that provides the details for the item.
    property definition : String read GetDefinitionST write SetDefinitionST;
    // A reference to an [ElementDefinition](elementdefinition.html) that provides the details for the item.
    property definitionElement : TFhirUri read FDefinition write SetDefinition;

    // Typed access to Text that is displayed above the contents of the group or as the text of the question being answered.
    property text : String read GetTextST write SetTextST;
    // Text that is displayed above the contents of the group or as the text of the question being answered.
    property textElement : TFhirString read FText write SetText;

    // The respondent's answer(s) to the question.
    property answerList : TFhirQuestionnaireResponseItemAnswerList read GetAnswerList;
    property hasAnswerList : boolean read GetHasAnswerList;

    // Sub-questions, sub-groups or display items nested beneath a group.
    property itemList : TFhirQuestionnaireResponseItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirQuestionnaireResponseItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireResponseItemList;
    function GetCurrent : TFhirQuestionnaireResponseItem;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirQuestionnaireResponseItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaireResponseItem read GetCurrent;
  end;

  TFhirQuestionnaireResponseItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirQuestionnaireResponseItem;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireResponseItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirQuestionnaireResponseItemList; overload;
    function Clone : TFhirQuestionnaireResponseItemList; overload;
    function GetEnumerator : TFhirQuestionnaireResponseItemListEnumerator;
    
    //  Add a FhirQuestionnaireResponseItem to the end of the list.
    function Append : TFhirQuestionnaireResponseItem;
    
    // Add an already existing FhirQuestionnaireResponseItem to the end of the list.
    function AddItem(value : TFhirQuestionnaireResponseItem) : TFhirQuestionnaireResponseItem; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuestionnaireResponseItem) : Integer;
    
    // Insert FhirQuestionnaireResponseItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuestionnaireResponseItem;
    
    // Insert an existing FhirQuestionnaireResponseItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireResponseItem);
    
    // Get the iIndexth FhirQuestionnaireResponseItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireResponseItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirQuestionnaireResponseItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirQuestionnaireResponseItems[index : Integer] : TFhirQuestionnaireResponseItem read GetItemN write SetItemN; default;
  End;

  // The respondent's answer(s) to the question.
  TFhirQuestionnaireResponseItemAnswer = class (TFhirBackboneElement)
  protected
    FValue : TFhirDataType;
    FitemList : TFhirQuestionnaireResponseItemList;
    procedure SetValue(value : TFhirDataType);
    function GetItemList : TFhirQuestionnaireResponseItemList;
    function GetHasItemList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuestionnaireResponseItemAnswer; overload;
    function Clone : TFhirQuestionnaireResponseItemAnswer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The answer (or one of the answers) provided by the respondent to the question. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The answer (or one of the answers) provided by the respondent to the question.
    property valueElement : TFhirDataType read FValue write SetValue;

    // Nested groups and/or questions found within this particular answer.
    property itemList : TFhirQuestionnaireResponseItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirQuestionnaireResponseItemAnswerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireResponseItemAnswerList;
    function GetCurrent : TFhirQuestionnaireResponseItemAnswer;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirQuestionnaireResponseItemAnswerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaireResponseItemAnswer read GetCurrent;
  end;

  TFhirQuestionnaireResponseItemAnswerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirQuestionnaireResponseItemAnswer;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireResponseItemAnswer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirQuestionnaireResponseItemAnswerList; overload;
    function Clone : TFhirQuestionnaireResponseItemAnswerList; overload;
    function GetEnumerator : TFhirQuestionnaireResponseItemAnswerListEnumerator;
    
    //  Add a FhirQuestionnaireResponseItemAnswer to the end of the list.
    function Append : TFhirQuestionnaireResponseItemAnswer;
    
    // Add an already existing FhirQuestionnaireResponseItemAnswer to the end of the list.
    function AddItem(value : TFhirQuestionnaireResponseItemAnswer) : TFhirQuestionnaireResponseItemAnswer; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuestionnaireResponseItemAnswer) : Integer;
    
    // Insert FhirQuestionnaireResponseItemAnswer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuestionnaireResponseItemAnswer;
    
    // Insert an existing FhirQuestionnaireResponseItemAnswer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireResponseItemAnswer);
    
    // Get the iIndexth FhirQuestionnaireResponseItemAnswer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireResponseItemAnswer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirQuestionnaireResponseItemAnswer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirQuestionnaireResponseItemAnswers[index : Integer] : TFhirQuestionnaireResponseItemAnswer read GetItemN write SetItemN; default;
  End;

  // A structured set of questions and their answers. The questions are ordered and grouped into coherent subsets, corresponding to the structure of the grouping of the questionnaire being responded to.
  TFhirQuestionnaireResponse = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FbasedOnList : TFhirReferenceList;
    FpartOfList : TFhirReferenceList;
    FQuestionnaire : TFhirCanonical;
    FStatus : TFhirEnum;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FAuthored : TFhirDateTime;
    FAuthor : TFhirReference;
    FSource : TFhirReference;
    FitemList : TFhirQuestionnaireResponseItemList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    procedure SetQuestionnaire(value : TFhirCanonical);
    function GetQuestionnaireST : String;
    procedure SetQuestionnaireST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirQuestionnaireResponseStatusEnum;
    procedure SetStatusST(value : TFhirQuestionnaireResponseStatusEnum);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetAuthored(value : TFhirDateTime);
    function GetAuthoredST : TFslDateTime;
    procedure SetAuthoredST(value : TFslDateTime);
    procedure SetAuthor(value : TFhirReference);
    procedure SetSource(value : TFhirReference);
    function GetItemList : TFhirQuestionnaireResponseItemList;
    function GetHasItemList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuestionnaireResponse; overload;
    function Clone : TFhirQuestionnaireResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A business identifier assigned to a particular completed (or partially completed) questionnaire.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The order, proposal or plan that is fulfilled in whole or in part by this QuestionnaireResponse.  For example, a ServiceRequest seeking an intake assessment or a decision support recommendation to assess for post-partum depression.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // A procedure or observation that this questionnaire was performed as part of the execution of.  For example, the surgery a checklist was executed as part of.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // Typed access to The Questionnaire that defines and organizes the questions for which answers are being provided.
    property questionnaire : String read GetQuestionnaireST write SetQuestionnaireST;
    // The Questionnaire that defines and organizes the questions for which answers are being provided.
    property questionnaireElement : TFhirCanonical read FQuestionnaire write SetQuestionnaire;

    // The position of the questionnaire response within its overall lifecycle.
    property status : TFhirQuestionnaireResponseStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The subject of the questionnaire response.  This could be a patient, organization, practitioner, device, etc.  This is who/what the answers apply to, but is not necessarily the source of information. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The subject of the questionnaire response.  This could be a patient, organization, practitioner, device, etc.  This is who/what the answers apply to, but is not necessarily the source of information.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The Encounter during which this questionnaire response was created or to which the creation of this record is tightly associated. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The Encounter during which this questionnaire response was created or to which the creation of this record is tightly associated.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The date and/or time that this questionnaire response was last modified by the user - e.g. changing answers or revising status.
    property authored : TFslDateTime read GetAuthoredST write SetAuthoredST;
    // The date and/or time that this questionnaire response was last modified by the user - e.g. changing answers or revising status.
    property authoredElement : TFhirDateTime read FAuthored write SetAuthored;

    // Typed access to The individual or device that received the answers to the questions in the QuestionnaireResponse and recorded them in the system. (defined for API consistency)
    property author : TFhirReference read FAuthor write SetAuthor;
    // The individual or device that received the answers to the questions in the QuestionnaireResponse and recorded them in the system.
    property authorElement : TFhirReference read FAuthor write SetAuthor;

    // Typed access to The individual or device that answered the questions about the subject. (defined for API consistency)
    property source : TFhirReference read FSource write SetSource;
    // The individual or device that answered the questions about the subject.
    property sourceElement : TFhirReference read FSource write SetSource;

    // A group or question item from the original questionnaire for which answers are provided.
    property itemList : TFhirQuestionnaireResponseItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirQuestionnaireResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireResponseList;
    function GetCurrent : TFhirQuestionnaireResponse;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirQuestionnaireResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaireResponse read GetCurrent;
  end;

  TFhirQuestionnaireResponseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirQuestionnaireResponse;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirQuestionnaireResponseList; overload;
    function Clone : TFhirQuestionnaireResponseList; overload;
    function GetEnumerator : TFhirQuestionnaireResponseListEnumerator;
    
    //  Add a FhirQuestionnaireResponse to the end of the list.
    function Append : TFhirQuestionnaireResponse;
    
    // Add an already existing FhirQuestionnaireResponse to the end of the list.
    function AddItem(value : TFhirQuestionnaireResponse) : TFhirQuestionnaireResponse; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuestionnaireResponse) : Integer;
    
    // Insert FhirQuestionnaireResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuestionnaireResponse;
    
    // Insert an existing FhirQuestionnaireResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireResponse);
    
    // Get the iIndexth FhirQuestionnaireResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireResponse);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirQuestionnaireResponse;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirQuestionnaireResponses[index : Integer] : TFhirQuestionnaireResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REQUESTGROUP}
  // The actions, if any, produced by the evaluation of the artifact.
  TFhirRequestGroupAction = class (TFhirBackboneElement)
  protected
    FLinkId : TFhirString;
    FPrefix : TFhirString;
    FTitle : TFhirString;
    FDescription : TFhirString;
    FTextEquivalent : TFhirString;
    FPriority : TFhirCode;
    FcodeList : TFhirCodeableConceptList;
    FdocumentationList : TFhirRelatedArtifactList;
    FgoalList : TFhirReferenceList;
    FconditionList : TFhirRequestGroupActionConditionList;
    FrelatedActionList : TFhirRequestGroupActionRelatedActionList;
    FTiming : TFhirDataType;
    FLocation : TFhirCodeableReference;
    FparticipantList : TFhirRequestGroupActionParticipantList;
    FType_ : TFhirCodeableConcept;
    FGroupingBehavior : TFhirCode;
    FSelectionBehavior : TFhirCode;
    FRequiredBehavior : TFhirCode;
    FPrecheckBehavior : TFhirCode;
    FCardinalityBehavior : TFhirCode;
    FResource : TFhirReference;
    FactionList : TFhirRequestGroupActionList;
    procedure SetLinkId(value : TFhirString);
    function GetLinkIdST : String;
    procedure SetLinkIdST(value : String);
    procedure SetPrefix(value : TFhirString);
    function GetPrefixST : String;
    procedure SetPrefixST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetTextEquivalent(value : TFhirString);
    function GetTextEquivalentST : String;
    procedure SetTextEquivalentST(value : String);
    procedure SetPriority(value : TFhirCode);
    function GetPriorityST : String;
    procedure SetPriorityST(value : String);
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    function GetDocumentationList : TFhirRelatedArtifactList;
    function GetHasDocumentationList : Boolean;
    function GetGoalList : TFhirReferenceList;
    function GetHasGoalList : Boolean;
    function GetConditionList : TFhirRequestGroupActionConditionList;
    function GetHasConditionList : Boolean;
    function GetRelatedActionList : TFhirRequestGroupActionRelatedActionList;
    function GetHasRelatedActionList : Boolean;
    procedure SetTiming(value : TFhirDataType);
    procedure SetLocation(value : TFhirCodeableReference);
    function GetParticipantList : TFhirRequestGroupActionParticipantList;
    function GetHasParticipantList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetGroupingBehavior(value : TFhirCode);
    function GetGroupingBehaviorST : String;
    procedure SetGroupingBehaviorST(value : String);
    procedure SetSelectionBehavior(value : TFhirCode);
    function GetSelectionBehaviorST : String;
    procedure SetSelectionBehaviorST(value : String);
    procedure SetRequiredBehavior(value : TFhirCode);
    function GetRequiredBehaviorST : String;
    procedure SetRequiredBehaviorST(value : String);
    procedure SetPrecheckBehavior(value : TFhirCode);
    function GetPrecheckBehaviorST : String;
    procedure SetPrecheckBehaviorST(value : String);
    procedure SetCardinalityBehavior(value : TFhirCode);
    function GetCardinalityBehaviorST : String;
    procedure SetCardinalityBehaviorST(value : String);
    procedure SetResource(value : TFhirReference);
    function GetActionList : TFhirRequestGroupActionList;
    function GetHasActionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRequestGroupAction; overload;
    function Clone : TFhirRequestGroupAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The linkId of the action from the PlanDefinition that corresponds to this action in the RequestGroup resource.
    property linkId : String read GetLinkIdST write SetLinkIdST;
    // The linkId of the action from the PlanDefinition that corresponds to this action in the RequestGroup resource.
    property linkIdElement : TFhirString read FLinkId write SetLinkId;

    // Typed access to A user-visible prefix for the action. For example a section or item numbering such as 1. or A.
    property prefix : String read GetPrefixST write SetPrefixST;
    // A user-visible prefix for the action. For example a section or item numbering such as 1. or A.
    property prefixElement : TFhirString read FPrefix write SetPrefix;

    // Typed access to The title of the action displayed to a user.
    property title : String read GetTitleST write SetTitleST;
    // The title of the action displayed to a user.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to A short description of the action used to provide a summary to display to the user.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A short description of the action used to provide a summary to display to the user.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to A text equivalent of the action to be performed. This provides a human-interpretable description of the action when the definition is consumed by a system that might not be capable of interpreting it dynamically.
    property textEquivalent : String read GetTextEquivalentST write SetTextEquivalentST;
    // A text equivalent of the action to be performed. This provides a human-interpretable description of the action when the definition is consumed by a system that might not be capable of interpreting it dynamically.
    property textEquivalentElement : TFhirString read FTextEquivalent write SetTextEquivalent;

    // Typed access to Indicates how quickly the action should be addressed with respect to other actions.
    property priority : String read GetPriorityST write SetPriorityST;
    // Indicates how quickly the action should be addressed with respect to other actions.
    property priorityElement : TFhirCode read FPriority write SetPriority;

    // A code that provides meaning for the action or action group. For example, a section may have a LOINC code for a section of a documentation template.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Didactic or other informational resources associated with the action that can be provided to the CDS recipient. Information resources can include inline text commentary and links to web resources.
    property documentationList : TFhirRelatedArtifactList read GetDocumentationList;
    property hasDocumentationList : boolean read GetHasDocumentationList;

    // Goals that are intended to be achieved by following the requests in this action.
    property goalList : TFhirReferenceList read GetGoalList;
    property hasGoalList : boolean read GetHasGoalList;

    // An expression that describes applicability criteria, or start/stop conditions for the action.
    property conditionList : TFhirRequestGroupActionConditionList read GetConditionList;
    property hasConditionList : boolean read GetHasConditionList;

    // A relationship to another action such as "before" or "30-60 minutes after start of".
    property relatedActionList : TFhirRequestGroupActionRelatedActionList read GetRelatedActionList;
    property hasRelatedActionList : boolean read GetHasRelatedActionList;

    // Typed access to An optional value describing when the action should be performed. (defined for API consistency)
    property timing : TFhirDataType read FTiming write SetTiming;
    // An optional value describing when the action should be performed.
    property timingElement : TFhirDataType read FTiming write SetTiming;

    // Typed access to Identifies the facility where the action will occur; e.g. home, hospital, specific clinic, etc. (defined for API consistency)
    property location : TFhirCodeableReference read FLocation write SetLocation;
    // Identifies the facility where the action will occur; e.g. home, hospital, specific clinic, etc.
    property locationElement : TFhirCodeableReference read FLocation write SetLocation;

    // The participant that should perform or be responsible for this action.
    property participantList : TFhirRequestGroupActionParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // Typed access to The type of action to perform (create, update, remove). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of action to perform (create, update, remove).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Defines the grouping behavior for the action and its children.
    property groupingBehavior : String read GetGroupingBehaviorST write SetGroupingBehaviorST;
    // Defines the grouping behavior for the action and its children.
    property groupingBehaviorElement : TFhirCode read FGroupingBehavior write SetGroupingBehavior;

    // Typed access to Defines the selection behavior for the action and its children.
    property selectionBehavior : String read GetSelectionBehaviorST write SetSelectionBehaviorST;
    // Defines the selection behavior for the action and its children.
    property selectionBehaviorElement : TFhirCode read FSelectionBehavior write SetSelectionBehavior;

    // Typed access to Defines expectations around whether an action is required.
    property requiredBehavior : String read GetRequiredBehaviorST write SetRequiredBehaviorST;
    // Defines expectations around whether an action is required.
    property requiredBehaviorElement : TFhirCode read FRequiredBehavior write SetRequiredBehavior;

    // Typed access to Defines whether the action should usually be preselected.
    property precheckBehavior : String read GetPrecheckBehaviorST write SetPrecheckBehaviorST;
    // Defines whether the action should usually be preselected.
    property precheckBehaviorElement : TFhirCode read FPrecheckBehavior write SetPrecheckBehavior;

    // Typed access to Defines whether the action can be selected multiple times.
    property cardinalityBehavior : String read GetCardinalityBehaviorST write SetCardinalityBehaviorST;
    // Defines whether the action can be selected multiple times.
    property cardinalityBehaviorElement : TFhirCode read FCardinalityBehavior write SetCardinalityBehavior;

    // Typed access to The resource that is the target of the action (e.g. CommunicationRequest). (defined for API consistency)
    property resource : TFhirReference read FResource write SetResource;
    // The resource that is the target of the action (e.g. CommunicationRequest).
    property resourceElement : TFhirReference read FResource write SetResource;

    // Sub actions.
    property actionList : TFhirRequestGroupActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirRequestGroupActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRequestGroupActionList;
    function GetCurrent : TFhirRequestGroupAction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRequestGroupActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRequestGroupAction read GetCurrent;
  end;

  TFhirRequestGroupActionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRequestGroupAction;
    procedure SetItemN(index : Integer; value : TFhirRequestGroupAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRequestGroupActionList; overload;
    function Clone : TFhirRequestGroupActionList; overload;
    function GetEnumerator : TFhirRequestGroupActionListEnumerator;
    
    //  Add a FhirRequestGroupAction to the end of the list.
    function Append : TFhirRequestGroupAction;
    
    // Add an already existing FhirRequestGroupAction to the end of the list.
    function AddItem(value : TFhirRequestGroupAction) : TFhirRequestGroupAction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRequestGroupAction) : Integer;
    
    // Insert FhirRequestGroupAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRequestGroupAction;
    
    // Insert an existing FhirRequestGroupAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRequestGroupAction);
    
    // Get the iIndexth FhirRequestGroupAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRequestGroupAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRequestGroupAction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRequestGroupActions[index : Integer] : TFhirRequestGroupAction read GetItemN write SetItemN; default;
  End;

  // An expression that describes applicability criteria, or start/stop conditions for the action.
  TFhirRequestGroupActionCondition = class (TFhirBackboneElement)
  protected
    FKind : TFhirCode;
    FExpression : TFhirExpression;
    procedure SetKind(value : TFhirCode);
    function GetKindST : String;
    procedure SetKindST(value : String);
    procedure SetExpression(value : TFhirExpression);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRequestGroupActionCondition; overload;
    function Clone : TFhirRequestGroupActionCondition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The kind of condition.
    property kind : String read GetKindST write SetKindST;
    // The kind of condition.
    property kindElement : TFhirCode read FKind write SetKind;

    // Typed access to An expression that returns true or false, indicating whether or not the condition is satisfied. (defined for API consistency)
    property expression : TFhirExpression read FExpression write SetExpression;
    // An expression that returns true or false, indicating whether or not the condition is satisfied.
    property expressionElement : TFhirExpression read FExpression write SetExpression;

  end;

  TFhirRequestGroupActionConditionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRequestGroupActionConditionList;
    function GetCurrent : TFhirRequestGroupActionCondition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRequestGroupActionConditionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRequestGroupActionCondition read GetCurrent;
  end;

  TFhirRequestGroupActionConditionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRequestGroupActionCondition;
    procedure SetItemN(index : Integer; value : TFhirRequestGroupActionCondition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRequestGroupActionConditionList; overload;
    function Clone : TFhirRequestGroupActionConditionList; overload;
    function GetEnumerator : TFhirRequestGroupActionConditionListEnumerator;
    
    //  Add a FhirRequestGroupActionCondition to the end of the list.
    function Append : TFhirRequestGroupActionCondition;
    
    // Add an already existing FhirRequestGroupActionCondition to the end of the list.
    function AddItem(value : TFhirRequestGroupActionCondition) : TFhirRequestGroupActionCondition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRequestGroupActionCondition) : Integer;
    
    // Insert FhirRequestGroupActionCondition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRequestGroupActionCondition;
    
    // Insert an existing FhirRequestGroupActionCondition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRequestGroupActionCondition);
    
    // Get the iIndexth FhirRequestGroupActionCondition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRequestGroupActionCondition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRequestGroupActionCondition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRequestGroupActionConditions[index : Integer] : TFhirRequestGroupActionCondition read GetItemN write SetItemN; default;
  End;

  // A relationship to another action such as "before" or "30-60 minutes after start of".
  TFhirRequestGroupActionRelatedAction = class (TFhirBackboneElement)
  protected
    FTargetId : TFhirId;
    FRelationship : TFhirCode;
    FOffset : TFhirDataType;
    procedure SetTargetId(value : TFhirId);
    function GetTargetIdST : String;
    procedure SetTargetIdST(value : String);
    procedure SetRelationship(value : TFhirCode);
    function GetRelationshipST : String;
    procedure SetRelationshipST(value : String);
    procedure SetOffset(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRequestGroupActionRelatedAction; overload;
    function Clone : TFhirRequestGroupActionRelatedAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The element id of the target related action.
    property targetId : String read GetTargetIdST write SetTargetIdST;
    // The element id of the target related action.
    property targetIdElement : TFhirId read FTargetId write SetTargetId;

    // Typed access to The relationship of this action to the related action.
    property relationship : String read GetRelationshipST write SetRelationshipST;
    // The relationship of this action to the related action.
    property relationshipElement : TFhirCode read FRelationship write SetRelationship;

    // Typed access to A duration or range of durations to apply to the relationship. For example, 30-60 minutes before. (defined for API consistency)
    property offset : TFhirDataType read FOffset write SetOffset;
    // A duration or range of durations to apply to the relationship. For example, 30-60 minutes before.
    property offsetElement : TFhirDataType read FOffset write SetOffset;

  end;

  TFhirRequestGroupActionRelatedActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRequestGroupActionRelatedActionList;
    function GetCurrent : TFhirRequestGroupActionRelatedAction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRequestGroupActionRelatedActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRequestGroupActionRelatedAction read GetCurrent;
  end;

  TFhirRequestGroupActionRelatedActionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRequestGroupActionRelatedAction;
    procedure SetItemN(index : Integer; value : TFhirRequestGroupActionRelatedAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRequestGroupActionRelatedActionList; overload;
    function Clone : TFhirRequestGroupActionRelatedActionList; overload;
    function GetEnumerator : TFhirRequestGroupActionRelatedActionListEnumerator;
    
    //  Add a FhirRequestGroupActionRelatedAction to the end of the list.
    function Append : TFhirRequestGroupActionRelatedAction;
    
    // Add an already existing FhirRequestGroupActionRelatedAction to the end of the list.
    function AddItem(value : TFhirRequestGroupActionRelatedAction) : TFhirRequestGroupActionRelatedAction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRequestGroupActionRelatedAction) : Integer;
    
    // Insert FhirRequestGroupActionRelatedAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRequestGroupActionRelatedAction;
    
    // Insert an existing FhirRequestGroupActionRelatedAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRequestGroupActionRelatedAction);
    
    // Get the iIndexth FhirRequestGroupActionRelatedAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRequestGroupActionRelatedAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRequestGroupActionRelatedAction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRequestGroupActionRelatedActions[index : Integer] : TFhirRequestGroupActionRelatedAction read GetItemN write SetItemN; default;
  End;

  // The participant that should perform or be responsible for this action.
  TFhirRequestGroupActionParticipant = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCode;
    FTypeReference : TFhirReference;
    FRole : TFhirCodeableConcept;
    FFunction_ : TFhirCodeableConcept;
    FActor : TFhirReference;
    procedure SetType_(value : TFhirCode);
    function GetType_ST : String;
    procedure SetType_ST(value : String);
    procedure SetTypeReference(value : TFhirReference);
    procedure SetRole(value : TFhirCodeableConcept);
    procedure SetFunction_(value : TFhirCodeableConcept);
    procedure SetActor(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRequestGroupActionParticipant; overload;
    function Clone : TFhirRequestGroupActionParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of participant in the action.
    property type_ : String read GetType_ST write SetType_ST;
    // The type of participant in the action.
    property type_Element : TFhirCode read FType_ write SetType_;

    // Typed access to The type of participant in the action. (defined for API consistency)
    property typeReference : TFhirReference read FTypeReference write SetTypeReference;
    // The type of participant in the action.
    property typeReferenceElement : TFhirReference read FTypeReference write SetTypeReference;

    // Typed access to The role the participant should play in performing the described action. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // The role the participant should play in performing the described action.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to Indicates how the actor will be involved in the action - author, reviewer, witness, etc. (defined for API consistency)
    property function_ : TFhirCodeableConcept read FFunction_ write SetFunction_;
    // Indicates how the actor will be involved in the action - author, reviewer, witness, etc.
    property function_Element : TFhirCodeableConcept read FFunction_ write SetFunction_;

    // Typed access to A reference to the actual participant. (defined for API consistency)
    property actor : TFhirReference read FActor write SetActor;
    // A reference to the actual participant.
    property actorElement : TFhirReference read FActor write SetActor;

  end;

  TFhirRequestGroupActionParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRequestGroupActionParticipantList;
    function GetCurrent : TFhirRequestGroupActionParticipant;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRequestGroupActionParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRequestGroupActionParticipant read GetCurrent;
  end;

  TFhirRequestGroupActionParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRequestGroupActionParticipant;
    procedure SetItemN(index : Integer; value : TFhirRequestGroupActionParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRequestGroupActionParticipantList; overload;
    function Clone : TFhirRequestGroupActionParticipantList; overload;
    function GetEnumerator : TFhirRequestGroupActionParticipantListEnumerator;
    
    //  Add a FhirRequestGroupActionParticipant to the end of the list.
    function Append : TFhirRequestGroupActionParticipant;
    
    // Add an already existing FhirRequestGroupActionParticipant to the end of the list.
    function AddItem(value : TFhirRequestGroupActionParticipant) : TFhirRequestGroupActionParticipant; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRequestGroupActionParticipant) : Integer;
    
    // Insert FhirRequestGroupActionParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRequestGroupActionParticipant;
    
    // Insert an existing FhirRequestGroupActionParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRequestGroupActionParticipant);
    
    // Get the iIndexth FhirRequestGroupActionParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRequestGroupActionParticipant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRequestGroupActionParticipant;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRequestGroupActionParticipants[index : Integer] : TFhirRequestGroupActionParticipant read GetItemN write SetItemN; default;
  End;

  // A group of related requests that can be used to capture intended activities that have inter-dependencies such as "give this medication after that one".
  TFhirRequestGroup = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FbasedOnList : TFhirReferenceList;
    FreplacesList : TFhirReferenceList;
    FGroupIdentifier : TFhirIdentifier;
    FStatus : TFhirCode;
    FIntent : TFhirCode;
    FPriority : TFhirCode;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FAuthoredOn : TFhirDateTime;
    FAuthor : TFhirReference;
    FreasonList : TFhirCodeableReferenceList;
    FgoalList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    FactionList : TFhirRequestGroupActionList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetReplacesList : TFhirReferenceList;
    function GetHasReplacesList : Boolean;
    procedure SetGroupIdentifier(value : TFhirIdentifier);
    procedure SetStatus(value : TFhirCode);
    function GetStatusST : String;
    procedure SetStatusST(value : String);
    procedure SetIntent(value : TFhirCode);
    function GetIntentST : String;
    procedure SetIntentST(value : String);
    procedure SetPriority(value : TFhirCode);
    function GetPriorityST : String;
    procedure SetPriorityST(value : String);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetAuthoredOn(value : TFhirDateTime);
    function GetAuthoredOnST : TFslDateTime;
    procedure SetAuthoredOnST(value : TFslDateTime);
    procedure SetAuthor(value : TFhirReference);
    function GetReasonList : TFhirCodeableReferenceList;
    function GetHasReasonList : Boolean;
    function GetGoalList : TFhirReferenceList;
    function GetHasGoalList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetActionList : TFhirRequestGroupActionList;
    function GetHasActionList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRequestGroup; overload;
    function Clone : TFhirRequestGroup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Allows a service to provide a unique, business identifier for the request.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A canonical URL referencing a FHIR-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this request.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // A URL referencing an externally defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this request.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // A plan, proposal or order that is fulfilled in whole or in part by this request.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Completed or terminated request(s) whose function is taken by this new request.
    property replacesList : TFhirReferenceList read GetReplacesList;
    property hasReplacesList : boolean read GetHasReplacesList;

    // Typed access to A shared identifier common to all requests that were authorized more or less simultaneously by a single author, representing the identifier of the requisition, prescription or similar form. (defined for API consistency)
    property groupIdentifier : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;
    // A shared identifier common to all requests that were authorized more or less simultaneously by a single author, representing the identifier of the requisition, prescription or similar form.
    property groupIdentifierElement : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;

    // Typed access to The current state of the request. For request groups, the status reflects the status of all the requests in the group.
    property status : String read GetStatusST write SetStatusST;
    // The current state of the request. For request groups, the status reflects the status of all the requests in the group.
    property statusElement : TFhirCode read FStatus write SetStatus;

    // Typed access to Indicates the level of authority/intentionality associated with the request and where the request fits into the workflow chain.
    property intent : String read GetIntentST write SetIntentST;
    // Indicates the level of authority/intentionality associated with the request and where the request fits into the workflow chain.
    property intentElement : TFhirCode read FIntent write SetIntent;

    // Typed access to Indicates how quickly the request should be addressed with respect to other requests.
    property priority : String read GetPriorityST write SetPriorityST;
    // Indicates how quickly the request should be addressed with respect to other requests.
    property priorityElement : TFhirCode read FPriority write SetPriority;

    // Typed access to A code that identifies what the overall request group is. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that identifies what the overall request group is.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The subject for which the request group was created. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The subject for which the request group was created.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to Describes the context of the request group, if any. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // Describes the context of the request group, if any.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to Indicates when the request group was created.
    property authoredOn : TFslDateTime read GetAuthoredOnST write SetAuthoredOnST;
    // Indicates when the request group was created.
    property authoredOnElement : TFhirDateTime read FAuthoredOn write SetAuthoredOn;

    // Typed access to Provides a reference to the author of the request group. (defined for API consistency)
    property author : TFhirReference read FAuthor write SetAuthor;
    // Provides a reference to the author of the request group.
    property authorElement : TFhirReference read FAuthor write SetAuthor;

    // Describes the reason for the request group in coded or textual form.
    property reasonList : TFhirCodeableReferenceList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Goals that are intended to be achieved by following the requests in this RequestGroup.
    property goalList : TFhirReferenceList read GetGoalList;
    property hasGoalList : boolean read GetHasGoalList;

    // Provides a mechanism to communicate additional information about the response.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // The actions, if any, produced by the evaluation of the artifact.
    property actionList : TFhirRequestGroupActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirRequestGroupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRequestGroupList;
    function GetCurrent : TFhirRequestGroup;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRequestGroupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRequestGroup read GetCurrent;
  end;

  TFhirRequestGroupList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRequestGroup;
    procedure SetItemN(index : Integer; value : TFhirRequestGroup);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRequestGroupList; overload;
    function Clone : TFhirRequestGroupList; overload;
    function GetEnumerator : TFhirRequestGroupListEnumerator;
    
    //  Add a FhirRequestGroup to the end of the list.
    function Append : TFhirRequestGroup;
    
    // Add an already existing FhirRequestGroup to the end of the list.
    function AddItem(value : TFhirRequestGroup) : TFhirRequestGroup; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRequestGroup) : Integer;
    
    // Insert FhirRequestGroup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRequestGroup;
    
    // Insert an existing FhirRequestGroup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRequestGroup);
    
    // Get the iIndexth FhirRequestGroup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRequestGroup);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRequestGroup;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRequestGroups[index : Integer] : TFhirRequestGroup read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_REQUESTORCHESTRATION}
  // The actions, if any, produced by the evaluation of the artifact.
  TFhirRequestOrchestrationAction = class (TFhirBackboneElement)
  protected
    FLinkId : TFhirString;
    FPrefix : TFhirString;
    FTitle : TFhirString;
    FDescription : TFhirString;
    FTextEquivalent : TFhirString;
    FPriority : TFhirEnum;
    FcodeList : TFhirCodeableConceptList;
    FdocumentationList : TFhirRelatedArtifactList;
    FgoalList : TFhirReferenceList;
    FconditionList : TFhirRequestOrchestrationActionConditionList;
    FinputList : TFhirRequestOrchestrationActionInputList;
    FoutputList : TFhirRequestOrchestrationActionOutputList;
    FrelatedActionList : TFhirRequestOrchestrationActionRelatedActionList;
    FTiming : TFhirDataType;
    FLocation : TFhirCodeableReference;
    FparticipantList : TFhirRequestOrchestrationActionParticipantList;
    FType_ : TFhirCodeableConcept;
    FGroupingBehavior : TFhirEnum;
    FSelectionBehavior : TFhirEnum;
    FRequiredBehavior : TFhirEnum;
    FPrecheckBehavior : TFhirEnum;
    FCardinalityBehavior : TFhirEnum;
    FResource : TFhirReference;
    FDefinition : TFhirDataType;
    FTransform : TFhirCanonical;
    FdynamicValueList : TFhirRequestOrchestrationActionDynamicValueList;
    FactionList : TFhirRequestOrchestrationActionList;
    procedure SetLinkId(value : TFhirString);
    function GetLinkIdST : String;
    procedure SetLinkIdST(value : String);
    procedure SetPrefix(value : TFhirString);
    function GetPrefixST : String;
    procedure SetPrefixST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetTextEquivalent(value : TFhirString);
    function GetTextEquivalentST : String;
    procedure SetTextEquivalentST(value : String);
    procedure SetPriority(value : TFhirEnum);
    function GetPriorityST : TFhirRequestPriorityEnum;
    procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    function GetDocumentationList : TFhirRelatedArtifactList;
    function GetHasDocumentationList : Boolean;
    function GetGoalList : TFhirReferenceList;
    function GetHasGoalList : Boolean;
    function GetConditionList : TFhirRequestOrchestrationActionConditionList;
    function GetHasConditionList : Boolean;
    function GetInputList : TFhirRequestOrchestrationActionInputList;
    function GetHasInputList : Boolean;
    function GetOutputList : TFhirRequestOrchestrationActionOutputList;
    function GetHasOutputList : Boolean;
    function GetRelatedActionList : TFhirRequestOrchestrationActionRelatedActionList;
    function GetHasRelatedActionList : Boolean;
    procedure SetTiming(value : TFhirDataType);
    procedure SetLocation(value : TFhirCodeableReference);
    function GetParticipantList : TFhirRequestOrchestrationActionParticipantList;
    function GetHasParticipantList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetGroupingBehavior(value : TFhirEnum);
    function GetGroupingBehaviorST : TFhirActionGroupingBehaviorEnum;
    procedure SetGroupingBehaviorST(value : TFhirActionGroupingBehaviorEnum);
    procedure SetSelectionBehavior(value : TFhirEnum);
    function GetSelectionBehaviorST : TFhirActionSelectionBehaviorEnum;
    procedure SetSelectionBehaviorST(value : TFhirActionSelectionBehaviorEnum);
    procedure SetRequiredBehavior(value : TFhirEnum);
    function GetRequiredBehaviorST : TFhirActionRequiredBehaviorEnum;
    procedure SetRequiredBehaviorST(value : TFhirActionRequiredBehaviorEnum);
    procedure SetPrecheckBehavior(value : TFhirEnum);
    function GetPrecheckBehaviorST : TFhirActionPrecheckBehaviorEnum;
    procedure SetPrecheckBehaviorST(value : TFhirActionPrecheckBehaviorEnum);
    procedure SetCardinalityBehavior(value : TFhirEnum);
    function GetCardinalityBehaviorST : TFhirActionCardinalityBehaviorEnum;
    procedure SetCardinalityBehaviorST(value : TFhirActionCardinalityBehaviorEnum);
    procedure SetResource(value : TFhirReference);
    procedure SetDefinition(value : TFhirDataType);
    procedure SetTransform(value : TFhirCanonical);
    function GetTransformST : String;
    procedure SetTransformST(value : String);
    function GetDynamicValueList : TFhirRequestOrchestrationActionDynamicValueList;
    function GetHasDynamicValueList : Boolean;
    function GetActionList : TFhirRequestOrchestrationActionList;
    function GetHasActionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRequestOrchestrationAction; overload;
    function Clone : TFhirRequestOrchestrationAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The linkId of the action from the PlanDefinition that corresponds to this action in the RequestOrchestration resource.
    property linkId : String read GetLinkIdST write SetLinkIdST;
    // The linkId of the action from the PlanDefinition that corresponds to this action in the RequestOrchestration resource.
    property linkIdElement : TFhirString read FLinkId write SetLinkId;

    // Typed access to A user-visible prefix for the action. For example a section or item numbering such as 1. or A.
    property prefix : String read GetPrefixST write SetPrefixST;
    // A user-visible prefix for the action. For example a section or item numbering such as 1. or A.
    property prefixElement : TFhirString read FPrefix write SetPrefix;

    // Typed access to The title of the action displayed to a user.
    property title : String read GetTitleST write SetTitleST;
    // The title of the action displayed to a user.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to A short description of the action used to provide a summary to display to the user.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A short description of the action used to provide a summary to display to the user.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to A text equivalent of the action to be performed. This provides a human-interpretable description of the action when the definition is consumed by a system that might not be capable of interpreting it dynamically.
    property textEquivalent : String read GetTextEquivalentST write SetTextEquivalentST;
    // A text equivalent of the action to be performed. This provides a human-interpretable description of the action when the definition is consumed by a system that might not be capable of interpreting it dynamically.
    property textEquivalentElement : TFhirString read FTextEquivalent write SetTextEquivalent;

    // Indicates how quickly the action should be addressed with respect to other actions.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // A code that provides meaning for the action or action group. For example, a section may have a LOINC code for a section of a documentation template.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Didactic or other informational resources associated with the action that can be provided to the CDS recipient. Information resources can include inline text commentary and links to web resources.
    property documentationList : TFhirRelatedArtifactList read GetDocumentationList;
    property hasDocumentationList : boolean read GetHasDocumentationList;

    // Goals that are intended to be achieved by following the requests in this action.
    property goalList : TFhirReferenceList read GetGoalList;
    property hasGoalList : boolean read GetHasGoalList;

    // An expression that describes applicability criteria, or start/stop conditions for the action.
    property conditionList : TFhirRequestOrchestrationActionConditionList read GetConditionList;
    property hasConditionList : boolean read GetHasConditionList;

    // Defines input data requirements for the action.
    property inputList : TFhirRequestOrchestrationActionInputList read GetInputList;
    property hasInputList : boolean read GetHasInputList;

    // Defines the outputs of the action, if any.
    property outputList : TFhirRequestOrchestrationActionOutputList read GetOutputList;
    property hasOutputList : boolean read GetHasOutputList;

    // A relationship to another action such as "before" or "30-60 minutes after start of".
    property relatedActionList : TFhirRequestOrchestrationActionRelatedActionList read GetRelatedActionList;
    property hasRelatedActionList : boolean read GetHasRelatedActionList;

    // Typed access to An optional value describing when the action should be performed. (defined for API consistency)
    property timing : TFhirDataType read FTiming write SetTiming;
    // An optional value describing when the action should be performed.
    property timingElement : TFhirDataType read FTiming write SetTiming;

    // Typed access to Identifies the facility where the action will occur; e.g. home, hospital, specific clinic, etc. (defined for API consistency)
    property location : TFhirCodeableReference read FLocation write SetLocation;
    // Identifies the facility where the action will occur; e.g. home, hospital, specific clinic, etc.
    property locationElement : TFhirCodeableReference read FLocation write SetLocation;

    // The participant that should perform or be responsible for this action.
    property participantList : TFhirRequestOrchestrationActionParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // Typed access to The type of action to perform (create, update, remove). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of action to perform (create, update, remove).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Defines the grouping behavior for the action and its children.
    property groupingBehavior : TFhirActionGroupingBehaviorEnum read GetGroupingBehaviorST write SetGroupingBehaviorST;
    property groupingBehaviorElement : TFhirEnum read FGroupingBehavior write SetGroupingBehavior;

    // Defines the selection behavior for the action and its children.
    property selectionBehavior : TFhirActionSelectionBehaviorEnum read GetSelectionBehaviorST write SetSelectionBehaviorST;
    property selectionBehaviorElement : TFhirEnum read FSelectionBehavior write SetSelectionBehavior;

    // Defines expectations around whether an action is required.
    property requiredBehavior : TFhirActionRequiredBehaviorEnum read GetRequiredBehaviorST write SetRequiredBehaviorST;
    property requiredBehaviorElement : TFhirEnum read FRequiredBehavior write SetRequiredBehavior;

    // Defines whether the action should usually be preselected.
    property precheckBehavior : TFhirActionPrecheckBehaviorEnum read GetPrecheckBehaviorST write SetPrecheckBehaviorST;
    property precheckBehaviorElement : TFhirEnum read FPrecheckBehavior write SetPrecheckBehavior;

    // Defines whether the action can be selected multiple times.
    property cardinalityBehavior : TFhirActionCardinalityBehaviorEnum read GetCardinalityBehaviorST write SetCardinalityBehaviorST;
    property cardinalityBehaviorElement : TFhirEnum read FCardinalityBehavior write SetCardinalityBehavior;

    // Typed access to The resource that is the target of the action (e.g. CommunicationRequest). (defined for API consistency)
    property resource : TFhirReference read FResource write SetResource;
    // The resource that is the target of the action (e.g. CommunicationRequest).
    property resourceElement : TFhirReference read FResource write SetResource;

    // Typed access to A reference to an ActivityDefinition that describes the action to be taken in detail, a PlanDefinition that describes a series of actions to be taken, a Questionnaire that should be filled out, a SpecimenDefinition describing a specimen to be collected, or an ObservationDefinition that specifies what observation should be captured. (defined for API consistency)
    property definition : TFhirDataType read FDefinition write SetDefinition;
    // A reference to an ActivityDefinition that describes the action to be taken in detail, a PlanDefinition that describes a series of actions to be taken, a Questionnaire that should be filled out, a SpecimenDefinition describing a specimen to be collected, or an ObservationDefinition that specifies what observation should be captured.
    property definitionElement : TFhirDataType read FDefinition write SetDefinition;

    // Typed access to A reference to a StructureMap resource that defines a transform that can be executed to produce the intent resource using the ActivityDefinition instance as the input.
    property transform : String read GetTransformST write SetTransformST;
    // A reference to a StructureMap resource that defines a transform that can be executed to produce the intent resource using the ActivityDefinition instance as the input.
    property transformElement : TFhirCanonical read FTransform write SetTransform;

    // Customizations that should be applied to the statically defined resource. For example, if the dosage of a medication must be computed based on the patient's weight, a customization would be used to specify an expression that calculated the weight, and the path on the resource that would contain the result.
    property dynamicValueList : TFhirRequestOrchestrationActionDynamicValueList read GetDynamicValueList;
    property hasDynamicValueList : boolean read GetHasDynamicValueList;

    // Sub actions.
    property actionList : TFhirRequestOrchestrationActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirRequestOrchestrationActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRequestOrchestrationActionList;
    function GetCurrent : TFhirRequestOrchestrationAction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRequestOrchestrationActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRequestOrchestrationAction read GetCurrent;
  end;

  TFhirRequestOrchestrationActionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRequestOrchestrationAction;
    procedure SetItemN(index : Integer; value : TFhirRequestOrchestrationAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRequestOrchestrationActionList; overload;
    function Clone : TFhirRequestOrchestrationActionList; overload;
    function GetEnumerator : TFhirRequestOrchestrationActionListEnumerator;
    
    //  Add a FhirRequestOrchestrationAction to the end of the list.
    function Append : TFhirRequestOrchestrationAction;
    
    // Add an already existing FhirRequestOrchestrationAction to the end of the list.
    function AddItem(value : TFhirRequestOrchestrationAction) : TFhirRequestOrchestrationAction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRequestOrchestrationAction) : Integer;
    
    // Insert FhirRequestOrchestrationAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRequestOrchestrationAction;
    
    // Insert an existing FhirRequestOrchestrationAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRequestOrchestrationAction);
    
    // Get the iIndexth FhirRequestOrchestrationAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRequestOrchestrationAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRequestOrchestrationAction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRequestOrchestrationActions[index : Integer] : TFhirRequestOrchestrationAction read GetItemN write SetItemN; default;
  End;

  // An expression that describes applicability criteria, or start/stop conditions for the action.
  TFhirRequestOrchestrationActionCondition = class (TFhirBackboneElement)
  protected
    FKind : TFhirEnum;
    FExpression : TFhirExpression;
    procedure SetKind(value : TFhirEnum);
    function GetKindST : TFhirActionConditionKindEnum;
    procedure SetKindST(value : TFhirActionConditionKindEnum);
    procedure SetExpression(value : TFhirExpression);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRequestOrchestrationActionCondition; overload;
    function Clone : TFhirRequestOrchestrationActionCondition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The kind of condition.
    property kind : TFhirActionConditionKindEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    // Typed access to An expression that returns true or false, indicating whether or not the condition is satisfied. (defined for API consistency)
    property expression : TFhirExpression read FExpression write SetExpression;
    // An expression that returns true or false, indicating whether or not the condition is satisfied.
    property expressionElement : TFhirExpression read FExpression write SetExpression;

  end;

  TFhirRequestOrchestrationActionConditionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRequestOrchestrationActionConditionList;
    function GetCurrent : TFhirRequestOrchestrationActionCondition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRequestOrchestrationActionConditionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRequestOrchestrationActionCondition read GetCurrent;
  end;

  TFhirRequestOrchestrationActionConditionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRequestOrchestrationActionCondition;
    procedure SetItemN(index : Integer; value : TFhirRequestOrchestrationActionCondition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRequestOrchestrationActionConditionList; overload;
    function Clone : TFhirRequestOrchestrationActionConditionList; overload;
    function GetEnumerator : TFhirRequestOrchestrationActionConditionListEnumerator;
    
    //  Add a FhirRequestOrchestrationActionCondition to the end of the list.
    function Append : TFhirRequestOrchestrationActionCondition;
    
    // Add an already existing FhirRequestOrchestrationActionCondition to the end of the list.
    function AddItem(value : TFhirRequestOrchestrationActionCondition) : TFhirRequestOrchestrationActionCondition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRequestOrchestrationActionCondition) : Integer;
    
    // Insert FhirRequestOrchestrationActionCondition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRequestOrchestrationActionCondition;
    
    // Insert an existing FhirRequestOrchestrationActionCondition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRequestOrchestrationActionCondition);
    
    // Get the iIndexth FhirRequestOrchestrationActionCondition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRequestOrchestrationActionCondition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRequestOrchestrationActionCondition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRequestOrchestrationActionConditions[index : Integer] : TFhirRequestOrchestrationActionCondition read GetItemN write SetItemN; default;
  End;

  // Defines input data requirements for the action.
  TFhirRequestOrchestrationActionInput = class (TFhirBackboneElement)
  protected
    FTitle : TFhirString;
    FRequirement : TFhirDataRequirement;
    FRelatedData : TFhirId;
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetRequirement(value : TFhirDataRequirement);
    procedure SetRelatedData(value : TFhirId);
    function GetRelatedDataST : String;
    procedure SetRelatedDataST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRequestOrchestrationActionInput; overload;
    function Clone : TFhirRequestOrchestrationActionInput; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A human-readable label for the data requirement used to label data flows in BPMN or similar diagrams. Also provides a human readable label when rendering the data requirement that conveys its purpose to human readers.
    property title : String read GetTitleST write SetTitleST;
    // A human-readable label for the data requirement used to label data flows in BPMN or similar diagrams. Also provides a human readable label when rendering the data requirement that conveys its purpose to human readers.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to Defines the data that is to be provided as input to the action. (defined for API consistency)
    property requirement : TFhirDataRequirement read FRequirement write SetRequirement;
    // Defines the data that is to be provided as input to the action.
    property requirementElement : TFhirDataRequirement read FRequirement write SetRequirement;

    // Typed access to Points to an existing input or output element that provides data to this input.
    property relatedData : String read GetRelatedDataST write SetRelatedDataST;
    // Points to an existing input or output element that provides data to this input.
    property relatedDataElement : TFhirId read FRelatedData write SetRelatedData;

  end;

  TFhirRequestOrchestrationActionInputListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRequestOrchestrationActionInputList;
    function GetCurrent : TFhirRequestOrchestrationActionInput;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRequestOrchestrationActionInputList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRequestOrchestrationActionInput read GetCurrent;
  end;

  TFhirRequestOrchestrationActionInputList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRequestOrchestrationActionInput;
    procedure SetItemN(index : Integer; value : TFhirRequestOrchestrationActionInput);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRequestOrchestrationActionInputList; overload;
    function Clone : TFhirRequestOrchestrationActionInputList; overload;
    function GetEnumerator : TFhirRequestOrchestrationActionInputListEnumerator;
    
    //  Add a FhirRequestOrchestrationActionInput to the end of the list.
    function Append : TFhirRequestOrchestrationActionInput;
    
    // Add an already existing FhirRequestOrchestrationActionInput to the end of the list.
    function AddItem(value : TFhirRequestOrchestrationActionInput) : TFhirRequestOrchestrationActionInput; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRequestOrchestrationActionInput) : Integer;
    
    // Insert FhirRequestOrchestrationActionInput before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRequestOrchestrationActionInput;
    
    // Insert an existing FhirRequestOrchestrationActionInput before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRequestOrchestrationActionInput);
    
    // Get the iIndexth FhirRequestOrchestrationActionInput. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRequestOrchestrationActionInput);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRequestOrchestrationActionInput;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRequestOrchestrationActionInputs[index : Integer] : TFhirRequestOrchestrationActionInput read GetItemN write SetItemN; default;
  End;

  // Defines the outputs of the action, if any.
  TFhirRequestOrchestrationActionOutput = class (TFhirBackboneElement)
  protected
    FTitle : TFhirString;
    FRequirement : TFhirDataRequirement;
    FRelatedData : TFhirString;
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetRequirement(value : TFhirDataRequirement);
    procedure SetRelatedData(value : TFhirString);
    function GetRelatedDataST : String;
    procedure SetRelatedDataST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRequestOrchestrationActionOutput; overload;
    function Clone : TFhirRequestOrchestrationActionOutput; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A human-readable label for the data requirement used to label data flows in BPMN or similar diagrams. Also provides a human readable label when rendering the data requirement that conveys its purpose to human readers.
    property title : String read GetTitleST write SetTitleST;
    // A human-readable label for the data requirement used to label data flows in BPMN or similar diagrams. Also provides a human readable label when rendering the data requirement that conveys its purpose to human readers.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to Defines the data that results as output from the action. (defined for API consistency)
    property requirement : TFhirDataRequirement read FRequirement write SetRequirement;
    // Defines the data that results as output from the action.
    property requirementElement : TFhirDataRequirement read FRequirement write SetRequirement;

    // Typed access to Points to an existing input or output element that is results as output from the action.
    property relatedData : String read GetRelatedDataST write SetRelatedDataST;
    // Points to an existing input or output element that is results as output from the action.
    property relatedDataElement : TFhirString read FRelatedData write SetRelatedData;

  end;

  TFhirRequestOrchestrationActionOutputListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRequestOrchestrationActionOutputList;
    function GetCurrent : TFhirRequestOrchestrationActionOutput;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRequestOrchestrationActionOutputList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRequestOrchestrationActionOutput read GetCurrent;
  end;

  TFhirRequestOrchestrationActionOutputList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRequestOrchestrationActionOutput;
    procedure SetItemN(index : Integer; value : TFhirRequestOrchestrationActionOutput);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRequestOrchestrationActionOutputList; overload;
    function Clone : TFhirRequestOrchestrationActionOutputList; overload;
    function GetEnumerator : TFhirRequestOrchestrationActionOutputListEnumerator;
    
    //  Add a FhirRequestOrchestrationActionOutput to the end of the list.
    function Append : TFhirRequestOrchestrationActionOutput;
    
    // Add an already existing FhirRequestOrchestrationActionOutput to the end of the list.
    function AddItem(value : TFhirRequestOrchestrationActionOutput) : TFhirRequestOrchestrationActionOutput; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRequestOrchestrationActionOutput) : Integer;
    
    // Insert FhirRequestOrchestrationActionOutput before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRequestOrchestrationActionOutput;
    
    // Insert an existing FhirRequestOrchestrationActionOutput before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRequestOrchestrationActionOutput);
    
    // Get the iIndexth FhirRequestOrchestrationActionOutput. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRequestOrchestrationActionOutput);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRequestOrchestrationActionOutput;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRequestOrchestrationActionOutputs[index : Integer] : TFhirRequestOrchestrationActionOutput read GetItemN write SetItemN; default;
  End;

  // A relationship to another action such as "before" or "30-60 minutes after start of".
  TFhirRequestOrchestrationActionRelatedAction = class (TFhirBackboneElement)
  protected
    FTargetId : TFhirId;
    FRelationship : TFhirEnum;
    FOffset : TFhirDataType;
    procedure SetTargetId(value : TFhirId);
    function GetTargetIdST : String;
    procedure SetTargetIdST(value : String);
    procedure SetRelationship(value : TFhirEnum);
    function GetRelationshipST : TFhirActionRelationshipTypeEnum;
    procedure SetRelationshipST(value : TFhirActionRelationshipTypeEnum);
    procedure SetOffset(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRequestOrchestrationActionRelatedAction; overload;
    function Clone : TFhirRequestOrchestrationActionRelatedAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The element id of the target related action.
    property targetId : String read GetTargetIdST write SetTargetIdST;
    // The element id of the target related action.
    property targetIdElement : TFhirId read FTargetId write SetTargetId;

    // The relationship of this action to the related action.
    property relationship : TFhirActionRelationshipTypeEnum read GetRelationshipST write SetRelationshipST;
    property relationshipElement : TFhirEnum read FRelationship write SetRelationship;

    // Typed access to A duration or range of durations to apply to the relationship. For example, 30-60 minutes before. (defined for API consistency)
    property offset : TFhirDataType read FOffset write SetOffset;
    // A duration or range of durations to apply to the relationship. For example, 30-60 minutes before.
    property offsetElement : TFhirDataType read FOffset write SetOffset;

  end;

  TFhirRequestOrchestrationActionRelatedActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRequestOrchestrationActionRelatedActionList;
    function GetCurrent : TFhirRequestOrchestrationActionRelatedAction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRequestOrchestrationActionRelatedActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRequestOrchestrationActionRelatedAction read GetCurrent;
  end;

  TFhirRequestOrchestrationActionRelatedActionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRequestOrchestrationActionRelatedAction;
    procedure SetItemN(index : Integer; value : TFhirRequestOrchestrationActionRelatedAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRequestOrchestrationActionRelatedActionList; overload;
    function Clone : TFhirRequestOrchestrationActionRelatedActionList; overload;
    function GetEnumerator : TFhirRequestOrchestrationActionRelatedActionListEnumerator;
    
    //  Add a FhirRequestOrchestrationActionRelatedAction to the end of the list.
    function Append : TFhirRequestOrchestrationActionRelatedAction;
    
    // Add an already existing FhirRequestOrchestrationActionRelatedAction to the end of the list.
    function AddItem(value : TFhirRequestOrchestrationActionRelatedAction) : TFhirRequestOrchestrationActionRelatedAction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRequestOrchestrationActionRelatedAction) : Integer;
    
    // Insert FhirRequestOrchestrationActionRelatedAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRequestOrchestrationActionRelatedAction;
    
    // Insert an existing FhirRequestOrchestrationActionRelatedAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRequestOrchestrationActionRelatedAction);
    
    // Get the iIndexth FhirRequestOrchestrationActionRelatedAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRequestOrchestrationActionRelatedAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRequestOrchestrationActionRelatedAction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRequestOrchestrationActionRelatedActions[index : Integer] : TFhirRequestOrchestrationActionRelatedAction read GetItemN write SetItemN; default;
  End;

  // The participant that should perform or be responsible for this action.
  TFhirRequestOrchestrationActionParticipant = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FTypeCanonical : TFhirCanonical;
    FTypeReference : TFhirReference;
    FRole : TFhirCodeableConcept;
    FFunction_ : TFhirCodeableConcept;
    FActor : TFhirDataType;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirActionParticipantTypeEnum;
    procedure SetType_ST(value : TFhirActionParticipantTypeEnum);
    procedure SetTypeCanonical(value : TFhirCanonical);
    function GetTypeCanonicalST : String;
    procedure SetTypeCanonicalST(value : String);
    procedure SetTypeReference(value : TFhirReference);
    procedure SetRole(value : TFhirCodeableConcept);
    procedure SetFunction_(value : TFhirCodeableConcept);
    procedure SetActor(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRequestOrchestrationActionParticipant; overload;
    function Clone : TFhirRequestOrchestrationActionParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of participant in the action.
    property type_ : TFhirActionParticipantTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The type of participant in the action.
    property typeCanonical : String read GetTypeCanonicalST write SetTypeCanonicalST;
    // The type of participant in the action.
    property typeCanonicalElement : TFhirCanonical read FTypeCanonical write SetTypeCanonical;

    // Typed access to The type of participant in the action. (defined for API consistency)
    property typeReference : TFhirReference read FTypeReference write SetTypeReference;
    // The type of participant in the action.
    property typeReferenceElement : TFhirReference read FTypeReference write SetTypeReference;

    // Typed access to The role the participant should play in performing the described action. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // The role the participant should play in performing the described action.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to Indicates how the actor will be involved in the action - author, reviewer, witness, etc. (defined for API consistency)
    property function_ : TFhirCodeableConcept read FFunction_ write SetFunction_;
    // Indicates how the actor will be involved in the action - author, reviewer, witness, etc.
    property function_Element : TFhirCodeableConcept read FFunction_ write SetFunction_;

    // Typed access to A reference to the actual participant. (defined for API consistency)
    property actor : TFhirDataType read FActor write SetActor;
    // A reference to the actual participant.
    property actorElement : TFhirDataType read FActor write SetActor;

  end;

  TFhirRequestOrchestrationActionParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRequestOrchestrationActionParticipantList;
    function GetCurrent : TFhirRequestOrchestrationActionParticipant;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRequestOrchestrationActionParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRequestOrchestrationActionParticipant read GetCurrent;
  end;

  TFhirRequestOrchestrationActionParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRequestOrchestrationActionParticipant;
    procedure SetItemN(index : Integer; value : TFhirRequestOrchestrationActionParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRequestOrchestrationActionParticipantList; overload;
    function Clone : TFhirRequestOrchestrationActionParticipantList; overload;
    function GetEnumerator : TFhirRequestOrchestrationActionParticipantListEnumerator;
    
    //  Add a FhirRequestOrchestrationActionParticipant to the end of the list.
    function Append : TFhirRequestOrchestrationActionParticipant;
    
    // Add an already existing FhirRequestOrchestrationActionParticipant to the end of the list.
    function AddItem(value : TFhirRequestOrchestrationActionParticipant) : TFhirRequestOrchestrationActionParticipant; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRequestOrchestrationActionParticipant) : Integer;
    
    // Insert FhirRequestOrchestrationActionParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRequestOrchestrationActionParticipant;
    
    // Insert an existing FhirRequestOrchestrationActionParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRequestOrchestrationActionParticipant);
    
    // Get the iIndexth FhirRequestOrchestrationActionParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRequestOrchestrationActionParticipant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRequestOrchestrationActionParticipant;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRequestOrchestrationActionParticipants[index : Integer] : TFhirRequestOrchestrationActionParticipant read GetItemN write SetItemN; default;
  End;

  // Customizations that should be applied to the statically defined resource. For example, if the dosage of a medication must be computed based on the patient's weight, a customization would be used to specify an expression that calculated the weight, and the path on the resource that would contain the result.
  TFhirRequestOrchestrationActionDynamicValue = class (TFhirBackboneElement)
  protected
    FPath : TFhirString;
    FExpression : TFhirExpression;
    procedure SetPath(value : TFhirString);
    function GetPathST : String;
    procedure SetPathST(value : String);
    procedure SetExpression(value : TFhirExpression);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRequestOrchestrationActionDynamicValue; overload;
    function Clone : TFhirRequestOrchestrationActionDynamicValue; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The path to the element to be customized. This is the path on the resource that will hold the result of the calculation defined by the expression. The specified path SHALL be a FHIRPath resolveable on the specified target type of the ActivityDefinition, and SHALL consist only of identifiers, constant indexers, and a restricted subset of functions. The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](fhirpath.html#simple) for full details).
    property path : String read GetPathST write SetPathST;
    // The path to the element to be customized. This is the path on the resource that will hold the result of the calculation defined by the expression. The specified path SHALL be a FHIRPath resolveable on the specified target type of the ActivityDefinition, and SHALL consist only of identifiers, constant indexers, and a restricted subset of functions. The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](fhirpath.html#simple) for full details).
    property pathElement : TFhirString read FPath write SetPath;

    // Typed access to An expression specifying the value of the customized element. (defined for API consistency)
    property expression : TFhirExpression read FExpression write SetExpression;
    // An expression specifying the value of the customized element.
    property expressionElement : TFhirExpression read FExpression write SetExpression;

  end;

  TFhirRequestOrchestrationActionDynamicValueListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRequestOrchestrationActionDynamicValueList;
    function GetCurrent : TFhirRequestOrchestrationActionDynamicValue;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRequestOrchestrationActionDynamicValueList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRequestOrchestrationActionDynamicValue read GetCurrent;
  end;

  TFhirRequestOrchestrationActionDynamicValueList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRequestOrchestrationActionDynamicValue;
    procedure SetItemN(index : Integer; value : TFhirRequestOrchestrationActionDynamicValue);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRequestOrchestrationActionDynamicValueList; overload;
    function Clone : TFhirRequestOrchestrationActionDynamicValueList; overload;
    function GetEnumerator : TFhirRequestOrchestrationActionDynamicValueListEnumerator;
    
    //  Add a FhirRequestOrchestrationActionDynamicValue to the end of the list.
    function Append : TFhirRequestOrchestrationActionDynamicValue;
    
    // Add an already existing FhirRequestOrchestrationActionDynamicValue to the end of the list.
    function AddItem(value : TFhirRequestOrchestrationActionDynamicValue) : TFhirRequestOrchestrationActionDynamicValue; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRequestOrchestrationActionDynamicValue) : Integer;
    
    // Insert FhirRequestOrchestrationActionDynamicValue before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRequestOrchestrationActionDynamicValue;
    
    // Insert an existing FhirRequestOrchestrationActionDynamicValue before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRequestOrchestrationActionDynamicValue);
    
    // Get the iIndexth FhirRequestOrchestrationActionDynamicValue. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRequestOrchestrationActionDynamicValue);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRequestOrchestrationActionDynamicValue;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRequestOrchestrationActionDynamicValues[index : Integer] : TFhirRequestOrchestrationActionDynamicValue read GetItemN write SetItemN; default;
  End;

  // A set of related requests that can be used to capture intended activities that have inter-dependencies such as "give this medication after that one".
  TFhirRequestOrchestration = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FbasedOnList : TFhirReferenceList;
    FreplacesList : TFhirReferenceList;
    FGroupIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FIntent : TFhirEnum;
    FPriority : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FAuthoredOn : TFhirDateTime;
    FAuthor : TFhirReference;
    FreasonList : TFhirCodeableReferenceList;
    FgoalList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    FactionList : TFhirRequestOrchestrationActionList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetReplacesList : TFhirReferenceList;
    function GetHasReplacesList : Boolean;
    procedure SetGroupIdentifier(value : TFhirIdentifier);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirRequestStatusEnum;
    procedure SetStatusST(value : TFhirRequestStatusEnum);
    procedure SetIntent(value : TFhirEnum);
    function GetIntentST : TFhirRequestIntentEnum;
    procedure SetIntentST(value : TFhirRequestIntentEnum);
    procedure SetPriority(value : TFhirEnum);
    function GetPriorityST : TFhirRequestPriorityEnum;
    procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetAuthoredOn(value : TFhirDateTime);
    function GetAuthoredOnST : TFslDateTime;
    procedure SetAuthoredOnST(value : TFslDateTime);
    procedure SetAuthor(value : TFhirReference);
    function GetReasonList : TFhirCodeableReferenceList;
    function GetHasReasonList : Boolean;
    function GetGoalList : TFhirReferenceList;
    function GetHasGoalList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetActionList : TFhirRequestOrchestrationActionList;
    function GetHasActionList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRequestOrchestration; overload;
    function Clone : TFhirRequestOrchestration; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Allows a service to provide a unique, business identifier for the request.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A canonical URL referencing a FHIR-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this request.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // A URL referencing an externally defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this request.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // A plan, proposal or order that is fulfilled in whole or in part by this request.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Completed or terminated request(s) whose function is taken by this new request.
    property replacesList : TFhirReferenceList read GetReplacesList;
    property hasReplacesList : boolean read GetHasReplacesList;

    // Typed access to A shared identifier common to all requests that were authorized more or less simultaneously by a single author, representing the identifier of the requisition, prescription or similar form. (defined for API consistency)
    property groupIdentifier : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;
    // A shared identifier common to all requests that were authorized more or less simultaneously by a single author, representing the identifier of the requisition, prescription or similar form.
    property groupIdentifierElement : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;

    // The current state of the request. For request orchestrations, the status reflects the status of all the requests in the orchestration.
    property status : TFhirRequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Indicates the level of authority/intentionality associated with the request and where the request fits into the workflow chain.
    property intent : TFhirRequestIntentEnum read GetIntentST write SetIntentST;
    property intentElement : TFhirEnum read FIntent write SetIntent;

    // Indicates how quickly the request should be addressed with respect to other requests.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // Typed access to A code that identifies what the overall request orchestration is. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that identifies what the overall request orchestration is.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The subject for which the request orchestration was created. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The subject for which the request orchestration was created.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to Describes the context of the request orchestration, if any. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // Describes the context of the request orchestration, if any.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to Indicates when the request orchestration was created.
    property authoredOn : TFslDateTime read GetAuthoredOnST write SetAuthoredOnST;
    // Indicates when the request orchestration was created.
    property authoredOnElement : TFhirDateTime read FAuthoredOn write SetAuthoredOn;

    // Typed access to Provides a reference to the author of the request orchestration. (defined for API consistency)
    property author : TFhirReference read FAuthor write SetAuthor;
    // Provides a reference to the author of the request orchestration.
    property authorElement : TFhirReference read FAuthor write SetAuthor;

    // Describes the reason for the request orchestration in coded or textual form.
    property reasonList : TFhirCodeableReferenceList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Goals that are intended to be achieved by following the requests in this RequestOrchestration.
    property goalList : TFhirReferenceList read GetGoalList;
    property hasGoalList : boolean read GetHasGoalList;

    // Provides a mechanism to communicate additional information about the response.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // The actions, if any, produced by the evaluation of the artifact.
    property actionList : TFhirRequestOrchestrationActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirRequestOrchestrationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRequestOrchestrationList;
    function GetCurrent : TFhirRequestOrchestration;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRequestOrchestrationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRequestOrchestration read GetCurrent;
  end;

  TFhirRequestOrchestrationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRequestOrchestration;
    procedure SetItemN(index : Integer; value : TFhirRequestOrchestration);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRequestOrchestrationList; overload;
    function Clone : TFhirRequestOrchestrationList; overload;
    function GetEnumerator : TFhirRequestOrchestrationListEnumerator;
    
    //  Add a FhirRequestOrchestration to the end of the list.
    function Append : TFhirRequestOrchestration;
    
    // Add an already existing FhirRequestOrchestration to the end of the list.
    function AddItem(value : TFhirRequestOrchestration) : TFhirRequestOrchestration; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRequestOrchestration) : Integer;
    
    // Insert FhirRequestOrchestration before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRequestOrchestration;
    
    // Insert an existing FhirRequestOrchestration before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRequestOrchestration);
    
    // Get the iIndexth FhirRequestOrchestration. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRequestOrchestration);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRequestOrchestration;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRequestOrchestrations[index : Integer] : TFhirRequestOrchestration read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_REQUESTORCHESTRATION}
{$IFDEF FHIR_RESEARCHSTUDY}
  // Additional names for the study.
  TFhirResearchStudyLabel = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirString;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirString);
    function GetValueST : String;
    procedure SetValueST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchStudyLabel; overload;
    function Clone : TFhirResearchStudyLabel; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Kind of name. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Kind of name.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The name.
    property value : String read GetValueST write SetValueST;
    // The name.
    property valueElement : TFhirString read FValue write SetValue;

  end;

  TFhirResearchStudyLabelListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchStudyLabelList;
    function GetCurrent : TFhirResearchStudyLabel;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirResearchStudyLabelList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchStudyLabel read GetCurrent;
  end;

  TFhirResearchStudyLabelList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirResearchStudyLabel;
    procedure SetItemN(index : Integer; value : TFhirResearchStudyLabel);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirResearchStudyLabelList; overload;
    function Clone : TFhirResearchStudyLabelList; overload;
    function GetEnumerator : TFhirResearchStudyLabelListEnumerator;
    
    //  Add a FhirResearchStudyLabel to the end of the list.
    function Append : TFhirResearchStudyLabel;
    
    // Add an already existing FhirResearchStudyLabel to the end of the list.
    function AddItem(value : TFhirResearchStudyLabel) : TFhirResearchStudyLabel; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchStudyLabel) : Integer;
    
    // Insert FhirResearchStudyLabel before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchStudyLabel;
    
    // Insert an existing FhirResearchStudyLabel before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchStudyLabel);
    
    // Get the iIndexth FhirResearchStudyLabel. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchStudyLabel);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchStudyLabel;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirResearchStudyLabels[index : Integer] : TFhirResearchStudyLabel read GetItemN write SetItemN; default;
  End;

  // The medication(s), food(s), therapy(ies), device(s) or other concerns or interventions that the study is seeking to gain more information about.
  TFhirResearchStudyFocus = class (TFhirBackboneElement)
  protected
    FProductCode : TFhirCodeableConcept;
    FfocusTypeList : TFhirCodeableConceptList;
    FFactor : TFhirMarkdown;
    procedure SetProductCode(value : TFhirCodeableConcept);
    function GetFocusTypeList : TFhirCodeableConceptList;
    function GetHasFocusTypeList : Boolean;
    procedure SetFactor(value : TFhirMarkdown);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchStudyFocus; overload;
    function Clone : TFhirResearchStudyFocus; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identification of product under study.  This may be any combination of code and/or name. (defined for API consistency)
    property productCode : TFhirCodeableConcept read FProductCode write SetProductCode;
    // Identification of product under study.  This may be any combination of code and/or name.
    property productCodeElement : TFhirCodeableConcept read FProductCode write SetProductCode;

    // Indicates whether the focus is a medication, a device, a procedure, a specific factor or some other intervention or characteristic.
    property focusTypeList : TFhirCodeableConceptList read GetFocusTypeList;
    property hasFocusTypeList : boolean read GetHasFocusTypeList;

    // Typed access to A factor corresponds to an independent variable manipulated by the experimentalist with the intention to affect biological systems in a way that can be measured by an assay.
    property factor : String read GetFactorST write SetFactorST;
    // A factor corresponds to an independent variable manipulated by the experimentalist with the intention to affect biological systems in a way that can be measured by an assay.
    property factorElement : TFhirMarkdown read FFactor write SetFactor;

  end;

  TFhirResearchStudyFocusListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchStudyFocusList;
    function GetCurrent : TFhirResearchStudyFocus;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirResearchStudyFocusList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchStudyFocus read GetCurrent;
  end;

  TFhirResearchStudyFocusList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirResearchStudyFocus;
    procedure SetItemN(index : Integer; value : TFhirResearchStudyFocus);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirResearchStudyFocusList; overload;
    function Clone : TFhirResearchStudyFocusList; overload;
    function GetEnumerator : TFhirResearchStudyFocusListEnumerator;
    
    //  Add a FhirResearchStudyFocus to the end of the list.
    function Append : TFhirResearchStudyFocus;
    
    // Add an already existing FhirResearchStudyFocus to the end of the list.
    function AddItem(value : TFhirResearchStudyFocus) : TFhirResearchStudyFocus; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchStudyFocus) : Integer;
    
    // Insert FhirResearchStudyFocus before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchStudyFocus;
    
    // Insert an existing FhirResearchStudyFocus before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchStudyFocus);
    
    // Get the iIndexth FhirResearchStudyFocus. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchStudyFocus);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchStudyFocus;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirResearchStudyFocus[index : Integer] : TFhirResearchStudyFocus read GetItemN write SetItemN; default;
  End;

  // Sponsors, collaborators, and other parties.
  TFhirResearchStudyAssociatedParty = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FRole : TFhirCodeableConcept;
    FperiodList : TFhirPeriodList;
    FclassifierList : TFhirCodeableConceptList;
    FParty : TFhirReference;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetRole(value : TFhirCodeableConcept);
    function GetPeriodList : TFhirPeriodList;
    function GetHasPeriodList : Boolean;
    function GetClassifierList : TFhirCodeableConceptList;
    function GetHasClassifierList : Boolean;
    procedure SetParty(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchStudyAssociatedParty; overload;
    function Clone : TFhirResearchStudyAssociatedParty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Name of associated party.
    property name : String read GetNameST write SetNameST;
    // Name of associated party.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Type of association. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // Type of association.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Identifies the start date and the end date of the associated party in the role.
    property periodList : TFhirPeriodList read GetPeriodList;
    property hasPeriodList : boolean read GetHasPeriodList;

    // A categorization other than role for the associated party.
    property classifierList : TFhirCodeableConceptList read GetClassifierList;
    property hasClassifierList : boolean read GetHasClassifierList;

    // Typed access to Individual or organization associated with study (use practitionerRole to specify their organisation). (defined for API consistency)
    property party : TFhirReference read FParty write SetParty;
    // Individual or organization associated with study (use practitionerRole to specify their organisation).
    property partyElement : TFhirReference read FParty write SetParty;

  end;

  TFhirResearchStudyAssociatedPartyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchStudyAssociatedPartyList;
    function GetCurrent : TFhirResearchStudyAssociatedParty;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirResearchStudyAssociatedPartyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchStudyAssociatedParty read GetCurrent;
  end;

  TFhirResearchStudyAssociatedPartyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirResearchStudyAssociatedParty;
    procedure SetItemN(index : Integer; value : TFhirResearchStudyAssociatedParty);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirResearchStudyAssociatedPartyList; overload;
    function Clone : TFhirResearchStudyAssociatedPartyList; overload;
    function GetEnumerator : TFhirResearchStudyAssociatedPartyListEnumerator;
    
    //  Add a FhirResearchStudyAssociatedParty to the end of the list.
    function Append : TFhirResearchStudyAssociatedParty;
    
    // Add an already existing FhirResearchStudyAssociatedParty to the end of the list.
    function AddItem(value : TFhirResearchStudyAssociatedParty) : TFhirResearchStudyAssociatedParty; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchStudyAssociatedParty) : Integer;
    
    // Insert FhirResearchStudyAssociatedParty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchStudyAssociatedParty;
    
    // Insert an existing FhirResearchStudyAssociatedParty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchStudyAssociatedParty);
    
    // Get the iIndexth FhirResearchStudyAssociatedParty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchStudyAssociatedParty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchStudyAssociatedParty;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirResearchStudyAssociatedParties[index : Integer] : TFhirResearchStudyAssociatedParty read GetItemN write SetItemN; default;
  End;

  // Status of study with time for that status.
  TFhirResearchStudyProgressStatus = class (TFhirBackboneElement)
  protected
    FState : TFhirCodeableConcept;
    FActual : TFhirBoolean;
    FPeriod : TFhirPeriod;
    procedure SetState(value : TFhirCodeableConcept);
    procedure SetActual(value : TFhirBoolean);
    function GetActualST : Boolean;
    procedure SetActualST(value : Boolean);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchStudyProgressStatus; overload;
    function Clone : TFhirResearchStudyProgressStatus; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Label for status or state (e.g. recruitment status). (defined for API consistency)
    property state : TFhirCodeableConcept read FState write SetState;
    // Label for status or state (e.g. recruitment status).
    property stateElement : TFhirCodeableConcept read FState write SetState;

    // Typed access to An indication of whether or not the date is a known date when the state changed or will change. A value of true indicates a known date. A value of false indicates an estimated date.
    property actual : Boolean read GetActualST write SetActualST;
    // An indication of whether or not the date is a known date when the state changed or will change. A value of true indicates a known date. A value of false indicates an estimated date.
    property actualElement : TFhirBoolean read FActual write SetActual;

    // Typed access to Date range. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Date range.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirResearchStudyProgressStatusListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchStudyProgressStatusList;
    function GetCurrent : TFhirResearchStudyProgressStatus;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirResearchStudyProgressStatusList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchStudyProgressStatus read GetCurrent;
  end;

  TFhirResearchStudyProgressStatusList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirResearchStudyProgressStatus;
    procedure SetItemN(index : Integer; value : TFhirResearchStudyProgressStatus);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirResearchStudyProgressStatusList; overload;
    function Clone : TFhirResearchStudyProgressStatusList; overload;
    function GetEnumerator : TFhirResearchStudyProgressStatusListEnumerator;
    
    //  Add a FhirResearchStudyProgressStatus to the end of the list.
    function Append : TFhirResearchStudyProgressStatus;
    
    // Add an already existing FhirResearchStudyProgressStatus to the end of the list.
    function AddItem(value : TFhirResearchStudyProgressStatus) : TFhirResearchStudyProgressStatus; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchStudyProgressStatus) : Integer;
    
    // Insert FhirResearchStudyProgressStatus before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchStudyProgressStatus;
    
    // Insert an existing FhirResearchStudyProgressStatus before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchStudyProgressStatus);
    
    // Get the iIndexth FhirResearchStudyProgressStatus. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchStudyProgressStatus);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchStudyProgressStatus;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirResearchStudyProgressStatuses[index : Integer] : TFhirResearchStudyProgressStatus read GetItemN write SetItemN; default;
  End;

  // Target or actual group of participants enrolled in study.
  TFhirResearchStudyRecruitment = class (TFhirBackboneElement)
  protected
    FTargetNumber : TFhirUnsignedInt;
    FActualNumber : TFhirUnsignedInt;
    FEligibility : TFhirReference;
    FActualGroup : TFhirReference;
    procedure SetTargetNumber(value : TFhirUnsignedInt);
    function GetTargetNumberST : String;
    procedure SetTargetNumberST(value : String);
    procedure SetActualNumber(value : TFhirUnsignedInt);
    function GetActualNumberST : String;
    procedure SetActualNumberST(value : String);
    procedure SetEligibility(value : TFhirReference);
    procedure SetActualGroup(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchStudyRecruitment; overload;
    function Clone : TFhirResearchStudyRecruitment; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Estimated total number of participants to be enrolled.
    property targetNumber : String read GetTargetNumberST write SetTargetNumberST;
    // Estimated total number of participants to be enrolled.
    property targetNumberElement : TFhirUnsignedInt read FTargetNumber write SetTargetNumber;

    // Typed access to Actual total number of participants enrolled in study.
    property actualNumber : String read GetActualNumberST write SetActualNumberST;
    // Actual total number of participants enrolled in study.
    property actualNumberElement : TFhirUnsignedInt read FActualNumber write SetActualNumber;

    // Typed access to Inclusion and exclusion criteria. (defined for API consistency)
    property eligibility : TFhirReference read FEligibility write SetEligibility;
    // Inclusion and exclusion criteria.
    property eligibilityElement : TFhirReference read FEligibility write SetEligibility;

    // Typed access to Group of participants who were enrolled in study. (defined for API consistency)
    property actualGroup : TFhirReference read FActualGroup write SetActualGroup;
    // Group of participants who were enrolled in study.
    property actualGroupElement : TFhirReference read FActualGroup write SetActualGroup;

  end;

  TFhirResearchStudyRecruitmentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchStudyRecruitmentList;
    function GetCurrent : TFhirResearchStudyRecruitment;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirResearchStudyRecruitmentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchStudyRecruitment read GetCurrent;
  end;

  TFhirResearchStudyRecruitmentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirResearchStudyRecruitment;
    procedure SetItemN(index : Integer; value : TFhirResearchStudyRecruitment);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirResearchStudyRecruitmentList; overload;
    function Clone : TFhirResearchStudyRecruitmentList; overload;
    function GetEnumerator : TFhirResearchStudyRecruitmentListEnumerator;
    
    //  Add a FhirResearchStudyRecruitment to the end of the list.
    function Append : TFhirResearchStudyRecruitment;
    
    // Add an already existing FhirResearchStudyRecruitment to the end of the list.
    function AddItem(value : TFhirResearchStudyRecruitment) : TFhirResearchStudyRecruitment; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchStudyRecruitment) : Integer;
    
    // Insert FhirResearchStudyRecruitment before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchStudyRecruitment;
    
    // Insert an existing FhirResearchStudyRecruitment before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchStudyRecruitment);
    
    // Get the iIndexth FhirResearchStudyRecruitment. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchStudyRecruitment);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchStudyRecruitment;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirResearchStudyRecruitments[index : Integer] : TFhirResearchStudyRecruitment read GetItemN write SetItemN; default;
  End;

  // Describes an expected sequence of events for one of the participants of a study.  E.g. Exposure to drug A, wash-out, exposure to drug B, wash-out, follow-up.
  TFhirResearchStudyComparisonGroup = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirDataType;
    FName : TFhirString;
    FType_ : TFhirCodeableConcept;
    FDescription : TFhirMarkdown;
    FintendedExposureList : TFhirReferenceList;
    FObservedGroup : TFhirReference;
    procedure SetIdentifier(value : TFhirDataType);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetIntendedExposureList : TFhirReferenceList;
    function GetHasIntendedExposureList : Boolean;
    procedure SetObservedGroup(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchStudyComparisonGroup; overload;
    function Clone : TFhirResearchStudyComparisonGroup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Allows the comparisonGroup for the study and the comparisonGroup for the subject to be linked easily. (defined for API consistency)
    property identifier : TFhirDataType read FIdentifier write SetIdentifier;
    // Allows the comparisonGroup for the study and the comparisonGroup for the subject to be linked easily.
    property identifierElement : TFhirDataType read FIdentifier write SetIdentifier;

    // Typed access to Unique, human-readable label for this comparisonGroup of the study.
    property name : String read GetNameST write SetNameST;
    // Unique, human-readable label for this comparisonGroup of the study.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Categorization of study comparisonGroup, e.g. experimental, active comparator, placebo comparater. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Categorization of study comparisonGroup, e.g. experimental, active comparator, placebo comparater.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A succinct description of the path through the study that would be followed by a subject adhering to this comparisonGroup.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A succinct description of the path through the study that would be followed by a subject adhering to this comparisonGroup.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Interventions or exposures in this comparisonGroup or cohort.
    property intendedExposureList : TFhirReferenceList read GetIntendedExposureList;
    property hasIntendedExposureList : boolean read GetHasIntendedExposureList;

    // Typed access to Group of participants who were enrolled in study comparisonGroup. (defined for API consistency)
    property observedGroup : TFhirReference read FObservedGroup write SetObservedGroup;
    // Group of participants who were enrolled in study comparisonGroup.
    property observedGroupElement : TFhirReference read FObservedGroup write SetObservedGroup;

  end;

  TFhirResearchStudyComparisonGroupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchStudyComparisonGroupList;
    function GetCurrent : TFhirResearchStudyComparisonGroup;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirResearchStudyComparisonGroupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchStudyComparisonGroup read GetCurrent;
  end;

  TFhirResearchStudyComparisonGroupList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirResearchStudyComparisonGroup;
    procedure SetItemN(index : Integer; value : TFhirResearchStudyComparisonGroup);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirResearchStudyComparisonGroupList; overload;
    function Clone : TFhirResearchStudyComparisonGroupList; overload;
    function GetEnumerator : TFhirResearchStudyComparisonGroupListEnumerator;
    
    //  Add a FhirResearchStudyComparisonGroup to the end of the list.
    function Append : TFhirResearchStudyComparisonGroup;
    
    // Add an already existing FhirResearchStudyComparisonGroup to the end of the list.
    function AddItem(value : TFhirResearchStudyComparisonGroup) : TFhirResearchStudyComparisonGroup; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchStudyComparisonGroup) : Integer;
    
    // Insert FhirResearchStudyComparisonGroup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchStudyComparisonGroup;
    
    // Insert an existing FhirResearchStudyComparisonGroup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchStudyComparisonGroup);
    
    // Get the iIndexth FhirResearchStudyComparisonGroup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchStudyComparisonGroup);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchStudyComparisonGroup;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirResearchStudyComparisonGroups[index : Integer] : TFhirResearchStudyComparisonGroup read GetItemN write SetItemN; default;
  End;

  // A goal that the study is aiming to achieve in terms of a scientific question to be answered by the analysis of data collected during the study.
  TFhirResearchStudyObjective = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FType_ : TFhirCodeableConcept;
    FDescription : TFhirMarkdown;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchStudyObjective; overload;
    function Clone : TFhirResearchStudyObjective; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Unique, human-readable label for this objective of the study.
    property name : String read GetNameST write SetNameST;
    // Unique, human-readable label for this objective of the study.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The kind of study objective. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The kind of study objective.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Free text description of the objective of the study.  This is what the study is trying to achieve rather than how it is going to achieve it (see ResearchStudy.description).
    property description : String read GetDescriptionST write SetDescriptionST;
    // Free text description of the objective of the study.  This is what the study is trying to achieve rather than how it is going to achieve it (see ResearchStudy.description).
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

  end;

  TFhirResearchStudyObjectiveListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchStudyObjectiveList;
    function GetCurrent : TFhirResearchStudyObjective;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirResearchStudyObjectiveList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchStudyObjective read GetCurrent;
  end;

  TFhirResearchStudyObjectiveList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirResearchStudyObjective;
    procedure SetItemN(index : Integer; value : TFhirResearchStudyObjective);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirResearchStudyObjectiveList; overload;
    function Clone : TFhirResearchStudyObjectiveList; overload;
    function GetEnumerator : TFhirResearchStudyObjectiveListEnumerator;
    
    //  Add a FhirResearchStudyObjective to the end of the list.
    function Append : TFhirResearchStudyObjective;
    
    // Add an already existing FhirResearchStudyObjective to the end of the list.
    function AddItem(value : TFhirResearchStudyObjective) : TFhirResearchStudyObjective; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchStudyObjective) : Integer;
    
    // Insert FhirResearchStudyObjective before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchStudyObjective;
    
    // Insert an existing FhirResearchStudyObjective before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchStudyObjective);
    
    // Get the iIndexth FhirResearchStudyObjective. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchStudyObjective);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchStudyObjective;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirResearchStudyObjectives[index : Integer] : TFhirResearchStudyObjective read GetItemN write SetItemN; default;
  End;

  // An outcome or planned variable to measure during the study.
  TFhirResearchStudyOutcomeMeasure = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    Ftype_List : TFhirCodeableConceptList;
    FDescription : TFhirMarkdown;
    FReference : TFhirReference;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetReference(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchStudyOutcomeMeasure; overload;
    function Clone : TFhirResearchStudyOutcomeMeasure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Label for the outcome.
    property name : String read GetNameST write SetNameST;
    // Label for the outcome.
    property nameElement : TFhirString read FName write SetName;

    // The parameter or characteristic being assessed as one of the values by which the study is assessed.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to Description of the outcome.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Description of the outcome.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to Structured outcome definition. (defined for API consistency)
    property reference : TFhirReference read FReference write SetReference;
    // Structured outcome definition.
    property referenceElement : TFhirReference read FReference write SetReference;

  end;

  TFhirResearchStudyOutcomeMeasureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchStudyOutcomeMeasureList;
    function GetCurrent : TFhirResearchStudyOutcomeMeasure;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirResearchStudyOutcomeMeasureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchStudyOutcomeMeasure read GetCurrent;
  end;

  TFhirResearchStudyOutcomeMeasureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirResearchStudyOutcomeMeasure;
    procedure SetItemN(index : Integer; value : TFhirResearchStudyOutcomeMeasure);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirResearchStudyOutcomeMeasureList; overload;
    function Clone : TFhirResearchStudyOutcomeMeasureList; overload;
    function GetEnumerator : TFhirResearchStudyOutcomeMeasureListEnumerator;
    
    //  Add a FhirResearchStudyOutcomeMeasure to the end of the list.
    function Append : TFhirResearchStudyOutcomeMeasure;
    
    // Add an already existing FhirResearchStudyOutcomeMeasure to the end of the list.
    function AddItem(value : TFhirResearchStudyOutcomeMeasure) : TFhirResearchStudyOutcomeMeasure; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchStudyOutcomeMeasure) : Integer;
    
    // Insert FhirResearchStudyOutcomeMeasure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchStudyOutcomeMeasure;
    
    // Insert an existing FhirResearchStudyOutcomeMeasure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchStudyOutcomeMeasure);
    
    // Get the iIndexth FhirResearchStudyOutcomeMeasure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchStudyOutcomeMeasure);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchStudyOutcomeMeasure;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirResearchStudyOutcomeMeasures[index : Integer] : TFhirResearchStudyOutcomeMeasure read GetItemN write SetItemN; default;
  End;

  // A general storage or archive location for the study.  This may contain an assortment of content which is not specified in advance.
  TFhirResearchStudyWebLocation = class (TFhirBackboneElement)
  protected
    FClassifier : TFhirCodeableConcept;
    FUrl : TFhirUri;
    procedure SetClassifier(value : TFhirCodeableConcept);
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchStudyWebLocation; overload;
    function Clone : TFhirResearchStudyWebLocation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Describes the nature of the location being specified. (defined for API consistency)
    property classifier : TFhirCodeableConcept read FClassifier write SetClassifier;
    // Describes the nature of the location being specified.
    property classifierElement : TFhirCodeableConcept read FClassifier write SetClassifier;

    // Typed access to The location address.
    property url : String read GetUrlST write SetUrlST;
    // The location address.
    property urlElement : TFhirUri read FUrl write SetUrl;

  end;

  TFhirResearchStudyWebLocationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchStudyWebLocationList;
    function GetCurrent : TFhirResearchStudyWebLocation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirResearchStudyWebLocationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchStudyWebLocation read GetCurrent;
  end;

  TFhirResearchStudyWebLocationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirResearchStudyWebLocation;
    procedure SetItemN(index : Integer; value : TFhirResearchStudyWebLocation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirResearchStudyWebLocationList; overload;
    function Clone : TFhirResearchStudyWebLocationList; overload;
    function GetEnumerator : TFhirResearchStudyWebLocationListEnumerator;
    
    //  Add a FhirResearchStudyWebLocation to the end of the list.
    function Append : TFhirResearchStudyWebLocation;
    
    // Add an already existing FhirResearchStudyWebLocation to the end of the list.
    function AddItem(value : TFhirResearchStudyWebLocation) : TFhirResearchStudyWebLocation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchStudyWebLocation) : Integer;
    
    // Insert FhirResearchStudyWebLocation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchStudyWebLocation;
    
    // Insert an existing FhirResearchStudyWebLocation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchStudyWebLocation);
    
    // Get the iIndexth FhirResearchStudyWebLocation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchStudyWebLocation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchStudyWebLocation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirResearchStudyWebLocations[index : Integer] : TFhirResearchStudyWebLocation read GetItemN write SetItemN; default;
  End;

  // A scientific study of nature that sometimes includes processes involved in health and disease. For example, clinical trials are research studies that involve people. These studies may be related to new ways to screen, prevent, diagnose, and treat disease. They may also study certain outcomes and certain groups of people by looking at data collected in the past or future.
  TFhirResearchStudy = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FidentifierList : TFhirIdentifierList;
    FVersion : TFhirString;
    FName : TFhirString;
    FTitle : TFhirString;
    Flabel_List : TFhirResearchStudyLabelList;
    FprotocolList : TFhirReferenceList;
    FpartOfList : TFhirReferenceList;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    FDate : TFhirDateTime;
    FStatus : TFhirEnum;
    FPrimaryPurposeType : TFhirCodeableConcept;
    FPhase : TFhirCodeableConcept;
    FstudyDesignList : TFhirCodeableConceptList;
    FfocusList : TFhirResearchStudyFocusList;
    FconditionList : TFhirCodeableConceptList;
    FkeywordList : TFhirCodeableConceptList;
    FregionList : TFhirCodeableConceptList;
    FDescriptionSummary : TFhirMarkdown;
    FDescription : TFhirMarkdown;
    FPeriod : TFhirPeriod;
    FsiteList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    FclassifierList : TFhirCodeableConceptList;
    FassociatedPartyList : TFhirResearchStudyAssociatedPartyList;
    FprogressStatusList : TFhirResearchStudyProgressStatusList;
    FWhyStopped : TFhirCodeableConcept;
    FRecruitment : TFhirResearchStudyRecruitment;
    FcomparisonGroupList : TFhirResearchStudyComparisonGroupList;
    FobjectiveList : TFhirResearchStudyObjectiveList;
    FoutcomeMeasureList : TFhirResearchStudyOutcomeMeasureList;
    FresultList : TFhirReferenceList;
    FwebLocationList : TFhirResearchStudyWebLocationList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    function GetLabel_List : TFhirResearchStudyLabelList;
    function GetHasLabel_List : Boolean;
    function GetProtocolList : TFhirReferenceList;
    function GetHasProtocolList : Boolean;
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetPrimaryPurposeType(value : TFhirCodeableConcept);
    procedure SetPhase(value : TFhirCodeableConcept);
    function GetStudyDesignList : TFhirCodeableConceptList;
    function GetHasStudyDesignList : Boolean;
    function GetFocusList : TFhirResearchStudyFocusList;
    function GetHasFocusList : Boolean;
    function GetConditionList : TFhirCodeableConceptList;
    function GetHasConditionList : Boolean;
    function GetKeywordList : TFhirCodeableConceptList;
    function GetHasKeywordList : Boolean;
    function GetRegionList : TFhirCodeableConceptList;
    function GetHasRegionList : Boolean;
    procedure SetDescriptionSummary(value : TFhirMarkdown);
    function GetDescriptionSummaryST : String;
    procedure SetDescriptionSummaryST(value : String);
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetPeriod(value : TFhirPeriod);
    function GetSiteList : TFhirReferenceList;
    function GetHasSiteList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetClassifierList : TFhirCodeableConceptList;
    function GetHasClassifierList : Boolean;
    function GetAssociatedPartyList : TFhirResearchStudyAssociatedPartyList;
    function GetHasAssociatedPartyList : Boolean;
    function GetProgressStatusList : TFhirResearchStudyProgressStatusList;
    function GetHasProgressStatusList : Boolean;
    procedure SetWhyStopped(value : TFhirCodeableConcept);
    procedure SetRecruitment(value : TFhirResearchStudyRecruitment);
    function GetComparisonGroupList : TFhirResearchStudyComparisonGroupList;
    function GetHasComparisonGroupList : Boolean;
    function GetObjectiveList : TFhirResearchStudyObjectiveList;
    function GetHasObjectiveList : Boolean;
    function GetOutcomeMeasureList : TFhirResearchStudyOutcomeMeasureList;
    function GetHasOutcomeMeasureList : Boolean;
    function GetResultList : TFhirReferenceList;
    function GetHasResultList : Boolean;
    function GetWebLocationList : TFhirResearchStudyWebLocationList;
    function GetHasWebLocationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchStudy; overload;
    function Clone : TFhirResearchStudy; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Canonical identifier for this study resource, represented as a globally unique URI.
    property url : String read GetUrlST write SetUrlST;
    // Canonical identifier for this study resource, represented as a globally unique URI.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Identifiers assigned to this research study by the sponsor or other systems.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The business version for the study record.
    property version : String read GetVersionST write SetVersionST;
    // The business version for the study record.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to Name for this study (computer friendly).
    property name : String read GetNameST write SetNameST;
    // Name for this study (computer friendly).
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The human readable name of the research study.
    property title : String read GetTitleST write SetTitleST;
    // The human readable name of the research study.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Additional names for the study.
    property label_List : TFhirResearchStudyLabelList read GetLabel_List;
    property hasLabel_List : boolean read GetHasLabel_List;

    // The set of steps expected to be performed as part of the execution of the study.
    property protocolList : TFhirReferenceList read GetProtocolList;
    property hasProtocolList : boolean read GetHasProtocolList;

    // A larger research study of which this particular study is a component or step.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // Citations, references and other related documents.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // Typed access to The date (and optionally time) when the ResearchStudy Resource was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the ResearchStudy Resource changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date (and optionally time) when the ResearchStudy Resource was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the ResearchStudy Resource changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // The publication state of the resource (not of the study).
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The type of study based upon the intent of the study activities. A classification of the intent of the study. (defined for API consistency)
    property primaryPurposeType : TFhirCodeableConcept read FPrimaryPurposeType write SetPrimaryPurposeType;
    // The type of study based upon the intent of the study activities. A classification of the intent of the study.
    property primaryPurposeTypeElement : TFhirCodeableConcept read FPrimaryPurposeType write SetPrimaryPurposeType;

    // Typed access to The stage in the progression of a therapy from initial experimental use in humans in clinical trials to post-market evaluation. (defined for API consistency)
    property phase : TFhirCodeableConcept read FPhase write SetPhase;
    // The stage in the progression of a therapy from initial experimental use in humans in clinical trials to post-market evaluation.
    property phaseElement : TFhirCodeableConcept read FPhase write SetPhase;

    // Codes categorizing the type of study such as investigational vs. observational, type of blinding, type of randomization, safety vs. efficacy, etc.
    property studyDesignList : TFhirCodeableConceptList read GetStudyDesignList;
    property hasStudyDesignList : boolean read GetHasStudyDesignList;

    // The medication(s), food(s), therapy(ies), device(s) or other concerns or interventions that the study is seeking to gain more information about.
    property focusList : TFhirResearchStudyFocusList read GetFocusList;
    property hasFocusList : boolean read GetHasFocusList;

    // The condition that is the focus of the study.  For example, In a study to examine risk factors for Lupus, might have as an inclusion criterion "healthy volunteer", but the target condition code would be a Lupus SNOMED code.
    property conditionList : TFhirCodeableConceptList read GetConditionList;
    property hasConditionList : boolean read GetHasConditionList;

    // Key terms to aid in searching for or filtering the study.
    property keywordList : TFhirCodeableConceptList read GetKeywordList;
    property hasKeywordList : boolean read GetHasKeywordList;

    // A country, state or other area where the study is taking place rather than its precise geographic location or address.
    property regionList : TFhirCodeableConceptList read GetRegionList;
    property hasRegionList : boolean read GetHasRegionList;

    // Typed access to A brief text for explaining the study.
    property descriptionSummary : String read GetDescriptionSummaryST write SetDescriptionSummaryST;
    // A brief text for explaining the study.
    property descriptionSummaryElement : TFhirMarkdown read FDescriptionSummary write SetDescriptionSummary;

    // Typed access to A detailed and human-readable narrative of the study. E.g., study abstract.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A detailed and human-readable narrative of the study. E.g., study abstract.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to Identifies the start date and the expected (or actual, depending on status) end date for the study. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Identifies the start date and the expected (or actual, depending on status) end date for the study.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // A facility in which study activities are conducted.
    property siteList : TFhirReferenceList read GetSiteList;
    property hasSiteList : boolean read GetHasSiteList;

    // Comments made about the study by the performer, subject or other participants.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Additional grouping mechanism or categorization of a research study. Example: FDA regulated device, FDA regulated drug, MPG Paragraph 23b (a German legal requirement), IRB-exempt, etc. Implementation Note: do not use the classifier element to support existing semantics that are already supported thru explicit elements in the resource.
    property classifierList : TFhirCodeableConceptList read GetClassifierList;
    property hasClassifierList : boolean read GetHasClassifierList;

    // Sponsors, collaborators, and other parties.
    property associatedPartyList : TFhirResearchStudyAssociatedPartyList read GetAssociatedPartyList;
    property hasAssociatedPartyList : boolean read GetHasAssociatedPartyList;

    // Status of study with time for that status.
    property progressStatusList : TFhirResearchStudyProgressStatusList read GetProgressStatusList;
    property hasProgressStatusList : boolean read GetHasProgressStatusList;

    // Typed access to A description and/or code explaining the premature termination of the study. (defined for API consistency)
    property whyStopped : TFhirCodeableConcept read FWhyStopped write SetWhyStopped;
    // A description and/or code explaining the premature termination of the study.
    property whyStoppedElement : TFhirCodeableConcept read FWhyStopped write SetWhyStopped;

    // Typed access to Target or actual group of participants enrolled in study. (defined for API consistency)
    property recruitment : TFhirResearchStudyRecruitment read FRecruitment write SetRecruitment;
    // Target or actual group of participants enrolled in study.
    property recruitmentElement : TFhirResearchStudyRecruitment read FRecruitment write SetRecruitment;

    // Describes an expected sequence of events for one of the participants of a study.  E.g. Exposure to drug A, wash-out, exposure to drug B, wash-out, follow-up.
    property comparisonGroupList : TFhirResearchStudyComparisonGroupList read GetComparisonGroupList;
    property hasComparisonGroupList : boolean read GetHasComparisonGroupList;

    // A goal that the study is aiming to achieve in terms of a scientific question to be answered by the analysis of data collected during the study.
    property objectiveList : TFhirResearchStudyObjectiveList read GetObjectiveList;
    property hasObjectiveList : boolean read GetHasObjectiveList;

    // An outcome or planned variable to measure during the study.
    property outcomeMeasureList : TFhirResearchStudyOutcomeMeasureList read GetOutcomeMeasureList;
    property hasOutcomeMeasureList : boolean read GetHasOutcomeMeasureList;

    // Link to one or more sets of results generated by the study.  Could also link to a research registry holding the results such as ClinicalTrials.gov.
    property resultList : TFhirReferenceList read GetResultList;
    property hasResultList : boolean read GetHasResultList;

    // A general storage or archive location for the study.  This may contain an assortment of content which is not specified in advance.
    property webLocationList : TFhirResearchStudyWebLocationList read GetWebLocationList;
    property hasWebLocationList : boolean read GetHasWebLocationList;

  end;

  TFhirResearchStudyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchStudyList;
    function GetCurrent : TFhirResearchStudy;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirResearchStudyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchStudy read GetCurrent;
  end;

  TFhirResearchStudyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirResearchStudy;
    procedure SetItemN(index : Integer; value : TFhirResearchStudy);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirResearchStudyList; overload;
    function Clone : TFhirResearchStudyList; overload;
    function GetEnumerator : TFhirResearchStudyListEnumerator;
    
    //  Add a FhirResearchStudy to the end of the list.
    function Append : TFhirResearchStudy;
    
    // Add an already existing FhirResearchStudy to the end of the list.
    function AddItem(value : TFhirResearchStudy) : TFhirResearchStudy; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchStudy) : Integer;
    
    // Insert FhirResearchStudy before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchStudy;
    
    // Insert an existing FhirResearchStudy before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchStudy);
    
    // Get the iIndexth FhirResearchStudy. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchStudy);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchStudy;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirResearchStudies[index : Integer] : TFhirResearchStudy read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
  // The current state (status) of the subject and resons for status change where appropriate.
  TFhirResearchSubjectProgress = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FSubjectState : TFhirCodeableConcept;
    FMilestone : TFhirCodeableConcept;
    FReason : TFhirCodeableConcept;
    FStartDate : TFhirDateTime;
    FEndDate : TFhirDateTime;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSubjectState(value : TFhirCodeableConcept);
    procedure SetMilestone(value : TFhirCodeableConcept);
    procedure SetReason(value : TFhirCodeableConcept);
    procedure SetStartDate(value : TFhirDateTime);
    function GetStartDateST : TFslDateTime;
    procedure SetStartDateST(value : TFslDateTime);
    procedure SetEndDate(value : TFhirDateTime);
    function GetEndDateST : TFslDateTime;
    procedure SetEndDateST(value : TFslDateTime);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchSubjectProgress; overload;
    function Clone : TFhirResearchSubjectProgress; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifies the aspect of the subject's journey that the state refers to. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Identifies the aspect of the subject's journey that the state refers to.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The current state of the subject. (defined for API consistency)
    property subjectState : TFhirCodeableConcept read FSubjectState write SetSubjectState;
    // The current state of the subject.
    property subjectStateElement : TFhirCodeableConcept read FSubjectState write SetSubjectState;

    // Typed access to The milestones the subject has passed through. (defined for API consistency)
    property milestone : TFhirCodeableConcept read FMilestone write SetMilestone;
    // The milestones the subject has passed through.
    property milestoneElement : TFhirCodeableConcept read FMilestone write SetMilestone;

    // Typed access to The reason for the state change.  If coded it should follow the formal subject state model. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // The reason for the state change.  If coded it should follow the formal subject state model.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

    // Typed access to The date when the new status started.
    property startDate : TFslDateTime read GetStartDateST write SetStartDateST;
    // The date when the new status started.
    property startDateElement : TFhirDateTime read FStartDate write SetStartDate;

    // Typed access to The date when the state ended.
    property endDate : TFslDateTime read GetEndDateST write SetEndDateST;
    // The date when the state ended.
    property endDateElement : TFhirDateTime read FEndDate write SetEndDate;

  end;

  TFhirResearchSubjectProgressListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchSubjectProgressList;
    function GetCurrent : TFhirResearchSubjectProgress;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirResearchSubjectProgressList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchSubjectProgress read GetCurrent;
  end;

  TFhirResearchSubjectProgressList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirResearchSubjectProgress;
    procedure SetItemN(index : Integer; value : TFhirResearchSubjectProgress);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirResearchSubjectProgressList; overload;
    function Clone : TFhirResearchSubjectProgressList; overload;
    function GetEnumerator : TFhirResearchSubjectProgressListEnumerator;
    
    //  Add a FhirResearchSubjectProgress to the end of the list.
    function Append : TFhirResearchSubjectProgress;
    
    // Add an already existing FhirResearchSubjectProgress to the end of the list.
    function AddItem(value : TFhirResearchSubjectProgress) : TFhirResearchSubjectProgress; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchSubjectProgress) : Integer;
    
    // Insert FhirResearchSubjectProgress before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchSubjectProgress;
    
    // Insert an existing FhirResearchSubjectProgress before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchSubjectProgress);
    
    // Get the iIndexth FhirResearchSubjectProgress. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchSubjectProgress);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchSubjectProgress;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirResearchSubjectProgresses[index : Integer] : TFhirResearchSubjectProgress read GetItemN write SetItemN; default;
  End;

  // A physical entity which is the primary unit of operational and/or administrative interest in a study.
  TFhirResearchSubject = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FprogressList : TFhirResearchSubjectProgressList;
    FPeriod : TFhirPeriod;
    FStudy : TFhirReference;
    FSubject : TFhirReference;
    FAssignedArm : TFhirString;
    FActualArm : TFhirString;
    FConsent : TFhirReference;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    function GetProgressList : TFhirResearchSubjectProgressList;
    function GetHasProgressList : Boolean;
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetStudy(value : TFhirReference);
    procedure SetSubject(value : TFhirReference);
    procedure SetAssignedArm(value : TFhirString);
    function GetAssignedArmST : String;
    procedure SetAssignedArmST(value : String);
    procedure SetActualArm(value : TFhirString);
    function GetActualArmST : String;
    procedure SetActualArmST(value : String);
    procedure SetConsent(value : TFhirReference);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchSubject; overload;
    function Clone : TFhirResearchSubject; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers assigned to this research subject for a study.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The publication state of the resource (not of the subject).
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The current state (status) of the subject and resons for status change where appropriate.
    property progressList : TFhirResearchSubjectProgressList read GetProgressList;
    property hasProgressList : boolean read GetHasProgressList;

    // Typed access to The dates the subject began and ended their participation in the study. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The dates the subject began and ended their participation in the study.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Reference to the study the subject is participating in. (defined for API consistency)
    property study : TFhirReference read FStudy write SetStudy;
    // Reference to the study the subject is participating in.
    property studyElement : TFhirReference read FStudy write SetStudy;

    // Typed access to The record of the person, animal or other entity involved in the study. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The record of the person, animal or other entity involved in the study.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The name of the arm in the study the subject is expected to follow as part of this study.
    property assignedArm : String read GetAssignedArmST write SetAssignedArmST;
    // The name of the arm in the study the subject is expected to follow as part of this study.
    property assignedArmElement : TFhirString read FAssignedArm write SetAssignedArm;

    // Typed access to The name of the arm in the study the subject actually followed as part of this study.
    property actualArm : String read GetActualArmST write SetActualArmST;
    // The name of the arm in the study the subject actually followed as part of this study.
    property actualArmElement : TFhirString read FActualArm write SetActualArm;

    // Typed access to A record of the patient's informed agreement to participate in the study. (defined for API consistency)
    property consent : TFhirReference read FConsent write SetConsent;
    // A record of the patient's informed agreement to participate in the study.
    property consentElement : TFhirReference read FConsent write SetConsent;

  end;

  TFhirResearchSubjectListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchSubjectList;
    function GetCurrent : TFhirResearchSubject;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirResearchSubjectList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchSubject read GetCurrent;
  end;

  TFhirResearchSubjectList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirResearchSubject;
    procedure SetItemN(index : Integer; value : TFhirResearchSubject);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirResearchSubjectList; overload;
    function Clone : TFhirResearchSubjectList; overload;
    function GetEnumerator : TFhirResearchSubjectListEnumerator;
    
    //  Add a FhirResearchSubject to the end of the list.
    function Append : TFhirResearchSubject;
    
    // Add an already existing FhirResearchSubject to the end of the list.
    function AddItem(value : TFhirResearchSubject) : TFhirResearchSubject; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchSubject) : Integer;
    
    // Insert FhirResearchSubject before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchSubject;
    
    // Insert an existing FhirResearchSubject before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchSubject);
    
    // Get the iIndexth FhirResearchSubject. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchSubject);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchSubject;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirResearchSubjects[index : Integer] : TFhirResearchSubject read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_SUBSCRIPTION}
  // The filter properties to be applied to narrow the subscription topic stream.  When multiple filters are applied, evaluates to true if all the conditions are met; otherwise it returns false.   (i.e., logical AND).
  TFhirSubscriptionFilterBy = class (TFhirBackboneElement)
  protected
    FResourceType : TFhirUri;
    FFilterParameter : TFhirString;
    FModifier : TFhirEnum;
    FValue : TFhirString;
    procedure SetResourceType(value : TFhirUri);
    function GetResourceTypeST : String;
    procedure SetResourceTypeST(value : String);
    procedure SetFilterParameter(value : TFhirString);
    function GetFilterParameterST : String;
    procedure SetFilterParameterST(value : String);
    procedure SetModifier(value : TFhirEnum);
    function GetModifierST : TFhirSubscriptionSearchModifierEnum;
    procedure SetModifierST(value : TFhirSubscriptionSearchModifierEnum);
    procedure SetValue(value : TFhirString);
    function GetValueST : String;
    procedure SetValueST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscriptionFilterBy; overload;
    function Clone : TFhirSubscriptionFilterBy; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to If the element is a reference to another resource, this element contains "Reference", and the targetProfile element defines what resources can be referenced. The targetProfile may be a reference to the general definition of a resource (e.g. http://hl7.org/fhir/StructureDefinition/Patient).
    property resourceType : String read GetResourceTypeST write SetResourceTypeST;
    // If the element is a reference to another resource, this element contains "Reference", and the targetProfile element defines what resources can be referenced. The targetProfile may be a reference to the general definition of a resource (e.g. http://hl7.org/fhir/StructureDefinition/Patient).
    property resourceTypeElement : TFhirUri read FResourceType write SetResourceType;

    // Typed access to The filter as defined in the `SubscriptionTopic.canfilterBy.filterParameter` element.
    property filterParameter : String read GetFilterParameterST write SetFilterParameterST;
    // The filter as defined in the `SubscriptionTopic.canfilterBy.filterParameter` element.
    property filterParameterElement : TFhirString read FFilterParameter write SetFilterParameter;

    // Operator to apply when determining matches (Search Modifiers), from the list of allowed modifiers for this filter in the relevant SubscriptionTopic.
    property modifier : TFhirSubscriptionSearchModifierEnum read GetModifierST write SetModifierST;
    property modifierElement : TFhirEnum read FModifier write SetModifier;

    // Typed access to The literal value or resource path as is legal in search - for example, "Patient/123" or "le1950".
    property value : String read GetValueST write SetValueST;
    // The literal value or resource path as is legal in search - for example, "Patient/123" or "le1950".
    property valueElement : TFhirString read FValue write SetValue;

  end;

  TFhirSubscriptionFilterByListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionFilterByList;
    function GetCurrent : TFhirSubscriptionFilterBy;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionFilterByList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscriptionFilterBy read GetCurrent;
  end;

  TFhirSubscriptionFilterByList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubscriptionFilterBy;
    procedure SetItemN(index : Integer; value : TFhirSubscriptionFilterBy);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubscriptionFilterByList; overload;
    function Clone : TFhirSubscriptionFilterByList; overload;
    function GetEnumerator : TFhirSubscriptionFilterByListEnumerator;
    
    //  Add a FhirSubscriptionFilterBy to the end of the list.
    function Append : TFhirSubscriptionFilterBy;
    
    // Add an already existing FhirSubscriptionFilterBy to the end of the list.
    function AddItem(value : TFhirSubscriptionFilterBy) : TFhirSubscriptionFilterBy; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscriptionFilterBy) : Integer;
    
    // Insert FhirSubscriptionFilterBy before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscriptionFilterBy;
    
    // Insert an existing FhirSubscriptionFilterBy before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscriptionFilterBy);
    
    // Get the iIndexth FhirSubscriptionFilterBy. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscriptionFilterBy);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscriptionFilterBy;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubscriptionFilterBies[index : Integer] : TFhirSubscriptionFilterBy read GetItemN write SetItemN; default;
  End;

  // The subscription resource describes a particular client's request to be notified about a SubscriptionTopic.
  TFhirSubscription = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FName : TFhirString;
    FStatus : TFhirEnum;
    FTopic : TFhirCanonical;
    FcontactList : TFhirContactPointList;
    FEnd_ : TFhirInstant;
    FManagingEntity : TFhirReference;
    FReason : TFhirString;
    FfilterByList : TFhirSubscriptionFilterByList;
    FChannelType : TFhirCoding;
    FEndpoint : TFhirUrl;
    FheaderList : TFhirStringList;
    FHeartbeatPeriod : TFhirUnsignedInt;
    FTimeout : TFhirUnsignedInt;
    FContentType : TFhirCode;
    FContent : TFhirEnum;
    FMaxCount : TFhirPositiveInt;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirSubscriptionStatusCodesEnum;
    procedure SetStatusST(value : TFhirSubscriptionStatusCodesEnum);
    procedure SetTopic(value : TFhirCanonical);
    function GetTopicST : String;
    procedure SetTopicST(value : String);
    function GetContactList : TFhirContactPointList;
    function GetHasContactList : Boolean;
    procedure SetEnd_(value : TFhirInstant);
    function GetEnd_ST : TFslDateTime;
    procedure SetEnd_ST(value : TFslDateTime);
    procedure SetManagingEntity(value : TFhirReference);
    procedure SetReason(value : TFhirString);
    function GetReasonST : String;
    procedure SetReasonST(value : String);
    function GetFilterByList : TFhirSubscriptionFilterByList;
    function GetHasFilterByList : Boolean;
    procedure SetChannelType(value : TFhirCoding);
    procedure SetEndpoint(value : TFhirUrl);
    function GetEndpointST : String;
    procedure SetEndpointST(value : String);
    function GetHeaderList : TFhirStringList;
    function GetHasHeaderList : Boolean;
    procedure SetHeartbeatPeriod(value : TFhirUnsignedInt);
    function GetHeartbeatPeriodST : String;
    procedure SetHeartbeatPeriodST(value : String);
    procedure SetTimeout(value : TFhirUnsignedInt);
    function GetTimeoutST : String;
    procedure SetTimeoutST(value : String);
    procedure SetContentType(value : TFhirCode);
    function GetContentTypeST : String;
    procedure SetContentTypeST(value : String);
    procedure SetContent(value : TFhirEnum);
    function GetContentST : TFhirSubscriptionPayloadContentEnum;
    procedure SetContentST(value : TFhirSubscriptionPayloadContentEnum);
    procedure SetMaxCount(value : TFhirPositiveInt);
    function GetMaxCountST : String;
    procedure SetMaxCountST(value : String);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscription; overload;
    function Clone : TFhirSubscription; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A formal identifier that is used to identify this code system when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to A natural language name identifying the subscription.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the subscription.
    property nameElement : TFhirString read FName write SetName;

    // The status of the subscription, which marks the server state for managing the subscription.
    property status : TFhirSubscriptionStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The reference to the subscription topic to be notified about.
    property topic : String read GetTopicST write SetTopicST;
    // The reference to the subscription topic to be notified about.
    property topicElement : TFhirCanonical read FTopic write SetTopic;

    // Contact details for a human to contact about the subscription. The primary use of this for system administrator troubleshooting.
    property contactList : TFhirContactPointList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to The time for the server to turn the subscription off.
    property end_ : TFslDateTime read GetEnd_ST write SetEnd_ST;
    // The time for the server to turn the subscription off.
    property end_Element : TFhirInstant read FEnd_ write SetEnd_;

    // Typed access to Entity with authorization to make subsequent revisions to the Subscription and also determines what data the subscription is authorized to disclose. (defined for API consistency)
    property managingEntity : TFhirReference read FManagingEntity write SetManagingEntity;
    // Entity with authorization to make subsequent revisions to the Subscription and also determines what data the subscription is authorized to disclose.
    property managingEntityElement : TFhirReference read FManagingEntity write SetManagingEntity;

    // Typed access to A description of why this subscription is defined.
    property reason : String read GetReasonST write SetReasonST;
    // A description of why this subscription is defined.
    property reasonElement : TFhirString read FReason write SetReason;

    // The filter properties to be applied to narrow the subscription topic stream.  When multiple filters are applied, evaluates to true if all the conditions are met; otherwise it returns false.   (i.e., logical AND).
    property filterByList : TFhirSubscriptionFilterByList read GetFilterByList;
    property hasFilterByList : boolean read GetHasFilterByList;

    // Typed access to The type of channel to send notifications on. (defined for API consistency)
    property channelType : TFhirCoding read FChannelType write SetChannelType;
    // The type of channel to send notifications on.
    property channelTypeElement : TFhirCoding read FChannelType write SetChannelType;

    // Typed access to The url that describes the actual end-point to send messages to.
    property endpoint : String read GetEndpointST write SetEndpointST;
    // The url that describes the actual end-point to send messages to.
    property endpointElement : TFhirUrl read FEndpoint write SetEndpoint;

    // Additional headers / information to send as part of the notification.
    property headerList : TFhirStringList read GetHeaderList;
    property hasHeaderList : boolean read GetHasHeaderList;

    // Typed access to If present,  a 'hearbeat" notification (keepalive) is sent via this channel with an the interval period equal to this elements integer value in seconds.    If not present, a heartbeat notification is not sent.
    property heartbeatPeriod : String read GetHeartbeatPeriodST write SetHeartbeatPeriodST;
    // If present,  a 'hearbeat" notification (keepalive) is sent via this channel with an the interval period equal to this elements integer value in seconds.    If not present, a heartbeat notification is not sent.
    property heartbeatPeriodElement : TFhirUnsignedInt read FHeartbeatPeriod write SetHeartbeatPeriod;

    // Typed access to If present, the maximum amount of time a server will allow before failing a notification attempt.
    property timeout : String read GetTimeoutST write SetTimeoutST;
    // If present, the maximum amount of time a server will allow before failing a notification attempt.
    property timeoutElement : TFhirUnsignedInt read FTimeout write SetTimeout;

    // Typed access to The mime type to send the payload in - either application/fhir+xml, or application/fhir+json. The MIME types "text/plain" and "text/html" may also be used for Email subscriptions.
    property contentType : String read GetContentTypeST write SetContentTypeST;
    // The mime type to send the payload in - either application/fhir+xml, or application/fhir+json. The MIME types "text/plain" and "text/html" may also be used for Email subscriptions.
    property contentTypeElement : TFhirCode read FContentType write SetContentType;

    // How much of the resource content to deliver in the notification payload. The choices are an empty payload, only the resource id, or the full resource content.
    property content : TFhirSubscriptionPayloadContentEnum read GetContentST write SetContentST;
    property contentElement : TFhirEnum read FContent write SetContent;

    // Typed access to If present, the maximum number of triggering resources that will be included in a notification bundle (e.g., a server will not include more than this number of trigger resources in a single notification).  Note that this is not a strict limit on the number of entries in a bundle, as dependent resources can be included.
    property maxCount : String read GetMaxCountST write SetMaxCountST;
    // If present, the maximum number of triggering resources that will be included in a notification bundle (e.g., a server will not include more than this number of trigger resources in a single notification).  Note that this is not a strict limit on the number of entries in a bundle, as dependent resources can be included.
    property maxCountElement : TFhirPositiveInt read FMaxCount write SetMaxCount;

  end;

  TFhirSubscriptionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionList;
    function GetCurrent : TFhirSubscription;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscription read GetCurrent;
  end;

  TFhirSubscriptionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubscription;
    procedure SetItemN(index : Integer; value : TFhirSubscription);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubscriptionList; overload;
    function Clone : TFhirSubscriptionList; overload;
    function GetEnumerator : TFhirSubscriptionListEnumerator;
    
    //  Add a FhirSubscription to the end of the list.
    function Append : TFhirSubscription;
    
    // Add an already existing FhirSubscription to the end of the list.
    function AddItem(value : TFhirSubscription) : TFhirSubscription; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscription) : Integer;
    
    // Insert FhirSubscription before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscription;
    
    // Insert an existing FhirSubscription before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscription);
    
    // Get the iIndexth FhirSubscription. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscription);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscription;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubscriptions[index : Integer] : TFhirSubscription read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSCRIPTIONSTATUS}
  // Detailed information about events relevant to this subscription notification.
  TFhirSubscriptionStatusNotificationEvent = class (TFhirBackboneElement)
  protected
    FEventNumber : TFhirInteger64;
    FTimestamp : TFhirInstant;
    FFocus : TFhirReference;
    FadditionalContextList : TFhirReferenceList;
    procedure SetEventNumber(value : TFhirInteger64);
    function GetEventNumberST : String;
    procedure SetEventNumberST(value : String);
    procedure SetTimestamp(value : TFhirInstant);
    function GetTimestampST : TFslDateTime;
    procedure SetTimestampST(value : TFslDateTime);
    procedure SetFocus(value : TFhirReference);
    function GetAdditionalContextList : TFhirReferenceList;
    function GetHasAdditionalContextList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscriptionStatusNotificationEvent; overload;
    function Clone : TFhirSubscriptionStatusNotificationEvent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The sequential number of this event in this subscription context.
    property eventNumber : String read GetEventNumberST write SetEventNumberST;
    // The sequential number of this event in this subscription context.
    property eventNumberElement : TFhirInteger64 read FEventNumber write SetEventNumber;

    // Typed access to The actual time this event occured on the server.
    property timestamp : TFslDateTime read GetTimestampST write SetTimestampST;
    // The actual time this event occured on the server.
    property timestampElement : TFhirInstant read FTimestamp write SetTimestamp;

    // Typed access to The focus of this event. While this will usually be a reference to the focus resource of the event, it MAY contain a reference to a non-FHIR object. (defined for API consistency)
    property focus : TFhirReference read FFocus write SetFocus;
    // The focus of this event. While this will usually be a reference to the focus resource of the event, it MAY contain a reference to a non-FHIR object.
    property focusElement : TFhirReference read FFocus write SetFocus;

    // Additional context information for this event. Generally, this will contain references to additional resources included with the event (e.g., the Patient relevant to an Encounter), however it MAY refer to non-FHIR objects.
    property additionalContextList : TFhirReferenceList read GetAdditionalContextList;
    property hasAdditionalContextList : boolean read GetHasAdditionalContextList;

  end;

  TFhirSubscriptionStatusNotificationEventListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionStatusNotificationEventList;
    function GetCurrent : TFhirSubscriptionStatusNotificationEvent;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionStatusNotificationEventList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscriptionStatusNotificationEvent read GetCurrent;
  end;

  TFhirSubscriptionStatusNotificationEventList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubscriptionStatusNotificationEvent;
    procedure SetItemN(index : Integer; value : TFhirSubscriptionStatusNotificationEvent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubscriptionStatusNotificationEventList; overload;
    function Clone : TFhirSubscriptionStatusNotificationEventList; overload;
    function GetEnumerator : TFhirSubscriptionStatusNotificationEventListEnumerator;
    
    //  Add a FhirSubscriptionStatusNotificationEvent to the end of the list.
    function Append : TFhirSubscriptionStatusNotificationEvent;
    
    // Add an already existing FhirSubscriptionStatusNotificationEvent to the end of the list.
    function AddItem(value : TFhirSubscriptionStatusNotificationEvent) : TFhirSubscriptionStatusNotificationEvent; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscriptionStatusNotificationEvent) : Integer;
    
    // Insert FhirSubscriptionStatusNotificationEvent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscriptionStatusNotificationEvent;
    
    // Insert an existing FhirSubscriptionStatusNotificationEvent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscriptionStatusNotificationEvent);
    
    // Get the iIndexth FhirSubscriptionStatusNotificationEvent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscriptionStatusNotificationEvent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscriptionStatusNotificationEvent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubscriptionStatusNotificationEvents[index : Integer] : TFhirSubscriptionStatusNotificationEvent read GetItemN write SetItemN; default;
  End;

  // The SubscriptionStatus resource describes the state of a Subscription during notifications.
  TFhirSubscriptionStatus = class (TFhirDomainResource)
  protected
    FStatus : TFhirEnum;
    FType_ : TFhirEnum;
    FEventsSinceSubscriptionStart : TFhirInteger64;
    FnotificationEventList : TFhirSubscriptionStatusNotificationEventList;
    FSubscription : TFhirReference;
    FTopic : TFhirCanonical;
    FerrorList : TFhirCodeableConceptList;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirSubscriptionStatusCodesEnum;
    procedure SetStatusST(value : TFhirSubscriptionStatusCodesEnum);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirSubscriptionNotificationTypeEnum;
    procedure SetType_ST(value : TFhirSubscriptionNotificationTypeEnum);
    procedure SetEventsSinceSubscriptionStart(value : TFhirInteger64);
    function GetEventsSinceSubscriptionStartST : String;
    procedure SetEventsSinceSubscriptionStartST(value : String);
    function GetNotificationEventList : TFhirSubscriptionStatusNotificationEventList;
    function GetHasNotificationEventList : Boolean;
    procedure SetSubscription(value : TFhirReference);
    procedure SetTopic(value : TFhirCanonical);
    function GetTopicST : String;
    procedure SetTopicST(value : String);
    function GetErrorList : TFhirCodeableConceptList;
    function GetHasErrorList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscriptionStatus; overload;
    function Clone : TFhirSubscriptionStatus; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The status of the subscription, which marks the server state for managing the subscription.
    property status : TFhirSubscriptionStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The type of event being conveyed with this notificaiton.
    property type_ : TFhirSubscriptionNotificationTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The total number of actual events which have been generated since the Subscription was created (inclusive of this notification) - regardless of how many have been successfully communicated.  This number is NOT incremented for handshake and heartbeat notifications.
    property eventsSinceSubscriptionStart : String read GetEventsSinceSubscriptionStartST write SetEventsSinceSubscriptionStartST;
    // The total number of actual events which have been generated since the Subscription was created (inclusive of this notification) - regardless of how many have been successfully communicated.  This number is NOT incremented for handshake and heartbeat notifications.
    property eventsSinceSubscriptionStartElement : TFhirInteger64 read FEventsSinceSubscriptionStart write SetEventsSinceSubscriptionStart;

    // Detailed information about events relevant to this subscription notification.
    property notificationEventList : TFhirSubscriptionStatusNotificationEventList read GetNotificationEventList;
    property hasNotificationEventList : boolean read GetHasNotificationEventList;

    // Typed access to The reference to the Subscription which generated this notification. (defined for API consistency)
    property subscription : TFhirReference read FSubscription write SetSubscription;
    // The reference to the Subscription which generated this notification.
    property subscriptionElement : TFhirReference read FSubscription write SetSubscription;

    // Typed access to The reference to the SubscriptionTopic for the Subscription which generated this notification.
    property topic : String read GetTopicST write SetTopicST;
    // The reference to the SubscriptionTopic for the Subscription which generated this notification.
    property topicElement : TFhirCanonical read FTopic write SetTopic;

    // A record of errors that occurred when the server processed a notification.
    property errorList : TFhirCodeableConceptList read GetErrorList;
    property hasErrorList : boolean read GetHasErrorList;

  end;

  TFhirSubscriptionStatusListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionStatusList;
    function GetCurrent : TFhirSubscriptionStatus;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionStatusList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscriptionStatus read GetCurrent;
  end;

  TFhirSubscriptionStatusList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubscriptionStatus;
    procedure SetItemN(index : Integer; value : TFhirSubscriptionStatus);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubscriptionStatusList; overload;
    function Clone : TFhirSubscriptionStatusList; overload;
    function GetEnumerator : TFhirSubscriptionStatusListEnumerator;
    
    //  Add a FhirSubscriptionStatus to the end of the list.
    function Append : TFhirSubscriptionStatus;
    
    // Add an already existing FhirSubscriptionStatus to the end of the list.
    function AddItem(value : TFhirSubscriptionStatus) : TFhirSubscriptionStatus; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscriptionStatus) : Integer;
    
    // Insert FhirSubscriptionStatus before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscriptionStatus;
    
    // Insert an existing FhirSubscriptionStatus before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscriptionStatus);
    
    // Get the iIndexth FhirSubscriptionStatus. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscriptionStatus);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscriptionStatus;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubscriptionStatuses[index : Integer] : TFhirSubscriptionStatus read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSCRIPTIONSTATUS}
{$IFDEF FHIR_SUBSCRIPTIONTOPIC}
  // A definition of a resource-based event that triggers a notification based on the SubscriptionTopic. The criteria may be just a human readable description and/or a full FHIR search string or FHIRPath expression. Multiple triggers are considered OR joined (e.g., a resource update matching ANY of the definitions will trigger a notification).
  TFhirSubscriptionTopicResourceTrigger = class (TFhirBackboneElement)
  protected
    FDescription : TFhirMarkdown;
    FResource : TFhirUri;
    FSupportedInteraction : TFhirEnumList;
    FQueryCriteria : TFhirSubscriptionTopicResourceTriggerQueryCriteria;
    FFhirPathCriteria : TFhirString;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetResource(value : TFhirUri);
    function GetResourceST : String;
    procedure SetResourceST(value : String);
    function GetSupportedInteraction : TFhirEnumList;
    function GetHasSupportedInteraction : Boolean;
    function GetSupportedInteractionST : TFhirInteractionTriggerEnumList;
    procedure SetSupportedInteractionST(value : TFhirInteractionTriggerEnumList);
    procedure SetQueryCriteria(value : TFhirSubscriptionTopicResourceTriggerQueryCriteria);
    procedure SetFhirPathCriteria(value : TFhirString);
    function GetFhirPathCriteriaST : String;
    procedure SetFhirPathCriteriaST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscriptionTopicResourceTrigger; overload;
    function Clone : TFhirSubscriptionTopicResourceTrigger; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The human readable description of this resource trigger for the SubscriptionTopic -  for example, "An Encounter enters the 'in-progress' state".
    property description : String read GetDescriptionST write SetDescriptionST;
    // The human readable description of this resource trigger for the SubscriptionTopic -  for example, "An Encounter enters the 'in-progress' state".
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to URL of the Resource that is the type used in this resource trigger.  Relative URLs are relative to the StructureDefinition root of the implemented FHIR version (e.g., http://hl7.org/fhir/StructureDefinition). For example, "Patient" maps to http://hl7.org/fhir/StructureDefinition/Patient.  For more information, see <a href="elementdefinition-definitions.html#ElementDefinition.type.code">ElementDefinition.type.code</a>.
    property resource : String read GetResourceST write SetResourceST;
    // URL of the Resource that is the type used in this resource trigger.  Relative URLs are relative to the StructureDefinition root of the implemented FHIR version (e.g., http://hl7.org/fhir/StructureDefinition). For example, "Patient" maps to http://hl7.org/fhir/StructureDefinition/Patient.  For more information, see <a href="elementdefinition-definitions.html#ElementDefinition.type.code">ElementDefinition.type.code</a>.
    property resourceElement : TFhirUri read FResource write SetResource;

    // The FHIR RESTful interaction which can be used to trigger a notification for the SubscriptionTopic. Multiple values are considered OR joined (e.g., CREATE or UPDATE).
    property supportedInteraction : TFhirInteractionTriggerEnumList read GetSupportedInteractionST write SetSupportedInteractionST;
    property supportedInteractionList : TFhirEnumList read GetSupportedInteraction;
    property hasSupportedInteraction : boolean read GetHasSupportedInteraction;
    // Typed access to The FHIR query based rules that the server should use to determine when to trigger a notification for this subscription topic. (defined for API consistency)
    property queryCriteria : TFhirSubscriptionTopicResourceTriggerQueryCriteria read FQueryCriteria write SetQueryCriteria;
    // The FHIR query based rules that the server should use to determine when to trigger a notification for this subscription topic.
    property queryCriteriaElement : TFhirSubscriptionTopicResourceTriggerQueryCriteria read FQueryCriteria write SetQueryCriteria;

    // Typed access to The FHIRPath based rules that the server should use to determine when to trigger a notification for this topic.
    property fhirPathCriteria : String read GetFhirPathCriteriaST write SetFhirPathCriteriaST;
    // The FHIRPath based rules that the server should use to determine when to trigger a notification for this topic.
    property fhirPathCriteriaElement : TFhirString read FFhirPathCriteria write SetFhirPathCriteria;

  end;

  TFhirSubscriptionTopicResourceTriggerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionTopicResourceTriggerList;
    function GetCurrent : TFhirSubscriptionTopicResourceTrigger;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionTopicResourceTriggerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscriptionTopicResourceTrigger read GetCurrent;
  end;

  TFhirSubscriptionTopicResourceTriggerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubscriptionTopicResourceTrigger;
    procedure SetItemN(index : Integer; value : TFhirSubscriptionTopicResourceTrigger);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubscriptionTopicResourceTriggerList; overload;
    function Clone : TFhirSubscriptionTopicResourceTriggerList; overload;
    function GetEnumerator : TFhirSubscriptionTopicResourceTriggerListEnumerator;
    
    //  Add a FhirSubscriptionTopicResourceTrigger to the end of the list.
    function Append : TFhirSubscriptionTopicResourceTrigger;
    
    // Add an already existing FhirSubscriptionTopicResourceTrigger to the end of the list.
    function AddItem(value : TFhirSubscriptionTopicResourceTrigger) : TFhirSubscriptionTopicResourceTrigger; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscriptionTopicResourceTrigger) : Integer;
    
    // Insert FhirSubscriptionTopicResourceTrigger before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscriptionTopicResourceTrigger;
    
    // Insert an existing FhirSubscriptionTopicResourceTrigger before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscriptionTopicResourceTrigger);
    
    // Get the iIndexth FhirSubscriptionTopicResourceTrigger. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscriptionTopicResourceTrigger);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscriptionTopicResourceTrigger;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubscriptionTopicResourceTriggers[index : Integer] : TFhirSubscriptionTopicResourceTrigger read GetItemN write SetItemN; default;
  End;

  // The FHIR query based rules that the server should use to determine when to trigger a notification for this subscription topic.
  TFhirSubscriptionTopicResourceTriggerQueryCriteria = class (TFhirBackboneElement)
  protected
    FPrevious : TFhirString;
    FResultForCreate : TFhirEnum;
    FCurrent : TFhirString;
    FResultForDelete : TFhirEnum;
    FRequireBoth : TFhirBoolean;
    procedure SetPrevious(value : TFhirString);
    function GetPreviousST : String;
    procedure SetPreviousST(value : String);
    procedure SetResultForCreate(value : TFhirEnum);
    function GetResultForCreateST : TFhirCriteriaNotExistsBehaviorEnum;
    procedure SetResultForCreateST(value : TFhirCriteriaNotExistsBehaviorEnum);
    procedure SetCurrent(value : TFhirString);
    function GetCurrentST : String;
    procedure SetCurrentST(value : String);
    procedure SetResultForDelete(value : TFhirEnum);
    function GetResultForDeleteST : TFhirCriteriaNotExistsBehaviorEnum;
    procedure SetResultForDeleteST(value : TFhirCriteriaNotExistsBehaviorEnum);
    procedure SetRequireBoth(value : TFhirBoolean);
    function GetRequireBothST : Boolean;
    procedure SetRequireBothST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscriptionTopicResourceTriggerQueryCriteria; overload;
    function Clone : TFhirSubscriptionTopicResourceTriggerQueryCriteria; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The FHIR query based rules are applied to the previous resource state (e.g., state before an update).
    property previous : String read GetPreviousST write SetPreviousST;
    // The FHIR query based rules are applied to the previous resource state (e.g., state before an update).
    property previousElement : TFhirString read FPrevious write SetPrevious;

    // For "create" interactions, should the "previous" criteria count as an automatic pass or an automatic fail.
    property resultForCreate : TFhirCriteriaNotExistsBehaviorEnum read GetResultForCreateST write SetResultForCreateST;
    property resultForCreateElement : TFhirEnum read FResultForCreate write SetResultForCreate;

    // Typed access to The FHIR query based rules are applied to the current resource state (e.g., state after an update).
    property current : String read GetCurrentST write SetCurrentST;
    // The FHIR query based rules are applied to the current resource state (e.g., state after an update).
    property currentElement : TFhirString read FCurrent write SetCurrent;

    // For "delete" interactions, should the "current" criteria count as an automatic pass or an automatic fail.
    property resultForDelete : TFhirCriteriaNotExistsBehaviorEnum read GetResultForDeleteST write SetResultForDeleteST;
    property resultForDeleteElement : TFhirEnum read FResultForDelete write SetResultForDelete;

    // Typed access to If set to true, both current and previous criteria must evaluate true to  trigger a notification for this topic.  Otherwise a notification for this topic will be triggered if either one evaluates to true.
    property requireBoth : Boolean read GetRequireBothST write SetRequireBothST;
    // If set to true, both current and previous criteria must evaluate true to  trigger a notification for this topic.  Otherwise a notification for this topic will be triggered if either one evaluates to true.
    property requireBothElement : TFhirBoolean read FRequireBoth write SetRequireBoth;

  end;

  TFhirSubscriptionTopicResourceTriggerQueryCriteriaListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionTopicResourceTriggerQueryCriteriaList;
    function GetCurrent : TFhirSubscriptionTopicResourceTriggerQueryCriteria;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionTopicResourceTriggerQueryCriteriaList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscriptionTopicResourceTriggerQueryCriteria read GetCurrent;
  end;

  TFhirSubscriptionTopicResourceTriggerQueryCriteriaList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubscriptionTopicResourceTriggerQueryCriteria;
    procedure SetItemN(index : Integer; value : TFhirSubscriptionTopicResourceTriggerQueryCriteria);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubscriptionTopicResourceTriggerQueryCriteriaList; overload;
    function Clone : TFhirSubscriptionTopicResourceTriggerQueryCriteriaList; overload;
    function GetEnumerator : TFhirSubscriptionTopicResourceTriggerQueryCriteriaListEnumerator;
    
    //  Add a FhirSubscriptionTopicResourceTriggerQueryCriteria to the end of the list.
    function Append : TFhirSubscriptionTopicResourceTriggerQueryCriteria;
    
    // Add an already existing FhirSubscriptionTopicResourceTriggerQueryCriteria to the end of the list.
    function AddItem(value : TFhirSubscriptionTopicResourceTriggerQueryCriteria) : TFhirSubscriptionTopicResourceTriggerQueryCriteria; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscriptionTopicResourceTriggerQueryCriteria) : Integer;
    
    // Insert FhirSubscriptionTopicResourceTriggerQueryCriteria before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscriptionTopicResourceTriggerQueryCriteria;
    
    // Insert an existing FhirSubscriptionTopicResourceTriggerQueryCriteria before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscriptionTopicResourceTriggerQueryCriteria);
    
    // Get the iIndexth FhirSubscriptionTopicResourceTriggerQueryCriteria. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscriptionTopicResourceTriggerQueryCriteria);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscriptionTopicResourceTriggerQueryCriteria;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubscriptionTopicResourceTriggerQueryCriteria[index : Integer] : TFhirSubscriptionTopicResourceTriggerQueryCriteria read GetItemN write SetItemN; default;
  End;

  // Event definition which can be used to trigger the SubscriptionTopic.
  TFhirSubscriptionTopicEventTrigger = class (TFhirBackboneElement)
  protected
    FDescription : TFhirMarkdown;
    FEvent : TFhirCodeableConcept;
    FResource : TFhirUri;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetEvent(value : TFhirCodeableConcept);
    procedure SetResource(value : TFhirUri);
    function GetResourceST : String;
    procedure SetResourceST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscriptionTopicEventTrigger; overload;
    function Clone : TFhirSubscriptionTopicEventTrigger; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The human readable description of an event to trigger a notification for the SubscriptionTopic - for example, "Patient Admission, as defined in HL7v2 via message ADT^A01". Multiple values are considered OR joined (e.g., matching any single event listed).
    property description : String read GetDescriptionST write SetDescriptionST;
    // The human readable description of an event to trigger a notification for the SubscriptionTopic - for example, "Patient Admission, as defined in HL7v2 via message ADT^A01". Multiple values are considered OR joined (e.g., matching any single event listed).
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to A well-defined event which can be used to trigger notifications from the SubscriptionTopic. (defined for API consistency)
    property event : TFhirCodeableConcept read FEvent write SetEvent;
    // A well-defined event which can be used to trigger notifications from the SubscriptionTopic.
    property eventElement : TFhirCodeableConcept read FEvent write SetEvent;

    // Typed access to URL of the Resource that is the focus type used in this event trigger.  Relative URLs are relative to the StructureDefinition root of the implemented FHIR version (e.g., http://hl7.org/fhir/StructureDefinition). For example, "Patient" maps to http://hl7.org/fhir/StructureDefinition/Patient.  For more information, see <a href="elementdefinition-definitions.html#ElementDefinition.type.code">ElementDefinition.type.code</a>.
    property resource : String read GetResourceST write SetResourceST;
    // URL of the Resource that is the focus type used in this event trigger.  Relative URLs are relative to the StructureDefinition root of the implemented FHIR version (e.g., http://hl7.org/fhir/StructureDefinition). For example, "Patient" maps to http://hl7.org/fhir/StructureDefinition/Patient.  For more information, see <a href="elementdefinition-definitions.html#ElementDefinition.type.code">ElementDefinition.type.code</a>.
    property resourceElement : TFhirUri read FResource write SetResource;

  end;

  TFhirSubscriptionTopicEventTriggerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionTopicEventTriggerList;
    function GetCurrent : TFhirSubscriptionTopicEventTrigger;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionTopicEventTriggerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscriptionTopicEventTrigger read GetCurrent;
  end;

  TFhirSubscriptionTopicEventTriggerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubscriptionTopicEventTrigger;
    procedure SetItemN(index : Integer; value : TFhirSubscriptionTopicEventTrigger);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubscriptionTopicEventTriggerList; overload;
    function Clone : TFhirSubscriptionTopicEventTriggerList; overload;
    function GetEnumerator : TFhirSubscriptionTopicEventTriggerListEnumerator;
    
    //  Add a FhirSubscriptionTopicEventTrigger to the end of the list.
    function Append : TFhirSubscriptionTopicEventTrigger;
    
    // Add an already existing FhirSubscriptionTopicEventTrigger to the end of the list.
    function AddItem(value : TFhirSubscriptionTopicEventTrigger) : TFhirSubscriptionTopicEventTrigger; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscriptionTopicEventTrigger) : Integer;
    
    // Insert FhirSubscriptionTopicEventTrigger before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscriptionTopicEventTrigger;
    
    // Insert an existing FhirSubscriptionTopicEventTrigger before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscriptionTopicEventTrigger);
    
    // Get the iIndexth FhirSubscriptionTopicEventTrigger. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscriptionTopicEventTrigger);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscriptionTopicEventTrigger;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubscriptionTopicEventTriggers[index : Integer] : TFhirSubscriptionTopicEventTrigger read GetItemN write SetItemN; default;
  End;

  // List of properties by which Subscriptions on the SubscriptionTopic can be filtered. May be defined Search Parameters (e.g., Encounter.patient) or parameters defined within this SubscriptionTopic context (e.g., hub.event).
  TFhirSubscriptionTopicCanFilterBy = class (TFhirBackboneElement)
  protected
    FDescription : TFhirMarkdown;
    FResource : TFhirUri;
    FFilterParameter : TFhirString;
    FFilterDefinition : TFhirUri;
    FModifier : TFhirEnumList;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetResource(value : TFhirUri);
    function GetResourceST : String;
    procedure SetResourceST(value : String);
    procedure SetFilterParameter(value : TFhirString);
    function GetFilterParameterST : String;
    procedure SetFilterParameterST(value : String);
    procedure SetFilterDefinition(value : TFhirUri);
    function GetFilterDefinitionST : String;
    procedure SetFilterDefinitionST(value : String);
    function GetModifier : TFhirEnumList;
    function GetHasModifier : Boolean;
    function GetModifierST : TFhirSubscriptionSearchModifierEnumList;
    procedure SetModifierST(value : TFhirSubscriptionSearchModifierEnumList);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscriptionTopicCanFilterBy; overload;
    function Clone : TFhirSubscriptionTopicCanFilterBy; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Description of how this filtering parameter is intended to be used.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Description of how this filtering parameter is intended to be used.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to URL of the Resource that is the type used in this filter. This is the "focus" of the topic (or one of them if there are more than one). It will be the same, a generality, or a specificity of SubscriptionTopic.resourceTrigger.resource or SubscriptionTopic.eventTrigger.resource when they are present.
    property resource : String read GetResourceST write SetResourceST;
    // URL of the Resource that is the type used in this filter. This is the "focus" of the topic (or one of them if there are more than one). It will be the same, a generality, or a specificity of SubscriptionTopic.resourceTrigger.resource or SubscriptionTopic.eventTrigger.resource when they are present.
    property resourceElement : TFhirUri read FResource write SetResource;

    // Typed access to Either the canonical URL to a search parameter (like "http://hl7.org/fhir/SearchParameter/encounter-patient") or topic-defined parameter (like "hub.event") which is a label for the filter.
    property filterParameter : String read GetFilterParameterST write SetFilterParameterST;
    // Either the canonical URL to a search parameter (like "http://hl7.org/fhir/SearchParameter/encounter-patient") or topic-defined parameter (like "hub.event") which is a label for the filter.
    property filterParameterElement : TFhirString read FFilterParameter write SetFilterParameter;

    // Typed access to Either the canonical URL to a search parameter (like "http://hl7.org/fhir/SearchParameter/encounter-patient") or the officially-defined URI for a shared filter concept (like "http://example.org/concepts/shared-common-event").
    property filterDefinition : String read GetFilterDefinitionST write SetFilterDefinitionST;
    // Either the canonical URL to a search parameter (like "http://hl7.org/fhir/SearchParameter/encounter-patient") or the officially-defined URI for a shared filter concept (like "http://example.org/concepts/shared-common-event").
    property filterDefinitionElement : TFhirUri read FFilterDefinition write SetFilterDefinition;

    // Allowable operators to apply when determining matches (Search Modifiers).  If the filterParameter is a SearchParameter, this list of modifiers SHALL be a strict subset of the modifiers defined on that SearchParameter.
    property modifier : TFhirSubscriptionSearchModifierEnumList read GetModifierST write SetModifierST;
    property modifierList : TFhirEnumList read GetModifier;
    property hasModifier : boolean read GetHasModifier;
  end;

  TFhirSubscriptionTopicCanFilterByListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionTopicCanFilterByList;
    function GetCurrent : TFhirSubscriptionTopicCanFilterBy;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionTopicCanFilterByList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscriptionTopicCanFilterBy read GetCurrent;
  end;

  TFhirSubscriptionTopicCanFilterByList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubscriptionTopicCanFilterBy;
    procedure SetItemN(index : Integer; value : TFhirSubscriptionTopicCanFilterBy);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubscriptionTopicCanFilterByList; overload;
    function Clone : TFhirSubscriptionTopicCanFilterByList; overload;
    function GetEnumerator : TFhirSubscriptionTopicCanFilterByListEnumerator;
    
    //  Add a FhirSubscriptionTopicCanFilterBy to the end of the list.
    function Append : TFhirSubscriptionTopicCanFilterBy;
    
    // Add an already existing FhirSubscriptionTopicCanFilterBy to the end of the list.
    function AddItem(value : TFhirSubscriptionTopicCanFilterBy) : TFhirSubscriptionTopicCanFilterBy; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscriptionTopicCanFilterBy) : Integer;
    
    // Insert FhirSubscriptionTopicCanFilterBy before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscriptionTopicCanFilterBy;
    
    // Insert an existing FhirSubscriptionTopicCanFilterBy before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscriptionTopicCanFilterBy);
    
    // Get the iIndexth FhirSubscriptionTopicCanFilterBy. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscriptionTopicCanFilterBy);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscriptionTopicCanFilterBy;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubscriptionTopicCanFilterBies[index : Integer] : TFhirSubscriptionTopicCanFilterBy read GetItemN write SetItemN; default;
  End;

  // List of properties to describe the shape (e.g., resources) included in notifications from this Subscription Topic.
  TFhirSubscriptionTopicNotificationShape = class (TFhirBackboneElement)
  protected
    FResource : TFhirUri;
    FincludeList : TFhirStringList;
    FrevIncludeList : TFhirStringList;
    procedure SetResource(value : TFhirUri);
    function GetResourceST : String;
    procedure SetResourceST(value : String);
    function GetIncludeList : TFhirStringList;
    function GetHasIncludeList : Boolean;
    function GetRevIncludeList : TFhirStringList;
    function GetHasRevIncludeList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscriptionTopicNotificationShape; overload;
    function Clone : TFhirSubscriptionTopicNotificationShape; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to URL of the Resource that is the type used in this shape. This is the "focus" of the topic (or one of them if there are more than one) and the root resource for this shape definition. It will be the same, a generality, or a specificity of SubscriptionTopic.resourceTrigger.resource or SubscriptionTopic.eventTrigger.resource when they are present.
    property resource : String read GetResourceST write SetResourceST;
    // URL of the Resource that is the type used in this shape. This is the "focus" of the topic (or one of them if there are more than one) and the root resource for this shape definition. It will be the same, a generality, or a specificity of SubscriptionTopic.resourceTrigger.resource or SubscriptionTopic.eventTrigger.resource when they are present.
    property resourceElement : TFhirUri read FResource write SetResource;

    // Search-style _include directives, rooted in the resource for this shape. Servers SHOULD include resources listed here, if they exist and the user is authorized to receive them.  Clients SHOULD be prepared to receive these additional resources, but SHALL function properly without them.
    property includeList : TFhirStringList read GetIncludeList;
    property hasIncludeList : boolean read GetHasIncludeList;

    // Search-style _revinclude directives, rooted in the resource for this shape. Servers SHOULD include resources listed here, if they exist and the user is authorized to receive them.  Clients SHOULD be prepared to receive these additional resources, but SHALL function properly without them.
    property revIncludeList : TFhirStringList read GetRevIncludeList;
    property hasRevIncludeList : boolean read GetHasRevIncludeList;

  end;

  TFhirSubscriptionTopicNotificationShapeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionTopicNotificationShapeList;
    function GetCurrent : TFhirSubscriptionTopicNotificationShape;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionTopicNotificationShapeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscriptionTopicNotificationShape read GetCurrent;
  end;

  TFhirSubscriptionTopicNotificationShapeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubscriptionTopicNotificationShape;
    procedure SetItemN(index : Integer; value : TFhirSubscriptionTopicNotificationShape);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubscriptionTopicNotificationShapeList; overload;
    function Clone : TFhirSubscriptionTopicNotificationShapeList; overload;
    function GetEnumerator : TFhirSubscriptionTopicNotificationShapeListEnumerator;
    
    //  Add a FhirSubscriptionTopicNotificationShape to the end of the list.
    function Append : TFhirSubscriptionTopicNotificationShape;
    
    // Add an already existing FhirSubscriptionTopicNotificationShape to the end of the list.
    function AddItem(value : TFhirSubscriptionTopicNotificationShape) : TFhirSubscriptionTopicNotificationShape; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscriptionTopicNotificationShape) : Integer;
    
    // Insert FhirSubscriptionTopicNotificationShape before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscriptionTopicNotificationShape;
    
    // Insert an existing FhirSubscriptionTopicNotificationShape before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscriptionTopicNotificationShape);
    
    // Get the iIndexth FhirSubscriptionTopicNotificationShape. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscriptionTopicNotificationShape);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscriptionTopicNotificationShape;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubscriptionTopicNotificationShapes[index : Integer] : TFhirSubscriptionTopicNotificationShape read GetItemN write SetItemN; default;
  End;

  // Describes a stream of resource state changes or events and annotated with labels useful to filter projections from this topic.
  TFhirSubscriptionTopic = class (TFhirCanonicalResource)
  protected
    FderivedFromList : TFhirCanonicalList;
    FApprovalDate : TFhirDate;
    FLastReviewDate : TFhirDate;
    FEffectivePeriod : TFhirPeriod;
    FresourceTriggerList : TFhirSubscriptionTopicResourceTriggerList;
    FeventTriggerList : TFhirSubscriptionTopicEventTriggerList;
    FcanFilterByList : TFhirSubscriptionTopicCanFilterByList;
    FnotificationShapeList : TFhirSubscriptionTopicNotificationShapeList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    function GetDerivedFromList : TFhirCanonicalList;
    function GetHasDerivedFromList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    procedure SetCopyrightLabel(value : TFhirString);
    function GetCopyrightLabelST : String;
    procedure SetCopyrightLabelST(value : String);
    procedure SetApprovalDate(value : TFhirDate);
    function GetApprovalDateST : TFslDateTime;
    procedure SetApprovalDateST(value : TFslDateTime);
    procedure SetLastReviewDate(value : TFhirDate);
    function GetLastReviewDateST : TFslDateTime;
    procedure SetLastReviewDateST(value : TFslDateTime);
    procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetResourceTriggerList : TFhirSubscriptionTopicResourceTriggerList;
    function GetHasResourceTriggerList : Boolean;
    function GetEventTriggerList : TFhirSubscriptionTopicEventTriggerList;
    function GetHasEventTriggerList : Boolean;
    function GetCanFilterByList : TFhirSubscriptionTopicCanFilterByList;
    function GetHasCanFilterByList : Boolean;
    function GetNotificationShapeList : TFhirSubscriptionTopicNotificationShapeList;
    function GetHasNotificationShapeList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscriptionTopic; overload;
    function Clone : TFhirSubscriptionTopic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this subscription topic when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which an authoritative instance of this subscription topic is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the subscription topic is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this subscription topic when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which an authoritative instance of this subscription topic is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the subscription topic is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Business identifiers assigned to this subscription topic by the performer and/or other systems.  These identifiers remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the subscription topic when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the Topic author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions are orderable.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the subscription topic when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the Topic author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions are orderable.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A short, descriptive, user-friendly title for the SubscriptionTopic, for example, "admission".
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the SubscriptionTopic, for example, "admission".
    property titleElement : TFhirString read FTitle write SetTitle;

    // The canonical URL pointing to another FHIR-defined SubscriptionTopic that is adhered to in whole or in part by this SubscriptionTopic.
    property derivedFromList : TFhirCanonicalList read GetDerivedFromList;
    property hasDerivedFromList : boolean read GetHasDerivedFromList;

    // The current state of the SubscriptionTopic.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A flag to indicate that this TopSubscriptionTopicic is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A flag to indicate that this TopSubscriptionTopicic is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to For draft definitions, indicates the date of initial creation.  For active definitions, represents the date of activation.  For withdrawn definitions, indicates the date of withdrawal.
    property date : TFslDateTime read GetDateST write SetDateST;
    // For draft definitions, indicates the date of initial creation.  For active definitions, represents the date of activation.  For withdrawn definitions, indicates the date of withdrawal.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Helps establish the "authority/credibility" of the SubscriptionTopic.  May also allow for contact.
    property publisher : String read GetPublisherST write SetPublisherST;
    // Helps establish the "authority/credibility" of the SubscriptionTopic.  May also allow for contact.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the Topic from the consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the Topic from the consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching of code system definitions.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A jurisdiction in which the Topic is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explains why this Topic is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explains why this Topic is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A copyright statement relating to the SubscriptionTopic and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the SubscriptionTopic.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the SubscriptionTopic and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the SubscriptionTopic.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to A short string (<50 characters), suitable for inclusion in a page footer that identifies the copyright holder, effective period, and optionally whether rights are resctricted. (e.g. 'All rights reserved', 'Some rights reserved').
    property copyrightLabel : String read GetCopyrightLabelST write SetCopyrightLabelST;
    // A short string (<50 characters), suitable for inclusion in a page footer that identifies the copyright holder, effective period, and optionally whether rights are resctricted. (e.g. 'All rights reserved', 'Some rights reserved').
    property copyrightLabelElement : TFhirString read FCopyrightLabel write SetCopyrightLabel;

    // Typed access to The date on which the asset content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the asset content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the asset content was last reviewed. Review happens periodically after that, but doesn't change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the asset content was last reviewed. Review happens periodically after that, but doesn't change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the SubscriptionTopic content was or is planned to be effective. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the SubscriptionTopic content was or is planned to be effective.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // A definition of a resource-based event that triggers a notification based on the SubscriptionTopic. The criteria may be just a human readable description and/or a full FHIR search string or FHIRPath expression. Multiple triggers are considered OR joined (e.g., a resource update matching ANY of the definitions will trigger a notification).
    property resourceTriggerList : TFhirSubscriptionTopicResourceTriggerList read GetResourceTriggerList;
    property hasResourceTriggerList : boolean read GetHasResourceTriggerList;

    // Event definition which can be used to trigger the SubscriptionTopic.
    property eventTriggerList : TFhirSubscriptionTopicEventTriggerList read GetEventTriggerList;
    property hasEventTriggerList : boolean read GetHasEventTriggerList;

    // List of properties by which Subscriptions on the SubscriptionTopic can be filtered. May be defined Search Parameters (e.g., Encounter.patient) or parameters defined within this SubscriptionTopic context (e.g., hub.event).
    property canFilterByList : TFhirSubscriptionTopicCanFilterByList read GetCanFilterByList;
    property hasCanFilterByList : boolean read GetHasCanFilterByList;

    // List of properties to describe the shape (e.g., resources) included in notifications from this Subscription Topic.
    property notificationShapeList : TFhirSubscriptionTopicNotificationShapeList read GetNotificationShapeList;
    property hasNotificationShapeList : boolean read GetHasNotificationShapeList;

  end;

  TFhirSubscriptionTopicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionTopicList;
    function GetCurrent : TFhirSubscriptionTopic;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionTopicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscriptionTopic read GetCurrent;
  end;

  TFhirSubscriptionTopicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubscriptionTopic;
    procedure SetItemN(index : Integer; value : TFhirSubscriptionTopic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubscriptionTopicList; overload;
    function Clone : TFhirSubscriptionTopicList; overload;
    function GetEnumerator : TFhirSubscriptionTopicListEnumerator;
    
    //  Add a FhirSubscriptionTopic to the end of the list.
    function Append : TFhirSubscriptionTopic;
    
    // Add an already existing FhirSubscriptionTopic to the end of the list.
    function AddItem(value : TFhirSubscriptionTopic) : TFhirSubscriptionTopic; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscriptionTopic) : Integer;
    
    // Insert FhirSubscriptionTopic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscriptionTopic;
    
    // Insert an existing FhirSubscriptionTopic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscriptionTopic);
    
    // Get the iIndexth FhirSubscriptionTopic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscriptionTopic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscriptionTopic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubscriptionTopics[index : Integer] : TFhirSubscriptionTopic read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSCRIPTIONTOPIC}
{$IFDEF FHIR_TASK}
  // If the Task.focus is a request resource and the task is seeking fulfillment (i.e. is asking for the request to be actioned), this element identifies any limitations on what parts of the referenced request should be actioned.
  TFhirTaskRestriction = class (TFhirBackboneElement)
  protected
    FRepetitions : TFhirPositiveInt;
    FPeriod : TFhirPeriod;
    FrecipientList : TFhirReferenceList;
    procedure SetRepetitions(value : TFhirPositiveInt);
    function GetRepetitionsST : String;
    procedure SetRepetitionsST(value : String);
    procedure SetPeriod(value : TFhirPeriod);
    function GetRecipientList : TFhirReferenceList;
    function GetHasRecipientList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTaskRestriction; overload;
    function Clone : TFhirTaskRestriction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates the number of times the requested action should occur.
    property repetitions : String read GetRepetitionsST write SetRepetitionsST;
    // Indicates the number of times the requested action should occur.
    property repetitionsElement : TFhirPositiveInt read FRepetitions write SetRepetitions;

    // Typed access to The time-period for which fulfillment is sought. This must fall within the overall time period authorized in the referenced request.  E.g. ServiceRequest.occurance[x]. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The time-period for which fulfillment is sought. This must fall within the overall time period authorized in the referenced request.  E.g. ServiceRequest.occurance[x].
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // For requests that are targeted to more than one potential recipient/target, to identify who is fulfillment is sought for.
    property recipientList : TFhirReferenceList read GetRecipientList;
    property hasRecipientList : boolean read GetHasRecipientList;

  end;

  TFhirTaskRestrictionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTaskRestrictionList;
    function GetCurrent : TFhirTaskRestriction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTaskRestrictionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTaskRestriction read GetCurrent;
  end;

  TFhirTaskRestrictionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTaskRestriction;
    procedure SetItemN(index : Integer; value : TFhirTaskRestriction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTaskRestrictionList; overload;
    function Clone : TFhirTaskRestrictionList; overload;
    function GetEnumerator : TFhirTaskRestrictionListEnumerator;
    
    //  Add a FhirTaskRestriction to the end of the list.
    function Append : TFhirTaskRestriction;
    
    // Add an already existing FhirTaskRestriction to the end of the list.
    function AddItem(value : TFhirTaskRestriction) : TFhirTaskRestriction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTaskRestriction) : Integer;
    
    // Insert FhirTaskRestriction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTaskRestriction;
    
    // Insert an existing FhirTaskRestriction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTaskRestriction);
    
    // Get the iIndexth FhirTaskRestriction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTaskRestriction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTaskRestriction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTaskRestrictions[index : Integer] : TFhirTaskRestriction read GetItemN write SetItemN; default;
  End;

  // Additional information that may be needed in the execution of the task.
  TFhirTaskInput = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTaskInput; overload;
    function Clone : TFhirTaskInput; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code or description indicating how the input is intended to be used as part of the task execution. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code or description indicating how the input is intended to be used as part of the task execution.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The value of the input parameter as a basic type. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The value of the input parameter as a basic type.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirTaskInputListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTaskInputList;
    function GetCurrent : TFhirTaskInput;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTaskInputList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTaskInput read GetCurrent;
  end;

  TFhirTaskInputList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTaskInput;
    procedure SetItemN(index : Integer; value : TFhirTaskInput);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTaskInputList; overload;
    function Clone : TFhirTaskInputList; overload;
    function GetEnumerator : TFhirTaskInputListEnumerator;
    
    //  Add a FhirTaskInput to the end of the list.
    function Append : TFhirTaskInput;
    
    // Add an already existing FhirTaskInput to the end of the list.
    function AddItem(value : TFhirTaskInput) : TFhirTaskInput; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTaskInput) : Integer;
    
    // Insert FhirTaskInput before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTaskInput;
    
    // Insert an existing FhirTaskInput before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTaskInput);
    
    // Get the iIndexth FhirTaskInput. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTaskInput);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTaskInput;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTaskInputs[index : Integer] : TFhirTaskInput read GetItemN write SetItemN; default;
  End;

  // Outputs produced by the Task.
  TFhirTaskOutput = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTaskOutput; overload;
    function Clone : TFhirTaskOutput; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of the Output parameter. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The name of the Output parameter.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The value of the Output parameter as a basic type. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The value of the Output parameter as a basic type.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirTaskOutputListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTaskOutputList;
    function GetCurrent : TFhirTaskOutput;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTaskOutputList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTaskOutput read GetCurrent;
  end;

  TFhirTaskOutputList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTaskOutput;
    procedure SetItemN(index : Integer; value : TFhirTaskOutput);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTaskOutputList; overload;
    function Clone : TFhirTaskOutputList; overload;
    function GetEnumerator : TFhirTaskOutputListEnumerator;
    
    //  Add a FhirTaskOutput to the end of the list.
    function Append : TFhirTaskOutput;
    
    // Add an already existing FhirTaskOutput to the end of the list.
    function AddItem(value : TFhirTaskOutput) : TFhirTaskOutput; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTaskOutput) : Integer;
    
    // Insert FhirTaskOutput before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTaskOutput;
    
    // Insert an existing FhirTaskOutput before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTaskOutput);
    
    // Get the iIndexth FhirTaskOutput. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTaskOutput);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTaskOutput;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTaskOutputs[index : Integer] : TFhirTaskOutput read GetItemN write SetItemN; default;
  End;

  // A task to be performed.
  TFhirTask = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FInstantiatesCanonical : TFhirCanonical;
    FInstantiatesUri : TFhirUri;
    FbasedOnList : TFhirReferenceList;
    FGroupIdentifier : TFhirIdentifier;
    FpartOfList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FStatusReason : TFhirCodeableReference;
    FBusinessStatus : TFhirCodeableConcept;
    FIntent : TFhirEnum;
    FPriority : TFhirEnum;
    FDoNotPerform : TFhirBoolean;
    FCode : TFhirCodeableConcept;
    FDescription : TFhirString;
    FFocus : TFhirReference;
    FFor_ : TFhirReference;
    FEncounter : TFhirReference;
    FRequestedPeriod : TFhirPeriod;
    FExecutionPeriod : TFhirPeriod;
    FAuthoredOn : TFhirDateTime;
    FLastModified : TFhirDateTime;
    FRequester : TFhirReference;
    FrequestedPerformerList : TFhirCodeableReferenceList;
    FOwner : TFhirReference;
    FLocation : TFhirReference;
    FreasonList : TFhirCodeableReferenceList;
    FinsuranceList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    FrelevantHistoryList : TFhirReferenceList;
    FRestriction : TFhirTaskRestriction;
    FinputList : TFhirTaskInputList;
    FoutputList : TFhirTaskOutputList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetInstantiatesCanonical(value : TFhirCanonical);
    function GetInstantiatesCanonicalST : String;
    procedure SetInstantiatesCanonicalST(value : String);
    procedure SetInstantiatesUri(value : TFhirUri);
    function GetInstantiatesUriST : String;
    procedure SetInstantiatesUriST(value : String);
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    procedure SetGroupIdentifier(value : TFhirIdentifier);
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirTaskStatusEnum;
    procedure SetStatusST(value : TFhirTaskStatusEnum);
    procedure SetStatusReason(value : TFhirCodeableReference);
    procedure SetBusinessStatus(value : TFhirCodeableConcept);
    procedure SetIntent(value : TFhirEnum);
    function GetIntentST : TFhirTaskIntentEnum;
    procedure SetIntentST(value : TFhirTaskIntentEnum);
    procedure SetPriority(value : TFhirEnum);
    function GetPriorityST : TFhirRequestPriorityEnum;
    procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    procedure SetDoNotPerform(value : TFhirBoolean);
    function GetDoNotPerformST : Boolean;
    procedure SetDoNotPerformST(value : Boolean);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetFocus(value : TFhirReference);
    procedure SetFor_(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetRequestedPeriod(value : TFhirPeriod);
    procedure SetExecutionPeriod(value : TFhirPeriod);
    procedure SetAuthoredOn(value : TFhirDateTime);
    function GetAuthoredOnST : TFslDateTime;
    procedure SetAuthoredOnST(value : TFslDateTime);
    procedure SetLastModified(value : TFhirDateTime);
    function GetLastModifiedST : TFslDateTime;
    procedure SetLastModifiedST(value : TFslDateTime);
    procedure SetRequester(value : TFhirReference);
    function GetRequestedPerformerList : TFhirCodeableReferenceList;
    function GetHasRequestedPerformerList : Boolean;
    procedure SetOwner(value : TFhirReference);
    procedure SetLocation(value : TFhirReference);
    function GetReasonList : TFhirCodeableReferenceList;
    function GetHasReasonList : Boolean;
    function GetInsuranceList : TFhirReferenceList;
    function GetHasInsuranceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetRelevantHistoryList : TFhirReferenceList;
    function GetHasRelevantHistoryList : Boolean;
    procedure SetRestriction(value : TFhirTaskRestriction);
    function GetInputList : TFhirTaskInputList;
    function GetHasInputList : Boolean;
    function GetOutputList : TFhirTaskOutputList;
    function GetHasOutputList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTask; overload;
    function Clone : TFhirTask; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The business identifier for this task.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The URL pointing to a *FHIR*-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this Task.
    property instantiatesCanonical : String read GetInstantiatesCanonicalST write SetInstantiatesCanonicalST;
    // The URL pointing to a *FHIR*-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this Task.
    property instantiatesCanonicalElement : TFhirCanonical read FInstantiatesCanonical write SetInstantiatesCanonical;

    // Typed access to The URL pointing to an *externally* maintained  protocol, guideline, orderset or other definition that is adhered to in whole or in part by this Task.
    property instantiatesUri : String read GetInstantiatesUriST write SetInstantiatesUriST;
    // The URL pointing to an *externally* maintained  protocol, guideline, orderset or other definition that is adhered to in whole or in part by this Task.
    property instantiatesUriElement : TFhirUri read FInstantiatesUri write SetInstantiatesUri;

    // BasedOn refers to a higher-level authorization that triggered the creation of the task.  It references a "request" resource such as a ServiceRequest, MedicationRequest, CarePlan, etc. which is distinct from the "request" resource the task is seeking to fulfill.  This latter resource is referenced by focus.  For example, based on a CarePlan (= basedOn), a task is created to fulfill a ServiceRequest ( = focus ) to collect a specimen from a patient.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Typed access to An identifier that links together multiple tasks and other requests that were created in the same context. (defined for API consistency)
    property groupIdentifier : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;
    // An identifier that links together multiple tasks and other requests that were created in the same context.
    property groupIdentifierElement : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;

    // Task that this particular task is part of.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // The current status of the task.
    property status : TFhirTaskStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to An explanation as to why this task is held, failed, was refused, etc. (defined for API consistency)
    property statusReason : TFhirCodeableReference read FStatusReason write SetStatusReason;
    // An explanation as to why this task is held, failed, was refused, etc.
    property statusReasonElement : TFhirCodeableReference read FStatusReason write SetStatusReason;

    // Typed access to Contains business-specific nuances of the business state. (defined for API consistency)
    property businessStatus : TFhirCodeableConcept read FBusinessStatus write SetBusinessStatus;
    // Contains business-specific nuances of the business state.
    property businessStatusElement : TFhirCodeableConcept read FBusinessStatus write SetBusinessStatus;

    // Indicates the "level" of actionability associated with the Task, i.e. i+R[9]Cs this a proposed task, a planned task, an actionable task, etc.
    property intent : TFhirTaskIntentEnum read GetIntentST write SetIntentST;
    property intentElement : TFhirEnum read FIntent write SetIntent;

    // Indicates how quickly the Task should be addressed with respect to other requests.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // Typed access to If true indicates that the Task is asking for the specified action to *not* occur.
    property doNotPerform : Boolean read GetDoNotPerformST write SetDoNotPerformST;
    // If true indicates that the Task is asking for the specified action to *not* occur.
    property doNotPerformElement : TFhirBoolean read FDoNotPerform write SetDoNotPerform;

    // Typed access to A name or code (or both) briefly describing what the task involves. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A name or code (or both) briefly describing what the task involves.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to A free-text description of what is to be performed.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free-text description of what is to be performed.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The request being fulfilled or the resource being manipulated (changed, suspended, etc.) by this task. (defined for API consistency)
    property focus : TFhirReference read FFocus write SetFocus;
    // The request being fulfilled or the resource being manipulated (changed, suspended, etc.) by this task.
    property focusElement : TFhirReference read FFocus write SetFocus;

    // Typed access to The entity who benefits from the performance of the service specified in the task (e.g., the patient). (defined for API consistency)
    property for_ : TFhirReference read FFor_ write SetFor_;
    // The entity who benefits from the performance of the service specified in the task (e.g., the patient).
    property for_Element : TFhirReference read FFor_ write SetFor_;

    // Typed access to The healthcare event  (e.g. a patient and healthcare provider interaction) during which this task was created. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The healthcare event  (e.g. a patient and healthcare provider interaction) during which this task was created.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to Indicates the start and/or end of the period of time when completion of the task is desired to take place. (defined for API consistency)
    property requestedPeriod : TFhirPeriod read FRequestedPeriod write SetRequestedPeriod;
    // Indicates the start and/or end of the period of time when completion of the task is desired to take place.
    property requestedPeriodElement : TFhirPeriod read FRequestedPeriod write SetRequestedPeriod;

    // Typed access to Identifies the time action was first taken against the task (start) and/or the time final action was taken against the task prior to marking it as completed (end). (defined for API consistency)
    property executionPeriod : TFhirPeriod read FExecutionPeriod write SetExecutionPeriod;
    // Identifies the time action was first taken against the task (start) and/or the time final action was taken against the task prior to marking it as completed (end).
    property executionPeriodElement : TFhirPeriod read FExecutionPeriod write SetExecutionPeriod;

    // Typed access to The date and time this task was created.
    property authoredOn : TFslDateTime read GetAuthoredOnST write SetAuthoredOnST;
    // The date and time this task was created.
    property authoredOnElement : TFhirDateTime read FAuthoredOn write SetAuthoredOn;

    // Typed access to The date and time of last modification to this task.
    property lastModified : TFslDateTime read GetLastModifiedST write SetLastModifiedST;
    // The date and time of last modification to this task.
    property lastModifiedElement : TFhirDateTime read FLastModified write SetLastModified;

    // Typed access to The creator of the task. (defined for API consistency)
    property requester : TFhirReference read FRequester write SetRequester;
    // The creator of the task.
    property requesterElement : TFhirReference read FRequester write SetRequester;

    // The kind of participant or specific participant that should perform the task.
    property requestedPerformerList : TFhirCodeableReferenceList read GetRequestedPerformerList;
    property hasRequestedPerformerList : boolean read GetHasRequestedPerformerList;

    // Typed access to Individual organization or Device currently responsible for task execution. (defined for API consistency)
    property owner : TFhirReference read FOwner write SetOwner;
    // Individual organization or Device currently responsible for task execution.
    property ownerElement : TFhirReference read FOwner write SetOwner;

    // Typed access to Principal physical location where the this task is performed. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // Principal physical location where the this task is performed.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // A description, code, or reference indicating why this task needs to be performed.
    property reasonList : TFhirCodeableReferenceList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Insurance plans, coverage extensions, pre-authorizations and/or pre-determinations that may be relevant to the Task.
    property insuranceList : TFhirReferenceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Free-text information captured about the task as it progresses.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Links to Provenance records for past versions of this Task that identify key state transitions or updates that are likely to be relevant to a user looking at the current version of the task.
    property relevantHistoryList : TFhirReferenceList read GetRelevantHistoryList;
    property hasRelevantHistoryList : boolean read GetHasRelevantHistoryList;

    // Typed access to If the Task.focus is a request resource and the task is seeking fulfillment (i.e. is asking for the request to be actioned), this element identifies any limitations on what parts of the referenced request should be actioned. (defined for API consistency)
    property restriction : TFhirTaskRestriction read FRestriction write SetRestriction;
    // If the Task.focus is a request resource and the task is seeking fulfillment (i.e. is asking for the request to be actioned), this element identifies any limitations on what parts of the referenced request should be actioned.
    property restrictionElement : TFhirTaskRestriction read FRestriction write SetRestriction;

    // Additional information that may be needed in the execution of the task.
    property inputList : TFhirTaskInputList read GetInputList;
    property hasInputList : boolean read GetHasInputList;

    // Outputs produced by the Task.
    property outputList : TFhirTaskOutputList read GetOutputList;
    property hasOutputList : boolean read GetHasOutputList;

  end;

  TFhirTaskListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTaskList;
    function GetCurrent : TFhirTask;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTaskList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTask read GetCurrent;
  end;

  TFhirTaskList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTask;
    procedure SetItemN(index : Integer; value : TFhirTask);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTaskList; overload;
    function Clone : TFhirTaskList; overload;
    function GetEnumerator : TFhirTaskListEnumerator;
    
    //  Add a FhirTask to the end of the list.
    function Append : TFhirTask;
    
    // Add an already existing FhirTask to the end of the list.
    function AddItem(value : TFhirTask) : TFhirTask; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTask) : Integer;
    
    // Insert FhirTask before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTask;
    
    // Insert an existing FhirTask before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTask);
    
    // Get the iIndexth FhirTask. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTask);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTask;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTasks[index : Integer] : TFhirTask read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TESTREPORT}
  // A participant in the test execution, either the execution engine, a client, or a server.
  TFhirTestReportParticipant = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FUri : TFhirUri;
    FDisplay : TFhirString;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirTestReportParticipantTypeEnum;
    procedure SetType_ST(value : TFhirTestReportParticipantTypeEnum);
    procedure SetUri(value : TFhirUri);
    function GetUriST : String;
    procedure SetUriST(value : String);
    procedure SetDisplay(value : TFhirString);
    function GetDisplayST : String;
    procedure SetDisplayST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportParticipant; overload;
    function Clone : TFhirTestReportParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of participant.
    property type_ : TFhirTestReportParticipantTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The uri of the participant. An absolute URL is preferred.
    property uri : String read GetUriST write SetUriST;
    // The uri of the participant. An absolute URL is preferred.
    property uriElement : TFhirUri read FUri write SetUri;

    // Typed access to The display name of the participant.
    property display : String read GetDisplayST write SetDisplayST;
    // The display name of the participant.
    property displayElement : TFhirString read FDisplay write SetDisplay;

  end;

  TFhirTestReportParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportParticipantList;
    function GetCurrent : TFhirTestReportParticipant;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestReportParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportParticipant read GetCurrent;
  end;

  TFhirTestReportParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestReportParticipant;
    procedure SetItemN(index : Integer; value : TFhirTestReportParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestReportParticipantList; overload;
    function Clone : TFhirTestReportParticipantList; overload;
    function GetEnumerator : TFhirTestReportParticipantListEnumerator;
    
    //  Add a FhirTestReportParticipant to the end of the list.
    function Append : TFhirTestReportParticipant;
    
    // Add an already existing FhirTestReportParticipant to the end of the list.
    function AddItem(value : TFhirTestReportParticipant) : TFhirTestReportParticipant; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportParticipant) : Integer;
    
    // Insert FhirTestReportParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportParticipant;
    
    // Insert an existing FhirTestReportParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportParticipant);
    
    // Get the iIndexth FhirTestReportParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportParticipant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportParticipant;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestReportParticipants[index : Integer] : TFhirTestReportParticipant read GetItemN write SetItemN; default;
  End;

  // The results of the series of required setup operations before the tests were executed.
  TFhirTestReportSetup = class (TFhirBackboneElement)
  protected
    FactionList : TFhirTestReportSetupActionList;
    function GetActionList : TFhirTestReportSetupActionList;
    function GetHasActionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportSetup; overload;
    function Clone : TFhirTestReportSetup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Action would contain either an operation or an assertion.
    property actionList : TFhirTestReportSetupActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirTestReportSetupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportSetupList;
    function GetCurrent : TFhirTestReportSetup;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestReportSetupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportSetup read GetCurrent;
  end;

  TFhirTestReportSetupList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestReportSetup;
    procedure SetItemN(index : Integer; value : TFhirTestReportSetup);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestReportSetupList; overload;
    function Clone : TFhirTestReportSetupList; overload;
    function GetEnumerator : TFhirTestReportSetupListEnumerator;
    
    //  Add a FhirTestReportSetup to the end of the list.
    function Append : TFhirTestReportSetup;
    
    // Add an already existing FhirTestReportSetup to the end of the list.
    function AddItem(value : TFhirTestReportSetup) : TFhirTestReportSetup; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportSetup) : Integer;
    
    // Insert FhirTestReportSetup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportSetup;
    
    // Insert an existing FhirTestReportSetup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportSetup);
    
    // Get the iIndexth FhirTestReportSetup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportSetup);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportSetup;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestReportSetups[index : Integer] : TFhirTestReportSetup read GetItemN write SetItemN; default;
  End;

  // Action would contain either an operation or an assertion.
  TFhirTestReportSetupAction = class (TFhirBackboneElement)
  protected
    FOperation : TFhirTestReportSetupActionOperation;
    FAssert : TFhirTestReportSetupActionAssert;
    procedure SetOperation(value : TFhirTestReportSetupActionOperation);
    procedure SetAssert(value : TFhirTestReportSetupActionAssert);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportSetupAction; overload;
    function Clone : TFhirTestReportSetupAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The operation performed. (defined for API consistency)
    property operation : TFhirTestReportSetupActionOperation read FOperation write SetOperation;
    // The operation performed.
    property operationElement : TFhirTestReportSetupActionOperation read FOperation write SetOperation;

    // Typed access to The results of the assertion performed on the previous operations. (defined for API consistency)
    property assert : TFhirTestReportSetupActionAssert read FAssert write SetAssert;
    // The results of the assertion performed on the previous operations.
    property assertElement : TFhirTestReportSetupActionAssert read FAssert write SetAssert;

  end;

  TFhirTestReportSetupActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportSetupActionList;
    function GetCurrent : TFhirTestReportSetupAction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestReportSetupActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportSetupAction read GetCurrent;
  end;

  TFhirTestReportSetupActionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestReportSetupAction;
    procedure SetItemN(index : Integer; value : TFhirTestReportSetupAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestReportSetupActionList; overload;
    function Clone : TFhirTestReportSetupActionList; overload;
    function GetEnumerator : TFhirTestReportSetupActionListEnumerator;
    
    //  Add a FhirTestReportSetupAction to the end of the list.
    function Append : TFhirTestReportSetupAction;
    
    // Add an already existing FhirTestReportSetupAction to the end of the list.
    function AddItem(value : TFhirTestReportSetupAction) : TFhirTestReportSetupAction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportSetupAction) : Integer;
    
    // Insert FhirTestReportSetupAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportSetupAction;
    
    // Insert an existing FhirTestReportSetupAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportSetupAction);
    
    // Get the iIndexth FhirTestReportSetupAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportSetupAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportSetupAction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestReportSetupActions[index : Integer] : TFhirTestReportSetupAction read GetItemN write SetItemN; default;
  End;

  // The operation performed.
  TFhirTestReportSetupActionOperation = class (TFhirBackboneElement)
  protected
    FResult : TFhirEnum;
    FMessage : TFhirMarkdown;
    FDetail : TFhirUri;
    procedure SetResult(value : TFhirEnum);
    function GetResultST : TFhirTestReportActionResultEnum;
    procedure SetResultST(value : TFhirTestReportActionResultEnum);
    procedure SetMessage(value : TFhirMarkdown);
    function GetMessageST : String;
    procedure SetMessageST(value : String);
    procedure SetDetail(value : TFhirUri);
    function GetDetailST : String;
    procedure SetDetailST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportSetupActionOperation; overload;
    function Clone : TFhirTestReportSetupActionOperation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The result of this operation.
    property result : TFhirTestReportActionResultEnum read GetResultST write SetResultST;
    property resultElement : TFhirEnum read FResult write SetResult;

    // Typed access to An explanatory message associated with the result.
    property message : String read GetMessageST write SetMessageST;
    // An explanatory message associated with the result.
    property messageElement : TFhirMarkdown read FMessage write SetMessage;

    // Typed access to A link to further details on the result.
    property detail : String read GetDetailST write SetDetailST;
    // A link to further details on the result.
    property detailElement : TFhirUri read FDetail write SetDetail;

  end;

  TFhirTestReportSetupActionOperationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportSetupActionOperationList;
    function GetCurrent : TFhirTestReportSetupActionOperation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestReportSetupActionOperationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportSetupActionOperation read GetCurrent;
  end;

  TFhirTestReportSetupActionOperationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestReportSetupActionOperation;
    procedure SetItemN(index : Integer; value : TFhirTestReportSetupActionOperation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestReportSetupActionOperationList; overload;
    function Clone : TFhirTestReportSetupActionOperationList; overload;
    function GetEnumerator : TFhirTestReportSetupActionOperationListEnumerator;
    
    //  Add a FhirTestReportSetupActionOperation to the end of the list.
    function Append : TFhirTestReportSetupActionOperation;
    
    // Add an already existing FhirTestReportSetupActionOperation to the end of the list.
    function AddItem(value : TFhirTestReportSetupActionOperation) : TFhirTestReportSetupActionOperation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportSetupActionOperation) : Integer;
    
    // Insert FhirTestReportSetupActionOperation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportSetupActionOperation;
    
    // Insert an existing FhirTestReportSetupActionOperation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportSetupActionOperation);
    
    // Get the iIndexth FhirTestReportSetupActionOperation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportSetupActionOperation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportSetupActionOperation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestReportSetupActionOperations[index : Integer] : TFhirTestReportSetupActionOperation read GetItemN write SetItemN; default;
  End;

  // The results of the assertion performed on the previous operations.
  TFhirTestReportSetupActionAssert = class (TFhirBackboneElement)
  protected
    FResult : TFhirEnum;
    FMessage : TFhirMarkdown;
    FDetail : TFhirString;
    procedure SetResult(value : TFhirEnum);
    function GetResultST : TFhirTestReportActionResultEnum;
    procedure SetResultST(value : TFhirTestReportActionResultEnum);
    procedure SetMessage(value : TFhirMarkdown);
    function GetMessageST : String;
    procedure SetMessageST(value : String);
    procedure SetDetail(value : TFhirString);
    function GetDetailST : String;
    procedure SetDetailST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportSetupActionAssert; overload;
    function Clone : TFhirTestReportSetupActionAssert; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The result of this assertion.
    property result : TFhirTestReportActionResultEnum read GetResultST write SetResultST;
    property resultElement : TFhirEnum read FResult write SetResult;

    // Typed access to An explanatory message associated with the result.
    property message : String read GetMessageST write SetMessageST;
    // An explanatory message associated with the result.
    property messageElement : TFhirMarkdown read FMessage write SetMessage;

    // Typed access to A link to further details on the result.
    property detail : String read GetDetailST write SetDetailST;
    // A link to further details on the result.
    property detailElement : TFhirString read FDetail write SetDetail;

  end;

  TFhirTestReportSetupActionAssertListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportSetupActionAssertList;
    function GetCurrent : TFhirTestReportSetupActionAssert;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestReportSetupActionAssertList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportSetupActionAssert read GetCurrent;
  end;

  TFhirTestReportSetupActionAssertList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestReportSetupActionAssert;
    procedure SetItemN(index : Integer; value : TFhirTestReportSetupActionAssert);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestReportSetupActionAssertList; overload;
    function Clone : TFhirTestReportSetupActionAssertList; overload;
    function GetEnumerator : TFhirTestReportSetupActionAssertListEnumerator;
    
    //  Add a FhirTestReportSetupActionAssert to the end of the list.
    function Append : TFhirTestReportSetupActionAssert;
    
    // Add an already existing FhirTestReportSetupActionAssert to the end of the list.
    function AddItem(value : TFhirTestReportSetupActionAssert) : TFhirTestReportSetupActionAssert; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportSetupActionAssert) : Integer;
    
    // Insert FhirTestReportSetupActionAssert before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportSetupActionAssert;
    
    // Insert an existing FhirTestReportSetupActionAssert before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportSetupActionAssert);
    
    // Get the iIndexth FhirTestReportSetupActionAssert. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportSetupActionAssert);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportSetupActionAssert;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestReportSetupActionAsserts[index : Integer] : TFhirTestReportSetupActionAssert read GetItemN write SetItemN; default;
  End;

  // A test executed from the test script.
  TFhirTestReportTest = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FDescription : TFhirString;
    FactionList : TFhirTestReportTestActionList;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetActionList : TFhirTestReportTestActionList;
    function GetHasActionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportTest; overload;
    function Clone : TFhirTestReportTest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of this test used for tracking/logging purposes by test engines.
    property name : String read GetNameST write SetNameST;
    // The name of this test used for tracking/logging purposes by test engines.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short description of the test used by test engines for tracking and reporting purposes.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A short description of the test used by test engines for tracking and reporting purposes.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Action would contain either an operation or an assertion.
    property actionList : TFhirTestReportTestActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirTestReportTestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportTestList;
    function GetCurrent : TFhirTestReportTest;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestReportTestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportTest read GetCurrent;
  end;

  TFhirTestReportTestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestReportTest;
    procedure SetItemN(index : Integer; value : TFhirTestReportTest);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestReportTestList; overload;
    function Clone : TFhirTestReportTestList; overload;
    function GetEnumerator : TFhirTestReportTestListEnumerator;
    
    //  Add a FhirTestReportTest to the end of the list.
    function Append : TFhirTestReportTest;
    
    // Add an already existing FhirTestReportTest to the end of the list.
    function AddItem(value : TFhirTestReportTest) : TFhirTestReportTest; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportTest) : Integer;
    
    // Insert FhirTestReportTest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportTest;
    
    // Insert an existing FhirTestReportTest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportTest);
    
    // Get the iIndexth FhirTestReportTest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportTest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportTest;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestReportTests[index : Integer] : TFhirTestReportTest read GetItemN write SetItemN; default;
  End;

  // Action would contain either an operation or an assertion.
  TFhirTestReportTestAction = class (TFhirBackboneElement)
  protected
    FOperation : TFhirTestReportSetupActionOperation;
    FAssert : TFhirTestReportSetupActionAssert;
    procedure SetOperation(value : TFhirTestReportSetupActionOperation);
    procedure SetAssert(value : TFhirTestReportSetupActionAssert);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportTestAction; overload;
    function Clone : TFhirTestReportTestAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An operation would involve a REST request to a server. (defined for API consistency)
    property operation : TFhirTestReportSetupActionOperation read FOperation write SetOperation;
    // An operation would involve a REST request to a server.
    property operationElement : TFhirTestReportSetupActionOperation read FOperation write SetOperation;

    // Typed access to The results of the assertion performed on the previous operations. (defined for API consistency)
    property assert : TFhirTestReportSetupActionAssert read FAssert write SetAssert;
    // The results of the assertion performed on the previous operations.
    property assertElement : TFhirTestReportSetupActionAssert read FAssert write SetAssert;

  end;

  TFhirTestReportTestActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportTestActionList;
    function GetCurrent : TFhirTestReportTestAction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestReportTestActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportTestAction read GetCurrent;
  end;

  TFhirTestReportTestActionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestReportTestAction;
    procedure SetItemN(index : Integer; value : TFhirTestReportTestAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestReportTestActionList; overload;
    function Clone : TFhirTestReportTestActionList; overload;
    function GetEnumerator : TFhirTestReportTestActionListEnumerator;
    
    //  Add a FhirTestReportTestAction to the end of the list.
    function Append : TFhirTestReportTestAction;
    
    // Add an already existing FhirTestReportTestAction to the end of the list.
    function AddItem(value : TFhirTestReportTestAction) : TFhirTestReportTestAction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportTestAction) : Integer;
    
    // Insert FhirTestReportTestAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportTestAction;
    
    // Insert an existing FhirTestReportTestAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportTestAction);
    
    // Get the iIndexth FhirTestReportTestAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportTestAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportTestAction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestReportTestActions[index : Integer] : TFhirTestReportTestAction read GetItemN write SetItemN; default;
  End;

  // The results of the series of operations required to clean up after all the tests were executed (successfully or otherwise).
  TFhirTestReportTeardown = class (TFhirBackboneElement)
  protected
    FactionList : TFhirTestReportTeardownActionList;
    function GetActionList : TFhirTestReportTeardownActionList;
    function GetHasActionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportTeardown; overload;
    function Clone : TFhirTestReportTeardown; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The teardown action will only contain an operation.
    property actionList : TFhirTestReportTeardownActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirTestReportTeardownListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportTeardownList;
    function GetCurrent : TFhirTestReportTeardown;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestReportTeardownList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportTeardown read GetCurrent;
  end;

  TFhirTestReportTeardownList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestReportTeardown;
    procedure SetItemN(index : Integer; value : TFhirTestReportTeardown);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestReportTeardownList; overload;
    function Clone : TFhirTestReportTeardownList; overload;
    function GetEnumerator : TFhirTestReportTeardownListEnumerator;
    
    //  Add a FhirTestReportTeardown to the end of the list.
    function Append : TFhirTestReportTeardown;
    
    // Add an already existing FhirTestReportTeardown to the end of the list.
    function AddItem(value : TFhirTestReportTeardown) : TFhirTestReportTeardown; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportTeardown) : Integer;
    
    // Insert FhirTestReportTeardown before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportTeardown;
    
    // Insert an existing FhirTestReportTeardown before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportTeardown);
    
    // Get the iIndexth FhirTestReportTeardown. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportTeardown);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportTeardown;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestReportTeardowns[index : Integer] : TFhirTestReportTeardown read GetItemN write SetItemN; default;
  End;

  // The teardown action will only contain an operation.
  TFhirTestReportTeardownAction = class (TFhirBackboneElement)
  protected
    FOperation : TFhirTestReportSetupActionOperation;
    procedure SetOperation(value : TFhirTestReportSetupActionOperation);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportTeardownAction; overload;
    function Clone : TFhirTestReportTeardownAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An operation would involve a REST request to a server. (defined for API consistency)
    property operation : TFhirTestReportSetupActionOperation read FOperation write SetOperation;
    // An operation would involve a REST request to a server.
    property operationElement : TFhirTestReportSetupActionOperation read FOperation write SetOperation;

  end;

  TFhirTestReportTeardownActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportTeardownActionList;
    function GetCurrent : TFhirTestReportTeardownAction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestReportTeardownActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportTeardownAction read GetCurrent;
  end;

  TFhirTestReportTeardownActionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestReportTeardownAction;
    procedure SetItemN(index : Integer; value : TFhirTestReportTeardownAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestReportTeardownActionList; overload;
    function Clone : TFhirTestReportTeardownActionList; overload;
    function GetEnumerator : TFhirTestReportTeardownActionListEnumerator;
    
    //  Add a FhirTestReportTeardownAction to the end of the list.
    function Append : TFhirTestReportTeardownAction;
    
    // Add an already existing FhirTestReportTeardownAction to the end of the list.
    function AddItem(value : TFhirTestReportTeardownAction) : TFhirTestReportTeardownAction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportTeardownAction) : Integer;
    
    // Insert FhirTestReportTeardownAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportTeardownAction;
    
    // Insert an existing FhirTestReportTeardownAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportTeardownAction);
    
    // Get the iIndexth FhirTestReportTeardownAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportTeardownAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportTeardownAction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestReportTeardownActions[index : Integer] : TFhirTestReportTeardownAction read GetItemN write SetItemN; default;
  End;

  // A summary of information based on the results of executing a TestScript.
  TFhirTestReport = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FName : TFhirString;
    FStatus : TFhirEnum;
    FTestScript : TFhirCanonical;
    FResult : TFhirEnum;
    FScore : TFhirDecimal;
    FTester : TFhirString;
    FIssued : TFhirDateTime;
    FparticipantList : TFhirTestReportParticipantList;
    FSetup : TFhirTestReportSetup;
    FtestList : TFhirTestReportTestList;
    FTeardown : TFhirTestReportTeardown;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirTestReportStatusEnum;
    procedure SetStatusST(value : TFhirTestReportStatusEnum);
    procedure SetTestScript(value : TFhirCanonical);
    function GetTestScriptST : String;
    procedure SetTestScriptST(value : String);
    procedure SetResult(value : TFhirEnum);
    function GetResultST : TFhirTestReportResultEnum;
    procedure SetResultST(value : TFhirTestReportResultEnum);
    procedure SetScore(value : TFhirDecimal);
    function GetScoreST : String;
    procedure SetScoreST(value : String);
    procedure SetTester(value : TFhirString);
    function GetTesterST : String;
    procedure SetTesterST(value : String);
    procedure SetIssued(value : TFhirDateTime);
    function GetIssuedST : TFslDateTime;
    procedure SetIssuedST(value : TFslDateTime);
    function GetParticipantList : TFhirTestReportParticipantList;
    function GetHasParticipantList : Boolean;
    procedure SetSetup(value : TFhirTestReportSetup);
    function GetTestList : TFhirTestReportTestList;
    function GetHasTestList : Boolean;
    procedure SetTeardown(value : TFhirTestReportTeardown);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReport; overload;
    function Clone : TFhirTestReport; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifier for the TestReport assigned for external purposes outside the context of FHIR. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifier for the TestReport assigned for external purposes outside the context of FHIR.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to A free text natural language name identifying the executed TestReport.
    property name : String read GetNameST write SetNameST;
    // A free text natural language name identifying the executed TestReport.
    property nameElement : TFhirString read FName write SetName;

    // The current state of this test report.
    property status : TFhirTestReportStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Ideally this is an absolute URL that is used to identify the version-specific TestScript that was executed, matching the `TestScript.url`.
    property testScript : String read GetTestScriptST write SetTestScriptST;
    // Ideally this is an absolute URL that is used to identify the version-specific TestScript that was executed, matching the `TestScript.url`.
    property testScriptElement : TFhirCanonical read FTestScript write SetTestScript;

    // The overall result from the execution of the TestScript.
    property result : TFhirTestReportResultEnum read GetResultST write SetResultST;
    property resultElement : TFhirEnum read FResult write SetResult;

    // Typed access to The final score (percentage of tests passed) resulting from the execution of the TestScript.
    property score : String read GetScoreST write SetScoreST;
    // The final score (percentage of tests passed) resulting from the execution of the TestScript.
    property scoreElement : TFhirDecimal read FScore write SetScore;

    // Typed access to Name of the tester producing this report (Organization or individual).
    property tester : String read GetTesterST write SetTesterST;
    // Name of the tester producing this report (Organization or individual).
    property testerElement : TFhirString read FTester write SetTester;

    // Typed access to When the TestScript was executed and this TestReport was generated.
    property issued : TFslDateTime read GetIssuedST write SetIssuedST;
    // When the TestScript was executed and this TestReport was generated.
    property issuedElement : TFhirDateTime read FIssued write SetIssued;

    // A participant in the test execution, either the execution engine, a client, or a server.
    property participantList : TFhirTestReportParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // Typed access to The results of the series of required setup operations before the tests were executed. (defined for API consistency)
    property setup : TFhirTestReportSetup read FSetup write SetSetup;
    // The results of the series of required setup operations before the tests were executed.
    property setupElement : TFhirTestReportSetup read FSetup write SetSetup;

    // A test executed from the test script.
    property testList : TFhirTestReportTestList read GetTestList;
    property hasTestList : boolean read GetHasTestList;

    // Typed access to The results of the series of operations required to clean up after all the tests were executed (successfully or otherwise). (defined for API consistency)
    property teardown : TFhirTestReportTeardown read FTeardown write SetTeardown;
    // The results of the series of operations required to clean up after all the tests were executed (successfully or otherwise).
    property teardownElement : TFhirTestReportTeardown read FTeardown write SetTeardown;

  end;

  TFhirTestReportListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportList;
    function GetCurrent : TFhirTestReport;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestReportList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReport read GetCurrent;
  end;

  TFhirTestReportList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestReport;
    procedure SetItemN(index : Integer; value : TFhirTestReport);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestReportList; overload;
    function Clone : TFhirTestReportList; overload;
    function GetEnumerator : TFhirTestReportListEnumerator;
    
    //  Add a FhirTestReport to the end of the list.
    function Append : TFhirTestReport;
    
    // Add an already existing FhirTestReport to the end of the list.
    function AddItem(value : TFhirTestReport) : TFhirTestReport; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReport) : Integer;
    
    // Insert FhirTestReport before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReport;
    
    // Insert an existing FhirTestReport before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReport);
    
    // Get the iIndexth FhirTestReport. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReport);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReport;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestReports[index : Integer] : TFhirTestReport read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_VERIFICATIONRESULT}
  // Information about the primary source(s) involved in validation.
  TFhirVerificationResultPrimarySource = class (TFhirBackboneElement)
  protected
    FWho : TFhirReference;
    Ftype_List : TFhirCodeableConceptList;
    FcommunicationMethodList : TFhirCodeableConceptList;
    FValidationStatus : TFhirCodeableConcept;
    FValidationDate : TFhirDateTime;
    FCanPushUpdates : TFhirCodeableConcept;
    FpushTypeAvailableList : TFhirCodeableConceptList;
    procedure SetWho(value : TFhirReference);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    function GetCommunicationMethodList : TFhirCodeableConceptList;
    function GetHasCommunicationMethodList : Boolean;
    procedure SetValidationStatus(value : TFhirCodeableConcept);
    procedure SetValidationDate(value : TFhirDateTime);
    function GetValidationDateST : TFslDateTime;
    procedure SetValidationDateST(value : TFslDateTime);
    procedure SetCanPushUpdates(value : TFhirCodeableConcept);
    function GetPushTypeAvailableList : TFhirCodeableConceptList;
    function GetHasPushTypeAvailableList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirVerificationResultPrimarySource; overload;
    function Clone : TFhirVerificationResultPrimarySource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Reference to the primary source. (defined for API consistency)
    property who : TFhirReference read FWho write SetWho;
    // Reference to the primary source.
    property whoElement : TFhirReference read FWho write SetWho;

    // Type of primary source (License Board; Primary Education; Continuing Education; Postal Service; Relationship owner; Registration Authority; legal source; issuing source; authoritative source).
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Method for communicating with the primary source (manual; API; Push).
    property communicationMethodList : TFhirCodeableConceptList read GetCommunicationMethodList;
    property hasCommunicationMethodList : boolean read GetHasCommunicationMethodList;

    // Typed access to Status of the validation of the target against the primary source (successful; failed; unknown). (defined for API consistency)
    property validationStatus : TFhirCodeableConcept read FValidationStatus write SetValidationStatus;
    // Status of the validation of the target against the primary source (successful; failed; unknown).
    property validationStatusElement : TFhirCodeableConcept read FValidationStatus write SetValidationStatus;

    // Typed access to When the target was validated against the primary source.
    property validationDate : TFslDateTime read GetValidationDateST write SetValidationDateST;
    // When the target was validated against the primary source.
    property validationDateElement : TFhirDateTime read FValidationDate write SetValidationDate;

    // Typed access to Ability of the primary source to push updates/alerts (yes; no; undetermined). (defined for API consistency)
    property canPushUpdates : TFhirCodeableConcept read FCanPushUpdates write SetCanPushUpdates;
    // Ability of the primary source to push updates/alerts (yes; no; undetermined).
    property canPushUpdatesElement : TFhirCodeableConcept read FCanPushUpdates write SetCanPushUpdates;

    // Type of alerts/updates the primary source can send (specific requested changes; any changes; as defined by source).
    property pushTypeAvailableList : TFhirCodeableConceptList read GetPushTypeAvailableList;
    property hasPushTypeAvailableList : boolean read GetHasPushTypeAvailableList;

  end;

  TFhirVerificationResultPrimarySourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirVerificationResultPrimarySourceList;
    function GetCurrent : TFhirVerificationResultPrimarySource;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirVerificationResultPrimarySourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirVerificationResultPrimarySource read GetCurrent;
  end;

  TFhirVerificationResultPrimarySourceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirVerificationResultPrimarySource;
    procedure SetItemN(index : Integer; value : TFhirVerificationResultPrimarySource);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirVerificationResultPrimarySourceList; overload;
    function Clone : TFhirVerificationResultPrimarySourceList; overload;
    function GetEnumerator : TFhirVerificationResultPrimarySourceListEnumerator;
    
    //  Add a FhirVerificationResultPrimarySource to the end of the list.
    function Append : TFhirVerificationResultPrimarySource;
    
    // Add an already existing FhirVerificationResultPrimarySource to the end of the list.
    function AddItem(value : TFhirVerificationResultPrimarySource) : TFhirVerificationResultPrimarySource; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirVerificationResultPrimarySource) : Integer;
    
    // Insert FhirVerificationResultPrimarySource before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirVerificationResultPrimarySource;
    
    // Insert an existing FhirVerificationResultPrimarySource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirVerificationResultPrimarySource);
    
    // Get the iIndexth FhirVerificationResultPrimarySource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirVerificationResultPrimarySource);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirVerificationResultPrimarySource;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirVerificationResultPrimarySources[index : Integer] : TFhirVerificationResultPrimarySource read GetItemN write SetItemN; default;
  End;

  // Information about the entity attesting to information.
  TFhirVerificationResultAttestation = class (TFhirBackboneElement)
  protected
    FWho : TFhirReference;
    FOnBehalfOf : TFhirReference;
    FCommunicationMethod : TFhirCodeableConcept;
    FDate : TFhirDate;
    FSourceIdentityCertificate : TFhirString;
    FProxyIdentityCertificate : TFhirString;
    FProxySignature : TFhirSignature;
    FSourceSignature : TFhirSignature;
    procedure SetWho(value : TFhirReference);
    procedure SetOnBehalfOf(value : TFhirReference);
    procedure SetCommunicationMethod(value : TFhirCodeableConcept);
    procedure SetDate(value : TFhirDate);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetSourceIdentityCertificate(value : TFhirString);
    function GetSourceIdentityCertificateST : String;
    procedure SetSourceIdentityCertificateST(value : String);
    procedure SetProxyIdentityCertificate(value : TFhirString);
    function GetProxyIdentityCertificateST : String;
    procedure SetProxyIdentityCertificateST(value : String);
    procedure SetProxySignature(value : TFhirSignature);
    procedure SetSourceSignature(value : TFhirSignature);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirVerificationResultAttestation; overload;
    function Clone : TFhirVerificationResultAttestation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The individual or organization attesting to information. (defined for API consistency)
    property who : TFhirReference read FWho write SetWho;
    // The individual or organization attesting to information.
    property whoElement : TFhirReference read FWho write SetWho;

    // Typed access to When the who is asserting on behalf of another (organization or individual). (defined for API consistency)
    property onBehalfOf : TFhirReference read FOnBehalfOf write SetOnBehalfOf;
    // When the who is asserting on behalf of another (organization or individual).
    property onBehalfOfElement : TFhirReference read FOnBehalfOf write SetOnBehalfOf;

    // Typed access to The method by which attested information was submitted/retrieved (manual; API; Push). (defined for API consistency)
    property communicationMethod : TFhirCodeableConcept read FCommunicationMethod write SetCommunicationMethod;
    // The method by which attested information was submitted/retrieved (manual; API; Push).
    property communicationMethodElement : TFhirCodeableConcept read FCommunicationMethod write SetCommunicationMethod;

    // Typed access to The date the information was attested to.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date the information was attested to.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to A digital identity certificate associated with the attestation source.
    property sourceIdentityCertificate : String read GetSourceIdentityCertificateST write SetSourceIdentityCertificateST;
    // A digital identity certificate associated with the attestation source.
    property sourceIdentityCertificateElement : TFhirString read FSourceIdentityCertificate write SetSourceIdentityCertificate;

    // Typed access to A digital identity certificate associated with the proxy entity submitting attested information on behalf of the attestation source.
    property proxyIdentityCertificate : String read GetProxyIdentityCertificateST write SetProxyIdentityCertificateST;
    // A digital identity certificate associated with the proxy entity submitting attested information on behalf of the attestation source.
    property proxyIdentityCertificateElement : TFhirString read FProxyIdentityCertificate write SetProxyIdentityCertificate;

    // Typed access to Signed assertion by the proxy entity indicating that they have the right to submit attested information on behalf of the attestation source. (defined for API consistency)
    property proxySignature : TFhirSignature read FProxySignature write SetProxySignature;
    // Signed assertion by the proxy entity indicating that they have the right to submit attested information on behalf of the attestation source.
    property proxySignatureElement : TFhirSignature read FProxySignature write SetProxySignature;

    // Typed access to Signed assertion by the attestation source that they have attested to the information. (defined for API consistency)
    property sourceSignature : TFhirSignature read FSourceSignature write SetSourceSignature;
    // Signed assertion by the attestation source that they have attested to the information.
    property sourceSignatureElement : TFhirSignature read FSourceSignature write SetSourceSignature;

  end;

  TFhirVerificationResultAttestationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirVerificationResultAttestationList;
    function GetCurrent : TFhirVerificationResultAttestation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirVerificationResultAttestationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirVerificationResultAttestation read GetCurrent;
  end;

  TFhirVerificationResultAttestationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirVerificationResultAttestation;
    procedure SetItemN(index : Integer; value : TFhirVerificationResultAttestation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirVerificationResultAttestationList; overload;
    function Clone : TFhirVerificationResultAttestationList; overload;
    function GetEnumerator : TFhirVerificationResultAttestationListEnumerator;
    
    //  Add a FhirVerificationResultAttestation to the end of the list.
    function Append : TFhirVerificationResultAttestation;
    
    // Add an already existing FhirVerificationResultAttestation to the end of the list.
    function AddItem(value : TFhirVerificationResultAttestation) : TFhirVerificationResultAttestation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirVerificationResultAttestation) : Integer;
    
    // Insert FhirVerificationResultAttestation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirVerificationResultAttestation;
    
    // Insert an existing FhirVerificationResultAttestation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirVerificationResultAttestation);
    
    // Get the iIndexth FhirVerificationResultAttestation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirVerificationResultAttestation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirVerificationResultAttestation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirVerificationResultAttestations[index : Integer] : TFhirVerificationResultAttestation read GetItemN write SetItemN; default;
  End;

  // Information about the entity validating information.
  TFhirVerificationResultValidator = class (TFhirBackboneElement)
  protected
    FOrganization : TFhirReference;
    FIdentityCertificate : TFhirString;
    FAttestationSignature : TFhirSignature;
    procedure SetOrganization(value : TFhirReference);
    procedure SetIdentityCertificate(value : TFhirString);
    function GetIdentityCertificateST : String;
    procedure SetIdentityCertificateST(value : String);
    procedure SetAttestationSignature(value : TFhirSignature);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirVerificationResultValidator; overload;
    function Clone : TFhirVerificationResultValidator; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Reference to the organization validating information. (defined for API consistency)
    property organization : TFhirReference read FOrganization write SetOrganization;
    // Reference to the organization validating information.
    property organizationElement : TFhirReference read FOrganization write SetOrganization;

    // Typed access to A digital identity certificate associated with the validator.
    property identityCertificate : String read GetIdentityCertificateST write SetIdentityCertificateST;
    // A digital identity certificate associated with the validator.
    property identityCertificateElement : TFhirString read FIdentityCertificate write SetIdentityCertificate;

    // Typed access to Signed assertion by the validator that they have validated the information. (defined for API consistency)
    property attestationSignature : TFhirSignature read FAttestationSignature write SetAttestationSignature;
    // Signed assertion by the validator that they have validated the information.
    property attestationSignatureElement : TFhirSignature read FAttestationSignature write SetAttestationSignature;

  end;

  TFhirVerificationResultValidatorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirVerificationResultValidatorList;
    function GetCurrent : TFhirVerificationResultValidator;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirVerificationResultValidatorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirVerificationResultValidator read GetCurrent;
  end;

  TFhirVerificationResultValidatorList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirVerificationResultValidator;
    procedure SetItemN(index : Integer; value : TFhirVerificationResultValidator);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirVerificationResultValidatorList; overload;
    function Clone : TFhirVerificationResultValidatorList; overload;
    function GetEnumerator : TFhirVerificationResultValidatorListEnumerator;
    
    //  Add a FhirVerificationResultValidator to the end of the list.
    function Append : TFhirVerificationResultValidator;
    
    // Add an already existing FhirVerificationResultValidator to the end of the list.
    function AddItem(value : TFhirVerificationResultValidator) : TFhirVerificationResultValidator; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirVerificationResultValidator) : Integer;
    
    // Insert FhirVerificationResultValidator before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirVerificationResultValidator;
    
    // Insert an existing FhirVerificationResultValidator before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirVerificationResultValidator);
    
    // Get the iIndexth FhirVerificationResultValidator. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirVerificationResultValidator);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirVerificationResultValidator;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirVerificationResultValidators[index : Integer] : TFhirVerificationResultValidator read GetItemN write SetItemN; default;
  End;

  // Describes validation requirements, source(s), status and dates for one or more elements.
  TFhirVerificationResult = class (TFhirDomainResource)
  protected
    FtargetList : TFhirReferenceList;
    FtargetLocationList : TFhirStringList;
    FNeed : TFhirCodeableConcept;
    FStatus : TFhirEnum;
    FStatusDate : TFhirDateTime;
    FValidationType : TFhirCodeableConcept;
    FvalidationProcessList : TFhirCodeableConceptList;
    FFrequency : TFhirTiming;
    FLastPerformed : TFhirDateTime;
    FNextScheduled : TFhirDate;
    FFailureAction : TFhirCodeableConcept;
    FprimarySourceList : TFhirVerificationResultPrimarySourceList;
    FAttestation : TFhirVerificationResultAttestation;
    FvalidatorList : TFhirVerificationResultValidatorList;
    function GetTargetList : TFhirReferenceList;
    function GetHasTargetList : Boolean;
    function GetTargetLocationList : TFhirStringList;
    function GetHasTargetLocationList : Boolean;
    procedure SetNeed(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirStatusEnum;
    procedure SetStatusST(value : TFhirStatusEnum);
    procedure SetStatusDate(value : TFhirDateTime);
    function GetStatusDateST : TFslDateTime;
    procedure SetStatusDateST(value : TFslDateTime);
    procedure SetValidationType(value : TFhirCodeableConcept);
    function GetValidationProcessList : TFhirCodeableConceptList;
    function GetHasValidationProcessList : Boolean;
    procedure SetFrequency(value : TFhirTiming);
    procedure SetLastPerformed(value : TFhirDateTime);
    function GetLastPerformedST : TFslDateTime;
    procedure SetLastPerformedST(value : TFslDateTime);
    procedure SetNextScheduled(value : TFhirDate);
    function GetNextScheduledST : TFslDateTime;
    procedure SetNextScheduledST(value : TFslDateTime);
    procedure SetFailureAction(value : TFhirCodeableConcept);
    function GetPrimarySourceList : TFhirVerificationResultPrimarySourceList;
    function GetHasPrimarySourceList : Boolean;
    procedure SetAttestation(value : TFhirVerificationResultAttestation);
    function GetValidatorList : TFhirVerificationResultValidatorList;
    function GetHasValidatorList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirVerificationResult; overload;
    function Clone : TFhirVerificationResult; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A resource that was validated.
    property targetList : TFhirReferenceList read GetTargetList;
    property hasTargetList : boolean read GetHasTargetList;

    // The fhirpath location(s) within the resource that was validated.
    property targetLocationList : TFhirStringList read GetTargetLocationList;
    property hasTargetLocationList : boolean read GetHasTargetLocationList;

    // Typed access to The frequency with which the target must be validated (none; initial; periodic). (defined for API consistency)
    property need : TFhirCodeableConcept read FNeed write SetNeed;
    // The frequency with which the target must be validated (none; initial; periodic).
    property needElement : TFhirCodeableConcept read FNeed write SetNeed;

    // The validation status of the target (attested; validated; in process; requires revalidation; validation failed; revalidation failed).
    property status : TFhirStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to When the validation status was updated.
    property statusDate : TFslDateTime read GetStatusDateST write SetStatusDateST;
    // When the validation status was updated.
    property statusDateElement : TFhirDateTime read FStatusDate write SetStatusDate;

    // Typed access to What the target is validated against (nothing; primary source; multiple sources). (defined for API consistency)
    property validationType : TFhirCodeableConcept read FValidationType write SetValidationType;
    // What the target is validated against (nothing; primary source; multiple sources).
    property validationTypeElement : TFhirCodeableConcept read FValidationType write SetValidationType;

    // The primary process by which the target is validated (edit check; value set; primary source; multiple sources; standalone; in context).
    property validationProcessList : TFhirCodeableConceptList read GetValidationProcessList;
    property hasValidationProcessList : boolean read GetHasValidationProcessList;

    // Typed access to Frequency of revalidation. (defined for API consistency)
    property frequency : TFhirTiming read FFrequency write SetFrequency;
    // Frequency of revalidation.
    property frequencyElement : TFhirTiming read FFrequency write SetFrequency;

    // Typed access to The date/time validation was last completed (including failed validations).
    property lastPerformed : TFslDateTime read GetLastPerformedST write SetLastPerformedST;
    // The date/time validation was last completed (including failed validations).
    property lastPerformedElement : TFhirDateTime read FLastPerformed write SetLastPerformed;

    // Typed access to The date when target is next validated, if appropriate.
    property nextScheduled : TFslDateTime read GetNextScheduledST write SetNextScheduledST;
    // The date when target is next validated, if appropriate.
    property nextScheduledElement : TFhirDate read FNextScheduled write SetNextScheduled;

    // Typed access to The result if validation fails (fatal; warning; record only; none). (defined for API consistency)
    property failureAction : TFhirCodeableConcept read FFailureAction write SetFailureAction;
    // The result if validation fails (fatal; warning; record only; none).
    property failureActionElement : TFhirCodeableConcept read FFailureAction write SetFailureAction;

    // Information about the primary source(s) involved in validation.
    property primarySourceList : TFhirVerificationResultPrimarySourceList read GetPrimarySourceList;
    property hasPrimarySourceList : boolean read GetHasPrimarySourceList;

    // Typed access to Information about the entity attesting to information. (defined for API consistency)
    property attestation : TFhirVerificationResultAttestation read FAttestation write SetAttestation;
    // Information about the entity attesting to information.
    property attestationElement : TFhirVerificationResultAttestation read FAttestation write SetAttestation;

    // Information about the entity validating information.
    property validatorList : TFhirVerificationResultValidatorList read GetValidatorList;
    property hasValidatorList : boolean read GetHasValidatorList;

  end;

  TFhirVerificationResultListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirVerificationResultList;
    function GetCurrent : TFhirVerificationResult;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirVerificationResultList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirVerificationResult read GetCurrent;
  end;

  TFhirVerificationResultList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirVerificationResult;
    procedure SetItemN(index : Integer; value : TFhirVerificationResult);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirVerificationResultList; overload;
    function Clone : TFhirVerificationResultList; overload;
    function GetEnumerator : TFhirVerificationResultListEnumerator;
    
    //  Add a FhirVerificationResult to the end of the list.
    function Append : TFhirVerificationResult;
    
    // Add an already existing FhirVerificationResult to the end of the list.
    function AddItem(value : TFhirVerificationResult) : TFhirVerificationResult; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirVerificationResult) : Integer;
    
    // Insert FhirVerificationResult before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirVerificationResult;
    
    // Insert an existing FhirVerificationResult before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirVerificationResult);
    
    // Get the iIndexth FhirVerificationResult. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirVerificationResult);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirVerificationResult;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirVerificationResults[index : Integer] : TFhirVerificationResult read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_VERIFICATIONRESULT}



implementation

uses
  fhir5_utilities;



{$IFDEF FHIR_ACTIVITYDEFINITION}
{ TFhirActivityDefinitionParticipant }

constructor TFhirActivityDefinitionParticipant.Create;
begin
  inherited;
end;

destructor TFhirActivityDefinitionParticipant.Destroy;
begin
  FType_.free;
  FTypeCanonical.free;
  FTypeReference.free;
  FRole.free;
  FFunction_.free;
  inherited;
end;

procedure TFhirActivityDefinitionParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirActivityDefinitionParticipant(oSource).type_Element.Clone;
  typeCanonicalElement := TFhirActivityDefinitionParticipant(oSource).typeCanonicalElement.Clone;
  typeReference := TFhirActivityDefinitionParticipant(oSource).typeReference.Clone;
  role := TFhirActivityDefinitionParticipant(oSource).role.Clone;
  function_ := TFhirActivityDefinitionParticipant(oSource).function_.Clone;
end;

procedure TFhirActivityDefinitionParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'typeCanonical') Then
     list.add(self.link, 'typeCanonical', FTypeCanonical.Link);
  if (child_name = 'typeReference') Then
     list.add(self.link, 'typeReference', FTypeReference.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'function') Then
     list.add(self.link, 'function', FFunction_.Link);
end;

procedure TFhirActivityDefinitionParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'typeCanonical', 'canonical', false, TFhirCanonical, FTypeCanonical.Link));
  oList.add(TFHIRProperty.create(self, 'typeReference', 'Reference', false, TFhirReference, FTypeReference.Link));
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));
  oList.add(TFHIRProperty.create(self, 'function', 'CodeableConcept', false, TFhirCodeableConcept, FFunction_.Link));
end;

function TFhirActivityDefinitionParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirActionParticipantTypeEnum, CODES_TFhirActionParticipantTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'typeCanonical') then
  begin
    TypeCanonicalElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'typeReference') then
  begin
    TypeReference := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'function') then
  begin
    Function_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirActivityDefinitionParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirActivityDefinitionParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirActionParticipantTypeEnum[ActionParticipantTypeNull], CODES_TFhirActionParticipantTypeEnum[ActionParticipantTypeNull]) 
  else if (propName = 'typeCanonical') then result := TFhirCanonical.create()
  else if (propName = 'typeReference') then result := TFhirReference.create()
  else if (propName = 'role') then result := TFhirCodeableConcept.create()
  else if (propName = 'function') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirActivityDefinitionParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'typeCanonical') then result := 'canonical'
  else if (propName = 'typeReference') then result := 'Reference'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'function') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirActivityDefinitionParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'typeCanonical') then TypeCanonicalElement := nil
  else if (propName = 'typeReference') then TypeReferenceElement := nil
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'function') then Function_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirActivityDefinitionParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirActionParticipantTypeEnum, CODES_TFhirActionParticipantTypeEnum, new)
  else if (propName = 'typeCanonical') then TypeCanonicalElement := asCanonical(new)
  else if (propName = 'typeReference') then TypeReferenceElement := new as TFhirReference
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept
  else if (propName = 'function') then Function_Element := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirActivityDefinitionParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirActivityDefinitionParticipant.fhirType : string;
begin
  result := 'ActivityDefinition.participant';
end;

function TFhirActivityDefinitionParticipant.Link : TFhirActivityDefinitionParticipant;
begin
  result := TFhirActivityDefinitionParticipant(inherited Link);
end;

function TFhirActivityDefinitionParticipant.Clone : TFhirActivityDefinitionParticipant;
begin
  result := TFhirActivityDefinitionParticipant(inherited Clone);
end;

function TFhirActivityDefinitionParticipant.equals(other : TObject) : boolean; 
var
  o : TFhirActivityDefinitionParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirActivityDefinitionParticipant)) then
    result := false
  else
  begin
    o := TFhirActivityDefinitionParticipant(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(typeCanonicalElement, o.typeCanonicalElement, true) and 
      compareDeep(typeReferenceElement, o.typeReferenceElement, true) and compareDeep(roleElement, o.roleElement, true) and 
      compareDeep(function_Element, o.function_Element, true);
  end;
end;

function TFhirActivityDefinitionParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FTypeCanonical) and isEmptyProp(FTypeReference) and isEmptyProp(FRole) and isEmptyProp(FFunction_);
end;

procedure TFhirActivityDefinitionParticipant.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('typeCanonical');
  fields.add('typeReference');
  fields.add('role');
  fields.add('function');
end;

function TFhirActivityDefinitionParticipant.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirActivityDefinitionParticipant.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirActivityDefinitionParticipant.GetType_ST : TFhirActionParticipantTypeEnum;
begin
  if FType_ = nil then
    result := TFhirActionParticipantTypeEnum(0)
  else
    result := TFhirActionParticipantTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirActionParticipantTypeEnum, FType_.value));
end;

procedure TFhirActivityDefinitionParticipant.SetType_ST(value : TFhirActionParticipantTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirActionParticipantTypeEnum[value], CODES_TFhirActionParticipantTypeEnum[value]);
end;

procedure TFhirActivityDefinitionParticipant.SetTypeCanonical(value : TFhirCanonical);
begin
  FTypeCanonical.free;
  FTypeCanonical := value;
end;

function TFhirActivityDefinitionParticipant.GetTypeCanonicalST : String;
begin
  if FTypeCanonical = nil then
    result := ''
  else
    result := FTypeCanonical.value;
end;

procedure TFhirActivityDefinitionParticipant.SetTypeCanonicalST(value : String);
begin
  if value <> '' then
  begin
    if FTypeCanonical = nil then
      FTypeCanonical := TFhirCanonical.create;
    FTypeCanonical.value := value
  end
  else if FTypeCanonical <> nil then
    FTypeCanonical.value := '';
end;

procedure TFhirActivityDefinitionParticipant.SetTypeReference(value : TFhirReference);
begin
  FTypeReference.free;
  FTypeReference := value;
end;

procedure TFhirActivityDefinitionParticipant.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

procedure TFhirActivityDefinitionParticipant.SetFunction_(value : TFhirCodeableConcept);
begin
  FFunction_.free;
  FFunction_ := value;
end;

{ TFhirActivityDefinitionParticipantListEnumerator }

constructor TFhirActivityDefinitionParticipantListEnumerator.Create(list : TFhirActivityDefinitionParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirActivityDefinitionParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirActivityDefinitionParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirActivityDefinitionParticipantListEnumerator.GetCurrent : TFhirActivityDefinitionParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirActivityDefinitionParticipantListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirActivityDefinitionParticipantList }

function TFhirActivityDefinitionParticipantList.AddItem(value: TFhirActivityDefinitionParticipant): TFhirActivityDefinitionParticipant;
begin
  assert(value.ClassName = 'TFhirActivityDefinitionParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirActivityDefinitionParticipant');
  add(value);
  result := value;
end;

function TFhirActivityDefinitionParticipantList.Append: TFhirActivityDefinitionParticipant;
begin
  result := TFhirActivityDefinitionParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirActivityDefinitionParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirActivityDefinitionParticipantList.GetEnumerator : TFhirActivityDefinitionParticipantListEnumerator;
begin
  result := TFhirActivityDefinitionParticipantListEnumerator.Create(self.link);
end;

function TFhirActivityDefinitionParticipantList.Clone: TFhirActivityDefinitionParticipantList;
begin
  result := TFhirActivityDefinitionParticipantList(inherited Clone);
end;

function TFhirActivityDefinitionParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirActivityDefinitionParticipantList.GetItemN(index: Integer): TFhirActivityDefinitionParticipant;
begin
  result := TFhirActivityDefinitionParticipant(ObjectByIndex[index]);
end;

function TFhirActivityDefinitionParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirActivityDefinitionParticipant;
end;
function TFhirActivityDefinitionParticipantList.IndexOf(value: TFhirActivityDefinitionParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirActivityDefinitionParticipantList.Insert(index: Integer): TFhirActivityDefinitionParticipant;
begin
  result := TFhirActivityDefinitionParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirActivityDefinitionParticipantList.InsertItem(index: Integer; value: TFhirActivityDefinitionParticipant);
begin
  assert(value is TFhirActivityDefinitionParticipant);
  Inherited Insert(index, value);
end;

function TFhirActivityDefinitionParticipantList.Item(index: Integer): TFhirActivityDefinitionParticipant;
begin
  result := TFhirActivityDefinitionParticipant(ObjectByIndex[index]);
end;

function TFhirActivityDefinitionParticipantList.Link: TFhirActivityDefinitionParticipantList;
begin
  result := TFhirActivityDefinitionParticipantList(inherited Link);
end;

procedure TFhirActivityDefinitionParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirActivityDefinitionParticipantList.SetItemByIndex(index: Integer; value: TFhirActivityDefinitionParticipant);
begin
  assert(value is TFhirActivityDefinitionParticipant);
  FhirActivityDefinitionParticipants[index] := value;
end;

procedure TFhirActivityDefinitionParticipantList.SetItemN(index: Integer; value: TFhirActivityDefinitionParticipant);
begin
  assert(value is TFhirActivityDefinitionParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirActivityDefinitionDynamicValue }

constructor TFhirActivityDefinitionDynamicValue.Create;
begin
  inherited;
end;

destructor TFhirActivityDefinitionDynamicValue.Destroy;
begin
  FPath.free;
  FExpression.free;
  inherited;
end;

procedure TFhirActivityDefinitionDynamicValue.Assign(oSource : TFslObject);
begin
  inherited;
  pathElement := TFhirActivityDefinitionDynamicValue(oSource).pathElement.Clone;
  expression := TFhirActivityDefinitionDynamicValue(oSource).expression.Clone;
end;

procedure TFhirActivityDefinitionDynamicValue.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'path') Then
     list.add(self.link, 'path', FPath.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
end;

procedure TFhirActivityDefinitionDynamicValue.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'path', 'string', false, TFhirString, FPath.Link));
  oList.add(TFHIRProperty.create(self, 'expression', 'Expression', false, TFhirExpression, FExpression.Link));
end;

function TFhirActivityDefinitionDynamicValue.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'path') then
  begin
    PathElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    Expression := propValue as TFhirExpression;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirActivityDefinitionDynamicValue.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirActivityDefinitionDynamicValue.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'path') then result := TFhirString.create()
  else if (propName = 'expression') then result := TFhirExpression.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirActivityDefinitionDynamicValue.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'path') then result := 'string'
  else if (propName = 'expression') then result := 'Expression'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirActivityDefinitionDynamicValue.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'path') then PathElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirActivityDefinitionDynamicValue.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'path') then PathElement := asString(new)
  else if (propName = 'expression') then ExpressionElement := new as TFhirExpression
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirActivityDefinitionDynamicValue.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirActivityDefinitionDynamicValue.fhirType : string;
begin
  result := 'ActivityDefinition.dynamicValue';
end;

function TFhirActivityDefinitionDynamicValue.Link : TFhirActivityDefinitionDynamicValue;
begin
  result := TFhirActivityDefinitionDynamicValue(inherited Link);
end;

function TFhirActivityDefinitionDynamicValue.Clone : TFhirActivityDefinitionDynamicValue;
begin
  result := TFhirActivityDefinitionDynamicValue(inherited Clone);
end;

function TFhirActivityDefinitionDynamicValue.equals(other : TObject) : boolean; 
var
  o : TFhirActivityDefinitionDynamicValue;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirActivityDefinitionDynamicValue)) then
    result := false
  else
  begin
    o := TFhirActivityDefinitionDynamicValue(other);
    result := compareDeep(pathElement, o.pathElement, true) and compareDeep(expressionElement, o.expressionElement, true);
  end;
end;

function TFhirActivityDefinitionDynamicValue.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPath) and isEmptyProp(FExpression);
end;

procedure TFhirActivityDefinitionDynamicValue.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('path');
  fields.add('expression');
end;

function TFhirActivityDefinitionDynamicValue.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirActivityDefinitionDynamicValue.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

function TFhirActivityDefinitionDynamicValue.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := FPath.value;
end;

procedure TFhirActivityDefinitionDynamicValue.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

procedure TFhirActivityDefinitionDynamicValue.SetExpression(value : TFhirExpression);
begin
  FExpression.free;
  FExpression := value;
end;

{ TFhirActivityDefinitionDynamicValueListEnumerator }

constructor TFhirActivityDefinitionDynamicValueListEnumerator.Create(list : TFhirActivityDefinitionDynamicValueList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirActivityDefinitionDynamicValueListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirActivityDefinitionDynamicValueListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirActivityDefinitionDynamicValueListEnumerator.GetCurrent : TFhirActivityDefinitionDynamicValue;
begin
  Result := FList[FIndex];
end;

function TFhirActivityDefinitionDynamicValueListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirActivityDefinitionDynamicValueList }

function TFhirActivityDefinitionDynamicValueList.AddItem(value: TFhirActivityDefinitionDynamicValue): TFhirActivityDefinitionDynamicValue;
begin
  assert(value.ClassName = 'TFhirActivityDefinitionDynamicValue', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirActivityDefinitionDynamicValue');
  add(value);
  result := value;
end;

function TFhirActivityDefinitionDynamicValueList.Append: TFhirActivityDefinitionDynamicValue;
begin
  result := TFhirActivityDefinitionDynamicValue.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirActivityDefinitionDynamicValueList.ClearItems;
begin
  Clear;
end;

function TFhirActivityDefinitionDynamicValueList.GetEnumerator : TFhirActivityDefinitionDynamicValueListEnumerator;
begin
  result := TFhirActivityDefinitionDynamicValueListEnumerator.Create(self.link);
end;

function TFhirActivityDefinitionDynamicValueList.Clone: TFhirActivityDefinitionDynamicValueList;
begin
  result := TFhirActivityDefinitionDynamicValueList(inherited Clone);
end;

function TFhirActivityDefinitionDynamicValueList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirActivityDefinitionDynamicValueList.GetItemN(index: Integer): TFhirActivityDefinitionDynamicValue;
begin
  result := TFhirActivityDefinitionDynamicValue(ObjectByIndex[index]);
end;

function TFhirActivityDefinitionDynamicValueList.ItemClass: TFslObjectClass;
begin
  result := TFhirActivityDefinitionDynamicValue;
end;
function TFhirActivityDefinitionDynamicValueList.IndexOf(value: TFhirActivityDefinitionDynamicValue): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirActivityDefinitionDynamicValueList.Insert(index: Integer): TFhirActivityDefinitionDynamicValue;
begin
  result := TFhirActivityDefinitionDynamicValue.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirActivityDefinitionDynamicValueList.InsertItem(index: Integer; value: TFhirActivityDefinitionDynamicValue);
begin
  assert(value is TFhirActivityDefinitionDynamicValue);
  Inherited Insert(index, value);
end;

function TFhirActivityDefinitionDynamicValueList.Item(index: Integer): TFhirActivityDefinitionDynamicValue;
begin
  result := TFhirActivityDefinitionDynamicValue(ObjectByIndex[index]);
end;

function TFhirActivityDefinitionDynamicValueList.Link: TFhirActivityDefinitionDynamicValueList;
begin
  result := TFhirActivityDefinitionDynamicValueList(inherited Link);
end;

procedure TFhirActivityDefinitionDynamicValueList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirActivityDefinitionDynamicValueList.SetItemByIndex(index: Integer; value: TFhirActivityDefinitionDynamicValue);
begin
  assert(value is TFhirActivityDefinitionDynamicValue);
  FhirActivityDefinitionDynamicValues[index] := value;
end;

procedure TFhirActivityDefinitionDynamicValueList.SetItemN(index: Integer; value: TFhirActivityDefinitionDynamicValue);
begin
  assert(value is TFhirActivityDefinitionDynamicValue);
  ObjectByIndex[index] := value;
end;

{ TFhirActivityDefinition }

constructor TFhirActivityDefinition.Create;
begin
  inherited;
end;

destructor TFhirActivityDefinition.Destroy;
begin
  FSubtitle.free;
  FSubject.free;
  FUsage.free;
  FLibrary_List.Free;
  FKind.free;
  FProfile.free;
  FCode.free;
  FIntent.free;
  FPriority.free;
  FDoNotPerform.free;
  FTiming.free;
  FAsNeeded.free;
  FLocation.free;
  FParticipantList.Free;
  FProduct.free;
  FQuantity.free;
  FDosageList.Free;
  FBodySiteList.Free;
  FSpecimenRequirementList.Free;
  FObservationRequirementList.Free;
  FObservationResultRequirementList.Free;
  FTransform.free;
  FDynamicValueList.Free;
  inherited;
end;

procedure TFhirActivityDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  subtitleElement := TFhirActivityDefinition(oSource).subtitleElement.Clone;
  subject := TFhirActivityDefinition(oSource).subject.Clone;
  usageElement := TFhirActivityDefinition(oSource).usageElement.Clone;
  if (TFhirActivityDefinition(oSource).FLibrary_List = nil) then
  begin
    FLibrary_List.free;
    FLibrary_List := nil;
  end
  else
  begin
    if FLibrary_List = nil then
      FLibrary_List := TFhirCanonicalList.Create;
    FLibrary_List.Assign(TFhirActivityDefinition(oSource).FLibrary_List);
  end;
  kindElement := TFhirActivityDefinition(oSource).kindElement.Clone;
  profileElement := TFhirActivityDefinition(oSource).profileElement.Clone;
  code := TFhirActivityDefinition(oSource).code.Clone;
  intentElement := TFhirActivityDefinition(oSource).intentElement.Clone;
  priorityElement := TFhirActivityDefinition(oSource).priorityElement.Clone;
  doNotPerformElement := TFhirActivityDefinition(oSource).doNotPerformElement.Clone;
  timing := TFhirActivityDefinition(oSource).timing.Clone;
  asNeeded := TFhirActivityDefinition(oSource).asNeeded.Clone;
  location := TFhirActivityDefinition(oSource).location.Clone;
  if (TFhirActivityDefinition(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirActivityDefinitionParticipantList.Create;
    FParticipantList.Assign(TFhirActivityDefinition(oSource).FParticipantList);
  end;
  product := TFhirActivityDefinition(oSource).product.Clone;
  quantity := TFhirActivityDefinition(oSource).quantity.Clone;
  if (TFhirActivityDefinition(oSource).FDosageList = nil) then
  begin
    FDosageList.free;
    FDosageList := nil;
  end
  else
  begin
    if FDosageList = nil then
      FDosageList := TFhirDosageList.Create;
    FDosageList.Assign(TFhirActivityDefinition(oSource).FDosageList);
  end;
  if (TFhirActivityDefinition(oSource).FBodySiteList = nil) then
  begin
    FBodySiteList.free;
    FBodySiteList := nil;
  end
  else
  begin
    if FBodySiteList = nil then
      FBodySiteList := TFhirCodeableConceptList.Create;
    FBodySiteList.Assign(TFhirActivityDefinition(oSource).FBodySiteList);
  end;
  if (TFhirActivityDefinition(oSource).FSpecimenRequirementList = nil) then
  begin
    FSpecimenRequirementList.free;
    FSpecimenRequirementList := nil;
  end
  else
  begin
    if FSpecimenRequirementList = nil then
      FSpecimenRequirementList := TFhirCanonicalList.Create;
    FSpecimenRequirementList.Assign(TFhirActivityDefinition(oSource).FSpecimenRequirementList);
  end;
  if (TFhirActivityDefinition(oSource).FObservationRequirementList = nil) then
  begin
    FObservationRequirementList.free;
    FObservationRequirementList := nil;
  end
  else
  begin
    if FObservationRequirementList = nil then
      FObservationRequirementList := TFhirCanonicalList.Create;
    FObservationRequirementList.Assign(TFhirActivityDefinition(oSource).FObservationRequirementList);
  end;
  if (TFhirActivityDefinition(oSource).FObservationResultRequirementList = nil) then
  begin
    FObservationResultRequirementList.free;
    FObservationResultRequirementList := nil;
  end
  else
  begin
    if FObservationResultRequirementList = nil then
      FObservationResultRequirementList := TFhirCanonicalList.Create;
    FObservationResultRequirementList.Assign(TFhirActivityDefinition(oSource).FObservationResultRequirementList);
  end;
  transformElement := TFhirActivityDefinition(oSource).transformElement.Clone;
  if (TFhirActivityDefinition(oSource).FDynamicValueList = nil) then
  begin
    FDynamicValueList.free;
    FDynamicValueList := nil;
  end
  else
  begin
    if FDynamicValueList = nil then
      FDynamicValueList := TFhirActivityDefinitionDynamicValueList.Create;
    FDynamicValueList.Assign(TFhirActivityDefinition(oSource).FDynamicValueList);
  end;
end;

function TFhirActivityDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtActivityDefinition;
end;

procedure TFhirActivityDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'subtitle') Then
     list.add(self.link, 'subtitle', FSubtitle.Link);
  if (child_name = 'subject[x]') or (child_name = 'subject') Then
     list.add(self.link, 'subject[x]', FSubject.Link);
  if (child_name = 'usage') Then
     list.add(self.link, 'usage', FUsage.Link);
  if (child_name = 'library') Then
    list.addAll(self, 'library', FLibrary_List);
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'profile') Then
     list.add(self.link, 'profile', FProfile.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'doNotPerform') Then
     list.add(self.link, 'doNotPerform', FDoNotPerform.Link);
  if (child_name = 'timing[x]') or (child_name = 'timing') Then
     list.add(self.link, 'timing[x]', FTiming.Link);
  if (child_name = 'asNeeded[x]') or (child_name = 'asNeeded') Then
     list.add(self.link, 'asNeeded[x]', FAsNeeded.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'product[x]') or (child_name = 'product') Then
     list.add(self.link, 'product[x]', FProduct.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'dosage') Then
    list.addAll(self, 'dosage', FDosageList);
  if (child_name = 'bodySite') Then
    list.addAll(self, 'bodySite', FBodySiteList);
  if (child_name = 'specimenRequirement') Then
    list.addAll(self, 'specimenRequirement', FSpecimenRequirementList);
  if (child_name = 'observationRequirement') Then
    list.addAll(self, 'observationRequirement', FObservationRequirementList);
  if (child_name = 'observationResultRequirement') Then
    list.addAll(self, 'observationResultRequirement', FObservationResultRequirementList);
  if (child_name = 'transform') Then
     list.add(self.link, 'transform', FTransform.Link);
  if (child_name = 'dynamicValue') Then
    list.addAll(self, 'dynamicValue', FDynamicValueList);
end;

procedure TFhirActivityDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'subtitle', 'string', false, TFhirString, FSubtitle.Link));
  oList.add(TFHIRProperty.create(self, 'subject[x]', 'CodeableConcept|Reference|canonical', false, TFhirDataType, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'usage', 'string', false, TFhirString, FUsage.Link));
  oList.add(TFHIRProperty.create(self, 'library', 'canonical', true, TFhirCanonical, FLibrary_List.Link));
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFhirEnum, FKind.Link));
  oList.add(TFHIRProperty.create(self, 'profile', 'canonical', false, TFhirCanonical, FProfile.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'intent', 'code', false, TFhirEnum, FIntent.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFhirEnum, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'doNotPerform', 'boolean', false, TFhirBoolean, FDoNotPerform.Link));
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'Timing|Age|Range|Duration', false, TFhirDataType, FTiming.Link));
  oList.add(TFHIRProperty.create(self, 'asNeeded[x]', 'boolean|CodeableConcept', false, TFhirDataType, FAsNeeded.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'CodeableReference', false, TFhirCodeableReference, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'participant', 'BackboneElement', true, TFhirActivityDefinitionParticipant, FParticipantList.Link));
  oList.add(TFHIRProperty.create(self, 'product[x]', 'Reference|CodeableConcept', false, TFhirDataType, FProduct.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'dosage', 'Dosage', true, TFhirDosage, FDosageList.Link));
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', true, TFhirCodeableConcept, FBodySiteList.Link));
  oList.add(TFHIRProperty.create(self, 'specimenRequirement', 'canonical', true, TFhirCanonical, FSpecimenRequirementList.Link));
  oList.add(TFHIRProperty.create(self, 'observationRequirement', 'canonical', true, TFhirCanonical, FObservationRequirementList.Link));
  oList.add(TFHIRProperty.create(self, 'observationResultRequirement', 'canonical', true, TFhirCanonical, FObservationResultRequirementList.Link));
  oList.add(TFHIRProperty.create(self, 'transform', 'canonical', false, TFhirCanonical, FTransform.Link));
  oList.add(TFHIRProperty.create(self, 'dynamicValue', 'BackboneElement', true, TFhirActivityDefinitionDynamicValue, FDynamicValueList.Link));
end;

function TFhirActivityDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'subtitle') then
  begin
    SubtitleElement := asString(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference', 'Canonical'])) then
  begin
    Subject := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'usage') then
  begin
    UsageElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'library') then
  begin
    Library_List.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirRequestResourceTypesEnum, CODES_TFhirRequestResourceTypesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'profile') then
  begin
    ProfileElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'intent') then
  begin
    IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, propValue);
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue;
  end
  else if (propName = 'doNotPerform') then
  begin
    DoNotPerformElement := asBoolean(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'timing', ['Timing', 'Age', 'Range', 'Duration'])) then
  begin
    Timing := propValue as TFhirDataType;
    result := propValue;
  end
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then
  begin
    AsNeeded := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirActivityDefinitionParticipant);
    result := propValue;
  end
  else if (isMatchingName(propName, 'product', ['Reference', 'CodeableConcept'])) then
  begin
    Product := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'dosage') then
  begin
    DosageList.add(propValue as TFhirDosage);
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySiteList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'specimenRequirement') then
  begin
    SpecimenRequirementList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'observationRequirement') then
  begin
    ObservationRequirementList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'observationResultRequirement') then
  begin
    ObservationResultRequirementList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'transform') then
  begin
    TransformElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'dynamicValue') then
  begin
    DynamicValueList.add(propValue as TFhirActivityDefinitionDynamicValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirActivityDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'library') then Library_List.insertItem(index, asCanonical(propValue))
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirActivityDefinitionParticipant)
  else if (propName = 'dosage') then DosageList.insertItem(index, propValue as TFhirDosage)
  else if (propName = 'bodySite') then BodySiteList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'specimenRequirement') then SpecimenRequirementList.insertItem(index, asCanonical(propValue))
  else if (propName = 'observationRequirement') then ObservationRequirementList.insertItem(index, asCanonical(propValue))
  else if (propName = 'observationResultRequirement') then ObservationResultRequirementList.insertItem(index, asCanonical(propValue))
  else if (propName = 'dynamicValue') then DynamicValueList.insertItem(index, propValue as TFhirActivityDefinitionDynamicValue)
  else inherited;
end;

function TFhirActivityDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'subtitle') then result := TFhirString.create()
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference', 'Canonical'])) then raise EFHIRException.create('Cannot make property Subject')
  else if (propName = 'usage') then result := TFhirString.create()
  else if (propName = 'library') then result := Library_List.new()
  else if (propName = 'kind') then result := TFhirEnum.create(SYSTEMS_TFhirRequestResourceTypesEnum[RequestResourceTypesNull], CODES_TFhirRequestResourceTypesEnum[RequestResourceTypesNull]) 
  else if (propName = 'profile') then result := TFhirCanonical.create()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'intent') then result := TFhirEnum.create(SYSTEMS_TFhirRequestIntentEnum[RequestIntentNull], CODES_TFhirRequestIntentEnum[RequestIntentNull]) 
  else if (propName = 'priority') then result := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[RequestPriorityNull], CODES_TFhirRequestPriorityEnum[RequestPriorityNull]) 
  else if (propName = 'doNotPerform') then result := TFhirBoolean.create()
  else if (isMatchingName(propName, 'timing', ['Timing', 'Age', 'Range', 'Duration'])) then raise EFHIRException.create('Cannot make property Timing')
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property AsNeeded')
  else if (propName = 'location') then result := TFhirCodeableReference.create()
  else if (propName = 'participant') then result := ParticipantList.new()
  else if (isMatchingName(propName, 'product', ['Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Product')
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'dosage') then result := DosageList.new()
  else if (propName = 'bodySite') then result := BodySiteList.new()
  else if (propName = 'specimenRequirement') then result := SpecimenRequirementList.new()
  else if (propName = 'observationRequirement') then result := ObservationRequirementList.new()
  else if (propName = 'observationResultRequirement') then result := ObservationResultRequirementList.new()
  else if (propName = 'transform') then result := TFhirCanonical.create()
  else if (propName = 'dynamicValue') then result := DynamicValueList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirActivityDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'subtitle') then result := 'string'
  else if (propName = 'subject[x]') then result := 'CodeableConcept|Reference|canonical'
  else if (propName = 'usage') then result := 'string'
  else if (propName = 'library') then result := 'canonical'
  else if (propName = 'kind') then result := 'code'
  else if (propName = 'profile') then result := 'canonical'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'intent') then result := 'code'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'doNotPerform') then result := 'boolean'
  else if (propName = 'timing[x]') then result := 'Timing|Age|Range|Duration'
  else if (propName = 'asNeeded[x]') then result := 'boolean|CodeableConcept'
  else if (propName = 'location') then result := 'CodeableReference'
  else if (propName = 'participant') then result := 'BackboneElement'
  else if (propName = 'product[x]') then result := 'Reference|CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'dosage') then result := 'Dosage'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'specimenRequirement') then result := 'canonical'
  else if (propName = 'observationRequirement') then result := 'canonical'
  else if (propName = 'observationResultRequirement') then result := 'canonical'
  else if (propName = 'transform') then result := 'canonical'
  else if (propName = 'dynamicValue') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirActivityDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'subtitle') then SubtitleElement := nil
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference', 'Canonical'])) then SubjectElement := nil
  else if (propName = 'usage') then UsageElement := nil
  else if (propName = 'library') then deletePropertyValue('library', Library_List, value)
  else if (propName = 'kind') then KindElement := nil
  else if (propName = 'profile') then ProfileElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'doNotPerform') then DoNotPerformElement := nil
  else if (isMatchingName(propName, 'timing', ['Timing', 'Age', 'Range', 'Duration'])) then TimingElement := nil
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then AsNeededElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value)
  else if (isMatchingName(propName, 'product', ['Reference', 'CodeableConcept'])) then ProductElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'dosage') then deletePropertyValue('dosage', DosageList, value)
  else if (propName = 'bodySite') then deletePropertyValue('bodySite', BodySiteList, value)
  else if (propName = 'specimenRequirement') then deletePropertyValue('specimenRequirement', SpecimenRequirementList, value)
  else if (propName = 'observationRequirement') then deletePropertyValue('observationRequirement', ObservationRequirementList, value)
  else if (propName = 'observationResultRequirement') then deletePropertyValue('observationResultRequirement', ObservationResultRequirementList, value)
  else if (propName = 'transform') then TransformElement := nil
  else if (propName = 'dynamicValue') then deletePropertyValue('dynamicValue', DynamicValueList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirActivityDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'subtitle') then SubtitleElement := asString(new)
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference', 'Canonical'])) then SubjectElement := new as TFhirDataType
  else if (propName = 'usage') then UsageElement := asString(new)
  else if (propName = 'library') then replacePropertyValue('library', Library_List, existing, new)
  else if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirRequestResourceTypesEnum, CODES_TFhirRequestResourceTypesEnum, new)
  else if (propName = 'profile') then ProfileElement := asCanonical(new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'intent') then IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, new)
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new)
  else if (propName = 'doNotPerform') then DoNotPerformElement := asBoolean(new)
  else if (isMatchingName(propName, 'timing', ['Timing', 'Age', 'Range', 'Duration'])) then TimingElement := new as TFhirDataType
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then AsNeededElement := new as TFhirDataType
  else if (propName = 'location') then LocationElement := new as TFhirCodeableReference
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new)
  else if (isMatchingName(propName, 'product', ['Reference', 'CodeableConcept'])) then ProductElement := new as TFhirDataType
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'dosage') then replacePropertyValue('dosage', DosageList, existing, new)
  else if (propName = 'bodySite') then replacePropertyValue('bodySite', BodySiteList, existing, new)
  else if (propName = 'specimenRequirement') then replacePropertyValue('specimenRequirement', SpecimenRequirementList, existing, new)
  else if (propName = 'observationRequirement') then replacePropertyValue('observationRequirement', ObservationRequirementList, existing, new)
  else if (propName = 'observationResultRequirement') then replacePropertyValue('observationResultRequirement', ObservationResultRequirementList, existing, new)
  else if (propName = 'transform') then TransformElement := asCanonical(new)
  else if (propName = 'dynamicValue') then replacePropertyValue('dynamicValue', DynamicValueList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirActivityDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'library') then Library_List.move(source, destination)
  else if (propName = 'participant') then ParticipantList.move(source, destination)
  else if (propName = 'dosage') then DosageList.move(source, destination)
  else if (propName = 'bodySite') then BodySiteList.move(source, destination)
  else if (propName = 'specimenRequirement') then SpecimenRequirementList.move(source, destination)
  else if (propName = 'observationRequirement') then ObservationRequirementList.move(source, destination)
  else if (propName = 'observationResultRequirement') then ObservationResultRequirementList.move(source, destination)
  else if (propName = 'dynamicValue') then DynamicValueList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirActivityDefinition.fhirType : string;
begin
  result := 'ActivityDefinition';
end;

function TFhirActivityDefinition.Link : TFhirActivityDefinition;
begin
  result := TFhirActivityDefinition(inherited Link);
end;

function TFhirActivityDefinition.Clone : TFhirActivityDefinition;
begin
  result := TFhirActivityDefinition(inherited Clone);
end;

function TFhirActivityDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirActivityDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirActivityDefinition)) then
    result := false
  else
  begin
    o := TFhirActivityDefinition(other);
    result := compareDeep(subtitleElement, o.subtitleElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(usageElement, o.usageElement, true) and compareDeep(library_List, o.library_List, true) and 
      compareDeep(kindElement, o.kindElement, true) and compareDeep(profileElement, o.profileElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(intentElement, o.intentElement, true) and 
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(doNotPerformElement, o.doNotPerformElement, true) and 
      compareDeep(timingElement, o.timingElement, true) and compareDeep(asNeededElement, o.asNeededElement, true) and 
      compareDeep(locationElement, o.locationElement, true) and compareDeep(participantList, o.participantList, true) and 
      compareDeep(productElement, o.productElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(dosageList, o.dosageList, true) and compareDeep(bodySiteList, o.bodySiteList, true) and 
      compareDeep(specimenRequirementList, o.specimenRequirementList, true) and compareDeep(observationRequirementList, o.observationRequirementList, true) and 
      compareDeep(observationResultRequirementList, o.observationResultRequirementList, true) and 
      compareDeep(transformElement, o.transformElement, true) and compareDeep(dynamicValueList, o.dynamicValueList, true);
  end;
end;

function TFhirActivityDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubtitle) and isEmptyProp(FSubject) and isEmptyProp(FUsage) and isEmptyProp(Flibrary_List) and isEmptyProp(FKind) and isEmptyProp(FProfile) and isEmptyProp(FCode) and isEmptyProp(FIntent) and isEmptyProp(FPriority) and isEmptyProp(FDoNotPerform) and isEmptyProp(FTiming) and isEmptyProp(FAsNeeded) and isEmptyProp(FLocation) and isEmptyProp(FparticipantList) and isEmptyProp(FProduct) and isEmptyProp(FQuantity) and isEmptyProp(FdosageList) and isEmptyProp(FbodySiteList) and isEmptyProp(FspecimenRequirementList) and isEmptyProp(FobservationRequirementList) and isEmptyProp(FobservationResultRequirementList) and isEmptyProp(FTransform) and isEmptyProp(FdynamicValueList);
end;

procedure TFhirActivityDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('subtitle');
  fields.add('status');
  fields.add('experimental');
  fields.add('subject[x]');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('usage');
  fields.add('copyright');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('topic');
  fields.add('author');
  fields.add('editor');
  fields.add('reviewer');
  fields.add('endorser');
  fields.add('relatedArtifact');
  fields.add('library');
  fields.add('kind');
  fields.add('profile');
  fields.add('code');
  fields.add('intent');
  fields.add('priority');
  fields.add('doNotPerform');
  fields.add('timing[x]');
  fields.add('asNeeded[x]');
  fields.add('location');
  fields.add('participant');
  fields.add('product[x]');
  fields.add('quantity');
  fields.add('dosage');
  fields.add('bodySite');
  fields.add('specimenRequirement');
  fields.add('observationRequirement');
  fields.add('observationResultRequirement');
  fields.add('transform');
  fields.add('dynamicValue');
end;

function TFhirActivityDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FLibrary_List.sizeInBytes(magic));
  inc(result, FParticipantList.sizeInBytes(magic));
  inc(result, FDosageList.sizeInBytes(magic));
  inc(result, FBodySiteList.sizeInBytes(magic));
  inc(result, FSpecimenRequirementList.sizeInBytes(magic));
  inc(result, FObservationRequirementList.sizeInBytes(magic));
  inc(result, FObservationResultRequirementList.sizeInBytes(magic));
  inc(result, FDynamicValueList.sizeInBytes(magic));
end;

procedure TFhirActivityDefinition.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirActivityDefinition.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirActivityDefinition.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirActivityDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirActivityDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirActivityDefinition.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirActivityDefinition.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirActivityDefinition.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirActivityDefinition.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirActivityDefinition.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirActivityDefinition.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirActivityDefinition.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirActivityDefinition.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirActivityDefinition.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirActivityDefinition.SetSubtitle(value : TFhirString);
begin
  FSubtitle.free;
  FSubtitle := value;
end;

function TFhirActivityDefinition.GetSubtitleST : String;
begin
  if FSubtitle = nil then
    result := ''
  else
    result := FSubtitle.value;
end;

procedure TFhirActivityDefinition.SetSubtitleST(value : String);
begin
  if value <> '' then
  begin
    if FSubtitle = nil then
      FSubtitle := TFhirString.create;
    FSubtitle.value := value
  end
  else if FSubtitle <> nil then
    FSubtitle.value := '';
end;

procedure TFhirActivityDefinition.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirActivityDefinition.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirActivityDefinition.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirActivityDefinition.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirActivityDefinition.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirActivityDefinition.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirActivityDefinition.SetSubject(value : TFhirDataType);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirActivityDefinition.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirActivityDefinition.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirActivityDefinition.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirActivityDefinition.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirActivityDefinition.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirActivityDefinition.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirActivityDefinition.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirActivityDefinition.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirActivityDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirActivityDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirActivityDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirActivityDefinition.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirActivityDefinition.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirActivityDefinition.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirActivityDefinition.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirActivityDefinition.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirActivityDefinition.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirActivityDefinition.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirActivityDefinition.SetUsage(value : TFhirString);
begin
  FUsage.free;
  FUsage := value;
end;

function TFhirActivityDefinition.GetUsageST : String;
begin
  if FUsage = nil then
    result := ''
  else
    result := FUsage.value;
end;

procedure TFhirActivityDefinition.SetUsageST(value : String);
begin
  if value <> '' then
  begin
    if FUsage = nil then
      FUsage := TFhirString.create;
    FUsage.value := value
  end
  else if FUsage <> nil then
    FUsage.value := '';
end;

procedure TFhirActivityDefinition.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirActivityDefinition.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirActivityDefinition.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

procedure TFhirActivityDefinition.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

function TFhirActivityDefinition.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

procedure TFhirActivityDefinition.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

procedure TFhirActivityDefinition.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

function TFhirActivityDefinition.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

procedure TFhirActivityDefinition.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

procedure TFhirActivityDefinition.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

function TFhirActivityDefinition.GetTopicList : TFhirCodeableConceptList;
begin
  if FTopicList = nil then
    FTopicList := TFhirCodeableConceptList.Create;
  result := FTopicList;
end;

function TFhirActivityDefinition.GetHasTopicList : boolean;
begin
  result := (FTopicList <> nil) and (FTopicList.count > 0);
end;

function TFhirActivityDefinition.GetAuthorList : TFhirContactDetailList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirContactDetailList.Create;
  result := FAuthorList;
end;

function TFhirActivityDefinition.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

function TFhirActivityDefinition.GetEditorList : TFhirContactDetailList;
begin
  if FEditorList = nil then
    FEditorList := TFhirContactDetailList.Create;
  result := FEditorList;
end;

function TFhirActivityDefinition.GetHasEditorList : boolean;
begin
  result := (FEditorList <> nil) and (FEditorList.count > 0);
end;

function TFhirActivityDefinition.GetReviewerList : TFhirContactDetailList;
begin
  if FReviewerList = nil then
    FReviewerList := TFhirContactDetailList.Create;
  result := FReviewerList;
end;

function TFhirActivityDefinition.GetHasReviewerList : boolean;
begin
  result := (FReviewerList <> nil) and (FReviewerList.count > 0);
end;

function TFhirActivityDefinition.GetEndorserList : TFhirContactDetailList;
begin
  if FEndorserList = nil then
    FEndorserList := TFhirContactDetailList.Create;
  result := FEndorserList;
end;

function TFhirActivityDefinition.GetHasEndorserList : boolean;
begin
  result := (FEndorserList <> nil) and (FEndorserList.count > 0);
end;

function TFhirActivityDefinition.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

function TFhirActivityDefinition.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

function TFhirActivityDefinition.GetLibrary_List : TFhirCanonicalList;
begin
  if FLibrary_List = nil then
    FLibrary_List := TFhirCanonicalList.Create;
  result := FLibrary_List;
end;

function TFhirActivityDefinition.GetHasLibrary_List : boolean;
begin
  result := (FLibrary_List <> nil) and (FLibrary_List.count > 0);
end;

procedure TFhirActivityDefinition.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

function TFhirActivityDefinition.GetKindST : TFhirRequestResourceTypesEnum;
begin
  if FKind = nil then
    result := TFhirRequestResourceTypesEnum(0)
  else
    result := TFhirRequestResourceTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestResourceTypesEnum, FKind.value));
end;

procedure TFhirActivityDefinition.SetKindST(value : TFhirRequestResourceTypesEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirRequestResourceTypesEnum[value], CODES_TFhirRequestResourceTypesEnum[value]);
end;

procedure TFhirActivityDefinition.SetProfile(value : TFhirCanonical);
begin
  FProfile.free;
  FProfile := value;
end;

function TFhirActivityDefinition.GetProfileST : String;
begin
  if FProfile = nil then
    result := ''
  else
    result := FProfile.value;
end;

procedure TFhirActivityDefinition.SetProfileST(value : String);
begin
  if value <> '' then
  begin
    if FProfile = nil then
      FProfile := TFhirCanonical.create;
    FProfile.value := value
  end
  else if FProfile <> nil then
    FProfile.value := '';
end;

procedure TFhirActivityDefinition.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirActivityDefinition.SetIntent(value : TFhirEnum);
begin
  FIntent.free;
  FIntent := value;
end;

function TFhirActivityDefinition.GetIntentST : TFhirRequestIntentEnum;
begin
  if FIntent = nil then
    result := TFhirRequestIntentEnum(0)
  else
    result := TFhirRequestIntentEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestIntentEnum, FIntent.value));
end;

procedure TFhirActivityDefinition.SetIntentST(value : TFhirRequestIntentEnum);
begin
  if ord(value) = 0 then
    IntentElement := nil
  else
    IntentElement := TFhirEnum.create(SYSTEMS_TFhirRequestIntentEnum[value], CODES_TFhirRequestIntentEnum[value]);
end;

procedure TFhirActivityDefinition.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirActivityDefinition.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

procedure TFhirActivityDefinition.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

procedure TFhirActivityDefinition.SetDoNotPerform(value : TFhirBoolean);
begin
  FDoNotPerform.free;
  FDoNotPerform := value;
end;

function TFhirActivityDefinition.GetDoNotPerformST : Boolean;
begin
  if FDoNotPerform = nil then
    result := false
  else
    result := FDoNotPerform.value;
end;

procedure TFhirActivityDefinition.SetDoNotPerformST(value : Boolean);
begin
  if FDoNotPerform = nil then
    FDoNotPerform := TFhirBoolean.create;
  FDoNotPerform.value := value
end;

procedure TFhirActivityDefinition.SetTiming(value : TFhirDataType);
begin
  FTiming.free;
  FTiming := value;
end;

procedure TFhirActivityDefinition.SetAsNeeded(value : TFhirDataType);
begin
  FAsNeeded.free;
  FAsNeeded := value;
end;

procedure TFhirActivityDefinition.SetLocation(value : TFhirCodeableReference);
begin
  FLocation.free;
  FLocation := value;
end;

function TFhirActivityDefinition.GetParticipantList : TFhirActivityDefinitionParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirActivityDefinitionParticipantList.Create;
  result := FParticipantList;
end;

function TFhirActivityDefinition.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

procedure TFhirActivityDefinition.SetProduct(value : TFhirDataType);
begin
  FProduct.free;
  FProduct := value;
end;

procedure TFhirActivityDefinition.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

function TFhirActivityDefinition.GetDosageList : TFhirDosageList;
begin
  if FDosageList = nil then
    FDosageList := TFhirDosageList.Create;
  result := FDosageList;
end;

function TFhirActivityDefinition.GetHasDosageList : boolean;
begin
  result := (FDosageList <> nil) and (FDosageList.count > 0);
end;

function TFhirActivityDefinition.GetBodySiteList : TFhirCodeableConceptList;
begin
  if FBodySiteList = nil then
    FBodySiteList := TFhirCodeableConceptList.Create;
  result := FBodySiteList;
end;

function TFhirActivityDefinition.GetHasBodySiteList : boolean;
begin
  result := (FBodySiteList <> nil) and (FBodySiteList.count > 0);
end;

function TFhirActivityDefinition.GetSpecimenRequirementList : TFhirCanonicalList;
begin
  if FSpecimenRequirementList = nil then
    FSpecimenRequirementList := TFhirCanonicalList.Create;
  result := FSpecimenRequirementList;
end;

function TFhirActivityDefinition.GetHasSpecimenRequirementList : boolean;
begin
  result := (FSpecimenRequirementList <> nil) and (FSpecimenRequirementList.count > 0);
end;

function TFhirActivityDefinition.GetObservationRequirementList : TFhirCanonicalList;
begin
  if FObservationRequirementList = nil then
    FObservationRequirementList := TFhirCanonicalList.Create;
  result := FObservationRequirementList;
end;

function TFhirActivityDefinition.GetHasObservationRequirementList : boolean;
begin
  result := (FObservationRequirementList <> nil) and (FObservationRequirementList.count > 0);
end;

function TFhirActivityDefinition.GetObservationResultRequirementList : TFhirCanonicalList;
begin
  if FObservationResultRequirementList = nil then
    FObservationResultRequirementList := TFhirCanonicalList.Create;
  result := FObservationResultRequirementList;
end;

function TFhirActivityDefinition.GetHasObservationResultRequirementList : boolean;
begin
  result := (FObservationResultRequirementList <> nil) and (FObservationResultRequirementList.count > 0);
end;

procedure TFhirActivityDefinition.SetTransform(value : TFhirCanonical);
begin
  FTransform.free;
  FTransform := value;
end;

function TFhirActivityDefinition.GetTransformST : String;
begin
  if FTransform = nil then
    result := ''
  else
    result := FTransform.value;
end;

procedure TFhirActivityDefinition.SetTransformST(value : String);
begin
  if value <> '' then
  begin
    if FTransform = nil then
      FTransform := TFhirCanonical.create;
    FTransform.value := value
  end
  else if FTransform <> nil then
    FTransform.value := '';
end;

function TFhirActivityDefinition.GetDynamicValueList : TFhirActivityDefinitionDynamicValueList;
begin
  if FDynamicValueList = nil then
    FDynamicValueList := TFhirActivityDefinitionDynamicValueList.Create;
  result := FDynamicValueList;
end;

function TFhirActivityDefinition.GetHasDynamicValueList : boolean;
begin
  result := (FDynamicValueList <> nil) and (FDynamicValueList.count > 0);
end;

{ TFhirActivityDefinitionListEnumerator }

constructor TFhirActivityDefinitionListEnumerator.Create(list : TFhirActivityDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirActivityDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirActivityDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirActivityDefinitionListEnumerator.GetCurrent : TFhirActivityDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirActivityDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirActivityDefinitionList }

function TFhirActivityDefinitionList.AddItem(value: TFhirActivityDefinition): TFhirActivityDefinition;
begin
  assert(value.ClassName = 'TFhirActivityDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirActivityDefinition');
  add(value);
  result := value;
end;

function TFhirActivityDefinitionList.Append: TFhirActivityDefinition;
begin
  result := TFhirActivityDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirActivityDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirActivityDefinitionList.GetEnumerator : TFhirActivityDefinitionListEnumerator;
begin
  result := TFhirActivityDefinitionListEnumerator.Create(self.link);
end;

function TFhirActivityDefinitionList.Clone: TFhirActivityDefinitionList;
begin
  result := TFhirActivityDefinitionList(inherited Clone);
end;

function TFhirActivityDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirActivityDefinitionList.GetItemN(index: Integer): TFhirActivityDefinition;
begin
  result := TFhirActivityDefinition(ObjectByIndex[index]);
end;

function TFhirActivityDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirActivityDefinition;
end;
function TFhirActivityDefinitionList.IndexOf(value: TFhirActivityDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirActivityDefinitionList.Insert(index: Integer): TFhirActivityDefinition;
begin
  result := TFhirActivityDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirActivityDefinitionList.InsertItem(index: Integer; value: TFhirActivityDefinition);
begin
  assert(value is TFhirActivityDefinition);
  Inherited Insert(index, value);
end;

function TFhirActivityDefinitionList.Item(index: Integer): TFhirActivityDefinition;
begin
  result := TFhirActivityDefinition(ObjectByIndex[index]);
end;

function TFhirActivityDefinitionList.Link: TFhirActivityDefinitionList;
begin
  result := TFhirActivityDefinitionList(inherited Link);
end;

procedure TFhirActivityDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirActivityDefinitionList.SetItemByIndex(index: Integer; value: TFhirActivityDefinition);
begin
  assert(value is TFhirActivityDefinition);
  FhirActivityDefinitions[index] := value;
end;

procedure TFhirActivityDefinitionList.SetItemN(index: Integer; value: TFhirActivityDefinition);
begin
  assert(value is TFhirActivityDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ARTIFACTASSESSMENT}
{ TFhirArtifactAssessmentContent }

constructor TFhirArtifactAssessmentContent.Create;
begin
  inherited;
end;

destructor TFhirArtifactAssessmentContent.Destroy;
begin
  FInformationType.free;
  FSummary.free;
  FType_.free;
  FClassifierList.Free;
  FAuthor.free;
  FPathList.Free;
  FRelatedArtifactList.Free;
  FFreeToShare.free;
  FComponentList.Free;
  inherited;
end;

procedure TFhirArtifactAssessmentContent.Assign(oSource : TFslObject);
begin
  inherited;
  informationTypeElement := TFhirArtifactAssessmentContent(oSource).informationTypeElement.Clone;
  summaryElement := TFhirArtifactAssessmentContent(oSource).summaryElement.Clone;
  type_ := TFhirArtifactAssessmentContent(oSource).type_.Clone;
  if (TFhirArtifactAssessmentContent(oSource).FClassifierList = nil) then
  begin
    FClassifierList.free;
    FClassifierList := nil;
  end
  else
  begin
    if FClassifierList = nil then
      FClassifierList := TFhirCodeableConceptList.Create;
    FClassifierList.Assign(TFhirArtifactAssessmentContent(oSource).FClassifierList);
  end;
  author := TFhirArtifactAssessmentContent(oSource).author.Clone;
  if (TFhirArtifactAssessmentContent(oSource).FPathList = nil) then
  begin
    FPathList.free;
    FPathList := nil;
  end
  else
  begin
    if FPathList = nil then
      FPathList := TFhirUriList.Create;
    FPathList.Assign(TFhirArtifactAssessmentContent(oSource).FPathList);
  end;
  if (TFhirArtifactAssessmentContent(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirArtifactAssessmentContent(oSource).FRelatedArtifactList);
  end;
  freeToShareElement := TFhirArtifactAssessmentContent(oSource).freeToShareElement.Clone;
  if (TFhirArtifactAssessmentContent(oSource).FComponentList = nil) then
  begin
    FComponentList.free;
    FComponentList := nil;
  end
  else
  begin
    if FComponentList = nil then
      FComponentList := TFhirArtifactAssessmentContentList.Create;
    FComponentList.Assign(TFhirArtifactAssessmentContent(oSource).FComponentList);
  end;
end;

procedure TFhirArtifactAssessmentContent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'informationType') Then
     list.add(self.link, 'informationType', FInformationType.Link);
  if (child_name = 'summary') Then
     list.add(self.link, 'summary', FSummary.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'classifier') Then
    list.addAll(self, 'classifier', FClassifierList);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'path') Then
    list.addAll(self, 'path', FPathList);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'freeToShare') Then
     list.add(self.link, 'freeToShare', FFreeToShare.Link);
  if (child_name = 'component') Then
    list.addAll(self, 'component', FComponentList);
end;

procedure TFhirArtifactAssessmentContent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'informationType', 'code', false, TFhirEnum, FInformationType.Link));
  oList.add(TFHIRProperty.create(self, 'summary', 'markdown', false, TFhirMarkdown, FSummary.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'classifier', 'CodeableConcept', true, TFhirCodeableConcept, FClassifierList.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', false, TFhirReference, FAuthor.Link));
  oList.add(TFHIRProperty.create(self, 'path', 'uri', true, TFhirUri, FPathList.Link));
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link));
  oList.add(TFHIRProperty.create(self, 'freeToShare', 'boolean', false, TFhirBoolean, FFreeToShare.Link));
  oList.add(TFHIRProperty.create(self, 'component', '', true, TFhirArtifactAssessmentContent, FComponentList.Link));
end;

function TFhirArtifactAssessmentContent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'informationType') then
  begin
    InformationTypeElement := asEnum(SYSTEMS_TFhirArtifactAssessmentInformationTypeEnum, CODES_TFhirArtifactAssessmentInformationTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'summary') then
  begin
    SummaryElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'classifier') then
  begin
    ClassifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'path') then
  begin
    PathList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact);
    result := propValue;
  end
  else if (propName = 'freeToShare') then
  begin
    FreeToShareElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'component') then
  begin
    ComponentList.add(propValue as TFhirArtifactAssessmentContent);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirArtifactAssessmentContent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'classifier') then ClassifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'path') then PathList.insertItem(index, asUri(propValue))
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact)
  else if (propName = 'component') then ComponentList.insertItem(index, propValue as TFhirArtifactAssessmentContent)
  else inherited;
end;

function TFhirArtifactAssessmentContent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'informationType') then result := TFhirEnum.create(SYSTEMS_TFhirArtifactAssessmentInformationTypeEnum[ArtifactAssessmentInformationTypeNull], CODES_TFhirArtifactAssessmentInformationTypeEnum[ArtifactAssessmentInformationTypeNull]) 
  else if (propName = 'summary') then result := TFhirMarkdown.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'classifier') then result := ClassifierList.new()
  else if (propName = 'author') then result := TFhirReference.create()
  else if (propName = 'path') then result := PathList.new()
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new()
  else if (propName = 'freeToShare') then result := TFhirBoolean.create()
  else if (propName = 'component') then result := ComponentList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirArtifactAssessmentContent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'informationType') then result := 'code'
  else if (propName = 'summary') then result := 'markdown'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'classifier') then result := 'CodeableConcept'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'path') then result := 'uri'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'freeToShare') then result := 'boolean'
  else if (propName = 'component') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirArtifactAssessmentContent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'informationType') then InformationTypeElement := nil
  else if (propName = 'summary') then SummaryElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'classifier') then deletePropertyValue('classifier', ClassifierList, value)
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'path') then deletePropertyValue('path', PathList, value)
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value)
  else if (propName = 'freeToShare') then FreeToShareElement := nil
  else if (propName = 'component') then deletePropertyValue('component', ComponentList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirArtifactAssessmentContent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'informationType') then InformationTypeElement := asEnum(SYSTEMS_TFhirArtifactAssessmentInformationTypeEnum, CODES_TFhirArtifactAssessmentInformationTypeEnum, new)
  else if (propName = 'summary') then SummaryElement := asMarkdown(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'classifier') then replacePropertyValue('classifier', ClassifierList, existing, new)
  else if (propName = 'author') then AuthorElement := new as TFhirReference
  else if (propName = 'path') then replacePropertyValue('path', PathList, existing, new)
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new)
  else if (propName = 'freeToShare') then FreeToShareElement := asBoolean(new)
  else if (propName = 'component') then replacePropertyValue('component', ComponentList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirArtifactAssessmentContent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'classifier') then ClassifierList.move(source, destination)
  else if (propName = 'path') then PathList.move(source, destination)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination)
  else if (propName = 'component') then ComponentList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirArtifactAssessmentContent.fhirType : string;
begin
  result := 'ArtifactAssessment.content';
end;

function TFhirArtifactAssessmentContent.Link : TFhirArtifactAssessmentContent;
begin
  result := TFhirArtifactAssessmentContent(inherited Link);
end;

function TFhirArtifactAssessmentContent.Clone : TFhirArtifactAssessmentContent;
begin
  result := TFhirArtifactAssessmentContent(inherited Clone);
end;

function TFhirArtifactAssessmentContent.equals(other : TObject) : boolean; 
var
  o : TFhirArtifactAssessmentContent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirArtifactAssessmentContent)) then
    result := false
  else
  begin
    o := TFhirArtifactAssessmentContent(other);
    result := compareDeep(informationTypeElement, o.informationTypeElement, true) and 
      compareDeep(summaryElement, o.summaryElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(classifierList, o.classifierList, true) and compareDeep(authorElement, o.authorElement, true) and 
      compareDeep(pathList, o.pathList, true) and compareDeep(relatedArtifactList, o.relatedArtifactList, true) and 
      compareDeep(freeToShareElement, o.freeToShareElement, true) and compareDeep(componentList, o.componentList, true);
  end;
end;

function TFhirArtifactAssessmentContent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FInformationType) and isEmptyProp(FSummary) and isEmptyProp(FType_) and isEmptyProp(FclassifierList) and isEmptyProp(FAuthor) and isEmptyProp(FpathList) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(FFreeToShare) and isEmptyProp(FcomponentList);
end;

procedure TFhirArtifactAssessmentContent.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('informationType');
  fields.add('summary');
  fields.add('type');
  fields.add('classifier');
  fields.add('author');
  fields.add('path');
  fields.add('relatedArtifact');
  fields.add('freeToShare');
  fields.add('component');
end;

function TFhirArtifactAssessmentContent.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FClassifierList.sizeInBytes(magic));
  inc(result, FPathList.sizeInBytes(magic));
  inc(result, FRelatedArtifactList.sizeInBytes(magic));
  inc(result, FComponentList.sizeInBytes(magic));
end;

procedure TFhirArtifactAssessmentContent.SetInformationType(value : TFhirEnum);
begin
  FInformationType.free;
  FInformationType := value;
end;

function TFhirArtifactAssessmentContent.GetInformationTypeST : TFhirArtifactAssessmentInformationTypeEnum;
begin
  if FInformationType = nil then
    result := TFhirArtifactAssessmentInformationTypeEnum(0)
  else
    result := TFhirArtifactAssessmentInformationTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirArtifactAssessmentInformationTypeEnum, FInformationType.value));
end;

procedure TFhirArtifactAssessmentContent.SetInformationTypeST(value : TFhirArtifactAssessmentInformationTypeEnum);
begin
  if ord(value) = 0 then
    InformationTypeElement := nil
  else
    InformationTypeElement := TFhirEnum.create(SYSTEMS_TFhirArtifactAssessmentInformationTypeEnum[value], CODES_TFhirArtifactAssessmentInformationTypeEnum[value]);
end;

procedure TFhirArtifactAssessmentContent.SetSummary(value : TFhirMarkdown);
begin
  FSummary.free;
  FSummary := value;
end;

function TFhirArtifactAssessmentContent.GetSummaryST : String;
begin
  if FSummary = nil then
    result := ''
  else
    result := FSummary.value;
end;

procedure TFhirArtifactAssessmentContent.SetSummaryST(value : String);
begin
  if value <> '' then
  begin
    if FSummary = nil then
      FSummary := TFhirMarkdown.create;
    FSummary.value := value
  end
  else if FSummary <> nil then
    FSummary.value := '';
end;

procedure TFhirArtifactAssessmentContent.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirArtifactAssessmentContent.GetClassifierList : TFhirCodeableConceptList;
begin
  if FClassifierList = nil then
    FClassifierList := TFhirCodeableConceptList.Create;
  result := FClassifierList;
end;

function TFhirArtifactAssessmentContent.GetHasClassifierList : boolean;
begin
  result := (FClassifierList <> nil) and (FClassifierList.count > 0);
end;

procedure TFhirArtifactAssessmentContent.SetAuthor(value : TFhirReference);
begin
  FAuthor.free;
  FAuthor := value;
end;

function TFhirArtifactAssessmentContent.GetPathList : TFhirUriList;
begin
  if FPathList = nil then
    FPathList := TFhirUriList.Create;
  result := FPathList;
end;

function TFhirArtifactAssessmentContent.GetHasPathList : boolean;
begin
  result := (FPathList <> nil) and (FPathList.count > 0);
end;

function TFhirArtifactAssessmentContent.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

function TFhirArtifactAssessmentContent.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

procedure TFhirArtifactAssessmentContent.SetFreeToShare(value : TFhirBoolean);
begin
  FFreeToShare.free;
  FFreeToShare := value;
end;

function TFhirArtifactAssessmentContent.GetFreeToShareST : Boolean;
begin
  if FFreeToShare = nil then
    result := false
  else
    result := FFreeToShare.value;
end;

procedure TFhirArtifactAssessmentContent.SetFreeToShareST(value : Boolean);
begin
  if FFreeToShare = nil then
    FFreeToShare := TFhirBoolean.create;
  FFreeToShare.value := value
end;

function TFhirArtifactAssessmentContent.GetComponentList : TFhirArtifactAssessmentContentList;
begin
  if FComponentList = nil then
    FComponentList := TFhirArtifactAssessmentContentList.Create;
  result := FComponentList;
end;

function TFhirArtifactAssessmentContent.GetHasComponentList : boolean;
begin
  result := (FComponentList <> nil) and (FComponentList.count > 0);
end;

{ TFhirArtifactAssessmentContentListEnumerator }

constructor TFhirArtifactAssessmentContentListEnumerator.Create(list : TFhirArtifactAssessmentContentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirArtifactAssessmentContentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirArtifactAssessmentContentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirArtifactAssessmentContentListEnumerator.GetCurrent : TFhirArtifactAssessmentContent;
begin
  Result := FList[FIndex];
end;

function TFhirArtifactAssessmentContentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirArtifactAssessmentContentList }

function TFhirArtifactAssessmentContentList.AddItem(value: TFhirArtifactAssessmentContent): TFhirArtifactAssessmentContent;
begin
  assert(value.ClassName = 'TFhirArtifactAssessmentContent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirArtifactAssessmentContent');
  add(value);
  result := value;
end;

function TFhirArtifactAssessmentContentList.Append: TFhirArtifactAssessmentContent;
begin
  result := TFhirArtifactAssessmentContent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirArtifactAssessmentContentList.ClearItems;
begin
  Clear;
end;

function TFhirArtifactAssessmentContentList.GetEnumerator : TFhirArtifactAssessmentContentListEnumerator;
begin
  result := TFhirArtifactAssessmentContentListEnumerator.Create(self.link);
end;

function TFhirArtifactAssessmentContentList.Clone: TFhirArtifactAssessmentContentList;
begin
  result := TFhirArtifactAssessmentContentList(inherited Clone);
end;

function TFhirArtifactAssessmentContentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirArtifactAssessmentContentList.GetItemN(index: Integer): TFhirArtifactAssessmentContent;
begin
  result := TFhirArtifactAssessmentContent(ObjectByIndex[index]);
end;

function TFhirArtifactAssessmentContentList.ItemClass: TFslObjectClass;
begin
  result := TFhirArtifactAssessmentContent;
end;
function TFhirArtifactAssessmentContentList.IndexOf(value: TFhirArtifactAssessmentContent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirArtifactAssessmentContentList.Insert(index: Integer): TFhirArtifactAssessmentContent;
begin
  result := TFhirArtifactAssessmentContent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirArtifactAssessmentContentList.InsertItem(index: Integer; value: TFhirArtifactAssessmentContent);
begin
  assert(value is TFhirArtifactAssessmentContent);
  Inherited Insert(index, value);
end;

function TFhirArtifactAssessmentContentList.Item(index: Integer): TFhirArtifactAssessmentContent;
begin
  result := TFhirArtifactAssessmentContent(ObjectByIndex[index]);
end;

function TFhirArtifactAssessmentContentList.Link: TFhirArtifactAssessmentContentList;
begin
  result := TFhirArtifactAssessmentContentList(inherited Link);
end;

procedure TFhirArtifactAssessmentContentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirArtifactAssessmentContentList.SetItemByIndex(index: Integer; value: TFhirArtifactAssessmentContent);
begin
  assert(value is TFhirArtifactAssessmentContent);
  FhirArtifactAssessmentContents[index] := value;
end;

procedure TFhirArtifactAssessmentContentList.SetItemN(index: Integer; value: TFhirArtifactAssessmentContent);
begin
  assert(value is TFhirArtifactAssessmentContent);
  ObjectByIndex[index] := value;
end;

{ TFhirArtifactAssessment }

constructor TFhirArtifactAssessment.Create;
begin
  inherited;
end;

destructor TFhirArtifactAssessment.Destroy;
begin
  FIdentifierList.Free;
  FCiteAs.free;
  FDate.free;
  FCopyright.free;
  FApprovalDate.free;
  FLastReviewDate.free;
  FArtifact.free;
  FContentList.Free;
  FWorkflowStatus.free;
  FDisposition.free;
  inherited;
end;

procedure TFhirArtifactAssessment.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirArtifactAssessment(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirArtifactAssessment(oSource).FIdentifierList);
  end;
  citeAs := TFhirArtifactAssessment(oSource).citeAs.Clone;
  dateElement := TFhirArtifactAssessment(oSource).dateElement.Clone;
  copyrightElement := TFhirArtifactAssessment(oSource).copyrightElement.Clone;
  approvalDateElement := TFhirArtifactAssessment(oSource).approvalDateElement.Clone;
  lastReviewDateElement := TFhirArtifactAssessment(oSource).lastReviewDateElement.Clone;
  artifact := TFhirArtifactAssessment(oSource).artifact.Clone;
  if (TFhirArtifactAssessment(oSource).FContentList = nil) then
  begin
    FContentList.free;
    FContentList := nil;
  end
  else
  begin
    if FContentList = nil then
      FContentList := TFhirArtifactAssessmentContentList.Create;
    FContentList.Assign(TFhirArtifactAssessment(oSource).FContentList);
  end;
  workflowStatusElement := TFhirArtifactAssessment(oSource).workflowStatusElement.Clone;
  dispositionElement := TFhirArtifactAssessment(oSource).dispositionElement.Clone;
end;

function TFhirArtifactAssessment.GetResourceType : TFhirResourceType;
begin
  result := frtArtifactAssessment;
end;

procedure TFhirArtifactAssessment.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'citeAs[x]') or (child_name = 'citeAs') Then
     list.add(self.link, 'citeAs[x]', FCiteAs.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'approvalDate') Then
     list.add(self.link, 'approvalDate', FApprovalDate.Link);
  if (child_name = 'lastReviewDate') Then
     list.add(self.link, 'lastReviewDate', FLastReviewDate.Link);
  if (child_name = 'artifact[x]') or (child_name = 'artifact') Then
     list.add(self.link, 'artifact[x]', FArtifact.Link);
  if (child_name = 'content') Then
    list.addAll(self, 'content', FContentList);
  if (child_name = 'workflowStatus') Then
     list.add(self.link, 'workflowStatus', FWorkflowStatus.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
end;

procedure TFhirArtifactAssessment.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'citeAs[x]', 'Reference|markdown', false, TFhirDataType, FCiteAs.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));
  oList.add(TFHIRProperty.create(self, 'approvalDate', 'date', false, TFhirDate, FApprovalDate.Link));
  oList.add(TFHIRProperty.create(self, 'lastReviewDate', 'date', false, TFhirDate, FLastReviewDate.Link));
  oList.add(TFHIRProperty.create(self, 'artifact[x]', 'Reference|canonical|uri', false, TFhirDataType, FArtifact.Link));
  oList.add(TFHIRProperty.create(self, 'content', 'BackboneElement', true, TFhirArtifactAssessmentContent, FContentList.Link));
  oList.add(TFHIRProperty.create(self, 'workflowStatus', 'code', false, TFhirEnum, FWorkflowStatus.Link));
  oList.add(TFHIRProperty.create(self, 'disposition', 'code', false, TFhirEnum, FDisposition.Link));
end;

function TFhirArtifactAssessment.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (isMatchingName(propName, 'citeAs', ['Reference', 'Markdown'])) then
  begin
    CiteAs := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'approvalDate') then
  begin
    ApprovalDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'lastReviewDate') then
  begin
    LastReviewDateElement := asDate(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'artifact', ['Reference', 'Canonical', 'Uri'])) then
  begin
    Artifact := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'content') then
  begin
    ContentList.add(propValue as TFhirArtifactAssessmentContent);
    result := propValue;
  end
  else if (propName = 'workflowStatus') then
  begin
    WorkflowStatusElement := asEnum(SYSTEMS_TFhirArtifactAssessmentWorkflowStatusEnum, CODES_TFhirArtifactAssessmentWorkflowStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asEnum(SYSTEMS_TFhirArtifactAssessmentDispositionEnum, CODES_TFhirArtifactAssessmentDispositionEnum, propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirArtifactAssessment.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'content') then ContentList.insertItem(index, propValue as TFhirArtifactAssessmentContent)
  else inherited;
end;

function TFhirArtifactAssessment.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (isMatchingName(propName, 'citeAs', ['Reference', 'Markdown'])) then raise EFHIRException.create('Cannot make property CiteAs')
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'copyright') then result := TFhirMarkdown.create()
  else if (propName = 'approvalDate') then result := TFhirDate.create()
  else if (propName = 'lastReviewDate') then result := TFhirDate.create()
  else if (isMatchingName(propName, 'artifact', ['Reference', 'Canonical', 'Uri'])) then raise EFHIRException.create('Cannot make property Artifact')
  else if (propName = 'content') then result := ContentList.new()
  else if (propName = 'workflowStatus') then result := TFhirEnum.create(SYSTEMS_TFhirArtifactAssessmentWorkflowStatusEnum[ArtifactAssessmentWorkflowStatusNull], CODES_TFhirArtifactAssessmentWorkflowStatusEnum[ArtifactAssessmentWorkflowStatusNull]) 
  else if (propName = 'disposition') then result := TFhirEnum.create(SYSTEMS_TFhirArtifactAssessmentDispositionEnum[ArtifactAssessmentDispositionNull], CODES_TFhirArtifactAssessmentDispositionEnum[ArtifactAssessmentDispositionNull]) 
  else result := inherited createPropertyValue(propName);
end;

function TFhirArtifactAssessment.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'citeAs[x]') then result := 'Reference|markdown'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'approvalDate') then result := 'date'
  else if (propName = 'lastReviewDate') then result := 'date'
  else if (propName = 'artifact[x]') then result := 'Reference|canonical|uri'
  else if (propName = 'content') then result := 'BackboneElement'
  else if (propName = 'workflowStatus') then result := 'code'
  else if (propName = 'disposition') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirArtifactAssessment.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (isMatchingName(propName, 'citeAs', ['Reference', 'Markdown'])) then CiteAsElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'approvalDate') then ApprovalDateElement := nil
  else if (propName = 'lastReviewDate') then LastReviewDateElement := nil
  else if (isMatchingName(propName, 'artifact', ['Reference', 'Canonical', 'Uri'])) then ArtifactElement := nil
  else if (propName = 'content') then deletePropertyValue('content', ContentList, value)
  else if (propName = 'workflowStatus') then WorkflowStatusElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirArtifactAssessment.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (isMatchingName(propName, 'citeAs', ['Reference', 'Markdown'])) then CiteAsElement := new as TFhirDataType
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new)
  else if (propName = 'approvalDate') then ApprovalDateElement := asDate(new)
  else if (propName = 'lastReviewDate') then LastReviewDateElement := asDate(new)
  else if (isMatchingName(propName, 'artifact', ['Reference', 'Canonical', 'Uri'])) then ArtifactElement := new as TFhirDataType
  else if (propName = 'content') then replacePropertyValue('content', ContentList, existing, new)
  else if (propName = 'workflowStatus') then WorkflowStatusElement := asEnum(SYSTEMS_TFhirArtifactAssessmentWorkflowStatusEnum, CODES_TFhirArtifactAssessmentWorkflowStatusEnum, new)
  else if (propName = 'disposition') then DispositionElement := asEnum(SYSTEMS_TFhirArtifactAssessmentDispositionEnum, CODES_TFhirArtifactAssessmentDispositionEnum, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirArtifactAssessment.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'content') then ContentList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirArtifactAssessment.fhirType : string;
begin
  result := 'ArtifactAssessment';
end;

function TFhirArtifactAssessment.Link : TFhirArtifactAssessment;
begin
  result := TFhirArtifactAssessment(inherited Link);
end;

function TFhirArtifactAssessment.Clone : TFhirArtifactAssessment;
begin
  result := TFhirArtifactAssessment(inherited Clone);
end;

function TFhirArtifactAssessment.equals(other : TObject) : boolean; 
var
  o : TFhirArtifactAssessment;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirArtifactAssessment)) then
    result := false
  else
  begin
    o := TFhirArtifactAssessment(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(citeAsElement, o.citeAsElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(copyrightElement, o.copyrightElement, true) and 
      compareDeep(approvalDateElement, o.approvalDateElement, true) and compareDeep(lastReviewDateElement, o.lastReviewDateElement, true) and 
      compareDeep(artifactElement, o.artifactElement, true) and compareDeep(contentList, o.contentList, true) and 
      compareDeep(workflowStatusElement, o.workflowStatusElement, true) and compareDeep(dispositionElement, o.dispositionElement, true);
  end;
end;

function TFhirArtifactAssessment.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FCiteAs) and isEmptyProp(FDate) and isEmptyProp(FCopyright) and isEmptyProp(FApprovalDate) and isEmptyProp(FLastReviewDate) and isEmptyProp(FArtifact) and isEmptyProp(FcontentList) and isEmptyProp(FWorkflowStatus) and isEmptyProp(FDisposition);
end;

procedure TFhirArtifactAssessment.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('citeAs[x]');
  fields.add('date');
  fields.add('copyright');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('artifact[x]');
  fields.add('content');
  fields.add('workflowStatus');
  fields.add('disposition');
end;

function TFhirArtifactAssessment.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FContentList.sizeInBytes(magic));
end;

function TFhirArtifactAssessment.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirArtifactAssessment.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirArtifactAssessment.SetCiteAs(value : TFhirDataType);
begin
  FCiteAs.free;
  FCiteAs := value;
end;

procedure TFhirArtifactAssessment.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirArtifactAssessment.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirArtifactAssessment.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirArtifactAssessment.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirArtifactAssessment.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirArtifactAssessment.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

procedure TFhirArtifactAssessment.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

function TFhirArtifactAssessment.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

procedure TFhirArtifactAssessment.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

procedure TFhirArtifactAssessment.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

function TFhirArtifactAssessment.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

procedure TFhirArtifactAssessment.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

procedure TFhirArtifactAssessment.SetArtifact(value : TFhirDataType);
begin
  FArtifact.free;
  FArtifact := value;
end;

function TFhirArtifactAssessment.GetContentList : TFhirArtifactAssessmentContentList;
begin
  if FContentList = nil then
    FContentList := TFhirArtifactAssessmentContentList.Create;
  result := FContentList;
end;

function TFhirArtifactAssessment.GetHasContentList : boolean;
begin
  result := (FContentList <> nil) and (FContentList.count > 0);
end;

procedure TFhirArtifactAssessment.SetWorkflowStatus(value : TFhirEnum);
begin
  FWorkflowStatus.free;
  FWorkflowStatus := value;
end;

function TFhirArtifactAssessment.GetWorkflowStatusST : TFhirArtifactAssessmentWorkflowStatusEnum;
begin
  if FWorkflowStatus = nil then
    result := TFhirArtifactAssessmentWorkflowStatusEnum(0)
  else
    result := TFhirArtifactAssessmentWorkflowStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirArtifactAssessmentWorkflowStatusEnum, FWorkflowStatus.value));
end;

procedure TFhirArtifactAssessment.SetWorkflowStatusST(value : TFhirArtifactAssessmentWorkflowStatusEnum);
begin
  if ord(value) = 0 then
    WorkflowStatusElement := nil
  else
    WorkflowStatusElement := TFhirEnum.create(SYSTEMS_TFhirArtifactAssessmentWorkflowStatusEnum[value], CODES_TFhirArtifactAssessmentWorkflowStatusEnum[value]);
end;

procedure TFhirArtifactAssessment.SetDisposition(value : TFhirEnum);
begin
  FDisposition.free;
  FDisposition := value;
end;

function TFhirArtifactAssessment.GetDispositionST : TFhirArtifactAssessmentDispositionEnum;
begin
  if FDisposition = nil then
    result := TFhirArtifactAssessmentDispositionEnum(0)
  else
    result := TFhirArtifactAssessmentDispositionEnum(StringArrayIndexOfSensitive(CODES_TFhirArtifactAssessmentDispositionEnum, FDisposition.value));
end;

procedure TFhirArtifactAssessment.SetDispositionST(value : TFhirArtifactAssessmentDispositionEnum);
begin
  if ord(value) = 0 then
    DispositionElement := nil
  else
    DispositionElement := TFhirEnum.create(SYSTEMS_TFhirArtifactAssessmentDispositionEnum[value], CODES_TFhirArtifactAssessmentDispositionEnum[value]);
end;

{ TFhirArtifactAssessmentListEnumerator }

constructor TFhirArtifactAssessmentListEnumerator.Create(list : TFhirArtifactAssessmentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirArtifactAssessmentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirArtifactAssessmentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirArtifactAssessmentListEnumerator.GetCurrent : TFhirArtifactAssessment;
begin
  Result := FList[FIndex];
end;

function TFhirArtifactAssessmentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirArtifactAssessmentList }

function TFhirArtifactAssessmentList.AddItem(value: TFhirArtifactAssessment): TFhirArtifactAssessment;
begin
  assert(value.ClassName = 'TFhirArtifactAssessment', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirArtifactAssessment');
  add(value);
  result := value;
end;

function TFhirArtifactAssessmentList.Append: TFhirArtifactAssessment;
begin
  result := TFhirArtifactAssessment.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirArtifactAssessmentList.ClearItems;
begin
  Clear;
end;

function TFhirArtifactAssessmentList.GetEnumerator : TFhirArtifactAssessmentListEnumerator;
begin
  result := TFhirArtifactAssessmentListEnumerator.Create(self.link);
end;

function TFhirArtifactAssessmentList.Clone: TFhirArtifactAssessmentList;
begin
  result := TFhirArtifactAssessmentList(inherited Clone);
end;

function TFhirArtifactAssessmentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirArtifactAssessmentList.GetItemN(index: Integer): TFhirArtifactAssessment;
begin
  result := TFhirArtifactAssessment(ObjectByIndex[index]);
end;

function TFhirArtifactAssessmentList.ItemClass: TFslObjectClass;
begin
  result := TFhirArtifactAssessment;
end;
function TFhirArtifactAssessmentList.IndexOf(value: TFhirArtifactAssessment): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirArtifactAssessmentList.Insert(index: Integer): TFhirArtifactAssessment;
begin
  result := TFhirArtifactAssessment.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirArtifactAssessmentList.InsertItem(index: Integer; value: TFhirArtifactAssessment);
begin
  assert(value is TFhirArtifactAssessment);
  Inherited Insert(index, value);
end;

function TFhirArtifactAssessmentList.Item(index: Integer): TFhirArtifactAssessment;
begin
  result := TFhirArtifactAssessment(ObjectByIndex[index]);
end;

function TFhirArtifactAssessmentList.Link: TFhirArtifactAssessmentList;
begin
  result := TFhirArtifactAssessmentList(inherited Link);
end;

procedure TFhirArtifactAssessmentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirArtifactAssessmentList.SetItemByIndex(index: Integer; value: TFhirArtifactAssessment);
begin
  assert(value is TFhirArtifactAssessment);
  FhirArtifactAssessments[index] := value;
end;

procedure TFhirArtifactAssessmentList.SetItemN(index: Integer; value: TFhirArtifactAssessment);
begin
  assert(value is TFhirArtifactAssessment);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ARTIFACTASSESSMENT}
{$IFDEF FHIR_AUDITEVENT}
{ TFhirAuditEventOutcome }

constructor TFhirAuditEventOutcome.Create;
begin
  inherited;
end;

destructor TFhirAuditEventOutcome.Destroy;
begin
  FCode.free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirAuditEventOutcome.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirAuditEventOutcome(oSource).code.Clone;
  if (TFhirAuditEventOutcome(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirCodeableConceptList.Create;
    FDetailList.Assign(TFhirAuditEventOutcome(oSource).FDetailList);
  end;
end;

procedure TFhirAuditEventOutcome.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirAuditEventOutcome.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'Coding', false, TFhirCoding, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'detail', 'CodeableConcept', true, TFhirCodeableConcept, FDetailList.Link));
end;

function TFhirAuditEventOutcome.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventOutcome.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirAuditEventOutcome.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCoding.create()
  else if (propName = 'detail') then result := DetailList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventOutcome.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'Coding'
  else if (propName = 'detail') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventOutcome.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventOutcome.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCoding
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventOutcome.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'detail') then DetailList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventOutcome.fhirType : string;
begin
  result := 'AuditEvent.outcome';
end;

function TFhirAuditEventOutcome.Link : TFhirAuditEventOutcome;
begin
  result := TFhirAuditEventOutcome(inherited Link);
end;

function TFhirAuditEventOutcome.Clone : TFhirAuditEventOutcome;
begin
  result := TFhirAuditEventOutcome(inherited Clone);
end;

function TFhirAuditEventOutcome.equals(other : TObject) : boolean; 
var
  o : TFhirAuditEventOutcome;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventOutcome)) then
    result := false
  else
  begin
    o := TFhirAuditEventOutcome(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirAuditEventOutcome.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FdetailList);
end;

procedure TFhirAuditEventOutcome.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('detail');
end;

function TFhirAuditEventOutcome.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FDetailList.sizeInBytes(magic));
end;

procedure TFhirAuditEventOutcome.SetCode(value : TFhirCoding);
begin
  FCode.free;
  FCode := value;
end;

function TFhirAuditEventOutcome.GetDetailList : TFhirCodeableConceptList;
begin
  if FDetailList = nil then
    FDetailList := TFhirCodeableConceptList.Create;
  result := FDetailList;
end;

function TFhirAuditEventOutcome.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

{ TFhirAuditEventOutcomeListEnumerator }

constructor TFhirAuditEventOutcomeListEnumerator.Create(list : TFhirAuditEventOutcomeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventOutcomeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventOutcomeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventOutcomeListEnumerator.GetCurrent : TFhirAuditEventOutcome;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventOutcomeListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAuditEventOutcomeList }

function TFhirAuditEventOutcomeList.AddItem(value: TFhirAuditEventOutcome): TFhirAuditEventOutcome;
begin
  assert(value.ClassName = 'TFhirAuditEventOutcome', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventOutcome');
  add(value);
  result := value;
end;

function TFhirAuditEventOutcomeList.Append: TFhirAuditEventOutcome;
begin
  result := TFhirAuditEventOutcome.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventOutcomeList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventOutcomeList.GetEnumerator : TFhirAuditEventOutcomeListEnumerator;
begin
  result := TFhirAuditEventOutcomeListEnumerator.Create(self.link);
end;

function TFhirAuditEventOutcomeList.Clone: TFhirAuditEventOutcomeList;
begin
  result := TFhirAuditEventOutcomeList(inherited Clone);
end;

function TFhirAuditEventOutcomeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventOutcomeList.GetItemN(index: Integer): TFhirAuditEventOutcome;
begin
  result := TFhirAuditEventOutcome(ObjectByIndex[index]);
end;

function TFhirAuditEventOutcomeList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventOutcome;
end;
function TFhirAuditEventOutcomeList.IndexOf(value: TFhirAuditEventOutcome): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventOutcomeList.Insert(index: Integer): TFhirAuditEventOutcome;
begin
  result := TFhirAuditEventOutcome.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventOutcomeList.InsertItem(index: Integer; value: TFhirAuditEventOutcome);
begin
  assert(value is TFhirAuditEventOutcome);
  Inherited Insert(index, value);
end;

function TFhirAuditEventOutcomeList.Item(index: Integer): TFhirAuditEventOutcome;
begin
  result := TFhirAuditEventOutcome(ObjectByIndex[index]);
end;

function TFhirAuditEventOutcomeList.Link: TFhirAuditEventOutcomeList;
begin
  result := TFhirAuditEventOutcomeList(inherited Link);
end;

procedure TFhirAuditEventOutcomeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventOutcomeList.SetItemByIndex(index: Integer; value: TFhirAuditEventOutcome);
begin
  assert(value is TFhirAuditEventOutcome);
  FhirAuditEventOutcomes[index] := value;
end;

procedure TFhirAuditEventOutcomeList.SetItemN(index: Integer; value: TFhirAuditEventOutcome);
begin
  assert(value is TFhirAuditEventOutcome);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEventAgent }

constructor TFhirAuditEventAgent.Create;
begin
  inherited;
end;

destructor TFhirAuditEventAgent.Destroy;
begin
  FType_.free;
  FRoleList.Free;
  FWho.free;
  FRequestor.free;
  FLocation.free;
  FPolicyList.Free;
  FNetwork.free;
  FAuthorizationList.Free;
  inherited;
end;

procedure TFhirAuditEventAgent.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirAuditEventAgent(oSource).type_.Clone;
  if (TFhirAuditEventAgent(oSource).FRoleList = nil) then
  begin
    FRoleList.free;
    FRoleList := nil;
  end
  else
  begin
    if FRoleList = nil then
      FRoleList := TFhirCodeableConceptList.Create;
    FRoleList.Assign(TFhirAuditEventAgent(oSource).FRoleList);
  end;
  who := TFhirAuditEventAgent(oSource).who.Clone;
  requestorElement := TFhirAuditEventAgent(oSource).requestorElement.Clone;
  location := TFhirAuditEventAgent(oSource).location.Clone;
  if (TFhirAuditEventAgent(oSource).FPolicyList = nil) then
  begin
    FPolicyList.free;
    FPolicyList := nil;
  end
  else
  begin
    if FPolicyList = nil then
      FPolicyList := TFhirUriList.Create;
    FPolicyList.Assign(TFhirAuditEventAgent(oSource).FPolicyList);
  end;
  network := TFhirAuditEventAgent(oSource).network.Clone;
  if (TFhirAuditEventAgent(oSource).FAuthorizationList = nil) then
  begin
    FAuthorizationList.free;
    FAuthorizationList := nil;
  end
  else
  begin
    if FAuthorizationList = nil then
      FAuthorizationList := TFhirCodeableConceptList.Create;
    FAuthorizationList.Assign(TFhirAuditEventAgent(oSource).FAuthorizationList);
  end;
end;

procedure TFhirAuditEventAgent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'role') Then
    list.addAll(self, 'role', FRoleList);
  if (child_name = 'who') Then
     list.add(self.link, 'who', FWho.Link);
  if (child_name = 'requestor') Then
     list.add(self.link, 'requestor', FRequestor.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'policy') Then
    list.addAll(self, 'policy', FPolicyList);
  if (child_name = 'network[x]') or (child_name = 'network') Then
     list.add(self.link, 'network[x]', FNetwork.Link);
  if (child_name = 'authorization') Then
    list.addAll(self, 'authorization', FAuthorizationList);
end;

procedure TFhirAuditEventAgent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', true, TFhirCodeableConcept, FRoleList.Link));
  oList.add(TFHIRProperty.create(self, 'who', 'Reference', false, TFhirReference, FWho.Link));
  oList.add(TFHIRProperty.create(self, 'requestor', 'boolean', false, TFhirBoolean, FRequestor.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'policy', 'uri', true, TFhirUri, FPolicyList.Link));
  oList.add(TFHIRProperty.create(self, 'network[x]', 'Reference|uri|string', false, TFhirDataType, FNetwork.Link));
  oList.add(TFHIRProperty.create(self, 'authorization', 'CodeableConcept', true, TFhirCodeableConcept, FAuthorizationList.Link));
end;

function TFhirAuditEventAgent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    RoleList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'who') then
  begin
    Who := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'requestor') then
  begin
    RequestorElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'policy') then
  begin
    PolicyList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (isMatchingName(propName, 'network', ['Reference', 'Uri', 'String'])) then
  begin
    Network := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'authorization') then
  begin
    AuthorizationList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventAgent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'role') then RoleList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'policy') then PolicyList.insertItem(index, asUri(propValue))
  else if (propName = 'authorization') then AuthorizationList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirAuditEventAgent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'role') then result := RoleList.new()
  else if (propName = 'who') then result := TFhirReference.create()
  else if (propName = 'requestor') then result := TFhirBoolean.create()
  else if (propName = 'location') then result := TFhirReference.create()
  else if (propName = 'policy') then result := PolicyList.new()
  else if (isMatchingName(propName, 'network', ['Reference', 'Uri', 'String'])) then raise EFHIRException.create('Cannot make property Network')
  else if (propName = 'authorization') then result := AuthorizationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventAgent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'who') then result := 'Reference'
  else if (propName = 'requestor') then result := 'boolean'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'policy') then result := 'uri'
  else if (propName = 'network[x]') then result := 'Reference|uri|string'
  else if (propName = 'authorization') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventAgent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'role') then deletePropertyValue('role', RoleList, value)
  else if (propName = 'who') then WhoElement := nil
  else if (propName = 'requestor') then RequestorElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'policy') then deletePropertyValue('policy', PolicyList, value)
  else if (isMatchingName(propName, 'network', ['Reference', 'Uri', 'String'])) then NetworkElement := nil
  else if (propName = 'authorization') then deletePropertyValue('authorization', AuthorizationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventAgent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'role') then replacePropertyValue('role', RoleList, existing, new)
  else if (propName = 'who') then WhoElement := new as TFhirReference
  else if (propName = 'requestor') then RequestorElement := asBoolean(new)
  else if (propName = 'location') then LocationElement := new as TFhirReference
  else if (propName = 'policy') then replacePropertyValue('policy', PolicyList, existing, new)
  else if (isMatchingName(propName, 'network', ['Reference', 'Uri', 'String'])) then NetworkElement := new as TFhirDataType
  else if (propName = 'authorization') then replacePropertyValue('authorization', AuthorizationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventAgent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'role') then RoleList.move(source, destination)
  else if (propName = 'policy') then PolicyList.move(source, destination)
  else if (propName = 'authorization') then AuthorizationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventAgent.fhirType : string;
begin
  result := 'AuditEvent.agent';
end;

function TFhirAuditEventAgent.Link : TFhirAuditEventAgent;
begin
  result := TFhirAuditEventAgent(inherited Link);
end;

function TFhirAuditEventAgent.Clone : TFhirAuditEventAgent;
begin
  result := TFhirAuditEventAgent(inherited Clone);
end;

function TFhirAuditEventAgent.equals(other : TObject) : boolean; 
var
  o : TFhirAuditEventAgent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventAgent)) then
    result := false
  else
  begin
    o := TFhirAuditEventAgent(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(roleList, o.roleList, true) and 
      compareDeep(whoElement, o.whoElement, true) and compareDeep(requestorElement, o.requestorElement, true) and 
      compareDeep(locationElement, o.locationElement, true) and compareDeep(policyList, o.policyList, true) and 
      compareDeep(networkElement, o.networkElement, true) and compareDeep(authorizationList, o.authorizationList, true);
  end;
end;

function TFhirAuditEventAgent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FroleList) and isEmptyProp(FWho) and isEmptyProp(FRequestor) and isEmptyProp(FLocation) and isEmptyProp(FpolicyList) and isEmptyProp(FNetwork) and isEmptyProp(FauthorizationList);
end;

procedure TFhirAuditEventAgent.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('role');
  fields.add('who');
  fields.add('requestor');
  fields.add('location');
  fields.add('policy');
  fields.add('network[x]');
  fields.add('authorization');
end;

function TFhirAuditEventAgent.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FRoleList.sizeInBytes(magic));
  inc(result, FPolicyList.sizeInBytes(magic));
  inc(result, FAuthorizationList.sizeInBytes(magic));
end;

procedure TFhirAuditEventAgent.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirAuditEventAgent.GetRoleList : TFhirCodeableConceptList;
begin
  if FRoleList = nil then
    FRoleList := TFhirCodeableConceptList.Create;
  result := FRoleList;
end;

function TFhirAuditEventAgent.GetHasRoleList : boolean;
begin
  result := (FRoleList <> nil) and (FRoleList.count > 0);
end;

procedure TFhirAuditEventAgent.SetWho(value : TFhirReference);
begin
  FWho.free;
  FWho := value;
end;

procedure TFhirAuditEventAgent.SetRequestor(value : TFhirBoolean);
begin
  FRequestor.free;
  FRequestor := value;
end;

function TFhirAuditEventAgent.GetRequestorST : Boolean;
begin
  if FRequestor = nil then
    result := false
  else
    result := FRequestor.value;
end;

procedure TFhirAuditEventAgent.SetRequestorST(value : Boolean);
begin
  if FRequestor = nil then
    FRequestor := TFhirBoolean.create;
  FRequestor.value := value
end;

procedure TFhirAuditEventAgent.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value;
end;

function TFhirAuditEventAgent.GetPolicyList : TFhirUriList;
begin
  if FPolicyList = nil then
    FPolicyList := TFhirUriList.Create;
  result := FPolicyList;
end;

function TFhirAuditEventAgent.GetHasPolicyList : boolean;
begin
  result := (FPolicyList <> nil) and (FPolicyList.count > 0);
end;

procedure TFhirAuditEventAgent.SetNetwork(value : TFhirDataType);
begin
  FNetwork.free;
  FNetwork := value;
end;

function TFhirAuditEventAgent.GetAuthorizationList : TFhirCodeableConceptList;
begin
  if FAuthorizationList = nil then
    FAuthorizationList := TFhirCodeableConceptList.Create;
  result := FAuthorizationList;
end;

function TFhirAuditEventAgent.GetHasAuthorizationList : boolean;
begin
  result := (FAuthorizationList <> nil) and (FAuthorizationList.count > 0);
end;

{ TFhirAuditEventAgentListEnumerator }

constructor TFhirAuditEventAgentListEnumerator.Create(list : TFhirAuditEventAgentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventAgentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventAgentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventAgentListEnumerator.GetCurrent : TFhirAuditEventAgent;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventAgentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAuditEventAgentList }

function TFhirAuditEventAgentList.AddItem(value: TFhirAuditEventAgent): TFhirAuditEventAgent;
begin
  assert(value.ClassName = 'TFhirAuditEventAgent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventAgent');
  add(value);
  result := value;
end;

function TFhirAuditEventAgentList.Append: TFhirAuditEventAgent;
begin
  result := TFhirAuditEventAgent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventAgentList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventAgentList.GetEnumerator : TFhirAuditEventAgentListEnumerator;
begin
  result := TFhirAuditEventAgentListEnumerator.Create(self.link);
end;

function TFhirAuditEventAgentList.Clone: TFhirAuditEventAgentList;
begin
  result := TFhirAuditEventAgentList(inherited Clone);
end;

function TFhirAuditEventAgentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventAgentList.GetItemN(index: Integer): TFhirAuditEventAgent;
begin
  result := TFhirAuditEventAgent(ObjectByIndex[index]);
end;

function TFhirAuditEventAgentList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventAgent;
end;
function TFhirAuditEventAgentList.IndexOf(value: TFhirAuditEventAgent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventAgentList.Insert(index: Integer): TFhirAuditEventAgent;
begin
  result := TFhirAuditEventAgent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventAgentList.InsertItem(index: Integer; value: TFhirAuditEventAgent);
begin
  assert(value is TFhirAuditEventAgent);
  Inherited Insert(index, value);
end;

function TFhirAuditEventAgentList.Item(index: Integer): TFhirAuditEventAgent;
begin
  result := TFhirAuditEventAgent(ObjectByIndex[index]);
end;

function TFhirAuditEventAgentList.Link: TFhirAuditEventAgentList;
begin
  result := TFhirAuditEventAgentList(inherited Link);
end;

procedure TFhirAuditEventAgentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventAgentList.SetItemByIndex(index: Integer; value: TFhirAuditEventAgent);
begin
  assert(value is TFhirAuditEventAgent);
  FhirAuditEventAgents[index] := value;
end;

procedure TFhirAuditEventAgentList.SetItemN(index: Integer; value: TFhirAuditEventAgent);
begin
  assert(value is TFhirAuditEventAgent);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEventSource }

constructor TFhirAuditEventSource.Create;
begin
  inherited;
end;

destructor TFhirAuditEventSource.Destroy;
begin
  FSite.free;
  FObserver.free;
  FType_List.Free;
  inherited;
end;

procedure TFhirAuditEventSource.Assign(oSource : TFslObject);
begin
  inherited;
  site := TFhirAuditEventSource(oSource).site.Clone;
  observer := TFhirAuditEventSource(oSource).observer.Clone;
  if (TFhirAuditEventSource(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirAuditEventSource(oSource).FType_List);
  end;
end;

procedure TFhirAuditEventSource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'site') Then
     list.add(self.link, 'site', FSite.Link);
  if (child_name = 'observer') Then
     list.add(self.link, 'observer', FObserver.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
end;

procedure TFhirAuditEventSource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'site', 'Reference', false, TFhirReference, FSite.Link));
  oList.add(TFHIRProperty.create(self, 'observer', 'Reference', false, TFhirReference, FObserver.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
end;

function TFhirAuditEventSource.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'site') then
  begin
    Site := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'observer') then
  begin
    Observer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventSource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirAuditEventSource.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'site') then result := TFhirReference.create()
  else if (propName = 'observer') then result := TFhirReference.create()
  else if (propName = 'type') then result := Type_List.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventSource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'site') then result := 'Reference'
  else if (propName = 'observer') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventSource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'site') then SiteElement := nil
  else if (propName = 'observer') then ObserverElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventSource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'site') then SiteElement := new as TFhirReference
  else if (propName = 'observer') then ObserverElement := new as TFhirReference
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventSource.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventSource.fhirType : string;
begin
  result := 'AuditEvent.source';
end;

function TFhirAuditEventSource.Link : TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource(inherited Link);
end;

function TFhirAuditEventSource.Clone : TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource(inherited Clone);
end;

function TFhirAuditEventSource.equals(other : TObject) : boolean; 
var
  o : TFhirAuditEventSource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventSource)) then
    result := false
  else
  begin
    o := TFhirAuditEventSource(other);
    result := compareDeep(siteElement, o.siteElement, true) and compareDeep(observerElement, o.observerElement, true) and 
      compareDeep(type_List, o.type_List, true);
  end;
end;

function TFhirAuditEventSource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSite) and isEmptyProp(FObserver) and isEmptyProp(Ftype_List);
end;

procedure TFhirAuditEventSource.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('site');
  fields.add('observer');
  fields.add('type');
end;

function TFhirAuditEventSource.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FType_List.sizeInBytes(magic));
end;

procedure TFhirAuditEventSource.SetSite(value : TFhirReference);
begin
  FSite.free;
  FSite := value;
end;

procedure TFhirAuditEventSource.SetObserver(value : TFhirReference);
begin
  FObserver.free;
  FObserver := value;
end;

function TFhirAuditEventSource.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirAuditEventSource.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

{ TFhirAuditEventSourceListEnumerator }

constructor TFhirAuditEventSourceListEnumerator.Create(list : TFhirAuditEventSourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventSourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventSourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventSourceListEnumerator.GetCurrent : TFhirAuditEventSource;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventSourceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAuditEventSourceList }

function TFhirAuditEventSourceList.AddItem(value: TFhirAuditEventSource): TFhirAuditEventSource;
begin
  assert(value.ClassName = 'TFhirAuditEventSource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventSource');
  add(value);
  result := value;
end;

function TFhirAuditEventSourceList.Append: TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventSourceList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventSourceList.GetEnumerator : TFhirAuditEventSourceListEnumerator;
begin
  result := TFhirAuditEventSourceListEnumerator.Create(self.link);
end;

function TFhirAuditEventSourceList.Clone: TFhirAuditEventSourceList;
begin
  result := TFhirAuditEventSourceList(inherited Clone);
end;

function TFhirAuditEventSourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventSourceList.GetItemN(index: Integer): TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource(ObjectByIndex[index]);
end;

function TFhirAuditEventSourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventSource;
end;
function TFhirAuditEventSourceList.IndexOf(value: TFhirAuditEventSource): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventSourceList.Insert(index: Integer): TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventSourceList.InsertItem(index: Integer; value: TFhirAuditEventSource);
begin
  assert(value is TFhirAuditEventSource);
  Inherited Insert(index, value);
end;

function TFhirAuditEventSourceList.Item(index: Integer): TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource(ObjectByIndex[index]);
end;

function TFhirAuditEventSourceList.Link: TFhirAuditEventSourceList;
begin
  result := TFhirAuditEventSourceList(inherited Link);
end;

procedure TFhirAuditEventSourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventSourceList.SetItemByIndex(index: Integer; value: TFhirAuditEventSource);
begin
  assert(value is TFhirAuditEventSource);
  FhirAuditEventSources[index] := value;
end;

procedure TFhirAuditEventSourceList.SetItemN(index: Integer; value: TFhirAuditEventSource);
begin
  assert(value is TFhirAuditEventSource);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEventEntity }

constructor TFhirAuditEventEntity.Create;
begin
  inherited;
end;

destructor TFhirAuditEventEntity.Destroy;
begin
  FWhat.free;
  FRole.free;
  FSecurityLabelList.Free;
  FQuery.free;
  FDetailList.Free;
  FAgentList.Free;
  inherited;
end;

procedure TFhirAuditEventEntity.Assign(oSource : TFslObject);
begin
  inherited;
  what := TFhirAuditEventEntity(oSource).what.Clone;
  role := TFhirAuditEventEntity(oSource).role.Clone;
  if (TFhirAuditEventEntity(oSource).FSecurityLabelList = nil) then
  begin
    FSecurityLabelList.free;
    FSecurityLabelList := nil;
  end
  else
  begin
    if FSecurityLabelList = nil then
      FSecurityLabelList := TFhirCodeableConceptList.Create;
    FSecurityLabelList.Assign(TFhirAuditEventEntity(oSource).FSecurityLabelList);
  end;
  queryElement := TFhirAuditEventEntity(oSource).queryElement.Clone;
  if (TFhirAuditEventEntity(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirAuditEventEntityDetailList.Create;
    FDetailList.Assign(TFhirAuditEventEntity(oSource).FDetailList);
  end;
  if (TFhirAuditEventEntity(oSource).FAgentList = nil) then
  begin
    FAgentList.free;
    FAgentList := nil;
  end
  else
  begin
    if FAgentList = nil then
      FAgentList := TFhirAuditEventAgentList.Create;
    FAgentList.Assign(TFhirAuditEventEntity(oSource).FAgentList);
  end;
end;

procedure TFhirAuditEventEntity.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'what') Then
     list.add(self.link, 'what', FWhat.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'securityLabel') Then
    list.addAll(self, 'securityLabel', FSecurityLabelList);
  if (child_name = 'query') Then
     list.add(self.link, 'query', FQuery.Link);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
  if (child_name = 'agent') Then
    list.addAll(self, 'agent', FAgentList);
end;

procedure TFhirAuditEventEntity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'what', 'Reference', false, TFhirReference, FWhat.Link));
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));
  oList.add(TFHIRProperty.create(self, 'securityLabel', 'CodeableConcept', true, TFhirCodeableConcept, FSecurityLabelList.Link));
  oList.add(TFHIRProperty.create(self, 'query', 'base64Binary', false, TFhirBase64Binary, FQuery.Link));
  oList.add(TFHIRProperty.create(self, 'detail', 'BackboneElement', true, TFhirAuditEventEntityDetail, FDetailList.Link));
  oList.add(TFHIRProperty.create(self, 'agent', '', true, TFhirAuditEventAgent, FAgentList.Link));
end;

function TFhirAuditEventEntity.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'what') then
  begin
    What := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'securityLabel') then
  begin
    SecurityLabelList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'query') then
  begin
    QueryElement := asBase64Binary(propValue);
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirAuditEventEntityDetail);
    result := propValue;
  end
  else if (propName = 'agent') then
  begin
    AgentList.add(propValue as TFhirAuditEventAgent);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventEntity.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'securityLabel') then SecurityLabelList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirAuditEventEntityDetail)
  else if (propName = 'agent') then AgentList.insertItem(index, propValue as TFhirAuditEventAgent)
  else inherited;
end;

function TFhirAuditEventEntity.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'what') then result := TFhirReference.create()
  else if (propName = 'role') then result := TFhirCodeableConcept.create()
  else if (propName = 'securityLabel') then result := SecurityLabelList.new()
  else if (propName = 'query') then result := TFhirBase64Binary.create()
  else if (propName = 'detail') then result := DetailList.new()
  else if (propName = 'agent') then result := AgentList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventEntity.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'what') then result := 'Reference'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'securityLabel') then result := 'CodeableConcept'
  else if (propName = 'query') then result := 'base64Binary'
  else if (propName = 'detail') then result := 'BackboneElement'
  else if (propName = 'agent') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventEntity.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'what') then WhatElement := nil
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'securityLabel') then deletePropertyValue('securityLabel', SecurityLabelList, value)
  else if (propName = 'query') then QueryElement := nil
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value)
  else if (propName = 'agent') then deletePropertyValue('agent', AgentList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventEntity.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'what') then WhatElement := new as TFhirReference
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept
  else if (propName = 'securityLabel') then replacePropertyValue('securityLabel', SecurityLabelList, existing, new)
  else if (propName = 'query') then QueryElement := asBase64Binary(new)
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new)
  else if (propName = 'agent') then replacePropertyValue('agent', AgentList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventEntity.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'securityLabel') then SecurityLabelList.move(source, destination)
  else if (propName = 'detail') then DetailList.move(source, destination)
  else if (propName = 'agent') then AgentList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventEntity.fhirType : string;
begin
  result := 'AuditEvent.entity';
end;

function TFhirAuditEventEntity.Link : TFhirAuditEventEntity;
begin
  result := TFhirAuditEventEntity(inherited Link);
end;

function TFhirAuditEventEntity.Clone : TFhirAuditEventEntity;
begin
  result := TFhirAuditEventEntity(inherited Clone);
end;

function TFhirAuditEventEntity.equals(other : TObject) : boolean; 
var
  o : TFhirAuditEventEntity;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventEntity)) then
    result := false
  else
  begin
    o := TFhirAuditEventEntity(other);
    result := compareDeep(whatElement, o.whatElement, true) and compareDeep(roleElement, o.roleElement, true) and 
      compareDeep(securityLabelList, o.securityLabelList, true) and compareDeep(queryElement, o.queryElement, true) and 
      compareDeep(detailList, o.detailList, true) and compareDeep(agentList, o.agentList, true);
  end;
end;

function TFhirAuditEventEntity.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FWhat) and isEmptyProp(FRole) and isEmptyProp(FsecurityLabelList) and isEmptyProp(FQuery) and isEmptyProp(FdetailList) and isEmptyProp(FagentList);
end;

procedure TFhirAuditEventEntity.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('what');
  fields.add('role');
  fields.add('securityLabel');
  fields.add('query');
  fields.add('detail');
  fields.add('agent');
end;

function TFhirAuditEventEntity.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FSecurityLabelList.sizeInBytes(magic));
  inc(result, FDetailList.sizeInBytes(magic));
  inc(result, FAgentList.sizeInBytes(magic));
end;

procedure TFhirAuditEventEntity.SetWhat(value : TFhirReference);
begin
  FWhat.free;
  FWhat := value;
end;

procedure TFhirAuditEventEntity.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

function TFhirAuditEventEntity.GetSecurityLabelList : TFhirCodeableConceptList;
begin
  if FSecurityLabelList = nil then
    FSecurityLabelList := TFhirCodeableConceptList.Create;
  result := FSecurityLabelList;
end;

function TFhirAuditEventEntity.GetHasSecurityLabelList : boolean;
begin
  result := (FSecurityLabelList <> nil) and (FSecurityLabelList.count > 0);
end;

procedure TFhirAuditEventEntity.SetQuery(value : TFhirBase64Binary);
begin
  FQuery.free;
  FQuery := value;
end;

function TFhirAuditEventEntity.GetQueryST : TBytes;
begin
  if FQuery = nil then
    result := nil
  else
    result := FQuery.value;
end;

procedure TFhirAuditEventEntity.SetQueryST(value : TBytes);
begin
  if value <> nil then
  begin
    if FQuery = nil then
      FQuery := TFhirBase64Binary.create;
    FQuery.value := value
  end
  else if FQuery <> nil then
    FQuery.value := nil;
end;

function TFhirAuditEventEntity.GetDetailList : TFhirAuditEventEntityDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirAuditEventEntityDetailList.Create;
  result := FDetailList;
end;

function TFhirAuditEventEntity.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

function TFhirAuditEventEntity.GetAgentList : TFhirAuditEventAgentList;
begin
  if FAgentList = nil then
    FAgentList := TFhirAuditEventAgentList.Create;
  result := FAgentList;
end;

function TFhirAuditEventEntity.GetHasAgentList : boolean;
begin
  result := (FAgentList <> nil) and (FAgentList.count > 0);
end;

{ TFhirAuditEventEntityListEnumerator }

constructor TFhirAuditEventEntityListEnumerator.Create(list : TFhirAuditEventEntityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventEntityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventEntityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventEntityListEnumerator.GetCurrent : TFhirAuditEventEntity;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventEntityListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAuditEventEntityList }

function TFhirAuditEventEntityList.AddItem(value: TFhirAuditEventEntity): TFhirAuditEventEntity;
begin
  assert(value.ClassName = 'TFhirAuditEventEntity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventEntity');
  add(value);
  result := value;
end;

function TFhirAuditEventEntityList.Append: TFhirAuditEventEntity;
begin
  result := TFhirAuditEventEntity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventEntityList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventEntityList.GetEnumerator : TFhirAuditEventEntityListEnumerator;
begin
  result := TFhirAuditEventEntityListEnumerator.Create(self.link);
end;

function TFhirAuditEventEntityList.Clone: TFhirAuditEventEntityList;
begin
  result := TFhirAuditEventEntityList(inherited Clone);
end;

function TFhirAuditEventEntityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventEntityList.GetItemN(index: Integer): TFhirAuditEventEntity;
begin
  result := TFhirAuditEventEntity(ObjectByIndex[index]);
end;

function TFhirAuditEventEntityList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventEntity;
end;
function TFhirAuditEventEntityList.IndexOf(value: TFhirAuditEventEntity): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventEntityList.Insert(index: Integer): TFhirAuditEventEntity;
begin
  result := TFhirAuditEventEntity.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventEntityList.InsertItem(index: Integer; value: TFhirAuditEventEntity);
begin
  assert(value is TFhirAuditEventEntity);
  Inherited Insert(index, value);
end;

function TFhirAuditEventEntityList.Item(index: Integer): TFhirAuditEventEntity;
begin
  result := TFhirAuditEventEntity(ObjectByIndex[index]);
end;

function TFhirAuditEventEntityList.Link: TFhirAuditEventEntityList;
begin
  result := TFhirAuditEventEntityList(inherited Link);
end;

procedure TFhirAuditEventEntityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventEntityList.SetItemByIndex(index: Integer; value: TFhirAuditEventEntity);
begin
  assert(value is TFhirAuditEventEntity);
  FhirAuditEventEntities[index] := value;
end;

procedure TFhirAuditEventEntityList.SetItemN(index: Integer; value: TFhirAuditEventEntity);
begin
  assert(value is TFhirAuditEventEntity);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEventEntityDetail }

constructor TFhirAuditEventEntityDetail.Create;
begin
  inherited;
end;

destructor TFhirAuditEventEntityDetail.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirAuditEventEntityDetail.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirAuditEventEntityDetail(oSource).type_.Clone;
  value := TFhirAuditEventEntityDetail(oSource).value.Clone;
end;

procedure TFhirAuditEventEntityDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirAuditEventEntityDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'Quantity|CodeableConcept|string|boolean|integer|Range|Ratio|time|dateTime|Period|base64Binary', false, TFhirDataType, FValue.Link));
end;

function TFhirAuditEventEntityDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Ratio', 'Time', 'DateTime', 'Period', 'Base64Binary'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventEntityDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAuditEventEntityDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Ratio', 'Time', 'DateTime', 'Period', 'Base64Binary'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventEntityDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'Quantity|CodeableConcept|string|boolean|integer|Range|Ratio|time|dateTime|Period|base64Binary'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventEntityDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Ratio', 'Time', 'DateTime', 'Period', 'Base64Binary'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventEntityDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Ratio', 'Time', 'DateTime', 'Period', 'Base64Binary'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventEntityDetail.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventEntityDetail.fhirType : string;
begin
  result := 'AuditEvent.entity.detail';
end;

function TFhirAuditEventEntityDetail.Link : TFhirAuditEventEntityDetail;
begin
  result := TFhirAuditEventEntityDetail(inherited Link);
end;

function TFhirAuditEventEntityDetail.Clone : TFhirAuditEventEntityDetail;
begin
  result := TFhirAuditEventEntityDetail(inherited Clone);
end;

function TFhirAuditEventEntityDetail.equals(other : TObject) : boolean; 
var
  o : TFhirAuditEventEntityDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventEntityDetail)) then
    result := false
  else
  begin
    o := TFhirAuditEventEntityDetail(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirAuditEventEntityDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirAuditEventEntityDetail.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirAuditEventEntityDetail.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirAuditEventEntityDetail.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirAuditEventEntityDetail.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirAuditEventEntityDetailListEnumerator }

constructor TFhirAuditEventEntityDetailListEnumerator.Create(list : TFhirAuditEventEntityDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventEntityDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventEntityDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventEntityDetailListEnumerator.GetCurrent : TFhirAuditEventEntityDetail;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventEntityDetailListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAuditEventEntityDetailList }

function TFhirAuditEventEntityDetailList.AddItem(value: TFhirAuditEventEntityDetail): TFhirAuditEventEntityDetail;
begin
  assert(value.ClassName = 'TFhirAuditEventEntityDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventEntityDetail');
  add(value);
  result := value;
end;

function TFhirAuditEventEntityDetailList.Append: TFhirAuditEventEntityDetail;
begin
  result := TFhirAuditEventEntityDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventEntityDetailList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventEntityDetailList.GetEnumerator : TFhirAuditEventEntityDetailListEnumerator;
begin
  result := TFhirAuditEventEntityDetailListEnumerator.Create(self.link);
end;

function TFhirAuditEventEntityDetailList.Clone: TFhirAuditEventEntityDetailList;
begin
  result := TFhirAuditEventEntityDetailList(inherited Clone);
end;

function TFhirAuditEventEntityDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventEntityDetailList.GetItemN(index: Integer): TFhirAuditEventEntityDetail;
begin
  result := TFhirAuditEventEntityDetail(ObjectByIndex[index]);
end;

function TFhirAuditEventEntityDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventEntityDetail;
end;
function TFhirAuditEventEntityDetailList.IndexOf(value: TFhirAuditEventEntityDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventEntityDetailList.Insert(index: Integer): TFhirAuditEventEntityDetail;
begin
  result := TFhirAuditEventEntityDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventEntityDetailList.InsertItem(index: Integer; value: TFhirAuditEventEntityDetail);
begin
  assert(value is TFhirAuditEventEntityDetail);
  Inherited Insert(index, value);
end;

function TFhirAuditEventEntityDetailList.Item(index: Integer): TFhirAuditEventEntityDetail;
begin
  result := TFhirAuditEventEntityDetail(ObjectByIndex[index]);
end;

function TFhirAuditEventEntityDetailList.Link: TFhirAuditEventEntityDetailList;
begin
  result := TFhirAuditEventEntityDetailList(inherited Link);
end;

procedure TFhirAuditEventEntityDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventEntityDetailList.SetItemByIndex(index: Integer; value: TFhirAuditEventEntityDetail);
begin
  assert(value is TFhirAuditEventEntityDetail);
  FhirAuditEventEntityDetails[index] := value;
end;

procedure TFhirAuditEventEntityDetailList.SetItemN(index: Integer; value: TFhirAuditEventEntityDetail);
begin
  assert(value is TFhirAuditEventEntityDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEvent }

constructor TFhirAuditEvent.Create;
begin
  inherited;
end;

destructor TFhirAuditEvent.Destroy;
begin
  FCategoryList.Free;
  FCode.free;
  FAction.free;
  FSeverity.free;
  FOccurred.free;
  FRecorded.free;
  FOutcome.free;
  FAuthorizationList.Free;
  FBasedOnList.Free;
  FPatient.free;
  FEncounter.free;
  FAgentList.Free;
  FSource.free;
  FEntityList.Free;
  inherited;
end;

procedure TFhirAuditEvent.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAuditEvent(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirAuditEvent(oSource).FCategoryList);
  end;
  code := TFhirAuditEvent(oSource).code.Clone;
  actionElement := TFhirAuditEvent(oSource).actionElement.Clone;
  severityElement := TFhirAuditEvent(oSource).severityElement.Clone;
  occurred := TFhirAuditEvent(oSource).occurred.Clone;
  recordedElement := TFhirAuditEvent(oSource).recordedElement.Clone;
  outcome := TFhirAuditEvent(oSource).outcome.Clone;
  if (TFhirAuditEvent(oSource).FAuthorizationList = nil) then
  begin
    FAuthorizationList.free;
    FAuthorizationList := nil;
  end
  else
  begin
    if FAuthorizationList = nil then
      FAuthorizationList := TFhirCodeableConceptList.Create;
    FAuthorizationList.Assign(TFhirAuditEvent(oSource).FAuthorizationList);
  end;
  if (TFhirAuditEvent(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirAuditEvent(oSource).FBasedOnList);
  end;
  patient := TFhirAuditEvent(oSource).patient.Clone;
  encounter := TFhirAuditEvent(oSource).encounter.Clone;
  if (TFhirAuditEvent(oSource).FAgentList = nil) then
  begin
    FAgentList.free;
    FAgentList := nil;
  end
  else
  begin
    if FAgentList = nil then
      FAgentList := TFhirAuditEventAgentList.Create;
    FAgentList.Assign(TFhirAuditEvent(oSource).FAgentList);
  end;
  source := TFhirAuditEvent(oSource).source.Clone;
  if (TFhirAuditEvent(oSource).FEntityList = nil) then
  begin
    FEntityList.free;
    FEntityList := nil;
  end
  else
  begin
    if FEntityList = nil then
      FEntityList := TFhirAuditEventEntityList.Create;
    FEntityList.Assign(TFhirAuditEvent(oSource).FEntityList);
  end;
end;

function TFhirAuditEvent.GetResourceType : TFhirResourceType;
begin
  result := frtAuditEvent;
end;

procedure TFhirAuditEvent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'action') Then
     list.add(self.link, 'action', FAction.Link);
  if (child_name = 'severity') Then
     list.add(self.link, 'severity', FSeverity.Link);
  if (child_name = 'occurred[x]') or (child_name = 'occurred') Then
     list.add(self.link, 'occurred[x]', FOccurred.Link);
  if (child_name = 'recorded') Then
     list.add(self.link, 'recorded', FRecorded.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'authorization') Then
    list.addAll(self, 'authorization', FAuthorizationList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'agent') Then
    list.addAll(self, 'agent', FAgentList);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'entity') Then
    list.addAll(self, 'entity', FEntityList);
end;

procedure TFhirAuditEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'action', 'code', false, TFhirEnum, FAction.Link));
  oList.add(TFHIRProperty.create(self, 'severity', 'code', false, TFhirEnum, FSeverity.Link));
  oList.add(TFHIRProperty.create(self, 'occurred[x]', 'Period|dateTime', false, TFhirDataType, FOccurred.Link));
  oList.add(TFHIRProperty.create(self, 'recorded', 'instant', false, TFhirInstant, FRecorded.Link));
  oList.add(TFHIRProperty.create(self, 'outcome', 'BackboneElement', false, TFhirAuditEventOutcome, FOutcome.Link));
  oList.add(TFHIRProperty.create(self, 'authorization', 'CodeableConcept', true, TFhirCodeableConcept, FAuthorizationList.Link));
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'agent', 'BackboneElement', true, TFhirAuditEventAgent, FAgentList.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'BackboneElement', false, TFhirAuditEventSource, FSource.Link));
  oList.add(TFHIRProperty.create(self, 'entity', 'BackboneElement', true, TFhirAuditEventEntity, FEntityList.Link));
end;

function TFhirAuditEvent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionElement := asEnum(SYSTEMS_TFhirAuditEventActionEnum, CODES_TFhirAuditEventActionEnum, propValue);
    result := propValue;
  end
  else if (propName = 'severity') then
  begin
    SeverityElement := asEnum(SYSTEMS_TFhirAuditEventSeverityEnum, CODES_TFhirAuditEventSeverityEnum, propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurred', ['Period', 'DateTime'])) then
  begin
    Occurred := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'recorded') then
  begin
    RecordedElement := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirAuditEventOutcome;
    result := propValue;
  end
  else if (propName = 'authorization') then
  begin
    AuthorizationList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'agent') then
  begin
    AgentList.add(propValue as TFhirAuditEventAgent);
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirAuditEventSource;
    result := propValue;
  end
  else if (propName = 'entity') then
  begin
    EntityList.add(propValue as TFhirAuditEventEntity);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEvent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'authorization') then AuthorizationList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'agent') then AgentList.insertItem(index, propValue as TFhirAuditEventAgent)
  else if (propName = 'entity') then EntityList.insertItem(index, propValue as TFhirAuditEventEntity)
  else inherited;
end;

function TFhirAuditEvent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'action') then result := TFhirEnum.create(SYSTEMS_TFhirAuditEventActionEnum[AuditEventActionNull], CODES_TFhirAuditEventActionEnum[AuditEventActionNull]) 
  else if (propName = 'severity') then result := TFhirEnum.create(SYSTEMS_TFhirAuditEventSeverityEnum[AuditEventSeverityNull], CODES_TFhirAuditEventSeverityEnum[AuditEventSeverityNull]) 
  else if (isMatchingName(propName, 'occurred', ['Period', 'DateTime'])) then raise EFHIRException.create('Cannot make property Occurred')
  else if (propName = 'recorded') then result := TFhirInstant.create()
  else if (propName = 'outcome') then result := TFhirAuditEventOutcome.create()
  else if (propName = 'authorization') then result := AuthorizationList.new()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'patient') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (propName = 'agent') then result := AgentList.new()
  else if (propName = 'source') then result := TFhirAuditEventSource.create()
  else if (propName = 'entity') then result := EntityList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEvent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'action') then result := 'code'
  else if (propName = 'severity') then result := 'code'
  else if (propName = 'occurred[x]') then result := 'Period|dateTime'
  else if (propName = 'recorded') then result := 'instant'
  else if (propName = 'outcome') then result := 'BackboneElement'
  else if (propName = 'authorization') then result := 'CodeableConcept'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'agent') then result := 'BackboneElement'
  else if (propName = 'source') then result := 'BackboneElement'
  else if (propName = 'entity') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEvent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'action') then ActionElement := nil
  else if (propName = 'severity') then SeverityElement := nil
  else if (isMatchingName(propName, 'occurred', ['Period', 'DateTime'])) then OccurredElement := nil
  else if (propName = 'recorded') then RecordedElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'authorization') then deletePropertyValue('authorization', AuthorizationList, value)
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'agent') then deletePropertyValue('agent', AgentList, value)
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'entity') then deletePropertyValue('entity', EntityList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEvent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'action') then ActionElement := asEnum(SYSTEMS_TFhirAuditEventActionEnum, CODES_TFhirAuditEventActionEnum, new)
  else if (propName = 'severity') then SeverityElement := asEnum(SYSTEMS_TFhirAuditEventSeverityEnum, CODES_TFhirAuditEventSeverityEnum, new)
  else if (isMatchingName(propName, 'occurred', ['Period', 'DateTime'])) then OccurredElement := new as TFhirDataType
  else if (propName = 'recorded') then RecordedElement := asInstant(new)
  else if (propName = 'outcome') then OutcomeElement := new as TFhirAuditEventOutcome
  else if (propName = 'authorization') then replacePropertyValue('authorization', AuthorizationList, existing, new)
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'patient') then PatientElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (propName = 'agent') then replacePropertyValue('agent', AgentList, existing, new)
  else if (propName = 'source') then SourceElement := new as TFhirAuditEventSource
  else if (propName = 'entity') then replacePropertyValue('entity', EntityList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEvent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'authorization') then AuthorizationList.move(source, destination)
  else if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'agent') then AgentList.move(source, destination)
  else if (propName = 'entity') then EntityList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEvent.fhirType : string;
begin
  result := 'AuditEvent';
end;

function TFhirAuditEvent.Link : TFhirAuditEvent;
begin
  result := TFhirAuditEvent(inherited Link);
end;

function TFhirAuditEvent.Clone : TFhirAuditEvent;
begin
  result := TFhirAuditEvent(inherited Clone);
end;

function TFhirAuditEvent.equals(other : TObject) : boolean; 
var
  o : TFhirAuditEvent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEvent)) then
    result := false
  else
  begin
    o := TFhirAuditEvent(other);
    result := compareDeep(categoryList, o.categoryList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(actionElement, o.actionElement, true) and compareDeep(severityElement, o.severityElement, true) and 
      compareDeep(occurredElement, o.occurredElement, true) and compareDeep(recordedElement, o.recordedElement, true) and 
      compareDeep(outcomeElement, o.outcomeElement, true) and compareDeep(authorizationList, o.authorizationList, true) and 
      compareDeep(basedOnList, o.basedOnList, true) and compareDeep(patientElement, o.patientElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(agentList, o.agentList, true) and 
      compareDeep(sourceElement, o.sourceElement, true) and compareDeep(entityList, o.entityList, true);
  end;
end;

function TFhirAuditEvent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FcategoryList) and isEmptyProp(FCode) and isEmptyProp(FAction) and isEmptyProp(FSeverity) and isEmptyProp(FOccurred) and isEmptyProp(FRecorded) and isEmptyProp(FOutcome) and isEmptyProp(FauthorizationList) and isEmptyProp(FbasedOnList) and isEmptyProp(FPatient) and isEmptyProp(FEncounter) and isEmptyProp(FagentList) and isEmptyProp(FSource) and isEmptyProp(FentityList);
end;

procedure TFhirAuditEvent.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('category');
  fields.add('code');
  fields.add('action');
  fields.add('severity');
  fields.add('occurred[x]');
  fields.add('recorded');
  fields.add('outcome');
  fields.add('authorization');
  fields.add('basedOn');
  fields.add('patient');
  fields.add('encounter');
  fields.add('agent');
  fields.add('source');
  fields.add('entity');
end;

function TFhirAuditEvent.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FAuthorizationList.sizeInBytes(magic));
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FAgentList.sizeInBytes(magic));
  inc(result, FEntityList.sizeInBytes(magic));
end;

function TFhirAuditEvent.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirAuditEvent.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirAuditEvent.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirAuditEvent.SetAction(value : TFhirEnum);
begin
  FAction.free;
  FAction := value;
end;

function TFhirAuditEvent.GetActionST : TFhirAuditEventActionEnum;
begin
  if FAction = nil then
    result := TFhirAuditEventActionEnum(0)
  else
    result := TFhirAuditEventActionEnum(StringArrayIndexOfSensitive(CODES_TFhirAuditEventActionEnum, FAction.value));
end;

procedure TFhirAuditEvent.SetActionST(value : TFhirAuditEventActionEnum);
begin
  if ord(value) = 0 then
    ActionElement := nil
  else
    ActionElement := TFhirEnum.create(SYSTEMS_TFhirAuditEventActionEnum[value], CODES_TFhirAuditEventActionEnum[value]);
end;

procedure TFhirAuditEvent.SetSeverity(value : TFhirEnum);
begin
  FSeverity.free;
  FSeverity := value;
end;

function TFhirAuditEvent.GetSeverityST : TFhirAuditEventSeverityEnum;
begin
  if FSeverity = nil then
    result := TFhirAuditEventSeverityEnum(0)
  else
    result := TFhirAuditEventSeverityEnum(StringArrayIndexOfSensitive(CODES_TFhirAuditEventSeverityEnum, FSeverity.value));
end;

procedure TFhirAuditEvent.SetSeverityST(value : TFhirAuditEventSeverityEnum);
begin
  if ord(value) = 0 then
    SeverityElement := nil
  else
    SeverityElement := TFhirEnum.create(SYSTEMS_TFhirAuditEventSeverityEnum[value], CODES_TFhirAuditEventSeverityEnum[value]);
end;

procedure TFhirAuditEvent.SetOccurred(value : TFhirDataType);
begin
  FOccurred.free;
  FOccurred := value;
end;

procedure TFhirAuditEvent.SetRecorded(value : TFhirInstant);
begin
  FRecorded.free;
  FRecorded := value;
end;

function TFhirAuditEvent.GetRecordedST : TFslDateTime;
begin
  if FRecorded = nil then
    result := TFslDateTime.makeNull
  else
    result := FRecorded.value;
end;

procedure TFhirAuditEvent.SetRecordedST(value : TFslDateTime);
begin
  if FRecorded = nil then
    FRecorded := TFhirInstant.create;
  FRecorded.value := value
end;

procedure TFhirAuditEvent.SetOutcome(value : TFhirAuditEventOutcome);
begin
  FOutcome.free;
  FOutcome := value;
end;

function TFhirAuditEvent.GetAuthorizationList : TFhirCodeableConceptList;
begin
  if FAuthorizationList = nil then
    FAuthorizationList := TFhirCodeableConceptList.Create;
  result := FAuthorizationList;
end;

function TFhirAuditEvent.GetHasAuthorizationList : boolean;
begin
  result := (FAuthorizationList <> nil) and (FAuthorizationList.count > 0);
end;

function TFhirAuditEvent.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirAuditEvent.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

procedure TFhirAuditEvent.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value;
end;

procedure TFhirAuditEvent.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

function TFhirAuditEvent.GetAgentList : TFhirAuditEventAgentList;
begin
  if FAgentList = nil then
    FAgentList := TFhirAuditEventAgentList.Create;
  result := FAgentList;
end;

function TFhirAuditEvent.GetHasAgentList : boolean;
begin
  result := (FAgentList <> nil) and (FAgentList.count > 0);
end;

procedure TFhirAuditEvent.SetSource(value : TFhirAuditEventSource);
begin
  FSource.free;
  FSource := value;
end;

function TFhirAuditEvent.GetEntityList : TFhirAuditEventEntityList;
begin
  if FEntityList = nil then
    FEntityList := TFhirAuditEventEntityList.Create;
  result := FEntityList;
end;

function TFhirAuditEvent.GetHasEntityList : boolean;
begin
  result := (FEntityList <> nil) and (FEntityList.count > 0);
end;

{ TFhirAuditEventListEnumerator }

constructor TFhirAuditEventListEnumerator.Create(list : TFhirAuditEventList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventListEnumerator.GetCurrent : TFhirAuditEvent;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAuditEventList }

function TFhirAuditEventList.AddItem(value: TFhirAuditEvent): TFhirAuditEvent;
begin
  assert(value.ClassName = 'TFhirAuditEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEvent');
  add(value);
  result := value;
end;

function TFhirAuditEventList.Append: TFhirAuditEvent;
begin
  result := TFhirAuditEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventList.GetEnumerator : TFhirAuditEventListEnumerator;
begin
  result := TFhirAuditEventListEnumerator.Create(self.link);
end;

function TFhirAuditEventList.Clone: TFhirAuditEventList;
begin
  result := TFhirAuditEventList(inherited Clone);
end;

function TFhirAuditEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventList.GetItemN(index: Integer): TFhirAuditEvent;
begin
  result := TFhirAuditEvent(ObjectByIndex[index]);
end;

function TFhirAuditEventList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEvent;
end;
function TFhirAuditEventList.IndexOf(value: TFhirAuditEvent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventList.Insert(index: Integer): TFhirAuditEvent;
begin
  result := TFhirAuditEvent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventList.InsertItem(index: Integer; value: TFhirAuditEvent);
begin
  assert(value is TFhirAuditEvent);
  Inherited Insert(index, value);
end;

function TFhirAuditEventList.Item(index: Integer): TFhirAuditEvent;
begin
  result := TFhirAuditEvent(ObjectByIndex[index]);
end;

function TFhirAuditEventList.Link: TFhirAuditEventList;
begin
  result := TFhirAuditEventList(inherited Link);
end;

procedure TFhirAuditEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventList.SetItemByIndex(index: Integer; value: TFhirAuditEvent);
begin
  assert(value is TFhirAuditEvent);
  FhirAuditEvents[index] := value;
end;

procedure TFhirAuditEventList.SetItemN(index: Integer; value: TFhirAuditEvent);
begin
  assert(value is TFhirAuditEvent);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BINARY}
{ TFhirBinary }

constructor TFhirBinary.Create;
begin
  inherited;
end;

destructor TFhirBinary.Destroy;
begin
  FContentType.free;
  FSecurityContext.free;
  FData.free;
  inherited;
end;

procedure TFhirBinary.Assign(oSource : TFslObject);
begin
  inherited;
  contentTypeElement := TFhirBinary(oSource).contentTypeElement.Clone;
  securityContext := TFhirBinary(oSource).securityContext.Clone;
  dataElement := TFhirBinary(oSource).dataElement.Clone;
end;

function TFhirBinary.GetResourceType : TFhirResourceType;
begin
  result := frtBinary;
end;

procedure TFhirBinary.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'contentType') Then
     list.add(self.link, 'contentType', FContentType.Link);
  if (child_name = 'securityContext') Then
     list.add(self.link, 'securityContext', FSecurityContext.Link);
  if (child_name = 'data') Then
     list.add(self.link, 'data', FData.Link);
end;

procedure TFhirBinary.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'contentType', 'code', false, TFhirCode, FContentType.Link));
  oList.add(TFHIRProperty.create(self, 'securityContext', 'Reference', false, TFhirReference, FSecurityContext.Link));
  oList.add(TFHIRProperty.create(self, 'data', 'base64Binary', false, TFhirBase64Binary, FData.Link));
end;

function TFhirBinary.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'contentType') then
  begin
    ContentTypeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'securityContext') then
  begin
    SecurityContext := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'data') then
  begin
    DataElement := asBase64Binary(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBinary.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBinary.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'contentType') then result := TFhirCode.create()
  else if (propName = 'securityContext') then result := TFhirReference.create()
  else if (propName = 'data') then result := TFhirBase64Binary.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirBinary.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'contentType') then result := 'code'
  else if (propName = 'securityContext') then result := 'Reference'
  else if (propName = 'data') then result := 'base64Binary'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBinary.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'contentType') then ContentTypeElement := nil
  else if (propName = 'securityContext') then SecurityContextElement := nil
  else if (propName = 'data') then DataElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBinary.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'contentType') then ContentTypeElement := asCode(new)
  else if (propName = 'securityContext') then SecurityContextElement := new as TFhirReference
  else if (propName = 'data') then DataElement := asBase64Binary(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBinary.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBinary.fhirType : string;
begin
  result := 'Binary';
end;

function TFhirBinary.Link : TFhirBinary;
begin
  result := TFhirBinary(inherited Link);
end;

function TFhirBinary.Clone : TFhirBinary;
begin
  result := TFhirBinary(inherited Clone);
end;

function TFhirBinary.equals(other : TObject) : boolean; 
var
  o : TFhirBinary;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBinary)) then
    result := false
  else
  begin
    o := TFhirBinary(other);
    result := compareDeep(contentTypeElement, o.contentTypeElement, true) and compareDeep(securityContextElement, o.securityContextElement, true) and 
      compareDeep(dataElement, o.dataElement, true);
  end;
end;

function TFhirBinary.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContentType) and isEmptyProp(FSecurityContext) and isEmptyProp(FData);
end;

procedure TFhirBinary.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('contentType');
  fields.add('securityContext');
  fields.add('data');
end;

function TFhirBinary.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirBinary.SetContentType(value : TFhirCode);
begin
  FContentType.free;
  FContentType := value;
end;

function TFhirBinary.GetContentTypeST : String;
begin
  if FContentType = nil then
    result := ''
  else
    result := FContentType.value;
end;

procedure TFhirBinary.SetContentTypeST(value : String);
begin
  if value <> '' then
  begin
    if FContentType = nil then
      FContentType := TFhirCode.create;
    FContentType.value := value
  end
  else if FContentType <> nil then
    FContentType.value := '';
end;

procedure TFhirBinary.SetSecurityContext(value : TFhirReference);
begin
  FSecurityContext.free;
  FSecurityContext := value;
end;

procedure TFhirBinary.SetData(value : TFhirBase64Binary);
begin
  FData.free;
  FData := value;
end;

function TFhirBinary.GetDataST : TBytes;
begin
  if FData = nil then
    result := nil
  else
    result := FData.value;
end;

procedure TFhirBinary.SetDataST(value : TBytes);
begin
  if value <> nil then
  begin
    if FData = nil then
      FData := TFhirBase64Binary.create;
    FData.value := value
  end
  else if FData <> nil then
    FData.value := nil;
end;

{ TFhirBinaryListEnumerator }

constructor TFhirBinaryListEnumerator.Create(list : TFhirBinaryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBinaryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBinaryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBinaryListEnumerator.GetCurrent : TFhirBinary;
begin
  Result := FList[FIndex];
end;

function TFhirBinaryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBinaryList }

function TFhirBinaryList.AddItem(value: TFhirBinary): TFhirBinary;
begin
  assert(value.ClassName = 'TFhirBinary', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBinary');
  add(value);
  result := value;
end;

function TFhirBinaryList.Append: TFhirBinary;
begin
  result := TFhirBinary.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBinaryList.ClearItems;
begin
  Clear;
end;

function TFhirBinaryList.GetEnumerator : TFhirBinaryListEnumerator;
begin
  result := TFhirBinaryListEnumerator.Create(self.link);
end;

function TFhirBinaryList.Clone: TFhirBinaryList;
begin
  result := TFhirBinaryList(inherited Clone);
end;

function TFhirBinaryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBinaryList.GetItemN(index: Integer): TFhirBinary;
begin
  result := TFhirBinary(ObjectByIndex[index]);
end;

function TFhirBinaryList.ItemClass: TFslObjectClass;
begin
  result := TFhirBinary;
end;
function TFhirBinaryList.IndexOf(value: TFhirBinary): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBinaryList.Insert(index: Integer): TFhirBinary;
begin
  result := TFhirBinary.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBinaryList.InsertItem(index: Integer; value: TFhirBinary);
begin
  assert(value is TFhirBinary);
  Inherited Insert(index, value);
end;

function TFhirBinaryList.Item(index: Integer): TFhirBinary;
begin
  result := TFhirBinary(ObjectByIndex[index]);
end;

function TFhirBinaryList.Link: TFhirBinaryList;
begin
  result := TFhirBinaryList(inherited Link);
end;

procedure TFhirBinaryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBinaryList.SetItemByIndex(index: Integer; value: TFhirBinary);
begin
  assert(value is TFhirBinary);
  FhirBinaries[index] := value;
end;

procedure TFhirBinaryList.SetItemN(index: Integer; value: TFhirBinary);
begin
  assert(value is TFhirBinary);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BUNDLE}
{ TFhirBundleLink }

constructor TFhirBundleLink.Create;
begin
  inherited;
end;

destructor TFhirBundleLink.Destroy;
begin
  FRelation.free;
  FUrl.free;
  inherited;
end;

procedure TFhirBundleLink.Assign(oSource : TFslObject);
begin
  inherited;
  relationElement := TFhirBundleLink(oSource).relationElement.Clone;
  urlElement := TFhirBundleLink(oSource).urlElement.Clone;
end;

procedure TFhirBundleLink.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'relation') Then
     list.add(self.link, 'relation', FRelation.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
end;

procedure TFhirBundleLink.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'relation', 'code', false, TFhirEnum, FRelation.Link));
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
end;

function TFhirBundleLink.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'relation') then
  begin
    RelationElement := asEnum(SYSTEMS_TFhirLinkRelationTypesEnum, CODES_TFhirLinkRelationTypesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundleLink.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBundleLink.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'relation') then result := TFhirEnum.create(SYSTEMS_TFhirLinkRelationTypesEnum[LinkRelationTypesNull], CODES_TFhirLinkRelationTypesEnum[LinkRelationTypesNull]) 
  else if (propName = 'url') then result := TFhirUri.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundleLink.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'relation') then result := 'code'
  else if (propName = 'url') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundleLink.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'relation') then RelationElement := nil
  else if (propName = 'url') then UrlElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundleLink.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'relation') then RelationElement := asEnum(SYSTEMS_TFhirLinkRelationTypesEnum, CODES_TFhirLinkRelationTypesEnum, new)
  else if (propName = 'url') then UrlElement := asUri(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundleLink.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBundleLink.fhirType : string;
begin
  result := 'Bundle.link';
end;

function TFhirBundleLink.Link : TFhirBundleLink;
begin
  result := TFhirBundleLink(inherited Link);
end;

function TFhirBundleLink.Clone : TFhirBundleLink;
begin
  result := TFhirBundleLink(inherited Clone);
end;

function TFhirBundleLink.equals(other : TObject) : boolean; 
var
  o : TFhirBundleLink;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundleLink)) then
    result := false
  else
  begin
    o := TFhirBundleLink(other);
    result := compareDeep(relationElement, o.relationElement, true) and compareDeep(urlElement, o.urlElement, true);
  end;
end;

function TFhirBundleLink.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRelation) and isEmptyProp(FUrl);
end;

procedure TFhirBundleLink.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('relation');
  fields.add('url');
end;

function TFhirBundleLink.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirBundleLink.SetRelation(value : TFhirEnum);
begin
  FRelation.free;
  FRelation := value;
end;

function TFhirBundleLink.GetRelationST : TFhirLinkRelationTypesEnum;
begin
  if FRelation = nil then
    result := TFhirLinkRelationTypesEnum(0)
  else
    result := TFhirLinkRelationTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirLinkRelationTypesEnum, FRelation.value));
end;

procedure TFhirBundleLink.SetRelationST(value : TFhirLinkRelationTypesEnum);
begin
  if ord(value) = 0 then
    RelationElement := nil
  else
    RelationElement := TFhirEnum.create(SYSTEMS_TFhirLinkRelationTypesEnum[value], CODES_TFhirLinkRelationTypesEnum[value]);
end;

procedure TFhirBundleLink.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirBundleLink.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirBundleLink.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

{ TFhirBundleLinkListEnumerator }

constructor TFhirBundleLinkListEnumerator.Create(list : TFhirBundleLinkList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleLinkListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleLinkListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleLinkListEnumerator.GetCurrent : TFhirBundleLink;
begin
  Result := FList[FIndex];
end;

function TFhirBundleLinkListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBundleLinkList }

function TFhirBundleLinkList.AddItem(value: TFhirBundleLink): TFhirBundleLink;
begin
  assert(value.ClassName = 'TFhirBundleLink', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundleLink');
  add(value);
  result := value;
end;

function TFhirBundleLinkList.Append: TFhirBundleLink;
begin
  result := TFhirBundleLink.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleLinkList.ClearItems;
begin
  Clear;
end;

function TFhirBundleLinkList.GetEnumerator : TFhirBundleLinkListEnumerator;
begin
  result := TFhirBundleLinkListEnumerator.Create(self.link);
end;

function TFhirBundleLinkList.Clone: TFhirBundleLinkList;
begin
  result := TFhirBundleLinkList(inherited Clone);
end;

function TFhirBundleLinkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleLinkList.GetItemN(index: Integer): TFhirBundleLink;
begin
  result := TFhirBundleLink(ObjectByIndex[index]);
end;

function TFhirBundleLinkList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundleLink;
end;
function TFhirBundleLinkList.IndexOf(value: TFhirBundleLink): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleLinkList.Insert(index: Integer): TFhirBundleLink;
begin
  result := TFhirBundleLink.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleLinkList.InsertItem(index: Integer; value: TFhirBundleLink);
begin
  assert(value is TFhirBundleLink);
  Inherited Insert(index, value);
end;

function TFhirBundleLinkList.Item(index: Integer): TFhirBundleLink;
begin
  result := TFhirBundleLink(ObjectByIndex[index]);
end;

function TFhirBundleLinkList.Link: TFhirBundleLinkList;
begin
  result := TFhirBundleLinkList(inherited Link);
end;

procedure TFhirBundleLinkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleLinkList.SetItemByIndex(index: Integer; value: TFhirBundleLink);
begin
  assert(value is TFhirBundleLink);
  FhirBundleLinks[index] := value;
end;

procedure TFhirBundleLinkList.SetItemN(index: Integer; value: TFhirBundleLink);
begin
  assert(value is TFhirBundleLink);
  ObjectByIndex[index] := value;
end;

{ TFhirBundleEntry }

constructor TFhirBundleEntry.Create;
begin
  inherited;
end;

destructor TFhirBundleEntry.Destroy;
begin
  FLink_List.Free;
  FFullUrl.free;
  FResource.free;
  FSearch.free;
  FRequest.free;
  FResponse.free;
  inherited;
end;

procedure TFhirBundleEntry.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirBundleEntry(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirBundleLinkList.Create;
    FLink_List.Assign(TFhirBundleEntry(oSource).FLink_List);
  end;
  fullUrlElement := TFhirBundleEntry(oSource).fullUrlElement.Clone;
  resource := TFhirBundleEntry(oSource).resource.Clone;
  search := TFhirBundleEntry(oSource).search.Clone;
  request := TFhirBundleEntry(oSource).request.Clone;
  response := TFhirBundleEntry(oSource).response.Clone;
end;

procedure TFhirBundleEntry.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
  if (child_name = 'fullUrl') Then
     list.add(self.link, 'fullUrl', FFullUrl.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'search') Then
     list.add(self.link, 'search', FSearch.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
end;

procedure TFhirBundleEntry.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'link', '', true, TFhirBundleLink, FLink_List.Link));
  oList.add(TFHIRProperty.create(self, 'fullUrl', 'uri', false, TFhirUri, FFullUrl.Link));
  oList.add(TFHIRProperty.create(self, 'resource', 'Resource', false, TFhirResource, FResource.Link));
  oList.add(TFHIRProperty.create(self, 'search', 'BackboneElement', false, TFhirBundleEntrySearch, FSearch.Link));
  oList.add(TFHIRProperty.create(self, 'request', 'BackboneElement', false, TFhirBundleEntryRequest, FRequest.Link));
  oList.add(TFHIRProperty.create(self, 'response', 'BackboneElement', false, TFhirBundleEntryResponse, FResponse.Link));
end;

function TFhirBundleEntry.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirBundleLink);
    result := propValue;
  end
  else if (propName = 'fullUrl') then
  begin
    FullUrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    Resource := propValue as TFhirResource;
    result := propValue;
  end
  else if (propName = 'search') then
  begin
    Search := propValue as TFhirBundleEntrySearch;
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirBundleEntryRequest;
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    Response := propValue as TFhirBundleEntryResponse;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundleEntry.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirBundleLink)
  else inherited;
end;

function TFhirBundleEntry.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'link') then result := Link_List.new()
  else if (propName = 'fullUrl') then result := TFhirUri.create()
  else if (propName = 'resource') then raise EFHIRException.create('Cannot make property Resource')
  else if (propName = 'search') then result := TFhirBundleEntrySearch.create()
  else if (propName = 'request') then result := TFhirBundleEntryRequest.create()
  else if (propName = 'response') then result := TFhirBundleEntryResponse.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundleEntry.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'link') then result := ''
  else if (propName = 'fullUrl') then result := 'uri'
  else if (propName = 'resource') then result := 'Resource'
  else if (propName = 'search') then result := 'BackboneElement'
  else if (propName = 'request') then result := 'BackboneElement'
  else if (propName = 'response') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundleEntry.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'link') then deletePropertyValue('link', Link_List, value)
  else if (propName = 'fullUrl') then FullUrlElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'search') then SearchElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundleEntry.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new)
  else if (propName = 'fullUrl') then FullUrlElement := asUri(new)
  else if (propName = 'resource') then ResourceElement := new as TFhirResource
  else if (propName = 'search') then SearchElement := new as TFhirBundleEntrySearch
  else if (propName = 'request') then RequestElement := new as TFhirBundleEntryRequest
  else if (propName = 'response') then ResponseElement := new as TFhirBundleEntryResponse
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundleEntry.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'link') then Link_List.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirBundleEntry.fhirType : string;
begin
  result := 'Bundle.entry';
end;

function TFhirBundleEntry.Link : TFhirBundleEntry;
begin
  result := TFhirBundleEntry(inherited Link);
end;

function TFhirBundleEntry.Clone : TFhirBundleEntry;
begin
  result := TFhirBundleEntry(inherited Clone);
end;

function TFhirBundleEntry.equals(other : TObject) : boolean; 
var
  o : TFhirBundleEntry;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundleEntry)) then
    result := false
  else
  begin
    o := TFhirBundleEntry(other);
    result := compareDeep(link_List, o.link_List, true) and compareDeep(fullUrlElement, o.fullUrlElement, true) and 
      compareDeep(resourceElement, o.resourceElement, true) and compareDeep(searchElement, o.searchElement, true) and 
      compareDeep(requestElement, o.requestElement, true) and compareDeep(responseElement, o.responseElement, true);
  end;
end;

function TFhirBundleEntry.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(Flink_List) and isEmptyProp(FFullUrl) and isEmptyProp(FResource) and isEmptyProp(FSearch) and isEmptyProp(FRequest) and isEmptyProp(FResponse);
end;

procedure TFhirBundleEntry.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('link');
  fields.add('fullUrl');
  fields.add('resource');
  fields.add('search');
  fields.add('request');
  fields.add('response');
end;

function TFhirBundleEntry.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FLink_List.sizeInBytes(magic));
end;

function TFhirBundleEntry.GetLink_List : TFhirBundleLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirBundleLinkList.Create;
  result := FLink_List;
end;

function TFhirBundleEntry.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

procedure TFhirBundleEntry.SetFullUrl(value : TFhirUri);
begin
  FFullUrl.free;
  FFullUrl := value;
end;

function TFhirBundleEntry.GetFullUrlST : String;
begin
  if FFullUrl = nil then
    result := ''
  else
    result := FFullUrl.value;
end;

procedure TFhirBundleEntry.SetFullUrlST(value : String);
begin
  if value <> '' then
  begin
    if FFullUrl = nil then
      FFullUrl := TFhirUri.create;
    FFullUrl.value := value
  end
  else if FFullUrl <> nil then
    FFullUrl.value := '';
end;

procedure TFhirBundleEntry.SetResource(value : TFhirResource);
begin
  FResource.free;
  FResource := value;
end;

procedure TFhirBundleEntry.SetSearch(value : TFhirBundleEntrySearch);
begin
  FSearch.free;
  FSearch := value;
end;

procedure TFhirBundleEntry.SetRequest(value : TFhirBundleEntryRequest);
begin
  FRequest.free;
  FRequest := value;
end;

procedure TFhirBundleEntry.SetResponse(value : TFhirBundleEntryResponse);
begin
  FResponse.free;
  FResponse := value;
end;

{ TFhirBundleEntryListEnumerator }

constructor TFhirBundleEntryListEnumerator.Create(list : TFhirBundleEntryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleEntryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleEntryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleEntryListEnumerator.GetCurrent : TFhirBundleEntry;
begin
  Result := FList[FIndex];
end;

function TFhirBundleEntryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBundleEntryList }

function TFhirBundleEntryList.AddItem(value: TFhirBundleEntry): TFhirBundleEntry;
begin
  assert(value.ClassName = 'TFhirBundleEntry', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundleEntry');
  add(value);
  result := value;
end;

function TFhirBundleEntryList.Append: TFhirBundleEntry;
begin
  result := TFhirBundleEntry.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryList.ClearItems;
begin
  Clear;
end;

function TFhirBundleEntryList.GetEnumerator : TFhirBundleEntryListEnumerator;
begin
  result := TFhirBundleEntryListEnumerator.Create(self.link);
end;

function TFhirBundleEntryList.Clone: TFhirBundleEntryList;
begin
  result := TFhirBundleEntryList(inherited Clone);
end;

function TFhirBundleEntryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleEntryList.GetItemN(index: Integer): TFhirBundleEntry;
begin
  result := TFhirBundleEntry(ObjectByIndex[index]);
end;

function TFhirBundleEntryList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundleEntry;
end;
function TFhirBundleEntryList.IndexOf(value: TFhirBundleEntry): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleEntryList.Insert(index: Integer): TFhirBundleEntry;
begin
  result := TFhirBundleEntry.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryList.InsertItem(index: Integer; value: TFhirBundleEntry);
begin
  assert(value is TFhirBundleEntry);
  Inherited Insert(index, value);
end;

function TFhirBundleEntryList.Item(index: Integer): TFhirBundleEntry;
begin
  result := TFhirBundleEntry(ObjectByIndex[index]);
end;

function TFhirBundleEntryList.Link: TFhirBundleEntryList;
begin
  result := TFhirBundleEntryList(inherited Link);
end;

procedure TFhirBundleEntryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleEntryList.SetItemByIndex(index: Integer; value: TFhirBundleEntry);
begin
  assert(value is TFhirBundleEntry);
  FhirBundleEntries[index] := value;
end;

procedure TFhirBundleEntryList.SetItemN(index: Integer; value: TFhirBundleEntry);
begin
  assert(value is TFhirBundleEntry);
  ObjectByIndex[index] := value;
end;

{ TFhirBundleEntrySearch }

constructor TFhirBundleEntrySearch.Create;
begin
  inherited;
end;

destructor TFhirBundleEntrySearch.Destroy;
begin
  FMode.free;
  FScore.free;
  inherited;
end;

procedure TFhirBundleEntrySearch.Assign(oSource : TFslObject);
begin
  inherited;
  modeElement := TFhirBundleEntrySearch(oSource).modeElement.Clone;
  scoreElement := TFhirBundleEntrySearch(oSource).scoreElement.Clone;
end;

procedure TFhirBundleEntrySearch.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'score') Then
     list.add(self.link, 'score', FScore.Link);
end;

procedure TFhirBundleEntrySearch.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFhirEnum, FMode.Link));
  oList.add(TFHIRProperty.create(self, 'score', 'decimal', false, TFhirDecimal, FScore.Link));
end;

function TFhirBundleEntrySearch.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirSearchEntryModeEnum, CODES_TFhirSearchEntryModeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'score') then
  begin
    ScoreElement := asDecimal(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundleEntrySearch.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBundleEntrySearch.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'mode') then result := TFhirEnum.create(SYSTEMS_TFhirSearchEntryModeEnum[SearchEntryModeNull], CODES_TFhirSearchEntryModeEnum[SearchEntryModeNull]) 
  else if (propName = 'score') then result := TFhirDecimal.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundleEntrySearch.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'mode') then result := 'code'
  else if (propName = 'score') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundleEntrySearch.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := nil
  else if (propName = 'score') then ScoreElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundleEntrySearch.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirSearchEntryModeEnum, CODES_TFhirSearchEntryModeEnum, new)
  else if (propName = 'score') then ScoreElement := asDecimal(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundleEntrySearch.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBundleEntrySearch.fhirType : string;
begin
  result := 'Bundle.entry.search';
end;

function TFhirBundleEntrySearch.Link : TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch(inherited Link);
end;

function TFhirBundleEntrySearch.Clone : TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch(inherited Clone);
end;

function TFhirBundleEntrySearch.equals(other : TObject) : boolean; 
var
  o : TFhirBundleEntrySearch;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundleEntrySearch)) then
    result := false
  else
  begin
    o := TFhirBundleEntrySearch(other);
    result := compareDeep(modeElement, o.modeElement, true) and compareDeep(scoreElement, o.scoreElement, true);
  end;
end;

function TFhirBundleEntrySearch.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMode) and isEmptyProp(FScore);
end;

procedure TFhirBundleEntrySearch.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('mode');
  fields.add('score');
end;

function TFhirBundleEntrySearch.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirBundleEntrySearch.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

function TFhirBundleEntrySearch.GetModeST : TFhirSearchEntryModeEnum;
begin
  if FMode = nil then
    result := TFhirSearchEntryModeEnum(0)
  else
    result := TFhirSearchEntryModeEnum(StringArrayIndexOfSensitive(CODES_TFhirSearchEntryModeEnum, FMode.value));
end;

procedure TFhirBundleEntrySearch.SetModeST(value : TFhirSearchEntryModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirSearchEntryModeEnum[value], CODES_TFhirSearchEntryModeEnum[value]);
end;

procedure TFhirBundleEntrySearch.SetScore(value : TFhirDecimal);
begin
  FScore.free;
  FScore := value;
end;

function TFhirBundleEntrySearch.GetScoreST : String;
begin
  if FScore = nil then
    result := ''
  else
    result := FScore.value;
end;

procedure TFhirBundleEntrySearch.SetScoreST(value : String);
begin
  if value <> '' then
  begin
    if FScore = nil then
      FScore := TFhirDecimal.create;
    FScore.value := value
  end
  else if FScore <> nil then
    FScore.value := '';
end;

{ TFhirBundleEntrySearchListEnumerator }

constructor TFhirBundleEntrySearchListEnumerator.Create(list : TFhirBundleEntrySearchList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleEntrySearchListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleEntrySearchListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleEntrySearchListEnumerator.GetCurrent : TFhirBundleEntrySearch;
begin
  Result := FList[FIndex];
end;

function TFhirBundleEntrySearchListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBundleEntrySearchList }

function TFhirBundleEntrySearchList.AddItem(value: TFhirBundleEntrySearch): TFhirBundleEntrySearch;
begin
  assert(value.ClassName = 'TFhirBundleEntrySearch', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundleEntrySearch');
  add(value);
  result := value;
end;

function TFhirBundleEntrySearchList.Append: TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntrySearchList.ClearItems;
begin
  Clear;
end;

function TFhirBundleEntrySearchList.GetEnumerator : TFhirBundleEntrySearchListEnumerator;
begin
  result := TFhirBundleEntrySearchListEnumerator.Create(self.link);
end;

function TFhirBundleEntrySearchList.Clone: TFhirBundleEntrySearchList;
begin
  result := TFhirBundleEntrySearchList(inherited Clone);
end;

function TFhirBundleEntrySearchList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleEntrySearchList.GetItemN(index: Integer): TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch(ObjectByIndex[index]);
end;

function TFhirBundleEntrySearchList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundleEntrySearch;
end;
function TFhirBundleEntrySearchList.IndexOf(value: TFhirBundleEntrySearch): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleEntrySearchList.Insert(index: Integer): TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntrySearchList.InsertItem(index: Integer; value: TFhirBundleEntrySearch);
begin
  assert(value is TFhirBundleEntrySearch);
  Inherited Insert(index, value);
end;

function TFhirBundleEntrySearchList.Item(index: Integer): TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch(ObjectByIndex[index]);
end;

function TFhirBundleEntrySearchList.Link: TFhirBundleEntrySearchList;
begin
  result := TFhirBundleEntrySearchList(inherited Link);
end;

procedure TFhirBundleEntrySearchList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleEntrySearchList.SetItemByIndex(index: Integer; value: TFhirBundleEntrySearch);
begin
  assert(value is TFhirBundleEntrySearch);
  FhirBundleEntrySearches[index] := value;
end;

procedure TFhirBundleEntrySearchList.SetItemN(index: Integer; value: TFhirBundleEntrySearch);
begin
  assert(value is TFhirBundleEntrySearch);
  ObjectByIndex[index] := value;
end;

{ TFhirBundleEntryRequest }

constructor TFhirBundleEntryRequest.Create;
begin
  inherited;
end;

destructor TFhirBundleEntryRequest.Destroy;
begin
  FMethod.free;
  FUrl.free;
  FIfNoneMatch.free;
  FIfModifiedSince.free;
  FIfMatch.free;
  FIfNoneExist.free;
  inherited;
end;

procedure TFhirBundleEntryRequest.Assign(oSource : TFslObject);
begin
  inherited;
  methodElement := TFhirBundleEntryRequest(oSource).methodElement.Clone;
  urlElement := TFhirBundleEntryRequest(oSource).urlElement.Clone;
  ifNoneMatchElement := TFhirBundleEntryRequest(oSource).ifNoneMatchElement.Clone;
  ifModifiedSinceElement := TFhirBundleEntryRequest(oSource).ifModifiedSinceElement.Clone;
  ifMatchElement := TFhirBundleEntryRequest(oSource).ifMatchElement.Clone;
  ifNoneExistElement := TFhirBundleEntryRequest(oSource).ifNoneExistElement.Clone;
end;

procedure TFhirBundleEntryRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'ifNoneMatch') Then
     list.add(self.link, 'ifNoneMatch', FIfNoneMatch.Link);
  if (child_name = 'ifModifiedSince') Then
     list.add(self.link, 'ifModifiedSince', FIfModifiedSince.Link);
  if (child_name = 'ifMatch') Then
     list.add(self.link, 'ifMatch', FIfMatch.Link);
  if (child_name = 'ifNoneExist') Then
     list.add(self.link, 'ifNoneExist', FIfNoneExist.Link);
end;

procedure TFhirBundleEntryRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'method', 'code', false, TFhirEnum, FMethod.Link));
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'ifNoneMatch', 'string', false, TFhirString, FIfNoneMatch.Link));
  oList.add(TFHIRProperty.create(self, 'ifModifiedSince', 'instant', false, TFhirInstant, FIfModifiedSince.Link));
  oList.add(TFHIRProperty.create(self, 'ifMatch', 'string', false, TFhirString, FIfMatch.Link));
  oList.add(TFHIRProperty.create(self, 'ifNoneExist', 'string', false, TFhirString, FIfNoneExist.Link));
end;

function TFhirBundleEntryRequest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'method') then
  begin
    MethodElement := asEnum(SYSTEMS_TFhirHTTPVerbEnum, CODES_TFhirHTTPVerbEnum, propValue);
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'ifNoneMatch') then
  begin
    IfNoneMatchElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'ifModifiedSince') then
  begin
    IfModifiedSinceElement := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'ifMatch') then
  begin
    IfMatchElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'ifNoneExist') then
  begin
    IfNoneExistElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundleEntryRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBundleEntryRequest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'method') then result := TFhirEnum.create(SYSTEMS_TFhirHTTPVerbEnum[HTTPVerbNull], CODES_TFhirHTTPVerbEnum[HTTPVerbNull]) 
  else if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'ifNoneMatch') then result := TFhirString.create()
  else if (propName = 'ifModifiedSince') then result := TFhirInstant.create()
  else if (propName = 'ifMatch') then result := TFhirString.create()
  else if (propName = 'ifNoneExist') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundleEntryRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'method') then result := 'code'
  else if (propName = 'url') then result := 'uri'
  else if (propName = 'ifNoneMatch') then result := 'string'
  else if (propName = 'ifModifiedSince') then result := 'instant'
  else if (propName = 'ifMatch') then result := 'string'
  else if (propName = 'ifNoneExist') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundleEntryRequest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'method') then MethodElement := nil
  else if (propName = 'url') then UrlElement := nil
  else if (propName = 'ifNoneMatch') then IfNoneMatchElement := nil
  else if (propName = 'ifModifiedSince') then IfModifiedSinceElement := nil
  else if (propName = 'ifMatch') then IfMatchElement := nil
  else if (propName = 'ifNoneExist') then IfNoneExistElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundleEntryRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'method') then MethodElement := asEnum(SYSTEMS_TFhirHTTPVerbEnum, CODES_TFhirHTTPVerbEnum, new)
  else if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'ifNoneMatch') then IfNoneMatchElement := asString(new)
  else if (propName = 'ifModifiedSince') then IfModifiedSinceElement := asInstant(new)
  else if (propName = 'ifMatch') then IfMatchElement := asString(new)
  else if (propName = 'ifNoneExist') then IfNoneExistElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundleEntryRequest.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBundleEntryRequest.fhirType : string;
begin
  result := 'Bundle.entry.request';
end;

function TFhirBundleEntryRequest.Link : TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest(inherited Link);
end;

function TFhirBundleEntryRequest.Clone : TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest(inherited Clone);
end;

function TFhirBundleEntryRequest.equals(other : TObject) : boolean; 
var
  o : TFhirBundleEntryRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundleEntryRequest)) then
    result := false
  else
  begin
    o := TFhirBundleEntryRequest(other);
    result := compareDeep(methodElement, o.methodElement, true) and compareDeep(urlElement, o.urlElement, true) and 
      compareDeep(ifNoneMatchElement, o.ifNoneMatchElement, true) and compareDeep(ifModifiedSinceElement, o.ifModifiedSinceElement, true) and 
      compareDeep(ifMatchElement, o.ifMatchElement, true) and compareDeep(ifNoneExistElement, o.ifNoneExistElement, true);
  end;
end;

function TFhirBundleEntryRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMethod) and isEmptyProp(FUrl) and isEmptyProp(FIfNoneMatch) and isEmptyProp(FIfModifiedSince) and isEmptyProp(FIfMatch) and isEmptyProp(FIfNoneExist);
end;

procedure TFhirBundleEntryRequest.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('method');
  fields.add('url');
  fields.add('ifNoneMatch');
  fields.add('ifModifiedSince');
  fields.add('ifMatch');
  fields.add('ifNoneExist');
end;

function TFhirBundleEntryRequest.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirBundleEntryRequest.SetMethod(value : TFhirEnum);
begin
  FMethod.free;
  FMethod := value;
end;

function TFhirBundleEntryRequest.GetMethodST : TFhirHTTPVerbEnum;
begin
  if FMethod = nil then
    result := TFhirHTTPVerbEnum(0)
  else
    result := TFhirHTTPVerbEnum(StringArrayIndexOfSensitive(CODES_TFhirHTTPVerbEnum, FMethod.value));
end;

procedure TFhirBundleEntryRequest.SetMethodST(value : TFhirHTTPVerbEnum);
begin
  if ord(value) = 0 then
    MethodElement := nil
  else
    MethodElement := TFhirEnum.create(SYSTEMS_TFhirHTTPVerbEnum[value], CODES_TFhirHTTPVerbEnum[value]);
end;

procedure TFhirBundleEntryRequest.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirBundleEntryRequest.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirBundleEntryRequest.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

procedure TFhirBundleEntryRequest.SetIfNoneMatch(value : TFhirString);
begin
  FIfNoneMatch.free;
  FIfNoneMatch := value;
end;

function TFhirBundleEntryRequest.GetIfNoneMatchST : String;
begin
  if FIfNoneMatch = nil then
    result := ''
  else
    result := FIfNoneMatch.value;
end;

procedure TFhirBundleEntryRequest.SetIfNoneMatchST(value : String);
begin
  if value <> '' then
  begin
    if FIfNoneMatch = nil then
      FIfNoneMatch := TFhirString.create;
    FIfNoneMatch.value := value
  end
  else if FIfNoneMatch <> nil then
    FIfNoneMatch.value := '';
end;

procedure TFhirBundleEntryRequest.SetIfModifiedSince(value : TFhirInstant);
begin
  FIfModifiedSince.free;
  FIfModifiedSince := value;
end;

function TFhirBundleEntryRequest.GetIfModifiedSinceST : TFslDateTime;
begin
  if FIfModifiedSince = nil then
    result := TFslDateTime.makeNull
  else
    result := FIfModifiedSince.value;
end;

procedure TFhirBundleEntryRequest.SetIfModifiedSinceST(value : TFslDateTime);
begin
  if FIfModifiedSince = nil then
    FIfModifiedSince := TFhirInstant.create;
  FIfModifiedSince.value := value
end;

procedure TFhirBundleEntryRequest.SetIfMatch(value : TFhirString);
begin
  FIfMatch.free;
  FIfMatch := value;
end;

function TFhirBundleEntryRequest.GetIfMatchST : String;
begin
  if FIfMatch = nil then
    result := ''
  else
    result := FIfMatch.value;
end;

procedure TFhirBundleEntryRequest.SetIfMatchST(value : String);
begin
  if value <> '' then
  begin
    if FIfMatch = nil then
      FIfMatch := TFhirString.create;
    FIfMatch.value := value
  end
  else if FIfMatch <> nil then
    FIfMatch.value := '';
end;

procedure TFhirBundleEntryRequest.SetIfNoneExist(value : TFhirString);
begin
  FIfNoneExist.free;
  FIfNoneExist := value;
end;

function TFhirBundleEntryRequest.GetIfNoneExistST : String;
begin
  if FIfNoneExist = nil then
    result := ''
  else
    result := FIfNoneExist.value;
end;

procedure TFhirBundleEntryRequest.SetIfNoneExistST(value : String);
begin
  if value <> '' then
  begin
    if FIfNoneExist = nil then
      FIfNoneExist := TFhirString.create;
    FIfNoneExist.value := value
  end
  else if FIfNoneExist <> nil then
    FIfNoneExist.value := '';
end;

{ TFhirBundleEntryRequestListEnumerator }

constructor TFhirBundleEntryRequestListEnumerator.Create(list : TFhirBundleEntryRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleEntryRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleEntryRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleEntryRequestListEnumerator.GetCurrent : TFhirBundleEntryRequest;
begin
  Result := FList[FIndex];
end;

function TFhirBundleEntryRequestListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBundleEntryRequestList }

function TFhirBundleEntryRequestList.AddItem(value: TFhirBundleEntryRequest): TFhirBundleEntryRequest;
begin
  assert(value.ClassName = 'TFhirBundleEntryRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundleEntryRequest');
  add(value);
  result := value;
end;

function TFhirBundleEntryRequestList.Append: TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryRequestList.ClearItems;
begin
  Clear;
end;

function TFhirBundleEntryRequestList.GetEnumerator : TFhirBundleEntryRequestListEnumerator;
begin
  result := TFhirBundleEntryRequestListEnumerator.Create(self.link);
end;

function TFhirBundleEntryRequestList.Clone: TFhirBundleEntryRequestList;
begin
  result := TFhirBundleEntryRequestList(inherited Clone);
end;

function TFhirBundleEntryRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleEntryRequestList.GetItemN(index: Integer): TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest(ObjectByIndex[index]);
end;

function TFhirBundleEntryRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundleEntryRequest;
end;
function TFhirBundleEntryRequestList.IndexOf(value: TFhirBundleEntryRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleEntryRequestList.Insert(index: Integer): TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryRequestList.InsertItem(index: Integer; value: TFhirBundleEntryRequest);
begin
  assert(value is TFhirBundleEntryRequest);
  Inherited Insert(index, value);
end;

function TFhirBundleEntryRequestList.Item(index: Integer): TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest(ObjectByIndex[index]);
end;

function TFhirBundleEntryRequestList.Link: TFhirBundleEntryRequestList;
begin
  result := TFhirBundleEntryRequestList(inherited Link);
end;

procedure TFhirBundleEntryRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleEntryRequestList.SetItemByIndex(index: Integer; value: TFhirBundleEntryRequest);
begin
  assert(value is TFhirBundleEntryRequest);
  FhirBundleEntryRequests[index] := value;
end;

procedure TFhirBundleEntryRequestList.SetItemN(index: Integer; value: TFhirBundleEntryRequest);
begin
  assert(value is TFhirBundleEntryRequest);
  ObjectByIndex[index] := value;
end;

{ TFhirBundleEntryResponse }

constructor TFhirBundleEntryResponse.Create;
begin
  inherited;
end;

destructor TFhirBundleEntryResponse.Destroy;
begin
  FStatus.free;
  FLocation.free;
  FEtag.free;
  FLastModified.free;
  FOutcome.free;
  inherited;
end;

procedure TFhirBundleEntryResponse.Assign(oSource : TFslObject);
begin
  inherited;
  statusElement := TFhirBundleEntryResponse(oSource).statusElement.Clone;
  locationElement := TFhirBundleEntryResponse(oSource).locationElement.Clone;
  etagElement := TFhirBundleEntryResponse(oSource).etagElement.Clone;
  lastModifiedElement := TFhirBundleEntryResponse(oSource).lastModifiedElement.Clone;
  outcome := TFhirBundleEntryResponse(oSource).outcome.Clone;
end;

procedure TFhirBundleEntryResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'etag') Then
     list.add(self.link, 'etag', FEtag.Link);
  if (child_name = 'lastModified') Then
     list.add(self.link, 'lastModified', FLastModified.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
end;

procedure TFhirBundleEntryResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'status', 'string', false, TFhirString, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'uri', false, TFhirUri, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'etag', 'string', false, TFhirString, FEtag.Link));
  oList.add(TFHIRProperty.create(self, 'lastModified', 'instant', false, TFhirInstant, FLastModified.Link));
  oList.add(TFHIRProperty.create(self, 'outcome', 'Resource', false, TFhirResource, FOutcome.Link));
end;

function TFhirBundleEntryResponse.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'status') then
  begin
    StatusElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'etag') then
  begin
    EtagElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'lastModified') then
  begin
    LastModifiedElement := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirResource;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundleEntryResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBundleEntryResponse.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'status') then result := TFhirString.create()
  else if (propName = 'location') then result := TFhirUri.create()
  else if (propName = 'etag') then result := TFhirString.create()
  else if (propName = 'lastModified') then result := TFhirInstant.create()
  else if (propName = 'outcome') then raise EFHIRException.create('Cannot make property Outcome')
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundleEntryResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'status') then result := 'string'
  else if (propName = 'location') then result := 'uri'
  else if (propName = 'etag') then result := 'string'
  else if (propName = 'lastModified') then result := 'instant'
  else if (propName = 'outcome') then result := 'Resource'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundleEntryResponse.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'etag') then EtagElement := nil
  else if (propName = 'lastModified') then LastModifiedElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundleEntryResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := asString(new)
  else if (propName = 'location') then LocationElement := asUri(new)
  else if (propName = 'etag') then EtagElement := asString(new)
  else if (propName = 'lastModified') then LastModifiedElement := asInstant(new)
  else if (propName = 'outcome') then OutcomeElement := new as TFhirResource
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundleEntryResponse.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBundleEntryResponse.fhirType : string;
begin
  result := 'Bundle.entry.response';
end;

function TFhirBundleEntryResponse.Link : TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse(inherited Link);
end;

function TFhirBundleEntryResponse.Clone : TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse(inherited Clone);
end;

function TFhirBundleEntryResponse.equals(other : TObject) : boolean; 
var
  o : TFhirBundleEntryResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundleEntryResponse)) then
    result := false
  else
  begin
    o := TFhirBundleEntryResponse(other);
    result := compareDeep(statusElement, o.statusElement, true) and compareDeep(locationElement, o.locationElement, true) and 
      compareDeep(etagElement, o.etagElement, true) and compareDeep(lastModifiedElement, o.lastModifiedElement, true) and 
      compareDeep(outcomeElement, o.outcomeElement, true);
  end;
end;

function TFhirBundleEntryResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStatus) and isEmptyProp(FLocation) and isEmptyProp(FEtag) and isEmptyProp(FLastModified) and isEmptyProp(FOutcome);
end;

procedure TFhirBundleEntryResponse.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('status');
  fields.add('location');
  fields.add('etag');
  fields.add('lastModified');
  fields.add('outcome');
end;

function TFhirBundleEntryResponse.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirBundleEntryResponse.SetStatus(value : TFhirString);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirBundleEntryResponse.GetStatusST : String;
begin
  if FStatus = nil then
    result := ''
  else
    result := FStatus.value;
end;

procedure TFhirBundleEntryResponse.SetStatusST(value : String);
begin
  if value <> '' then
  begin
    if FStatus = nil then
      FStatus := TFhirString.create;
    FStatus.value := value
  end
  else if FStatus <> nil then
    FStatus.value := '';
end;

procedure TFhirBundleEntryResponse.SetLocation(value : TFhirUri);
begin
  FLocation.free;
  FLocation := value;
end;

function TFhirBundleEntryResponse.GetLocationST : String;
begin
  if FLocation = nil then
    result := ''
  else
    result := FLocation.value;
end;

procedure TFhirBundleEntryResponse.SetLocationST(value : String);
begin
  if value <> '' then
  begin
    if FLocation = nil then
      FLocation := TFhirUri.create;
    FLocation.value := value
  end
  else if FLocation <> nil then
    FLocation.value := '';
end;

procedure TFhirBundleEntryResponse.SetEtag(value : TFhirString);
begin
  FEtag.free;
  FEtag := value;
end;

function TFhirBundleEntryResponse.GetEtagST : String;
begin
  if FEtag = nil then
    result := ''
  else
    result := FEtag.value;
end;

procedure TFhirBundleEntryResponse.SetEtagST(value : String);
begin
  if value <> '' then
  begin
    if FEtag = nil then
      FEtag := TFhirString.create;
    FEtag.value := value
  end
  else if FEtag <> nil then
    FEtag.value := '';
end;

procedure TFhirBundleEntryResponse.SetLastModified(value : TFhirInstant);
begin
  FLastModified.free;
  FLastModified := value;
end;

function TFhirBundleEntryResponse.GetLastModifiedST : TFslDateTime;
begin
  if FLastModified = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastModified.value;
end;

procedure TFhirBundleEntryResponse.SetLastModifiedST(value : TFslDateTime);
begin
  if FLastModified = nil then
    FLastModified := TFhirInstant.create;
  FLastModified.value := value
end;

procedure TFhirBundleEntryResponse.SetOutcome(value : TFhirResource);
begin
  FOutcome.free;
  FOutcome := value;
end;

{ TFhirBundleEntryResponseListEnumerator }

constructor TFhirBundleEntryResponseListEnumerator.Create(list : TFhirBundleEntryResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleEntryResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleEntryResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleEntryResponseListEnumerator.GetCurrent : TFhirBundleEntryResponse;
begin
  Result := FList[FIndex];
end;

function TFhirBundleEntryResponseListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBundleEntryResponseList }

function TFhirBundleEntryResponseList.AddItem(value: TFhirBundleEntryResponse): TFhirBundleEntryResponse;
begin
  assert(value.ClassName = 'TFhirBundleEntryResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundleEntryResponse');
  add(value);
  result := value;
end;

function TFhirBundleEntryResponseList.Append: TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryResponseList.ClearItems;
begin
  Clear;
end;

function TFhirBundleEntryResponseList.GetEnumerator : TFhirBundleEntryResponseListEnumerator;
begin
  result := TFhirBundleEntryResponseListEnumerator.Create(self.link);
end;

function TFhirBundleEntryResponseList.Clone: TFhirBundleEntryResponseList;
begin
  result := TFhirBundleEntryResponseList(inherited Clone);
end;

function TFhirBundleEntryResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleEntryResponseList.GetItemN(index: Integer): TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse(ObjectByIndex[index]);
end;

function TFhirBundleEntryResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundleEntryResponse;
end;
function TFhirBundleEntryResponseList.IndexOf(value: TFhirBundleEntryResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleEntryResponseList.Insert(index: Integer): TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryResponseList.InsertItem(index: Integer; value: TFhirBundleEntryResponse);
begin
  assert(value is TFhirBundleEntryResponse);
  Inherited Insert(index, value);
end;

function TFhirBundleEntryResponseList.Item(index: Integer): TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse(ObjectByIndex[index]);
end;

function TFhirBundleEntryResponseList.Link: TFhirBundleEntryResponseList;
begin
  result := TFhirBundleEntryResponseList(inherited Link);
end;

procedure TFhirBundleEntryResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleEntryResponseList.SetItemByIndex(index: Integer; value: TFhirBundleEntryResponse);
begin
  assert(value is TFhirBundleEntryResponse);
  FhirBundleEntryResponses[index] := value;
end;

procedure TFhirBundleEntryResponseList.SetItemN(index: Integer; value: TFhirBundleEntryResponse);
begin
  assert(value is TFhirBundleEntryResponse);
  ObjectByIndex[index] := value;
end;

{ TFhirBundle }

constructor TFhirBundle.Create;
begin
  inherited;
end;

destructor TFhirBundle.Destroy;
begin
  FIdentifier.free;
  FType_.free;
  FTimestamp.free;
  FTotal.free;
  FLink_List.Free;
  FEntryList.Free;
  FSignature.free;
  FIssues.free;
  inherited;
end;

procedure TFhirBundle.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirBundle(oSource).identifier.Clone;
  type_Element := TFhirBundle(oSource).type_Element.Clone;
  timestampElement := TFhirBundle(oSource).timestampElement.Clone;
  totalElement := TFhirBundle(oSource).totalElement.Clone;
  if (TFhirBundle(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirBundleLinkList.Create;
    FLink_List.Assign(TFhirBundle(oSource).FLink_List);
  end;
  if (TFhirBundle(oSource).FEntryList = nil) then
  begin
    FEntryList.free;
    FEntryList := nil;
  end
  else
  begin
    if FEntryList = nil then
      FEntryList := TFhirBundleEntryList.Create;
    FEntryList.Assign(TFhirBundle(oSource).FEntryList);
  end;
  signature := TFhirBundle(oSource).signature.Clone;
  issues := TFhirBundle(oSource).issues.Clone;
end;

function TFhirBundle.GetResourceType : TFhirResourceType;
begin
  result := frtBundle;
end;

procedure TFhirBundle.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'timestamp') Then
     list.add(self.link, 'timestamp', FTimestamp.Link);
  if (child_name = 'total') Then
     list.add(self.link, 'total', FTotal.Link);
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
  if (child_name = 'entry') Then
    list.addAll(self, 'entry', FEntryList);
  if (child_name = 'signature') Then
     list.add(self.link, 'signature', FSignature.Link);
  if (child_name = 'issues') Then
     list.add(self.link, 'issues', FIssues.Link);
end;

procedure TFhirBundle.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'timestamp', 'instant', false, TFhirInstant, FTimestamp.Link));
  oList.add(TFHIRProperty.create(self, 'total', 'unsignedInt', false, TFhirUnsignedInt, FTotal.Link));
  oList.add(TFHIRProperty.create(self, 'link', 'BackboneElement', true, TFhirBundleLink, FLink_List.Link));
  oList.add(TFHIRProperty.create(self, 'entry', 'BackboneElement', true, TFhirBundleEntry, FEntryList.Link));
  oList.add(TFHIRProperty.create(self, 'signature', 'Signature', false, TFhirSignature, FSignature.Link));
  oList.add(TFHIRProperty.create(self, 'issues', 'Resource', false, TFhirResource, FIssues.Link));
end;

function TFhirBundle.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirBundleTypeEnum, CODES_TFhirBundleTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'timestamp') then
  begin
    TimestampElement := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'total') then
  begin
    TotalElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirBundleLink);
    result := propValue;
  end
  else if (propName = 'entry') then
  begin
    EntryList.add(propValue as TFhirBundleEntry);
    result := propValue;
  end
  else if (propName = 'signature') then
  begin
    Signature := propValue as TFhirSignature;
    result := propValue;
  end
  else if (propName = 'issues') then
  begin
    Issues := propValue as TFhirResource;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundle.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirBundleLink)
  else if (propName = 'entry') then EntryList.insertItem(index, propValue as TFhirBundleEntry)
  else inherited;
end;

function TFhirBundle.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirBundleTypeEnum[BundleTypeNull], CODES_TFhirBundleTypeEnum[BundleTypeNull]) 
  else if (propName = 'timestamp') then result := TFhirInstant.create()
  else if (propName = 'total') then result := TFhirUnsignedInt.create()
  else if (propName = 'link') then result := Link_List.new()
  else if (propName = 'entry') then result := EntryList.new()
  else if (propName = 'signature') then result := TFhirSignature.create()
  else if (propName = 'issues') then raise EFHIRException.create('Cannot make property Issues')
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundle.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'timestamp') then result := 'instant'
  else if (propName = 'total') then result := 'unsignedInt'
  else if (propName = 'link') then result := 'BackboneElement'
  else if (propName = 'entry') then result := 'BackboneElement'
  else if (propName = 'signature') then result := 'Signature'
  else if (propName = 'issues') then result := 'Resource'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundle.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'timestamp') then TimestampElement := nil
  else if (propName = 'total') then TotalElement := nil
  else if (propName = 'link') then deletePropertyValue('link', Link_List, value)
  else if (propName = 'entry') then deletePropertyValue('entry', EntryList, value)
  else if (propName = 'signature') then SignatureElement := nil
  else if (propName = 'issues') then IssuesElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundle.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirBundleTypeEnum, CODES_TFhirBundleTypeEnum, new)
  else if (propName = 'timestamp') then TimestampElement := asInstant(new)
  else if (propName = 'total') then TotalElement := asUnsignedInt(new)
  else if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new)
  else if (propName = 'entry') then replacePropertyValue('entry', EntryList, existing, new)
  else if (propName = 'signature') then SignatureElement := new as TFhirSignature
  else if (propName = 'issues') then IssuesElement := new as TFhirResource
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundle.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'link') then Link_List.move(source, destination)
  else if (propName = 'entry') then EntryList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirBundle.fhirType : string;
begin
  result := 'Bundle';
end;

function TFhirBundle.Link : TFhirBundle;
begin
  result := TFhirBundle(inherited Link);
end;

function TFhirBundle.Clone : TFhirBundle;
begin
  result := TFhirBundle(inherited Clone);
end;

function TFhirBundle.equals(other : TObject) : boolean; 
var
  o : TFhirBundle;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundle)) then
    result := false
  else
  begin
    o := TFhirBundle(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(timestampElement, o.timestampElement, true) and compareDeep(totalElement, o.totalElement, true) and 
      compareDeep(link_List, o.link_List, true) and compareDeep(entryList, o.entryList, true) and 
      compareDeep(signatureElement, o.signatureElement, true) and compareDeep(issuesElement, o.issuesElement, true);
  end;
end;

function TFhirBundle.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FType_) and isEmptyProp(FTimestamp) and isEmptyProp(FTotal) and isEmptyProp(Flink_List) and isEmptyProp(FentryList) and isEmptyProp(FSignature) and isEmptyProp(FIssues);
end;

procedure TFhirBundle.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('timestamp');
  fields.add('total');
  fields.add('link');
  fields.add('entry');
  fields.add('signature');
  fields.add('issues');
end;

function TFhirBundle.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FLink_List.sizeInBytes(magic));
  inc(result, FEntryList.sizeInBytes(magic));
end;

procedure TFhirBundle.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirBundle.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirBundle.GetType_ST : TFhirBundleTypeEnum;
begin
  if FType_ = nil then
    result := TFhirBundleTypeEnum(0)
  else
    result := TFhirBundleTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirBundleTypeEnum, FType_.value));
end;

procedure TFhirBundle.SetType_ST(value : TFhirBundleTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirBundleTypeEnum[value], CODES_TFhirBundleTypeEnum[value]);
end;

procedure TFhirBundle.SetTimestamp(value : TFhirInstant);
begin
  FTimestamp.free;
  FTimestamp := value;
end;

function TFhirBundle.GetTimestampST : TFslDateTime;
begin
  if FTimestamp = nil then
    result := TFslDateTime.makeNull
  else
    result := FTimestamp.value;
end;

procedure TFhirBundle.SetTimestampST(value : TFslDateTime);
begin
  if FTimestamp = nil then
    FTimestamp := TFhirInstant.create;
  FTimestamp.value := value
end;

procedure TFhirBundle.SetTotal(value : TFhirUnsignedInt);
begin
  FTotal.free;
  FTotal := value;
end;

function TFhirBundle.GetTotalST : String;
begin
  if FTotal = nil then
    result := ''
  else
    result := FTotal.value;
end;

procedure TFhirBundle.SetTotalST(value : String);
begin
  if value <> '' then
  begin
    if FTotal = nil then
      FTotal := TFhirUnsignedInt.create;
    FTotal.value := value
  end
  else if FTotal <> nil then
    FTotal.value := '';
end;

function TFhirBundle.GetLink_List : TFhirBundleLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirBundleLinkList.Create;
  result := FLink_List;
end;

function TFhirBundle.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

function TFhirBundle.GetEntryList : TFhirBundleEntryList;
begin
  if FEntryList = nil then
    FEntryList := TFhirBundleEntryList.Create;
  result := FEntryList;
end;

function TFhirBundle.GetHasEntryList : boolean;
begin
  result := (FEntryList <> nil) and (FEntryList.count > 0);
end;

procedure TFhirBundle.SetSignature(value : TFhirSignature);
begin
  FSignature.free;
  FSignature := value;
end;

procedure TFhirBundle.SetIssues(value : TFhirResource);
begin
  FIssues.free;
  FIssues := value;
end;

{ TFhirBundleListEnumerator }

constructor TFhirBundleListEnumerator.Create(list : TFhirBundleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleListEnumerator.GetCurrent : TFhirBundle;
begin
  Result := FList[FIndex];
end;

function TFhirBundleListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBundleList }

function TFhirBundleList.AddItem(value: TFhirBundle): TFhirBundle;
begin
  assert(value.ClassName = 'TFhirBundle', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundle');
  add(value);
  result := value;
end;

function TFhirBundleList.Append: TFhirBundle;
begin
  result := TFhirBundle.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleList.ClearItems;
begin
  Clear;
end;

function TFhirBundleList.GetEnumerator : TFhirBundleListEnumerator;
begin
  result := TFhirBundleListEnumerator.Create(self.link);
end;

function TFhirBundleList.Clone: TFhirBundleList;
begin
  result := TFhirBundleList(inherited Clone);
end;

function TFhirBundleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleList.GetItemN(index: Integer): TFhirBundle;
begin
  result := TFhirBundle(ObjectByIndex[index]);
end;

function TFhirBundleList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundle;
end;
function TFhirBundleList.IndexOf(value: TFhirBundle): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleList.Insert(index: Integer): TFhirBundle;
begin
  result := TFhirBundle.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleList.InsertItem(index: Integer; value: TFhirBundle);
begin
  assert(value is TFhirBundle);
  Inherited Insert(index, value);
end;

function TFhirBundleList.Item(index: Integer): TFhirBundle;
begin
  result := TFhirBundle(ObjectByIndex[index]);
end;

function TFhirBundleList.Link: TFhirBundleList;
begin
  result := TFhirBundleList(inherited Link);
end;

procedure TFhirBundleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleList.SetItemByIndex(index: Integer; value: TFhirBundle);
begin
  assert(value is TFhirBundle);
  FhirBundles[index] := value;
end;

procedure TFhirBundleList.SetItemN(index: Integer; value: TFhirBundle);
begin
  assert(value is TFhirBundle);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CONSENT}
{ TFhirConsentPolicyBasis }

constructor TFhirConsentPolicyBasis.Create;
begin
  inherited;
end;

destructor TFhirConsentPolicyBasis.Destroy;
begin
  FReference.free;
  FUrl.free;
  inherited;
end;

procedure TFhirConsentPolicyBasis.Assign(oSource : TFslObject);
begin
  inherited;
  reference := TFhirConsentPolicyBasis(oSource).reference.Clone;
  urlElement := TFhirConsentPolicyBasis(oSource).urlElement.Clone;
end;

procedure TFhirConsentPolicyBasis.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
end;

procedure TFhirConsentPolicyBasis.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference', false, TFhirReference, FReference.Link));
  oList.add(TFHIRProperty.create(self, 'url', 'url', false, TFhirUrl, FUrl.Link));
end;

function TFhirConsentPolicyBasis.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUrl(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConsentPolicyBasis.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConsentPolicyBasis.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'reference') then result := TFhirReference.create()
  else if (propName = 'url') then result := TFhirUrl.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirConsentPolicyBasis.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'reference') then result := 'Reference'
  else if (propName = 'url') then result := 'url'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConsentPolicyBasis.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'reference') then ReferenceElement := nil
  else if (propName = 'url') then UrlElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConsentPolicyBasis.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'reference') then ReferenceElement := new as TFhirReference
  else if (propName = 'url') then UrlElement := asUrl(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConsentPolicyBasis.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConsentPolicyBasis.fhirType : string;
begin
  result := 'Consent.policyBasis';
end;

function TFhirConsentPolicyBasis.Link : TFhirConsentPolicyBasis;
begin
  result := TFhirConsentPolicyBasis(inherited Link);
end;

function TFhirConsentPolicyBasis.Clone : TFhirConsentPolicyBasis;
begin
  result := TFhirConsentPolicyBasis(inherited Clone);
end;

function TFhirConsentPolicyBasis.equals(other : TObject) : boolean; 
var
  o : TFhirConsentPolicyBasis;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConsentPolicyBasis)) then
    result := false
  else
  begin
    o := TFhirConsentPolicyBasis(other);
    result := compareDeep(referenceElement, o.referenceElement, true) and compareDeep(urlElement, o.urlElement, true);
  end;
end;

function TFhirConsentPolicyBasis.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FReference) and isEmptyProp(FUrl);
end;

procedure TFhirConsentPolicyBasis.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('reference');
  fields.add('url');
end;

function TFhirConsentPolicyBasis.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirConsentPolicyBasis.SetReference(value : TFhirReference);
begin
  FReference.free;
  FReference := value;
end;

procedure TFhirConsentPolicyBasis.SetUrl(value : TFhirUrl);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirConsentPolicyBasis.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirConsentPolicyBasis.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUrl.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

{ TFhirConsentPolicyBasisListEnumerator }

constructor TFhirConsentPolicyBasisListEnumerator.Create(list : TFhirConsentPolicyBasisList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConsentPolicyBasisListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConsentPolicyBasisListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConsentPolicyBasisListEnumerator.GetCurrent : TFhirConsentPolicyBasis;
begin
  Result := FList[FIndex];
end;

function TFhirConsentPolicyBasisListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirConsentPolicyBasisList }

function TFhirConsentPolicyBasisList.AddItem(value: TFhirConsentPolicyBasis): TFhirConsentPolicyBasis;
begin
  assert(value.ClassName = 'TFhirConsentPolicyBasis', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConsentPolicyBasis');
  add(value);
  result := value;
end;

function TFhirConsentPolicyBasisList.Append: TFhirConsentPolicyBasis;
begin
  result := TFhirConsentPolicyBasis.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentPolicyBasisList.ClearItems;
begin
  Clear;
end;

function TFhirConsentPolicyBasisList.GetEnumerator : TFhirConsentPolicyBasisListEnumerator;
begin
  result := TFhirConsentPolicyBasisListEnumerator.Create(self.link);
end;

function TFhirConsentPolicyBasisList.Clone: TFhirConsentPolicyBasisList;
begin
  result := TFhirConsentPolicyBasisList(inherited Clone);
end;

function TFhirConsentPolicyBasisList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConsentPolicyBasisList.GetItemN(index: Integer): TFhirConsentPolicyBasis;
begin
  result := TFhirConsentPolicyBasis(ObjectByIndex[index]);
end;

function TFhirConsentPolicyBasisList.ItemClass: TFslObjectClass;
begin
  result := TFhirConsentPolicyBasis;
end;
function TFhirConsentPolicyBasisList.IndexOf(value: TFhirConsentPolicyBasis): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConsentPolicyBasisList.Insert(index: Integer): TFhirConsentPolicyBasis;
begin
  result := TFhirConsentPolicyBasis.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentPolicyBasisList.InsertItem(index: Integer; value: TFhirConsentPolicyBasis);
begin
  assert(value is TFhirConsentPolicyBasis);
  Inherited Insert(index, value);
end;

function TFhirConsentPolicyBasisList.Item(index: Integer): TFhirConsentPolicyBasis;
begin
  result := TFhirConsentPolicyBasis(ObjectByIndex[index]);
end;

function TFhirConsentPolicyBasisList.Link: TFhirConsentPolicyBasisList;
begin
  result := TFhirConsentPolicyBasisList(inherited Link);
end;

procedure TFhirConsentPolicyBasisList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConsentPolicyBasisList.SetItemByIndex(index: Integer; value: TFhirConsentPolicyBasis);
begin
  assert(value is TFhirConsentPolicyBasis);
  FhirConsentPolicyBases[index] := value;
end;

procedure TFhirConsentPolicyBasisList.SetItemN(index: Integer; value: TFhirConsentPolicyBasis);
begin
  assert(value is TFhirConsentPolicyBasis);
  ObjectByIndex[index] := value;
end;

{ TFhirConsentVerification }

constructor TFhirConsentVerification.Create;
begin
  inherited;
end;

destructor TFhirConsentVerification.Destroy;
begin
  FVerified.free;
  FVerificationType.free;
  FVerifiedBy.free;
  FVerifiedWith.free;
  FVerificationDateList.Free;
  inherited;
end;

procedure TFhirConsentVerification.Assign(oSource : TFslObject);
begin
  inherited;
  verifiedElement := TFhirConsentVerification(oSource).verifiedElement.Clone;
  verificationType := TFhirConsentVerification(oSource).verificationType.Clone;
  verifiedBy := TFhirConsentVerification(oSource).verifiedBy.Clone;
  verifiedWith := TFhirConsentVerification(oSource).verifiedWith.Clone;
  if (TFhirConsentVerification(oSource).FVerificationDateList = nil) then
  begin
    FVerificationDateList.free;
    FVerificationDateList := nil;
  end
  else
  begin
    if FVerificationDateList = nil then
      FVerificationDateList := TFhirDateTimeList.Create;
    FVerificationDateList.Assign(TFhirConsentVerification(oSource).FVerificationDateList);
  end;
end;

procedure TFhirConsentVerification.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'verified') Then
     list.add(self.link, 'verified', FVerified.Link);
  if (child_name = 'verificationType') Then
     list.add(self.link, 'verificationType', FVerificationType.Link);
  if (child_name = 'verifiedBy') Then
     list.add(self.link, 'verifiedBy', FVerifiedBy.Link);
  if (child_name = 'verifiedWith') Then
     list.add(self.link, 'verifiedWith', FVerifiedWith.Link);
  if (child_name = 'verificationDate') Then
    list.addAll(self, 'verificationDate', FVerificationDateList);
end;

procedure TFhirConsentVerification.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'verified', 'boolean', false, TFhirBoolean, FVerified.Link));
  oList.add(TFHIRProperty.create(self, 'verificationType', 'CodeableConcept', false, TFhirCodeableConcept, FVerificationType.Link));
  oList.add(TFHIRProperty.create(self, 'verifiedBy', 'Reference', false, TFhirReference, FVerifiedBy.Link));
  oList.add(TFHIRProperty.create(self, 'verifiedWith', 'Reference', false, TFhirReference, FVerifiedWith.Link));
  oList.add(TFHIRProperty.create(self, 'verificationDate', 'dateTime', true, TFhirDateTime, FVerificationDateList.Link));
end;

function TFhirConsentVerification.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'verified') then
  begin
    VerifiedElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'verificationType') then
  begin
    VerificationType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'verifiedBy') then
  begin
    VerifiedBy := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'verifiedWith') then
  begin
    VerifiedWith := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'verificationDate') then
  begin
    VerificationDateList.add(asDateTime(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConsentVerification.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'verificationDate') then VerificationDateList.insertItem(index, asDateTime(propValue))
  else inherited;
end;

function TFhirConsentVerification.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'verified') then result := TFhirBoolean.create()
  else if (propName = 'verificationType') then result := TFhirCodeableConcept.create()
  else if (propName = 'verifiedBy') then result := TFhirReference.create()
  else if (propName = 'verifiedWith') then result := TFhirReference.create()
  else if (propName = 'verificationDate') then result := VerificationDateList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirConsentVerification.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'verified') then result := 'boolean'
  else if (propName = 'verificationType') then result := 'CodeableConcept'
  else if (propName = 'verifiedBy') then result := 'Reference'
  else if (propName = 'verifiedWith') then result := 'Reference'
  else if (propName = 'verificationDate') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConsentVerification.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'verified') then VerifiedElement := nil
  else if (propName = 'verificationType') then VerificationTypeElement := nil
  else if (propName = 'verifiedBy') then VerifiedByElement := nil
  else if (propName = 'verifiedWith') then VerifiedWithElement := nil
  else if (propName = 'verificationDate') then deletePropertyValue('verificationDate', VerificationDateList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConsentVerification.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'verified') then VerifiedElement := asBoolean(new)
  else if (propName = 'verificationType') then VerificationTypeElement := new as TFhirCodeableConcept
  else if (propName = 'verifiedBy') then VerifiedByElement := new as TFhirReference
  else if (propName = 'verifiedWith') then VerifiedWithElement := new as TFhirReference
  else if (propName = 'verificationDate') then replacePropertyValue('verificationDate', VerificationDateList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConsentVerification.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'verificationDate') then VerificationDateList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConsentVerification.fhirType : string;
begin
  result := 'Consent.verification';
end;

function TFhirConsentVerification.Link : TFhirConsentVerification;
begin
  result := TFhirConsentVerification(inherited Link);
end;

function TFhirConsentVerification.Clone : TFhirConsentVerification;
begin
  result := TFhirConsentVerification(inherited Clone);
end;

function TFhirConsentVerification.equals(other : TObject) : boolean; 
var
  o : TFhirConsentVerification;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConsentVerification)) then
    result := false
  else
  begin
    o := TFhirConsentVerification(other);
    result := compareDeep(verifiedElement, o.verifiedElement, true) and compareDeep(verificationTypeElement, o.verificationTypeElement, true) and 
      compareDeep(verifiedByElement, o.verifiedByElement, true) and compareDeep(verifiedWithElement, o.verifiedWithElement, true) and 
      compareDeep(verificationDateList, o.verificationDateList, true);
  end;
end;

function TFhirConsentVerification.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FVerified) and isEmptyProp(FVerificationType) and isEmptyProp(FVerifiedBy) and isEmptyProp(FVerifiedWith) and isEmptyProp(FverificationDateList);
end;

procedure TFhirConsentVerification.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('verified');
  fields.add('verificationType');
  fields.add('verifiedBy');
  fields.add('verifiedWith');
  fields.add('verificationDate');
end;

function TFhirConsentVerification.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FVerificationDateList.sizeInBytes(magic));
end;

procedure TFhirConsentVerification.SetVerified(value : TFhirBoolean);
begin
  FVerified.free;
  FVerified := value;
end;

function TFhirConsentVerification.GetVerifiedST : Boolean;
begin
  if FVerified = nil then
    result := false
  else
    result := FVerified.value;
end;

procedure TFhirConsentVerification.SetVerifiedST(value : Boolean);
begin
  if FVerified = nil then
    FVerified := TFhirBoolean.create;
  FVerified.value := value
end;

procedure TFhirConsentVerification.SetVerificationType(value : TFhirCodeableConcept);
begin
  FVerificationType.free;
  FVerificationType := value;
end;

procedure TFhirConsentVerification.SetVerifiedBy(value : TFhirReference);
begin
  FVerifiedBy.free;
  FVerifiedBy := value;
end;

procedure TFhirConsentVerification.SetVerifiedWith(value : TFhirReference);
begin
  FVerifiedWith.free;
  FVerifiedWith := value;
end;

function TFhirConsentVerification.GetVerificationDateList : TFhirDateTimeList;
begin
  if FVerificationDateList = nil then
    FVerificationDateList := TFhirDateTimeList.Create;
  result := FVerificationDateList;
end;

function TFhirConsentVerification.GetHasVerificationDateList : boolean;
begin
  result := (FVerificationDateList <> nil) and (FVerificationDateList.count > 0);
end;

{ TFhirConsentVerificationListEnumerator }

constructor TFhirConsentVerificationListEnumerator.Create(list : TFhirConsentVerificationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConsentVerificationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConsentVerificationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConsentVerificationListEnumerator.GetCurrent : TFhirConsentVerification;
begin
  Result := FList[FIndex];
end;

function TFhirConsentVerificationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirConsentVerificationList }

function TFhirConsentVerificationList.AddItem(value: TFhirConsentVerification): TFhirConsentVerification;
begin
  assert(value.ClassName = 'TFhirConsentVerification', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConsentVerification');
  add(value);
  result := value;
end;

function TFhirConsentVerificationList.Append: TFhirConsentVerification;
begin
  result := TFhirConsentVerification.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentVerificationList.ClearItems;
begin
  Clear;
end;

function TFhirConsentVerificationList.GetEnumerator : TFhirConsentVerificationListEnumerator;
begin
  result := TFhirConsentVerificationListEnumerator.Create(self.link);
end;

function TFhirConsentVerificationList.Clone: TFhirConsentVerificationList;
begin
  result := TFhirConsentVerificationList(inherited Clone);
end;

function TFhirConsentVerificationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConsentVerificationList.GetItemN(index: Integer): TFhirConsentVerification;
begin
  result := TFhirConsentVerification(ObjectByIndex[index]);
end;

function TFhirConsentVerificationList.ItemClass: TFslObjectClass;
begin
  result := TFhirConsentVerification;
end;
function TFhirConsentVerificationList.IndexOf(value: TFhirConsentVerification): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConsentVerificationList.Insert(index: Integer): TFhirConsentVerification;
begin
  result := TFhirConsentVerification.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentVerificationList.InsertItem(index: Integer; value: TFhirConsentVerification);
begin
  assert(value is TFhirConsentVerification);
  Inherited Insert(index, value);
end;

function TFhirConsentVerificationList.Item(index: Integer): TFhirConsentVerification;
begin
  result := TFhirConsentVerification(ObjectByIndex[index]);
end;

function TFhirConsentVerificationList.Link: TFhirConsentVerificationList;
begin
  result := TFhirConsentVerificationList(inherited Link);
end;

procedure TFhirConsentVerificationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConsentVerificationList.SetItemByIndex(index: Integer; value: TFhirConsentVerification);
begin
  assert(value is TFhirConsentVerification);
  FhirConsentVerifications[index] := value;
end;

procedure TFhirConsentVerificationList.SetItemN(index: Integer; value: TFhirConsentVerification);
begin
  assert(value is TFhirConsentVerification);
  ObjectByIndex[index] := value;
end;

{ TFhirConsentProvision }

constructor TFhirConsentProvision.Create;
begin
  inherited;
end;

destructor TFhirConsentProvision.Destroy;
begin
  FType_.free;
  FPeriod.free;
  FActorList.Free;
  FActionList.Free;
  FSecurityLabelList.Free;
  FPurposeList.Free;
  FClass_List.Free;
  FCodeList.Free;
  FDataPeriod.free;
  FDataList.Free;
  FExpression.free;
  FProvisionList.Free;
  inherited;
end;

procedure TFhirConsentProvision.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirConsentProvision(oSource).type_Element.Clone;
  period := TFhirConsentProvision(oSource).period.Clone;
  if (TFhirConsentProvision(oSource).FActorList = nil) then
  begin
    FActorList.free;
    FActorList := nil;
  end
  else
  begin
    if FActorList = nil then
      FActorList := TFhirConsentProvisionActorList.Create;
    FActorList.Assign(TFhirConsentProvision(oSource).FActorList);
  end;
  if (TFhirConsentProvision(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirCodeableConceptList.Create;
    FActionList.Assign(TFhirConsentProvision(oSource).FActionList);
  end;
  if (TFhirConsentProvision(oSource).FSecurityLabelList = nil) then
  begin
    FSecurityLabelList.free;
    FSecurityLabelList := nil;
  end
  else
  begin
    if FSecurityLabelList = nil then
      FSecurityLabelList := TFhirCodingList.Create;
    FSecurityLabelList.Assign(TFhirConsentProvision(oSource).FSecurityLabelList);
  end;
  if (TFhirConsentProvision(oSource).FPurposeList = nil) then
  begin
    FPurposeList.free;
    FPurposeList := nil;
  end
  else
  begin
    if FPurposeList = nil then
      FPurposeList := TFhirCodingList.Create;
    FPurposeList.Assign(TFhirConsentProvision(oSource).FPurposeList);
  end;
  if (TFhirConsentProvision(oSource).FClass_List = nil) then
  begin
    FClass_List.free;
    FClass_List := nil;
  end
  else
  begin
    if FClass_List = nil then
      FClass_List := TFhirCodingList.Create;
    FClass_List.Assign(TFhirConsentProvision(oSource).FClass_List);
  end;
  if (TFhirConsentProvision(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirConsentProvision(oSource).FCodeList);
  end;
  dataPeriod := TFhirConsentProvision(oSource).dataPeriod.Clone;
  if (TFhirConsentProvision(oSource).FDataList = nil) then
  begin
    FDataList.free;
    FDataList := nil;
  end
  else
  begin
    if FDataList = nil then
      FDataList := TFhirConsentProvisionDataList.Create;
    FDataList.Assign(TFhirConsentProvision(oSource).FDataList);
  end;
  expression := TFhirConsentProvision(oSource).expression.Clone;
  if (TFhirConsentProvision(oSource).FProvisionList = nil) then
  begin
    FProvisionList.free;
    FProvisionList := nil;
  end
  else
  begin
    if FProvisionList = nil then
      FProvisionList := TFhirConsentProvisionList.Create;
    FProvisionList.Assign(TFhirConsentProvision(oSource).FProvisionList);
  end;
end;

procedure TFhirConsentProvision.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'actor') Then
    list.addAll(self, 'actor', FActorList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
  if (child_name = 'securityLabel') Then
    list.addAll(self, 'securityLabel', FSecurityLabelList);
  if (child_name = 'purpose') Then
    list.addAll(self, 'purpose', FPurposeList);
  if (child_name = 'class') Then
    list.addAll(self, 'class', FClass_List);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'dataPeriod') Then
     list.add(self.link, 'dataPeriod', FDataPeriod.Link);
  if (child_name = 'data') Then
    list.addAll(self, 'data', FDataList);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
  if (child_name = 'provision') Then
    list.addAll(self, 'provision', FProvisionList);
end;

procedure TFhirConsentProvision.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'actor', 'BackboneElement', true, TFhirConsentProvisionActor, FActorList.Link));
  oList.add(TFHIRProperty.create(self, 'action', 'CodeableConcept', true, TFhirCodeableConcept, FActionList.Link));
  oList.add(TFHIRProperty.create(self, 'securityLabel', 'Coding', true, TFhirCoding, FSecurityLabelList.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'Coding', true, TFhirCoding, FPurposeList.Link));
  oList.add(TFHIRProperty.create(self, 'class', 'Coding', true, TFhirCoding, FClass_List.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'dataPeriod', 'Period', false, TFhirPeriod, FDataPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'data', 'BackboneElement', true, TFhirConsentProvisionData, FDataList.Link));
  oList.add(TFHIRProperty.create(self, 'expression', 'Expression', false, TFhirExpression, FExpression.Link));
  oList.add(TFHIRProperty.create(self, 'provision', '', true, TFhirConsentProvision, FProvisionList.Link));
end;

function TFhirConsentProvision.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirConsentProvisionTypeEnum, CODES_TFhirConsentProvisionTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    ActorList.add(propValue as TFhirConsentProvisionActor);
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'securityLabel') then
  begin
    SecurityLabelList.add(propValue as TFhirCoding);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeList.add(propValue as TFhirCoding);
    result := propValue;
  end
  else if (propName = 'class') then
  begin
    Class_List.add(propValue as TFhirCoding);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'dataPeriod') then
  begin
    DataPeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'data') then
  begin
    DataList.add(propValue as TFhirConsentProvisionData);
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    Expression := propValue as TFhirExpression;
    result := propValue;
  end
  else if (propName = 'provision') then
  begin
    ProvisionList.add(propValue as TFhirConsentProvision);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConsentProvision.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'actor') then ActorList.insertItem(index, propValue as TFhirConsentProvisionActor)
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'securityLabel') then SecurityLabelList.insertItem(index, propValue as TFhirCoding)
  else if (propName = 'purpose') then PurposeList.insertItem(index, propValue as TFhirCoding)
  else if (propName = 'class') then Class_List.insertItem(index, propValue as TFhirCoding)
  else if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'data') then DataList.insertItem(index, propValue as TFhirConsentProvisionData)
  else if (propName = 'provision') then ProvisionList.insertItem(index, propValue as TFhirConsentProvision)
  else inherited;
end;

function TFhirConsentProvision.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirConsentProvisionTypeEnum[ConsentProvisionTypeNull], CODES_TFhirConsentProvisionTypeEnum[ConsentProvisionTypeNull]) 
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'actor') then result := ActorList.new()
  else if (propName = 'action') then result := ActionList.new()
  else if (propName = 'securityLabel') then result := SecurityLabelList.new()
  else if (propName = 'purpose') then result := PurposeList.new()
  else if (propName = 'class') then result := Class_List.new()
  else if (propName = 'code') then result := CodeList.new()
  else if (propName = 'dataPeriod') then result := TFhirPeriod.create()
  else if (propName = 'data') then result := DataList.new()
  else if (propName = 'expression') then result := TFhirExpression.create()
  else if (propName = 'provision') then result := ProvisionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirConsentProvision.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'actor') then result := 'BackboneElement'
  else if (propName = 'action') then result := 'CodeableConcept'
  else if (propName = 'securityLabel') then result := 'Coding'
  else if (propName = 'purpose') then result := 'Coding'
  else if (propName = 'class') then result := 'Coding'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'dataPeriod') then result := 'Period'
  else if (propName = 'data') then result := 'BackboneElement'
  else if (propName = 'expression') then result := 'Expression'
  else if (propName = 'provision') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConsentProvision.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'actor') then deletePropertyValue('actor', ActorList, value)
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value)
  else if (propName = 'securityLabel') then deletePropertyValue('securityLabel', SecurityLabelList, value)
  else if (propName = 'purpose') then deletePropertyValue('purpose', PurposeList, value)
  else if (propName = 'class') then deletePropertyValue('class', Class_List, value)
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value)
  else if (propName = 'dataPeriod') then DataPeriodElement := nil
  else if (propName = 'data') then deletePropertyValue('data', DataList, value)
  else if (propName = 'expression') then ExpressionElement := nil
  else if (propName = 'provision') then deletePropertyValue('provision', ProvisionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConsentProvision.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirConsentProvisionTypeEnum, CODES_TFhirConsentProvisionTypeEnum, new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'actor') then replacePropertyValue('actor', ActorList, existing, new)
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new)
  else if (propName = 'securityLabel') then replacePropertyValue('securityLabel', SecurityLabelList, existing, new)
  else if (propName = 'purpose') then replacePropertyValue('purpose', PurposeList, existing, new)
  else if (propName = 'class') then replacePropertyValue('class', Class_List, existing, new)
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new)
  else if (propName = 'dataPeriod') then DataPeriodElement := new as TFhirPeriod
  else if (propName = 'data') then replacePropertyValue('data', DataList, existing, new)
  else if (propName = 'expression') then ExpressionElement := new as TFhirExpression
  else if (propName = 'provision') then replacePropertyValue('provision', ProvisionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConsentProvision.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'actor') then ActorList.move(source, destination)
  else if (propName = 'action') then ActionList.move(source, destination)
  else if (propName = 'securityLabel') then SecurityLabelList.move(source, destination)
  else if (propName = 'purpose') then PurposeList.move(source, destination)
  else if (propName = 'class') then Class_List.move(source, destination)
  else if (propName = 'code') then CodeList.move(source, destination)
  else if (propName = 'data') then DataList.move(source, destination)
  else if (propName = 'provision') then ProvisionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConsentProvision.fhirType : string;
begin
  result := 'Consent.provision';
end;

function TFhirConsentProvision.Link : TFhirConsentProvision;
begin
  result := TFhirConsentProvision(inherited Link);
end;

function TFhirConsentProvision.Clone : TFhirConsentProvision;
begin
  result := TFhirConsentProvision(inherited Clone);
end;

function TFhirConsentProvision.equals(other : TObject) : boolean; 
var
  o : TFhirConsentProvision;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConsentProvision)) then
    result := false
  else
  begin
    o := TFhirConsentProvision(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(actorList, o.actorList, true) and compareDeep(actionList, o.actionList, true) and 
      compareDeep(securityLabelList, o.securityLabelList, true) and compareDeep(purposeList, o.purposeList, true) and 
      compareDeep(class_List, o.class_List, true) and compareDeep(codeList, o.codeList, true) and 
      compareDeep(dataPeriodElement, o.dataPeriodElement, true) and compareDeep(dataList, o.dataList, true) and 
      compareDeep(expressionElement, o.expressionElement, true) and compareDeep(provisionList, o.provisionList, true);
  end;
end;

function TFhirConsentProvision.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FPeriod) and isEmptyProp(FactorList) and isEmptyProp(FactionList) and isEmptyProp(FsecurityLabelList) and isEmptyProp(FpurposeList) and isEmptyProp(Fclass_List) and isEmptyProp(FcodeList) and isEmptyProp(FDataPeriod) and isEmptyProp(FdataList) and isEmptyProp(FExpression) and isEmptyProp(FprovisionList);
end;

procedure TFhirConsentProvision.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('period');
  fields.add('actor');
  fields.add('action');
  fields.add('securityLabel');
  fields.add('purpose');
  fields.add('class');
  fields.add('code');
  fields.add('dataPeriod');
  fields.add('data');
  fields.add('expression');
  fields.add('provision');
end;

function TFhirConsentProvision.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FActorList.sizeInBytes(magic));
  inc(result, FActionList.sizeInBytes(magic));
  inc(result, FSecurityLabelList.sizeInBytes(magic));
  inc(result, FPurposeList.sizeInBytes(magic));
  inc(result, FClass_List.sizeInBytes(magic));
  inc(result, FCodeList.sizeInBytes(magic));
  inc(result, FDataList.sizeInBytes(magic));
  inc(result, FProvisionList.sizeInBytes(magic));
end;

procedure TFhirConsentProvision.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirConsentProvision.GetType_ST : TFhirConsentProvisionTypeEnum;
begin
  if FType_ = nil then
    result := TFhirConsentProvisionTypeEnum(0)
  else
    result := TFhirConsentProvisionTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirConsentProvisionTypeEnum, FType_.value));
end;

procedure TFhirConsentProvision.SetType_ST(value : TFhirConsentProvisionTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirConsentProvisionTypeEnum[value], CODES_TFhirConsentProvisionTypeEnum[value]);
end;

procedure TFhirConsentProvision.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirConsentProvision.GetActorList : TFhirConsentProvisionActorList;
begin
  if FActorList = nil then
    FActorList := TFhirConsentProvisionActorList.Create;
  result := FActorList;
end;

function TFhirConsentProvision.GetHasActorList : boolean;
begin
  result := (FActorList <> nil) and (FActorList.count > 0);
end;

function TFhirConsentProvision.GetActionList : TFhirCodeableConceptList;
begin
  if FActionList = nil then
    FActionList := TFhirCodeableConceptList.Create;
  result := FActionList;
end;

function TFhirConsentProvision.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

function TFhirConsentProvision.GetSecurityLabelList : TFhirCodingList;
begin
  if FSecurityLabelList = nil then
    FSecurityLabelList := TFhirCodingList.Create;
  result := FSecurityLabelList;
end;

function TFhirConsentProvision.GetHasSecurityLabelList : boolean;
begin
  result := (FSecurityLabelList <> nil) and (FSecurityLabelList.count > 0);
end;

function TFhirConsentProvision.GetPurposeList : TFhirCodingList;
begin
  if FPurposeList = nil then
    FPurposeList := TFhirCodingList.Create;
  result := FPurposeList;
end;

function TFhirConsentProvision.GetHasPurposeList : boolean;
begin
  result := (FPurposeList <> nil) and (FPurposeList.count > 0);
end;

function TFhirConsentProvision.GetClass_List : TFhirCodingList;
begin
  if FClass_List = nil then
    FClass_List := TFhirCodingList.Create;
  result := FClass_List;
end;

function TFhirConsentProvision.GetHasClass_List : boolean;
begin
  result := (FClass_List <> nil) and (FClass_List.count > 0);
end;

function TFhirConsentProvision.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

function TFhirConsentProvision.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

procedure TFhirConsentProvision.SetDataPeriod(value : TFhirPeriod);
begin
  FDataPeriod.free;
  FDataPeriod := value;
end;

function TFhirConsentProvision.GetDataList : TFhirConsentProvisionDataList;
begin
  if FDataList = nil then
    FDataList := TFhirConsentProvisionDataList.Create;
  result := FDataList;
end;

function TFhirConsentProvision.GetHasDataList : boolean;
begin
  result := (FDataList <> nil) and (FDataList.count > 0);
end;

procedure TFhirConsentProvision.SetExpression(value : TFhirExpression);
begin
  FExpression.free;
  FExpression := value;
end;

function TFhirConsentProvision.GetProvisionList : TFhirConsentProvisionList;
begin
  if FProvisionList = nil then
    FProvisionList := TFhirConsentProvisionList.Create;
  result := FProvisionList;
end;

function TFhirConsentProvision.GetHasProvisionList : boolean;
begin
  result := (FProvisionList <> nil) and (FProvisionList.count > 0);
end;

{ TFhirConsentProvisionListEnumerator }

constructor TFhirConsentProvisionListEnumerator.Create(list : TFhirConsentProvisionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConsentProvisionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConsentProvisionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConsentProvisionListEnumerator.GetCurrent : TFhirConsentProvision;
begin
  Result := FList[FIndex];
end;

function TFhirConsentProvisionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirConsentProvisionList }

function TFhirConsentProvisionList.AddItem(value: TFhirConsentProvision): TFhirConsentProvision;
begin
  assert(value.ClassName = 'TFhirConsentProvision', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConsentProvision');
  add(value);
  result := value;
end;

function TFhirConsentProvisionList.Append: TFhirConsentProvision;
begin
  result := TFhirConsentProvision.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentProvisionList.ClearItems;
begin
  Clear;
end;

function TFhirConsentProvisionList.GetEnumerator : TFhirConsentProvisionListEnumerator;
begin
  result := TFhirConsentProvisionListEnumerator.Create(self.link);
end;

function TFhirConsentProvisionList.Clone: TFhirConsentProvisionList;
begin
  result := TFhirConsentProvisionList(inherited Clone);
end;

function TFhirConsentProvisionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConsentProvisionList.GetItemN(index: Integer): TFhirConsentProvision;
begin
  result := TFhirConsentProvision(ObjectByIndex[index]);
end;

function TFhirConsentProvisionList.ItemClass: TFslObjectClass;
begin
  result := TFhirConsentProvision;
end;
function TFhirConsentProvisionList.IndexOf(value: TFhirConsentProvision): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConsentProvisionList.Insert(index: Integer): TFhirConsentProvision;
begin
  result := TFhirConsentProvision.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentProvisionList.InsertItem(index: Integer; value: TFhirConsentProvision);
begin
  assert(value is TFhirConsentProvision);
  Inherited Insert(index, value);
end;

function TFhirConsentProvisionList.Item(index: Integer): TFhirConsentProvision;
begin
  result := TFhirConsentProvision(ObjectByIndex[index]);
end;

function TFhirConsentProvisionList.Link: TFhirConsentProvisionList;
begin
  result := TFhirConsentProvisionList(inherited Link);
end;

procedure TFhirConsentProvisionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConsentProvisionList.SetItemByIndex(index: Integer; value: TFhirConsentProvision);
begin
  assert(value is TFhirConsentProvision);
  FhirConsentProvisions[index] := value;
end;

procedure TFhirConsentProvisionList.SetItemN(index: Integer; value: TFhirConsentProvision);
begin
  assert(value is TFhirConsentProvision);
  ObjectByIndex[index] := value;
end;

{ TFhirConsentProvisionActor }

constructor TFhirConsentProvisionActor.Create;
begin
  inherited;
end;

destructor TFhirConsentProvisionActor.Destroy;
begin
  FRole.free;
  FReference.free;
  inherited;
end;

procedure TFhirConsentProvisionActor.Assign(oSource : TFslObject);
begin
  inherited;
  role := TFhirConsentProvisionActor(oSource).role.Clone;
  reference := TFhirConsentProvisionActor(oSource).reference.Clone;
end;

procedure TFhirConsentProvisionActor.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
end;

procedure TFhirConsentProvisionActor.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference', false, TFhirReference, FReference.Link));
end;

function TFhirConsentProvisionActor.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConsentProvisionActor.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConsentProvisionActor.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirCodeableConcept.create()
  else if (propName = 'reference') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirConsentProvisionActor.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'reference') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConsentProvisionActor.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConsentProvisionActor.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := new as TFhirCodeableConcept
  else if (propName = 'reference') then ReferenceElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConsentProvisionActor.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConsentProvisionActor.fhirType : string;
begin
  result := 'Consent.provision.actor';
end;

function TFhirConsentProvisionActor.Link : TFhirConsentProvisionActor;
begin
  result := TFhirConsentProvisionActor(inherited Link);
end;

function TFhirConsentProvisionActor.Clone : TFhirConsentProvisionActor;
begin
  result := TFhirConsentProvisionActor(inherited Clone);
end;

function TFhirConsentProvisionActor.equals(other : TObject) : boolean; 
var
  o : TFhirConsentProvisionActor;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConsentProvisionActor)) then
    result := false
  else
  begin
    o := TFhirConsentProvisionActor(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(referenceElement, o.referenceElement, true);
  end;
end;

function TFhirConsentProvisionActor.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FReference);
end;

procedure TFhirConsentProvisionActor.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('role');
  fields.add('reference');
end;

function TFhirConsentProvisionActor.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirConsentProvisionActor.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

procedure TFhirConsentProvisionActor.SetReference(value : TFhirReference);
begin
  FReference.free;
  FReference := value;
end;

{ TFhirConsentProvisionActorListEnumerator }

constructor TFhirConsentProvisionActorListEnumerator.Create(list : TFhirConsentProvisionActorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConsentProvisionActorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConsentProvisionActorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConsentProvisionActorListEnumerator.GetCurrent : TFhirConsentProvisionActor;
begin
  Result := FList[FIndex];
end;

function TFhirConsentProvisionActorListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirConsentProvisionActorList }

function TFhirConsentProvisionActorList.AddItem(value: TFhirConsentProvisionActor): TFhirConsentProvisionActor;
begin
  assert(value.ClassName = 'TFhirConsentProvisionActor', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConsentProvisionActor');
  add(value);
  result := value;
end;

function TFhirConsentProvisionActorList.Append: TFhirConsentProvisionActor;
begin
  result := TFhirConsentProvisionActor.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentProvisionActorList.ClearItems;
begin
  Clear;
end;

function TFhirConsentProvisionActorList.GetEnumerator : TFhirConsentProvisionActorListEnumerator;
begin
  result := TFhirConsentProvisionActorListEnumerator.Create(self.link);
end;

function TFhirConsentProvisionActorList.Clone: TFhirConsentProvisionActorList;
begin
  result := TFhirConsentProvisionActorList(inherited Clone);
end;

function TFhirConsentProvisionActorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConsentProvisionActorList.GetItemN(index: Integer): TFhirConsentProvisionActor;
begin
  result := TFhirConsentProvisionActor(ObjectByIndex[index]);
end;

function TFhirConsentProvisionActorList.ItemClass: TFslObjectClass;
begin
  result := TFhirConsentProvisionActor;
end;
function TFhirConsentProvisionActorList.IndexOf(value: TFhirConsentProvisionActor): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConsentProvisionActorList.Insert(index: Integer): TFhirConsentProvisionActor;
begin
  result := TFhirConsentProvisionActor.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentProvisionActorList.InsertItem(index: Integer; value: TFhirConsentProvisionActor);
begin
  assert(value is TFhirConsentProvisionActor);
  Inherited Insert(index, value);
end;

function TFhirConsentProvisionActorList.Item(index: Integer): TFhirConsentProvisionActor;
begin
  result := TFhirConsentProvisionActor(ObjectByIndex[index]);
end;

function TFhirConsentProvisionActorList.Link: TFhirConsentProvisionActorList;
begin
  result := TFhirConsentProvisionActorList(inherited Link);
end;

procedure TFhirConsentProvisionActorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConsentProvisionActorList.SetItemByIndex(index: Integer; value: TFhirConsentProvisionActor);
begin
  assert(value is TFhirConsentProvisionActor);
  FhirConsentProvisionActors[index] := value;
end;

procedure TFhirConsentProvisionActorList.SetItemN(index: Integer; value: TFhirConsentProvisionActor);
begin
  assert(value is TFhirConsentProvisionActor);
  ObjectByIndex[index] := value;
end;

{ TFhirConsentProvisionData }

constructor TFhirConsentProvisionData.Create;
begin
  inherited;
end;

destructor TFhirConsentProvisionData.Destroy;
begin
  FMeaning.free;
  FReference.free;
  inherited;
end;

procedure TFhirConsentProvisionData.Assign(oSource : TFslObject);
begin
  inherited;
  meaningElement := TFhirConsentProvisionData(oSource).meaningElement.Clone;
  reference := TFhirConsentProvisionData(oSource).reference.Clone;
end;

procedure TFhirConsentProvisionData.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'meaning') Then
     list.add(self.link, 'meaning', FMeaning.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
end;

procedure TFhirConsentProvisionData.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'meaning', 'code', false, TFhirEnum, FMeaning.Link));
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference', false, TFhirReference, FReference.Link));
end;

function TFhirConsentProvisionData.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'meaning') then
  begin
    MeaningElement := asEnum(SYSTEMS_TFhirConsentDataMeaningEnum, CODES_TFhirConsentDataMeaningEnum, propValue);
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConsentProvisionData.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConsentProvisionData.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'meaning') then result := TFhirEnum.create(SYSTEMS_TFhirConsentDataMeaningEnum[ConsentDataMeaningNull], CODES_TFhirConsentDataMeaningEnum[ConsentDataMeaningNull]) 
  else if (propName = 'reference') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirConsentProvisionData.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'meaning') then result := 'code'
  else if (propName = 'reference') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConsentProvisionData.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'meaning') then MeaningElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConsentProvisionData.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'meaning') then MeaningElement := asEnum(SYSTEMS_TFhirConsentDataMeaningEnum, CODES_TFhirConsentDataMeaningEnum, new)
  else if (propName = 'reference') then ReferenceElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConsentProvisionData.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConsentProvisionData.fhirType : string;
begin
  result := 'Consent.provision.data';
end;

function TFhirConsentProvisionData.Link : TFhirConsentProvisionData;
begin
  result := TFhirConsentProvisionData(inherited Link);
end;

function TFhirConsentProvisionData.Clone : TFhirConsentProvisionData;
begin
  result := TFhirConsentProvisionData(inherited Clone);
end;

function TFhirConsentProvisionData.equals(other : TObject) : boolean; 
var
  o : TFhirConsentProvisionData;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConsentProvisionData)) then
    result := false
  else
  begin
    o := TFhirConsentProvisionData(other);
    result := compareDeep(meaningElement, o.meaningElement, true) and compareDeep(referenceElement, o.referenceElement, true);
  end;
end;

function TFhirConsentProvisionData.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMeaning) and isEmptyProp(FReference);
end;

procedure TFhirConsentProvisionData.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('meaning');
  fields.add('reference');
end;

function TFhirConsentProvisionData.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirConsentProvisionData.SetMeaning(value : TFhirEnum);
begin
  FMeaning.free;
  FMeaning := value;
end;

function TFhirConsentProvisionData.GetMeaningST : TFhirConsentDataMeaningEnum;
begin
  if FMeaning = nil then
    result := TFhirConsentDataMeaningEnum(0)
  else
    result := TFhirConsentDataMeaningEnum(StringArrayIndexOfSensitive(CODES_TFhirConsentDataMeaningEnum, FMeaning.value));
end;

procedure TFhirConsentProvisionData.SetMeaningST(value : TFhirConsentDataMeaningEnum);
begin
  if ord(value) = 0 then
    MeaningElement := nil
  else
    MeaningElement := TFhirEnum.create(SYSTEMS_TFhirConsentDataMeaningEnum[value], CODES_TFhirConsentDataMeaningEnum[value]);
end;

procedure TFhirConsentProvisionData.SetReference(value : TFhirReference);
begin
  FReference.free;
  FReference := value;
end;

{ TFhirConsentProvisionDataListEnumerator }

constructor TFhirConsentProvisionDataListEnumerator.Create(list : TFhirConsentProvisionDataList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConsentProvisionDataListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConsentProvisionDataListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConsentProvisionDataListEnumerator.GetCurrent : TFhirConsentProvisionData;
begin
  Result := FList[FIndex];
end;

function TFhirConsentProvisionDataListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirConsentProvisionDataList }

function TFhirConsentProvisionDataList.AddItem(value: TFhirConsentProvisionData): TFhirConsentProvisionData;
begin
  assert(value.ClassName = 'TFhirConsentProvisionData', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConsentProvisionData');
  add(value);
  result := value;
end;

function TFhirConsentProvisionDataList.Append: TFhirConsentProvisionData;
begin
  result := TFhirConsentProvisionData.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentProvisionDataList.ClearItems;
begin
  Clear;
end;

function TFhirConsentProvisionDataList.GetEnumerator : TFhirConsentProvisionDataListEnumerator;
begin
  result := TFhirConsentProvisionDataListEnumerator.Create(self.link);
end;

function TFhirConsentProvisionDataList.Clone: TFhirConsentProvisionDataList;
begin
  result := TFhirConsentProvisionDataList(inherited Clone);
end;

function TFhirConsentProvisionDataList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConsentProvisionDataList.GetItemN(index: Integer): TFhirConsentProvisionData;
begin
  result := TFhirConsentProvisionData(ObjectByIndex[index]);
end;

function TFhirConsentProvisionDataList.ItemClass: TFslObjectClass;
begin
  result := TFhirConsentProvisionData;
end;
function TFhirConsentProvisionDataList.IndexOf(value: TFhirConsentProvisionData): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConsentProvisionDataList.Insert(index: Integer): TFhirConsentProvisionData;
begin
  result := TFhirConsentProvisionData.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentProvisionDataList.InsertItem(index: Integer; value: TFhirConsentProvisionData);
begin
  assert(value is TFhirConsentProvisionData);
  Inherited Insert(index, value);
end;

function TFhirConsentProvisionDataList.Item(index: Integer): TFhirConsentProvisionData;
begin
  result := TFhirConsentProvisionData(ObjectByIndex[index]);
end;

function TFhirConsentProvisionDataList.Link: TFhirConsentProvisionDataList;
begin
  result := TFhirConsentProvisionDataList(inherited Link);
end;

procedure TFhirConsentProvisionDataList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConsentProvisionDataList.SetItemByIndex(index: Integer; value: TFhirConsentProvisionData);
begin
  assert(value is TFhirConsentProvisionData);
  FhirConsentProvisionData[index] := value;
end;

procedure TFhirConsentProvisionDataList.SetItemN(index: Integer; value: TFhirConsentProvisionData);
begin
  assert(value is TFhirConsentProvisionData);
  ObjectByIndex[index] := value;
end;

{ TFhirConsent }

constructor TFhirConsent.Create;
begin
  inherited;
end;

destructor TFhirConsent.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCategoryList.Free;
  FSubject.free;
  FDateTime.free;
  FGrantorList.Free;
  FGranteeList.Free;
  FManagerList.Free;
  FControllerList.Free;
  FSourceAttachmentList.Free;
  FSourceReferenceList.Free;
  FRegulatoryBasisList.Free;
  FPolicyBasis.free;
  FPolicyTextList.Free;
  FVerificationList.Free;
  FProvision.free;
  inherited;
end;

procedure TFhirConsent.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirConsent(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirConsent(oSource).FIdentifierList);
  end;
  statusElement := TFhirConsent(oSource).statusElement.Clone;
  if (TFhirConsent(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirConsent(oSource).FCategoryList);
  end;
  subject := TFhirConsent(oSource).subject.Clone;
  dateTimeElement := TFhirConsent(oSource).dateTimeElement.Clone;
  if (TFhirConsent(oSource).FGrantorList = nil) then
  begin
    FGrantorList.free;
    FGrantorList := nil;
  end
  else
  begin
    if FGrantorList = nil then
      FGrantorList := TFhirReferenceList.Create;
    FGrantorList.Assign(TFhirConsent(oSource).FGrantorList);
  end;
  if (TFhirConsent(oSource).FGranteeList = nil) then
  begin
    FGranteeList.free;
    FGranteeList := nil;
  end
  else
  begin
    if FGranteeList = nil then
      FGranteeList := TFhirReferenceList.Create;
    FGranteeList.Assign(TFhirConsent(oSource).FGranteeList);
  end;
  if (TFhirConsent(oSource).FManagerList = nil) then
  begin
    FManagerList.free;
    FManagerList := nil;
  end
  else
  begin
    if FManagerList = nil then
      FManagerList := TFhirReferenceList.Create;
    FManagerList.Assign(TFhirConsent(oSource).FManagerList);
  end;
  if (TFhirConsent(oSource).FControllerList = nil) then
  begin
    FControllerList.free;
    FControllerList := nil;
  end
  else
  begin
    if FControllerList = nil then
      FControllerList := TFhirReferenceList.Create;
    FControllerList.Assign(TFhirConsent(oSource).FControllerList);
  end;
  if (TFhirConsent(oSource).FSourceAttachmentList = nil) then
  begin
    FSourceAttachmentList.free;
    FSourceAttachmentList := nil;
  end
  else
  begin
    if FSourceAttachmentList = nil then
      FSourceAttachmentList := TFhirAttachmentList.Create;
    FSourceAttachmentList.Assign(TFhirConsent(oSource).FSourceAttachmentList);
  end;
  if (TFhirConsent(oSource).FSourceReferenceList = nil) then
  begin
    FSourceReferenceList.free;
    FSourceReferenceList := nil;
  end
  else
  begin
    if FSourceReferenceList = nil then
      FSourceReferenceList := TFhirReferenceList.Create;
    FSourceReferenceList.Assign(TFhirConsent(oSource).FSourceReferenceList);
  end;
  if (TFhirConsent(oSource).FRegulatoryBasisList = nil) then
  begin
    FRegulatoryBasisList.free;
    FRegulatoryBasisList := nil;
  end
  else
  begin
    if FRegulatoryBasisList = nil then
      FRegulatoryBasisList := TFhirCodeableConceptList.Create;
    FRegulatoryBasisList.Assign(TFhirConsent(oSource).FRegulatoryBasisList);
  end;
  policyBasis := TFhirConsent(oSource).policyBasis.Clone;
  if (TFhirConsent(oSource).FPolicyTextList = nil) then
  begin
    FPolicyTextList.free;
    FPolicyTextList := nil;
  end
  else
  begin
    if FPolicyTextList = nil then
      FPolicyTextList := TFhirReferenceList.Create;
    FPolicyTextList.Assign(TFhirConsent(oSource).FPolicyTextList);
  end;
  if (TFhirConsent(oSource).FVerificationList = nil) then
  begin
    FVerificationList.free;
    FVerificationList := nil;
  end
  else
  begin
    if FVerificationList = nil then
      FVerificationList := TFhirConsentVerificationList.Create;
    FVerificationList.Assign(TFhirConsent(oSource).FVerificationList);
  end;
  provision := TFhirConsent(oSource).provision.Clone;
end;

function TFhirConsent.GetResourceType : TFhirResourceType;
begin
  result := frtConsent;
end;

procedure TFhirConsent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'dateTime') Then
     list.add(self.link, 'dateTime', FDateTime.Link);
  if (child_name = 'grantor') Then
    list.addAll(self, 'grantor', FGrantorList);
  if (child_name = 'grantee') Then
    list.addAll(self, 'grantee', FGranteeList);
  if (child_name = 'manager') Then
    list.addAll(self, 'manager', FManagerList);
  if (child_name = 'controller') Then
    list.addAll(self, 'controller', FControllerList);
  if (child_name = 'sourceAttachment') Then
    list.addAll(self, 'sourceAttachment', FSourceAttachmentList);
  if (child_name = 'sourceReference') Then
    list.addAll(self, 'sourceReference', FSourceReferenceList);
  if (child_name = 'regulatoryBasis') Then
    list.addAll(self, 'regulatoryBasis', FRegulatoryBasisList);
  if (child_name = 'policyBasis') Then
     list.add(self.link, 'policyBasis', FPolicyBasis.Link);
  if (child_name = 'policyText') Then
    list.addAll(self, 'policyText', FPolicyTextList);
  if (child_name = 'verification') Then
    list.addAll(self, 'verification', FVerificationList);
  if (child_name = 'provision') Then
     list.add(self.link, 'provision', FProvision.Link);
end;

procedure TFhirConsent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'dateTime', 'dateTime', false, TFhirDateTime, FDateTime.Link));
  oList.add(TFHIRProperty.create(self, 'grantor', 'Reference', true, TFhirReference, FGrantorList.Link));
  oList.add(TFHIRProperty.create(self, 'grantee', 'Reference', true, TFhirReference, FGranteeList.Link));
  oList.add(TFHIRProperty.create(self, 'manager', 'Reference', true, TFhirReference, FManagerList.Link));
  oList.add(TFHIRProperty.create(self, 'controller', 'Reference', true, TFhirReference, FControllerList.Link));
  oList.add(TFHIRProperty.create(self, 'sourceAttachment', 'Attachment', true, TFhirAttachment, FSourceAttachmentList.Link));
  oList.add(TFHIRProperty.create(self, 'sourceReference', 'Reference', true, TFhirReference, FSourceReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'regulatoryBasis', 'CodeableConcept', true, TFhirCodeableConcept, FRegulatoryBasisList.Link));
  oList.add(TFHIRProperty.create(self, 'policyBasis', 'BackboneElement', false, TFhirConsentPolicyBasis, FPolicyBasis.Link));
  oList.add(TFHIRProperty.create(self, 'policyText', 'Reference', true, TFhirReference, FPolicyTextList.Link));
  oList.add(TFHIRProperty.create(self, 'verification', 'BackboneElement', true, TFhirConsentVerification, FVerificationList.Link));
  oList.add(TFHIRProperty.create(self, 'provision', 'BackboneElement', false, TFhirConsentProvision, FProvision.Link));
end;

function TFhirConsent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirConsentStateEnum, CODES_TFhirConsentStateEnum, propValue);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'dateTime') then
  begin
    DateTimeElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'grantor') then
  begin
    GrantorList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'grantee') then
  begin
    GranteeList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'manager') then
  begin
    ManagerList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'controller') then
  begin
    ControllerList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'sourceAttachment') then
  begin
    SourceAttachmentList.add(propValue as TFhirAttachment);
    result := propValue;
  end
  else if (propName = 'sourceReference') then
  begin
    SourceReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'regulatoryBasis') then
  begin
    RegulatoryBasisList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'policyBasis') then
  begin
    PolicyBasis := propValue as TFhirConsentPolicyBasis;
    result := propValue;
  end
  else if (propName = 'policyText') then
  begin
    PolicyTextList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'verification') then
  begin
    VerificationList.add(propValue as TFhirConsentVerification);
    result := propValue;
  end
  else if (propName = 'provision') then
  begin
    Provision := propValue as TFhirConsentProvision;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConsent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'grantor') then GrantorList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'grantee') then GranteeList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'manager') then ManagerList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'controller') then ControllerList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'sourceAttachment') then SourceAttachmentList.insertItem(index, propValue as TFhirAttachment)
  else if (propName = 'sourceReference') then SourceReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'regulatoryBasis') then RegulatoryBasisList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'policyText') then PolicyTextList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'verification') then VerificationList.insertItem(index, propValue as TFhirConsentVerification)
  else inherited;
end;

function TFhirConsent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirConsentStateEnum[ConsentStateNull], CODES_TFhirConsentStateEnum[ConsentStateNull]) 
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'dateTime') then result := TFhirDateTime.create()
  else if (propName = 'grantor') then result := GrantorList.new()
  else if (propName = 'grantee') then result := GranteeList.new()
  else if (propName = 'manager') then result := ManagerList.new()
  else if (propName = 'controller') then result := ControllerList.new()
  else if (propName = 'sourceAttachment') then result := SourceAttachmentList.new()
  else if (propName = 'sourceReference') then result := SourceReferenceList.new()
  else if (propName = 'regulatoryBasis') then result := RegulatoryBasisList.new()
  else if (propName = 'policyBasis') then result := TFhirConsentPolicyBasis.create()
  else if (propName = 'policyText') then result := PolicyTextList.new()
  else if (propName = 'verification') then result := VerificationList.new()
  else if (propName = 'provision') then result := TFhirConsentProvision.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirConsent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'dateTime') then result := 'dateTime'
  else if (propName = 'grantor') then result := 'Reference'
  else if (propName = 'grantee') then result := 'Reference'
  else if (propName = 'manager') then result := 'Reference'
  else if (propName = 'controller') then result := 'Reference'
  else if (propName = 'sourceAttachment') then result := 'Attachment'
  else if (propName = 'sourceReference') then result := 'Reference'
  else if (propName = 'regulatoryBasis') then result := 'CodeableConcept'
  else if (propName = 'policyBasis') then result := 'BackboneElement'
  else if (propName = 'policyText') then result := 'Reference'
  else if (propName = 'verification') then result := 'BackboneElement'
  else if (propName = 'provision') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConsent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'dateTime') then DateTimeElement := nil
  else if (propName = 'grantor') then deletePropertyValue('grantor', GrantorList, value)
  else if (propName = 'grantee') then deletePropertyValue('grantee', GranteeList, value)
  else if (propName = 'manager') then deletePropertyValue('manager', ManagerList, value)
  else if (propName = 'controller') then deletePropertyValue('controller', ControllerList, value)
  else if (propName = 'sourceAttachment') then deletePropertyValue('sourceAttachment', SourceAttachmentList, value)
  else if (propName = 'sourceReference') then deletePropertyValue('sourceReference', SourceReferenceList, value)
  else if (propName = 'regulatoryBasis') then deletePropertyValue('regulatoryBasis', RegulatoryBasisList, value)
  else if (propName = 'policyBasis') then PolicyBasisElement := nil
  else if (propName = 'policyText') then deletePropertyValue('policyText', PolicyTextList, value)
  else if (propName = 'verification') then deletePropertyValue('verification', VerificationList, value)
  else if (propName = 'provision') then ProvisionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConsent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirConsentStateEnum, CODES_TFhirConsentStateEnum, new)
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'dateTime') then DateTimeElement := asDateTime(new)
  else if (propName = 'grantor') then replacePropertyValue('grantor', GrantorList, existing, new)
  else if (propName = 'grantee') then replacePropertyValue('grantee', GranteeList, existing, new)
  else if (propName = 'manager') then replacePropertyValue('manager', ManagerList, existing, new)
  else if (propName = 'controller') then replacePropertyValue('controller', ControllerList, existing, new)
  else if (propName = 'sourceAttachment') then replacePropertyValue('sourceAttachment', SourceAttachmentList, existing, new)
  else if (propName = 'sourceReference') then replacePropertyValue('sourceReference', SourceReferenceList, existing, new)
  else if (propName = 'regulatoryBasis') then replacePropertyValue('regulatoryBasis', RegulatoryBasisList, existing, new)
  else if (propName = 'policyBasis') then PolicyBasisElement := new as TFhirConsentPolicyBasis
  else if (propName = 'policyText') then replacePropertyValue('policyText', PolicyTextList, existing, new)
  else if (propName = 'verification') then replacePropertyValue('verification', VerificationList, existing, new)
  else if (propName = 'provision') then ProvisionElement := new as TFhirConsentProvision
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConsent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'grantor') then GrantorList.move(source, destination)
  else if (propName = 'grantee') then GranteeList.move(source, destination)
  else if (propName = 'manager') then ManagerList.move(source, destination)
  else if (propName = 'controller') then ControllerList.move(source, destination)
  else if (propName = 'sourceAttachment') then SourceAttachmentList.move(source, destination)
  else if (propName = 'sourceReference') then SourceReferenceList.move(source, destination)
  else if (propName = 'regulatoryBasis') then RegulatoryBasisList.move(source, destination)
  else if (propName = 'policyText') then PolicyTextList.move(source, destination)
  else if (propName = 'verification') then VerificationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConsent.fhirType : string;
begin
  result := 'Consent';
end;

function TFhirConsent.Link : TFhirConsent;
begin
  result := TFhirConsent(inherited Link);
end;

function TFhirConsent.Clone : TFhirConsent;
begin
  result := TFhirConsent(inherited Clone);
end;

function TFhirConsent.equals(other : TObject) : boolean; 
var
  o : TFhirConsent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConsent)) then
    result := false
  else
  begin
    o := TFhirConsent(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(dateTimeElement, o.dateTimeElement, true) and compareDeep(grantorList, o.grantorList, true) and 
      compareDeep(granteeList, o.granteeList, true) and compareDeep(managerList, o.managerList, true) and 
      compareDeep(controllerList, o.controllerList, true) and compareDeep(sourceAttachmentList, o.sourceAttachmentList, true) and 
      compareDeep(sourceReferenceList, o.sourceReferenceList, true) and compareDeep(regulatoryBasisList, o.regulatoryBasisList, true) and 
      compareDeep(policyBasisElement, o.policyBasisElement, true) and compareDeep(policyTextList, o.policyTextList, true) and 
      compareDeep(verificationList, o.verificationList, true) and compareDeep(provisionElement, o.provisionElement, true);
  end;
end;

function TFhirConsent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FSubject) and isEmptyProp(FDateTime) and isEmptyProp(FgrantorList) and isEmptyProp(FgranteeList) and isEmptyProp(FmanagerList) and isEmptyProp(FcontrollerList) and isEmptyProp(FsourceAttachmentList) and isEmptyProp(FsourceReferenceList) and isEmptyProp(FregulatoryBasisList) and isEmptyProp(FPolicyBasis) and isEmptyProp(FpolicyTextList) and isEmptyProp(FverificationList) and isEmptyProp(FProvision);
end;

procedure TFhirConsent.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('category');
  fields.add('subject');
  fields.add('dateTime');
  fields.add('grantor');
  fields.add('grantee');
  fields.add('manager');
  fields.add('controller');
  fields.add('sourceAttachment');
  fields.add('sourceReference');
  fields.add('regulatoryBasis');
  fields.add('policyBasis');
  fields.add('policyText');
  fields.add('verification');
  fields.add('provision');
end;

function TFhirConsent.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FGrantorList.sizeInBytes(magic));
  inc(result, FGranteeList.sizeInBytes(magic));
  inc(result, FManagerList.sizeInBytes(magic));
  inc(result, FControllerList.sizeInBytes(magic));
  inc(result, FSourceAttachmentList.sizeInBytes(magic));
  inc(result, FSourceReferenceList.sizeInBytes(magic));
  inc(result, FRegulatoryBasisList.sizeInBytes(magic));
  inc(result, FPolicyTextList.sizeInBytes(magic));
  inc(result, FVerificationList.sizeInBytes(magic));
end;

function TFhirConsent.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirConsent.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirConsent.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirConsent.GetStatusST : TFhirConsentStateEnum;
begin
  if FStatus = nil then
    result := TFhirConsentStateEnum(0)
  else
    result := TFhirConsentStateEnum(StringArrayIndexOfSensitive(CODES_TFhirConsentStateEnum, FStatus.value));
end;

procedure TFhirConsent.SetStatusST(value : TFhirConsentStateEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirConsentStateEnum[value], CODES_TFhirConsentStateEnum[value]);
end;

function TFhirConsent.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirConsent.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirConsent.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirConsent.SetDateTime(value : TFhirDateTime);
begin
  FDateTime.free;
  FDateTime := value;
end;

function TFhirConsent.GetDateTimeST : TFslDateTime;
begin
  if FDateTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateTime.value;
end;

procedure TFhirConsent.SetDateTimeST(value : TFslDateTime);
begin
  if FDateTime = nil then
    FDateTime := TFhirDateTime.create;
  FDateTime.value := value
end;

function TFhirConsent.GetGrantorList : TFhirReferenceList;
begin
  if FGrantorList = nil then
    FGrantorList := TFhirReferenceList.Create;
  result := FGrantorList;
end;

function TFhirConsent.GetHasGrantorList : boolean;
begin
  result := (FGrantorList <> nil) and (FGrantorList.count > 0);
end;

function TFhirConsent.GetGranteeList : TFhirReferenceList;
begin
  if FGranteeList = nil then
    FGranteeList := TFhirReferenceList.Create;
  result := FGranteeList;
end;

function TFhirConsent.GetHasGranteeList : boolean;
begin
  result := (FGranteeList <> nil) and (FGranteeList.count > 0);
end;

function TFhirConsent.GetManagerList : TFhirReferenceList;
begin
  if FManagerList = nil then
    FManagerList := TFhirReferenceList.Create;
  result := FManagerList;
end;

function TFhirConsent.GetHasManagerList : boolean;
begin
  result := (FManagerList <> nil) and (FManagerList.count > 0);
end;

function TFhirConsent.GetControllerList : TFhirReferenceList;
begin
  if FControllerList = nil then
    FControllerList := TFhirReferenceList.Create;
  result := FControllerList;
end;

function TFhirConsent.GetHasControllerList : boolean;
begin
  result := (FControllerList <> nil) and (FControllerList.count > 0);
end;

function TFhirConsent.GetSourceAttachmentList : TFhirAttachmentList;
begin
  if FSourceAttachmentList = nil then
    FSourceAttachmentList := TFhirAttachmentList.Create;
  result := FSourceAttachmentList;
end;

function TFhirConsent.GetHasSourceAttachmentList : boolean;
begin
  result := (FSourceAttachmentList <> nil) and (FSourceAttachmentList.count > 0);
end;

function TFhirConsent.GetSourceReferenceList : TFhirReferenceList;
begin
  if FSourceReferenceList = nil then
    FSourceReferenceList := TFhirReferenceList.Create;
  result := FSourceReferenceList;
end;

function TFhirConsent.GetHasSourceReferenceList : boolean;
begin
  result := (FSourceReferenceList <> nil) and (FSourceReferenceList.count > 0);
end;

function TFhirConsent.GetRegulatoryBasisList : TFhirCodeableConceptList;
begin
  if FRegulatoryBasisList = nil then
    FRegulatoryBasisList := TFhirCodeableConceptList.Create;
  result := FRegulatoryBasisList;
end;

function TFhirConsent.GetHasRegulatoryBasisList : boolean;
begin
  result := (FRegulatoryBasisList <> nil) and (FRegulatoryBasisList.count > 0);
end;

procedure TFhirConsent.SetPolicyBasis(value : TFhirConsentPolicyBasis);
begin
  FPolicyBasis.free;
  FPolicyBasis := value;
end;

function TFhirConsent.GetPolicyTextList : TFhirReferenceList;
begin
  if FPolicyTextList = nil then
    FPolicyTextList := TFhirReferenceList.Create;
  result := FPolicyTextList;
end;

function TFhirConsent.GetHasPolicyTextList : boolean;
begin
  result := (FPolicyTextList <> nil) and (FPolicyTextList.count > 0);
end;

function TFhirConsent.GetVerificationList : TFhirConsentVerificationList;
begin
  if FVerificationList = nil then
    FVerificationList := TFhirConsentVerificationList.Create;
  result := FVerificationList;
end;

function TFhirConsent.GetHasVerificationList : boolean;
begin
  result := (FVerificationList <> nil) and (FVerificationList.count > 0);
end;

procedure TFhirConsent.SetProvision(value : TFhirConsentProvision);
begin
  FProvision.free;
  FProvision := value;
end;

{ TFhirConsentListEnumerator }

constructor TFhirConsentListEnumerator.Create(list : TFhirConsentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConsentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConsentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConsentListEnumerator.GetCurrent : TFhirConsent;
begin
  Result := FList[FIndex];
end;

function TFhirConsentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirConsentList }

function TFhirConsentList.AddItem(value: TFhirConsent): TFhirConsent;
begin
  assert(value.ClassName = 'TFhirConsent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConsent');
  add(value);
  result := value;
end;

function TFhirConsentList.Append: TFhirConsent;
begin
  result := TFhirConsent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentList.ClearItems;
begin
  Clear;
end;

function TFhirConsentList.GetEnumerator : TFhirConsentListEnumerator;
begin
  result := TFhirConsentListEnumerator.Create(self.link);
end;

function TFhirConsentList.Clone: TFhirConsentList;
begin
  result := TFhirConsentList(inherited Clone);
end;

function TFhirConsentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConsentList.GetItemN(index: Integer): TFhirConsent;
begin
  result := TFhirConsent(ObjectByIndex[index]);
end;

function TFhirConsentList.ItemClass: TFslObjectClass;
begin
  result := TFhirConsent;
end;
function TFhirConsentList.IndexOf(value: TFhirConsent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConsentList.Insert(index: Integer): TFhirConsent;
begin
  result := TFhirConsent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentList.InsertItem(index: Integer; value: TFhirConsent);
begin
  assert(value is TFhirConsent);
  Inherited Insert(index, value);
end;

function TFhirConsentList.Item(index: Integer): TFhirConsent;
begin
  result := TFhirConsent(ObjectByIndex[index]);
end;

function TFhirConsentList.Link: TFhirConsentList;
begin
  result := TFhirConsentList(inherited Link);
end;

procedure TFhirConsentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConsentList.SetItemByIndex(index: Integer; value: TFhirConsent);
begin
  assert(value is TFhirConsent);
  FhirConsents[index] := value;
end;

procedure TFhirConsentList.SetItemN(index: Integer; value: TFhirConsent);
begin
  assert(value is TFhirConsent);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
{ TFhirContractContentDefinition }

constructor TFhirContractContentDefinition.Create;
begin
  inherited;
end;

destructor TFhirContractContentDefinition.Destroy;
begin
  FType_.free;
  FSubType.free;
  FPublisher.free;
  FPublicationDate.free;
  FPublicationStatus.free;
  FCopyright.free;
  inherited;
end;

procedure TFhirContractContentDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirContractContentDefinition(oSource).type_.Clone;
  subType := TFhirContractContentDefinition(oSource).subType.Clone;
  publisher := TFhirContractContentDefinition(oSource).publisher.Clone;
  publicationDateElement := TFhirContractContentDefinition(oSource).publicationDateElement.Clone;
  publicationStatusElement := TFhirContractContentDefinition(oSource).publicationStatusElement.Clone;
  copyrightElement := TFhirContractContentDefinition(oSource).copyrightElement.Clone;
end;

procedure TFhirContractContentDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subType') Then
     list.add(self.link, 'subType', FSubType.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'publicationDate') Then
     list.add(self.link, 'publicationDate', FPublicationDate.Link);
  if (child_name = 'publicationStatus') Then
     list.add(self.link, 'publicationStatus', FPublicationStatus.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
end;

procedure TFhirContractContentDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'subType', 'CodeableConcept', false, TFhirCodeableConcept, FSubType.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'Reference', false, TFhirReference, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'publicationDate', 'dateTime', false, TFhirDateTime, FPublicationDate.Link));
  oList.add(TFHIRProperty.create(self, 'publicationStatus', 'code', false, TFhirEnum, FPublicationStatus.Link));
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));
end;

function TFhirContractContentDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subType') then
  begin
    SubType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    Publisher := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'publicationDate') then
  begin
    PublicationDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publicationStatus') then
  begin
    PublicationStatusElement := asEnum(SYSTEMS_TFhirContractResourcePublicationStatusCodesEnum, CODES_TFhirContractResourcePublicationStatusCodesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractContentDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractContentDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'subType') then result := TFhirCodeableConcept.create()
  else if (propName = 'publisher') then result := TFhirReference.create()
  else if (propName = 'publicationDate') then result := TFhirDateTime.create()
  else if (propName = 'publicationStatus') then result := TFhirEnum.create(SYSTEMS_TFhirContractResourcePublicationStatusCodesEnum[ContractResourcePublicationStatusCodesNull], CODES_TFhirContractResourcePublicationStatusCodesEnum[ContractResourcePublicationStatusCodesNull]) 
  else if (propName = 'copyright') then result := TFhirMarkdown.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractContentDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subType') then result := 'CodeableConcept'
  else if (propName = 'publisher') then result := 'Reference'
  else if (propName = 'publicationDate') then result := 'dateTime'
  else if (propName = 'publicationStatus') then result := 'code'
  else if (propName = 'copyright') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractContentDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'subType') then SubTypeElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'publicationDate') then PublicationDateElement := nil
  else if (propName = 'publicationStatus') then PublicationStatusElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractContentDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'subType') then SubTypeElement := new as TFhirCodeableConcept
  else if (propName = 'publisher') then PublisherElement := new as TFhirReference
  else if (propName = 'publicationDate') then PublicationDateElement := asDateTime(new)
  else if (propName = 'publicationStatus') then PublicationStatusElement := asEnum(SYSTEMS_TFhirContractResourcePublicationStatusCodesEnum, CODES_TFhirContractResourcePublicationStatusCodesEnum, new)
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractContentDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractContentDefinition.fhirType : string;
begin
  result := 'Contract.contentDefinition';
end;

function TFhirContractContentDefinition.Link : TFhirContractContentDefinition;
begin
  result := TFhirContractContentDefinition(inherited Link);
end;

function TFhirContractContentDefinition.Clone : TFhirContractContentDefinition;
begin
  result := TFhirContractContentDefinition(inherited Clone);
end;

function TFhirContractContentDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirContractContentDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractContentDefinition)) then
    result := false
  else
  begin
    o := TFhirContractContentDefinition(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(subTypeElement, o.subTypeElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(publicationDateElement, o.publicationDateElement, true) and 
      compareDeep(publicationStatusElement, o.publicationStatusElement, true) and compareDeep(copyrightElement, o.copyrightElement, true);
  end;
end;

function TFhirContractContentDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FSubType) and isEmptyProp(FPublisher) and isEmptyProp(FPublicationDate) and isEmptyProp(FPublicationStatus) and isEmptyProp(FCopyright);
end;

procedure TFhirContractContentDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('subType');
  fields.add('publisher');
  fields.add('publicationDate');
  fields.add('publicationStatus');
  fields.add('copyright');
end;

function TFhirContractContentDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirContractContentDefinition.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirContractContentDefinition.SetSubType(value : TFhirCodeableConcept);
begin
  FSubType.free;
  FSubType := value;
end;

procedure TFhirContractContentDefinition.SetPublisher(value : TFhirReference);
begin
  FPublisher.free;
  FPublisher := value;
end;

procedure TFhirContractContentDefinition.SetPublicationDate(value : TFhirDateTime);
begin
  FPublicationDate.free;
  FPublicationDate := value;
end;

function TFhirContractContentDefinition.GetPublicationDateST : TFslDateTime;
begin
  if FPublicationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FPublicationDate.value;
end;

procedure TFhirContractContentDefinition.SetPublicationDateST(value : TFslDateTime);
begin
  if FPublicationDate = nil then
    FPublicationDate := TFhirDateTime.create;
  FPublicationDate.value := value
end;

procedure TFhirContractContentDefinition.SetPublicationStatus(value : TFhirEnum);
begin
  FPublicationStatus.free;
  FPublicationStatus := value;
end;

function TFhirContractContentDefinition.GetPublicationStatusST : TFhirContractResourcePublicationStatusCodesEnum;
begin
  if FPublicationStatus = nil then
    result := TFhirContractResourcePublicationStatusCodesEnum(0)
  else
    result := TFhirContractResourcePublicationStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirContractResourcePublicationStatusCodesEnum, FPublicationStatus.value));
end;

procedure TFhirContractContentDefinition.SetPublicationStatusST(value : TFhirContractResourcePublicationStatusCodesEnum);
begin
  if ord(value) = 0 then
    PublicationStatusElement := nil
  else
    PublicationStatusElement := TFhirEnum.create(SYSTEMS_TFhirContractResourcePublicationStatusCodesEnum[value], CODES_TFhirContractResourcePublicationStatusCodesEnum[value]);
end;

procedure TFhirContractContentDefinition.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirContractContentDefinition.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirContractContentDefinition.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

{ TFhirContractContentDefinitionListEnumerator }

constructor TFhirContractContentDefinitionListEnumerator.Create(list : TFhirContractContentDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractContentDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractContentDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractContentDefinitionListEnumerator.GetCurrent : TFhirContractContentDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirContractContentDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractContentDefinitionList }

function TFhirContractContentDefinitionList.AddItem(value: TFhirContractContentDefinition): TFhirContractContentDefinition;
begin
  assert(value.ClassName = 'TFhirContractContentDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractContentDefinition');
  add(value);
  result := value;
end;

function TFhirContractContentDefinitionList.Append: TFhirContractContentDefinition;
begin
  result := TFhirContractContentDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractContentDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirContractContentDefinitionList.GetEnumerator : TFhirContractContentDefinitionListEnumerator;
begin
  result := TFhirContractContentDefinitionListEnumerator.Create(self.link);
end;

function TFhirContractContentDefinitionList.Clone: TFhirContractContentDefinitionList;
begin
  result := TFhirContractContentDefinitionList(inherited Clone);
end;

function TFhirContractContentDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractContentDefinitionList.GetItemN(index: Integer): TFhirContractContentDefinition;
begin
  result := TFhirContractContentDefinition(ObjectByIndex[index]);
end;

function TFhirContractContentDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractContentDefinition;
end;
function TFhirContractContentDefinitionList.IndexOf(value: TFhirContractContentDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractContentDefinitionList.Insert(index: Integer): TFhirContractContentDefinition;
begin
  result := TFhirContractContentDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractContentDefinitionList.InsertItem(index: Integer; value: TFhirContractContentDefinition);
begin
  assert(value is TFhirContractContentDefinition);
  Inherited Insert(index, value);
end;

function TFhirContractContentDefinitionList.Item(index: Integer): TFhirContractContentDefinition;
begin
  result := TFhirContractContentDefinition(ObjectByIndex[index]);
end;

function TFhirContractContentDefinitionList.Link: TFhirContractContentDefinitionList;
begin
  result := TFhirContractContentDefinitionList(inherited Link);
end;

procedure TFhirContractContentDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractContentDefinitionList.SetItemByIndex(index: Integer; value: TFhirContractContentDefinition);
begin
  assert(value is TFhirContractContentDefinition);
  FhirContractContentDefinitions[index] := value;
end;

procedure TFhirContractContentDefinitionList.SetItemN(index: Integer; value: TFhirContractContentDefinition);
begin
  assert(value is TFhirContractContentDefinition);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTerm }

constructor TFhirContractTerm.Create;
begin
  inherited;
end;

destructor TFhirContractTerm.Destroy;
begin
  FIdentifier.free;
  FIssued.free;
  FApplies.free;
  FTopic.free;
  FType_.free;
  FSubType.free;
  FText.free;
  FSecurityLabelList.Free;
  FOffer.free;
  FAssetList.Free;
  FActionList.Free;
  FGroupList.Free;
  inherited;
end;

procedure TFhirContractTerm.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirContractTerm(oSource).identifier.Clone;
  issuedElement := TFhirContractTerm(oSource).issuedElement.Clone;
  applies := TFhirContractTerm(oSource).applies.Clone;
  topic := TFhirContractTerm(oSource).topic.Clone;
  type_ := TFhirContractTerm(oSource).type_.Clone;
  subType := TFhirContractTerm(oSource).subType.Clone;
  textElement := TFhirContractTerm(oSource).textElement.Clone;
  if (TFhirContractTerm(oSource).FSecurityLabelList = nil) then
  begin
    FSecurityLabelList.free;
    FSecurityLabelList := nil;
  end
  else
  begin
    if FSecurityLabelList = nil then
      FSecurityLabelList := TFhirContractTermSecurityLabelList.Create;
    FSecurityLabelList.Assign(TFhirContractTerm(oSource).FSecurityLabelList);
  end;
  offer := TFhirContractTerm(oSource).offer.Clone;
  if (TFhirContractTerm(oSource).FAssetList = nil) then
  begin
    FAssetList.free;
    FAssetList := nil;
  end
  else
  begin
    if FAssetList = nil then
      FAssetList := TFhirContractTermAssetList.Create;
    FAssetList.Assign(TFhirContractTerm(oSource).FAssetList);
  end;
  if (TFhirContractTerm(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirContractTermActionList.Create;
    FActionList.Assign(TFhirContractTerm(oSource).FActionList);
  end;
  if (TFhirContractTerm(oSource).FGroupList = nil) then
  begin
    FGroupList.free;
    FGroupList := nil;
  end
  else
  begin
    if FGroupList = nil then
      FGroupList := TFhirContractTermList.Create;
    FGroupList.Assign(TFhirContractTerm(oSource).FGroupList);
  end;
end;

procedure TFhirContractTerm.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'issued') Then
     list.add(self.link, 'issued', FIssued.Link);
  if (child_name = 'applies') Then
     list.add(self.link, 'applies', FApplies.Link);
  if (child_name = 'topic[x]') or (child_name = 'topic') Then
     list.add(self.link, 'topic[x]', FTopic.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subType') Then
     list.add(self.link, 'subType', FSubType.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'securityLabel') Then
    list.addAll(self, 'securityLabel', FSecurityLabelList);
  if (child_name = 'offer') Then
     list.add(self.link, 'offer', FOffer.Link);
  if (child_name = 'asset') Then
    list.addAll(self, 'asset', FAssetList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
  if (child_name = 'group') Then
    list.addAll(self, 'group', FGroupList);
end;

procedure TFhirContractTerm.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'issued', 'dateTime', false, TFhirDateTime, FIssued.Link));
  oList.add(TFHIRProperty.create(self, 'applies', 'Period', false, TFhirPeriod, FApplies.Link));
  oList.add(TFHIRProperty.create(self, 'topic[x]', 'CodeableConcept|Reference', false, TFhirDataType, FTopic.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'subType', 'CodeableConcept', false, TFhirCodeableConcept, FSubType.Link));
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));
  oList.add(TFHIRProperty.create(self, 'securityLabel', 'BackboneElement', true, TFhirContractTermSecurityLabel, FSecurityLabelList.Link));
  oList.add(TFHIRProperty.create(self, 'offer', 'BackboneElement', false, TFhirContractTermOffer, FOffer.Link));
  oList.add(TFHIRProperty.create(self, 'asset', 'BackboneElement', true, TFhirContractTermAsset, FAssetList.Link));
  oList.add(TFHIRProperty.create(self, 'action', 'BackboneElement', true, TFhirContractTermAction, FActionList.Link));
  oList.add(TFHIRProperty.create(self, 'group', '', true, TFhirContractTerm, FGroupList.Link));
end;

function TFhirContractTerm.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'issued') then
  begin
    IssuedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'applies') then
  begin
    Applies := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (isMatchingName(propName, 'topic', ['CodeableConcept', 'Reference'])) then
  begin
    Topic := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subType') then
  begin
    SubType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'securityLabel') then
  begin
    SecurityLabelList.add(propValue as TFhirContractTermSecurityLabel);
    result := propValue;
  end
  else if (propName = 'offer') then
  begin
    Offer := propValue as TFhirContractTermOffer;
    result := propValue;
  end
  else if (propName = 'asset') then
  begin
    AssetList.add(propValue as TFhirContractTermAsset);
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirContractTermAction);
    result := propValue;
  end
  else if (propName = 'group') then
  begin
    GroupList.add(propValue as TFhirContractTerm);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTerm.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'securityLabel') then SecurityLabelList.insertItem(index, propValue as TFhirContractTermSecurityLabel)
  else if (propName = 'asset') then AssetList.insertItem(index, propValue as TFhirContractTermAsset)
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirContractTermAction)
  else if (propName = 'group') then GroupList.insertItem(index, propValue as TFhirContractTerm)
  else inherited;
end;

function TFhirContractTerm.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'issued') then result := TFhirDateTime.create()
  else if (propName = 'applies') then result := TFhirPeriod.create()
  else if (isMatchingName(propName, 'topic', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Topic')
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'subType') then result := TFhirCodeableConcept.create()
  else if (propName = 'text') then result := TFhirString.create()
  else if (propName = 'securityLabel') then result := SecurityLabelList.new()
  else if (propName = 'offer') then result := TFhirContractTermOffer.create()
  else if (propName = 'asset') then result := AssetList.new()
  else if (propName = 'action') then result := ActionList.new()
  else if (propName = 'group') then result := GroupList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTerm.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'issued') then result := 'dateTime'
  else if (propName = 'applies') then result := 'Period'
  else if (propName = 'topic[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subType') then result := 'CodeableConcept'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'securityLabel') then result := 'BackboneElement'
  else if (propName = 'offer') then result := 'BackboneElement'
  else if (propName = 'asset') then result := 'BackboneElement'
  else if (propName = 'action') then result := 'BackboneElement'
  else if (propName = 'group') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTerm.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'issued') then IssuedElement := nil
  else if (propName = 'applies') then AppliesElement := nil
  else if (isMatchingName(propName, 'topic', ['CodeableConcept', 'Reference'])) then TopicElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subType') then SubTypeElement := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'securityLabel') then deletePropertyValue('securityLabel', SecurityLabelList, value)
  else if (propName = 'offer') then OfferElement := nil
  else if (propName = 'asset') then deletePropertyValue('asset', AssetList, value)
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value)
  else if (propName = 'group') then deletePropertyValue('group', GroupList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTerm.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'issued') then IssuedElement := asDateTime(new)
  else if (propName = 'applies') then AppliesElement := new as TFhirPeriod
  else if (isMatchingName(propName, 'topic', ['CodeableConcept', 'Reference'])) then TopicElement := new as TFhirDataType
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'subType') then SubTypeElement := new as TFhirCodeableConcept
  else if (propName = 'text') then TextElement := asString(new)
  else if (propName = 'securityLabel') then replacePropertyValue('securityLabel', SecurityLabelList, existing, new)
  else if (propName = 'offer') then OfferElement := new as TFhirContractTermOffer
  else if (propName = 'asset') then replacePropertyValue('asset', AssetList, existing, new)
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new)
  else if (propName = 'group') then replacePropertyValue('group', GroupList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTerm.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'securityLabel') then SecurityLabelList.move(source, destination)
  else if (propName = 'asset') then AssetList.move(source, destination)
  else if (propName = 'action') then ActionList.move(source, destination)
  else if (propName = 'group') then GroupList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTerm.fhirType : string;
begin
  result := 'Contract.term';
end;

function TFhirContractTerm.Link : TFhirContractTerm;
begin
  result := TFhirContractTerm(inherited Link);
end;

function TFhirContractTerm.Clone : TFhirContractTerm;
begin
  result := TFhirContractTerm(inherited Clone);
end;

function TFhirContractTerm.equals(other : TObject) : boolean; 
var
  o : TFhirContractTerm;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTerm)) then
    result := false
  else
  begin
    o := TFhirContractTerm(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(issuedElement, o.issuedElement, true) and 
      compareDeep(appliesElement, o.appliesElement, true) and compareDeep(topicElement, o.topicElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subTypeElement, o.subTypeElement, true) and 
      compareDeep(textElement, o.textElement, true) and compareDeep(securityLabelList, o.securityLabelList, true) and 
      compareDeep(offerElement, o.offerElement, true) and compareDeep(assetList, o.assetList, true) and 
      compareDeep(actionList, o.actionList, true) and compareDeep(groupList, o.groupList, true);
  end;
end;

function TFhirContractTerm.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FIssued) and isEmptyProp(FApplies) and isEmptyProp(FTopic) and isEmptyProp(FType_) and isEmptyProp(FSubType) and isEmptyProp(FText) and isEmptyProp(FsecurityLabelList) and isEmptyProp(FOffer) and isEmptyProp(FassetList) and isEmptyProp(FactionList) and isEmptyProp(FgroupList);
end;

procedure TFhirContractTerm.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('issued');
  fields.add('applies');
  fields.add('topic[x]');
  fields.add('type');
  fields.add('subType');
  fields.add('text');
  fields.add('securityLabel');
  fields.add('offer');
  fields.add('asset');
  fields.add('action');
  fields.add('group');
end;

function TFhirContractTerm.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FSecurityLabelList.sizeInBytes(magic));
  inc(result, FAssetList.sizeInBytes(magic));
  inc(result, FActionList.sizeInBytes(magic));
  inc(result, FGroupList.sizeInBytes(magic));
end;

procedure TFhirContractTerm.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirContractTerm.SetIssued(value : TFhirDateTime);
begin
  FIssued.free;
  FIssued := value;
end;

function TFhirContractTerm.GetIssuedST : TFslDateTime;
begin
  if FIssued = nil then
    result := TFslDateTime.makeNull
  else
    result := FIssued.value;
end;

procedure TFhirContractTerm.SetIssuedST(value : TFslDateTime);
begin
  if FIssued = nil then
    FIssued := TFhirDateTime.create;
  FIssued.value := value
end;

procedure TFhirContractTerm.SetApplies(value : TFhirPeriod);
begin
  FApplies.free;
  FApplies := value;
end;

procedure TFhirContractTerm.SetTopic(value : TFhirDataType);
begin
  FTopic.free;
  FTopic := value;
end;

procedure TFhirContractTerm.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirContractTerm.SetSubType(value : TFhirCodeableConcept);
begin
  FSubType.free;
  FSubType := value;
end;

procedure TFhirContractTerm.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

function TFhirContractTerm.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirContractTerm.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

function TFhirContractTerm.GetSecurityLabelList : TFhirContractTermSecurityLabelList;
begin
  if FSecurityLabelList = nil then
    FSecurityLabelList := TFhirContractTermSecurityLabelList.Create;
  result := FSecurityLabelList;
end;

function TFhirContractTerm.GetHasSecurityLabelList : boolean;
begin
  result := (FSecurityLabelList <> nil) and (FSecurityLabelList.count > 0);
end;

procedure TFhirContractTerm.SetOffer(value : TFhirContractTermOffer);
begin
  FOffer.free;
  FOffer := value;
end;

function TFhirContractTerm.GetAssetList : TFhirContractTermAssetList;
begin
  if FAssetList = nil then
    FAssetList := TFhirContractTermAssetList.Create;
  result := FAssetList;
end;

function TFhirContractTerm.GetHasAssetList : boolean;
begin
  result := (FAssetList <> nil) and (FAssetList.count > 0);
end;

function TFhirContractTerm.GetActionList : TFhirContractTermActionList;
begin
  if FActionList = nil then
    FActionList := TFhirContractTermActionList.Create;
  result := FActionList;
end;

function TFhirContractTerm.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

function TFhirContractTerm.GetGroupList : TFhirContractTermList;
begin
  if FGroupList = nil then
    FGroupList := TFhirContractTermList.Create;
  result := FGroupList;
end;

function TFhirContractTerm.GetHasGroupList : boolean;
begin
  result := (FGroupList <> nil) and (FGroupList.count > 0);
end;

{ TFhirContractTermListEnumerator }

constructor TFhirContractTermListEnumerator.Create(list : TFhirContractTermList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermListEnumerator.GetCurrent : TFhirContractTerm;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractTermList }

function TFhirContractTermList.AddItem(value: TFhirContractTerm): TFhirContractTerm;
begin
  assert(value.ClassName = 'TFhirContractTerm', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTerm');
  add(value);
  result := value;
end;

function TFhirContractTermList.Append: TFhirContractTerm;
begin
  result := TFhirContractTerm.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermList.GetEnumerator : TFhirContractTermListEnumerator;
begin
  result := TFhirContractTermListEnumerator.Create(self.link);
end;

function TFhirContractTermList.Clone: TFhirContractTermList;
begin
  result := TFhirContractTermList(inherited Clone);
end;

function TFhirContractTermList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermList.GetItemN(index: Integer): TFhirContractTerm;
begin
  result := TFhirContractTerm(ObjectByIndex[index]);
end;

function TFhirContractTermList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTerm;
end;
function TFhirContractTermList.IndexOf(value: TFhirContractTerm): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermList.Insert(index: Integer): TFhirContractTerm;
begin
  result := TFhirContractTerm.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermList.InsertItem(index: Integer; value: TFhirContractTerm);
begin
  assert(value is TFhirContractTerm);
  Inherited Insert(index, value);
end;

function TFhirContractTermList.Item(index: Integer): TFhirContractTerm;
begin
  result := TFhirContractTerm(ObjectByIndex[index]);
end;

function TFhirContractTermList.Link: TFhirContractTermList;
begin
  result := TFhirContractTermList(inherited Link);
end;

procedure TFhirContractTermList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermList.SetItemByIndex(index: Integer; value: TFhirContractTerm);
begin
  assert(value is TFhirContractTerm);
  FhirContractTerms[index] := value;
end;

procedure TFhirContractTermList.SetItemN(index: Integer; value: TFhirContractTerm);
begin
  assert(value is TFhirContractTerm);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermSecurityLabel }

constructor TFhirContractTermSecurityLabel.Create;
begin
  inherited;
end;

destructor TFhirContractTermSecurityLabel.Destroy;
begin
  FNumberList.Free;
  FClassification.free;
  FCategoryList.Free;
  FControlList.Free;
  inherited;
end;

procedure TFhirContractTermSecurityLabel.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirContractTermSecurityLabel(oSource).FNumberList = nil) then
  begin
    FNumberList.free;
    FNumberList := nil;
  end
  else
  begin
    if FNumberList = nil then
      FNumberList := TFhirUnsignedIntList.Create;
    FNumberList.Assign(TFhirContractTermSecurityLabel(oSource).FNumberList);
  end;
  classification := TFhirContractTermSecurityLabel(oSource).classification.Clone;
  if (TFhirContractTermSecurityLabel(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodingList.Create;
    FCategoryList.Assign(TFhirContractTermSecurityLabel(oSource).FCategoryList);
  end;
  if (TFhirContractTermSecurityLabel(oSource).FControlList = nil) then
  begin
    FControlList.free;
    FControlList := nil;
  end
  else
  begin
    if FControlList = nil then
      FControlList := TFhirCodingList.Create;
    FControlList.Assign(TFhirContractTermSecurityLabel(oSource).FControlList);
  end;
end;

procedure TFhirContractTermSecurityLabel.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'number') Then
    list.addAll(self, 'number', FNumberList);
  if (child_name = 'classification') Then
     list.add(self.link, 'classification', FClassification.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'control') Then
    list.addAll(self, 'control', FControlList);
end;

procedure TFhirContractTermSecurityLabel.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'number', 'unsignedInt', true, TFhirUnsignedInt, FNumberList.Link));
  oList.add(TFHIRProperty.create(self, 'classification', 'Coding', false, TFhirCoding, FClassification.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'Coding', true, TFhirCoding, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'control', 'Coding', true, TFhirCoding, FControlList.Link));
end;

function TFhirContractTermSecurityLabel.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'number') then
  begin
    NumberList.add(asUnsignedInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'classification') then
  begin
    Classification := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCoding);
    result := propValue;
  end
  else if (propName = 'control') then
  begin
    ControlList.add(propValue as TFhirCoding);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermSecurityLabel.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'number') then NumberList.insertItem(index, asUnsignedInt(propValue))
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCoding)
  else if (propName = 'control') then ControlList.insertItem(index, propValue as TFhirCoding)
  else inherited;
end;

function TFhirContractTermSecurityLabel.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'number') then result := NumberList.new()
  else if (propName = 'classification') then result := TFhirCoding.create()
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'control') then result := ControlList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermSecurityLabel.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'number') then result := 'unsignedInt'
  else if (propName = 'classification') then result := 'Coding'
  else if (propName = 'category') then result := 'Coding'
  else if (propName = 'control') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermSecurityLabel.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'number') then deletePropertyValue('number', NumberList, value)
  else if (propName = 'classification') then ClassificationElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'control') then deletePropertyValue('control', ControlList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermSecurityLabel.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'number') then replacePropertyValue('number', NumberList, existing, new)
  else if (propName = 'classification') then ClassificationElement := new as TFhirCoding
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'control') then replacePropertyValue('control', ControlList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermSecurityLabel.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'number') then NumberList.move(source, destination)
  else if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'control') then ControlList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermSecurityLabel.fhirType : string;
begin
  result := 'Contract.term.securityLabel';
end;

function TFhirContractTermSecurityLabel.Link : TFhirContractTermSecurityLabel;
begin
  result := TFhirContractTermSecurityLabel(inherited Link);
end;

function TFhirContractTermSecurityLabel.Clone : TFhirContractTermSecurityLabel;
begin
  result := TFhirContractTermSecurityLabel(inherited Clone);
end;

function TFhirContractTermSecurityLabel.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermSecurityLabel;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermSecurityLabel)) then
    result := false
  else
  begin
    o := TFhirContractTermSecurityLabel(other);
    result := compareDeep(numberList, o.numberList, true) and compareDeep(classificationElement, o.classificationElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(controlList, o.controlList, true);
  end;
end;

function TFhirContractTermSecurityLabel.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FnumberList) and isEmptyProp(FClassification) and isEmptyProp(FcategoryList) and isEmptyProp(FcontrolList);
end;

procedure TFhirContractTermSecurityLabel.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('number');
  fields.add('classification');
  fields.add('category');
  fields.add('control');
end;

function TFhirContractTermSecurityLabel.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FNumberList.sizeInBytes(magic));
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FControlList.sizeInBytes(magic));
end;

function TFhirContractTermSecurityLabel.GetNumberList : TFhirUnsignedIntList;
begin
  if FNumberList = nil then
    FNumberList := TFhirUnsignedIntList.Create;
  result := FNumberList;
end;

function TFhirContractTermSecurityLabel.GetHasNumberList : boolean;
begin
  result := (FNumberList <> nil) and (FNumberList.count > 0);
end;

procedure TFhirContractTermSecurityLabel.SetClassification(value : TFhirCoding);
begin
  FClassification.free;
  FClassification := value;
end;

function TFhirContractTermSecurityLabel.GetCategoryList : TFhirCodingList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodingList.Create;
  result := FCategoryList;
end;

function TFhirContractTermSecurityLabel.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

function TFhirContractTermSecurityLabel.GetControlList : TFhirCodingList;
begin
  if FControlList = nil then
    FControlList := TFhirCodingList.Create;
  result := FControlList;
end;

function TFhirContractTermSecurityLabel.GetHasControlList : boolean;
begin
  result := (FControlList <> nil) and (FControlList.count > 0);
end;

{ TFhirContractTermSecurityLabelListEnumerator }

constructor TFhirContractTermSecurityLabelListEnumerator.Create(list : TFhirContractTermSecurityLabelList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermSecurityLabelListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermSecurityLabelListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermSecurityLabelListEnumerator.GetCurrent : TFhirContractTermSecurityLabel;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermSecurityLabelListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractTermSecurityLabelList }

function TFhirContractTermSecurityLabelList.AddItem(value: TFhirContractTermSecurityLabel): TFhirContractTermSecurityLabel;
begin
  assert(value.ClassName = 'TFhirContractTermSecurityLabel', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermSecurityLabel');
  add(value);
  result := value;
end;

function TFhirContractTermSecurityLabelList.Append: TFhirContractTermSecurityLabel;
begin
  result := TFhirContractTermSecurityLabel.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermSecurityLabelList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermSecurityLabelList.GetEnumerator : TFhirContractTermSecurityLabelListEnumerator;
begin
  result := TFhirContractTermSecurityLabelListEnumerator.Create(self.link);
end;

function TFhirContractTermSecurityLabelList.Clone: TFhirContractTermSecurityLabelList;
begin
  result := TFhirContractTermSecurityLabelList(inherited Clone);
end;

function TFhirContractTermSecurityLabelList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermSecurityLabelList.GetItemN(index: Integer): TFhirContractTermSecurityLabel;
begin
  result := TFhirContractTermSecurityLabel(ObjectByIndex[index]);
end;

function TFhirContractTermSecurityLabelList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermSecurityLabel;
end;
function TFhirContractTermSecurityLabelList.IndexOf(value: TFhirContractTermSecurityLabel): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermSecurityLabelList.Insert(index: Integer): TFhirContractTermSecurityLabel;
begin
  result := TFhirContractTermSecurityLabel.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermSecurityLabelList.InsertItem(index: Integer; value: TFhirContractTermSecurityLabel);
begin
  assert(value is TFhirContractTermSecurityLabel);
  Inherited Insert(index, value);
end;

function TFhirContractTermSecurityLabelList.Item(index: Integer): TFhirContractTermSecurityLabel;
begin
  result := TFhirContractTermSecurityLabel(ObjectByIndex[index]);
end;

function TFhirContractTermSecurityLabelList.Link: TFhirContractTermSecurityLabelList;
begin
  result := TFhirContractTermSecurityLabelList(inherited Link);
end;

procedure TFhirContractTermSecurityLabelList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermSecurityLabelList.SetItemByIndex(index: Integer; value: TFhirContractTermSecurityLabel);
begin
  assert(value is TFhirContractTermSecurityLabel);
  FhirContractTermSecurityLabels[index] := value;
end;

procedure TFhirContractTermSecurityLabelList.SetItemN(index: Integer; value: TFhirContractTermSecurityLabel);
begin
  assert(value is TFhirContractTermSecurityLabel);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermOffer }

constructor TFhirContractTermOffer.Create;
begin
  inherited;
end;

destructor TFhirContractTermOffer.Destroy;
begin
  FIdentifierList.Free;
  FPartyList.Free;
  FTopic.free;
  FType_.free;
  FDecision.free;
  FDecisionModeList.Free;
  FAnswerList.Free;
  FText.free;
  FLinkIdList.Free;
  FSecurityLabelNumberList.Free;
  inherited;
end;

procedure TFhirContractTermOffer.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirContractTermOffer(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirContractTermOffer(oSource).FIdentifierList);
  end;
  if (TFhirContractTermOffer(oSource).FPartyList = nil) then
  begin
    FPartyList.free;
    FPartyList := nil;
  end
  else
  begin
    if FPartyList = nil then
      FPartyList := TFhirContractTermOfferPartyList.Create;
    FPartyList.Assign(TFhirContractTermOffer(oSource).FPartyList);
  end;
  topic := TFhirContractTermOffer(oSource).topic.Clone;
  type_ := TFhirContractTermOffer(oSource).type_.Clone;
  decision := TFhirContractTermOffer(oSource).decision.Clone;
  if (TFhirContractTermOffer(oSource).FDecisionModeList = nil) then
  begin
    FDecisionModeList.free;
    FDecisionModeList := nil;
  end
  else
  begin
    if FDecisionModeList = nil then
      FDecisionModeList := TFhirCodeableConceptList.Create;
    FDecisionModeList.Assign(TFhirContractTermOffer(oSource).FDecisionModeList);
  end;
  if (TFhirContractTermOffer(oSource).FAnswerList = nil) then
  begin
    FAnswerList.free;
    FAnswerList := nil;
  end
  else
  begin
    if FAnswerList = nil then
      FAnswerList := TFhirContractTermOfferAnswerList.Create;
    FAnswerList.Assign(TFhirContractTermOffer(oSource).FAnswerList);
  end;
  textElement := TFhirContractTermOffer(oSource).textElement.Clone;
  if (TFhirContractTermOffer(oSource).FLinkIdList = nil) then
  begin
    FLinkIdList.free;
    FLinkIdList := nil;
  end
  else
  begin
    if FLinkIdList = nil then
      FLinkIdList := TFhirStringList.Create;
    FLinkIdList.Assign(TFhirContractTermOffer(oSource).FLinkIdList);
  end;
  if (TFhirContractTermOffer(oSource).FSecurityLabelNumberList = nil) then
  begin
    FSecurityLabelNumberList.free;
    FSecurityLabelNumberList := nil;
  end
  else
  begin
    if FSecurityLabelNumberList = nil then
      FSecurityLabelNumberList := TFhirUnsignedIntList.Create;
    FSecurityLabelNumberList.Assign(TFhirContractTermOffer(oSource).FSecurityLabelNumberList);
  end;
end;

procedure TFhirContractTermOffer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'party') Then
    list.addAll(self, 'party', FPartyList);
  if (child_name = 'topic') Then
     list.add(self.link, 'topic', FTopic.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'decision') Then
     list.add(self.link, 'decision', FDecision.Link);
  if (child_name = 'decisionMode') Then
    list.addAll(self, 'decisionMode', FDecisionModeList);
  if (child_name = 'answer') Then
    list.addAll(self, 'answer', FAnswerList);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'linkId') Then
    list.addAll(self, 'linkId', FLinkIdList);
  if (child_name = 'securityLabelNumber') Then
    list.addAll(self, 'securityLabelNumber', FSecurityLabelNumberList);
end;

procedure TFhirContractTermOffer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'party', 'BackboneElement', true, TFhirContractTermOfferParty, FPartyList.Link));
  oList.add(TFHIRProperty.create(self, 'topic', 'Reference', false, TFhirReference, FTopic.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'decision', 'CodeableConcept', false, TFhirCodeableConcept, FDecision.Link));
  oList.add(TFHIRProperty.create(self, 'decisionMode', 'CodeableConcept', true, TFhirCodeableConcept, FDecisionModeList.Link));
  oList.add(TFHIRProperty.create(self, 'answer', 'BackboneElement', true, TFhirContractTermOfferAnswer, FAnswerList.Link));
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));
  oList.add(TFHIRProperty.create(self, 'linkId', 'string', true, TFhirString, FLinkIdList.Link));
  oList.add(TFHIRProperty.create(self, 'securityLabelNumber', 'unsignedInt', true, TFhirUnsignedInt, FSecurityLabelNumberList.Link));
end;

function TFhirContractTermOffer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'party') then
  begin
    PartyList.add(propValue as TFhirContractTermOfferParty);
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    Topic := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'decision') then
  begin
    Decision := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'decisionMode') then
  begin
    DecisionModeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'answer') then
  begin
    AnswerList.add(propValue as TFhirContractTermOfferAnswer);
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'linkId') then
  begin
    LinkIdList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'securityLabelNumber') then
  begin
    SecurityLabelNumberList.add(asUnsignedInt(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermOffer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'party') then PartyList.insertItem(index, propValue as TFhirContractTermOfferParty)
  else if (propName = 'decisionMode') then DecisionModeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'answer') then AnswerList.insertItem(index, propValue as TFhirContractTermOfferAnswer)
  else if (propName = 'linkId') then LinkIdList.insertItem(index, asString(propValue))
  else if (propName = 'securityLabelNumber') then SecurityLabelNumberList.insertItem(index, asUnsignedInt(propValue))
  else inherited;
end;

function TFhirContractTermOffer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'party') then result := PartyList.new()
  else if (propName = 'topic') then result := TFhirReference.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'decision') then result := TFhirCodeableConcept.create()
  else if (propName = 'decisionMode') then result := DecisionModeList.new()
  else if (propName = 'answer') then result := AnswerList.new()
  else if (propName = 'text') then result := TFhirString.create()
  else if (propName = 'linkId') then result := LinkIdList.new()
  else if (propName = 'securityLabelNumber') then result := SecurityLabelNumberList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermOffer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'party') then result := 'BackboneElement'
  else if (propName = 'topic') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'decision') then result := 'CodeableConcept'
  else if (propName = 'decisionMode') then result := 'CodeableConcept'
  else if (propName = 'answer') then result := 'BackboneElement'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'linkId') then result := 'string'
  else if (propName = 'securityLabelNumber') then result := 'unsignedInt'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermOffer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'party') then deletePropertyValue('party', PartyList, value)
  else if (propName = 'topic') then TopicElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'decision') then DecisionElement := nil
  else if (propName = 'decisionMode') then deletePropertyValue('decisionMode', DecisionModeList, value)
  else if (propName = 'answer') then deletePropertyValue('answer', AnswerList, value)
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'linkId') then deletePropertyValue('linkId', LinkIdList, value)
  else if (propName = 'securityLabelNumber') then deletePropertyValue('securityLabelNumber', SecurityLabelNumberList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermOffer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'party') then replacePropertyValue('party', PartyList, existing, new)
  else if (propName = 'topic') then TopicElement := new as TFhirReference
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'decision') then DecisionElement := new as TFhirCodeableConcept
  else if (propName = 'decisionMode') then replacePropertyValue('decisionMode', DecisionModeList, existing, new)
  else if (propName = 'answer') then replacePropertyValue('answer', AnswerList, existing, new)
  else if (propName = 'text') then TextElement := asString(new)
  else if (propName = 'linkId') then replacePropertyValue('linkId', LinkIdList, existing, new)
  else if (propName = 'securityLabelNumber') then replacePropertyValue('securityLabelNumber', SecurityLabelNumberList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermOffer.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'party') then PartyList.move(source, destination)
  else if (propName = 'decisionMode') then DecisionModeList.move(source, destination)
  else if (propName = 'answer') then AnswerList.move(source, destination)
  else if (propName = 'linkId') then LinkIdList.move(source, destination)
  else if (propName = 'securityLabelNumber') then SecurityLabelNumberList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermOffer.fhirType : string;
begin
  result := 'Contract.term.offer';
end;

function TFhirContractTermOffer.Link : TFhirContractTermOffer;
begin
  result := TFhirContractTermOffer(inherited Link);
end;

function TFhirContractTermOffer.Clone : TFhirContractTermOffer;
begin
  result := TFhirContractTermOffer(inherited Clone);
end;

function TFhirContractTermOffer.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermOffer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermOffer)) then
    result := false
  else
  begin
    o := TFhirContractTermOffer(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(partyList, o.partyList, true) and 
      compareDeep(topicElement, o.topicElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(decisionElement, o.decisionElement, true) and compareDeep(decisionModeList, o.decisionModeList, true) and 
      compareDeep(answerList, o.answerList, true) and compareDeep(textElement, o.textElement, true) and 
      compareDeep(linkIdList, o.linkIdList, true) and compareDeep(securityLabelNumberList, o.securityLabelNumberList, true);
  end;
end;

function TFhirContractTermOffer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FpartyList) and isEmptyProp(FTopic) and isEmptyProp(FType_) and isEmptyProp(FDecision) and isEmptyProp(FdecisionModeList) and isEmptyProp(FanswerList) and isEmptyProp(FText) and isEmptyProp(FlinkIdList) and isEmptyProp(FsecurityLabelNumberList);
end;

procedure TFhirContractTermOffer.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('party');
  fields.add('topic');
  fields.add('type');
  fields.add('decision');
  fields.add('decisionMode');
  fields.add('answer');
  fields.add('text');
  fields.add('linkId');
  fields.add('securityLabelNumber');
end;

function TFhirContractTermOffer.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FPartyList.sizeInBytes(magic));
  inc(result, FDecisionModeList.sizeInBytes(magic));
  inc(result, FAnswerList.sizeInBytes(magic));
  inc(result, FLinkIdList.sizeInBytes(magic));
  inc(result, FSecurityLabelNumberList.sizeInBytes(magic));
end;

function TFhirContractTermOffer.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirContractTermOffer.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirContractTermOffer.GetPartyList : TFhirContractTermOfferPartyList;
begin
  if FPartyList = nil then
    FPartyList := TFhirContractTermOfferPartyList.Create;
  result := FPartyList;
end;

function TFhirContractTermOffer.GetHasPartyList : boolean;
begin
  result := (FPartyList <> nil) and (FPartyList.count > 0);
end;

procedure TFhirContractTermOffer.SetTopic(value : TFhirReference);
begin
  FTopic.free;
  FTopic := value;
end;

procedure TFhirContractTermOffer.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirContractTermOffer.SetDecision(value : TFhirCodeableConcept);
begin
  FDecision.free;
  FDecision := value;
end;

function TFhirContractTermOffer.GetDecisionModeList : TFhirCodeableConceptList;
begin
  if FDecisionModeList = nil then
    FDecisionModeList := TFhirCodeableConceptList.Create;
  result := FDecisionModeList;
end;

function TFhirContractTermOffer.GetHasDecisionModeList : boolean;
begin
  result := (FDecisionModeList <> nil) and (FDecisionModeList.count > 0);
end;

function TFhirContractTermOffer.GetAnswerList : TFhirContractTermOfferAnswerList;
begin
  if FAnswerList = nil then
    FAnswerList := TFhirContractTermOfferAnswerList.Create;
  result := FAnswerList;
end;

function TFhirContractTermOffer.GetHasAnswerList : boolean;
begin
  result := (FAnswerList <> nil) and (FAnswerList.count > 0);
end;

procedure TFhirContractTermOffer.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

function TFhirContractTermOffer.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirContractTermOffer.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

function TFhirContractTermOffer.GetLinkIdList : TFhirStringList;
begin
  if FLinkIdList = nil then
    FLinkIdList := TFhirStringList.Create;
  result := FLinkIdList;
end;

function TFhirContractTermOffer.GetHasLinkIdList : boolean;
begin
  result := (FLinkIdList <> nil) and (FLinkIdList.count > 0);
end;

function TFhirContractTermOffer.GetSecurityLabelNumberList : TFhirUnsignedIntList;
begin
  if FSecurityLabelNumberList = nil then
    FSecurityLabelNumberList := TFhirUnsignedIntList.Create;
  result := FSecurityLabelNumberList;
end;

function TFhirContractTermOffer.GetHasSecurityLabelNumberList : boolean;
begin
  result := (FSecurityLabelNumberList <> nil) and (FSecurityLabelNumberList.count > 0);
end;

{ TFhirContractTermOfferListEnumerator }

constructor TFhirContractTermOfferListEnumerator.Create(list : TFhirContractTermOfferList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermOfferListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermOfferListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermOfferListEnumerator.GetCurrent : TFhirContractTermOffer;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermOfferListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractTermOfferList }

function TFhirContractTermOfferList.AddItem(value: TFhirContractTermOffer): TFhirContractTermOffer;
begin
  assert(value.ClassName = 'TFhirContractTermOffer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermOffer');
  add(value);
  result := value;
end;

function TFhirContractTermOfferList.Append: TFhirContractTermOffer;
begin
  result := TFhirContractTermOffer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermOfferList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermOfferList.GetEnumerator : TFhirContractTermOfferListEnumerator;
begin
  result := TFhirContractTermOfferListEnumerator.Create(self.link);
end;

function TFhirContractTermOfferList.Clone: TFhirContractTermOfferList;
begin
  result := TFhirContractTermOfferList(inherited Clone);
end;

function TFhirContractTermOfferList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermOfferList.GetItemN(index: Integer): TFhirContractTermOffer;
begin
  result := TFhirContractTermOffer(ObjectByIndex[index]);
end;

function TFhirContractTermOfferList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermOffer;
end;
function TFhirContractTermOfferList.IndexOf(value: TFhirContractTermOffer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermOfferList.Insert(index: Integer): TFhirContractTermOffer;
begin
  result := TFhirContractTermOffer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermOfferList.InsertItem(index: Integer; value: TFhirContractTermOffer);
begin
  assert(value is TFhirContractTermOffer);
  Inherited Insert(index, value);
end;

function TFhirContractTermOfferList.Item(index: Integer): TFhirContractTermOffer;
begin
  result := TFhirContractTermOffer(ObjectByIndex[index]);
end;

function TFhirContractTermOfferList.Link: TFhirContractTermOfferList;
begin
  result := TFhirContractTermOfferList(inherited Link);
end;

procedure TFhirContractTermOfferList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermOfferList.SetItemByIndex(index: Integer; value: TFhirContractTermOffer);
begin
  assert(value is TFhirContractTermOffer);
  FhirContractTermOffers[index] := value;
end;

procedure TFhirContractTermOfferList.SetItemN(index: Integer; value: TFhirContractTermOffer);
begin
  assert(value is TFhirContractTermOffer);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermOfferParty }

constructor TFhirContractTermOfferParty.Create;
begin
  inherited;
end;

destructor TFhirContractTermOfferParty.Destroy;
begin
  FReferenceList.Free;
  FRole.free;
  inherited;
end;

procedure TFhirContractTermOfferParty.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirContractTermOfferParty(oSource).FReferenceList = nil) then
  begin
    FReferenceList.free;
    FReferenceList := nil;
  end
  else
  begin
    if FReferenceList = nil then
      FReferenceList := TFhirReferenceList.Create;
    FReferenceList.Assign(TFhirContractTermOfferParty(oSource).FReferenceList);
  end;
  role := TFhirContractTermOfferParty(oSource).role.Clone;
end;

procedure TFhirContractTermOfferParty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'reference') Then
    list.addAll(self, 'reference', FReferenceList);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
end;

procedure TFhirContractTermOfferParty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference', true, TFhirReference, FReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));
end;

function TFhirContractTermOfferParty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'reference') then
  begin
    ReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermOfferParty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'reference') then ReferenceList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirContractTermOfferParty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'reference') then result := ReferenceList.new()
  else if (propName = 'role') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermOfferParty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'reference') then result := 'Reference'
  else if (propName = 'role') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermOfferParty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'reference') then deletePropertyValue('reference', ReferenceList, value)
  else if (propName = 'role') then RoleElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermOfferParty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'reference') then replacePropertyValue('reference', ReferenceList, existing, new)
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermOfferParty.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'reference') then ReferenceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermOfferParty.fhirType : string;
begin
  result := 'Contract.term.offer.party';
end;

function TFhirContractTermOfferParty.Link : TFhirContractTermOfferParty;
begin
  result := TFhirContractTermOfferParty(inherited Link);
end;

function TFhirContractTermOfferParty.Clone : TFhirContractTermOfferParty;
begin
  result := TFhirContractTermOfferParty(inherited Clone);
end;

function TFhirContractTermOfferParty.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermOfferParty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermOfferParty)) then
    result := false
  else
  begin
    o := TFhirContractTermOfferParty(other);
    result := compareDeep(referenceList, o.referenceList, true) and compareDeep(roleElement, o.roleElement, true);
  end;
end;

function TFhirContractTermOfferParty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FreferenceList) and isEmptyProp(FRole);
end;

procedure TFhirContractTermOfferParty.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('reference');
  fields.add('role');
end;

function TFhirContractTermOfferParty.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FReferenceList.sizeInBytes(magic));
end;

function TFhirContractTermOfferParty.GetReferenceList : TFhirReferenceList;
begin
  if FReferenceList = nil then
    FReferenceList := TFhirReferenceList.Create;
  result := FReferenceList;
end;

function TFhirContractTermOfferParty.GetHasReferenceList : boolean;
begin
  result := (FReferenceList <> nil) and (FReferenceList.count > 0);
end;

procedure TFhirContractTermOfferParty.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

{ TFhirContractTermOfferPartyListEnumerator }

constructor TFhirContractTermOfferPartyListEnumerator.Create(list : TFhirContractTermOfferPartyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermOfferPartyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermOfferPartyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermOfferPartyListEnumerator.GetCurrent : TFhirContractTermOfferParty;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermOfferPartyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractTermOfferPartyList }

function TFhirContractTermOfferPartyList.AddItem(value: TFhirContractTermOfferParty): TFhirContractTermOfferParty;
begin
  assert(value.ClassName = 'TFhirContractTermOfferParty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermOfferParty');
  add(value);
  result := value;
end;

function TFhirContractTermOfferPartyList.Append: TFhirContractTermOfferParty;
begin
  result := TFhirContractTermOfferParty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermOfferPartyList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermOfferPartyList.GetEnumerator : TFhirContractTermOfferPartyListEnumerator;
begin
  result := TFhirContractTermOfferPartyListEnumerator.Create(self.link);
end;

function TFhirContractTermOfferPartyList.Clone: TFhirContractTermOfferPartyList;
begin
  result := TFhirContractTermOfferPartyList(inherited Clone);
end;

function TFhirContractTermOfferPartyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermOfferPartyList.GetItemN(index: Integer): TFhirContractTermOfferParty;
begin
  result := TFhirContractTermOfferParty(ObjectByIndex[index]);
end;

function TFhirContractTermOfferPartyList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermOfferParty;
end;
function TFhirContractTermOfferPartyList.IndexOf(value: TFhirContractTermOfferParty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermOfferPartyList.Insert(index: Integer): TFhirContractTermOfferParty;
begin
  result := TFhirContractTermOfferParty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermOfferPartyList.InsertItem(index: Integer; value: TFhirContractTermOfferParty);
begin
  assert(value is TFhirContractTermOfferParty);
  Inherited Insert(index, value);
end;

function TFhirContractTermOfferPartyList.Item(index: Integer): TFhirContractTermOfferParty;
begin
  result := TFhirContractTermOfferParty(ObjectByIndex[index]);
end;

function TFhirContractTermOfferPartyList.Link: TFhirContractTermOfferPartyList;
begin
  result := TFhirContractTermOfferPartyList(inherited Link);
end;

procedure TFhirContractTermOfferPartyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermOfferPartyList.SetItemByIndex(index: Integer; value: TFhirContractTermOfferParty);
begin
  assert(value is TFhirContractTermOfferParty);
  FhirContractTermOfferParties[index] := value;
end;

procedure TFhirContractTermOfferPartyList.SetItemN(index: Integer; value: TFhirContractTermOfferParty);
begin
  assert(value is TFhirContractTermOfferParty);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermOfferAnswer }

constructor TFhirContractTermOfferAnswer.Create;
begin
  inherited;
end;

destructor TFhirContractTermOfferAnswer.Destroy;
begin
  FValue.free;
  inherited;
end;

procedure TFhirContractTermOfferAnswer.Assign(oSource : TFslObject);
begin
  inherited;
  value := TFhirContractTermOfferAnswer(oSource).value.Clone;
end;

procedure TFhirContractTermOfferAnswer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirContractTermOfferAnswer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'value[x]', 'boolean|decimal|integer|date|dateTime|time|string|uri|Attachment|Coding|Quantity|Reference', false, TFhirDataType, FValue.Link));
end;

function TFhirContractTermOfferAnswer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermOfferAnswer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractTermOfferAnswer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermOfferAnswer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'value[x]') then result := 'boolean|decimal|integer|date|dateTime|time|string|uri|Attachment|Coding|Quantity|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermOfferAnswer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermOfferAnswer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermOfferAnswer.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermOfferAnswer.fhirType : string;
begin
  result := 'Contract.term.offer.answer';
end;

function TFhirContractTermOfferAnswer.Link : TFhirContractTermOfferAnswer;
begin
  result := TFhirContractTermOfferAnswer(inherited Link);
end;

function TFhirContractTermOfferAnswer.Clone : TFhirContractTermOfferAnswer;
begin
  result := TFhirContractTermOfferAnswer(inherited Clone);
end;

function TFhirContractTermOfferAnswer.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermOfferAnswer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermOfferAnswer)) then
    result := false
  else
  begin
    o := TFhirContractTermOfferAnswer(other);
    result := compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirContractTermOfferAnswer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValue);
end;

procedure TFhirContractTermOfferAnswer.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('value[x]');
end;

function TFhirContractTermOfferAnswer.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirContractTermOfferAnswer.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirContractTermOfferAnswerListEnumerator }

constructor TFhirContractTermOfferAnswerListEnumerator.Create(list : TFhirContractTermOfferAnswerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermOfferAnswerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermOfferAnswerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermOfferAnswerListEnumerator.GetCurrent : TFhirContractTermOfferAnswer;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermOfferAnswerListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractTermOfferAnswerList }

function TFhirContractTermOfferAnswerList.AddItem(value: TFhirContractTermOfferAnswer): TFhirContractTermOfferAnswer;
begin
  assert(value.ClassName = 'TFhirContractTermOfferAnswer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermOfferAnswer');
  add(value);
  result := value;
end;

function TFhirContractTermOfferAnswerList.Append: TFhirContractTermOfferAnswer;
begin
  result := TFhirContractTermOfferAnswer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermOfferAnswerList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermOfferAnswerList.GetEnumerator : TFhirContractTermOfferAnswerListEnumerator;
begin
  result := TFhirContractTermOfferAnswerListEnumerator.Create(self.link);
end;

function TFhirContractTermOfferAnswerList.Clone: TFhirContractTermOfferAnswerList;
begin
  result := TFhirContractTermOfferAnswerList(inherited Clone);
end;

function TFhirContractTermOfferAnswerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermOfferAnswerList.GetItemN(index: Integer): TFhirContractTermOfferAnswer;
begin
  result := TFhirContractTermOfferAnswer(ObjectByIndex[index]);
end;

function TFhirContractTermOfferAnswerList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermOfferAnswer;
end;
function TFhirContractTermOfferAnswerList.IndexOf(value: TFhirContractTermOfferAnswer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermOfferAnswerList.Insert(index: Integer): TFhirContractTermOfferAnswer;
begin
  result := TFhirContractTermOfferAnswer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermOfferAnswerList.InsertItem(index: Integer; value: TFhirContractTermOfferAnswer);
begin
  assert(value is TFhirContractTermOfferAnswer);
  Inherited Insert(index, value);
end;

function TFhirContractTermOfferAnswerList.Item(index: Integer): TFhirContractTermOfferAnswer;
begin
  result := TFhirContractTermOfferAnswer(ObjectByIndex[index]);
end;

function TFhirContractTermOfferAnswerList.Link: TFhirContractTermOfferAnswerList;
begin
  result := TFhirContractTermOfferAnswerList(inherited Link);
end;

procedure TFhirContractTermOfferAnswerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermOfferAnswerList.SetItemByIndex(index: Integer; value: TFhirContractTermOfferAnswer);
begin
  assert(value is TFhirContractTermOfferAnswer);
  FhirContractTermOfferAnswers[index] := value;
end;

procedure TFhirContractTermOfferAnswerList.SetItemN(index: Integer; value: TFhirContractTermOfferAnswer);
begin
  assert(value is TFhirContractTermOfferAnswer);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermAsset }

constructor TFhirContractTermAsset.Create;
begin
  inherited;
end;

destructor TFhirContractTermAsset.Destroy;
begin
  FScope.free;
  FType_List.Free;
  FTypeReferenceList.Free;
  FSubtypeList.Free;
  FRelationship.free;
  FContextList.Free;
  FCondition.free;
  FPeriodTypeList.Free;
  FPeriodList.Free;
  FUsePeriodList.Free;
  FText.free;
  FLinkIdList.Free;
  FAnswerList.Free;
  FSecurityLabelNumberList.Free;
  FValuedItemList.Free;
  inherited;
end;

procedure TFhirContractTermAsset.Assign(oSource : TFslObject);
begin
  inherited;
  scope := TFhirContractTermAsset(oSource).scope.Clone;
  if (TFhirContractTermAsset(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirContractTermAsset(oSource).FType_List);
  end;
  if (TFhirContractTermAsset(oSource).FTypeReferenceList = nil) then
  begin
    FTypeReferenceList.free;
    FTypeReferenceList := nil;
  end
  else
  begin
    if FTypeReferenceList = nil then
      FTypeReferenceList := TFhirReferenceList.Create;
    FTypeReferenceList.Assign(TFhirContractTermAsset(oSource).FTypeReferenceList);
  end;
  if (TFhirContractTermAsset(oSource).FSubtypeList = nil) then
  begin
    FSubtypeList.free;
    FSubtypeList := nil;
  end
  else
  begin
    if FSubtypeList = nil then
      FSubtypeList := TFhirCodeableConceptList.Create;
    FSubtypeList.Assign(TFhirContractTermAsset(oSource).FSubtypeList);
  end;
  relationship := TFhirContractTermAsset(oSource).relationship.Clone;
  if (TFhirContractTermAsset(oSource).FContextList = nil) then
  begin
    FContextList.free;
    FContextList := nil;
  end
  else
  begin
    if FContextList = nil then
      FContextList := TFhirContractTermAssetContextList.Create;
    FContextList.Assign(TFhirContractTermAsset(oSource).FContextList);
  end;
  conditionElement := TFhirContractTermAsset(oSource).conditionElement.Clone;
  if (TFhirContractTermAsset(oSource).FPeriodTypeList = nil) then
  begin
    FPeriodTypeList.free;
    FPeriodTypeList := nil;
  end
  else
  begin
    if FPeriodTypeList = nil then
      FPeriodTypeList := TFhirCodeableConceptList.Create;
    FPeriodTypeList.Assign(TFhirContractTermAsset(oSource).FPeriodTypeList);
  end;
  if (TFhirContractTermAsset(oSource).FPeriodList = nil) then
  begin
    FPeriodList.free;
    FPeriodList := nil;
  end
  else
  begin
    if FPeriodList = nil then
      FPeriodList := TFhirPeriodList.Create;
    FPeriodList.Assign(TFhirContractTermAsset(oSource).FPeriodList);
  end;
  if (TFhirContractTermAsset(oSource).FUsePeriodList = nil) then
  begin
    FUsePeriodList.free;
    FUsePeriodList := nil;
  end
  else
  begin
    if FUsePeriodList = nil then
      FUsePeriodList := TFhirPeriodList.Create;
    FUsePeriodList.Assign(TFhirContractTermAsset(oSource).FUsePeriodList);
  end;
  textElement := TFhirContractTermAsset(oSource).textElement.Clone;
  if (TFhirContractTermAsset(oSource).FLinkIdList = nil) then
  begin
    FLinkIdList.free;
    FLinkIdList := nil;
  end
  else
  begin
    if FLinkIdList = nil then
      FLinkIdList := TFhirStringList.Create;
    FLinkIdList.Assign(TFhirContractTermAsset(oSource).FLinkIdList);
  end;
  if (TFhirContractTermAsset(oSource).FAnswerList = nil) then
  begin
    FAnswerList.free;
    FAnswerList := nil;
  end
  else
  begin
    if FAnswerList = nil then
      FAnswerList := TFhirContractTermOfferAnswerList.Create;
    FAnswerList.Assign(TFhirContractTermAsset(oSource).FAnswerList);
  end;
  if (TFhirContractTermAsset(oSource).FSecurityLabelNumberList = nil) then
  begin
    FSecurityLabelNumberList.free;
    FSecurityLabelNumberList := nil;
  end
  else
  begin
    if FSecurityLabelNumberList = nil then
      FSecurityLabelNumberList := TFhirUnsignedIntList.Create;
    FSecurityLabelNumberList.Assign(TFhirContractTermAsset(oSource).FSecurityLabelNumberList);
  end;
  if (TFhirContractTermAsset(oSource).FValuedItemList = nil) then
  begin
    FValuedItemList.free;
    FValuedItemList := nil;
  end
  else
  begin
    if FValuedItemList = nil then
      FValuedItemList := TFhirContractTermAssetValuedItemList.Create;
    FValuedItemList.Assign(TFhirContractTermAsset(oSource).FValuedItemList);
  end;
end;

procedure TFhirContractTermAsset.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'scope') Then
     list.add(self.link, 'scope', FScope.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'typeReference') Then
    list.addAll(self, 'typeReference', FTypeReferenceList);
  if (child_name = 'subtype') Then
    list.addAll(self, 'subtype', FSubtypeList);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'context') Then
    list.addAll(self, 'context', FContextList);
  if (child_name = 'condition') Then
     list.add(self.link, 'condition', FCondition.Link);
  if (child_name = 'periodType') Then
    list.addAll(self, 'periodType', FPeriodTypeList);
  if (child_name = 'period') Then
    list.addAll(self, 'period', FPeriodList);
  if (child_name = 'usePeriod') Then
    list.addAll(self, 'usePeriod', FUsePeriodList);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'linkId') Then
    list.addAll(self, 'linkId', FLinkIdList);
  if (child_name = 'answer') Then
    list.addAll(self, 'answer', FAnswerList);
  if (child_name = 'securityLabelNumber') Then
    list.addAll(self, 'securityLabelNumber', FSecurityLabelNumberList);
  if (child_name = 'valuedItem') Then
    list.addAll(self, 'valuedItem', FValuedItemList);
end;

procedure TFhirContractTermAsset.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'scope', 'CodeableConcept', false, TFhirCodeableConcept, FScope.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
  oList.add(TFHIRProperty.create(self, 'typeReference', 'Reference', true, TFhirReference, FTypeReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'subtype', 'CodeableConcept', true, TFhirCodeableConcept, FSubtypeList.Link));
  oList.add(TFHIRProperty.create(self, 'relationship', 'Coding', false, TFhirCoding, FRelationship.Link));
  oList.add(TFHIRProperty.create(self, 'context', 'BackboneElement', true, TFhirContractTermAssetContext, FContextList.Link));
  oList.add(TFHIRProperty.create(self, 'condition', 'string', false, TFhirString, FCondition.Link));
  oList.add(TFHIRProperty.create(self, 'periodType', 'CodeableConcept', true, TFhirCodeableConcept, FPeriodTypeList.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', true, TFhirPeriod, FPeriodList.Link));
  oList.add(TFHIRProperty.create(self, 'usePeriod', 'Period', true, TFhirPeriod, FUsePeriodList.Link));
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));
  oList.add(TFHIRProperty.create(self, 'linkId', 'string', true, TFhirString, FLinkIdList.Link));
  oList.add(TFHIRProperty.create(self, 'answer', '', true, TFhirContractTermOfferAnswer, FAnswerList.Link));
  oList.add(TFHIRProperty.create(self, 'securityLabelNumber', 'unsignedInt', true, TFhirUnsignedInt, FSecurityLabelNumberList.Link));
  oList.add(TFHIRProperty.create(self, 'valuedItem', 'BackboneElement', true, TFhirContractTermAssetValuedItem, FValuedItemList.Link));
end;

function TFhirContractTermAsset.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'scope') then
  begin
    Scope := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'typeReference') then
  begin
    TypeReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'subtype') then
  begin
    SubtypeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    Relationship := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    ContextList.add(propValue as TFhirContractTermAssetContext);
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    ConditionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'periodType') then
  begin
    PeriodTypeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    PeriodList.add(propValue as TFhirPeriod);
    result := propValue;
  end
  else if (propName = 'usePeriod') then
  begin
    UsePeriodList.add(propValue as TFhirPeriod);
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'linkId') then
  begin
    LinkIdList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'answer') then
  begin
    AnswerList.add(propValue as TFhirContractTermOfferAnswer);
    result := propValue;
  end
  else if (propName = 'securityLabelNumber') then
  begin
    SecurityLabelNumberList.add(asUnsignedInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'valuedItem') then
  begin
    ValuedItemList.add(propValue as TFhirContractTermAssetValuedItem);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermAsset.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'typeReference') then TypeReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'subtype') then SubtypeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'context') then ContextList.insertItem(index, propValue as TFhirContractTermAssetContext)
  else if (propName = 'periodType') then PeriodTypeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'period') then PeriodList.insertItem(index, propValue as TFhirPeriod)
  else if (propName = 'usePeriod') then UsePeriodList.insertItem(index, propValue as TFhirPeriod)
  else if (propName = 'linkId') then LinkIdList.insertItem(index, asString(propValue))
  else if (propName = 'answer') then AnswerList.insertItem(index, propValue as TFhirContractTermOfferAnswer)
  else if (propName = 'securityLabelNumber') then SecurityLabelNumberList.insertItem(index, asUnsignedInt(propValue))
  else if (propName = 'valuedItem') then ValuedItemList.insertItem(index, propValue as TFhirContractTermAssetValuedItem)
  else inherited;
end;

function TFhirContractTermAsset.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'scope') then result := TFhirCodeableConcept.create()
  else if (propName = 'type') then result := Type_List.new()
  else if (propName = 'typeReference') then result := TypeReferenceList.new()
  else if (propName = 'subtype') then result := SubtypeList.new()
  else if (propName = 'relationship') then result := TFhirCoding.create()
  else if (propName = 'context') then result := ContextList.new()
  else if (propName = 'condition') then result := TFhirString.create()
  else if (propName = 'periodType') then result := PeriodTypeList.new()
  else if (propName = 'period') then result := PeriodList.new()
  else if (propName = 'usePeriod') then result := UsePeriodList.new()
  else if (propName = 'text') then result := TFhirString.create()
  else if (propName = 'linkId') then result := LinkIdList.new()
  else if (propName = 'answer') then result := AnswerList.new()
  else if (propName = 'securityLabelNumber') then result := SecurityLabelNumberList.new()
  else if (propName = 'valuedItem') then result := ValuedItemList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermAsset.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'scope') then result := 'CodeableConcept'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'typeReference') then result := 'Reference'
  else if (propName = 'subtype') then result := 'CodeableConcept'
  else if (propName = 'relationship') then result := 'Coding'
  else if (propName = 'context') then result := 'BackboneElement'
  else if (propName = 'condition') then result := 'string'
  else if (propName = 'periodType') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'usePeriod') then result := 'Period'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'linkId') then result := 'string'
  else if (propName = 'answer') then result := ''
  else if (propName = 'securityLabelNumber') then result := 'unsignedInt'
  else if (propName = 'valuedItem') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermAsset.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'scope') then ScopeElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else if (propName = 'typeReference') then deletePropertyValue('typeReference', TypeReferenceList, value)
  else if (propName = 'subtype') then deletePropertyValue('subtype', SubtypeList, value)
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (propName = 'context') then deletePropertyValue('context', ContextList, value)
  else if (propName = 'condition') then ConditionElement := nil
  else if (propName = 'periodType') then deletePropertyValue('periodType', PeriodTypeList, value)
  else if (propName = 'period') then deletePropertyValue('period', PeriodList, value)
  else if (propName = 'usePeriod') then deletePropertyValue('usePeriod', UsePeriodList, value)
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'linkId') then deletePropertyValue('linkId', LinkIdList, value)
  else if (propName = 'answer') then deletePropertyValue('answer', AnswerList, value)
  else if (propName = 'securityLabelNumber') then deletePropertyValue('securityLabelNumber', SecurityLabelNumberList, value)
  else if (propName = 'valuedItem') then deletePropertyValue('valuedItem', ValuedItemList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermAsset.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'scope') then ScopeElement := new as TFhirCodeableConcept
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else if (propName = 'typeReference') then replacePropertyValue('typeReference', TypeReferenceList, existing, new)
  else if (propName = 'subtype') then replacePropertyValue('subtype', SubtypeList, existing, new)
  else if (propName = 'relationship') then RelationshipElement := new as TFhirCoding
  else if (propName = 'context') then replacePropertyValue('context', ContextList, existing, new)
  else if (propName = 'condition') then ConditionElement := asString(new)
  else if (propName = 'periodType') then replacePropertyValue('periodType', PeriodTypeList, existing, new)
  else if (propName = 'period') then replacePropertyValue('period', PeriodList, existing, new)
  else if (propName = 'usePeriod') then replacePropertyValue('usePeriod', UsePeriodList, existing, new)
  else if (propName = 'text') then TextElement := asString(new)
  else if (propName = 'linkId') then replacePropertyValue('linkId', LinkIdList, existing, new)
  else if (propName = 'answer') then replacePropertyValue('answer', AnswerList, existing, new)
  else if (propName = 'securityLabelNumber') then replacePropertyValue('securityLabelNumber', SecurityLabelNumberList, existing, new)
  else if (propName = 'valuedItem') then replacePropertyValue('valuedItem', ValuedItemList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermAsset.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination)
  else if (propName = 'typeReference') then TypeReferenceList.move(source, destination)
  else if (propName = 'subtype') then SubtypeList.move(source, destination)
  else if (propName = 'context') then ContextList.move(source, destination)
  else if (propName = 'periodType') then PeriodTypeList.move(source, destination)
  else if (propName = 'period') then PeriodList.move(source, destination)
  else if (propName = 'usePeriod') then UsePeriodList.move(source, destination)
  else if (propName = 'linkId') then LinkIdList.move(source, destination)
  else if (propName = 'answer') then AnswerList.move(source, destination)
  else if (propName = 'securityLabelNumber') then SecurityLabelNumberList.move(source, destination)
  else if (propName = 'valuedItem') then ValuedItemList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermAsset.fhirType : string;
begin
  result := 'Contract.term.asset';
end;

function TFhirContractTermAsset.Link : TFhirContractTermAsset;
begin
  result := TFhirContractTermAsset(inherited Link);
end;

function TFhirContractTermAsset.Clone : TFhirContractTermAsset;
begin
  result := TFhirContractTermAsset(inherited Clone);
end;

function TFhirContractTermAsset.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermAsset;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermAsset)) then
    result := false
  else
  begin
    o := TFhirContractTermAsset(other);
    result := compareDeep(scopeElement, o.scopeElement, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(typeReferenceList, o.typeReferenceList, true) and compareDeep(subtypeList, o.subtypeList, true) and 
      compareDeep(relationshipElement, o.relationshipElement, true) and compareDeep(contextList, o.contextList, true) and 
      compareDeep(conditionElement, o.conditionElement, true) and compareDeep(periodTypeList, o.periodTypeList, true) and 
      compareDeep(periodList, o.periodList, true) and compareDeep(usePeriodList, o.usePeriodList, true) and 
      compareDeep(textElement, o.textElement, true) and compareDeep(linkIdList, o.linkIdList, true) and 
      compareDeep(answerList, o.answerList, true) and compareDeep(securityLabelNumberList, o.securityLabelNumberList, true) and 
      compareDeep(valuedItemList, o.valuedItemList, true);
  end;
end;

function TFhirContractTermAsset.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FScope) and isEmptyProp(Ftype_List) and isEmptyProp(FtypeReferenceList) and isEmptyProp(FsubtypeList) and isEmptyProp(FRelationship) and isEmptyProp(FcontextList) and isEmptyProp(FCondition) and isEmptyProp(FperiodTypeList) and isEmptyProp(FperiodList) and isEmptyProp(FusePeriodList) and isEmptyProp(FText) and isEmptyProp(FlinkIdList) and isEmptyProp(FanswerList) and isEmptyProp(FsecurityLabelNumberList) and isEmptyProp(FvaluedItemList);
end;

procedure TFhirContractTermAsset.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('scope');
  fields.add('type');
  fields.add('typeReference');
  fields.add('subtype');
  fields.add('relationship');
  fields.add('context');
  fields.add('condition');
  fields.add('periodType');
  fields.add('period');
  fields.add('usePeriod');
  fields.add('text');
  fields.add('linkId');
  fields.add('answer');
  fields.add('securityLabelNumber');
  fields.add('valuedItem');
end;

function TFhirContractTermAsset.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FType_List.sizeInBytes(magic));
  inc(result, FTypeReferenceList.sizeInBytes(magic));
  inc(result, FSubtypeList.sizeInBytes(magic));
  inc(result, FContextList.sizeInBytes(magic));
  inc(result, FPeriodTypeList.sizeInBytes(magic));
  inc(result, FPeriodList.sizeInBytes(magic));
  inc(result, FUsePeriodList.sizeInBytes(magic));
  inc(result, FLinkIdList.sizeInBytes(magic));
  inc(result, FAnswerList.sizeInBytes(magic));
  inc(result, FSecurityLabelNumberList.sizeInBytes(magic));
  inc(result, FValuedItemList.sizeInBytes(magic));
end;

procedure TFhirContractTermAsset.SetScope(value : TFhirCodeableConcept);
begin
  FScope.free;
  FScope := value;
end;

function TFhirContractTermAsset.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirContractTermAsset.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

function TFhirContractTermAsset.GetTypeReferenceList : TFhirReferenceList;
begin
  if FTypeReferenceList = nil then
    FTypeReferenceList := TFhirReferenceList.Create;
  result := FTypeReferenceList;
end;

function TFhirContractTermAsset.GetHasTypeReferenceList : boolean;
begin
  result := (FTypeReferenceList <> nil) and (FTypeReferenceList.count > 0);
end;

function TFhirContractTermAsset.GetSubtypeList : TFhirCodeableConceptList;
begin
  if FSubtypeList = nil then
    FSubtypeList := TFhirCodeableConceptList.Create;
  result := FSubtypeList;
end;

function TFhirContractTermAsset.GetHasSubtypeList : boolean;
begin
  result := (FSubtypeList <> nil) and (FSubtypeList.count > 0);
end;

procedure TFhirContractTermAsset.SetRelationship(value : TFhirCoding);
begin
  FRelationship.free;
  FRelationship := value;
end;

function TFhirContractTermAsset.GetContextList : TFhirContractTermAssetContextList;
begin
  if FContextList = nil then
    FContextList := TFhirContractTermAssetContextList.Create;
  result := FContextList;
end;

function TFhirContractTermAsset.GetHasContextList : boolean;
begin
  result := (FContextList <> nil) and (FContextList.count > 0);
end;

procedure TFhirContractTermAsset.SetCondition(value : TFhirString);
begin
  FCondition.free;
  FCondition := value;
end;

function TFhirContractTermAsset.GetConditionST : String;
begin
  if FCondition = nil then
    result := ''
  else
    result := FCondition.value;
end;

procedure TFhirContractTermAsset.SetConditionST(value : String);
begin
  if value <> '' then
  begin
    if FCondition = nil then
      FCondition := TFhirString.create;
    FCondition.value := value
  end
  else if FCondition <> nil then
    FCondition.value := '';
end;

function TFhirContractTermAsset.GetPeriodTypeList : TFhirCodeableConceptList;
begin
  if FPeriodTypeList = nil then
    FPeriodTypeList := TFhirCodeableConceptList.Create;
  result := FPeriodTypeList;
end;

function TFhirContractTermAsset.GetHasPeriodTypeList : boolean;
begin
  result := (FPeriodTypeList <> nil) and (FPeriodTypeList.count > 0);
end;

function TFhirContractTermAsset.GetPeriodList : TFhirPeriodList;
begin
  if FPeriodList = nil then
    FPeriodList := TFhirPeriodList.Create;
  result := FPeriodList;
end;

function TFhirContractTermAsset.GetHasPeriodList : boolean;
begin
  result := (FPeriodList <> nil) and (FPeriodList.count > 0);
end;

function TFhirContractTermAsset.GetUsePeriodList : TFhirPeriodList;
begin
  if FUsePeriodList = nil then
    FUsePeriodList := TFhirPeriodList.Create;
  result := FUsePeriodList;
end;

function TFhirContractTermAsset.GetHasUsePeriodList : boolean;
begin
  result := (FUsePeriodList <> nil) and (FUsePeriodList.count > 0);
end;

procedure TFhirContractTermAsset.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

function TFhirContractTermAsset.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirContractTermAsset.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

function TFhirContractTermAsset.GetLinkIdList : TFhirStringList;
begin
  if FLinkIdList = nil then
    FLinkIdList := TFhirStringList.Create;
  result := FLinkIdList;
end;

function TFhirContractTermAsset.GetHasLinkIdList : boolean;
begin
  result := (FLinkIdList <> nil) and (FLinkIdList.count > 0);
end;

function TFhirContractTermAsset.GetAnswerList : TFhirContractTermOfferAnswerList;
begin
  if FAnswerList = nil then
    FAnswerList := TFhirContractTermOfferAnswerList.Create;
  result := FAnswerList;
end;

function TFhirContractTermAsset.GetHasAnswerList : boolean;
begin
  result := (FAnswerList <> nil) and (FAnswerList.count > 0);
end;

function TFhirContractTermAsset.GetSecurityLabelNumberList : TFhirUnsignedIntList;
begin
  if FSecurityLabelNumberList = nil then
    FSecurityLabelNumberList := TFhirUnsignedIntList.Create;
  result := FSecurityLabelNumberList;
end;

function TFhirContractTermAsset.GetHasSecurityLabelNumberList : boolean;
begin
  result := (FSecurityLabelNumberList <> nil) and (FSecurityLabelNumberList.count > 0);
end;

function TFhirContractTermAsset.GetValuedItemList : TFhirContractTermAssetValuedItemList;
begin
  if FValuedItemList = nil then
    FValuedItemList := TFhirContractTermAssetValuedItemList.Create;
  result := FValuedItemList;
end;

function TFhirContractTermAsset.GetHasValuedItemList : boolean;
begin
  result := (FValuedItemList <> nil) and (FValuedItemList.count > 0);
end;

{ TFhirContractTermAssetListEnumerator }

constructor TFhirContractTermAssetListEnumerator.Create(list : TFhirContractTermAssetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermAssetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermAssetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermAssetListEnumerator.GetCurrent : TFhirContractTermAsset;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermAssetListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractTermAssetList }

function TFhirContractTermAssetList.AddItem(value: TFhirContractTermAsset): TFhirContractTermAsset;
begin
  assert(value.ClassName = 'TFhirContractTermAsset', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermAsset');
  add(value);
  result := value;
end;

function TFhirContractTermAssetList.Append: TFhirContractTermAsset;
begin
  result := TFhirContractTermAsset.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermAssetList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermAssetList.GetEnumerator : TFhirContractTermAssetListEnumerator;
begin
  result := TFhirContractTermAssetListEnumerator.Create(self.link);
end;

function TFhirContractTermAssetList.Clone: TFhirContractTermAssetList;
begin
  result := TFhirContractTermAssetList(inherited Clone);
end;

function TFhirContractTermAssetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermAssetList.GetItemN(index: Integer): TFhirContractTermAsset;
begin
  result := TFhirContractTermAsset(ObjectByIndex[index]);
end;

function TFhirContractTermAssetList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermAsset;
end;
function TFhirContractTermAssetList.IndexOf(value: TFhirContractTermAsset): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermAssetList.Insert(index: Integer): TFhirContractTermAsset;
begin
  result := TFhirContractTermAsset.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermAssetList.InsertItem(index: Integer; value: TFhirContractTermAsset);
begin
  assert(value is TFhirContractTermAsset);
  Inherited Insert(index, value);
end;

function TFhirContractTermAssetList.Item(index: Integer): TFhirContractTermAsset;
begin
  result := TFhirContractTermAsset(ObjectByIndex[index]);
end;

function TFhirContractTermAssetList.Link: TFhirContractTermAssetList;
begin
  result := TFhirContractTermAssetList(inherited Link);
end;

procedure TFhirContractTermAssetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermAssetList.SetItemByIndex(index: Integer; value: TFhirContractTermAsset);
begin
  assert(value is TFhirContractTermAsset);
  FhirContractTermAssets[index] := value;
end;

procedure TFhirContractTermAssetList.SetItemN(index: Integer; value: TFhirContractTermAsset);
begin
  assert(value is TFhirContractTermAsset);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermAssetContext }

constructor TFhirContractTermAssetContext.Create;
begin
  inherited;
end;

destructor TFhirContractTermAssetContext.Destroy;
begin
  FReference.free;
  FCodeList.Free;
  FText.free;
  inherited;
end;

procedure TFhirContractTermAssetContext.Assign(oSource : TFslObject);
begin
  inherited;
  reference := TFhirContractTermAssetContext(oSource).reference.Clone;
  if (TFhirContractTermAssetContext(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirContractTermAssetContext(oSource).FCodeList);
  end;
  textElement := TFhirContractTermAssetContext(oSource).textElement.Clone;
end;

procedure TFhirContractTermAssetContext.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
end;

procedure TFhirContractTermAssetContext.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference', false, TFhirReference, FReference.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));
end;

function TFhirContractTermAssetContext.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermAssetContext.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirContractTermAssetContext.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'reference') then result := TFhirReference.create()
  else if (propName = 'code') then result := CodeList.new()
  else if (propName = 'text') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermAssetContext.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'reference') then result := 'Reference'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'text') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermAssetContext.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'reference') then ReferenceElement := nil
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value)
  else if (propName = 'text') then TextElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermAssetContext.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'reference') then ReferenceElement := new as TFhirReference
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new)
  else if (propName = 'text') then TextElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermAssetContext.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'code') then CodeList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermAssetContext.fhirType : string;
begin
  result := 'Contract.term.asset.context';
end;

function TFhirContractTermAssetContext.Link : TFhirContractTermAssetContext;
begin
  result := TFhirContractTermAssetContext(inherited Link);
end;

function TFhirContractTermAssetContext.Clone : TFhirContractTermAssetContext;
begin
  result := TFhirContractTermAssetContext(inherited Clone);
end;

function TFhirContractTermAssetContext.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermAssetContext;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermAssetContext)) then
    result := false
  else
  begin
    o := TFhirContractTermAssetContext(other);
    result := compareDeep(referenceElement, o.referenceElement, true) and compareDeep(codeList, o.codeList, true) and 
      compareDeep(textElement, o.textElement, true);
  end;
end;

function TFhirContractTermAssetContext.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FReference) and isEmptyProp(FcodeList) and isEmptyProp(FText);
end;

procedure TFhirContractTermAssetContext.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('reference');
  fields.add('code');
  fields.add('text');
end;

function TFhirContractTermAssetContext.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCodeList.sizeInBytes(magic));
end;

procedure TFhirContractTermAssetContext.SetReference(value : TFhirReference);
begin
  FReference.free;
  FReference := value;
end;

function TFhirContractTermAssetContext.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

function TFhirContractTermAssetContext.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

procedure TFhirContractTermAssetContext.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

function TFhirContractTermAssetContext.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirContractTermAssetContext.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

{ TFhirContractTermAssetContextListEnumerator }

constructor TFhirContractTermAssetContextListEnumerator.Create(list : TFhirContractTermAssetContextList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermAssetContextListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermAssetContextListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermAssetContextListEnumerator.GetCurrent : TFhirContractTermAssetContext;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermAssetContextListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractTermAssetContextList }

function TFhirContractTermAssetContextList.AddItem(value: TFhirContractTermAssetContext): TFhirContractTermAssetContext;
begin
  assert(value.ClassName = 'TFhirContractTermAssetContext', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermAssetContext');
  add(value);
  result := value;
end;

function TFhirContractTermAssetContextList.Append: TFhirContractTermAssetContext;
begin
  result := TFhirContractTermAssetContext.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermAssetContextList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermAssetContextList.GetEnumerator : TFhirContractTermAssetContextListEnumerator;
begin
  result := TFhirContractTermAssetContextListEnumerator.Create(self.link);
end;

function TFhirContractTermAssetContextList.Clone: TFhirContractTermAssetContextList;
begin
  result := TFhirContractTermAssetContextList(inherited Clone);
end;

function TFhirContractTermAssetContextList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermAssetContextList.GetItemN(index: Integer): TFhirContractTermAssetContext;
begin
  result := TFhirContractTermAssetContext(ObjectByIndex[index]);
end;

function TFhirContractTermAssetContextList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermAssetContext;
end;
function TFhirContractTermAssetContextList.IndexOf(value: TFhirContractTermAssetContext): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermAssetContextList.Insert(index: Integer): TFhirContractTermAssetContext;
begin
  result := TFhirContractTermAssetContext.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermAssetContextList.InsertItem(index: Integer; value: TFhirContractTermAssetContext);
begin
  assert(value is TFhirContractTermAssetContext);
  Inherited Insert(index, value);
end;

function TFhirContractTermAssetContextList.Item(index: Integer): TFhirContractTermAssetContext;
begin
  result := TFhirContractTermAssetContext(ObjectByIndex[index]);
end;

function TFhirContractTermAssetContextList.Link: TFhirContractTermAssetContextList;
begin
  result := TFhirContractTermAssetContextList(inherited Link);
end;

procedure TFhirContractTermAssetContextList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermAssetContextList.SetItemByIndex(index: Integer; value: TFhirContractTermAssetContext);
begin
  assert(value is TFhirContractTermAssetContext);
  FhirContractTermAssetContexts[index] := value;
end;

procedure TFhirContractTermAssetContextList.SetItemN(index: Integer; value: TFhirContractTermAssetContext);
begin
  assert(value is TFhirContractTermAssetContext);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermAssetValuedItem }

constructor TFhirContractTermAssetValuedItem.Create;
begin
  inherited;
end;

destructor TFhirContractTermAssetValuedItem.Destroy;
begin
  FEntity.free;
  FIdentifier.free;
  FEffectiveTime.free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FPoints.free;
  FNet.free;
  FPayment.free;
  FPaymentDate.free;
  FResponsible.free;
  FRecipient.free;
  FLinkIdList.Free;
  FSecurityLabelNumberList.Free;
  inherited;
end;

procedure TFhirContractTermAssetValuedItem.Assign(oSource : TFslObject);
begin
  inherited;
  entity := TFhirContractTermAssetValuedItem(oSource).entity.Clone;
  identifier := TFhirContractTermAssetValuedItem(oSource).identifier.Clone;
  effectiveTimeElement := TFhirContractTermAssetValuedItem(oSource).effectiveTimeElement.Clone;
  quantity := TFhirContractTermAssetValuedItem(oSource).quantity.Clone;
  unitPrice := TFhirContractTermAssetValuedItem(oSource).unitPrice.Clone;
  factorElement := TFhirContractTermAssetValuedItem(oSource).factorElement.Clone;
  pointsElement := TFhirContractTermAssetValuedItem(oSource).pointsElement.Clone;
  net := TFhirContractTermAssetValuedItem(oSource).net.Clone;
  paymentElement := TFhirContractTermAssetValuedItem(oSource).paymentElement.Clone;
  paymentDateElement := TFhirContractTermAssetValuedItem(oSource).paymentDateElement.Clone;
  responsible := TFhirContractTermAssetValuedItem(oSource).responsible.Clone;
  recipient := TFhirContractTermAssetValuedItem(oSource).recipient.Clone;
  if (TFhirContractTermAssetValuedItem(oSource).FLinkIdList = nil) then
  begin
    FLinkIdList.free;
    FLinkIdList := nil;
  end
  else
  begin
    if FLinkIdList = nil then
      FLinkIdList := TFhirStringList.Create;
    FLinkIdList.Assign(TFhirContractTermAssetValuedItem(oSource).FLinkIdList);
  end;
  if (TFhirContractTermAssetValuedItem(oSource).FSecurityLabelNumberList = nil) then
  begin
    FSecurityLabelNumberList.free;
    FSecurityLabelNumberList := nil;
  end
  else
  begin
    if FSecurityLabelNumberList = nil then
      FSecurityLabelNumberList := TFhirUnsignedIntList.Create;
    FSecurityLabelNumberList.Assign(TFhirContractTermAssetValuedItem(oSource).FSecurityLabelNumberList);
  end;
end;

procedure TFhirContractTermAssetValuedItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'entity[x]') or (child_name = 'entity') Then
     list.add(self.link, 'entity[x]', FEntity.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'effectiveTime') Then
     list.add(self.link, 'effectiveTime', FEffectiveTime.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'points') Then
     list.add(self.link, 'points', FPoints.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'payment') Then
     list.add(self.link, 'payment', FPayment.Link);
  if (child_name = 'paymentDate') Then
     list.add(self.link, 'paymentDate', FPaymentDate.Link);
  if (child_name = 'responsible') Then
     list.add(self.link, 'responsible', FResponsible.Link);
  if (child_name = 'recipient') Then
     list.add(self.link, 'recipient', FRecipient.Link);
  if (child_name = 'linkId') Then
    list.addAll(self, 'linkId', FLinkIdList);
  if (child_name = 'securityLabelNumber') Then
    list.addAll(self, 'securityLabelNumber', FSecurityLabelNumberList);
end;

procedure TFhirContractTermAssetValuedItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'entity[x]', 'CodeableConcept|Reference', false, TFhirDataType, FEntity.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'effectiveTime', 'dateTime', false, TFhirDateTime, FEffectiveTime.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));
  oList.add(TFHIRProperty.create(self, 'points', 'decimal', false, TFhirDecimal, FPoints.Link));
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));
  oList.add(TFHIRProperty.create(self, 'payment', 'string', false, TFhirString, FPayment.Link));
  oList.add(TFHIRProperty.create(self, 'paymentDate', 'dateTime', false, TFhirDateTime, FPaymentDate.Link));
  oList.add(TFHIRProperty.create(self, 'responsible', 'Reference', false, TFhirReference, FResponsible.Link));
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference', false, TFhirReference, FRecipient.Link));
  oList.add(TFHIRProperty.create(self, 'linkId', 'string', true, TFhirString, FLinkIdList.Link));
  oList.add(TFHIRProperty.create(self, 'securityLabelNumber', 'unsignedInt', true, TFhirUnsignedInt, FSecurityLabelNumberList.Link));
end;

function TFhirContractTermAssetValuedItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then
  begin
    Entity := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'effectiveTime') then
  begin
    EffectiveTimeElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'points') then
  begin
    PointsElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'payment') then
  begin
    PaymentElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'paymentDate') then
  begin
    PaymentDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'responsible') then
  begin
    Responsible := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    Recipient := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'linkId') then
  begin
    LinkIdList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'securityLabelNumber') then
  begin
    SecurityLabelNumberList.add(asUnsignedInt(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermAssetValuedItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'linkId') then LinkIdList.insertItem(index, asString(propValue))
  else if (propName = 'securityLabelNumber') then SecurityLabelNumberList.insertItem(index, asUnsignedInt(propValue))
  else inherited;
end;

function TFhirContractTermAssetValuedItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Entity')
  else if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'effectiveTime') then result := TFhirDateTime.create()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'unitPrice') then result := TFhirMoney.create()
  else if (propName = 'factor') then result := TFhirDecimal.create()
  else if (propName = 'points') then result := TFhirDecimal.create()
  else if (propName = 'net') then result := TFhirMoney.create()
  else if (propName = 'payment') then result := TFhirString.create()
  else if (propName = 'paymentDate') then result := TFhirDateTime.create()
  else if (propName = 'responsible') then result := TFhirReference.create()
  else if (propName = 'recipient') then result := TFhirReference.create()
  else if (propName = 'linkId') then result := LinkIdList.new()
  else if (propName = 'securityLabelNumber') then result := SecurityLabelNumberList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermAssetValuedItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'entity[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'effectiveTime') then result := 'dateTime'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'points') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'payment') then result := 'string'
  else if (propName = 'paymentDate') then result := 'dateTime'
  else if (propName = 'responsible') then result := 'Reference'
  else if (propName = 'recipient') then result := 'Reference'
  else if (propName = 'linkId') then result := 'string'
  else if (propName = 'securityLabelNumber') then result := 'unsignedInt'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermAssetValuedItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then EntityElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'effectiveTime') then EffectiveTimeElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'points') then PointsElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'payment') then PaymentElement := nil
  else if (propName = 'paymentDate') then PaymentDateElement := nil
  else if (propName = 'responsible') then ResponsibleElement := nil
  else if (propName = 'recipient') then RecipientElement := nil
  else if (propName = 'linkId') then deletePropertyValue('linkId', LinkIdList, value)
  else if (propName = 'securityLabelNumber') then deletePropertyValue('securityLabelNumber', SecurityLabelNumberList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermAssetValuedItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then EntityElement := new as TFhirDataType
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'effectiveTime') then EffectiveTimeElement := asDateTime(new)
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney
  else if (propName = 'factor') then FactorElement := asDecimal(new)
  else if (propName = 'points') then PointsElement := asDecimal(new)
  else if (propName = 'net') then NetElement := new as TFhirMoney
  else if (propName = 'payment') then PaymentElement := asString(new)
  else if (propName = 'paymentDate') then PaymentDateElement := asDateTime(new)
  else if (propName = 'responsible') then ResponsibleElement := new as TFhirReference
  else if (propName = 'recipient') then RecipientElement := new as TFhirReference
  else if (propName = 'linkId') then replacePropertyValue('linkId', LinkIdList, existing, new)
  else if (propName = 'securityLabelNumber') then replacePropertyValue('securityLabelNumber', SecurityLabelNumberList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermAssetValuedItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'linkId') then LinkIdList.move(source, destination)
  else if (propName = 'securityLabelNumber') then SecurityLabelNumberList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermAssetValuedItem.fhirType : string;
begin
  result := 'Contract.term.asset.valuedItem';
end;

function TFhirContractTermAssetValuedItem.Link : TFhirContractTermAssetValuedItem;
begin
  result := TFhirContractTermAssetValuedItem(inherited Link);
end;

function TFhirContractTermAssetValuedItem.Clone : TFhirContractTermAssetValuedItem;
begin
  result := TFhirContractTermAssetValuedItem(inherited Clone);
end;

function TFhirContractTermAssetValuedItem.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermAssetValuedItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermAssetValuedItem)) then
    result := false
  else
  begin
    o := TFhirContractTermAssetValuedItem(other);
    result := compareDeep(entityElement, o.entityElement, true) and compareDeep(identifierElement, o.identifierElement, true) and 
      compareDeep(effectiveTimeElement, o.effectiveTimeElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and 
      compareDeep(pointsElement, o.pointsElement, true) and compareDeep(netElement, o.netElement, true) and 
      compareDeep(paymentElement, o.paymentElement, true) and compareDeep(paymentDateElement, o.paymentDateElement, true) and 
      compareDeep(responsibleElement, o.responsibleElement, true) and compareDeep(recipientElement, o.recipientElement, true) and 
      compareDeep(linkIdList, o.linkIdList, true) and compareDeep(securityLabelNumberList, o.securityLabelNumberList, true);
  end;
end;

function TFhirContractTermAssetValuedItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FEntity) and isEmptyProp(FIdentifier) and isEmptyProp(FEffectiveTime) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FPoints) and isEmptyProp(FNet) and isEmptyProp(FPayment) and isEmptyProp(FPaymentDate) and isEmptyProp(FResponsible) and isEmptyProp(FRecipient) and isEmptyProp(FlinkIdList) and isEmptyProp(FsecurityLabelNumberList);
end;

procedure TFhirContractTermAssetValuedItem.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('entity[x]');
  fields.add('identifier');
  fields.add('effectiveTime');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('points');
  fields.add('net');
  fields.add('payment');
  fields.add('paymentDate');
  fields.add('responsible');
  fields.add('recipient');
  fields.add('linkId');
  fields.add('securityLabelNumber');
end;

function TFhirContractTermAssetValuedItem.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FLinkIdList.sizeInBytes(magic));
  inc(result, FSecurityLabelNumberList.sizeInBytes(magic));
end;

procedure TFhirContractTermAssetValuedItem.SetEntity(value : TFhirDataType);
begin
  FEntity.free;
  FEntity := value;
end;

procedure TFhirContractTermAssetValuedItem.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirContractTermAssetValuedItem.SetEffectiveTime(value : TFhirDateTime);
begin
  FEffectiveTime.free;
  FEffectiveTime := value;
end;

function TFhirContractTermAssetValuedItem.GetEffectiveTimeST : TFslDateTime;
begin
  if FEffectiveTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FEffectiveTime.value;
end;

procedure TFhirContractTermAssetValuedItem.SetEffectiveTimeST(value : TFslDateTime);
begin
  if FEffectiveTime = nil then
    FEffectiveTime := TFhirDateTime.create;
  FEffectiveTime.value := value
end;

procedure TFhirContractTermAssetValuedItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirContractTermAssetValuedItem.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

procedure TFhirContractTermAssetValuedItem.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

function TFhirContractTermAssetValuedItem.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirContractTermAssetValuedItem.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirContractTermAssetValuedItem.SetPoints(value : TFhirDecimal);
begin
  FPoints.free;
  FPoints := value;
end;

function TFhirContractTermAssetValuedItem.GetPointsST : String;
begin
  if FPoints = nil then
    result := ''
  else
    result := FPoints.value;
end;

procedure TFhirContractTermAssetValuedItem.SetPointsST(value : String);
begin
  if value <> '' then
  begin
    if FPoints = nil then
      FPoints := TFhirDecimal.create;
    FPoints.value := value
  end
  else if FPoints <> nil then
    FPoints.value := '';
end;

procedure TFhirContractTermAssetValuedItem.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

procedure TFhirContractTermAssetValuedItem.SetPayment(value : TFhirString);
begin
  FPayment.free;
  FPayment := value;
end;

function TFhirContractTermAssetValuedItem.GetPaymentST : String;
begin
  if FPayment = nil then
    result := ''
  else
    result := FPayment.value;
end;

procedure TFhirContractTermAssetValuedItem.SetPaymentST(value : String);
begin
  if value <> '' then
  begin
    if FPayment = nil then
      FPayment := TFhirString.create;
    FPayment.value := value
  end
  else if FPayment <> nil then
    FPayment.value := '';
end;

procedure TFhirContractTermAssetValuedItem.SetPaymentDate(value : TFhirDateTime);
begin
  FPaymentDate.free;
  FPaymentDate := value;
end;

function TFhirContractTermAssetValuedItem.GetPaymentDateST : TFslDateTime;
begin
  if FPaymentDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FPaymentDate.value;
end;

procedure TFhirContractTermAssetValuedItem.SetPaymentDateST(value : TFslDateTime);
begin
  if FPaymentDate = nil then
    FPaymentDate := TFhirDateTime.create;
  FPaymentDate.value := value
end;

procedure TFhirContractTermAssetValuedItem.SetResponsible(value : TFhirReference);
begin
  FResponsible.free;
  FResponsible := value;
end;

procedure TFhirContractTermAssetValuedItem.SetRecipient(value : TFhirReference);
begin
  FRecipient.free;
  FRecipient := value;
end;

function TFhirContractTermAssetValuedItem.GetLinkIdList : TFhirStringList;
begin
  if FLinkIdList = nil then
    FLinkIdList := TFhirStringList.Create;
  result := FLinkIdList;
end;

function TFhirContractTermAssetValuedItem.GetHasLinkIdList : boolean;
begin
  result := (FLinkIdList <> nil) and (FLinkIdList.count > 0);
end;

function TFhirContractTermAssetValuedItem.GetSecurityLabelNumberList : TFhirUnsignedIntList;
begin
  if FSecurityLabelNumberList = nil then
    FSecurityLabelNumberList := TFhirUnsignedIntList.Create;
  result := FSecurityLabelNumberList;
end;

function TFhirContractTermAssetValuedItem.GetHasSecurityLabelNumberList : boolean;
begin
  result := (FSecurityLabelNumberList <> nil) and (FSecurityLabelNumberList.count > 0);
end;

{ TFhirContractTermAssetValuedItemListEnumerator }

constructor TFhirContractTermAssetValuedItemListEnumerator.Create(list : TFhirContractTermAssetValuedItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermAssetValuedItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermAssetValuedItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermAssetValuedItemListEnumerator.GetCurrent : TFhirContractTermAssetValuedItem;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermAssetValuedItemListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractTermAssetValuedItemList }

function TFhirContractTermAssetValuedItemList.AddItem(value: TFhirContractTermAssetValuedItem): TFhirContractTermAssetValuedItem;
begin
  assert(value.ClassName = 'TFhirContractTermAssetValuedItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermAssetValuedItem');
  add(value);
  result := value;
end;

function TFhirContractTermAssetValuedItemList.Append: TFhirContractTermAssetValuedItem;
begin
  result := TFhirContractTermAssetValuedItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermAssetValuedItemList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermAssetValuedItemList.GetEnumerator : TFhirContractTermAssetValuedItemListEnumerator;
begin
  result := TFhirContractTermAssetValuedItemListEnumerator.Create(self.link);
end;

function TFhirContractTermAssetValuedItemList.Clone: TFhirContractTermAssetValuedItemList;
begin
  result := TFhirContractTermAssetValuedItemList(inherited Clone);
end;

function TFhirContractTermAssetValuedItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermAssetValuedItemList.GetItemN(index: Integer): TFhirContractTermAssetValuedItem;
begin
  result := TFhirContractTermAssetValuedItem(ObjectByIndex[index]);
end;

function TFhirContractTermAssetValuedItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermAssetValuedItem;
end;
function TFhirContractTermAssetValuedItemList.IndexOf(value: TFhirContractTermAssetValuedItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermAssetValuedItemList.Insert(index: Integer): TFhirContractTermAssetValuedItem;
begin
  result := TFhirContractTermAssetValuedItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermAssetValuedItemList.InsertItem(index: Integer; value: TFhirContractTermAssetValuedItem);
begin
  assert(value is TFhirContractTermAssetValuedItem);
  Inherited Insert(index, value);
end;

function TFhirContractTermAssetValuedItemList.Item(index: Integer): TFhirContractTermAssetValuedItem;
begin
  result := TFhirContractTermAssetValuedItem(ObjectByIndex[index]);
end;

function TFhirContractTermAssetValuedItemList.Link: TFhirContractTermAssetValuedItemList;
begin
  result := TFhirContractTermAssetValuedItemList(inherited Link);
end;

procedure TFhirContractTermAssetValuedItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermAssetValuedItemList.SetItemByIndex(index: Integer; value: TFhirContractTermAssetValuedItem);
begin
  assert(value is TFhirContractTermAssetValuedItem);
  FhirContractTermAssetValuedItems[index] := value;
end;

procedure TFhirContractTermAssetValuedItemList.SetItemN(index: Integer; value: TFhirContractTermAssetValuedItem);
begin
  assert(value is TFhirContractTermAssetValuedItem);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermAction }

constructor TFhirContractTermAction.Create;
begin
  inherited;
end;

destructor TFhirContractTermAction.Destroy;
begin
  FDoNotPerform.free;
  FType_.free;
  FSubjectList.Free;
  FIntent.free;
  FLinkIdList.Free;
  FStatus.free;
  FContext.free;
  FContextLinkIdList.Free;
  FOccurrence.free;
  FRequesterList.Free;
  FRequesterLinkIdList.Free;
  FPerformerTypeList.Free;
  FPerformerRole.free;
  FPerformer.free;
  FPerformerLinkIdList.Free;
  FReasonList.Free;
  FReasonLinkIdList.Free;
  FNoteList.Free;
  FSecurityLabelNumberList.Free;
  inherited;
end;

procedure TFhirContractTermAction.Assign(oSource : TFslObject);
begin
  inherited;
  doNotPerformElement := TFhirContractTermAction(oSource).doNotPerformElement.Clone;
  type_ := TFhirContractTermAction(oSource).type_.Clone;
  if (TFhirContractTermAction(oSource).FSubjectList = nil) then
  begin
    FSubjectList.free;
    FSubjectList := nil;
  end
  else
  begin
    if FSubjectList = nil then
      FSubjectList := TFhirContractTermActionSubjectList.Create;
    FSubjectList.Assign(TFhirContractTermAction(oSource).FSubjectList);
  end;
  intent := TFhirContractTermAction(oSource).intent.Clone;
  if (TFhirContractTermAction(oSource).FLinkIdList = nil) then
  begin
    FLinkIdList.free;
    FLinkIdList := nil;
  end
  else
  begin
    if FLinkIdList = nil then
      FLinkIdList := TFhirStringList.Create;
    FLinkIdList.Assign(TFhirContractTermAction(oSource).FLinkIdList);
  end;
  status := TFhirContractTermAction(oSource).status.Clone;
  context := TFhirContractTermAction(oSource).context.Clone;
  if (TFhirContractTermAction(oSource).FContextLinkIdList = nil) then
  begin
    FContextLinkIdList.free;
    FContextLinkIdList := nil;
  end
  else
  begin
    if FContextLinkIdList = nil then
      FContextLinkIdList := TFhirStringList.Create;
    FContextLinkIdList.Assign(TFhirContractTermAction(oSource).FContextLinkIdList);
  end;
  occurrence := TFhirContractTermAction(oSource).occurrence.Clone;
  if (TFhirContractTermAction(oSource).FRequesterList = nil) then
  begin
    FRequesterList.free;
    FRequesterList := nil;
  end
  else
  begin
    if FRequesterList = nil then
      FRequesterList := TFhirReferenceList.Create;
    FRequesterList.Assign(TFhirContractTermAction(oSource).FRequesterList);
  end;
  if (TFhirContractTermAction(oSource).FRequesterLinkIdList = nil) then
  begin
    FRequesterLinkIdList.free;
    FRequesterLinkIdList := nil;
  end
  else
  begin
    if FRequesterLinkIdList = nil then
      FRequesterLinkIdList := TFhirStringList.Create;
    FRequesterLinkIdList.Assign(TFhirContractTermAction(oSource).FRequesterLinkIdList);
  end;
  if (TFhirContractTermAction(oSource).FPerformerTypeList = nil) then
  begin
    FPerformerTypeList.free;
    FPerformerTypeList := nil;
  end
  else
  begin
    if FPerformerTypeList = nil then
      FPerformerTypeList := TFhirCodeableConceptList.Create;
    FPerformerTypeList.Assign(TFhirContractTermAction(oSource).FPerformerTypeList);
  end;
  performerRole := TFhirContractTermAction(oSource).performerRole.Clone;
  performer := TFhirContractTermAction(oSource).performer.Clone;
  if (TFhirContractTermAction(oSource).FPerformerLinkIdList = nil) then
  begin
    FPerformerLinkIdList.free;
    FPerformerLinkIdList := nil;
  end
  else
  begin
    if FPerformerLinkIdList = nil then
      FPerformerLinkIdList := TFhirStringList.Create;
    FPerformerLinkIdList.Assign(TFhirContractTermAction(oSource).FPerformerLinkIdList);
  end;
  if (TFhirContractTermAction(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableReferenceList.Create;
    FReasonList.Assign(TFhirContractTermAction(oSource).FReasonList);
  end;
  if (TFhirContractTermAction(oSource).FReasonLinkIdList = nil) then
  begin
    FReasonLinkIdList.free;
    FReasonLinkIdList := nil;
  end
  else
  begin
    if FReasonLinkIdList = nil then
      FReasonLinkIdList := TFhirStringList.Create;
    FReasonLinkIdList.Assign(TFhirContractTermAction(oSource).FReasonLinkIdList);
  end;
  if (TFhirContractTermAction(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirContractTermAction(oSource).FNoteList);
  end;
  if (TFhirContractTermAction(oSource).FSecurityLabelNumberList = nil) then
  begin
    FSecurityLabelNumberList.free;
    FSecurityLabelNumberList := nil;
  end
  else
  begin
    if FSecurityLabelNumberList = nil then
      FSecurityLabelNumberList := TFhirUnsignedIntList.Create;
    FSecurityLabelNumberList.Assign(TFhirContractTermAction(oSource).FSecurityLabelNumberList);
  end;
end;

procedure TFhirContractTermAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'doNotPerform') Then
     list.add(self.link, 'doNotPerform', FDoNotPerform.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subject') Then
    list.addAll(self, 'subject', FSubjectList);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'linkId') Then
    list.addAll(self, 'linkId', FLinkIdList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'contextLinkId') Then
    list.addAll(self, 'contextLinkId', FContextLinkIdList);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'requester') Then
    list.addAll(self, 'requester', FRequesterList);
  if (child_name = 'requesterLinkId') Then
    list.addAll(self, 'requesterLinkId', FRequesterLinkIdList);
  if (child_name = 'performerType') Then
    list.addAll(self, 'performerType', FPerformerTypeList);
  if (child_name = 'performerRole') Then
     list.add(self.link, 'performerRole', FPerformerRole.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
  if (child_name = 'performerLinkId') Then
    list.addAll(self, 'performerLinkId', FPerformerLinkIdList);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'reasonLinkId') Then
    list.addAll(self, 'reasonLinkId', FReasonLinkIdList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'securityLabelNumber') Then
    list.addAll(self, 'securityLabelNumber', FSecurityLabelNumberList);
end;

procedure TFhirContractTermAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'doNotPerform', 'boolean', false, TFhirBoolean, FDoNotPerform.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'BackboneElement', true, TFhirContractTermActionSubject, FSubjectList.Link));
  oList.add(TFHIRProperty.create(self, 'intent', 'CodeableConcept', false, TFhirCodeableConcept, FIntent.Link));
  oList.add(TFHIRProperty.create(self, 'linkId', 'string', true, TFhirString, FLinkIdList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'context', 'Reference', false, TFhirReference, FContext.Link));
  oList.add(TFHIRProperty.create(self, 'contextLinkId', 'string', true, TFhirString, FContextLinkIdList.Link));
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period|Timing', false, TFhirDataType, FOccurrence.Link));
  oList.add(TFHIRProperty.create(self, 'requester', 'Reference', true, TFhirReference, FRequesterList.Link));
  oList.add(TFHIRProperty.create(self, 'requesterLinkId', 'string', true, TFhirString, FRequesterLinkIdList.Link));
  oList.add(TFHIRProperty.create(self, 'performerType', 'CodeableConcept', true, TFhirCodeableConcept, FPerformerTypeList.Link));
  oList.add(TFHIRProperty.create(self, 'performerRole', 'CodeableConcept', false, TFhirCodeableConcept, FPerformerRole.Link));
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference', false, TFhirReference, FPerformer.Link));
  oList.add(TFHIRProperty.create(self, 'performerLinkId', 'string', true, TFhirString, FPerformerLinkIdList.Link));
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableReference', true, TFhirCodeableReference, FReasonList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonLinkId', 'string', true, TFhirString, FReasonLinkIdList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'securityLabelNumber', 'unsignedInt', true, TFhirUnsignedInt, FSecurityLabelNumberList.Link));
end;

function TFhirContractTermAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'doNotPerform') then
  begin
    DoNotPerformElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    SubjectList.add(propValue as TFhirContractTermActionSubject);
    result := propValue;
  end
  else if (propName = 'intent') then
  begin
    Intent := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'linkId') then
  begin
    LinkIdList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'contextLinkId') then
  begin
    ContextLinkIdList.add(asString(propValue)){2};     result := propValue;

  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then
  begin
    Occurrence := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    RequesterList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'requesterLinkId') then
  begin
    RequesterLinkIdList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'performerType') then
  begin
    PerformerTypeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'performerRole') then
  begin
    PerformerRole := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'performerLinkId') then
  begin
    PerformerLinkIdList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableReference);
    result := propValue;
  end
  else if (propName = 'reasonLinkId') then
  begin
    ReasonLinkIdList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'securityLabelNumber') then
  begin
    SecurityLabelNumberList.add(asUnsignedInt(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'subject') then SubjectList.insertItem(index, propValue as TFhirContractTermActionSubject)
  else if (propName = 'linkId') then LinkIdList.insertItem(index, asString(propValue))
  else if (propName = 'contextLinkId') then ContextLinkIdList.insertItem(index, asString(propValue))
  else if (propName = 'requester') then RequesterList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'requesterLinkId') then RequesterLinkIdList.insertItem(index, asString(propValue))
  else if (propName = 'performerType') then PerformerTypeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'performerLinkId') then PerformerLinkIdList.insertItem(index, asString(propValue))
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableReference)
  else if (propName = 'reasonLinkId') then ReasonLinkIdList.insertItem(index, asString(propValue))
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'securityLabelNumber') then SecurityLabelNumberList.insertItem(index, asUnsignedInt(propValue))
  else inherited;
end;

function TFhirContractTermAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'doNotPerform') then result := TFhirBoolean.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'subject') then result := SubjectList.new()
  else if (propName = 'intent') then result := TFhirCodeableConcept.create()
  else if (propName = 'linkId') then result := LinkIdList.new()
  else if (propName = 'status') then result := TFhirCodeableConcept.create()
  else if (propName = 'context') then result := TFhirReference.create()
  else if (propName = 'contextLinkId') then result := ContextLinkIdList.new()
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then raise EFHIRException.create('Cannot make property Occurrence')
  else if (propName = 'requester') then result := RequesterList.new()
  else if (propName = 'requesterLinkId') then result := RequesterLinkIdList.new()
  else if (propName = 'performerType') then result := PerformerTypeList.new()
  else if (propName = 'performerRole') then result := TFhirCodeableConcept.create()
  else if (propName = 'performer') then result := TFhirReference.create()
  else if (propName = 'performerLinkId') then result := PerformerLinkIdList.new()
  else if (propName = 'reason') then result := ReasonList.new()
  else if (propName = 'reasonLinkId') then result := ReasonLinkIdList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'securityLabelNumber') then result := SecurityLabelNumberList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'doNotPerform') then result := 'boolean'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'BackboneElement'
  else if (propName = 'intent') then result := 'CodeableConcept'
  else if (propName = 'linkId') then result := 'string'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'contextLinkId') then result := 'string'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period|Timing'
  else if (propName = 'requester') then result := 'Reference'
  else if (propName = 'requesterLinkId') then result := 'string'
  else if (propName = 'performerType') then result := 'CodeableConcept'
  else if (propName = 'performerRole') then result := 'CodeableConcept'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'performerLinkId') then result := 'string'
  else if (propName = 'reason') then result := 'CodeableReference'
  else if (propName = 'reasonLinkId') then result := 'string'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'securityLabelNumber') then result := 'unsignedInt'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'doNotPerform') then DoNotPerformElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subject') then deletePropertyValue('subject', SubjectList, value)
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'linkId') then deletePropertyValue('linkId', LinkIdList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (propName = 'contextLinkId') then deletePropertyValue('contextLinkId', ContextLinkIdList, value)
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := nil
  else if (propName = 'requester') then deletePropertyValue('requester', RequesterList, value)
  else if (propName = 'requesterLinkId') then deletePropertyValue('requesterLinkId', RequesterLinkIdList, value)
  else if (propName = 'performerType') then deletePropertyValue('performerType', PerformerTypeList, value)
  else if (propName = 'performerRole') then PerformerRoleElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else if (propName = 'performerLinkId') then deletePropertyValue('performerLinkId', PerformerLinkIdList, value)
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value)
  else if (propName = 'reasonLinkId') then deletePropertyValue('reasonLinkId', ReasonLinkIdList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'securityLabelNumber') then deletePropertyValue('securityLabelNumber', SecurityLabelNumberList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'doNotPerform') then DoNotPerformElement := asBoolean(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'subject') then replacePropertyValue('subject', SubjectList, existing, new)
  else if (propName = 'intent') then IntentElement := new as TFhirCodeableConcept
  else if (propName = 'linkId') then replacePropertyValue('linkId', LinkIdList, existing, new)
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept
  else if (propName = 'context') then ContextElement := new as TFhirReference
  else if (propName = 'contextLinkId') then replacePropertyValue('contextLinkId', ContextLinkIdList, existing, new)
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := new as TFhirDataType
  else if (propName = 'requester') then replacePropertyValue('requester', RequesterList, existing, new)
  else if (propName = 'requesterLinkId') then replacePropertyValue('requesterLinkId', RequesterLinkIdList, existing, new)
  else if (propName = 'performerType') then replacePropertyValue('performerType', PerformerTypeList, existing, new)
  else if (propName = 'performerRole') then PerformerRoleElement := new as TFhirCodeableConcept
  else if (propName = 'performer') then PerformerElement := new as TFhirReference
  else if (propName = 'performerLinkId') then replacePropertyValue('performerLinkId', PerformerLinkIdList, existing, new)
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new)
  else if (propName = 'reasonLinkId') then replacePropertyValue('reasonLinkId', ReasonLinkIdList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'securityLabelNumber') then replacePropertyValue('securityLabelNumber', SecurityLabelNumberList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermAction.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'subject') then SubjectList.move(source, destination)
  else if (propName = 'linkId') then LinkIdList.move(source, destination)
  else if (propName = 'contextLinkId') then ContextLinkIdList.move(source, destination)
  else if (propName = 'requester') then RequesterList.move(source, destination)
  else if (propName = 'requesterLinkId') then RequesterLinkIdList.move(source, destination)
  else if (propName = 'performerType') then PerformerTypeList.move(source, destination)
  else if (propName = 'performerLinkId') then PerformerLinkIdList.move(source, destination)
  else if (propName = 'reason') then ReasonList.move(source, destination)
  else if (propName = 'reasonLinkId') then ReasonLinkIdList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'securityLabelNumber') then SecurityLabelNumberList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermAction.fhirType : string;
begin
  result := 'Contract.term.action';
end;

function TFhirContractTermAction.Link : TFhirContractTermAction;
begin
  result := TFhirContractTermAction(inherited Link);
end;

function TFhirContractTermAction.Clone : TFhirContractTermAction;
begin
  result := TFhirContractTermAction(inherited Clone);
end;

function TFhirContractTermAction.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermAction)) then
    result := false
  else
  begin
    o := TFhirContractTermAction(other);
    result := compareDeep(doNotPerformElement, o.doNotPerformElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subjectList, o.subjectList, true) and 
      compareDeep(intentElement, o.intentElement, true) and compareDeep(linkIdList, o.linkIdList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(contextElement, o.contextElement, true) and 
      compareDeep(contextLinkIdList, o.contextLinkIdList, true) and compareDeep(occurrenceElement, o.occurrenceElement, true) and 
      compareDeep(requesterList, o.requesterList, true) and compareDeep(requesterLinkIdList, o.requesterLinkIdList, true) and 
      compareDeep(performerTypeList, o.performerTypeList, true) and compareDeep(performerRoleElement, o.performerRoleElement, true) and 
      compareDeep(performerElement, o.performerElement, true) and compareDeep(performerLinkIdList, o.performerLinkIdList, true) and 
      compareDeep(reasonList, o.reasonList, true) and compareDeep(reasonLinkIdList, o.reasonLinkIdList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(securityLabelNumberList, o.securityLabelNumberList, true);
  end;
end;

function TFhirContractTermAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDoNotPerform) and isEmptyProp(FType_) and isEmptyProp(FsubjectList) and isEmptyProp(FIntent) and isEmptyProp(FlinkIdList) and isEmptyProp(FStatus) and isEmptyProp(FContext) and isEmptyProp(FcontextLinkIdList) and isEmptyProp(FOccurrence) and isEmptyProp(FrequesterList) and isEmptyProp(FrequesterLinkIdList) and isEmptyProp(FperformerTypeList) and isEmptyProp(FPerformerRole) and isEmptyProp(FPerformer) and isEmptyProp(FperformerLinkIdList) and isEmptyProp(FreasonList) and isEmptyProp(FreasonLinkIdList) and isEmptyProp(FnoteList) and isEmptyProp(FsecurityLabelNumberList);
end;

procedure TFhirContractTermAction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('doNotPerform');
  fields.add('type');
  fields.add('subject');
  fields.add('intent');
  fields.add('linkId');
  fields.add('status');
  fields.add('context');
  fields.add('contextLinkId');
  fields.add('occurrence[x]');
  fields.add('requester');
  fields.add('requesterLinkId');
  fields.add('performerType');
  fields.add('performerRole');
  fields.add('performer');
  fields.add('performerLinkId');
  fields.add('reason');
  fields.add('reasonLinkId');
  fields.add('note');
  fields.add('securityLabelNumber');
end;

function TFhirContractTermAction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FSubjectList.sizeInBytes(magic));
  inc(result, FLinkIdList.sizeInBytes(magic));
  inc(result, FContextLinkIdList.sizeInBytes(magic));
  inc(result, FRequesterList.sizeInBytes(magic));
  inc(result, FRequesterLinkIdList.sizeInBytes(magic));
  inc(result, FPerformerTypeList.sizeInBytes(magic));
  inc(result, FPerformerLinkIdList.sizeInBytes(magic));
  inc(result, FReasonList.sizeInBytes(magic));
  inc(result, FReasonLinkIdList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FSecurityLabelNumberList.sizeInBytes(magic));
end;

procedure TFhirContractTermAction.SetDoNotPerform(value : TFhirBoolean);
begin
  FDoNotPerform.free;
  FDoNotPerform := value;
end;

function TFhirContractTermAction.GetDoNotPerformST : Boolean;
begin
  if FDoNotPerform = nil then
    result := false
  else
    result := FDoNotPerform.value;
end;

procedure TFhirContractTermAction.SetDoNotPerformST(value : Boolean);
begin
  if FDoNotPerform = nil then
    FDoNotPerform := TFhirBoolean.create;
  FDoNotPerform.value := value
end;

procedure TFhirContractTermAction.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirContractTermAction.GetSubjectList : TFhirContractTermActionSubjectList;
begin
  if FSubjectList = nil then
    FSubjectList := TFhirContractTermActionSubjectList.Create;
  result := FSubjectList;
end;

function TFhirContractTermAction.GetHasSubjectList : boolean;
begin
  result := (FSubjectList <> nil) and (FSubjectList.count > 0);
end;

procedure TFhirContractTermAction.SetIntent(value : TFhirCodeableConcept);
begin
  FIntent.free;
  FIntent := value;
end;

function TFhirContractTermAction.GetLinkIdList : TFhirStringList;
begin
  if FLinkIdList = nil then
    FLinkIdList := TFhirStringList.Create;
  result := FLinkIdList;
end;

function TFhirContractTermAction.GetHasLinkIdList : boolean;
begin
  result := (FLinkIdList <> nil) and (FLinkIdList.count > 0);
end;

procedure TFhirContractTermAction.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

procedure TFhirContractTermAction.SetContext(value : TFhirReference);
begin
  FContext.free;
  FContext := value;
end;

function TFhirContractTermAction.GetContextLinkIdList : TFhirStringList;
begin
  if FContextLinkIdList = nil then
    FContextLinkIdList := TFhirStringList.Create;
  result := FContextLinkIdList;
end;

function TFhirContractTermAction.GetHasContextLinkIdList : boolean;
begin
  result := (FContextLinkIdList <> nil) and (FContextLinkIdList.count > 0);
end;

procedure TFhirContractTermAction.SetOccurrence(value : TFhirDataType);
begin
  FOccurrence.free;
  FOccurrence := value;
end;

function TFhirContractTermAction.GetRequesterList : TFhirReferenceList;
begin
  if FRequesterList = nil then
    FRequesterList := TFhirReferenceList.Create;
  result := FRequesterList;
end;

function TFhirContractTermAction.GetHasRequesterList : boolean;
begin
  result := (FRequesterList <> nil) and (FRequesterList.count > 0);
end;

function TFhirContractTermAction.GetRequesterLinkIdList : TFhirStringList;
begin
  if FRequesterLinkIdList = nil then
    FRequesterLinkIdList := TFhirStringList.Create;
  result := FRequesterLinkIdList;
end;

function TFhirContractTermAction.GetHasRequesterLinkIdList : boolean;
begin
  result := (FRequesterLinkIdList <> nil) and (FRequesterLinkIdList.count > 0);
end;

function TFhirContractTermAction.GetPerformerTypeList : TFhirCodeableConceptList;
begin
  if FPerformerTypeList = nil then
    FPerformerTypeList := TFhirCodeableConceptList.Create;
  result := FPerformerTypeList;
end;

function TFhirContractTermAction.GetHasPerformerTypeList : boolean;
begin
  result := (FPerformerTypeList <> nil) and (FPerformerTypeList.count > 0);
end;

procedure TFhirContractTermAction.SetPerformerRole(value : TFhirCodeableConcept);
begin
  FPerformerRole.free;
  FPerformerRole := value;
end;

procedure TFhirContractTermAction.SetPerformer(value : TFhirReference);
begin
  FPerformer.free;
  FPerformer := value;
end;

function TFhirContractTermAction.GetPerformerLinkIdList : TFhirStringList;
begin
  if FPerformerLinkIdList = nil then
    FPerformerLinkIdList := TFhirStringList.Create;
  result := FPerformerLinkIdList;
end;

function TFhirContractTermAction.GetHasPerformerLinkIdList : boolean;
begin
  result := (FPerformerLinkIdList <> nil) and (FPerformerLinkIdList.count > 0);
end;

function TFhirContractTermAction.GetReasonList : TFhirCodeableReferenceList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableReferenceList.Create;
  result := FReasonList;
end;

function TFhirContractTermAction.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirContractTermAction.GetReasonLinkIdList : TFhirStringList;
begin
  if FReasonLinkIdList = nil then
    FReasonLinkIdList := TFhirStringList.Create;
  result := FReasonLinkIdList;
end;

function TFhirContractTermAction.GetHasReasonLinkIdList : boolean;
begin
  result := (FReasonLinkIdList <> nil) and (FReasonLinkIdList.count > 0);
end;

function TFhirContractTermAction.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirContractTermAction.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirContractTermAction.GetSecurityLabelNumberList : TFhirUnsignedIntList;
begin
  if FSecurityLabelNumberList = nil then
    FSecurityLabelNumberList := TFhirUnsignedIntList.Create;
  result := FSecurityLabelNumberList;
end;

function TFhirContractTermAction.GetHasSecurityLabelNumberList : boolean;
begin
  result := (FSecurityLabelNumberList <> nil) and (FSecurityLabelNumberList.count > 0);
end;

{ TFhirContractTermActionListEnumerator }

constructor TFhirContractTermActionListEnumerator.Create(list : TFhirContractTermActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermActionListEnumerator.GetCurrent : TFhirContractTermAction;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermActionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractTermActionList }

function TFhirContractTermActionList.AddItem(value: TFhirContractTermAction): TFhirContractTermAction;
begin
  assert(value.ClassName = 'TFhirContractTermAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermAction');
  add(value);
  result := value;
end;

function TFhirContractTermActionList.Append: TFhirContractTermAction;
begin
  result := TFhirContractTermAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermActionList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermActionList.GetEnumerator : TFhirContractTermActionListEnumerator;
begin
  result := TFhirContractTermActionListEnumerator.Create(self.link);
end;

function TFhirContractTermActionList.Clone: TFhirContractTermActionList;
begin
  result := TFhirContractTermActionList(inherited Clone);
end;

function TFhirContractTermActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermActionList.GetItemN(index: Integer): TFhirContractTermAction;
begin
  result := TFhirContractTermAction(ObjectByIndex[index]);
end;

function TFhirContractTermActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermAction;
end;
function TFhirContractTermActionList.IndexOf(value: TFhirContractTermAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermActionList.Insert(index: Integer): TFhirContractTermAction;
begin
  result := TFhirContractTermAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermActionList.InsertItem(index: Integer; value: TFhirContractTermAction);
begin
  assert(value is TFhirContractTermAction);
  Inherited Insert(index, value);
end;

function TFhirContractTermActionList.Item(index: Integer): TFhirContractTermAction;
begin
  result := TFhirContractTermAction(ObjectByIndex[index]);
end;

function TFhirContractTermActionList.Link: TFhirContractTermActionList;
begin
  result := TFhirContractTermActionList(inherited Link);
end;

procedure TFhirContractTermActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermActionList.SetItemByIndex(index: Integer; value: TFhirContractTermAction);
begin
  assert(value is TFhirContractTermAction);
  FhirContractTermActions[index] := value;
end;

procedure TFhirContractTermActionList.SetItemN(index: Integer; value: TFhirContractTermAction);
begin
  assert(value is TFhirContractTermAction);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermActionSubject }

constructor TFhirContractTermActionSubject.Create;
begin
  inherited;
end;

destructor TFhirContractTermActionSubject.Destroy;
begin
  FReferenceList.Free;
  FRole.free;
  inherited;
end;

procedure TFhirContractTermActionSubject.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirContractTermActionSubject(oSource).FReferenceList = nil) then
  begin
    FReferenceList.free;
    FReferenceList := nil;
  end
  else
  begin
    if FReferenceList = nil then
      FReferenceList := TFhirReferenceList.Create;
    FReferenceList.Assign(TFhirContractTermActionSubject(oSource).FReferenceList);
  end;
  role := TFhirContractTermActionSubject(oSource).role.Clone;
end;

procedure TFhirContractTermActionSubject.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'reference') Then
    list.addAll(self, 'reference', FReferenceList);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
end;

procedure TFhirContractTermActionSubject.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference', true, TFhirReference, FReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));
end;

function TFhirContractTermActionSubject.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'reference') then
  begin
    ReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermActionSubject.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'reference') then ReferenceList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirContractTermActionSubject.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'reference') then result := ReferenceList.new()
  else if (propName = 'role') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermActionSubject.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'reference') then result := 'Reference'
  else if (propName = 'role') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermActionSubject.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'reference') then deletePropertyValue('reference', ReferenceList, value)
  else if (propName = 'role') then RoleElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermActionSubject.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'reference') then replacePropertyValue('reference', ReferenceList, existing, new)
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermActionSubject.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'reference') then ReferenceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermActionSubject.fhirType : string;
begin
  result := 'Contract.term.action.subject';
end;

function TFhirContractTermActionSubject.Link : TFhirContractTermActionSubject;
begin
  result := TFhirContractTermActionSubject(inherited Link);
end;

function TFhirContractTermActionSubject.Clone : TFhirContractTermActionSubject;
begin
  result := TFhirContractTermActionSubject(inherited Clone);
end;

function TFhirContractTermActionSubject.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermActionSubject;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermActionSubject)) then
    result := false
  else
  begin
    o := TFhirContractTermActionSubject(other);
    result := compareDeep(referenceList, o.referenceList, true) and compareDeep(roleElement, o.roleElement, true);
  end;
end;

function TFhirContractTermActionSubject.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FreferenceList) and isEmptyProp(FRole);
end;

procedure TFhirContractTermActionSubject.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('reference');
  fields.add('role');
end;

function TFhirContractTermActionSubject.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FReferenceList.sizeInBytes(magic));
end;

function TFhirContractTermActionSubject.GetReferenceList : TFhirReferenceList;
begin
  if FReferenceList = nil then
    FReferenceList := TFhirReferenceList.Create;
  result := FReferenceList;
end;

function TFhirContractTermActionSubject.GetHasReferenceList : boolean;
begin
  result := (FReferenceList <> nil) and (FReferenceList.count > 0);
end;

procedure TFhirContractTermActionSubject.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

{ TFhirContractTermActionSubjectListEnumerator }

constructor TFhirContractTermActionSubjectListEnumerator.Create(list : TFhirContractTermActionSubjectList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermActionSubjectListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermActionSubjectListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermActionSubjectListEnumerator.GetCurrent : TFhirContractTermActionSubject;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermActionSubjectListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractTermActionSubjectList }

function TFhirContractTermActionSubjectList.AddItem(value: TFhirContractTermActionSubject): TFhirContractTermActionSubject;
begin
  assert(value.ClassName = 'TFhirContractTermActionSubject', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermActionSubject');
  add(value);
  result := value;
end;

function TFhirContractTermActionSubjectList.Append: TFhirContractTermActionSubject;
begin
  result := TFhirContractTermActionSubject.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermActionSubjectList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermActionSubjectList.GetEnumerator : TFhirContractTermActionSubjectListEnumerator;
begin
  result := TFhirContractTermActionSubjectListEnumerator.Create(self.link);
end;

function TFhirContractTermActionSubjectList.Clone: TFhirContractTermActionSubjectList;
begin
  result := TFhirContractTermActionSubjectList(inherited Clone);
end;

function TFhirContractTermActionSubjectList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermActionSubjectList.GetItemN(index: Integer): TFhirContractTermActionSubject;
begin
  result := TFhirContractTermActionSubject(ObjectByIndex[index]);
end;

function TFhirContractTermActionSubjectList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermActionSubject;
end;
function TFhirContractTermActionSubjectList.IndexOf(value: TFhirContractTermActionSubject): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermActionSubjectList.Insert(index: Integer): TFhirContractTermActionSubject;
begin
  result := TFhirContractTermActionSubject.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermActionSubjectList.InsertItem(index: Integer; value: TFhirContractTermActionSubject);
begin
  assert(value is TFhirContractTermActionSubject);
  Inherited Insert(index, value);
end;

function TFhirContractTermActionSubjectList.Item(index: Integer): TFhirContractTermActionSubject;
begin
  result := TFhirContractTermActionSubject(ObjectByIndex[index]);
end;

function TFhirContractTermActionSubjectList.Link: TFhirContractTermActionSubjectList;
begin
  result := TFhirContractTermActionSubjectList(inherited Link);
end;

procedure TFhirContractTermActionSubjectList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermActionSubjectList.SetItemByIndex(index: Integer; value: TFhirContractTermActionSubject);
begin
  assert(value is TFhirContractTermActionSubject);
  FhirContractTermActionSubjects[index] := value;
end;

procedure TFhirContractTermActionSubjectList.SetItemN(index: Integer; value: TFhirContractTermActionSubject);
begin
  assert(value is TFhirContractTermActionSubject);
  ObjectByIndex[index] := value;
end;

{ TFhirContractSigner }

constructor TFhirContractSigner.Create;
begin
  inherited;
end;

destructor TFhirContractSigner.Destroy;
begin
  FType_.free;
  FParty.free;
  FSignatureList.Free;
  inherited;
end;

procedure TFhirContractSigner.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirContractSigner(oSource).type_.Clone;
  party := TFhirContractSigner(oSource).party.Clone;
  if (TFhirContractSigner(oSource).FSignatureList = nil) then
  begin
    FSignatureList.free;
    FSignatureList := nil;
  end
  else
  begin
    if FSignatureList = nil then
      FSignatureList := TFhirSignatureList.Create;
    FSignatureList.Assign(TFhirContractSigner(oSource).FSignatureList);
  end;
end;

procedure TFhirContractSigner.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'party') Then
     list.add(self.link, 'party', FParty.Link);
  if (child_name = 'signature') Then
    list.addAll(self, 'signature', FSignatureList);
end;

procedure TFhirContractSigner.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'party', 'Reference', false, TFhirReference, FParty.Link));
  oList.add(TFHIRProperty.create(self, 'signature', 'Signature', true, TFhirSignature, FSignatureList.Link));
end;

function TFhirContractSigner.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'party') then
  begin
    Party := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'signature') then
  begin
    SignatureList.add(propValue as TFhirSignature);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractSigner.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'signature') then SignatureList.insertItem(index, propValue as TFhirSignature)
  else inherited;
end;

function TFhirContractSigner.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCoding.create()
  else if (propName = 'party') then result := TFhirReference.create()
  else if (propName = 'signature') then result := SignatureList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractSigner.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'Coding'
  else if (propName = 'party') then result := 'Reference'
  else if (propName = 'signature') then result := 'Signature'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractSigner.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'party') then PartyElement := nil
  else if (propName = 'signature') then deletePropertyValue('signature', SignatureList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractSigner.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCoding
  else if (propName = 'party') then PartyElement := new as TFhirReference
  else if (propName = 'signature') then replacePropertyValue('signature', SignatureList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractSigner.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'signature') then SignatureList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractSigner.fhirType : string;
begin
  result := 'Contract.signer';
end;

function TFhirContractSigner.Link : TFhirContractSigner;
begin
  result := TFhirContractSigner(inherited Link);
end;

function TFhirContractSigner.Clone : TFhirContractSigner;
begin
  result := TFhirContractSigner(inherited Clone);
end;

function TFhirContractSigner.equals(other : TObject) : boolean; 
var
  o : TFhirContractSigner;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractSigner)) then
    result := false
  else
  begin
    o := TFhirContractSigner(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(partyElement, o.partyElement, true) and 
      compareDeep(signatureList, o.signatureList, true);
  end;
end;

function TFhirContractSigner.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FParty) and isEmptyProp(FsignatureList);
end;

procedure TFhirContractSigner.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('party');
  fields.add('signature');
end;

function TFhirContractSigner.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FSignatureList.sizeInBytes(magic));
end;

procedure TFhirContractSigner.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirContractSigner.SetParty(value : TFhirReference);
begin
  FParty.free;
  FParty := value;
end;

function TFhirContractSigner.GetSignatureList : TFhirSignatureList;
begin
  if FSignatureList = nil then
    FSignatureList := TFhirSignatureList.Create;
  result := FSignatureList;
end;

function TFhirContractSigner.GetHasSignatureList : boolean;
begin
  result := (FSignatureList <> nil) and (FSignatureList.count > 0);
end;

{ TFhirContractSignerListEnumerator }

constructor TFhirContractSignerListEnumerator.Create(list : TFhirContractSignerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractSignerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractSignerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractSignerListEnumerator.GetCurrent : TFhirContractSigner;
begin
  Result := FList[FIndex];
end;

function TFhirContractSignerListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractSignerList }

function TFhirContractSignerList.AddItem(value: TFhirContractSigner): TFhirContractSigner;
begin
  assert(value.ClassName = 'TFhirContractSigner', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractSigner');
  add(value);
  result := value;
end;

function TFhirContractSignerList.Append: TFhirContractSigner;
begin
  result := TFhirContractSigner.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractSignerList.ClearItems;
begin
  Clear;
end;

function TFhirContractSignerList.GetEnumerator : TFhirContractSignerListEnumerator;
begin
  result := TFhirContractSignerListEnumerator.Create(self.link);
end;

function TFhirContractSignerList.Clone: TFhirContractSignerList;
begin
  result := TFhirContractSignerList(inherited Clone);
end;

function TFhirContractSignerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractSignerList.GetItemN(index: Integer): TFhirContractSigner;
begin
  result := TFhirContractSigner(ObjectByIndex[index]);
end;

function TFhirContractSignerList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractSigner;
end;
function TFhirContractSignerList.IndexOf(value: TFhirContractSigner): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractSignerList.Insert(index: Integer): TFhirContractSigner;
begin
  result := TFhirContractSigner.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractSignerList.InsertItem(index: Integer; value: TFhirContractSigner);
begin
  assert(value is TFhirContractSigner);
  Inherited Insert(index, value);
end;

function TFhirContractSignerList.Item(index: Integer): TFhirContractSigner;
begin
  result := TFhirContractSigner(ObjectByIndex[index]);
end;

function TFhirContractSignerList.Link: TFhirContractSignerList;
begin
  result := TFhirContractSignerList(inherited Link);
end;

procedure TFhirContractSignerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractSignerList.SetItemByIndex(index: Integer; value: TFhirContractSigner);
begin
  assert(value is TFhirContractSigner);
  FhirContractSigners[index] := value;
end;

procedure TFhirContractSignerList.SetItemN(index: Integer; value: TFhirContractSigner);
begin
  assert(value is TFhirContractSigner);
  ObjectByIndex[index] := value;
end;

{ TFhirContractFriendly }

constructor TFhirContractFriendly.Create;
begin
  inherited;
end;

destructor TFhirContractFriendly.Destroy;
begin
  FContent.free;
  inherited;
end;

procedure TFhirContractFriendly.Assign(oSource : TFslObject);
begin
  inherited;
  content := TFhirContractFriendly(oSource).content.Clone;
end;

procedure TFhirContractFriendly.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'content[x]') or (child_name = 'content') Then
     list.add(self.link, 'content[x]', FContent.Link);
end;

procedure TFhirContractFriendly.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'content[x]', 'Attachment|Reference', false, TFhirDataType, FContent.Link));
end;

function TFhirContractFriendly.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then
  begin
    Content := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractFriendly.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractFriendly.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Content')
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractFriendly.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'content[x]') then result := 'Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractFriendly.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractFriendly.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractFriendly.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractFriendly.fhirType : string;
begin
  result := 'Contract.friendly';
end;

function TFhirContractFriendly.Link : TFhirContractFriendly;
begin
  result := TFhirContractFriendly(inherited Link);
end;

function TFhirContractFriendly.Clone : TFhirContractFriendly;
begin
  result := TFhirContractFriendly(inherited Clone);
end;

function TFhirContractFriendly.equals(other : TObject) : boolean; 
var
  o : TFhirContractFriendly;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractFriendly)) then
    result := false
  else
  begin
    o := TFhirContractFriendly(other);
    result := compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirContractFriendly.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContent);
end;

procedure TFhirContractFriendly.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('content[x]');
end;

function TFhirContractFriendly.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirContractFriendly.SetContent(value : TFhirDataType);
begin
  FContent.free;
  FContent := value;
end;

{ TFhirContractFriendlyListEnumerator }

constructor TFhirContractFriendlyListEnumerator.Create(list : TFhirContractFriendlyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractFriendlyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractFriendlyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractFriendlyListEnumerator.GetCurrent : TFhirContractFriendly;
begin
  Result := FList[FIndex];
end;

function TFhirContractFriendlyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractFriendlyList }

function TFhirContractFriendlyList.AddItem(value: TFhirContractFriendly): TFhirContractFriendly;
begin
  assert(value.ClassName = 'TFhirContractFriendly', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractFriendly');
  add(value);
  result := value;
end;

function TFhirContractFriendlyList.Append: TFhirContractFriendly;
begin
  result := TFhirContractFriendly.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractFriendlyList.ClearItems;
begin
  Clear;
end;

function TFhirContractFriendlyList.GetEnumerator : TFhirContractFriendlyListEnumerator;
begin
  result := TFhirContractFriendlyListEnumerator.Create(self.link);
end;

function TFhirContractFriendlyList.Clone: TFhirContractFriendlyList;
begin
  result := TFhirContractFriendlyList(inherited Clone);
end;

function TFhirContractFriendlyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractFriendlyList.GetItemN(index: Integer): TFhirContractFriendly;
begin
  result := TFhirContractFriendly(ObjectByIndex[index]);
end;

function TFhirContractFriendlyList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractFriendly;
end;
function TFhirContractFriendlyList.IndexOf(value: TFhirContractFriendly): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractFriendlyList.Insert(index: Integer): TFhirContractFriendly;
begin
  result := TFhirContractFriendly.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractFriendlyList.InsertItem(index: Integer; value: TFhirContractFriendly);
begin
  assert(value is TFhirContractFriendly);
  Inherited Insert(index, value);
end;

function TFhirContractFriendlyList.Item(index: Integer): TFhirContractFriendly;
begin
  result := TFhirContractFriendly(ObjectByIndex[index]);
end;

function TFhirContractFriendlyList.Link: TFhirContractFriendlyList;
begin
  result := TFhirContractFriendlyList(inherited Link);
end;

procedure TFhirContractFriendlyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractFriendlyList.SetItemByIndex(index: Integer; value: TFhirContractFriendly);
begin
  assert(value is TFhirContractFriendly);
  FhirContractFriendlies[index] := value;
end;

procedure TFhirContractFriendlyList.SetItemN(index: Integer; value: TFhirContractFriendly);
begin
  assert(value is TFhirContractFriendly);
  ObjectByIndex[index] := value;
end;

{ TFhirContractLegal }

constructor TFhirContractLegal.Create;
begin
  inherited;
end;

destructor TFhirContractLegal.Destroy;
begin
  FContent.free;
  inherited;
end;

procedure TFhirContractLegal.Assign(oSource : TFslObject);
begin
  inherited;
  content := TFhirContractLegal(oSource).content.Clone;
end;

procedure TFhirContractLegal.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'content[x]') or (child_name = 'content') Then
     list.add(self.link, 'content[x]', FContent.Link);
end;

procedure TFhirContractLegal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'content[x]', 'Attachment|Reference', false, TFhirDataType, FContent.Link));
end;

function TFhirContractLegal.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then
  begin
    Content := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractLegal.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractLegal.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Content')
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractLegal.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'content[x]') then result := 'Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractLegal.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractLegal.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractLegal.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractLegal.fhirType : string;
begin
  result := 'Contract.legal';
end;

function TFhirContractLegal.Link : TFhirContractLegal;
begin
  result := TFhirContractLegal(inherited Link);
end;

function TFhirContractLegal.Clone : TFhirContractLegal;
begin
  result := TFhirContractLegal(inherited Clone);
end;

function TFhirContractLegal.equals(other : TObject) : boolean; 
var
  o : TFhirContractLegal;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractLegal)) then
    result := false
  else
  begin
    o := TFhirContractLegal(other);
    result := compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirContractLegal.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContent);
end;

procedure TFhirContractLegal.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('content[x]');
end;

function TFhirContractLegal.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirContractLegal.SetContent(value : TFhirDataType);
begin
  FContent.free;
  FContent := value;
end;

{ TFhirContractLegalListEnumerator }

constructor TFhirContractLegalListEnumerator.Create(list : TFhirContractLegalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractLegalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractLegalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractLegalListEnumerator.GetCurrent : TFhirContractLegal;
begin
  Result := FList[FIndex];
end;

function TFhirContractLegalListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractLegalList }

function TFhirContractLegalList.AddItem(value: TFhirContractLegal): TFhirContractLegal;
begin
  assert(value.ClassName = 'TFhirContractLegal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractLegal');
  add(value);
  result := value;
end;

function TFhirContractLegalList.Append: TFhirContractLegal;
begin
  result := TFhirContractLegal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractLegalList.ClearItems;
begin
  Clear;
end;

function TFhirContractLegalList.GetEnumerator : TFhirContractLegalListEnumerator;
begin
  result := TFhirContractLegalListEnumerator.Create(self.link);
end;

function TFhirContractLegalList.Clone: TFhirContractLegalList;
begin
  result := TFhirContractLegalList(inherited Clone);
end;

function TFhirContractLegalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractLegalList.GetItemN(index: Integer): TFhirContractLegal;
begin
  result := TFhirContractLegal(ObjectByIndex[index]);
end;

function TFhirContractLegalList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractLegal;
end;
function TFhirContractLegalList.IndexOf(value: TFhirContractLegal): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractLegalList.Insert(index: Integer): TFhirContractLegal;
begin
  result := TFhirContractLegal.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractLegalList.InsertItem(index: Integer; value: TFhirContractLegal);
begin
  assert(value is TFhirContractLegal);
  Inherited Insert(index, value);
end;

function TFhirContractLegalList.Item(index: Integer): TFhirContractLegal;
begin
  result := TFhirContractLegal(ObjectByIndex[index]);
end;

function TFhirContractLegalList.Link: TFhirContractLegalList;
begin
  result := TFhirContractLegalList(inherited Link);
end;

procedure TFhirContractLegalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractLegalList.SetItemByIndex(index: Integer; value: TFhirContractLegal);
begin
  assert(value is TFhirContractLegal);
  FhirContractLegals[index] := value;
end;

procedure TFhirContractLegalList.SetItemN(index: Integer; value: TFhirContractLegal);
begin
  assert(value is TFhirContractLegal);
  ObjectByIndex[index] := value;
end;

{ TFhirContractRule }

constructor TFhirContractRule.Create;
begin
  inherited;
end;

destructor TFhirContractRule.Destroy;
begin
  FContent.free;
  inherited;
end;

procedure TFhirContractRule.Assign(oSource : TFslObject);
begin
  inherited;
  content := TFhirContractRule(oSource).content.Clone;
end;

procedure TFhirContractRule.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'content[x]') or (child_name = 'content') Then
     list.add(self.link, 'content[x]', FContent.Link);
end;

procedure TFhirContractRule.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'content[x]', 'Attachment|Reference', false, TFhirDataType, FContent.Link));
end;

function TFhirContractRule.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then
  begin
    Content := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractRule.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractRule.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Content')
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractRule.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'content[x]') then result := 'Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractRule.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractRule.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractRule.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractRule.fhirType : string;
begin
  result := 'Contract.rule';
end;

function TFhirContractRule.Link : TFhirContractRule;
begin
  result := TFhirContractRule(inherited Link);
end;

function TFhirContractRule.Clone : TFhirContractRule;
begin
  result := TFhirContractRule(inherited Clone);
end;

function TFhirContractRule.equals(other : TObject) : boolean; 
var
  o : TFhirContractRule;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractRule)) then
    result := false
  else
  begin
    o := TFhirContractRule(other);
    result := compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirContractRule.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContent);
end;

procedure TFhirContractRule.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('content[x]');
end;

function TFhirContractRule.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirContractRule.SetContent(value : TFhirDataType);
begin
  FContent.free;
  FContent := value;
end;

{ TFhirContractRuleListEnumerator }

constructor TFhirContractRuleListEnumerator.Create(list : TFhirContractRuleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractRuleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractRuleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractRuleListEnumerator.GetCurrent : TFhirContractRule;
begin
  Result := FList[FIndex];
end;

function TFhirContractRuleListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractRuleList }

function TFhirContractRuleList.AddItem(value: TFhirContractRule): TFhirContractRule;
begin
  assert(value.ClassName = 'TFhirContractRule', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractRule');
  add(value);
  result := value;
end;

function TFhirContractRuleList.Append: TFhirContractRule;
begin
  result := TFhirContractRule.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractRuleList.ClearItems;
begin
  Clear;
end;

function TFhirContractRuleList.GetEnumerator : TFhirContractRuleListEnumerator;
begin
  result := TFhirContractRuleListEnumerator.Create(self.link);
end;

function TFhirContractRuleList.Clone: TFhirContractRuleList;
begin
  result := TFhirContractRuleList(inherited Clone);
end;

function TFhirContractRuleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractRuleList.GetItemN(index: Integer): TFhirContractRule;
begin
  result := TFhirContractRule(ObjectByIndex[index]);
end;

function TFhirContractRuleList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractRule;
end;
function TFhirContractRuleList.IndexOf(value: TFhirContractRule): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractRuleList.Insert(index: Integer): TFhirContractRule;
begin
  result := TFhirContractRule.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractRuleList.InsertItem(index: Integer; value: TFhirContractRule);
begin
  assert(value is TFhirContractRule);
  Inherited Insert(index, value);
end;

function TFhirContractRuleList.Item(index: Integer): TFhirContractRule;
begin
  result := TFhirContractRule(ObjectByIndex[index]);
end;

function TFhirContractRuleList.Link: TFhirContractRuleList;
begin
  result := TFhirContractRuleList(inherited Link);
end;

procedure TFhirContractRuleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractRuleList.SetItemByIndex(index: Integer; value: TFhirContractRule);
begin
  assert(value is TFhirContractRule);
  FhirContractRules[index] := value;
end;

procedure TFhirContractRuleList.SetItemN(index: Integer; value: TFhirContractRule);
begin
  assert(value is TFhirContractRule);
  ObjectByIndex[index] := value;
end;

{ TFhirContract }

constructor TFhirContract.Create;
begin
  inherited;
end;

destructor TFhirContract.Destroy;
begin
  FIdentifierList.Free;
  FUrl.free;
  FVersion.free;
  FStatus.free;
  FLegalState.free;
  FInstantiatesCanonical.free;
  FInstantiatesUri.free;
  FContentDerivative.free;
  FIssued.free;
  FApplies.free;
  FExpirationType.free;
  FSubjectList.Free;
  FAuthorityList.Free;
  FDomainList.Free;
  FSiteList.Free;
  FName.free;
  FTitle.free;
  FSubtitle.free;
  FAliasList.Free;
  FAuthor.free;
  FScope.free;
  FTopic.free;
  FType_.free;
  FSubTypeList.Free;
  FContentDefinition.free;
  FTermList.Free;
  FSupportingInfoList.Free;
  FRelevantHistoryList.Free;
  FSignerList.Free;
  FFriendlyList.Free;
  FLegalList.Free;
  FRuleList.Free;
  FLegallyBinding.free;
  inherited;
end;

procedure TFhirContract.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirContract(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirContract(oSource).FIdentifierList);
  end;
  urlElement := TFhirContract(oSource).urlElement.Clone;
  versionElement := TFhirContract(oSource).versionElement.Clone;
  statusElement := TFhirContract(oSource).statusElement.Clone;
  legalState := TFhirContract(oSource).legalState.Clone;
  instantiatesCanonical := TFhirContract(oSource).instantiatesCanonical.Clone;
  instantiatesUriElement := TFhirContract(oSource).instantiatesUriElement.Clone;
  contentDerivative := TFhirContract(oSource).contentDerivative.Clone;
  issuedElement := TFhirContract(oSource).issuedElement.Clone;
  applies := TFhirContract(oSource).applies.Clone;
  expirationType := TFhirContract(oSource).expirationType.Clone;
  if (TFhirContract(oSource).FSubjectList = nil) then
  begin
    FSubjectList.free;
    FSubjectList := nil;
  end
  else
  begin
    if FSubjectList = nil then
      FSubjectList := TFhirReferenceList.Create;
    FSubjectList.Assign(TFhirContract(oSource).FSubjectList);
  end;
  if (TFhirContract(oSource).FAuthorityList = nil) then
  begin
    FAuthorityList.free;
    FAuthorityList := nil;
  end
  else
  begin
    if FAuthorityList = nil then
      FAuthorityList := TFhirReferenceList.Create;
    FAuthorityList.Assign(TFhirContract(oSource).FAuthorityList);
  end;
  if (TFhirContract(oSource).FDomainList = nil) then
  begin
    FDomainList.free;
    FDomainList := nil;
  end
  else
  begin
    if FDomainList = nil then
      FDomainList := TFhirReferenceList.Create;
    FDomainList.Assign(TFhirContract(oSource).FDomainList);
  end;
  if (TFhirContract(oSource).FSiteList = nil) then
  begin
    FSiteList.free;
    FSiteList := nil;
  end
  else
  begin
    if FSiteList = nil then
      FSiteList := TFhirReferenceList.Create;
    FSiteList.Assign(TFhirContract(oSource).FSiteList);
  end;
  nameElement := TFhirContract(oSource).nameElement.Clone;
  titleElement := TFhirContract(oSource).titleElement.Clone;
  subtitleElement := TFhirContract(oSource).subtitleElement.Clone;
  if (TFhirContract(oSource).FAliasList = nil) then
  begin
    FAliasList.free;
    FAliasList := nil;
  end
  else
  begin
    if FAliasList = nil then
      FAliasList := TFhirStringList.Create;
    FAliasList.Assign(TFhirContract(oSource).FAliasList);
  end;
  author := TFhirContract(oSource).author.Clone;
  scope := TFhirContract(oSource).scope.Clone;
  topic := TFhirContract(oSource).topic.Clone;
  type_ := TFhirContract(oSource).type_.Clone;
  if (TFhirContract(oSource).FSubTypeList = nil) then
  begin
    FSubTypeList.free;
    FSubTypeList := nil;
  end
  else
  begin
    if FSubTypeList = nil then
      FSubTypeList := TFhirCodeableConceptList.Create;
    FSubTypeList.Assign(TFhirContract(oSource).FSubTypeList);
  end;
  contentDefinition := TFhirContract(oSource).contentDefinition.Clone;
  if (TFhirContract(oSource).FTermList = nil) then
  begin
    FTermList.free;
    FTermList := nil;
  end
  else
  begin
    if FTermList = nil then
      FTermList := TFhirContractTermList.Create;
    FTermList.Assign(TFhirContract(oSource).FTermList);
  end;
  if (TFhirContract(oSource).FSupportingInfoList = nil) then
  begin
    FSupportingInfoList.free;
    FSupportingInfoList := nil;
  end
  else
  begin
    if FSupportingInfoList = nil then
      FSupportingInfoList := TFhirReferenceList.Create;
    FSupportingInfoList.Assign(TFhirContract(oSource).FSupportingInfoList);
  end;
  if (TFhirContract(oSource).FRelevantHistoryList = nil) then
  begin
    FRelevantHistoryList.free;
    FRelevantHistoryList := nil;
  end
  else
  begin
    if FRelevantHistoryList = nil then
      FRelevantHistoryList := TFhirReferenceList.Create;
    FRelevantHistoryList.Assign(TFhirContract(oSource).FRelevantHistoryList);
  end;
  if (TFhirContract(oSource).FSignerList = nil) then
  begin
    FSignerList.free;
    FSignerList := nil;
  end
  else
  begin
    if FSignerList = nil then
      FSignerList := TFhirContractSignerList.Create;
    FSignerList.Assign(TFhirContract(oSource).FSignerList);
  end;
  if (TFhirContract(oSource).FFriendlyList = nil) then
  begin
    FFriendlyList.free;
    FFriendlyList := nil;
  end
  else
  begin
    if FFriendlyList = nil then
      FFriendlyList := TFhirContractFriendlyList.Create;
    FFriendlyList.Assign(TFhirContract(oSource).FFriendlyList);
  end;
  if (TFhirContract(oSource).FLegalList = nil) then
  begin
    FLegalList.free;
    FLegalList := nil;
  end
  else
  begin
    if FLegalList = nil then
      FLegalList := TFhirContractLegalList.Create;
    FLegalList.Assign(TFhirContract(oSource).FLegalList);
  end;
  if (TFhirContract(oSource).FRuleList = nil) then
  begin
    FRuleList.free;
    FRuleList := nil;
  end
  else
  begin
    if FRuleList = nil then
      FRuleList := TFhirContractRuleList.Create;
    FRuleList.Assign(TFhirContract(oSource).FRuleList);
  end;
  legallyBinding := TFhirContract(oSource).legallyBinding.Clone;
end;

function TFhirContract.GetResourceType : TFhirResourceType;
begin
  result := frtContract;
end;

procedure TFhirContract.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'legalState') Then
     list.add(self.link, 'legalState', FLegalState.Link);
  if (child_name = 'instantiatesCanonical') Then
     list.add(self.link, 'instantiatesCanonical', FInstantiatesCanonical.Link);
  if (child_name = 'instantiatesUri') Then
     list.add(self.link, 'instantiatesUri', FInstantiatesUri.Link);
  if (child_name = 'contentDerivative') Then
     list.add(self.link, 'contentDerivative', FContentDerivative.Link);
  if (child_name = 'issued') Then
     list.add(self.link, 'issued', FIssued.Link);
  if (child_name = 'applies') Then
     list.add(self.link, 'applies', FApplies.Link);
  if (child_name = 'expirationType') Then
     list.add(self.link, 'expirationType', FExpirationType.Link);
  if (child_name = 'subject') Then
    list.addAll(self, 'subject', FSubjectList);
  if (child_name = 'authority') Then
    list.addAll(self, 'authority', FAuthorityList);
  if (child_name = 'domain') Then
    list.addAll(self, 'domain', FDomainList);
  if (child_name = 'site') Then
    list.addAll(self, 'site', FSiteList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'subtitle') Then
     list.add(self.link, 'subtitle', FSubtitle.Link);
  if (child_name = 'alias') Then
    list.addAll(self, 'alias', FAliasList);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'scope') Then
     list.add(self.link, 'scope', FScope.Link);
  if (child_name = 'topic[x]') or (child_name = 'topic') Then
     list.add(self.link, 'topic[x]', FTopic.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subType') Then
    list.addAll(self, 'subType', FSubTypeList);
  if (child_name = 'contentDefinition') Then
     list.add(self.link, 'contentDefinition', FContentDefinition.Link);
  if (child_name = 'term') Then
    list.addAll(self, 'term', FTermList);
  if (child_name = 'supportingInfo') Then
    list.addAll(self, 'supportingInfo', FSupportingInfoList);
  if (child_name = 'relevantHistory') Then
    list.addAll(self, 'relevantHistory', FRelevantHistoryList);
  if (child_name = 'signer') Then
    list.addAll(self, 'signer', FSignerList);
  if (child_name = 'friendly') Then
    list.addAll(self, 'friendly', FFriendlyList);
  if (child_name = 'legal') Then
    list.addAll(self, 'legal', FLegalList);
  if (child_name = 'rule') Then
    list.addAll(self, 'rule', FRuleList);
  if (child_name = 'legallyBinding[x]') or (child_name = 'legallyBinding') Then
     list.add(self.link, 'legallyBinding[x]', FLegallyBinding.Link);
end;

procedure TFhirContract.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'legalState', 'CodeableConcept', false, TFhirCodeableConcept, FLegalState.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'Reference', false, TFhirReference, FInstantiatesCanonical.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', false, TFhirUri, FInstantiatesUri.Link));
  oList.add(TFHIRProperty.create(self, 'contentDerivative', 'CodeableConcept', false, TFhirCodeableConcept, FContentDerivative.Link));
  oList.add(TFHIRProperty.create(self, 'issued', 'dateTime', false, TFhirDateTime, FIssued.Link));
  oList.add(TFHIRProperty.create(self, 'applies', 'Period', false, TFhirPeriod, FApplies.Link));
  oList.add(TFHIRProperty.create(self, 'expirationType', 'CodeableConcept', false, TFhirCodeableConcept, FExpirationType.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', true, TFhirReference, FSubjectList.Link));
  oList.add(TFHIRProperty.create(self, 'authority', 'Reference', true, TFhirReference, FAuthorityList.Link));
  oList.add(TFHIRProperty.create(self, 'domain', 'Reference', true, TFhirReference, FDomainList.Link));
  oList.add(TFHIRProperty.create(self, 'site', 'Reference', true, TFhirReference, FSiteList.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'subtitle', 'string', false, TFhirString, FSubtitle.Link));
  oList.add(TFHIRProperty.create(self, 'alias', 'string', true, TFhirString, FAliasList.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', false, TFhirReference, FAuthor.Link));
  oList.add(TFHIRProperty.create(self, 'scope', 'CodeableConcept', false, TFhirCodeableConcept, FScope.Link));
  oList.add(TFHIRProperty.create(self, 'topic[x]', 'CodeableConcept|Reference', false, TFhirDataType, FTopic.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'subType', 'CodeableConcept', true, TFhirCodeableConcept, FSubTypeList.Link));
  oList.add(TFHIRProperty.create(self, 'contentDefinition', 'BackboneElement', false, TFhirContractContentDefinition, FContentDefinition.Link));
  oList.add(TFHIRProperty.create(self, 'term', 'BackboneElement', true, TFhirContractTerm, FTermList.Link));
  oList.add(TFHIRProperty.create(self, 'supportingInfo', 'Reference', true, TFhirReference, FSupportingInfoList.Link));
  oList.add(TFHIRProperty.create(self, 'relevantHistory', 'Reference', true, TFhirReference, FRelevantHistoryList.Link));
  oList.add(TFHIRProperty.create(self, 'signer', 'BackboneElement', true, TFhirContractSigner, FSignerList.Link));
  oList.add(TFHIRProperty.create(self, 'friendly', 'BackboneElement', true, TFhirContractFriendly, FFriendlyList.Link));
  oList.add(TFHIRProperty.create(self, 'legal', 'BackboneElement', true, TFhirContractLegal, FLegalList.Link));
  oList.add(TFHIRProperty.create(self, 'rule', 'BackboneElement', true, TFhirContractRule, FRuleList.Link));
  oList.add(TFHIRProperty.create(self, 'legallyBinding[x]', 'Attachment|Reference', false, TFhirDataType, FLegallyBinding.Link));
end;

function TFhirContract.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirContractResourceStatusCodesEnum, CODES_TFhirContractResourceStatusCodesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'legalState') then
  begin
    LegalState := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonical := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'contentDerivative') then
  begin
    ContentDerivative := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'issued') then
  begin
    IssuedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'applies') then
  begin
    Applies := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'expirationType') then
  begin
    ExpirationType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    SubjectList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'authority') then
  begin
    AuthorityList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'domain') then
  begin
    DomainList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'site') then
  begin
    SiteList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'subtitle') then
  begin
    SubtitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'alias') then
  begin
    AliasList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'scope') then
  begin
    Scope := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'topic', ['CodeableConcept', 'Reference'])) then
  begin
    Topic := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subType') then
  begin
    SubTypeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'contentDefinition') then
  begin
    ContentDefinition := propValue as TFhirContractContentDefinition;
    result := propValue;
  end
  else if (propName = 'term') then
  begin
    TermList.add(propValue as TFhirContractTerm);
    result := propValue;
  end
  else if (propName = 'supportingInfo') then
  begin
    SupportingInfoList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'relevantHistory') then
  begin
    RelevantHistoryList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'signer') then
  begin
    SignerList.add(propValue as TFhirContractSigner);
    result := propValue;
  end
  else if (propName = 'friendly') then
  begin
    FriendlyList.add(propValue as TFhirContractFriendly);
    result := propValue;
  end
  else if (propName = 'legal') then
  begin
    LegalList.add(propValue as TFhirContractLegal);
    result := propValue;
  end
  else if (propName = 'rule') then
  begin
    RuleList.add(propValue as TFhirContractRule);
    result := propValue;
  end
  else if (isMatchingName(propName, 'legallyBinding', ['Attachment', 'Reference'])) then
  begin
    LegallyBinding := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContract.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'subject') then SubjectList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'authority') then AuthorityList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'domain') then DomainList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'site') then SiteList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'alias') then AliasList.insertItem(index, asString(propValue))
  else if (propName = 'subType') then SubTypeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'term') then TermList.insertItem(index, propValue as TFhirContractTerm)
  else if (propName = 'supportingInfo') then SupportingInfoList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'relevantHistory') then RelevantHistoryList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'signer') then SignerList.insertItem(index, propValue as TFhirContractSigner)
  else if (propName = 'friendly') then FriendlyList.insertItem(index, propValue as TFhirContractFriendly)
  else if (propName = 'legal') then LegalList.insertItem(index, propValue as TFhirContractLegal)
  else if (propName = 'rule') then RuleList.insertItem(index, propValue as TFhirContractRule)
  else inherited;
end;

function TFhirContract.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirContractResourceStatusCodesEnum[ContractResourceStatusCodesNull], CODES_TFhirContractResourceStatusCodesEnum[ContractResourceStatusCodesNull]) 
  else if (propName = 'legalState') then result := TFhirCodeableConcept.create()
  else if (propName = 'instantiatesCanonical') then result := TFhirReference.create()
  else if (propName = 'instantiatesUri') then result := TFhirUri.create()
  else if (propName = 'contentDerivative') then result := TFhirCodeableConcept.create()
  else if (propName = 'issued') then result := TFhirDateTime.create()
  else if (propName = 'applies') then result := TFhirPeriod.create()
  else if (propName = 'expirationType') then result := TFhirCodeableConcept.create()
  else if (propName = 'subject') then result := SubjectList.new()
  else if (propName = 'authority') then result := AuthorityList.new()
  else if (propName = 'domain') then result := DomainList.new()
  else if (propName = 'site') then result := SiteList.new()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'subtitle') then result := TFhirString.create()
  else if (propName = 'alias') then result := AliasList.new()
  else if (propName = 'author') then result := TFhirReference.create()
  else if (propName = 'scope') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'topic', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Topic')
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'subType') then result := SubTypeList.new()
  else if (propName = 'contentDefinition') then result := TFhirContractContentDefinition.create()
  else if (propName = 'term') then result := TermList.new()
  else if (propName = 'supportingInfo') then result := SupportingInfoList.new()
  else if (propName = 'relevantHistory') then result := RelevantHistoryList.new()
  else if (propName = 'signer') then result := SignerList.new()
  else if (propName = 'friendly') then result := FriendlyList.new()
  else if (propName = 'legal') then result := LegalList.new()
  else if (propName = 'rule') then result := RuleList.new()
  else if (isMatchingName(propName, 'legallyBinding', ['Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property LegallyBinding')
  else result := inherited createPropertyValue(propName);
end;

function TFhirContract.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'url') then result := 'uri'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'legalState') then result := 'CodeableConcept'
  else if (propName = 'instantiatesCanonical') then result := 'Reference'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'contentDerivative') then result := 'CodeableConcept'
  else if (propName = 'issued') then result := 'dateTime'
  else if (propName = 'applies') then result := 'Period'
  else if (propName = 'expirationType') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'authority') then result := 'Reference'
  else if (propName = 'domain') then result := 'Reference'
  else if (propName = 'site') then result := 'Reference'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'subtitle') then result := 'string'
  else if (propName = 'alias') then result := 'string'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'scope') then result := 'CodeableConcept'
  else if (propName = 'topic[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subType') then result := 'CodeableConcept'
  else if (propName = 'contentDefinition') then result := 'BackboneElement'
  else if (propName = 'term') then result := 'BackboneElement'
  else if (propName = 'supportingInfo') then result := 'Reference'
  else if (propName = 'relevantHistory') then result := 'Reference'
  else if (propName = 'signer') then result := 'BackboneElement'
  else if (propName = 'friendly') then result := 'BackboneElement'
  else if (propName = 'legal') then result := 'BackboneElement'
  else if (propName = 'rule') then result := 'BackboneElement'
  else if (propName = 'legallyBinding[x]') then result := 'Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContract.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'url') then UrlElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'legalState') then LegalStateElement := nil
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalElement := nil
  else if (propName = 'instantiatesUri') then InstantiatesUriElement := nil
  else if (propName = 'contentDerivative') then ContentDerivativeElement := nil
  else if (propName = 'issued') then IssuedElement := nil
  else if (propName = 'applies') then AppliesElement := nil
  else if (propName = 'expirationType') then ExpirationTypeElement := nil
  else if (propName = 'subject') then deletePropertyValue('subject', SubjectList, value)
  else if (propName = 'authority') then deletePropertyValue('authority', AuthorityList, value)
  else if (propName = 'domain') then deletePropertyValue('domain', DomainList, value)
  else if (propName = 'site') then deletePropertyValue('site', SiteList, value)
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'subtitle') then SubtitleElement := nil
  else if (propName = 'alias') then deletePropertyValue('alias', AliasList, value)
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'scope') then ScopeElement := nil
  else if (isMatchingName(propName, 'topic', ['CodeableConcept', 'Reference'])) then TopicElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subType') then deletePropertyValue('subType', SubTypeList, value)
  else if (propName = 'contentDefinition') then ContentDefinitionElement := nil
  else if (propName = 'term') then deletePropertyValue('term', TermList, value)
  else if (propName = 'supportingInfo') then deletePropertyValue('supportingInfo', SupportingInfoList, value)
  else if (propName = 'relevantHistory') then deletePropertyValue('relevantHistory', RelevantHistoryList, value)
  else if (propName = 'signer') then deletePropertyValue('signer', SignerList, value)
  else if (propName = 'friendly') then deletePropertyValue('friendly', FriendlyList, value)
  else if (propName = 'legal') then deletePropertyValue('legal', LegalList, value)
  else if (propName = 'rule') then deletePropertyValue('rule', RuleList, value)
  else if (isMatchingName(propName, 'legallyBinding', ['Attachment', 'Reference'])) then LegallyBindingElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContract.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirContractResourceStatusCodesEnum, CODES_TFhirContractResourceStatusCodesEnum, new)
  else if (propName = 'legalState') then LegalStateElement := new as TFhirCodeableConcept
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalElement := new as TFhirReference
  else if (propName = 'instantiatesUri') then InstantiatesUriElement := asUri(new)
  else if (propName = 'contentDerivative') then ContentDerivativeElement := new as TFhirCodeableConcept
  else if (propName = 'issued') then IssuedElement := asDateTime(new)
  else if (propName = 'applies') then AppliesElement := new as TFhirPeriod
  else if (propName = 'expirationType') then ExpirationTypeElement := new as TFhirCodeableConcept
  else if (propName = 'subject') then replacePropertyValue('subject', SubjectList, existing, new)
  else if (propName = 'authority') then replacePropertyValue('authority', AuthorityList, existing, new)
  else if (propName = 'domain') then replacePropertyValue('domain', DomainList, existing, new)
  else if (propName = 'site') then replacePropertyValue('site', SiteList, existing, new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'subtitle') then SubtitleElement := asString(new)
  else if (propName = 'alias') then replacePropertyValue('alias', AliasList, existing, new)
  else if (propName = 'author') then AuthorElement := new as TFhirReference
  else if (propName = 'scope') then ScopeElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'topic', ['CodeableConcept', 'Reference'])) then TopicElement := new as TFhirDataType
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'subType') then replacePropertyValue('subType', SubTypeList, existing, new)
  else if (propName = 'contentDefinition') then ContentDefinitionElement := new as TFhirContractContentDefinition
  else if (propName = 'term') then replacePropertyValue('term', TermList, existing, new)
  else if (propName = 'supportingInfo') then replacePropertyValue('supportingInfo', SupportingInfoList, existing, new)
  else if (propName = 'relevantHistory') then replacePropertyValue('relevantHistory', RelevantHistoryList, existing, new)
  else if (propName = 'signer') then replacePropertyValue('signer', SignerList, existing, new)
  else if (propName = 'friendly') then replacePropertyValue('friendly', FriendlyList, existing, new)
  else if (propName = 'legal') then replacePropertyValue('legal', LegalList, existing, new)
  else if (propName = 'rule') then replacePropertyValue('rule', RuleList, existing, new)
  else if (isMatchingName(propName, 'legallyBinding', ['Attachment', 'Reference'])) then LegallyBindingElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContract.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'subject') then SubjectList.move(source, destination)
  else if (propName = 'authority') then AuthorityList.move(source, destination)
  else if (propName = 'domain') then DomainList.move(source, destination)
  else if (propName = 'site') then SiteList.move(source, destination)
  else if (propName = 'alias') then AliasList.move(source, destination)
  else if (propName = 'subType') then SubTypeList.move(source, destination)
  else if (propName = 'term') then TermList.move(source, destination)
  else if (propName = 'supportingInfo') then SupportingInfoList.move(source, destination)
  else if (propName = 'relevantHistory') then RelevantHistoryList.move(source, destination)
  else if (propName = 'signer') then SignerList.move(source, destination)
  else if (propName = 'friendly') then FriendlyList.move(source, destination)
  else if (propName = 'legal') then LegalList.move(source, destination)
  else if (propName = 'rule') then RuleList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContract.fhirType : string;
begin
  result := 'Contract';
end;

function TFhirContract.Link : TFhirContract;
begin
  result := TFhirContract(inherited Link);
end;

function TFhirContract.Clone : TFhirContract;
begin
  result := TFhirContract(inherited Clone);
end;

function TFhirContract.equals(other : TObject) : boolean; 
var
  o : TFhirContract;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContract)) then
    result := false
  else
  begin
    o := TFhirContract(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(urlElement, o.urlElement, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(legalStateElement, o.legalStateElement, true) and compareDeep(instantiatesCanonicalElement, o.instantiatesCanonicalElement, true) and 
      compareDeep(instantiatesUriElement, o.instantiatesUriElement, true) and compareDeep(contentDerivativeElement, o.contentDerivativeElement, true) and 
      compareDeep(issuedElement, o.issuedElement, true) and compareDeep(appliesElement, o.appliesElement, true) and 
      compareDeep(expirationTypeElement, o.expirationTypeElement, true) and compareDeep(subjectList, o.subjectList, true) and 
      compareDeep(authorityList, o.authorityList, true) and compareDeep(domainList, o.domainList, true) and 
      compareDeep(siteList, o.siteList, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(subtitleElement, o.subtitleElement, true) and 
      compareDeep(aliasList, o.aliasList, true) and compareDeep(authorElement, o.authorElement, true) and 
      compareDeep(scopeElement, o.scopeElement, true) and compareDeep(topicElement, o.topicElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subTypeList, o.subTypeList, true) and 
      compareDeep(contentDefinitionElement, o.contentDefinitionElement, true) and compareDeep(termList, o.termList, true) and 
      compareDeep(supportingInfoList, o.supportingInfoList, true) and compareDeep(relevantHistoryList, o.relevantHistoryList, true) and 
      compareDeep(signerList, o.signerList, true) and compareDeep(friendlyList, o.friendlyList, true) and 
      compareDeep(legalList, o.legalList, true) and compareDeep(ruleList, o.ruleList, true) and 
      compareDeep(legallyBindingElement, o.legallyBindingElement, true);
  end;
end;

function TFhirContract.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FUrl) and isEmptyProp(FVersion) and isEmptyProp(FStatus) and isEmptyProp(FLegalState) and isEmptyProp(FInstantiatesCanonical) and isEmptyProp(FInstantiatesUri) and isEmptyProp(FContentDerivative) and isEmptyProp(FIssued) and isEmptyProp(FApplies) and isEmptyProp(FExpirationType) and isEmptyProp(FsubjectList) and isEmptyProp(FauthorityList) and isEmptyProp(FdomainList) and isEmptyProp(FsiteList) and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FSubtitle) and isEmptyProp(FaliasList) and isEmptyProp(FAuthor) and isEmptyProp(FScope) and isEmptyProp(FTopic) and isEmptyProp(FType_) and isEmptyProp(FsubTypeList) and isEmptyProp(FContentDefinition) and isEmptyProp(FtermList) and isEmptyProp(FsupportingInfoList) and isEmptyProp(FrelevantHistoryList) and isEmptyProp(FsignerList) and isEmptyProp(FfriendlyList) and isEmptyProp(FlegalList) and isEmptyProp(FruleList) and isEmptyProp(FLegallyBinding);
end;

procedure TFhirContract.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('url');
  fields.add('version');
  fields.add('status');
  fields.add('legalState');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('contentDerivative');
  fields.add('issued');
  fields.add('applies');
  fields.add('expirationType');
  fields.add('subject');
  fields.add('authority');
  fields.add('domain');
  fields.add('site');
  fields.add('name');
  fields.add('title');
  fields.add('subtitle');
  fields.add('alias');
  fields.add('author');
  fields.add('scope');
  fields.add('topic[x]');
  fields.add('type');
  fields.add('subType');
  fields.add('contentDefinition');
  fields.add('term');
  fields.add('supportingInfo');
  fields.add('relevantHistory');
  fields.add('signer');
  fields.add('friendly');
  fields.add('legal');
  fields.add('rule');
  fields.add('legallyBinding[x]');
end;

function TFhirContract.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FSubjectList.sizeInBytes(magic));
  inc(result, FAuthorityList.sizeInBytes(magic));
  inc(result, FDomainList.sizeInBytes(magic));
  inc(result, FSiteList.sizeInBytes(magic));
  inc(result, FAliasList.sizeInBytes(magic));
  inc(result, FSubTypeList.sizeInBytes(magic));
  inc(result, FTermList.sizeInBytes(magic));
  inc(result, FSupportingInfoList.sizeInBytes(magic));
  inc(result, FRelevantHistoryList.sizeInBytes(magic));
  inc(result, FSignerList.sizeInBytes(magic));
  inc(result, FFriendlyList.sizeInBytes(magic));
  inc(result, FLegalList.sizeInBytes(magic));
  inc(result, FRuleList.sizeInBytes(magic));
end;

function TFhirContract.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirContract.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirContract.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirContract.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirContract.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

procedure TFhirContract.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirContract.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirContract.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirContract.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirContract.GetStatusST : TFhirContractResourceStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirContractResourceStatusCodesEnum(0)
  else
    result := TFhirContractResourceStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirContractResourceStatusCodesEnum, FStatus.value));
end;

procedure TFhirContract.SetStatusST(value : TFhirContractResourceStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirContractResourceStatusCodesEnum[value], CODES_TFhirContractResourceStatusCodesEnum[value]);
end;

procedure TFhirContract.SetLegalState(value : TFhirCodeableConcept);
begin
  FLegalState.free;
  FLegalState := value;
end;

procedure TFhirContract.SetInstantiatesCanonical(value : TFhirReference);
begin
  FInstantiatesCanonical.free;
  FInstantiatesCanonical := value;
end;

procedure TFhirContract.SetInstantiatesUri(value : TFhirUri);
begin
  FInstantiatesUri.free;
  FInstantiatesUri := value;
end;

function TFhirContract.GetInstantiatesUriST : String;
begin
  if FInstantiatesUri = nil then
    result := ''
  else
    result := FInstantiatesUri.value;
end;

procedure TFhirContract.SetInstantiatesUriST(value : String);
begin
  if value <> '' then
  begin
    if FInstantiatesUri = nil then
      FInstantiatesUri := TFhirUri.create;
    FInstantiatesUri.value := value
  end
  else if FInstantiatesUri <> nil then
    FInstantiatesUri.value := '';
end;

procedure TFhirContract.SetContentDerivative(value : TFhirCodeableConcept);
begin
  FContentDerivative.free;
  FContentDerivative := value;
end;

procedure TFhirContract.SetIssued(value : TFhirDateTime);
begin
  FIssued.free;
  FIssued := value;
end;

function TFhirContract.GetIssuedST : TFslDateTime;
begin
  if FIssued = nil then
    result := TFslDateTime.makeNull
  else
    result := FIssued.value;
end;

procedure TFhirContract.SetIssuedST(value : TFslDateTime);
begin
  if FIssued = nil then
    FIssued := TFhirDateTime.create;
  FIssued.value := value
end;

procedure TFhirContract.SetApplies(value : TFhirPeriod);
begin
  FApplies.free;
  FApplies := value;
end;

procedure TFhirContract.SetExpirationType(value : TFhirCodeableConcept);
begin
  FExpirationType.free;
  FExpirationType := value;
end;

function TFhirContract.GetSubjectList : TFhirReferenceList;
begin
  if FSubjectList = nil then
    FSubjectList := TFhirReferenceList.Create;
  result := FSubjectList;
end;

function TFhirContract.GetHasSubjectList : boolean;
begin
  result := (FSubjectList <> nil) and (FSubjectList.count > 0);
end;

function TFhirContract.GetAuthorityList : TFhirReferenceList;
begin
  if FAuthorityList = nil then
    FAuthorityList := TFhirReferenceList.Create;
  result := FAuthorityList;
end;

function TFhirContract.GetHasAuthorityList : boolean;
begin
  result := (FAuthorityList <> nil) and (FAuthorityList.count > 0);
end;

function TFhirContract.GetDomainList : TFhirReferenceList;
begin
  if FDomainList = nil then
    FDomainList := TFhirReferenceList.Create;
  result := FDomainList;
end;

function TFhirContract.GetHasDomainList : boolean;
begin
  result := (FDomainList <> nil) and (FDomainList.count > 0);
end;

function TFhirContract.GetSiteList : TFhirReferenceList;
begin
  if FSiteList = nil then
    FSiteList := TFhirReferenceList.Create;
  result := FSiteList;
end;

function TFhirContract.GetHasSiteList : boolean;
begin
  result := (FSiteList <> nil) and (FSiteList.count > 0);
end;

procedure TFhirContract.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirContract.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirContract.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirContract.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirContract.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirContract.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirContract.SetSubtitle(value : TFhirString);
begin
  FSubtitle.free;
  FSubtitle := value;
end;

function TFhirContract.GetSubtitleST : String;
begin
  if FSubtitle = nil then
    result := ''
  else
    result := FSubtitle.value;
end;

procedure TFhirContract.SetSubtitleST(value : String);
begin
  if value <> '' then
  begin
    if FSubtitle = nil then
      FSubtitle := TFhirString.create;
    FSubtitle.value := value
  end
  else if FSubtitle <> nil then
    FSubtitle.value := '';
end;

function TFhirContract.GetAliasList : TFhirStringList;
begin
  if FAliasList = nil then
    FAliasList := TFhirStringList.Create;
  result := FAliasList;
end;

function TFhirContract.GetHasAliasList : boolean;
begin
  result := (FAliasList <> nil) and (FAliasList.count > 0);
end;

procedure TFhirContract.SetAuthor(value : TFhirReference);
begin
  FAuthor.free;
  FAuthor := value;
end;

procedure TFhirContract.SetScope(value : TFhirCodeableConcept);
begin
  FScope.free;
  FScope := value;
end;

procedure TFhirContract.SetTopic(value : TFhirDataType);
begin
  FTopic.free;
  FTopic := value;
end;

procedure TFhirContract.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirContract.GetSubTypeList : TFhirCodeableConceptList;
begin
  if FSubTypeList = nil then
    FSubTypeList := TFhirCodeableConceptList.Create;
  result := FSubTypeList;
end;

function TFhirContract.GetHasSubTypeList : boolean;
begin
  result := (FSubTypeList <> nil) and (FSubTypeList.count > 0);
end;

procedure TFhirContract.SetContentDefinition(value : TFhirContractContentDefinition);
begin
  FContentDefinition.free;
  FContentDefinition := value;
end;

function TFhirContract.GetTermList : TFhirContractTermList;
begin
  if FTermList = nil then
    FTermList := TFhirContractTermList.Create;
  result := FTermList;
end;

function TFhirContract.GetHasTermList : boolean;
begin
  result := (FTermList <> nil) and (FTermList.count > 0);
end;

function TFhirContract.GetSupportingInfoList : TFhirReferenceList;
begin
  if FSupportingInfoList = nil then
    FSupportingInfoList := TFhirReferenceList.Create;
  result := FSupportingInfoList;
end;

function TFhirContract.GetHasSupportingInfoList : boolean;
begin
  result := (FSupportingInfoList <> nil) and (FSupportingInfoList.count > 0);
end;

function TFhirContract.GetRelevantHistoryList : TFhirReferenceList;
begin
  if FRelevantHistoryList = nil then
    FRelevantHistoryList := TFhirReferenceList.Create;
  result := FRelevantHistoryList;
end;

function TFhirContract.GetHasRelevantHistoryList : boolean;
begin
  result := (FRelevantHistoryList <> nil) and (FRelevantHistoryList.count > 0);
end;

function TFhirContract.GetSignerList : TFhirContractSignerList;
begin
  if FSignerList = nil then
    FSignerList := TFhirContractSignerList.Create;
  result := FSignerList;
end;

function TFhirContract.GetHasSignerList : boolean;
begin
  result := (FSignerList <> nil) and (FSignerList.count > 0);
end;

function TFhirContract.GetFriendlyList : TFhirContractFriendlyList;
begin
  if FFriendlyList = nil then
    FFriendlyList := TFhirContractFriendlyList.Create;
  result := FFriendlyList;
end;

function TFhirContract.GetHasFriendlyList : boolean;
begin
  result := (FFriendlyList <> nil) and (FFriendlyList.count > 0);
end;

function TFhirContract.GetLegalList : TFhirContractLegalList;
begin
  if FLegalList = nil then
    FLegalList := TFhirContractLegalList.Create;
  result := FLegalList;
end;

function TFhirContract.GetHasLegalList : boolean;
begin
  result := (FLegalList <> nil) and (FLegalList.count > 0);
end;

function TFhirContract.GetRuleList : TFhirContractRuleList;
begin
  if FRuleList = nil then
    FRuleList := TFhirContractRuleList.Create;
  result := FRuleList;
end;

function TFhirContract.GetHasRuleList : boolean;
begin
  result := (FRuleList <> nil) and (FRuleList.count > 0);
end;

procedure TFhirContract.SetLegallyBinding(value : TFhirDataType);
begin
  FLegallyBinding.free;
  FLegallyBinding := value;
end;

{ TFhirContractListEnumerator }

constructor TFhirContractListEnumerator.Create(list : TFhirContractList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractListEnumerator.GetCurrent : TFhirContract;
begin
  Result := FList[FIndex];
end;

function TFhirContractListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractList }

function TFhirContractList.AddItem(value: TFhirContract): TFhirContract;
begin
  assert(value.ClassName = 'TFhirContract', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContract');
  add(value);
  result := value;
end;

function TFhirContractList.Append: TFhirContract;
begin
  result := TFhirContract.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractList.ClearItems;
begin
  Clear;
end;

function TFhirContractList.GetEnumerator : TFhirContractListEnumerator;
begin
  result := TFhirContractListEnumerator.Create(self.link);
end;

function TFhirContractList.Clone: TFhirContractList;
begin
  result := TFhirContractList(inherited Clone);
end;

function TFhirContractList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractList.GetItemN(index: Integer): TFhirContract;
begin
  result := TFhirContract(ObjectByIndex[index]);
end;

function TFhirContractList.ItemClass: TFslObjectClass;
begin
  result := TFhirContract;
end;
function TFhirContractList.IndexOf(value: TFhirContract): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractList.Insert(index: Integer): TFhirContract;
begin
  result := TFhirContract.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractList.InsertItem(index: Integer; value: TFhirContract);
begin
  assert(value is TFhirContract);
  Inherited Insert(index, value);
end;

function TFhirContractList.Item(index: Integer): TFhirContract;
begin
  result := TFhirContract(ObjectByIndex[index]);
end;

function TFhirContractList.Link: TFhirContractList;
begin
  result := TFhirContractList(inherited Link);
end;

procedure TFhirContractList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractList.SetItemByIndex(index: Integer; value: TFhirContract);
begin
  assert(value is TFhirContract);
  FhirContracts[index] := value;
end;

procedure TFhirContractList.SetItemN(index: Integer; value: TFhirContract);
begin
  assert(value is TFhirContract);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_EVIDENCE}
{ TFhirEvidenceVariableDefinition }

constructor TFhirEvidenceVariableDefinition.Create;
begin
  inherited;
end;

destructor TFhirEvidenceVariableDefinition.Destroy;
begin
  FDescription.free;
  FNoteList.Free;
  FVariableRole.free;
  FObserved.free;
  FIntended.free;
  FDirectnessMatch.free;
  inherited;
end;

procedure TFhirEvidenceVariableDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirEvidenceVariableDefinition(oSource).descriptionElement.Clone;
  if (TFhirEvidenceVariableDefinition(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEvidenceVariableDefinition(oSource).FNoteList);
  end;
  variableRole := TFhirEvidenceVariableDefinition(oSource).variableRole.Clone;
  observed := TFhirEvidenceVariableDefinition(oSource).observed.Clone;
  intended := TFhirEvidenceVariableDefinition(oSource).intended.Clone;
  directnessMatch := TFhirEvidenceVariableDefinition(oSource).directnessMatch.Clone;
end;

procedure TFhirEvidenceVariableDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'variableRole') Then
     list.add(self.link, 'variableRole', FVariableRole.Link);
  if (child_name = 'observed') Then
     list.add(self.link, 'observed', FObserved.Link);
  if (child_name = 'intended') Then
     list.add(self.link, 'intended', FIntended.Link);
  if (child_name = 'directnessMatch') Then
     list.add(self.link, 'directnessMatch', FDirectnessMatch.Link);
end;

procedure TFhirEvidenceVariableDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'variableRole', 'CodeableConcept', false, TFhirCodeableConcept, FVariableRole.Link));
  oList.add(TFHIRProperty.create(self, 'observed', 'Reference', false, TFhirReference, FObserved.Link));
  oList.add(TFHIRProperty.create(self, 'intended', 'Reference', false, TFhirReference, FIntended.Link));
  oList.add(TFHIRProperty.create(self, 'directnessMatch', 'CodeableConcept', false, TFhirCodeableConcept, FDirectnessMatch.Link));
end;

function TFhirEvidenceVariableDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'variableRole') then
  begin
    VariableRole := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'observed') then
  begin
    Observed := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'intended') then
  begin
    Intended := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'directnessMatch') then
  begin
    DirectnessMatch := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceVariableDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirEvidenceVariableDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'variableRole') then result := TFhirCodeableConcept.create()
  else if (propName = 'observed') then result := TFhirReference.create()
  else if (propName = 'intended') then result := TFhirReference.create()
  else if (propName = 'directnessMatch') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceVariableDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'markdown'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'variableRole') then result := 'CodeableConcept'
  else if (propName = 'observed') then result := 'Reference'
  else if (propName = 'intended') then result := 'Reference'
  else if (propName = 'directnessMatch') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceVariableDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'variableRole') then VariableRoleElement := nil
  else if (propName = 'observed') then ObservedElement := nil
  else if (propName = 'intended') then IntendedElement := nil
  else if (propName = 'directnessMatch') then DirectnessMatchElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceVariableDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'variableRole') then VariableRoleElement := new as TFhirCodeableConcept
  else if (propName = 'observed') then ObservedElement := new as TFhirReference
  else if (propName = 'intended') then IntendedElement := new as TFhirReference
  else if (propName = 'directnessMatch') then DirectnessMatchElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceVariableDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceVariableDefinition.fhirType : string;
begin
  result := 'Evidence.variableDefinition';
end;

function TFhirEvidenceVariableDefinition.Link : TFhirEvidenceVariableDefinition;
begin
  result := TFhirEvidenceVariableDefinition(inherited Link);
end;

function TFhirEvidenceVariableDefinition.Clone : TFhirEvidenceVariableDefinition;
begin
  result := TFhirEvidenceVariableDefinition(inherited Clone);
end;

function TFhirEvidenceVariableDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceVariableDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceVariableDefinition)) then
    result := false
  else
  begin
    o := TFhirEvidenceVariableDefinition(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(variableRoleElement, o.variableRoleElement, true) and compareDeep(observedElement, o.observedElement, true) and 
      compareDeep(intendedElement, o.intendedElement, true) and compareDeep(directnessMatchElement, o.directnessMatchElement, true);
  end;
end;

function TFhirEvidenceVariableDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FnoteList) and isEmptyProp(FVariableRole) and isEmptyProp(FObserved) and isEmptyProp(FIntended) and isEmptyProp(FDirectnessMatch);
end;

procedure TFhirEvidenceVariableDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('note');
  fields.add('variableRole');
  fields.add('observed');
  fields.add('intended');
  fields.add('directnessMatch');
end;

function TFhirEvidenceVariableDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FNoteList.sizeInBytes(magic));
end;

procedure TFhirEvidenceVariableDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirEvidenceVariableDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirEvidenceVariableDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirEvidenceVariableDefinition.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirEvidenceVariableDefinition.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirEvidenceVariableDefinition.SetVariableRole(value : TFhirCodeableConcept);
begin
  FVariableRole.free;
  FVariableRole := value;
end;

procedure TFhirEvidenceVariableDefinition.SetObserved(value : TFhirReference);
begin
  FObserved.free;
  FObserved := value;
end;

procedure TFhirEvidenceVariableDefinition.SetIntended(value : TFhirReference);
begin
  FIntended.free;
  FIntended := value;
end;

procedure TFhirEvidenceVariableDefinition.SetDirectnessMatch(value : TFhirCodeableConcept);
begin
  FDirectnessMatch.free;
  FDirectnessMatch := value;
end;

{ TFhirEvidenceVariableDefinitionListEnumerator }

constructor TFhirEvidenceVariableDefinitionListEnumerator.Create(list : TFhirEvidenceVariableDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceVariableDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceVariableDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceVariableDefinitionListEnumerator.GetCurrent : TFhirEvidenceVariableDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceVariableDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceVariableDefinitionList }

function TFhirEvidenceVariableDefinitionList.AddItem(value: TFhirEvidenceVariableDefinition): TFhirEvidenceVariableDefinition;
begin
  assert(value.ClassName = 'TFhirEvidenceVariableDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceVariableDefinition');
  add(value);
  result := value;
end;

function TFhirEvidenceVariableDefinitionList.Append: TFhirEvidenceVariableDefinition;
begin
  result := TFhirEvidenceVariableDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceVariableDefinitionList.GetEnumerator : TFhirEvidenceVariableDefinitionListEnumerator;
begin
  result := TFhirEvidenceVariableDefinitionListEnumerator.Create(self.link);
end;

function TFhirEvidenceVariableDefinitionList.Clone: TFhirEvidenceVariableDefinitionList;
begin
  result := TFhirEvidenceVariableDefinitionList(inherited Clone);
end;

function TFhirEvidenceVariableDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceVariableDefinitionList.GetItemN(index: Integer): TFhirEvidenceVariableDefinition;
begin
  result := TFhirEvidenceVariableDefinition(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceVariableDefinition;
end;
function TFhirEvidenceVariableDefinitionList.IndexOf(value: TFhirEvidenceVariableDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceVariableDefinitionList.Insert(index: Integer): TFhirEvidenceVariableDefinition;
begin
  result := TFhirEvidenceVariableDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableDefinitionList.InsertItem(index: Integer; value: TFhirEvidenceVariableDefinition);
begin
  assert(value is TFhirEvidenceVariableDefinition);
  Inherited Insert(index, value);
end;

function TFhirEvidenceVariableDefinitionList.Item(index: Integer): TFhirEvidenceVariableDefinition;
begin
  result := TFhirEvidenceVariableDefinition(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableDefinitionList.Link: TFhirEvidenceVariableDefinitionList;
begin
  result := TFhirEvidenceVariableDefinitionList(inherited Link);
end;

procedure TFhirEvidenceVariableDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceVariableDefinitionList.SetItemByIndex(index: Integer; value: TFhirEvidenceVariableDefinition);
begin
  assert(value is TFhirEvidenceVariableDefinition);
  FhirEvidenceVariableDefinitions[index] := value;
end;

procedure TFhirEvidenceVariableDefinitionList.SetItemN(index: Integer; value: TFhirEvidenceVariableDefinition);
begin
  assert(value is TFhirEvidenceVariableDefinition);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceStatistic }

constructor TFhirEvidenceStatistic.Create;
begin
  inherited;
end;

destructor TFhirEvidenceStatistic.Destroy;
begin
  FDescription.free;
  FNoteList.Free;
  FStatisticType.free;
  FCategory.free;
  FQuantity.free;
  FNumberOfEvents.free;
  FNumberAffected.free;
  FSampleSize.free;
  FAttributeEstimateList.Free;
  FModelCharacteristicList.Free;
  inherited;
end;

procedure TFhirEvidenceStatistic.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirEvidenceStatistic(oSource).descriptionElement.Clone;
  if (TFhirEvidenceStatistic(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEvidenceStatistic(oSource).FNoteList);
  end;
  statisticType := TFhirEvidenceStatistic(oSource).statisticType.Clone;
  category := TFhirEvidenceStatistic(oSource).category.Clone;
  quantity := TFhirEvidenceStatistic(oSource).quantity.Clone;
  numberOfEventsElement := TFhirEvidenceStatistic(oSource).numberOfEventsElement.Clone;
  numberAffectedElement := TFhirEvidenceStatistic(oSource).numberAffectedElement.Clone;
  sampleSize := TFhirEvidenceStatistic(oSource).sampleSize.Clone;
  if (TFhirEvidenceStatistic(oSource).FAttributeEstimateList = nil) then
  begin
    FAttributeEstimateList.free;
    FAttributeEstimateList := nil;
  end
  else
  begin
    if FAttributeEstimateList = nil then
      FAttributeEstimateList := TFhirEvidenceStatisticAttributeEstimateList.Create;
    FAttributeEstimateList.Assign(TFhirEvidenceStatistic(oSource).FAttributeEstimateList);
  end;
  if (TFhirEvidenceStatistic(oSource).FModelCharacteristicList = nil) then
  begin
    FModelCharacteristicList.free;
    FModelCharacteristicList := nil;
  end
  else
  begin
    if FModelCharacteristicList = nil then
      FModelCharacteristicList := TFhirEvidenceStatisticModelCharacteristicList.Create;
    FModelCharacteristicList.Assign(TFhirEvidenceStatistic(oSource).FModelCharacteristicList);
  end;
end;

procedure TFhirEvidenceStatistic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'statisticType') Then
     list.add(self.link, 'statisticType', FStatisticType.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'numberOfEvents') Then
     list.add(self.link, 'numberOfEvents', FNumberOfEvents.Link);
  if (child_name = 'numberAffected') Then
     list.add(self.link, 'numberAffected', FNumberAffected.Link);
  if (child_name = 'sampleSize') Then
     list.add(self.link, 'sampleSize', FSampleSize.Link);
  if (child_name = 'attributeEstimate') Then
    list.addAll(self, 'attributeEstimate', FAttributeEstimateList);
  if (child_name = 'modelCharacteristic') Then
    list.addAll(self, 'modelCharacteristic', FModelCharacteristicList);
end;

procedure TFhirEvidenceStatistic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'statisticType', 'CodeableConcept', false, TFhirCodeableConcept, FStatisticType.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'numberOfEvents', 'unsignedInt', false, TFhirUnsignedInt, FNumberOfEvents.Link));
  oList.add(TFHIRProperty.create(self, 'numberAffected', 'unsignedInt', false, TFhirUnsignedInt, FNumberAffected.Link));
  oList.add(TFHIRProperty.create(self, 'sampleSize', 'BackboneElement', false, TFhirEvidenceStatisticSampleSize, FSampleSize.Link));
  oList.add(TFHIRProperty.create(self, 'attributeEstimate', 'BackboneElement', true, TFhirEvidenceStatisticAttributeEstimate, FAttributeEstimateList.Link));
  oList.add(TFHIRProperty.create(self, 'modelCharacteristic', 'BackboneElement', true, TFhirEvidenceStatisticModelCharacteristic, FModelCharacteristicList.Link));
end;

function TFhirEvidenceStatistic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'statisticType') then
  begin
    StatisticType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'numberOfEvents') then
  begin
    NumberOfEventsElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'numberAffected') then
  begin
    NumberAffectedElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'sampleSize') then
  begin
    SampleSize := propValue as TFhirEvidenceStatisticSampleSize;
    result := propValue;
  end
  else if (propName = 'attributeEstimate') then
  begin
    AttributeEstimateList.add(propValue as TFhirEvidenceStatisticAttributeEstimate);
    result := propValue;
  end
  else if (propName = 'modelCharacteristic') then
  begin
    ModelCharacteristicList.add(propValue as TFhirEvidenceStatisticModelCharacteristic);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceStatistic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'attributeEstimate') then AttributeEstimateList.insertItem(index, propValue as TFhirEvidenceStatisticAttributeEstimate)
  else if (propName = 'modelCharacteristic') then ModelCharacteristicList.insertItem(index, propValue as TFhirEvidenceStatisticModelCharacteristic)
  else inherited;
end;

function TFhirEvidenceStatistic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'statisticType') then result := TFhirCodeableConcept.create()
  else if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'numberOfEvents') then result := TFhirUnsignedInt.create()
  else if (propName = 'numberAffected') then result := TFhirUnsignedInt.create()
  else if (propName = 'sampleSize') then result := TFhirEvidenceStatisticSampleSize.create()
  else if (propName = 'attributeEstimate') then result := AttributeEstimateList.new()
  else if (propName = 'modelCharacteristic') then result := ModelCharacteristicList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceStatistic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'statisticType') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'numberOfEvents') then result := 'unsignedInt'
  else if (propName = 'numberAffected') then result := 'unsignedInt'
  else if (propName = 'sampleSize') then result := 'BackboneElement'
  else if (propName = 'attributeEstimate') then result := 'BackboneElement'
  else if (propName = 'modelCharacteristic') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceStatistic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'statisticType') then StatisticTypeElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'numberOfEvents') then NumberOfEventsElement := nil
  else if (propName = 'numberAffected') then NumberAffectedElement := nil
  else if (propName = 'sampleSize') then SampleSizeElement := nil
  else if (propName = 'attributeEstimate') then deletePropertyValue('attributeEstimate', AttributeEstimateList, value)
  else if (propName = 'modelCharacteristic') then deletePropertyValue('modelCharacteristic', ModelCharacteristicList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceStatistic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'statisticType') then StatisticTypeElement := new as TFhirCodeableConcept
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'numberOfEvents') then NumberOfEventsElement := asUnsignedInt(new)
  else if (propName = 'numberAffected') then NumberAffectedElement := asUnsignedInt(new)
  else if (propName = 'sampleSize') then SampleSizeElement := new as TFhirEvidenceStatisticSampleSize
  else if (propName = 'attributeEstimate') then replacePropertyValue('attributeEstimate', AttributeEstimateList, existing, new)
  else if (propName = 'modelCharacteristic') then replacePropertyValue('modelCharacteristic', ModelCharacteristicList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceStatistic.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'attributeEstimate') then AttributeEstimateList.move(source, destination)
  else if (propName = 'modelCharacteristic') then ModelCharacteristicList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceStatistic.fhirType : string;
begin
  result := 'Evidence.statistic';
end;

function TFhirEvidenceStatistic.Link : TFhirEvidenceStatistic;
begin
  result := TFhirEvidenceStatistic(inherited Link);
end;

function TFhirEvidenceStatistic.Clone : TFhirEvidenceStatistic;
begin
  result := TFhirEvidenceStatistic(inherited Clone);
end;

function TFhirEvidenceStatistic.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceStatistic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceStatistic)) then
    result := false
  else
  begin
    o := TFhirEvidenceStatistic(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(statisticTypeElement, o.statisticTypeElement, true) and compareDeep(categoryElement, o.categoryElement, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(numberOfEventsElement, o.numberOfEventsElement, true) and 
      compareDeep(numberAffectedElement, o.numberAffectedElement, true) and compareDeep(sampleSizeElement, o.sampleSizeElement, true) and 
      compareDeep(attributeEstimateList, o.attributeEstimateList, true) and compareDeep(modelCharacteristicList, o.modelCharacteristicList, true);
  end;
end;

function TFhirEvidenceStatistic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FnoteList) and isEmptyProp(FStatisticType) and isEmptyProp(FCategory) and isEmptyProp(FQuantity) and isEmptyProp(FNumberOfEvents) and isEmptyProp(FNumberAffected) and isEmptyProp(FSampleSize) and isEmptyProp(FattributeEstimateList) and isEmptyProp(FmodelCharacteristicList);
end;

procedure TFhirEvidenceStatistic.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('note');
  fields.add('statisticType');
  fields.add('category');
  fields.add('quantity');
  fields.add('numberOfEvents');
  fields.add('numberAffected');
  fields.add('sampleSize');
  fields.add('attributeEstimate');
  fields.add('modelCharacteristic');
end;

function TFhirEvidenceStatistic.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FAttributeEstimateList.sizeInBytes(magic));
  inc(result, FModelCharacteristicList.sizeInBytes(magic));
end;

procedure TFhirEvidenceStatistic.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirEvidenceStatistic.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirEvidenceStatistic.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirEvidenceStatistic.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirEvidenceStatistic.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirEvidenceStatistic.SetStatisticType(value : TFhirCodeableConcept);
begin
  FStatisticType.free;
  FStatisticType := value;
end;

procedure TFhirEvidenceStatistic.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirEvidenceStatistic.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirEvidenceStatistic.SetNumberOfEvents(value : TFhirUnsignedInt);
begin
  FNumberOfEvents.free;
  FNumberOfEvents := value;
end;

function TFhirEvidenceStatistic.GetNumberOfEventsST : String;
begin
  if FNumberOfEvents = nil then
    result := ''
  else
    result := FNumberOfEvents.value;
end;

procedure TFhirEvidenceStatistic.SetNumberOfEventsST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfEvents = nil then
      FNumberOfEvents := TFhirUnsignedInt.create;
    FNumberOfEvents.value := value
  end
  else if FNumberOfEvents <> nil then
    FNumberOfEvents.value := '';
end;

procedure TFhirEvidenceStatistic.SetNumberAffected(value : TFhirUnsignedInt);
begin
  FNumberAffected.free;
  FNumberAffected := value;
end;

function TFhirEvidenceStatistic.GetNumberAffectedST : String;
begin
  if FNumberAffected = nil then
    result := ''
  else
    result := FNumberAffected.value;
end;

procedure TFhirEvidenceStatistic.SetNumberAffectedST(value : String);
begin
  if value <> '' then
  begin
    if FNumberAffected = nil then
      FNumberAffected := TFhirUnsignedInt.create;
    FNumberAffected.value := value
  end
  else if FNumberAffected <> nil then
    FNumberAffected.value := '';
end;

procedure TFhirEvidenceStatistic.SetSampleSize(value : TFhirEvidenceStatisticSampleSize);
begin
  FSampleSize.free;
  FSampleSize := value;
end;

function TFhirEvidenceStatistic.GetAttributeEstimateList : TFhirEvidenceStatisticAttributeEstimateList;
begin
  if FAttributeEstimateList = nil then
    FAttributeEstimateList := TFhirEvidenceStatisticAttributeEstimateList.Create;
  result := FAttributeEstimateList;
end;

function TFhirEvidenceStatistic.GetHasAttributeEstimateList : boolean;
begin
  result := (FAttributeEstimateList <> nil) and (FAttributeEstimateList.count > 0);
end;

function TFhirEvidenceStatistic.GetModelCharacteristicList : TFhirEvidenceStatisticModelCharacteristicList;
begin
  if FModelCharacteristicList = nil then
    FModelCharacteristicList := TFhirEvidenceStatisticModelCharacteristicList.Create;
  result := FModelCharacteristicList;
end;

function TFhirEvidenceStatistic.GetHasModelCharacteristicList : boolean;
begin
  result := (FModelCharacteristicList <> nil) and (FModelCharacteristicList.count > 0);
end;

{ TFhirEvidenceStatisticListEnumerator }

constructor TFhirEvidenceStatisticListEnumerator.Create(list : TFhirEvidenceStatisticList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceStatisticListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceStatisticListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceStatisticListEnumerator.GetCurrent : TFhirEvidenceStatistic;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceStatisticListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceStatisticList }

function TFhirEvidenceStatisticList.AddItem(value: TFhirEvidenceStatistic): TFhirEvidenceStatistic;
begin
  assert(value.ClassName = 'TFhirEvidenceStatistic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceStatistic');
  add(value);
  result := value;
end;

function TFhirEvidenceStatisticList.Append: TFhirEvidenceStatistic;
begin
  result := TFhirEvidenceStatistic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceStatisticList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceStatisticList.GetEnumerator : TFhirEvidenceStatisticListEnumerator;
begin
  result := TFhirEvidenceStatisticListEnumerator.Create(self.link);
end;

function TFhirEvidenceStatisticList.Clone: TFhirEvidenceStatisticList;
begin
  result := TFhirEvidenceStatisticList(inherited Clone);
end;

function TFhirEvidenceStatisticList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceStatisticList.GetItemN(index: Integer): TFhirEvidenceStatistic;
begin
  result := TFhirEvidenceStatistic(ObjectByIndex[index]);
end;

function TFhirEvidenceStatisticList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceStatistic;
end;
function TFhirEvidenceStatisticList.IndexOf(value: TFhirEvidenceStatistic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceStatisticList.Insert(index: Integer): TFhirEvidenceStatistic;
begin
  result := TFhirEvidenceStatistic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceStatisticList.InsertItem(index: Integer; value: TFhirEvidenceStatistic);
begin
  assert(value is TFhirEvidenceStatistic);
  Inherited Insert(index, value);
end;

function TFhirEvidenceStatisticList.Item(index: Integer): TFhirEvidenceStatistic;
begin
  result := TFhirEvidenceStatistic(ObjectByIndex[index]);
end;

function TFhirEvidenceStatisticList.Link: TFhirEvidenceStatisticList;
begin
  result := TFhirEvidenceStatisticList(inherited Link);
end;

procedure TFhirEvidenceStatisticList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceStatisticList.SetItemByIndex(index: Integer; value: TFhirEvidenceStatistic);
begin
  assert(value is TFhirEvidenceStatistic);
  FhirEvidenceStatistics[index] := value;
end;

procedure TFhirEvidenceStatisticList.SetItemN(index: Integer; value: TFhirEvidenceStatistic);
begin
  assert(value is TFhirEvidenceStatistic);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceStatisticSampleSize }

constructor TFhirEvidenceStatisticSampleSize.Create;
begin
  inherited;
end;

destructor TFhirEvidenceStatisticSampleSize.Destroy;
begin
  FDescription.free;
  FNoteList.Free;
  FNumberOfStudies.free;
  FNumberOfParticipants.free;
  FKnownDataCount.free;
  inherited;
end;

procedure TFhirEvidenceStatisticSampleSize.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirEvidenceStatisticSampleSize(oSource).descriptionElement.Clone;
  if (TFhirEvidenceStatisticSampleSize(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEvidenceStatisticSampleSize(oSource).FNoteList);
  end;
  numberOfStudiesElement := TFhirEvidenceStatisticSampleSize(oSource).numberOfStudiesElement.Clone;
  numberOfParticipantsElement := TFhirEvidenceStatisticSampleSize(oSource).numberOfParticipantsElement.Clone;
  knownDataCountElement := TFhirEvidenceStatisticSampleSize(oSource).knownDataCountElement.Clone;
end;

procedure TFhirEvidenceStatisticSampleSize.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'numberOfStudies') Then
     list.add(self.link, 'numberOfStudies', FNumberOfStudies.Link);
  if (child_name = 'numberOfParticipants') Then
     list.add(self.link, 'numberOfParticipants', FNumberOfParticipants.Link);
  if (child_name = 'knownDataCount') Then
     list.add(self.link, 'knownDataCount', FKnownDataCount.Link);
end;

procedure TFhirEvidenceStatisticSampleSize.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'numberOfStudies', 'unsignedInt', false, TFhirUnsignedInt, FNumberOfStudies.Link));
  oList.add(TFHIRProperty.create(self, 'numberOfParticipants', 'unsignedInt', false, TFhirUnsignedInt, FNumberOfParticipants.Link));
  oList.add(TFHIRProperty.create(self, 'knownDataCount', 'unsignedInt', false, TFhirUnsignedInt, FKnownDataCount.Link));
end;

function TFhirEvidenceStatisticSampleSize.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'numberOfStudies') then
  begin
    NumberOfStudiesElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'numberOfParticipants') then
  begin
    NumberOfParticipantsElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'knownDataCount') then
  begin
    KnownDataCountElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceStatisticSampleSize.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirEvidenceStatisticSampleSize.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'numberOfStudies') then result := TFhirUnsignedInt.create()
  else if (propName = 'numberOfParticipants') then result := TFhirUnsignedInt.create()
  else if (propName = 'knownDataCount') then result := TFhirUnsignedInt.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceStatisticSampleSize.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'numberOfStudies') then result := 'unsignedInt'
  else if (propName = 'numberOfParticipants') then result := 'unsignedInt'
  else if (propName = 'knownDataCount') then result := 'unsignedInt'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceStatisticSampleSize.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'numberOfStudies') then NumberOfStudiesElement := nil
  else if (propName = 'numberOfParticipants') then NumberOfParticipantsElement := nil
  else if (propName = 'knownDataCount') then KnownDataCountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceStatisticSampleSize.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'numberOfStudies') then NumberOfStudiesElement := asUnsignedInt(new)
  else if (propName = 'numberOfParticipants') then NumberOfParticipantsElement := asUnsignedInt(new)
  else if (propName = 'knownDataCount') then KnownDataCountElement := asUnsignedInt(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceStatisticSampleSize.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceStatisticSampleSize.fhirType : string;
begin
  result := 'Evidence.statistic.sampleSize';
end;

function TFhirEvidenceStatisticSampleSize.Link : TFhirEvidenceStatisticSampleSize;
begin
  result := TFhirEvidenceStatisticSampleSize(inherited Link);
end;

function TFhirEvidenceStatisticSampleSize.Clone : TFhirEvidenceStatisticSampleSize;
begin
  result := TFhirEvidenceStatisticSampleSize(inherited Clone);
end;

function TFhirEvidenceStatisticSampleSize.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceStatisticSampleSize;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceStatisticSampleSize)) then
    result := false
  else
  begin
    o := TFhirEvidenceStatisticSampleSize(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(numberOfStudiesElement, o.numberOfStudiesElement, true) and compareDeep(numberOfParticipantsElement, o.numberOfParticipantsElement, true) and 
      compareDeep(knownDataCountElement, o.knownDataCountElement, true);
  end;
end;

function TFhirEvidenceStatisticSampleSize.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FnoteList) and isEmptyProp(FNumberOfStudies) and isEmptyProp(FNumberOfParticipants) and isEmptyProp(FKnownDataCount);
end;

procedure TFhirEvidenceStatisticSampleSize.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('note');
  fields.add('numberOfStudies');
  fields.add('numberOfParticipants');
  fields.add('knownDataCount');
end;

function TFhirEvidenceStatisticSampleSize.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FNoteList.sizeInBytes(magic));
end;

procedure TFhirEvidenceStatisticSampleSize.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirEvidenceStatisticSampleSize.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirEvidenceStatisticSampleSize.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirEvidenceStatisticSampleSize.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirEvidenceStatisticSampleSize.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirEvidenceStatisticSampleSize.SetNumberOfStudies(value : TFhirUnsignedInt);
begin
  FNumberOfStudies.free;
  FNumberOfStudies := value;
end;

function TFhirEvidenceStatisticSampleSize.GetNumberOfStudiesST : String;
begin
  if FNumberOfStudies = nil then
    result := ''
  else
    result := FNumberOfStudies.value;
end;

procedure TFhirEvidenceStatisticSampleSize.SetNumberOfStudiesST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfStudies = nil then
      FNumberOfStudies := TFhirUnsignedInt.create;
    FNumberOfStudies.value := value
  end
  else if FNumberOfStudies <> nil then
    FNumberOfStudies.value := '';
end;

procedure TFhirEvidenceStatisticSampleSize.SetNumberOfParticipants(value : TFhirUnsignedInt);
begin
  FNumberOfParticipants.free;
  FNumberOfParticipants := value;
end;

function TFhirEvidenceStatisticSampleSize.GetNumberOfParticipantsST : String;
begin
  if FNumberOfParticipants = nil then
    result := ''
  else
    result := FNumberOfParticipants.value;
end;

procedure TFhirEvidenceStatisticSampleSize.SetNumberOfParticipantsST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfParticipants = nil then
      FNumberOfParticipants := TFhirUnsignedInt.create;
    FNumberOfParticipants.value := value
  end
  else if FNumberOfParticipants <> nil then
    FNumberOfParticipants.value := '';
end;

procedure TFhirEvidenceStatisticSampleSize.SetKnownDataCount(value : TFhirUnsignedInt);
begin
  FKnownDataCount.free;
  FKnownDataCount := value;
end;

function TFhirEvidenceStatisticSampleSize.GetKnownDataCountST : String;
begin
  if FKnownDataCount = nil then
    result := ''
  else
    result := FKnownDataCount.value;
end;

procedure TFhirEvidenceStatisticSampleSize.SetKnownDataCountST(value : String);
begin
  if value <> '' then
  begin
    if FKnownDataCount = nil then
      FKnownDataCount := TFhirUnsignedInt.create;
    FKnownDataCount.value := value
  end
  else if FKnownDataCount <> nil then
    FKnownDataCount.value := '';
end;

{ TFhirEvidenceStatisticSampleSizeListEnumerator }

constructor TFhirEvidenceStatisticSampleSizeListEnumerator.Create(list : TFhirEvidenceStatisticSampleSizeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceStatisticSampleSizeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceStatisticSampleSizeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceStatisticSampleSizeListEnumerator.GetCurrent : TFhirEvidenceStatisticSampleSize;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceStatisticSampleSizeListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceStatisticSampleSizeList }

function TFhirEvidenceStatisticSampleSizeList.AddItem(value: TFhirEvidenceStatisticSampleSize): TFhirEvidenceStatisticSampleSize;
begin
  assert(value.ClassName = 'TFhirEvidenceStatisticSampleSize', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceStatisticSampleSize');
  add(value);
  result := value;
end;

function TFhirEvidenceStatisticSampleSizeList.Append: TFhirEvidenceStatisticSampleSize;
begin
  result := TFhirEvidenceStatisticSampleSize.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceStatisticSampleSizeList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceStatisticSampleSizeList.GetEnumerator : TFhirEvidenceStatisticSampleSizeListEnumerator;
begin
  result := TFhirEvidenceStatisticSampleSizeListEnumerator.Create(self.link);
end;

function TFhirEvidenceStatisticSampleSizeList.Clone: TFhirEvidenceStatisticSampleSizeList;
begin
  result := TFhirEvidenceStatisticSampleSizeList(inherited Clone);
end;

function TFhirEvidenceStatisticSampleSizeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceStatisticSampleSizeList.GetItemN(index: Integer): TFhirEvidenceStatisticSampleSize;
begin
  result := TFhirEvidenceStatisticSampleSize(ObjectByIndex[index]);
end;

function TFhirEvidenceStatisticSampleSizeList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceStatisticSampleSize;
end;
function TFhirEvidenceStatisticSampleSizeList.IndexOf(value: TFhirEvidenceStatisticSampleSize): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceStatisticSampleSizeList.Insert(index: Integer): TFhirEvidenceStatisticSampleSize;
begin
  result := TFhirEvidenceStatisticSampleSize.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceStatisticSampleSizeList.InsertItem(index: Integer; value: TFhirEvidenceStatisticSampleSize);
begin
  assert(value is TFhirEvidenceStatisticSampleSize);
  Inherited Insert(index, value);
end;

function TFhirEvidenceStatisticSampleSizeList.Item(index: Integer): TFhirEvidenceStatisticSampleSize;
begin
  result := TFhirEvidenceStatisticSampleSize(ObjectByIndex[index]);
end;

function TFhirEvidenceStatisticSampleSizeList.Link: TFhirEvidenceStatisticSampleSizeList;
begin
  result := TFhirEvidenceStatisticSampleSizeList(inherited Link);
end;

procedure TFhirEvidenceStatisticSampleSizeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceStatisticSampleSizeList.SetItemByIndex(index: Integer; value: TFhirEvidenceStatisticSampleSize);
begin
  assert(value is TFhirEvidenceStatisticSampleSize);
  FhirEvidenceStatisticSampleSizes[index] := value;
end;

procedure TFhirEvidenceStatisticSampleSizeList.SetItemN(index: Integer; value: TFhirEvidenceStatisticSampleSize);
begin
  assert(value is TFhirEvidenceStatisticSampleSize);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceStatisticAttributeEstimate }

constructor TFhirEvidenceStatisticAttributeEstimate.Create;
begin
  inherited;
end;

destructor TFhirEvidenceStatisticAttributeEstimate.Destroy;
begin
  FDescription.free;
  FNoteList.Free;
  FType_.free;
  FQuantity.free;
  FLevel.free;
  FRange.free;
  FAttributeEstimateList.Free;
  inherited;
end;

procedure TFhirEvidenceStatisticAttributeEstimate.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirEvidenceStatisticAttributeEstimate(oSource).descriptionElement.Clone;
  if (TFhirEvidenceStatisticAttributeEstimate(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEvidenceStatisticAttributeEstimate(oSource).FNoteList);
  end;
  type_ := TFhirEvidenceStatisticAttributeEstimate(oSource).type_.Clone;
  quantity := TFhirEvidenceStatisticAttributeEstimate(oSource).quantity.Clone;
  levelElement := TFhirEvidenceStatisticAttributeEstimate(oSource).levelElement.Clone;
  range := TFhirEvidenceStatisticAttributeEstimate(oSource).range.Clone;
  if (TFhirEvidenceStatisticAttributeEstimate(oSource).FAttributeEstimateList = nil) then
  begin
    FAttributeEstimateList.free;
    FAttributeEstimateList := nil;
  end
  else
  begin
    if FAttributeEstimateList = nil then
      FAttributeEstimateList := TFhirEvidenceStatisticAttributeEstimateList.Create;
    FAttributeEstimateList.Assign(TFhirEvidenceStatisticAttributeEstimate(oSource).FAttributeEstimateList);
  end;
end;

procedure TFhirEvidenceStatisticAttributeEstimate.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'level') Then
     list.add(self.link, 'level', FLevel.Link);
  if (child_name = 'range') Then
     list.add(self.link, 'range', FRange.Link);
  if (child_name = 'attributeEstimate') Then
    list.addAll(self, 'attributeEstimate', FAttributeEstimateList);
end;

procedure TFhirEvidenceStatisticAttributeEstimate.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'level', 'decimal', false, TFhirDecimal, FLevel.Link));
  oList.add(TFHIRProperty.create(self, 'range', 'Range', false, TFhirRange, FRange.Link));
  oList.add(TFHIRProperty.create(self, 'attributeEstimate', '', true, TFhirEvidenceStatisticAttributeEstimate, FAttributeEstimateList.Link));
end;

function TFhirEvidenceStatisticAttributeEstimate.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'level') then
  begin
    LevelElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'range') then
  begin
    Range := propValue as TFhirRange;
    result := propValue;
  end
  else if (propName = 'attributeEstimate') then
  begin
    AttributeEstimateList.add(propValue as TFhirEvidenceStatisticAttributeEstimate);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceStatisticAttributeEstimate.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'attributeEstimate') then AttributeEstimateList.insertItem(index, propValue as TFhirEvidenceStatisticAttributeEstimate)
  else inherited;
end;

function TFhirEvidenceStatisticAttributeEstimate.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'level') then result := TFhirDecimal.create()
  else if (propName = 'range') then result := TFhirRange.create()
  else if (propName = 'attributeEstimate') then result := AttributeEstimateList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceStatisticAttributeEstimate.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'level') then result := 'decimal'
  else if (propName = 'range') then result := 'Range'
  else if (propName = 'attributeEstimate') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceStatisticAttributeEstimate.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'level') then LevelElement := nil
  else if (propName = 'range') then RangeElement := nil
  else if (propName = 'attributeEstimate') then deletePropertyValue('attributeEstimate', AttributeEstimateList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceStatisticAttributeEstimate.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'level') then LevelElement := asDecimal(new)
  else if (propName = 'range') then RangeElement := new as TFhirRange
  else if (propName = 'attributeEstimate') then replacePropertyValue('attributeEstimate', AttributeEstimateList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceStatisticAttributeEstimate.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'attributeEstimate') then AttributeEstimateList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceStatisticAttributeEstimate.fhirType : string;
begin
  result := 'Evidence.statistic.attributeEstimate';
end;

function TFhirEvidenceStatisticAttributeEstimate.Link : TFhirEvidenceStatisticAttributeEstimate;
begin
  result := TFhirEvidenceStatisticAttributeEstimate(inherited Link);
end;

function TFhirEvidenceStatisticAttributeEstimate.Clone : TFhirEvidenceStatisticAttributeEstimate;
begin
  result := TFhirEvidenceStatisticAttributeEstimate(inherited Clone);
end;

function TFhirEvidenceStatisticAttributeEstimate.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceStatisticAttributeEstimate;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceStatisticAttributeEstimate)) then
    result := false
  else
  begin
    o := TFhirEvidenceStatisticAttributeEstimate(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(levelElement, o.levelElement, true) and compareDeep(rangeElement, o.rangeElement, true) and 
      compareDeep(attributeEstimateList, o.attributeEstimateList, true);
  end;
end;

function TFhirEvidenceStatisticAttributeEstimate.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FnoteList) and isEmptyProp(FType_) and isEmptyProp(FQuantity) and isEmptyProp(FLevel) and isEmptyProp(FRange) and isEmptyProp(FattributeEstimateList);
end;

procedure TFhirEvidenceStatisticAttributeEstimate.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('note');
  fields.add('type');
  fields.add('quantity');
  fields.add('level');
  fields.add('range');
  fields.add('attributeEstimate');
end;

function TFhirEvidenceStatisticAttributeEstimate.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FAttributeEstimateList.sizeInBytes(magic));
end;

procedure TFhirEvidenceStatisticAttributeEstimate.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirEvidenceStatisticAttributeEstimate.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirEvidenceStatisticAttributeEstimate.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirEvidenceStatisticAttributeEstimate.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirEvidenceStatisticAttributeEstimate.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirEvidenceStatisticAttributeEstimate.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirEvidenceStatisticAttributeEstimate.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirEvidenceStatisticAttributeEstimate.SetLevel(value : TFhirDecimal);
begin
  FLevel.free;
  FLevel := value;
end;

function TFhirEvidenceStatisticAttributeEstimate.GetLevelST : String;
begin
  if FLevel = nil then
    result := ''
  else
    result := FLevel.value;
end;

procedure TFhirEvidenceStatisticAttributeEstimate.SetLevelST(value : String);
begin
  if value <> '' then
  begin
    if FLevel = nil then
      FLevel := TFhirDecimal.create;
    FLevel.value := value
  end
  else if FLevel <> nil then
    FLevel.value := '';
end;

procedure TFhirEvidenceStatisticAttributeEstimate.SetRange(value : TFhirRange);
begin
  FRange.free;
  FRange := value;
end;

function TFhirEvidenceStatisticAttributeEstimate.GetAttributeEstimateList : TFhirEvidenceStatisticAttributeEstimateList;
begin
  if FAttributeEstimateList = nil then
    FAttributeEstimateList := TFhirEvidenceStatisticAttributeEstimateList.Create;
  result := FAttributeEstimateList;
end;

function TFhirEvidenceStatisticAttributeEstimate.GetHasAttributeEstimateList : boolean;
begin
  result := (FAttributeEstimateList <> nil) and (FAttributeEstimateList.count > 0);
end;

{ TFhirEvidenceStatisticAttributeEstimateListEnumerator }

constructor TFhirEvidenceStatisticAttributeEstimateListEnumerator.Create(list : TFhirEvidenceStatisticAttributeEstimateList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceStatisticAttributeEstimateListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceStatisticAttributeEstimateListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceStatisticAttributeEstimateListEnumerator.GetCurrent : TFhirEvidenceStatisticAttributeEstimate;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceStatisticAttributeEstimateListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceStatisticAttributeEstimateList }

function TFhirEvidenceStatisticAttributeEstimateList.AddItem(value: TFhirEvidenceStatisticAttributeEstimate): TFhirEvidenceStatisticAttributeEstimate;
begin
  assert(value.ClassName = 'TFhirEvidenceStatisticAttributeEstimate', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceStatisticAttributeEstimate');
  add(value);
  result := value;
end;

function TFhirEvidenceStatisticAttributeEstimateList.Append: TFhirEvidenceStatisticAttributeEstimate;
begin
  result := TFhirEvidenceStatisticAttributeEstimate.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceStatisticAttributeEstimateList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceStatisticAttributeEstimateList.GetEnumerator : TFhirEvidenceStatisticAttributeEstimateListEnumerator;
begin
  result := TFhirEvidenceStatisticAttributeEstimateListEnumerator.Create(self.link);
end;

function TFhirEvidenceStatisticAttributeEstimateList.Clone: TFhirEvidenceStatisticAttributeEstimateList;
begin
  result := TFhirEvidenceStatisticAttributeEstimateList(inherited Clone);
end;

function TFhirEvidenceStatisticAttributeEstimateList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceStatisticAttributeEstimateList.GetItemN(index: Integer): TFhirEvidenceStatisticAttributeEstimate;
begin
  result := TFhirEvidenceStatisticAttributeEstimate(ObjectByIndex[index]);
end;

function TFhirEvidenceStatisticAttributeEstimateList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceStatisticAttributeEstimate;
end;
function TFhirEvidenceStatisticAttributeEstimateList.IndexOf(value: TFhirEvidenceStatisticAttributeEstimate): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceStatisticAttributeEstimateList.Insert(index: Integer): TFhirEvidenceStatisticAttributeEstimate;
begin
  result := TFhirEvidenceStatisticAttributeEstimate.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceStatisticAttributeEstimateList.InsertItem(index: Integer; value: TFhirEvidenceStatisticAttributeEstimate);
begin
  assert(value is TFhirEvidenceStatisticAttributeEstimate);
  Inherited Insert(index, value);
end;

function TFhirEvidenceStatisticAttributeEstimateList.Item(index: Integer): TFhirEvidenceStatisticAttributeEstimate;
begin
  result := TFhirEvidenceStatisticAttributeEstimate(ObjectByIndex[index]);
end;

function TFhirEvidenceStatisticAttributeEstimateList.Link: TFhirEvidenceStatisticAttributeEstimateList;
begin
  result := TFhirEvidenceStatisticAttributeEstimateList(inherited Link);
end;

procedure TFhirEvidenceStatisticAttributeEstimateList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceStatisticAttributeEstimateList.SetItemByIndex(index: Integer; value: TFhirEvidenceStatisticAttributeEstimate);
begin
  assert(value is TFhirEvidenceStatisticAttributeEstimate);
  FhirEvidenceStatisticAttributeEstimates[index] := value;
end;

procedure TFhirEvidenceStatisticAttributeEstimateList.SetItemN(index: Integer; value: TFhirEvidenceStatisticAttributeEstimate);
begin
  assert(value is TFhirEvidenceStatisticAttributeEstimate);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceStatisticModelCharacteristic }

constructor TFhirEvidenceStatisticModelCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirEvidenceStatisticModelCharacteristic.Destroy;
begin
  FCode.free;
  FValue.free;
  FVariableList.Free;
  FAttributeEstimateList.Free;
  inherited;
end;

procedure TFhirEvidenceStatisticModelCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirEvidenceStatisticModelCharacteristic(oSource).code.Clone;
  value := TFhirEvidenceStatisticModelCharacteristic(oSource).value.Clone;
  if (TFhirEvidenceStatisticModelCharacteristic(oSource).FVariableList = nil) then
  begin
    FVariableList.free;
    FVariableList := nil;
  end
  else
  begin
    if FVariableList = nil then
      FVariableList := TFhirEvidenceStatisticModelCharacteristicVariableList.Create;
    FVariableList.Assign(TFhirEvidenceStatisticModelCharacteristic(oSource).FVariableList);
  end;
  if (TFhirEvidenceStatisticModelCharacteristic(oSource).FAttributeEstimateList = nil) then
  begin
    FAttributeEstimateList.free;
    FAttributeEstimateList := nil;
  end
  else
  begin
    if FAttributeEstimateList = nil then
      FAttributeEstimateList := TFhirEvidenceStatisticAttributeEstimateList.Create;
    FAttributeEstimateList.Assign(TFhirEvidenceStatisticModelCharacteristic(oSource).FAttributeEstimateList);
  end;
end;

procedure TFhirEvidenceStatisticModelCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'variable') Then
    list.addAll(self, 'variable', FVariableList);
  if (child_name = 'attributeEstimate') Then
    list.addAll(self, 'attributeEstimate', FAttributeEstimateList);
end;

procedure TFhirEvidenceStatisticModelCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'Quantity', false, TFhirQuantity, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'variable', 'BackboneElement', true, TFhirEvidenceStatisticModelCharacteristicVariable, FVariableList.Link));
  oList.add(TFHIRProperty.create(self, 'attributeEstimate', '', true, TFhirEvidenceStatisticAttributeEstimate, FAttributeEstimateList.Link));
end;

function TFhirEvidenceStatisticModelCharacteristic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    Value := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'variable') then
  begin
    VariableList.add(propValue as TFhirEvidenceStatisticModelCharacteristicVariable);
    result := propValue;
  end
  else if (propName = 'attributeEstimate') then
  begin
    AttributeEstimateList.add(propValue as TFhirEvidenceStatisticAttributeEstimate);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceStatisticModelCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'variable') then VariableList.insertItem(index, propValue as TFhirEvidenceStatisticModelCharacteristicVariable)
  else if (propName = 'attributeEstimate') then AttributeEstimateList.insertItem(index, propValue as TFhirEvidenceStatisticAttributeEstimate)
  else inherited;
end;

function TFhirEvidenceStatisticModelCharacteristic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'value') then result := TFhirQuantity.create()
  else if (propName = 'variable') then result := VariableList.new()
  else if (propName = 'attributeEstimate') then result := AttributeEstimateList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceStatisticModelCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'value') then result := 'Quantity'
  else if (propName = 'variable') then result := 'BackboneElement'
  else if (propName = 'attributeEstimate') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceStatisticModelCharacteristic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'value') then ValueElement := nil
  else if (propName = 'variable') then deletePropertyValue('variable', VariableList, value)
  else if (propName = 'attributeEstimate') then deletePropertyValue('attributeEstimate', AttributeEstimateList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceStatisticModelCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'value') then ValueElement := new as TFhirQuantity
  else if (propName = 'variable') then replacePropertyValue('variable', VariableList, existing, new)
  else if (propName = 'attributeEstimate') then replacePropertyValue('attributeEstimate', AttributeEstimateList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceStatisticModelCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'variable') then VariableList.move(source, destination)
  else if (propName = 'attributeEstimate') then AttributeEstimateList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceStatisticModelCharacteristic.fhirType : string;
begin
  result := 'Evidence.statistic.modelCharacteristic';
end;

function TFhirEvidenceStatisticModelCharacteristic.Link : TFhirEvidenceStatisticModelCharacteristic;
begin
  result := TFhirEvidenceStatisticModelCharacteristic(inherited Link);
end;

function TFhirEvidenceStatisticModelCharacteristic.Clone : TFhirEvidenceStatisticModelCharacteristic;
begin
  result := TFhirEvidenceStatisticModelCharacteristic(inherited Clone);
end;

function TFhirEvidenceStatisticModelCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceStatisticModelCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceStatisticModelCharacteristic)) then
    result := false
  else
  begin
    o := TFhirEvidenceStatisticModelCharacteristic(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(variableList, o.variableList, true) and compareDeep(attributeEstimateList, o.attributeEstimateList, true);
  end;
end;

function TFhirEvidenceStatisticModelCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue) and isEmptyProp(FvariableList) and isEmptyProp(FattributeEstimateList);
end;

procedure TFhirEvidenceStatisticModelCharacteristic.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('value');
  fields.add('variable');
  fields.add('attributeEstimate');
end;

function TFhirEvidenceStatisticModelCharacteristic.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FVariableList.sizeInBytes(magic));
  inc(result, FAttributeEstimateList.sizeInBytes(magic));
end;

procedure TFhirEvidenceStatisticModelCharacteristic.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirEvidenceStatisticModelCharacteristic.SetValue(value : TFhirQuantity);
begin
  FValue.free;
  FValue := value;
end;

function TFhirEvidenceStatisticModelCharacteristic.GetVariableList : TFhirEvidenceStatisticModelCharacteristicVariableList;
begin
  if FVariableList = nil then
    FVariableList := TFhirEvidenceStatisticModelCharacteristicVariableList.Create;
  result := FVariableList;
end;

function TFhirEvidenceStatisticModelCharacteristic.GetHasVariableList : boolean;
begin
  result := (FVariableList <> nil) and (FVariableList.count > 0);
end;

function TFhirEvidenceStatisticModelCharacteristic.GetAttributeEstimateList : TFhirEvidenceStatisticAttributeEstimateList;
begin
  if FAttributeEstimateList = nil then
    FAttributeEstimateList := TFhirEvidenceStatisticAttributeEstimateList.Create;
  result := FAttributeEstimateList;
end;

function TFhirEvidenceStatisticModelCharacteristic.GetHasAttributeEstimateList : boolean;
begin
  result := (FAttributeEstimateList <> nil) and (FAttributeEstimateList.count > 0);
end;

{ TFhirEvidenceStatisticModelCharacteristicListEnumerator }

constructor TFhirEvidenceStatisticModelCharacteristicListEnumerator.Create(list : TFhirEvidenceStatisticModelCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceStatisticModelCharacteristicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceStatisticModelCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceStatisticModelCharacteristicListEnumerator.GetCurrent : TFhirEvidenceStatisticModelCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceStatisticModelCharacteristicListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceStatisticModelCharacteristicList }

function TFhirEvidenceStatisticModelCharacteristicList.AddItem(value: TFhirEvidenceStatisticModelCharacteristic): TFhirEvidenceStatisticModelCharacteristic;
begin
  assert(value.ClassName = 'TFhirEvidenceStatisticModelCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceStatisticModelCharacteristic');
  add(value);
  result := value;
end;

function TFhirEvidenceStatisticModelCharacteristicList.Append: TFhirEvidenceStatisticModelCharacteristic;
begin
  result := TFhirEvidenceStatisticModelCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceStatisticModelCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceStatisticModelCharacteristicList.GetEnumerator : TFhirEvidenceStatisticModelCharacteristicListEnumerator;
begin
  result := TFhirEvidenceStatisticModelCharacteristicListEnumerator.Create(self.link);
end;

function TFhirEvidenceStatisticModelCharacteristicList.Clone: TFhirEvidenceStatisticModelCharacteristicList;
begin
  result := TFhirEvidenceStatisticModelCharacteristicList(inherited Clone);
end;

function TFhirEvidenceStatisticModelCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceStatisticModelCharacteristicList.GetItemN(index: Integer): TFhirEvidenceStatisticModelCharacteristic;
begin
  result := TFhirEvidenceStatisticModelCharacteristic(ObjectByIndex[index]);
end;

function TFhirEvidenceStatisticModelCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceStatisticModelCharacteristic;
end;
function TFhirEvidenceStatisticModelCharacteristicList.IndexOf(value: TFhirEvidenceStatisticModelCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceStatisticModelCharacteristicList.Insert(index: Integer): TFhirEvidenceStatisticModelCharacteristic;
begin
  result := TFhirEvidenceStatisticModelCharacteristic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceStatisticModelCharacteristicList.InsertItem(index: Integer; value: TFhirEvidenceStatisticModelCharacteristic);
begin
  assert(value is TFhirEvidenceStatisticModelCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirEvidenceStatisticModelCharacteristicList.Item(index: Integer): TFhirEvidenceStatisticModelCharacteristic;
begin
  result := TFhirEvidenceStatisticModelCharacteristic(ObjectByIndex[index]);
end;

function TFhirEvidenceStatisticModelCharacteristicList.Link: TFhirEvidenceStatisticModelCharacteristicList;
begin
  result := TFhirEvidenceStatisticModelCharacteristicList(inherited Link);
end;

procedure TFhirEvidenceStatisticModelCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceStatisticModelCharacteristicList.SetItemByIndex(index: Integer; value: TFhirEvidenceStatisticModelCharacteristic);
begin
  assert(value is TFhirEvidenceStatisticModelCharacteristic);
  FhirEvidenceStatisticModelCharacteristics[index] := value;
end;

procedure TFhirEvidenceStatisticModelCharacteristicList.SetItemN(index: Integer; value: TFhirEvidenceStatisticModelCharacteristic);
begin
  assert(value is TFhirEvidenceStatisticModelCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceStatisticModelCharacteristicVariable }

constructor TFhirEvidenceStatisticModelCharacteristicVariable.Create;
begin
  inherited;
end;

destructor TFhirEvidenceStatisticModelCharacteristicVariable.Destroy;
begin
  FVariableDefinition.free;
  FHandling.free;
  FValueCategoryList.Free;
  FValueQuantityList.Free;
  FValueRangeList.Free;
  inherited;
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariable.Assign(oSource : TFslObject);
begin
  inherited;
  variableDefinition := TFhirEvidenceStatisticModelCharacteristicVariable(oSource).variableDefinition.Clone;
  handlingElement := TFhirEvidenceStatisticModelCharacteristicVariable(oSource).handlingElement.Clone;
  if (TFhirEvidenceStatisticModelCharacteristicVariable(oSource).FValueCategoryList = nil) then
  begin
    FValueCategoryList.free;
    FValueCategoryList := nil;
  end
  else
  begin
    if FValueCategoryList = nil then
      FValueCategoryList := TFhirCodeableConceptList.Create;
    FValueCategoryList.Assign(TFhirEvidenceStatisticModelCharacteristicVariable(oSource).FValueCategoryList);
  end;
  if (TFhirEvidenceStatisticModelCharacteristicVariable(oSource).FValueQuantityList = nil) then
  begin
    FValueQuantityList.free;
    FValueQuantityList := nil;
  end
  else
  begin
    if FValueQuantityList = nil then
      FValueQuantityList := TFhirQuantityList.Create;
    FValueQuantityList.Assign(TFhirEvidenceStatisticModelCharacteristicVariable(oSource).FValueQuantityList);
  end;
  if (TFhirEvidenceStatisticModelCharacteristicVariable(oSource).FValueRangeList = nil) then
  begin
    FValueRangeList.free;
    FValueRangeList := nil;
  end
  else
  begin
    if FValueRangeList = nil then
      FValueRangeList := TFhirRangeList.Create;
    FValueRangeList.Assign(TFhirEvidenceStatisticModelCharacteristicVariable(oSource).FValueRangeList);
  end;
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariable.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'variableDefinition') Then
     list.add(self.link, 'variableDefinition', FVariableDefinition.Link);
  if (child_name = 'handling') Then
     list.add(self.link, 'handling', FHandling.Link);
  if (child_name = 'valueCategory') Then
    list.addAll(self, 'valueCategory', FValueCategoryList);
  if (child_name = 'valueQuantity') Then
    list.addAll(self, 'valueQuantity', FValueQuantityList);
  if (child_name = 'valueRange') Then
    list.addAll(self, 'valueRange', FValueRangeList);
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariable.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'variableDefinition', 'Reference', false, TFhirReference, FVariableDefinition.Link));
  oList.add(TFHIRProperty.create(self, 'handling', 'code', false, TFhirEnum, FHandling.Link));
  oList.add(TFHIRProperty.create(self, 'valueCategory', 'CodeableConcept', true, TFhirCodeableConcept, FValueCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'valueQuantity', 'Quantity', true, TFhirQuantity, FValueQuantityList.Link));
  oList.add(TFHIRProperty.create(self, 'valueRange', 'Range', true, TFhirRange, FValueRangeList.Link));
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'variableDefinition') then
  begin
    VariableDefinition := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'handling') then
  begin
    HandlingElement := asEnum(SYSTEMS_TFhirEvidenceVariableHandlingEnum, CODES_TFhirEvidenceVariableHandlingEnum, propValue);
    result := propValue;
  end
  else if (propName = 'valueCategory') then
  begin
    ValueCategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'valueQuantity') then
  begin
    ValueQuantityList.add(propValue as TFhirQuantity);
    result := propValue;
  end
  else if (propName = 'valueRange') then
  begin
    ValueRangeList.add(propValue as TFhirRange);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariable.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'valueCategory') then ValueCategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'valueQuantity') then ValueQuantityList.insertItem(index, propValue as TFhirQuantity)
  else if (propName = 'valueRange') then ValueRangeList.insertItem(index, propValue as TFhirRange)
  else inherited;
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'variableDefinition') then result := TFhirReference.create()
  else if (propName = 'handling') then result := TFhirEnum.create(SYSTEMS_TFhirEvidenceVariableHandlingEnum[EvidenceVariableHandlingNull], CODES_TFhirEvidenceVariableHandlingEnum[EvidenceVariableHandlingNull]) 
  else if (propName = 'valueCategory') then result := ValueCategoryList.new()
  else if (propName = 'valueQuantity') then result := ValueQuantityList.new()
  else if (propName = 'valueRange') then result := ValueRangeList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'variableDefinition') then result := 'Reference'
  else if (propName = 'handling') then result := 'code'
  else if (propName = 'valueCategory') then result := 'CodeableConcept'
  else if (propName = 'valueQuantity') then result := 'Quantity'
  else if (propName = 'valueRange') then result := 'Range'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariable.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'variableDefinition') then VariableDefinitionElement := nil
  else if (propName = 'handling') then HandlingElement := nil
  else if (propName = 'valueCategory') then deletePropertyValue('valueCategory', ValueCategoryList, value)
  else if (propName = 'valueQuantity') then deletePropertyValue('valueQuantity', ValueQuantityList, value)
  else if (propName = 'valueRange') then deletePropertyValue('valueRange', ValueRangeList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariable.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'variableDefinition') then VariableDefinitionElement := new as TFhirReference
  else if (propName = 'handling') then HandlingElement := asEnum(SYSTEMS_TFhirEvidenceVariableHandlingEnum, CODES_TFhirEvidenceVariableHandlingEnum, new)
  else if (propName = 'valueCategory') then replacePropertyValue('valueCategory', ValueCategoryList, existing, new)
  else if (propName = 'valueQuantity') then replacePropertyValue('valueQuantity', ValueQuantityList, existing, new)
  else if (propName = 'valueRange') then replacePropertyValue('valueRange', ValueRangeList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariable.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'valueCategory') then ValueCategoryList.move(source, destination)
  else if (propName = 'valueQuantity') then ValueQuantityList.move(source, destination)
  else if (propName = 'valueRange') then ValueRangeList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.fhirType : string;
begin
  result := 'Evidence.statistic.modelCharacteristic.variable';
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.Link : TFhirEvidenceStatisticModelCharacteristicVariable;
begin
  result := TFhirEvidenceStatisticModelCharacteristicVariable(inherited Link);
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.Clone : TFhirEvidenceStatisticModelCharacteristicVariable;
begin
  result := TFhirEvidenceStatisticModelCharacteristicVariable(inherited Clone);
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceStatisticModelCharacteristicVariable;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceStatisticModelCharacteristicVariable)) then
    result := false
  else
  begin
    o := TFhirEvidenceStatisticModelCharacteristicVariable(other);
    result := compareDeep(variableDefinitionElement, o.variableDefinitionElement, true) and 
      compareDeep(handlingElement, o.handlingElement, true) and compareDeep(valueCategoryList, o.valueCategoryList, true) and 
      compareDeep(valueQuantityList, o.valueQuantityList, true) and compareDeep(valueRangeList, o.valueRangeList, true);
  end;
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FVariableDefinition) and isEmptyProp(FHandling) and isEmptyProp(FvalueCategoryList) and isEmptyProp(FvalueQuantityList) and isEmptyProp(FvalueRangeList);
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariable.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('variableDefinition');
  fields.add('handling');
  fields.add('valueCategory');
  fields.add('valueQuantity');
  fields.add('valueRange');
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FValueCategoryList.sizeInBytes(magic));
  inc(result, FValueQuantityList.sizeInBytes(magic));
  inc(result, FValueRangeList.sizeInBytes(magic));
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariable.SetVariableDefinition(value : TFhirReference);
begin
  FVariableDefinition.free;
  FVariableDefinition := value;
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariable.SetHandling(value : TFhirEnum);
begin
  FHandling.free;
  FHandling := value;
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.GetHandlingST : TFhirEvidenceVariableHandlingEnum;
begin
  if FHandling = nil then
    result := TFhirEvidenceVariableHandlingEnum(0)
  else
    result := TFhirEvidenceVariableHandlingEnum(StringArrayIndexOfSensitive(CODES_TFhirEvidenceVariableHandlingEnum, FHandling.value));
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariable.SetHandlingST(value : TFhirEvidenceVariableHandlingEnum);
begin
  if ord(value) = 0 then
    HandlingElement := nil
  else
    HandlingElement := TFhirEnum.create(SYSTEMS_TFhirEvidenceVariableHandlingEnum[value], CODES_TFhirEvidenceVariableHandlingEnum[value]);
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.GetValueCategoryList : TFhirCodeableConceptList;
begin
  if FValueCategoryList = nil then
    FValueCategoryList := TFhirCodeableConceptList.Create;
  result := FValueCategoryList;
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.GetHasValueCategoryList : boolean;
begin
  result := (FValueCategoryList <> nil) and (FValueCategoryList.count > 0);
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.GetValueQuantityList : TFhirQuantityList;
begin
  if FValueQuantityList = nil then
    FValueQuantityList := TFhirQuantityList.Create;
  result := FValueQuantityList;
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.GetHasValueQuantityList : boolean;
begin
  result := (FValueQuantityList <> nil) and (FValueQuantityList.count > 0);
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.GetValueRangeList : TFhirRangeList;
begin
  if FValueRangeList = nil then
    FValueRangeList := TFhirRangeList.Create;
  result := FValueRangeList;
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.GetHasValueRangeList : boolean;
begin
  result := (FValueRangeList <> nil) and (FValueRangeList.count > 0);
end;

{ TFhirEvidenceStatisticModelCharacteristicVariableListEnumerator }

constructor TFhirEvidenceStatisticModelCharacteristicVariableListEnumerator.Create(list : TFhirEvidenceStatisticModelCharacteristicVariableList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceStatisticModelCharacteristicVariableListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceStatisticModelCharacteristicVariableListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceStatisticModelCharacteristicVariableListEnumerator.GetCurrent : TFhirEvidenceStatisticModelCharacteristicVariable;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceStatisticModelCharacteristicVariableListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceStatisticModelCharacteristicVariableList }

function TFhirEvidenceStatisticModelCharacteristicVariableList.AddItem(value: TFhirEvidenceStatisticModelCharacteristicVariable): TFhirEvidenceStatisticModelCharacteristicVariable;
begin
  assert(value.ClassName = 'TFhirEvidenceStatisticModelCharacteristicVariable', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceStatisticModelCharacteristicVariable');
  add(value);
  result := value;
end;

function TFhirEvidenceStatisticModelCharacteristicVariableList.Append: TFhirEvidenceStatisticModelCharacteristicVariable;
begin
  result := TFhirEvidenceStatisticModelCharacteristicVariable.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariableList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceStatisticModelCharacteristicVariableList.GetEnumerator : TFhirEvidenceStatisticModelCharacteristicVariableListEnumerator;
begin
  result := TFhirEvidenceStatisticModelCharacteristicVariableListEnumerator.Create(self.link);
end;

function TFhirEvidenceStatisticModelCharacteristicVariableList.Clone: TFhirEvidenceStatisticModelCharacteristicVariableList;
begin
  result := TFhirEvidenceStatisticModelCharacteristicVariableList(inherited Clone);
end;

function TFhirEvidenceStatisticModelCharacteristicVariableList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceStatisticModelCharacteristicVariableList.GetItemN(index: Integer): TFhirEvidenceStatisticModelCharacteristicVariable;
begin
  result := TFhirEvidenceStatisticModelCharacteristicVariable(ObjectByIndex[index]);
end;

function TFhirEvidenceStatisticModelCharacteristicVariableList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceStatisticModelCharacteristicVariable;
end;
function TFhirEvidenceStatisticModelCharacteristicVariableList.IndexOf(value: TFhirEvidenceStatisticModelCharacteristicVariable): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceStatisticModelCharacteristicVariableList.Insert(index: Integer): TFhirEvidenceStatisticModelCharacteristicVariable;
begin
  result := TFhirEvidenceStatisticModelCharacteristicVariable.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariableList.InsertItem(index: Integer; value: TFhirEvidenceStatisticModelCharacteristicVariable);
begin
  assert(value is TFhirEvidenceStatisticModelCharacteristicVariable);
  Inherited Insert(index, value);
end;

function TFhirEvidenceStatisticModelCharacteristicVariableList.Item(index: Integer): TFhirEvidenceStatisticModelCharacteristicVariable;
begin
  result := TFhirEvidenceStatisticModelCharacteristicVariable(ObjectByIndex[index]);
end;

function TFhirEvidenceStatisticModelCharacteristicVariableList.Link: TFhirEvidenceStatisticModelCharacteristicVariableList;
begin
  result := TFhirEvidenceStatisticModelCharacteristicVariableList(inherited Link);
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariableList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariableList.SetItemByIndex(index: Integer; value: TFhirEvidenceStatisticModelCharacteristicVariable);
begin
  assert(value is TFhirEvidenceStatisticModelCharacteristicVariable);
  FhirEvidenceStatisticModelCharacteristicVariables[index] := value;
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariableList.SetItemN(index: Integer; value: TFhirEvidenceStatisticModelCharacteristicVariable);
begin
  assert(value is TFhirEvidenceStatisticModelCharacteristicVariable);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceCertainty }

constructor TFhirEvidenceCertainty.Create;
begin
  inherited;
end;

destructor TFhirEvidenceCertainty.Destroy;
begin
  FDescription.free;
  FNoteList.Free;
  FType_.free;
  FRating.free;
  FRater.free;
  FSubcomponentList.Free;
  inherited;
end;

procedure TFhirEvidenceCertainty.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirEvidenceCertainty(oSource).descriptionElement.Clone;
  if (TFhirEvidenceCertainty(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEvidenceCertainty(oSource).FNoteList);
  end;
  type_ := TFhirEvidenceCertainty(oSource).type_.Clone;
  rating := TFhirEvidenceCertainty(oSource).rating.Clone;
  raterElement := TFhirEvidenceCertainty(oSource).raterElement.Clone;
  if (TFhirEvidenceCertainty(oSource).FSubcomponentList = nil) then
  begin
    FSubcomponentList.free;
    FSubcomponentList := nil;
  end
  else
  begin
    if FSubcomponentList = nil then
      FSubcomponentList := TFhirEvidenceCertaintyList.Create;
    FSubcomponentList.Assign(TFhirEvidenceCertainty(oSource).FSubcomponentList);
  end;
end;

procedure TFhirEvidenceCertainty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'rating') Then
     list.add(self.link, 'rating', FRating.Link);
  if (child_name = 'rater') Then
     list.add(self.link, 'rater', FRater.Link);
  if (child_name = 'subcomponent') Then
    list.addAll(self, 'subcomponent', FSubcomponentList);
end;

procedure TFhirEvidenceCertainty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'rating', 'CodeableConcept', false, TFhirCodeableConcept, FRating.Link));
  oList.add(TFHIRProperty.create(self, 'rater', 'string', false, TFhirString, FRater.Link));
  oList.add(TFHIRProperty.create(self, 'subcomponent', '', true, TFhirEvidenceCertainty, FSubcomponentList.Link));
end;

function TFhirEvidenceCertainty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'rating') then
  begin
    Rating := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'rater') then
  begin
    RaterElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'subcomponent') then
  begin
    SubcomponentList.add(propValue as TFhirEvidenceCertainty);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceCertainty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'subcomponent') then SubcomponentList.insertItem(index, propValue as TFhirEvidenceCertainty)
  else inherited;
end;

function TFhirEvidenceCertainty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'rating') then result := TFhirCodeableConcept.create()
  else if (propName = 'rater') then result := TFhirString.create()
  else if (propName = 'subcomponent') then result := SubcomponentList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceCertainty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'rating') then result := 'CodeableConcept'
  else if (propName = 'rater') then result := 'string'
  else if (propName = 'subcomponent') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceCertainty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'rating') then RatingElement := nil
  else if (propName = 'rater') then RaterElement := nil
  else if (propName = 'subcomponent') then deletePropertyValue('subcomponent', SubcomponentList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceCertainty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'rating') then RatingElement := new as TFhirCodeableConcept
  else if (propName = 'rater') then RaterElement := asString(new)
  else if (propName = 'subcomponent') then replacePropertyValue('subcomponent', SubcomponentList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceCertainty.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'subcomponent') then SubcomponentList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceCertainty.fhirType : string;
begin
  result := 'Evidence.certainty';
end;

function TFhirEvidenceCertainty.Link : TFhirEvidenceCertainty;
begin
  result := TFhirEvidenceCertainty(inherited Link);
end;

function TFhirEvidenceCertainty.Clone : TFhirEvidenceCertainty;
begin
  result := TFhirEvidenceCertainty(inherited Clone);
end;

function TFhirEvidenceCertainty.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceCertainty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceCertainty)) then
    result := false
  else
  begin
    o := TFhirEvidenceCertainty(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(ratingElement, o.ratingElement, true) and 
      compareDeep(raterElement, o.raterElement, true) and compareDeep(subcomponentList, o.subcomponentList, true);
  end;
end;

function TFhirEvidenceCertainty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FnoteList) and isEmptyProp(FType_) and isEmptyProp(FRating) and isEmptyProp(FRater) and isEmptyProp(FsubcomponentList);
end;

procedure TFhirEvidenceCertainty.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('note');
  fields.add('type');
  fields.add('rating');
  fields.add('rater');
  fields.add('subcomponent');
end;

function TFhirEvidenceCertainty.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FSubcomponentList.sizeInBytes(magic));
end;

procedure TFhirEvidenceCertainty.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirEvidenceCertainty.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirEvidenceCertainty.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirEvidenceCertainty.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirEvidenceCertainty.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirEvidenceCertainty.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirEvidenceCertainty.SetRating(value : TFhirCodeableConcept);
begin
  FRating.free;
  FRating := value;
end;

procedure TFhirEvidenceCertainty.SetRater(value : TFhirString);
begin
  FRater.free;
  FRater := value;
end;

function TFhirEvidenceCertainty.GetRaterST : String;
begin
  if FRater = nil then
    result := ''
  else
    result := FRater.value;
end;

procedure TFhirEvidenceCertainty.SetRaterST(value : String);
begin
  if value <> '' then
  begin
    if FRater = nil then
      FRater := TFhirString.create;
    FRater.value := value
  end
  else if FRater <> nil then
    FRater.value := '';
end;

function TFhirEvidenceCertainty.GetSubcomponentList : TFhirEvidenceCertaintyList;
begin
  if FSubcomponentList = nil then
    FSubcomponentList := TFhirEvidenceCertaintyList.Create;
  result := FSubcomponentList;
end;

function TFhirEvidenceCertainty.GetHasSubcomponentList : boolean;
begin
  result := (FSubcomponentList <> nil) and (FSubcomponentList.count > 0);
end;

{ TFhirEvidenceCertaintyListEnumerator }

constructor TFhirEvidenceCertaintyListEnumerator.Create(list : TFhirEvidenceCertaintyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceCertaintyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceCertaintyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceCertaintyListEnumerator.GetCurrent : TFhirEvidenceCertainty;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceCertaintyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceCertaintyList }

function TFhirEvidenceCertaintyList.AddItem(value: TFhirEvidenceCertainty): TFhirEvidenceCertainty;
begin
  assert(value.ClassName = 'TFhirEvidenceCertainty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceCertainty');
  add(value);
  result := value;
end;

function TFhirEvidenceCertaintyList.Append: TFhirEvidenceCertainty;
begin
  result := TFhirEvidenceCertainty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceCertaintyList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceCertaintyList.GetEnumerator : TFhirEvidenceCertaintyListEnumerator;
begin
  result := TFhirEvidenceCertaintyListEnumerator.Create(self.link);
end;

function TFhirEvidenceCertaintyList.Clone: TFhirEvidenceCertaintyList;
begin
  result := TFhirEvidenceCertaintyList(inherited Clone);
end;

function TFhirEvidenceCertaintyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceCertaintyList.GetItemN(index: Integer): TFhirEvidenceCertainty;
begin
  result := TFhirEvidenceCertainty(ObjectByIndex[index]);
end;

function TFhirEvidenceCertaintyList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceCertainty;
end;
function TFhirEvidenceCertaintyList.IndexOf(value: TFhirEvidenceCertainty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceCertaintyList.Insert(index: Integer): TFhirEvidenceCertainty;
begin
  result := TFhirEvidenceCertainty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceCertaintyList.InsertItem(index: Integer; value: TFhirEvidenceCertainty);
begin
  assert(value is TFhirEvidenceCertainty);
  Inherited Insert(index, value);
end;

function TFhirEvidenceCertaintyList.Item(index: Integer): TFhirEvidenceCertainty;
begin
  result := TFhirEvidenceCertainty(ObjectByIndex[index]);
end;

function TFhirEvidenceCertaintyList.Link: TFhirEvidenceCertaintyList;
begin
  result := TFhirEvidenceCertaintyList(inherited Link);
end;

procedure TFhirEvidenceCertaintyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceCertaintyList.SetItemByIndex(index: Integer; value: TFhirEvidenceCertainty);
begin
  assert(value is TFhirEvidenceCertainty);
  FhirEvidenceCertainties[index] := value;
end;

procedure TFhirEvidenceCertaintyList.SetItemN(index: Integer; value: TFhirEvidenceCertainty);
begin
  assert(value is TFhirEvidenceCertainty);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidence }

constructor TFhirEvidence.Create;
begin
  inherited;
end;

destructor TFhirEvidence.Destroy;
begin
  FCiteAs.free;
  FAssertion.free;
  FNoteList.Free;
  FVariableDefinitionList.Free;
  FSynthesisType.free;
  FStudyDesignList.Free;
  FStatisticList.Free;
  FCertaintyList.Free;
  inherited;
end;

procedure TFhirEvidence.Assign(oSource : TFslObject);
begin
  inherited;
  citeAs := TFhirEvidence(oSource).citeAs.Clone;
  assertionElement := TFhirEvidence(oSource).assertionElement.Clone;
  if (TFhirEvidence(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEvidence(oSource).FNoteList);
  end;
  if (TFhirEvidence(oSource).FVariableDefinitionList = nil) then
  begin
    FVariableDefinitionList.free;
    FVariableDefinitionList := nil;
  end
  else
  begin
    if FVariableDefinitionList = nil then
      FVariableDefinitionList := TFhirEvidenceVariableDefinitionList.Create;
    FVariableDefinitionList.Assign(TFhirEvidence(oSource).FVariableDefinitionList);
  end;
  synthesisType := TFhirEvidence(oSource).synthesisType.Clone;
  if (TFhirEvidence(oSource).FStudyDesignList = nil) then
  begin
    FStudyDesignList.free;
    FStudyDesignList := nil;
  end
  else
  begin
    if FStudyDesignList = nil then
      FStudyDesignList := TFhirCodeableConceptList.Create;
    FStudyDesignList.Assign(TFhirEvidence(oSource).FStudyDesignList);
  end;
  if (TFhirEvidence(oSource).FStatisticList = nil) then
  begin
    FStatisticList.free;
    FStatisticList := nil;
  end
  else
  begin
    if FStatisticList = nil then
      FStatisticList := TFhirEvidenceStatisticList.Create;
    FStatisticList.Assign(TFhirEvidence(oSource).FStatisticList);
  end;
  if (TFhirEvidence(oSource).FCertaintyList = nil) then
  begin
    FCertaintyList.free;
    FCertaintyList := nil;
  end
  else
  begin
    if FCertaintyList = nil then
      FCertaintyList := TFhirEvidenceCertaintyList.Create;
    FCertaintyList.Assign(TFhirEvidence(oSource).FCertaintyList);
  end;
end;

function TFhirEvidence.GetResourceType : TFhirResourceType;
begin
  result := frtEvidence;
end;

procedure TFhirEvidence.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'citeAs[x]') or (child_name = 'citeAs') Then
     list.add(self.link, 'citeAs[x]', FCiteAs.Link);
  if (child_name = 'assertion') Then
     list.add(self.link, 'assertion', FAssertion.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'variableDefinition') Then
    list.addAll(self, 'variableDefinition', FVariableDefinitionList);
  if (child_name = 'synthesisType') Then
     list.add(self.link, 'synthesisType', FSynthesisType.Link);
  if (child_name = 'studyDesign') Then
    list.addAll(self, 'studyDesign', FStudyDesignList);
  if (child_name = 'statistic') Then
    list.addAll(self, 'statistic', FStatisticList);
  if (child_name = 'certainty') Then
    list.addAll(self, 'certainty', FCertaintyList);
end;

procedure TFhirEvidence.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'citeAs[x]', 'Reference|markdown', false, TFhirDataType, FCiteAs.Link));
  oList.add(TFHIRProperty.create(self, 'assertion', 'markdown', false, TFhirMarkdown, FAssertion.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'variableDefinition', 'BackboneElement', true, TFhirEvidenceVariableDefinition, FVariableDefinitionList.Link));
  oList.add(TFHIRProperty.create(self, 'synthesisType', 'CodeableConcept', false, TFhirCodeableConcept, FSynthesisType.Link));
  oList.add(TFHIRProperty.create(self, 'studyDesign', 'CodeableConcept', true, TFhirCodeableConcept, FStudyDesignList.Link));
  oList.add(TFHIRProperty.create(self, 'statistic', 'BackboneElement', true, TFhirEvidenceStatistic, FStatisticList.Link));
  oList.add(TFHIRProperty.create(self, 'certainty', 'BackboneElement', true, TFhirEvidenceCertainty, FCertaintyList.Link));
end;

function TFhirEvidence.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'citeAs', ['Reference', 'Markdown'])) then
  begin
    CiteAs := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'assertion') then
  begin
    AssertionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'variableDefinition') then
  begin
    VariableDefinitionList.add(propValue as TFhirEvidenceVariableDefinition);
    result := propValue;
  end
  else if (propName = 'synthesisType') then
  begin
    SynthesisType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'studyDesign') then
  begin
    StudyDesignList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'statistic') then
  begin
    StatisticList.add(propValue as TFhirEvidenceStatistic);
    result := propValue;
  end
  else if (propName = 'certainty') then
  begin
    CertaintyList.add(propValue as TFhirEvidenceCertainty);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidence.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'variableDefinition') then VariableDefinitionList.insertItem(index, propValue as TFhirEvidenceVariableDefinition)
  else if (propName = 'studyDesign') then StudyDesignList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'statistic') then StatisticList.insertItem(index, propValue as TFhirEvidenceStatistic)
  else if (propName = 'certainty') then CertaintyList.insertItem(index, propValue as TFhirEvidenceCertainty)
  else inherited;
end;

function TFhirEvidence.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'citeAs', ['Reference', 'Markdown'])) then raise EFHIRException.create('Cannot make property CiteAs')
  else if (propName = 'assertion') then result := TFhirMarkdown.create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'variableDefinition') then result := VariableDefinitionList.new()
  else if (propName = 'synthesisType') then result := TFhirCodeableConcept.create()
  else if (propName = 'studyDesign') then result := StudyDesignList.new()
  else if (propName = 'statistic') then result := StatisticList.new()
  else if (propName = 'certainty') then result := CertaintyList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidence.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'citeAs[x]') then result := 'Reference|markdown'
  else if (propName = 'assertion') then result := 'markdown'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'variableDefinition') then result := 'BackboneElement'
  else if (propName = 'synthesisType') then result := 'CodeableConcept'
  else if (propName = 'studyDesign') then result := 'CodeableConcept'
  else if (propName = 'statistic') then result := 'BackboneElement'
  else if (propName = 'certainty') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidence.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'citeAs', ['Reference', 'Markdown'])) then CiteAsElement := nil
  else if (propName = 'assertion') then AssertionElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'variableDefinition') then deletePropertyValue('variableDefinition', VariableDefinitionList, value)
  else if (propName = 'synthesisType') then SynthesisTypeElement := nil
  else if (propName = 'studyDesign') then deletePropertyValue('studyDesign', StudyDesignList, value)
  else if (propName = 'statistic') then deletePropertyValue('statistic', StatisticList, value)
  else if (propName = 'certainty') then deletePropertyValue('certainty', CertaintyList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidence.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'citeAs', ['Reference', 'Markdown'])) then CiteAsElement := new as TFhirDataType
  else if (propName = 'assertion') then AssertionElement := asMarkdown(new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'variableDefinition') then replacePropertyValue('variableDefinition', VariableDefinitionList, existing, new)
  else if (propName = 'synthesisType') then SynthesisTypeElement := new as TFhirCodeableConcept
  else if (propName = 'studyDesign') then replacePropertyValue('studyDesign', StudyDesignList, existing, new)
  else if (propName = 'statistic') then replacePropertyValue('statistic', StatisticList, existing, new)
  else if (propName = 'certainty') then replacePropertyValue('certainty', CertaintyList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidence.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'variableDefinition') then VariableDefinitionList.move(source, destination)
  else if (propName = 'studyDesign') then StudyDesignList.move(source, destination)
  else if (propName = 'statistic') then StatisticList.move(source, destination)
  else if (propName = 'certainty') then CertaintyList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidence.fhirType : string;
begin
  result := 'Evidence';
end;

function TFhirEvidence.Link : TFhirEvidence;
begin
  result := TFhirEvidence(inherited Link);
end;

function TFhirEvidence.Clone : TFhirEvidence;
begin
  result := TFhirEvidence(inherited Clone);
end;

function TFhirEvidence.equals(other : TObject) : boolean; 
var
  o : TFhirEvidence;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidence)) then
    result := false
  else
  begin
    o := TFhirEvidence(other);
    result := compareDeep(citeAsElement, o.citeAsElement, true) and compareDeep(assertionElement, o.assertionElement, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(variableDefinitionList, o.variableDefinitionList, true) and 
      compareDeep(synthesisTypeElement, o.synthesisTypeElement, true) and compareDeep(studyDesignList, o.studyDesignList, true) and 
      compareDeep(statisticList, o.statisticList, true) and compareDeep(certaintyList, o.certaintyList, true);
  end;
end;

function TFhirEvidence.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCiteAs) and isEmptyProp(FAssertion) and isEmptyProp(FnoteList) and isEmptyProp(FvariableDefinitionList) and isEmptyProp(FSynthesisType) and isEmptyProp(FstudyDesignList) and isEmptyProp(FstatisticList) and isEmptyProp(FcertaintyList);
end;

procedure TFhirEvidence.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('citeAs[x]');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('useContext');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('publisher');
  fields.add('contact');
  fields.add('author');
  fields.add('editor');
  fields.add('reviewer');
  fields.add('endorser');
  fields.add('relatedArtifact');
  fields.add('description');
  fields.add('assertion');
  fields.add('note');
  fields.add('variableDefinition');
  fields.add('synthesisType');
  fields.add('studyDesign');
  fields.add('statistic');
  fields.add('certainty');
end;

function TFhirEvidence.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FVariableDefinitionList.sizeInBytes(magic));
  inc(result, FStudyDesignList.sizeInBytes(magic));
  inc(result, FStatisticList.sizeInBytes(magic));
  inc(result, FCertaintyList.sizeInBytes(magic));
end;

procedure TFhirEvidence.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirEvidence.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirEvidence.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirEvidence.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirEvidence.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirEvidence.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirEvidence.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirEvidence.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirEvidence.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirEvidence.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirEvidence.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirEvidence.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirEvidence.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirEvidence.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirEvidence.SetCiteAs(value : TFhirDataType);
begin
  FCiteAs.free;
  FCiteAs := value;
end;

procedure TFhirEvidence.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEvidence.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirEvidence.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirEvidence.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirEvidence.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirEvidence.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirEvidence.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirEvidence.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirEvidence.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

function TFhirEvidence.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirEvidence.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

procedure TFhirEvidence.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

function TFhirEvidence.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

procedure TFhirEvidence.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

procedure TFhirEvidence.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

function TFhirEvidence.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

procedure TFhirEvidence.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

procedure TFhirEvidence.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirEvidence.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirEvidence.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirEvidence.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirEvidence.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

function TFhirEvidence.GetAuthorList : TFhirContactDetailList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirContactDetailList.Create;
  result := FAuthorList;
end;

function TFhirEvidence.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

function TFhirEvidence.GetEditorList : TFhirContactDetailList;
begin
  if FEditorList = nil then
    FEditorList := TFhirContactDetailList.Create;
  result := FEditorList;
end;

function TFhirEvidence.GetHasEditorList : boolean;
begin
  result := (FEditorList <> nil) and (FEditorList.count > 0);
end;

function TFhirEvidence.GetReviewerList : TFhirContactDetailList;
begin
  if FReviewerList = nil then
    FReviewerList := TFhirContactDetailList.Create;
  result := FReviewerList;
end;

function TFhirEvidence.GetHasReviewerList : boolean;
begin
  result := (FReviewerList <> nil) and (FReviewerList.count > 0);
end;

function TFhirEvidence.GetEndorserList : TFhirContactDetailList;
begin
  if FEndorserList = nil then
    FEndorserList := TFhirContactDetailList.Create;
  result := FEndorserList;
end;

function TFhirEvidence.GetHasEndorserList : boolean;
begin
  result := (FEndorserList <> nil) and (FEndorserList.count > 0);
end;

function TFhirEvidence.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

function TFhirEvidence.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

procedure TFhirEvidence.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirEvidence.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirEvidence.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirEvidence.SetAssertion(value : TFhirMarkdown);
begin
  FAssertion.free;
  FAssertion := value;
end;

function TFhirEvidence.GetAssertionST : String;
begin
  if FAssertion = nil then
    result := ''
  else
    result := FAssertion.value;
end;

procedure TFhirEvidence.SetAssertionST(value : String);
begin
  if value <> '' then
  begin
    if FAssertion = nil then
      FAssertion := TFhirMarkdown.create;
    FAssertion.value := value
  end
  else if FAssertion <> nil then
    FAssertion.value := '';
end;

function TFhirEvidence.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirEvidence.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirEvidence.GetVariableDefinitionList : TFhirEvidenceVariableDefinitionList;
begin
  if FVariableDefinitionList = nil then
    FVariableDefinitionList := TFhirEvidenceVariableDefinitionList.Create;
  result := FVariableDefinitionList;
end;

function TFhirEvidence.GetHasVariableDefinitionList : boolean;
begin
  result := (FVariableDefinitionList <> nil) and (FVariableDefinitionList.count > 0);
end;

procedure TFhirEvidence.SetSynthesisType(value : TFhirCodeableConcept);
begin
  FSynthesisType.free;
  FSynthesisType := value;
end;

function TFhirEvidence.GetStudyDesignList : TFhirCodeableConceptList;
begin
  if FStudyDesignList = nil then
    FStudyDesignList := TFhirCodeableConceptList.Create;
  result := FStudyDesignList;
end;

function TFhirEvidence.GetHasStudyDesignList : boolean;
begin
  result := (FStudyDesignList <> nil) and (FStudyDesignList.count > 0);
end;

function TFhirEvidence.GetStatisticList : TFhirEvidenceStatisticList;
begin
  if FStatisticList = nil then
    FStatisticList := TFhirEvidenceStatisticList.Create;
  result := FStatisticList;
end;

function TFhirEvidence.GetHasStatisticList : boolean;
begin
  result := (FStatisticList <> nil) and (FStatisticList.count > 0);
end;

function TFhirEvidence.GetCertaintyList : TFhirEvidenceCertaintyList;
begin
  if FCertaintyList = nil then
    FCertaintyList := TFhirEvidenceCertaintyList.Create;
  result := FCertaintyList;
end;

function TFhirEvidence.GetHasCertaintyList : boolean;
begin
  result := (FCertaintyList <> nil) and (FCertaintyList.count > 0);
end;

{ TFhirEvidenceListEnumerator }

constructor TFhirEvidenceListEnumerator.Create(list : TFhirEvidenceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceListEnumerator.GetCurrent : TFhirEvidence;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceList }

function TFhirEvidenceList.AddItem(value: TFhirEvidence): TFhirEvidence;
begin
  assert(value.ClassName = 'TFhirEvidence', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidence');
  add(value);
  result := value;
end;

function TFhirEvidenceList.Append: TFhirEvidence;
begin
  result := TFhirEvidence.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceList.GetEnumerator : TFhirEvidenceListEnumerator;
begin
  result := TFhirEvidenceListEnumerator.Create(self.link);
end;

function TFhirEvidenceList.Clone: TFhirEvidenceList;
begin
  result := TFhirEvidenceList(inherited Clone);
end;

function TFhirEvidenceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceList.GetItemN(index: Integer): TFhirEvidence;
begin
  result := TFhirEvidence(ObjectByIndex[index]);
end;

function TFhirEvidenceList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidence;
end;
function TFhirEvidenceList.IndexOf(value: TFhirEvidence): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceList.Insert(index: Integer): TFhirEvidence;
begin
  result := TFhirEvidence.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceList.InsertItem(index: Integer; value: TFhirEvidence);
begin
  assert(value is TFhirEvidence);
  Inherited Insert(index, value);
end;

function TFhirEvidenceList.Item(index: Integer): TFhirEvidence;
begin
  result := TFhirEvidence(ObjectByIndex[index]);
end;

function TFhirEvidenceList.Link: TFhirEvidenceList;
begin
  result := TFhirEvidenceList(inherited Link);
end;

procedure TFhirEvidenceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceList.SetItemByIndex(index: Integer; value: TFhirEvidence);
begin
  assert(value is TFhirEvidence);
  FhirEvidences[index] := value;
end;

procedure TFhirEvidenceList.SetItemN(index: Integer; value: TFhirEvidence);
begin
  assert(value is TFhirEvidence);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEREPORT}
{ TFhirEvidenceReportSubject }

constructor TFhirEvidenceReportSubject.Create;
begin
  inherited;
end;

destructor TFhirEvidenceReportSubject.Destroy;
begin
  FCharacteristicList.Free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirEvidenceReportSubject.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEvidenceReportSubject(oSource).FCharacteristicList = nil) then
  begin
    FCharacteristicList.free;
    FCharacteristicList := nil;
  end
  else
  begin
    if FCharacteristicList = nil then
      FCharacteristicList := TFhirEvidenceReportSubjectCharacteristicList.Create;
    FCharacteristicList.Assign(TFhirEvidenceReportSubject(oSource).FCharacteristicList);
  end;
  if (TFhirEvidenceReportSubject(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEvidenceReportSubject(oSource).FNoteList);
  end;
end;

procedure TFhirEvidenceReportSubject.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'characteristic') Then
    list.addAll(self, 'characteristic', FCharacteristicList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirEvidenceReportSubject.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'characteristic', 'BackboneElement', true, TFhirEvidenceReportSubjectCharacteristic, FCharacteristicList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
end;

function TFhirEvidenceReportSubject.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'characteristic') then
  begin
    CharacteristicList.add(propValue as TFhirEvidenceReportSubjectCharacteristic);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceReportSubject.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'characteristic') then CharacteristicList.insertItem(index, propValue as TFhirEvidenceReportSubjectCharacteristic)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirEvidenceReportSubject.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'characteristic') then result := CharacteristicList.new()
  else if (propName = 'note') then result := NoteList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceReportSubject.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'characteristic') then result := 'BackboneElement'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceReportSubject.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'characteristic') then deletePropertyValue('characteristic', CharacteristicList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceReportSubject.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'characteristic') then replacePropertyValue('characteristic', CharacteristicList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceReportSubject.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'characteristic') then CharacteristicList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceReportSubject.fhirType : string;
begin
  result := 'EvidenceReport.subject';
end;

function TFhirEvidenceReportSubject.Link : TFhirEvidenceReportSubject;
begin
  result := TFhirEvidenceReportSubject(inherited Link);
end;

function TFhirEvidenceReportSubject.Clone : TFhirEvidenceReportSubject;
begin
  result := TFhirEvidenceReportSubject(inherited Clone);
end;

function TFhirEvidenceReportSubject.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceReportSubject;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceReportSubject)) then
    result := false
  else
  begin
    o := TFhirEvidenceReportSubject(other);
    result := compareDeep(characteristicList, o.characteristicList, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirEvidenceReportSubject.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FcharacteristicList) and isEmptyProp(FnoteList);
end;

procedure TFhirEvidenceReportSubject.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('characteristic');
  fields.add('note');
end;

function TFhirEvidenceReportSubject.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCharacteristicList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
end;

function TFhirEvidenceReportSubject.GetCharacteristicList : TFhirEvidenceReportSubjectCharacteristicList;
begin
  if FCharacteristicList = nil then
    FCharacteristicList := TFhirEvidenceReportSubjectCharacteristicList.Create;
  result := FCharacteristicList;
end;

function TFhirEvidenceReportSubject.GetHasCharacteristicList : boolean;
begin
  result := (FCharacteristicList <> nil) and (FCharacteristicList.count > 0);
end;

function TFhirEvidenceReportSubject.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirEvidenceReportSubject.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

{ TFhirEvidenceReportSubjectListEnumerator }

constructor TFhirEvidenceReportSubjectListEnumerator.Create(list : TFhirEvidenceReportSubjectList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceReportSubjectListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceReportSubjectListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceReportSubjectListEnumerator.GetCurrent : TFhirEvidenceReportSubject;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceReportSubjectListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceReportSubjectList }

function TFhirEvidenceReportSubjectList.AddItem(value: TFhirEvidenceReportSubject): TFhirEvidenceReportSubject;
begin
  assert(value.ClassName = 'TFhirEvidenceReportSubject', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceReportSubject');
  add(value);
  result := value;
end;

function TFhirEvidenceReportSubjectList.Append: TFhirEvidenceReportSubject;
begin
  result := TFhirEvidenceReportSubject.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceReportSubjectList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceReportSubjectList.GetEnumerator : TFhirEvidenceReportSubjectListEnumerator;
begin
  result := TFhirEvidenceReportSubjectListEnumerator.Create(self.link);
end;

function TFhirEvidenceReportSubjectList.Clone: TFhirEvidenceReportSubjectList;
begin
  result := TFhirEvidenceReportSubjectList(inherited Clone);
end;

function TFhirEvidenceReportSubjectList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceReportSubjectList.GetItemN(index: Integer): TFhirEvidenceReportSubject;
begin
  result := TFhirEvidenceReportSubject(ObjectByIndex[index]);
end;

function TFhirEvidenceReportSubjectList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceReportSubject;
end;
function TFhirEvidenceReportSubjectList.IndexOf(value: TFhirEvidenceReportSubject): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceReportSubjectList.Insert(index: Integer): TFhirEvidenceReportSubject;
begin
  result := TFhirEvidenceReportSubject.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceReportSubjectList.InsertItem(index: Integer; value: TFhirEvidenceReportSubject);
begin
  assert(value is TFhirEvidenceReportSubject);
  Inherited Insert(index, value);
end;

function TFhirEvidenceReportSubjectList.Item(index: Integer): TFhirEvidenceReportSubject;
begin
  result := TFhirEvidenceReportSubject(ObjectByIndex[index]);
end;

function TFhirEvidenceReportSubjectList.Link: TFhirEvidenceReportSubjectList;
begin
  result := TFhirEvidenceReportSubjectList(inherited Link);
end;

procedure TFhirEvidenceReportSubjectList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceReportSubjectList.SetItemByIndex(index: Integer; value: TFhirEvidenceReportSubject);
begin
  assert(value is TFhirEvidenceReportSubject);
  FhirEvidenceReportSubjects[index] := value;
end;

procedure TFhirEvidenceReportSubjectList.SetItemN(index: Integer; value: TFhirEvidenceReportSubject);
begin
  assert(value is TFhirEvidenceReportSubject);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceReportSubjectCharacteristic }

constructor TFhirEvidenceReportSubjectCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirEvidenceReportSubjectCharacteristic.Destroy;
begin
  FCode.free;
  FValue.free;
  FExclude.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirEvidenceReportSubjectCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirEvidenceReportSubjectCharacteristic(oSource).code.Clone;
  value := TFhirEvidenceReportSubjectCharacteristic(oSource).value.Clone;
  excludeElement := TFhirEvidenceReportSubjectCharacteristic(oSource).excludeElement.Clone;
  period := TFhirEvidenceReportSubjectCharacteristic(oSource).period.Clone;
end;

procedure TFhirEvidenceReportSubjectCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'exclude') Then
     list.add(self.link, 'exclude', FExclude.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirEvidenceReportSubjectCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'Reference|CodeableConcept|boolean|Quantity|Range', false, TFhirDataType, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'exclude', 'boolean', false, TFhirBoolean, FExclude.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
end;

function TFhirEvidenceReportSubjectCharacteristic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Reference', 'CodeableConcept', 'Boolean', 'Quantity', 'Range'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'exclude') then
  begin
    ExcludeElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceReportSubjectCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEvidenceReportSubjectCharacteristic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['Reference', 'CodeableConcept', 'Boolean', 'Quantity', 'Range'])) then raise EFHIRException.create('Cannot make property Value')
  else if (propName = 'exclude') then result := TFhirBoolean.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceReportSubjectCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'Reference|CodeableConcept|boolean|Quantity|Range'
  else if (propName = 'exclude') then result := 'boolean'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceReportSubjectCharacteristic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'value', ['Reference', 'CodeableConcept', 'Boolean', 'Quantity', 'Range'])) then ValueElement := nil
  else if (propName = 'exclude') then ExcludeElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceReportSubjectCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['Reference', 'CodeableConcept', 'Boolean', 'Quantity', 'Range'])) then ValueElement := new as TFhirDataType
  else if (propName = 'exclude') then ExcludeElement := asBoolean(new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceReportSubjectCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceReportSubjectCharacteristic.fhirType : string;
begin
  result := 'EvidenceReport.subject.characteristic';
end;

function TFhirEvidenceReportSubjectCharacteristic.Link : TFhirEvidenceReportSubjectCharacteristic;
begin
  result := TFhirEvidenceReportSubjectCharacteristic(inherited Link);
end;

function TFhirEvidenceReportSubjectCharacteristic.Clone : TFhirEvidenceReportSubjectCharacteristic;
begin
  result := TFhirEvidenceReportSubjectCharacteristic(inherited Clone);
end;

function TFhirEvidenceReportSubjectCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceReportSubjectCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceReportSubjectCharacteristic)) then
    result := false
  else
  begin
    o := TFhirEvidenceReportSubjectCharacteristic(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(excludeElement, o.excludeElement, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirEvidenceReportSubjectCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue) and isEmptyProp(FExclude) and isEmptyProp(FPeriod);
end;

procedure TFhirEvidenceReportSubjectCharacteristic.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('value[x]');
  fields.add('exclude');
  fields.add('period');
end;

function TFhirEvidenceReportSubjectCharacteristic.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirEvidenceReportSubjectCharacteristic.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirEvidenceReportSubjectCharacteristic.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

procedure TFhirEvidenceReportSubjectCharacteristic.SetExclude(value : TFhirBoolean);
begin
  FExclude.free;
  FExclude := value;
end;

function TFhirEvidenceReportSubjectCharacteristic.GetExcludeST : Boolean;
begin
  if FExclude = nil then
    result := false
  else
    result := FExclude.value;
end;

procedure TFhirEvidenceReportSubjectCharacteristic.SetExcludeST(value : Boolean);
begin
  if FExclude = nil then
    FExclude := TFhirBoolean.create;
  FExclude.value := value
end;

procedure TFhirEvidenceReportSubjectCharacteristic.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

{ TFhirEvidenceReportSubjectCharacteristicListEnumerator }

constructor TFhirEvidenceReportSubjectCharacteristicListEnumerator.Create(list : TFhirEvidenceReportSubjectCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceReportSubjectCharacteristicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceReportSubjectCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceReportSubjectCharacteristicListEnumerator.GetCurrent : TFhirEvidenceReportSubjectCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceReportSubjectCharacteristicListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceReportSubjectCharacteristicList }

function TFhirEvidenceReportSubjectCharacteristicList.AddItem(value: TFhirEvidenceReportSubjectCharacteristic): TFhirEvidenceReportSubjectCharacteristic;
begin
  assert(value.ClassName = 'TFhirEvidenceReportSubjectCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceReportSubjectCharacteristic');
  add(value);
  result := value;
end;

function TFhirEvidenceReportSubjectCharacteristicList.Append: TFhirEvidenceReportSubjectCharacteristic;
begin
  result := TFhirEvidenceReportSubjectCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceReportSubjectCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceReportSubjectCharacteristicList.GetEnumerator : TFhirEvidenceReportSubjectCharacteristicListEnumerator;
begin
  result := TFhirEvidenceReportSubjectCharacteristicListEnumerator.Create(self.link);
end;

function TFhirEvidenceReportSubjectCharacteristicList.Clone: TFhirEvidenceReportSubjectCharacteristicList;
begin
  result := TFhirEvidenceReportSubjectCharacteristicList(inherited Clone);
end;

function TFhirEvidenceReportSubjectCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceReportSubjectCharacteristicList.GetItemN(index: Integer): TFhirEvidenceReportSubjectCharacteristic;
begin
  result := TFhirEvidenceReportSubjectCharacteristic(ObjectByIndex[index]);
end;

function TFhirEvidenceReportSubjectCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceReportSubjectCharacteristic;
end;
function TFhirEvidenceReportSubjectCharacteristicList.IndexOf(value: TFhirEvidenceReportSubjectCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceReportSubjectCharacteristicList.Insert(index: Integer): TFhirEvidenceReportSubjectCharacteristic;
begin
  result := TFhirEvidenceReportSubjectCharacteristic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceReportSubjectCharacteristicList.InsertItem(index: Integer; value: TFhirEvidenceReportSubjectCharacteristic);
begin
  assert(value is TFhirEvidenceReportSubjectCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirEvidenceReportSubjectCharacteristicList.Item(index: Integer): TFhirEvidenceReportSubjectCharacteristic;
begin
  result := TFhirEvidenceReportSubjectCharacteristic(ObjectByIndex[index]);
end;

function TFhirEvidenceReportSubjectCharacteristicList.Link: TFhirEvidenceReportSubjectCharacteristicList;
begin
  result := TFhirEvidenceReportSubjectCharacteristicList(inherited Link);
end;

procedure TFhirEvidenceReportSubjectCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceReportSubjectCharacteristicList.SetItemByIndex(index: Integer; value: TFhirEvidenceReportSubjectCharacteristic);
begin
  assert(value is TFhirEvidenceReportSubjectCharacteristic);
  FhirEvidenceReportSubjectCharacteristics[index] := value;
end;

procedure TFhirEvidenceReportSubjectCharacteristicList.SetItemN(index: Integer; value: TFhirEvidenceReportSubjectCharacteristic);
begin
  assert(value is TFhirEvidenceReportSubjectCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceReportRelatesTo }

constructor TFhirEvidenceReportRelatesTo.Create;
begin
  inherited;
end;

destructor TFhirEvidenceReportRelatesTo.Destroy;
begin
  FCode.free;
  FTarget.free;
  inherited;
end;

procedure TFhirEvidenceReportRelatesTo.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirEvidenceReportRelatesTo(oSource).codeElement.Clone;
  target := TFhirEvidenceReportRelatesTo(oSource).target.Clone;
end;

procedure TFhirEvidenceReportRelatesTo.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
end;

procedure TFhirEvidenceReportRelatesTo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirEnum, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'target', 'BackboneElement', false, TFhirEvidenceReportRelatesToTarget, FTarget.Link));
end;

function TFhirEvidenceReportRelatesTo.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirReportRelationshipTypeEnum, CODES_TFhirReportRelationshipTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    Target := propValue as TFhirEvidenceReportRelatesToTarget;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceReportRelatesTo.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEvidenceReportRelatesTo.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirEnum.create(SYSTEMS_TFhirReportRelationshipTypeEnum[ReportRelationshipTypeNull], CODES_TFhirReportRelationshipTypeEnum[ReportRelationshipTypeNull]) 
  else if (propName = 'target') then result := TFhirEvidenceReportRelatesToTarget.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceReportRelatesTo.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'target') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceReportRelatesTo.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'target') then TargetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceReportRelatesTo.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirReportRelationshipTypeEnum, CODES_TFhirReportRelationshipTypeEnum, new)
  else if (propName = 'target') then TargetElement := new as TFhirEvidenceReportRelatesToTarget
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceReportRelatesTo.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceReportRelatesTo.fhirType : string;
begin
  result := 'EvidenceReport.relatesTo';
end;

function TFhirEvidenceReportRelatesTo.Link : TFhirEvidenceReportRelatesTo;
begin
  result := TFhirEvidenceReportRelatesTo(inherited Link);
end;

function TFhirEvidenceReportRelatesTo.Clone : TFhirEvidenceReportRelatesTo;
begin
  result := TFhirEvidenceReportRelatesTo(inherited Clone);
end;

function TFhirEvidenceReportRelatesTo.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceReportRelatesTo;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceReportRelatesTo)) then
    result := false
  else
  begin
    o := TFhirEvidenceReportRelatesTo(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(targetElement, o.targetElement, true);
  end;
end;

function TFhirEvidenceReportRelatesTo.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FTarget);
end;

procedure TFhirEvidenceReportRelatesTo.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('target');
end;

function TFhirEvidenceReportRelatesTo.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirEvidenceReportRelatesTo.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

function TFhirEvidenceReportRelatesTo.GetCodeST : TFhirReportRelationshipTypeEnum;
begin
  if FCode = nil then
    result := TFhirReportRelationshipTypeEnum(0)
  else
    result := TFhirReportRelationshipTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirReportRelationshipTypeEnum, FCode.value));
end;

procedure TFhirEvidenceReportRelatesTo.SetCodeST(value : TFhirReportRelationshipTypeEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirReportRelationshipTypeEnum[value], CODES_TFhirReportRelationshipTypeEnum[value]);
end;

procedure TFhirEvidenceReportRelatesTo.SetTarget(value : TFhirEvidenceReportRelatesToTarget);
begin
  FTarget.free;
  FTarget := value;
end;

{ TFhirEvidenceReportRelatesToListEnumerator }

constructor TFhirEvidenceReportRelatesToListEnumerator.Create(list : TFhirEvidenceReportRelatesToList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceReportRelatesToListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceReportRelatesToListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceReportRelatesToListEnumerator.GetCurrent : TFhirEvidenceReportRelatesTo;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceReportRelatesToListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceReportRelatesToList }

function TFhirEvidenceReportRelatesToList.AddItem(value: TFhirEvidenceReportRelatesTo): TFhirEvidenceReportRelatesTo;
begin
  assert(value.ClassName = 'TFhirEvidenceReportRelatesTo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceReportRelatesTo');
  add(value);
  result := value;
end;

function TFhirEvidenceReportRelatesToList.Append: TFhirEvidenceReportRelatesTo;
begin
  result := TFhirEvidenceReportRelatesTo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceReportRelatesToList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceReportRelatesToList.GetEnumerator : TFhirEvidenceReportRelatesToListEnumerator;
begin
  result := TFhirEvidenceReportRelatesToListEnumerator.Create(self.link);
end;

function TFhirEvidenceReportRelatesToList.Clone: TFhirEvidenceReportRelatesToList;
begin
  result := TFhirEvidenceReportRelatesToList(inherited Clone);
end;

function TFhirEvidenceReportRelatesToList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceReportRelatesToList.GetItemN(index: Integer): TFhirEvidenceReportRelatesTo;
begin
  result := TFhirEvidenceReportRelatesTo(ObjectByIndex[index]);
end;

function TFhirEvidenceReportRelatesToList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceReportRelatesTo;
end;
function TFhirEvidenceReportRelatesToList.IndexOf(value: TFhirEvidenceReportRelatesTo): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceReportRelatesToList.Insert(index: Integer): TFhirEvidenceReportRelatesTo;
begin
  result := TFhirEvidenceReportRelatesTo.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceReportRelatesToList.InsertItem(index: Integer; value: TFhirEvidenceReportRelatesTo);
begin
  assert(value is TFhirEvidenceReportRelatesTo);
  Inherited Insert(index, value);
end;

function TFhirEvidenceReportRelatesToList.Item(index: Integer): TFhirEvidenceReportRelatesTo;
begin
  result := TFhirEvidenceReportRelatesTo(ObjectByIndex[index]);
end;

function TFhirEvidenceReportRelatesToList.Link: TFhirEvidenceReportRelatesToList;
begin
  result := TFhirEvidenceReportRelatesToList(inherited Link);
end;

procedure TFhirEvidenceReportRelatesToList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceReportRelatesToList.SetItemByIndex(index: Integer; value: TFhirEvidenceReportRelatesTo);
begin
  assert(value is TFhirEvidenceReportRelatesTo);
  FhirEvidenceReportRelatesTos[index] := value;
end;

procedure TFhirEvidenceReportRelatesToList.SetItemN(index: Integer; value: TFhirEvidenceReportRelatesTo);
begin
  assert(value is TFhirEvidenceReportRelatesTo);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceReportRelatesToTarget }

constructor TFhirEvidenceReportRelatesToTarget.Create;
begin
  inherited;
end;

destructor TFhirEvidenceReportRelatesToTarget.Destroy;
begin
  FUrl.free;
  FIdentifier.free;
  FDisplay.free;
  FResource.free;
  inherited;
end;

procedure TFhirEvidenceReportRelatesToTarget.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirEvidenceReportRelatesToTarget(oSource).urlElement.Clone;
  identifier := TFhirEvidenceReportRelatesToTarget(oSource).identifier.Clone;
  displayElement := TFhirEvidenceReportRelatesToTarget(oSource).displayElement.Clone;
  resource := TFhirEvidenceReportRelatesToTarget(oSource).resource.Clone;
end;

procedure TFhirEvidenceReportRelatesToTarget.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
end;

procedure TFhirEvidenceReportRelatesToTarget.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'display', 'markdown', false, TFhirMarkdown, FDisplay.Link));
  oList.add(TFHIRProperty.create(self, 'resource', 'Reference', false, TFhirReference, FResource.Link));
end;

function TFhirEvidenceReportRelatesToTarget.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    Resource := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceReportRelatesToTarget.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEvidenceReportRelatesToTarget.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'display') then result := TFhirMarkdown.create()
  else if (propName = 'resource') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceReportRelatesToTarget.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'display') then result := 'markdown'
  else if (propName = 'resource') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceReportRelatesToTarget.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceReportRelatesToTarget.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'display') then DisplayElement := asMarkdown(new)
  else if (propName = 'resource') then ResourceElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceReportRelatesToTarget.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceReportRelatesToTarget.fhirType : string;
begin
  result := 'EvidenceReport.relatesTo.target';
end;

function TFhirEvidenceReportRelatesToTarget.Link : TFhirEvidenceReportRelatesToTarget;
begin
  result := TFhirEvidenceReportRelatesToTarget(inherited Link);
end;

function TFhirEvidenceReportRelatesToTarget.Clone : TFhirEvidenceReportRelatesToTarget;
begin
  result := TFhirEvidenceReportRelatesToTarget(inherited Clone);
end;

function TFhirEvidenceReportRelatesToTarget.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceReportRelatesToTarget;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceReportRelatesToTarget)) then
    result := false
  else
  begin
    o := TFhirEvidenceReportRelatesToTarget(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(identifierElement, o.identifierElement, true) and 
      compareDeep(displayElement, o.displayElement, true) and compareDeep(resourceElement, o.resourceElement, true);
  end;
end;

function TFhirEvidenceReportRelatesToTarget.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FIdentifier) and isEmptyProp(FDisplay) and isEmptyProp(FResource);
end;

procedure TFhirEvidenceReportRelatesToTarget.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('display');
  fields.add('resource');
end;

function TFhirEvidenceReportRelatesToTarget.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirEvidenceReportRelatesToTarget.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirEvidenceReportRelatesToTarget.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirEvidenceReportRelatesToTarget.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

procedure TFhirEvidenceReportRelatesToTarget.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirEvidenceReportRelatesToTarget.SetDisplay(value : TFhirMarkdown);
begin
  FDisplay.free;
  FDisplay := value;
end;

function TFhirEvidenceReportRelatesToTarget.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

procedure TFhirEvidenceReportRelatesToTarget.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirMarkdown.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

procedure TFhirEvidenceReportRelatesToTarget.SetResource(value : TFhirReference);
begin
  FResource.free;
  FResource := value;
end;

{ TFhirEvidenceReportRelatesToTargetListEnumerator }

constructor TFhirEvidenceReportRelatesToTargetListEnumerator.Create(list : TFhirEvidenceReportRelatesToTargetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceReportRelatesToTargetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceReportRelatesToTargetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceReportRelatesToTargetListEnumerator.GetCurrent : TFhirEvidenceReportRelatesToTarget;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceReportRelatesToTargetListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceReportRelatesToTargetList }

function TFhirEvidenceReportRelatesToTargetList.AddItem(value: TFhirEvidenceReportRelatesToTarget): TFhirEvidenceReportRelatesToTarget;
begin
  assert(value.ClassName = 'TFhirEvidenceReportRelatesToTarget', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceReportRelatesToTarget');
  add(value);
  result := value;
end;

function TFhirEvidenceReportRelatesToTargetList.Append: TFhirEvidenceReportRelatesToTarget;
begin
  result := TFhirEvidenceReportRelatesToTarget.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceReportRelatesToTargetList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceReportRelatesToTargetList.GetEnumerator : TFhirEvidenceReportRelatesToTargetListEnumerator;
begin
  result := TFhirEvidenceReportRelatesToTargetListEnumerator.Create(self.link);
end;

function TFhirEvidenceReportRelatesToTargetList.Clone: TFhirEvidenceReportRelatesToTargetList;
begin
  result := TFhirEvidenceReportRelatesToTargetList(inherited Clone);
end;

function TFhirEvidenceReportRelatesToTargetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceReportRelatesToTargetList.GetItemN(index: Integer): TFhirEvidenceReportRelatesToTarget;
begin
  result := TFhirEvidenceReportRelatesToTarget(ObjectByIndex[index]);
end;

function TFhirEvidenceReportRelatesToTargetList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceReportRelatesToTarget;
end;
function TFhirEvidenceReportRelatesToTargetList.IndexOf(value: TFhirEvidenceReportRelatesToTarget): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceReportRelatesToTargetList.Insert(index: Integer): TFhirEvidenceReportRelatesToTarget;
begin
  result := TFhirEvidenceReportRelatesToTarget.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceReportRelatesToTargetList.InsertItem(index: Integer; value: TFhirEvidenceReportRelatesToTarget);
begin
  assert(value is TFhirEvidenceReportRelatesToTarget);
  Inherited Insert(index, value);
end;

function TFhirEvidenceReportRelatesToTargetList.Item(index: Integer): TFhirEvidenceReportRelatesToTarget;
begin
  result := TFhirEvidenceReportRelatesToTarget(ObjectByIndex[index]);
end;

function TFhirEvidenceReportRelatesToTargetList.Link: TFhirEvidenceReportRelatesToTargetList;
begin
  result := TFhirEvidenceReportRelatesToTargetList(inherited Link);
end;

procedure TFhirEvidenceReportRelatesToTargetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceReportRelatesToTargetList.SetItemByIndex(index: Integer; value: TFhirEvidenceReportRelatesToTarget);
begin
  assert(value is TFhirEvidenceReportRelatesToTarget);
  FhirEvidenceReportRelatesToTargets[index] := value;
end;

procedure TFhirEvidenceReportRelatesToTargetList.SetItemN(index: Integer; value: TFhirEvidenceReportRelatesToTarget);
begin
  assert(value is TFhirEvidenceReportRelatesToTarget);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceReportSection }

constructor TFhirEvidenceReportSection.Create;
begin
  inherited;
end;

destructor TFhirEvidenceReportSection.Destroy;
begin
  FTitle.free;
  FFocus.free;
  FFocusReference.free;
  FAuthorList.Free;
  FText.free;
  FMode.free;
  FOrderedBy.free;
  FEntryClassifierList.Free;
  FEntryReferenceList.Free;
  FEntryQuantityList.Free;
  FEmptyReason.free;
  FSectionList.Free;
  inherited;
end;

procedure TFhirEvidenceReportSection.Assign(oSource : TFslObject);
begin
  inherited;
  titleElement := TFhirEvidenceReportSection(oSource).titleElement.Clone;
  focus := TFhirEvidenceReportSection(oSource).focus.Clone;
  focusReference := TFhirEvidenceReportSection(oSource).focusReference.Clone;
  if (TFhirEvidenceReportSection(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirReferenceList.Create;
    FAuthorList.Assign(TFhirEvidenceReportSection(oSource).FAuthorList);
  end;
  text := TFhirEvidenceReportSection(oSource).text.Clone;
  modeElement := TFhirEvidenceReportSection(oSource).modeElement.Clone;
  orderedBy := TFhirEvidenceReportSection(oSource).orderedBy.Clone;
  if (TFhirEvidenceReportSection(oSource).FEntryClassifierList = nil) then
  begin
    FEntryClassifierList.free;
    FEntryClassifierList := nil;
  end
  else
  begin
    if FEntryClassifierList = nil then
      FEntryClassifierList := TFhirCodeableConceptList.Create;
    FEntryClassifierList.Assign(TFhirEvidenceReportSection(oSource).FEntryClassifierList);
  end;
  if (TFhirEvidenceReportSection(oSource).FEntryReferenceList = nil) then
  begin
    FEntryReferenceList.free;
    FEntryReferenceList := nil;
  end
  else
  begin
    if FEntryReferenceList = nil then
      FEntryReferenceList := TFhirReferenceList.Create;
    FEntryReferenceList.Assign(TFhirEvidenceReportSection(oSource).FEntryReferenceList);
  end;
  if (TFhirEvidenceReportSection(oSource).FEntryQuantityList = nil) then
  begin
    FEntryQuantityList.free;
    FEntryQuantityList := nil;
  end
  else
  begin
    if FEntryQuantityList = nil then
      FEntryQuantityList := TFhirQuantityList.Create;
    FEntryQuantityList.Assign(TFhirEvidenceReportSection(oSource).FEntryQuantityList);
  end;
  emptyReason := TFhirEvidenceReportSection(oSource).emptyReason.Clone;
  if (TFhirEvidenceReportSection(oSource).FSectionList = nil) then
  begin
    FSectionList.free;
    FSectionList := nil;
  end
  else
  begin
    if FSectionList = nil then
      FSectionList := TFhirEvidenceReportSectionList.Create;
    FSectionList.Assign(TFhirEvidenceReportSection(oSource).FSectionList);
  end;
end;

procedure TFhirEvidenceReportSection.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'focus') Then
     list.add(self.link, 'focus', FFocus.Link);
  if (child_name = 'focusReference') Then
     list.add(self.link, 'focusReference', FFocusReference.Link);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'orderedBy') Then
     list.add(self.link, 'orderedBy', FOrderedBy.Link);
  if (child_name = 'entryClassifier') Then
    list.addAll(self, 'entryClassifier', FEntryClassifierList);
  if (child_name = 'entryReference') Then
    list.addAll(self, 'entryReference', FEntryReferenceList);
  if (child_name = 'entryQuantity') Then
    list.addAll(self, 'entryQuantity', FEntryQuantityList);
  if (child_name = 'emptyReason') Then
     list.add(self.link, 'emptyReason', FEmptyReason.Link);
  if (child_name = 'section') Then
    list.addAll(self, 'section', FSectionList);
end;

procedure TFhirEvidenceReportSection.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'focus', 'CodeableConcept', false, TFhirCodeableConcept, FFocus.Link));
  oList.add(TFHIRProperty.create(self, 'focusReference', 'Reference', false, TFhirReference, FFocusReference.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', true, TFhirReference, FAuthorList.Link));
  oList.add(TFHIRProperty.create(self, 'text', 'Narrative', false, TFhirNarrative, FText.Link));
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFhirEnum, FMode.Link));
  oList.add(TFHIRProperty.create(self, 'orderedBy', 'CodeableConcept', false, TFhirCodeableConcept, FOrderedBy.Link));
  oList.add(TFHIRProperty.create(self, 'entryClassifier', 'CodeableConcept', true, TFhirCodeableConcept, FEntryClassifierList.Link));
  oList.add(TFHIRProperty.create(self, 'entryReference', 'Reference', true, TFhirReference, FEntryReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'entryQuantity', 'Quantity', true, TFhirQuantity, FEntryQuantityList.Link));
  oList.add(TFHIRProperty.create(self, 'emptyReason', 'CodeableConcept', false, TFhirCodeableConcept, FEmptyReason.Link));
  oList.add(TFHIRProperty.create(self, 'section', '', true, TFhirEvidenceReportSection, FSectionList.Link));
end;

function TFhirEvidenceReportSection.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'focus') then
  begin
    Focus := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'focusReference') then
  begin
    FocusReference := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    Text := propValue as TFhirNarrative;
    result := propValue;
  end
  else if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirListModeEnum, CODES_TFhirListModeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'orderedBy') then
  begin
    OrderedBy := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'entryClassifier') then
  begin
    EntryClassifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'entryReference') then
  begin
    EntryReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'entryQuantity') then
  begin
    EntryQuantityList.add(propValue as TFhirQuantity);
    result := propValue;
  end
  else if (propName = 'emptyReason') then
  begin
    EmptyReason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'section') then
  begin
    SectionList.add(propValue as TFhirEvidenceReportSection);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceReportSection.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'entryClassifier') then EntryClassifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'entryReference') then EntryReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'entryQuantity') then EntryQuantityList.insertItem(index, propValue as TFhirQuantity)
  else if (propName = 'section') then SectionList.insertItem(index, propValue as TFhirEvidenceReportSection)
  else inherited;
end;

function TFhirEvidenceReportSection.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'focus') then result := TFhirCodeableConcept.create()
  else if (propName = 'focusReference') then result := TFhirReference.create()
  else if (propName = 'author') then result := AuthorList.new()
  else if (propName = 'text') then result := TFhirNarrative.create()
  else if (propName = 'mode') then result := TFhirEnum.create(SYSTEMS_TFhirListModeEnum[ListModeNull], CODES_TFhirListModeEnum[ListModeNull]) 
  else if (propName = 'orderedBy') then result := TFhirCodeableConcept.create()
  else if (propName = 'entryClassifier') then result := EntryClassifierList.new()
  else if (propName = 'entryReference') then result := EntryReferenceList.new()
  else if (propName = 'entryQuantity') then result := EntryQuantityList.new()
  else if (propName = 'emptyReason') then result := TFhirCodeableConcept.create()
  else if (propName = 'section') then result := SectionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceReportSection.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'title') then result := 'string'
  else if (propName = 'focus') then result := 'CodeableConcept'
  else if (propName = 'focusReference') then result := 'Reference'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'text') then result := 'Narrative'
  else if (propName = 'mode') then result := 'code'
  else if (propName = 'orderedBy') then result := 'CodeableConcept'
  else if (propName = 'entryClassifier') then result := 'CodeableConcept'
  else if (propName = 'entryReference') then result := 'Reference'
  else if (propName = 'entryQuantity') then result := 'Quantity'
  else if (propName = 'emptyReason') then result := 'CodeableConcept'
  else if (propName = 'section') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceReportSection.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := nil
  else if (propName = 'focus') then FocusElement := nil
  else if (propName = 'focusReference') then FocusReferenceElement := nil
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value)
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'mode') then ModeElement := nil
  else if (propName = 'orderedBy') then OrderedByElement := nil
  else if (propName = 'entryClassifier') then deletePropertyValue('entryClassifier', EntryClassifierList, value)
  else if (propName = 'entryReference') then deletePropertyValue('entryReference', EntryReferenceList, value)
  else if (propName = 'entryQuantity') then deletePropertyValue('entryQuantity', EntryQuantityList, value)
  else if (propName = 'emptyReason') then EmptyReasonElement := nil
  else if (propName = 'section') then deletePropertyValue('section', SectionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceReportSection.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'focus') then FocusElement := new as TFhirCodeableConcept
  else if (propName = 'focusReference') then FocusReferenceElement := new as TFhirReference
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new)
  else if (propName = 'text') then TextElement := new as TFhirNarrative
  else if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirListModeEnum, CODES_TFhirListModeEnum, new)
  else if (propName = 'orderedBy') then OrderedByElement := new as TFhirCodeableConcept
  else if (propName = 'entryClassifier') then replacePropertyValue('entryClassifier', EntryClassifierList, existing, new)
  else if (propName = 'entryReference') then replacePropertyValue('entryReference', EntryReferenceList, existing, new)
  else if (propName = 'entryQuantity') then replacePropertyValue('entryQuantity', EntryQuantityList, existing, new)
  else if (propName = 'emptyReason') then EmptyReasonElement := new as TFhirCodeableConcept
  else if (propName = 'section') then replacePropertyValue('section', SectionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceReportSection.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'author') then AuthorList.move(source, destination)
  else if (propName = 'entryClassifier') then EntryClassifierList.move(source, destination)
  else if (propName = 'entryReference') then EntryReferenceList.move(source, destination)
  else if (propName = 'entryQuantity') then EntryQuantityList.move(source, destination)
  else if (propName = 'section') then SectionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceReportSection.fhirType : string;
begin
  result := 'EvidenceReport.section';
end;

function TFhirEvidenceReportSection.Link : TFhirEvidenceReportSection;
begin
  result := TFhirEvidenceReportSection(inherited Link);
end;

function TFhirEvidenceReportSection.Clone : TFhirEvidenceReportSection;
begin
  result := TFhirEvidenceReportSection(inherited Clone);
end;

function TFhirEvidenceReportSection.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceReportSection;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceReportSection)) then
    result := false
  else
  begin
    o := TFhirEvidenceReportSection(other);
    result := compareDeep(titleElement, o.titleElement, true) and compareDeep(focusElement, o.focusElement, true) and 
      compareDeep(focusReferenceElement, o.focusReferenceElement, true) and compareDeep(authorList, o.authorList, true) and 
      compareDeep(textElement, o.textElement, true) and compareDeep(modeElement, o.modeElement, true) and 
      compareDeep(orderedByElement, o.orderedByElement, true) and compareDeep(entryClassifierList, o.entryClassifierList, true) and 
      compareDeep(entryReferenceList, o.entryReferenceList, true) and compareDeep(entryQuantityList, o.entryQuantityList, true) and 
      compareDeep(emptyReasonElement, o.emptyReasonElement, true) and compareDeep(sectionList, o.sectionList, true);
  end;
end;

function TFhirEvidenceReportSection.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTitle) and isEmptyProp(FFocus) and isEmptyProp(FFocusReference) and isEmptyProp(FauthorList) and isEmptyProp(FText) and isEmptyProp(FMode) and isEmptyProp(FOrderedBy) and isEmptyProp(FentryClassifierList) and isEmptyProp(FentryReferenceList) and isEmptyProp(FentryQuantityList) and isEmptyProp(FEmptyReason) and isEmptyProp(FsectionList);
end;

procedure TFhirEvidenceReportSection.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('title');
  fields.add('focus');
  fields.add('focusReference');
  fields.add('author');
  fields.add('text');
  fields.add('mode');
  fields.add('orderedBy');
  fields.add('entryClassifier');
  fields.add('entryReference');
  fields.add('entryQuantity');
  fields.add('emptyReason');
  fields.add('section');
end;

function TFhirEvidenceReportSection.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FAuthorList.sizeInBytes(magic));
  inc(result, FEntryClassifierList.sizeInBytes(magic));
  inc(result, FEntryReferenceList.sizeInBytes(magic));
  inc(result, FEntryQuantityList.sizeInBytes(magic));
  inc(result, FSectionList.sizeInBytes(magic));
end;

procedure TFhirEvidenceReportSection.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirEvidenceReportSection.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirEvidenceReportSection.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirEvidenceReportSection.SetFocus(value : TFhirCodeableConcept);
begin
  FFocus.free;
  FFocus := value;
end;

procedure TFhirEvidenceReportSection.SetFocusReference(value : TFhirReference);
begin
  FFocusReference.free;
  FFocusReference := value;
end;

function TFhirEvidenceReportSection.GetAuthorList : TFhirReferenceList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirReferenceList.Create;
  result := FAuthorList;
end;

function TFhirEvidenceReportSection.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

procedure TFhirEvidenceReportSection.SetText(value : TFhirNarrative);
begin
  FText.free;
  FText := value;
end;

procedure TFhirEvidenceReportSection.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

function TFhirEvidenceReportSection.GetModeST : TFhirListModeEnum;
begin
  if FMode = nil then
    result := TFhirListModeEnum(0)
  else
    result := TFhirListModeEnum(StringArrayIndexOfSensitive(CODES_TFhirListModeEnum, FMode.value));
end;

procedure TFhirEvidenceReportSection.SetModeST(value : TFhirListModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirListModeEnum[value], CODES_TFhirListModeEnum[value]);
end;

procedure TFhirEvidenceReportSection.SetOrderedBy(value : TFhirCodeableConcept);
begin
  FOrderedBy.free;
  FOrderedBy := value;
end;

function TFhirEvidenceReportSection.GetEntryClassifierList : TFhirCodeableConceptList;
begin
  if FEntryClassifierList = nil then
    FEntryClassifierList := TFhirCodeableConceptList.Create;
  result := FEntryClassifierList;
end;

function TFhirEvidenceReportSection.GetHasEntryClassifierList : boolean;
begin
  result := (FEntryClassifierList <> nil) and (FEntryClassifierList.count > 0);
end;

function TFhirEvidenceReportSection.GetEntryReferenceList : TFhirReferenceList;
begin
  if FEntryReferenceList = nil then
    FEntryReferenceList := TFhirReferenceList.Create;
  result := FEntryReferenceList;
end;

function TFhirEvidenceReportSection.GetHasEntryReferenceList : boolean;
begin
  result := (FEntryReferenceList <> nil) and (FEntryReferenceList.count > 0);
end;

function TFhirEvidenceReportSection.GetEntryQuantityList : TFhirQuantityList;
begin
  if FEntryQuantityList = nil then
    FEntryQuantityList := TFhirQuantityList.Create;
  result := FEntryQuantityList;
end;

function TFhirEvidenceReportSection.GetHasEntryQuantityList : boolean;
begin
  result := (FEntryQuantityList <> nil) and (FEntryQuantityList.count > 0);
end;

procedure TFhirEvidenceReportSection.SetEmptyReason(value : TFhirCodeableConcept);
begin
  FEmptyReason.free;
  FEmptyReason := value;
end;

function TFhirEvidenceReportSection.GetSectionList : TFhirEvidenceReportSectionList;
begin
  if FSectionList = nil then
    FSectionList := TFhirEvidenceReportSectionList.Create;
  result := FSectionList;
end;

function TFhirEvidenceReportSection.GetHasSectionList : boolean;
begin
  result := (FSectionList <> nil) and (FSectionList.count > 0);
end;

{ TFhirEvidenceReportSectionListEnumerator }

constructor TFhirEvidenceReportSectionListEnumerator.Create(list : TFhirEvidenceReportSectionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceReportSectionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceReportSectionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceReportSectionListEnumerator.GetCurrent : TFhirEvidenceReportSection;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceReportSectionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceReportSectionList }

function TFhirEvidenceReportSectionList.AddItem(value: TFhirEvidenceReportSection): TFhirEvidenceReportSection;
begin
  assert(value.ClassName = 'TFhirEvidenceReportSection', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceReportSection');
  add(value);
  result := value;
end;

function TFhirEvidenceReportSectionList.Append: TFhirEvidenceReportSection;
begin
  result := TFhirEvidenceReportSection.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceReportSectionList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceReportSectionList.GetEnumerator : TFhirEvidenceReportSectionListEnumerator;
begin
  result := TFhirEvidenceReportSectionListEnumerator.Create(self.link);
end;

function TFhirEvidenceReportSectionList.Clone: TFhirEvidenceReportSectionList;
begin
  result := TFhirEvidenceReportSectionList(inherited Clone);
end;

function TFhirEvidenceReportSectionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceReportSectionList.GetItemN(index: Integer): TFhirEvidenceReportSection;
begin
  result := TFhirEvidenceReportSection(ObjectByIndex[index]);
end;

function TFhirEvidenceReportSectionList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceReportSection;
end;
function TFhirEvidenceReportSectionList.IndexOf(value: TFhirEvidenceReportSection): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceReportSectionList.Insert(index: Integer): TFhirEvidenceReportSection;
begin
  result := TFhirEvidenceReportSection.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceReportSectionList.InsertItem(index: Integer; value: TFhirEvidenceReportSection);
begin
  assert(value is TFhirEvidenceReportSection);
  Inherited Insert(index, value);
end;

function TFhirEvidenceReportSectionList.Item(index: Integer): TFhirEvidenceReportSection;
begin
  result := TFhirEvidenceReportSection(ObjectByIndex[index]);
end;

function TFhirEvidenceReportSectionList.Link: TFhirEvidenceReportSectionList;
begin
  result := TFhirEvidenceReportSectionList(inherited Link);
end;

procedure TFhirEvidenceReportSectionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceReportSectionList.SetItemByIndex(index: Integer; value: TFhirEvidenceReportSection);
begin
  assert(value is TFhirEvidenceReportSection);
  FhirEvidenceReportSections[index] := value;
end;

procedure TFhirEvidenceReportSectionList.SetItemN(index: Integer; value: TFhirEvidenceReportSection);
begin
  assert(value is TFhirEvidenceReportSection);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceReport }

constructor TFhirEvidenceReport.Create;
begin
  inherited;
end;

destructor TFhirEvidenceReport.Destroy;
begin
  FRelatedIdentifierList.Free;
  FCiteAs.free;
  FType_.free;
  FNoteList.Free;
  FSubject.free;
  FRelatesToList.Free;
  FSectionList.Free;
  inherited;
end;

procedure TFhirEvidenceReport.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEvidenceReport(oSource).FRelatedIdentifierList = nil) then
  begin
    FRelatedIdentifierList.free;
    FRelatedIdentifierList := nil;
  end
  else
  begin
    if FRelatedIdentifierList = nil then
      FRelatedIdentifierList := TFhirIdentifierList.Create;
    FRelatedIdentifierList.Assign(TFhirEvidenceReport(oSource).FRelatedIdentifierList);
  end;
  citeAs := TFhirEvidenceReport(oSource).citeAs.Clone;
  type_ := TFhirEvidenceReport(oSource).type_.Clone;
  if (TFhirEvidenceReport(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEvidenceReport(oSource).FNoteList);
  end;
  subject := TFhirEvidenceReport(oSource).subject.Clone;
  if (TFhirEvidenceReport(oSource).FRelatesToList = nil) then
  begin
    FRelatesToList.free;
    FRelatesToList := nil;
  end
  else
  begin
    if FRelatesToList = nil then
      FRelatesToList := TFhirEvidenceReportRelatesToList.Create;
    FRelatesToList.Assign(TFhirEvidenceReport(oSource).FRelatesToList);
  end;
  if (TFhirEvidenceReport(oSource).FSectionList = nil) then
  begin
    FSectionList.free;
    FSectionList := nil;
  end
  else
  begin
    if FSectionList = nil then
      FSectionList := TFhirEvidenceReportSectionList.Create;
    FSectionList.Assign(TFhirEvidenceReport(oSource).FSectionList);
  end;
end;

function TFhirEvidenceReport.GetResourceType : TFhirResourceType;
begin
  result := frtEvidenceReport;
end;

procedure TFhirEvidenceReport.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'relatedIdentifier') Then
    list.addAll(self, 'relatedIdentifier', FRelatedIdentifierList);
  if (child_name = 'citeAs[x]') or (child_name = 'citeAs') Then
     list.add(self.link, 'citeAs[x]', FCiteAs.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'relatesTo') Then
    list.addAll(self, 'relatesTo', FRelatesToList);
  if (child_name = 'section') Then
    list.addAll(self, 'section', FSectionList);
end;

procedure TFhirEvidenceReport.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'relatedIdentifier', 'Identifier', true, TFhirIdentifier, FRelatedIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'citeAs[x]', 'Reference|markdown', false, TFhirDataType, FCiteAs.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'BackboneElement', false, TFhirEvidenceReportSubject, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'relatesTo', 'BackboneElement', true, TFhirEvidenceReportRelatesTo, FRelatesToList.Link));
  oList.add(TFHIRProperty.create(self, 'section', 'BackboneElement', true, TFhirEvidenceReportSection, FSectionList.Link));
end;

function TFhirEvidenceReport.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'relatedIdentifier') then
  begin
    RelatedIdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (isMatchingName(propName, 'citeAs', ['Reference', 'Markdown'])) then
  begin
    CiteAs := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirEvidenceReportSubject;
    result := propValue;
  end
  else if (propName = 'relatesTo') then
  begin
    RelatesToList.add(propValue as TFhirEvidenceReportRelatesTo);
    result := propValue;
  end
  else if (propName = 'section') then
  begin
    SectionList.add(propValue as TFhirEvidenceReportSection);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceReport.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'relatedIdentifier') then RelatedIdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'relatesTo') then RelatesToList.insertItem(index, propValue as TFhirEvidenceReportRelatesTo)
  else if (propName = 'section') then SectionList.insertItem(index, propValue as TFhirEvidenceReportSection)
  else inherited;
end;

function TFhirEvidenceReport.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'relatedIdentifier') then result := RelatedIdentifierList.new()
  else if (isMatchingName(propName, 'citeAs', ['Reference', 'Markdown'])) then raise EFHIRException.create('Cannot make property CiteAs')
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'subject') then result := TFhirEvidenceReportSubject.create()
  else if (propName = 'relatesTo') then result := RelatesToList.new()
  else if (propName = 'section') then result := SectionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceReport.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'relatedIdentifier') then result := 'Identifier'
  else if (propName = 'citeAs[x]') then result := 'Reference|markdown'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'subject') then result := 'BackboneElement'
  else if (propName = 'relatesTo') then result := 'BackboneElement'
  else if (propName = 'section') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceReport.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'relatedIdentifier') then deletePropertyValue('relatedIdentifier', RelatedIdentifierList, value)
  else if (isMatchingName(propName, 'citeAs', ['Reference', 'Markdown'])) then CiteAsElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'relatesTo') then deletePropertyValue('relatesTo', RelatesToList, value)
  else if (propName = 'section') then deletePropertyValue('section', SectionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceReport.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'relatedIdentifier') then replacePropertyValue('relatedIdentifier', RelatedIdentifierList, existing, new)
  else if (isMatchingName(propName, 'citeAs', ['Reference', 'Markdown'])) then CiteAsElement := new as TFhirDataType
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'subject') then SubjectElement := new as TFhirEvidenceReportSubject
  else if (propName = 'relatesTo') then replacePropertyValue('relatesTo', RelatesToList, existing, new)
  else if (propName = 'section') then replacePropertyValue('section', SectionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceReport.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'relatedIdentifier') then RelatedIdentifierList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'relatesTo') then RelatesToList.move(source, destination)
  else if (propName = 'section') then SectionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceReport.fhirType : string;
begin
  result := 'EvidenceReport';
end;

function TFhirEvidenceReport.Link : TFhirEvidenceReport;
begin
  result := TFhirEvidenceReport(inherited Link);
end;

function TFhirEvidenceReport.Clone : TFhirEvidenceReport;
begin
  result := TFhirEvidenceReport(inherited Clone);
end;

function TFhirEvidenceReport.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceReport;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceReport)) then
    result := false
  else
  begin
    o := TFhirEvidenceReport(other);
    result := compareDeep(relatedIdentifierList, o.relatedIdentifierList, true) and 
      compareDeep(citeAsElement, o.citeAsElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(relatesToList, o.relatesToList, true) and compareDeep(sectionList, o.sectionList, true);
  end;
end;

function TFhirEvidenceReport.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FrelatedIdentifierList) and isEmptyProp(FCiteAs) and isEmptyProp(FType_) and isEmptyProp(FnoteList) and isEmptyProp(FSubject) and isEmptyProp(FrelatesToList) and isEmptyProp(FsectionList);
end;

procedure TFhirEvidenceReport.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('status');
  fields.add('useContext');
  fields.add('identifier');
  fields.add('relatedIdentifier');
  fields.add('citeAs[x]');
  fields.add('type');
  fields.add('note');
  fields.add('relatedArtifact');
  fields.add('subject');
  fields.add('publisher');
  fields.add('contact');
  fields.add('author');
  fields.add('editor');
  fields.add('reviewer');
  fields.add('endorser');
  fields.add('relatesTo');
  fields.add('section');
end;

function TFhirEvidenceReport.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FRelatedIdentifierList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FRelatesToList.sizeInBytes(magic));
  inc(result, FSectionList.sizeInBytes(magic));
end;

procedure TFhirEvidenceReport.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirEvidenceReport.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirEvidenceReport.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

procedure TFhirEvidenceReport.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEvidenceReport.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirEvidenceReport.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

function TFhirEvidenceReport.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirEvidenceReport.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirEvidenceReport.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirEvidenceReport.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirEvidenceReport.GetRelatedIdentifierList : TFhirIdentifierList;
begin
  if FRelatedIdentifierList = nil then
    FRelatedIdentifierList := TFhirIdentifierList.Create;
  result := FRelatedIdentifierList;
end;

function TFhirEvidenceReport.GetHasRelatedIdentifierList : boolean;
begin
  result := (FRelatedIdentifierList <> nil) and (FRelatedIdentifierList.count > 0);
end;

procedure TFhirEvidenceReport.SetCiteAs(value : TFhirDataType);
begin
  FCiteAs.free;
  FCiteAs := value;
end;

procedure TFhirEvidenceReport.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirEvidenceReport.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirEvidenceReport.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirEvidenceReport.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

function TFhirEvidenceReport.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

procedure TFhirEvidenceReport.SetSubject(value : TFhirEvidenceReportSubject);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirEvidenceReport.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirEvidenceReport.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirEvidenceReport.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirEvidenceReport.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirEvidenceReport.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

function TFhirEvidenceReport.GetAuthorList : TFhirContactDetailList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirContactDetailList.Create;
  result := FAuthorList;
end;

function TFhirEvidenceReport.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

function TFhirEvidenceReport.GetEditorList : TFhirContactDetailList;
begin
  if FEditorList = nil then
    FEditorList := TFhirContactDetailList.Create;
  result := FEditorList;
end;

function TFhirEvidenceReport.GetHasEditorList : boolean;
begin
  result := (FEditorList <> nil) and (FEditorList.count > 0);
end;

function TFhirEvidenceReport.GetReviewerList : TFhirContactDetailList;
begin
  if FReviewerList = nil then
    FReviewerList := TFhirContactDetailList.Create;
  result := FReviewerList;
end;

function TFhirEvidenceReport.GetHasReviewerList : boolean;
begin
  result := (FReviewerList <> nil) and (FReviewerList.count > 0);
end;

function TFhirEvidenceReport.GetEndorserList : TFhirContactDetailList;
begin
  if FEndorserList = nil then
    FEndorserList := TFhirContactDetailList.Create;
  result := FEndorserList;
end;

function TFhirEvidenceReport.GetHasEndorserList : boolean;
begin
  result := (FEndorserList <> nil) and (FEndorserList.count > 0);
end;

function TFhirEvidenceReport.GetRelatesToList : TFhirEvidenceReportRelatesToList;
begin
  if FRelatesToList = nil then
    FRelatesToList := TFhirEvidenceReportRelatesToList.Create;
  result := FRelatesToList;
end;

function TFhirEvidenceReport.GetHasRelatesToList : boolean;
begin
  result := (FRelatesToList <> nil) and (FRelatesToList.count > 0);
end;

function TFhirEvidenceReport.GetSectionList : TFhirEvidenceReportSectionList;
begin
  if FSectionList = nil then
    FSectionList := TFhirEvidenceReportSectionList.Create;
  result := FSectionList;
end;

function TFhirEvidenceReport.GetHasSectionList : boolean;
begin
  result := (FSectionList <> nil) and (FSectionList.count > 0);
end;

{ TFhirEvidenceReportListEnumerator }

constructor TFhirEvidenceReportListEnumerator.Create(list : TFhirEvidenceReportList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceReportListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceReportListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceReportListEnumerator.GetCurrent : TFhirEvidenceReport;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceReportListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceReportList }

function TFhirEvidenceReportList.AddItem(value: TFhirEvidenceReport): TFhirEvidenceReport;
begin
  assert(value.ClassName = 'TFhirEvidenceReport', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceReport');
  add(value);
  result := value;
end;

function TFhirEvidenceReportList.Append: TFhirEvidenceReport;
begin
  result := TFhirEvidenceReport.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceReportList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceReportList.GetEnumerator : TFhirEvidenceReportListEnumerator;
begin
  result := TFhirEvidenceReportListEnumerator.Create(self.link);
end;

function TFhirEvidenceReportList.Clone: TFhirEvidenceReportList;
begin
  result := TFhirEvidenceReportList(inherited Clone);
end;

function TFhirEvidenceReportList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceReportList.GetItemN(index: Integer): TFhirEvidenceReport;
begin
  result := TFhirEvidenceReport(ObjectByIndex[index]);
end;

function TFhirEvidenceReportList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceReport;
end;
function TFhirEvidenceReportList.IndexOf(value: TFhirEvidenceReport): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceReportList.Insert(index: Integer): TFhirEvidenceReport;
begin
  result := TFhirEvidenceReport.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceReportList.InsertItem(index: Integer; value: TFhirEvidenceReport);
begin
  assert(value is TFhirEvidenceReport);
  Inherited Insert(index, value);
end;

function TFhirEvidenceReportList.Item(index: Integer): TFhirEvidenceReport;
begin
  result := TFhirEvidenceReport(ObjectByIndex[index]);
end;

function TFhirEvidenceReportList.Link: TFhirEvidenceReportList;
begin
  result := TFhirEvidenceReportList(inherited Link);
end;

procedure TFhirEvidenceReportList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceReportList.SetItemByIndex(index: Integer; value: TFhirEvidenceReport);
begin
  assert(value is TFhirEvidenceReport);
  FhirEvidenceReports[index] := value;
end;

procedure TFhirEvidenceReportList.SetItemN(index: Integer; value: TFhirEvidenceReport);
begin
  assert(value is TFhirEvidenceReport);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_EVIDENCEREPORT}
{$IFDEF FHIR_EVIDENCEVARIABLE}
{ TFhirEvidenceVariableCharacteristic }

constructor TFhirEvidenceVariableCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirEvidenceVariableCharacteristic.Destroy;
begin
  FLinkId.free;
  FDescription.free;
  FNoteList.Free;
  FExclude.free;
  FDefinitionReference.free;
  FDefinitionCanonical.free;
  FDefinitionCodeableConcept.free;
  FDefinitionExpression.free;
  FDefinitionId.free;
  FDefinitionByTypeAndValue.free;
  FDefinitionByCombination.free;
  FTimeFromEventList.Free;
  inherited;
end;

procedure TFhirEvidenceVariableCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  linkIdElement := TFhirEvidenceVariableCharacteristic(oSource).linkIdElement.Clone;
  descriptionElement := TFhirEvidenceVariableCharacteristic(oSource).descriptionElement.Clone;
  if (TFhirEvidenceVariableCharacteristic(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEvidenceVariableCharacteristic(oSource).FNoteList);
  end;
  excludeElement := TFhirEvidenceVariableCharacteristic(oSource).excludeElement.Clone;
  definitionReference := TFhirEvidenceVariableCharacteristic(oSource).definitionReference.Clone;
  definitionCanonicalElement := TFhirEvidenceVariableCharacteristic(oSource).definitionCanonicalElement.Clone;
  definitionCodeableConcept := TFhirEvidenceVariableCharacteristic(oSource).definitionCodeableConcept.Clone;
  definitionExpression := TFhirEvidenceVariableCharacteristic(oSource).definitionExpression.Clone;
  definitionIdElement := TFhirEvidenceVariableCharacteristic(oSource).definitionIdElement.Clone;
  definitionByTypeAndValue := TFhirEvidenceVariableCharacteristic(oSource).definitionByTypeAndValue.Clone;
  definitionByCombination := TFhirEvidenceVariableCharacteristic(oSource).definitionByCombination.Clone;
  if (TFhirEvidenceVariableCharacteristic(oSource).FTimeFromEventList = nil) then
  begin
    FTimeFromEventList.free;
    FTimeFromEventList := nil;
  end
  else
  begin
    if FTimeFromEventList = nil then
      FTimeFromEventList := TFhirEvidenceVariableCharacteristicTimeFromEventList.Create;
    FTimeFromEventList.Assign(TFhirEvidenceVariableCharacteristic(oSource).FTimeFromEventList);
  end;
end;

procedure TFhirEvidenceVariableCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'linkId') Then
     list.add(self.link, 'linkId', FLinkId.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'exclude') Then
     list.add(self.link, 'exclude', FExclude.Link);
  if (child_name = 'definitionReference') Then
     list.add(self.link, 'definitionReference', FDefinitionReference.Link);
  if (child_name = 'definitionCanonical') Then
     list.add(self.link, 'definitionCanonical', FDefinitionCanonical.Link);
  if (child_name = 'definitionCodeableConcept') Then
     list.add(self.link, 'definitionCodeableConcept', FDefinitionCodeableConcept.Link);
  if (child_name = 'definitionExpression') Then
     list.add(self.link, 'definitionExpression', FDefinitionExpression.Link);
  if (child_name = 'definitionId') Then
     list.add(self.link, 'definitionId', FDefinitionId.Link);
  if (child_name = 'definitionByTypeAndValue') Then
     list.add(self.link, 'definitionByTypeAndValue', FDefinitionByTypeAndValue.Link);
  if (child_name = 'definitionByCombination') Then
     list.add(self.link, 'definitionByCombination', FDefinitionByCombination.Link);
  if (child_name = 'timeFromEvent') Then
    list.addAll(self, 'timeFromEvent', FTimeFromEventList);
end;

procedure TFhirEvidenceVariableCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'linkId', 'id', false, TFhirId, FLinkId.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'exclude', 'boolean', false, TFhirBoolean, FExclude.Link));
  oList.add(TFHIRProperty.create(self, 'definitionReference', 'Reference', false, TFhirReference, FDefinitionReference.Link));
  oList.add(TFHIRProperty.create(self, 'definitionCanonical', 'canonical', false, TFhirCanonical, FDefinitionCanonical.Link));
  oList.add(TFHIRProperty.create(self, 'definitionCodeableConcept', 'CodeableConcept', false, TFhirCodeableConcept, FDefinitionCodeableConcept.Link));
  oList.add(TFHIRProperty.create(self, 'definitionExpression', 'Expression', false, TFhirExpression, FDefinitionExpression.Link));
  oList.add(TFHIRProperty.create(self, 'definitionId', 'id', false, TFhirId, FDefinitionId.Link));
  oList.add(TFHIRProperty.create(self, 'definitionByTypeAndValue', 'BackboneElement', false, TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue, FDefinitionByTypeAndValue.Link));
  oList.add(TFHIRProperty.create(self, 'definitionByCombination', 'BackboneElement', false, TFhirEvidenceVariableCharacteristicDefinitionByCombination, FDefinitionByCombination.Link));
  oList.add(TFHIRProperty.create(self, 'timeFromEvent', 'BackboneElement', true, TFhirEvidenceVariableCharacteristicTimeFromEvent, FTimeFromEventList.Link));
end;

function TFhirEvidenceVariableCharacteristic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'linkId') then
  begin
    LinkIdElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'exclude') then
  begin
    ExcludeElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'definitionReference') then
  begin
    DefinitionReference := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'definitionCanonical') then
  begin
    DefinitionCanonicalElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'definitionCodeableConcept') then
  begin
    DefinitionCodeableConcept := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'definitionExpression') then
  begin
    DefinitionExpression := propValue as TFhirExpression;
    result := propValue;
  end
  else if (propName = 'definitionId') then
  begin
    DefinitionIdElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'definitionByTypeAndValue') then
  begin
    DefinitionByTypeAndValue := propValue as TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue;
    result := propValue;
  end
  else if (propName = 'definitionByCombination') then
  begin
    DefinitionByCombination := propValue as TFhirEvidenceVariableCharacteristicDefinitionByCombination;
    result := propValue;
  end
  else if (propName = 'timeFromEvent') then
  begin
    TimeFromEventList.add(propValue as TFhirEvidenceVariableCharacteristicTimeFromEvent);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceVariableCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'timeFromEvent') then TimeFromEventList.insertItem(index, propValue as TFhirEvidenceVariableCharacteristicTimeFromEvent)
  else inherited;
end;

function TFhirEvidenceVariableCharacteristic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'linkId') then result := TFhirId.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'exclude') then result := TFhirBoolean.create()
  else if (propName = 'definitionReference') then result := TFhirReference.create()
  else if (propName = 'definitionCanonical') then result := TFhirCanonical.create()
  else if (propName = 'definitionCodeableConcept') then result := TFhirCodeableConcept.create()
  else if (propName = 'definitionExpression') then result := TFhirExpression.create()
  else if (propName = 'definitionId') then result := TFhirId.create()
  else if (propName = 'definitionByTypeAndValue') then result := TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.create()
  else if (propName = 'definitionByCombination') then result := TFhirEvidenceVariableCharacteristicDefinitionByCombination.create()
  else if (propName = 'timeFromEvent') then result := TimeFromEventList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceVariableCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'linkId') then result := 'id'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'exclude') then result := 'boolean'
  else if (propName = 'definitionReference') then result := 'Reference'
  else if (propName = 'definitionCanonical') then result := 'canonical'
  else if (propName = 'definitionCodeableConcept') then result := 'CodeableConcept'
  else if (propName = 'definitionExpression') then result := 'Expression'
  else if (propName = 'definitionId') then result := 'id'
  else if (propName = 'definitionByTypeAndValue') then result := 'BackboneElement'
  else if (propName = 'definitionByCombination') then result := 'BackboneElement'
  else if (propName = 'timeFromEvent') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceVariableCharacteristic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'exclude') then ExcludeElement := nil
  else if (propName = 'definitionReference') then DefinitionReferenceElement := nil
  else if (propName = 'definitionCanonical') then DefinitionCanonicalElement := nil
  else if (propName = 'definitionCodeableConcept') then DefinitionCodeableConceptElement := nil
  else if (propName = 'definitionExpression') then DefinitionExpressionElement := nil
  else if (propName = 'definitionId') then DefinitionIdElement := nil
  else if (propName = 'definitionByTypeAndValue') then DefinitionByTypeAndValueElement := nil
  else if (propName = 'definitionByCombination') then DefinitionByCombinationElement := nil
  else if (propName = 'timeFromEvent') then deletePropertyValue('timeFromEvent', TimeFromEventList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceVariableCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := asId(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'exclude') then ExcludeElement := asBoolean(new)
  else if (propName = 'definitionReference') then DefinitionReferenceElement := new as TFhirReference
  else if (propName = 'definitionCanonical') then DefinitionCanonicalElement := asCanonical(new)
  else if (propName = 'definitionCodeableConcept') then DefinitionCodeableConceptElement := new as TFhirCodeableConcept
  else if (propName = 'definitionExpression') then DefinitionExpressionElement := new as TFhirExpression
  else if (propName = 'definitionId') then DefinitionIdElement := asId(new)
  else if (propName = 'definitionByTypeAndValue') then DefinitionByTypeAndValueElement := new as TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue
  else if (propName = 'definitionByCombination') then DefinitionByCombinationElement := new as TFhirEvidenceVariableCharacteristicDefinitionByCombination
  else if (propName = 'timeFromEvent') then replacePropertyValue('timeFromEvent', TimeFromEventList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceVariableCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'timeFromEvent') then TimeFromEventList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceVariableCharacteristic.fhirType : string;
begin
  result := 'EvidenceVariable.characteristic';
end;

function TFhirEvidenceVariableCharacteristic.Link : TFhirEvidenceVariableCharacteristic;
begin
  result := TFhirEvidenceVariableCharacteristic(inherited Link);
end;

function TFhirEvidenceVariableCharacteristic.Clone : TFhirEvidenceVariableCharacteristic;
begin
  result := TFhirEvidenceVariableCharacteristic(inherited Clone);
end;

function TFhirEvidenceVariableCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceVariableCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceVariableCharacteristic)) then
    result := false
  else
  begin
    o := TFhirEvidenceVariableCharacteristic(other);
    result := compareDeep(linkIdElement, o.linkIdElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(excludeElement, o.excludeElement, true) and 
      compareDeep(definitionReferenceElement, o.definitionReferenceElement, true) and 
      compareDeep(definitionCanonicalElement, o.definitionCanonicalElement, true) and 
      compareDeep(definitionCodeableConceptElement, o.definitionCodeableConceptElement, true) and 
      compareDeep(definitionExpressionElement, o.definitionExpressionElement, true) and 
      compareDeep(definitionIdElement, o.definitionIdElement, true) and compareDeep(definitionByTypeAndValueElement, o.definitionByTypeAndValueElement, true) and 
      compareDeep(definitionByCombinationElement, o.definitionByCombinationElement, true) and 
      compareDeep(timeFromEventList, o.timeFromEventList, true);
  end;
end;

function TFhirEvidenceVariableCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLinkId) and isEmptyProp(FDescription) and isEmptyProp(FnoteList) and isEmptyProp(FExclude) and isEmptyProp(FDefinitionReference) and isEmptyProp(FDefinitionCanonical) and isEmptyProp(FDefinitionCodeableConcept) and isEmptyProp(FDefinitionExpression) and isEmptyProp(FDefinitionId) and isEmptyProp(FDefinitionByTypeAndValue) and isEmptyProp(FDefinitionByCombination) and isEmptyProp(FtimeFromEventList);
end;

procedure TFhirEvidenceVariableCharacteristic.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('linkId');
  fields.add('description');
  fields.add('note');
  fields.add('exclude');
  fields.add('definitionReference');
  fields.add('definitionCanonical');
  fields.add('definitionCodeableConcept');
  fields.add('definitionExpression');
  fields.add('definitionId');
  fields.add('definitionByTypeAndValue');
  fields.add('definitionByCombination');
  fields.add('timeFromEvent');
end;

function TFhirEvidenceVariableCharacteristic.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FTimeFromEventList.sizeInBytes(magic));
end;

procedure TFhirEvidenceVariableCharacteristic.SetLinkId(value : TFhirId);
begin
  FLinkId.free;
  FLinkId := value;
end;

function TFhirEvidenceVariableCharacteristic.GetLinkIdST : String;
begin
  if FLinkId = nil then
    result := ''
  else
    result := FLinkId.value;
end;

procedure TFhirEvidenceVariableCharacteristic.SetLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FLinkId = nil then
      FLinkId := TFhirId.create;
    FLinkId.value := value
  end
  else if FLinkId <> nil then
    FLinkId.value := '';
end;

procedure TFhirEvidenceVariableCharacteristic.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirEvidenceVariableCharacteristic.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirEvidenceVariableCharacteristic.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirEvidenceVariableCharacteristic.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirEvidenceVariableCharacteristic.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirEvidenceVariableCharacteristic.SetExclude(value : TFhirBoolean);
begin
  FExclude.free;
  FExclude := value;
end;

function TFhirEvidenceVariableCharacteristic.GetExcludeST : Boolean;
begin
  if FExclude = nil then
    result := false
  else
    result := FExclude.value;
end;

procedure TFhirEvidenceVariableCharacteristic.SetExcludeST(value : Boolean);
begin
  if FExclude = nil then
    FExclude := TFhirBoolean.create;
  FExclude.value := value
end;

procedure TFhirEvidenceVariableCharacteristic.SetDefinitionReference(value : TFhirReference);
begin
  FDefinitionReference.free;
  FDefinitionReference := value;
end;

procedure TFhirEvidenceVariableCharacteristic.SetDefinitionCanonical(value : TFhirCanonical);
begin
  FDefinitionCanonical.free;
  FDefinitionCanonical := value;
end;

function TFhirEvidenceVariableCharacteristic.GetDefinitionCanonicalST : String;
begin
  if FDefinitionCanonical = nil then
    result := ''
  else
    result := FDefinitionCanonical.value;
end;

procedure TFhirEvidenceVariableCharacteristic.SetDefinitionCanonicalST(value : String);
begin
  if value <> '' then
  begin
    if FDefinitionCanonical = nil then
      FDefinitionCanonical := TFhirCanonical.create;
    FDefinitionCanonical.value := value
  end
  else if FDefinitionCanonical <> nil then
    FDefinitionCanonical.value := '';
end;

procedure TFhirEvidenceVariableCharacteristic.SetDefinitionCodeableConcept(value : TFhirCodeableConcept);
begin
  FDefinitionCodeableConcept.free;
  FDefinitionCodeableConcept := value;
end;

procedure TFhirEvidenceVariableCharacteristic.SetDefinitionExpression(value : TFhirExpression);
begin
  FDefinitionExpression.free;
  FDefinitionExpression := value;
end;

procedure TFhirEvidenceVariableCharacteristic.SetDefinitionId(value : TFhirId);
begin
  FDefinitionId.free;
  FDefinitionId := value;
end;

function TFhirEvidenceVariableCharacteristic.GetDefinitionIdST : String;
begin
  if FDefinitionId = nil then
    result := ''
  else
    result := FDefinitionId.value;
end;

procedure TFhirEvidenceVariableCharacteristic.SetDefinitionIdST(value : String);
begin
  if value <> '' then
  begin
    if FDefinitionId = nil then
      FDefinitionId := TFhirId.create;
    FDefinitionId.value := value
  end
  else if FDefinitionId <> nil then
    FDefinitionId.value := '';
end;

procedure TFhirEvidenceVariableCharacteristic.SetDefinitionByTypeAndValue(value : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue);
begin
  FDefinitionByTypeAndValue.free;
  FDefinitionByTypeAndValue := value;
end;

procedure TFhirEvidenceVariableCharacteristic.SetDefinitionByCombination(value : TFhirEvidenceVariableCharacteristicDefinitionByCombination);
begin
  FDefinitionByCombination.free;
  FDefinitionByCombination := value;
end;

function TFhirEvidenceVariableCharacteristic.GetTimeFromEventList : TFhirEvidenceVariableCharacteristicTimeFromEventList;
begin
  if FTimeFromEventList = nil then
    FTimeFromEventList := TFhirEvidenceVariableCharacteristicTimeFromEventList.Create;
  result := FTimeFromEventList;
end;

function TFhirEvidenceVariableCharacteristic.GetHasTimeFromEventList : boolean;
begin
  result := (FTimeFromEventList <> nil) and (FTimeFromEventList.count > 0);
end;

{ TFhirEvidenceVariableCharacteristicListEnumerator }

constructor TFhirEvidenceVariableCharacteristicListEnumerator.Create(list : TFhirEvidenceVariableCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceVariableCharacteristicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceVariableCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceVariableCharacteristicListEnumerator.GetCurrent : TFhirEvidenceVariableCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceVariableCharacteristicListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceVariableCharacteristicList }

function TFhirEvidenceVariableCharacteristicList.AddItem(value: TFhirEvidenceVariableCharacteristic): TFhirEvidenceVariableCharacteristic;
begin
  assert(value.ClassName = 'TFhirEvidenceVariableCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceVariableCharacteristic');
  add(value);
  result := value;
end;

function TFhirEvidenceVariableCharacteristicList.Append: TFhirEvidenceVariableCharacteristic;
begin
  result := TFhirEvidenceVariableCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceVariableCharacteristicList.GetEnumerator : TFhirEvidenceVariableCharacteristicListEnumerator;
begin
  result := TFhirEvidenceVariableCharacteristicListEnumerator.Create(self.link);
end;

function TFhirEvidenceVariableCharacteristicList.Clone: TFhirEvidenceVariableCharacteristicList;
begin
  result := TFhirEvidenceVariableCharacteristicList(inherited Clone);
end;

function TFhirEvidenceVariableCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceVariableCharacteristicList.GetItemN(index: Integer): TFhirEvidenceVariableCharacteristic;
begin
  result := TFhirEvidenceVariableCharacteristic(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceVariableCharacteristic;
end;
function TFhirEvidenceVariableCharacteristicList.IndexOf(value: TFhirEvidenceVariableCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceVariableCharacteristicList.Insert(index: Integer): TFhirEvidenceVariableCharacteristic;
begin
  result := TFhirEvidenceVariableCharacteristic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableCharacteristicList.InsertItem(index: Integer; value: TFhirEvidenceVariableCharacteristic);
begin
  assert(value is TFhirEvidenceVariableCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirEvidenceVariableCharacteristicList.Item(index: Integer): TFhirEvidenceVariableCharacteristic;
begin
  result := TFhirEvidenceVariableCharacteristic(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableCharacteristicList.Link: TFhirEvidenceVariableCharacteristicList;
begin
  result := TFhirEvidenceVariableCharacteristicList(inherited Link);
end;

procedure TFhirEvidenceVariableCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceVariableCharacteristicList.SetItemByIndex(index: Integer; value: TFhirEvidenceVariableCharacteristic);
begin
  assert(value is TFhirEvidenceVariableCharacteristic);
  FhirEvidenceVariableCharacteristics[index] := value;
end;

procedure TFhirEvidenceVariableCharacteristicList.SetItemN(index: Integer; value: TFhirEvidenceVariableCharacteristic);
begin
  assert(value is TFhirEvidenceVariableCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue }

constructor TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.Create;
begin
  inherited;
end;

destructor TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.Destroy;
begin
  FType_.free;
  FMethodList.Free;
  FDevice.free;
  FValue.free;
  FOffset.free;
  inherited;
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue(oSource).type_.Clone;
  if (TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue(oSource).FMethodList = nil) then
  begin
    FMethodList.free;
    FMethodList := nil;
  end
  else
  begin
    if FMethodList = nil then
      FMethodList := TFhirCodeableConceptList.Create;
    FMethodList.Assign(TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue(oSource).FMethodList);
  end;
  device := TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue(oSource).device.Clone;
  value := TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue(oSource).value.Clone;
  offset := TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue(oSource).offset.Clone;
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'method') Then
    list.addAll(self, 'method', FMethodList);
  if (child_name = 'device') Then
     list.add(self.link, 'device', FDevice.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'offset') Then
     list.add(self.link, 'offset', FOffset.Link);
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', true, TFhirCodeableConcept, FMethodList.Link));
  oList.add(TFHIRProperty.create(self, 'device', 'Reference', false, TFhirReference, FDevice.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|boolean|Quantity|Range|Reference|id', false, TFhirDataType, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'offset', 'CodeableConcept', false, TFhirCodeableConcept, FOffset.Link));
end;

function TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    MethodList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    Device := propValue as TFhirReference;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference', 'Id'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'offset') then
  begin
    Offset := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'method') then MethodList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'method') then result := MethodList.new()
  else if (propName = 'device') then result := TFhirReference.create()
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference', 'Id'])) then raise EFHIRException.create('Cannot make property Value')
  else if (propName = 'offset') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'value[x]') then result := 'CodeableConcept|boolean|Quantity|Range|Reference|id'
  else if (propName = 'offset') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'method') then deletePropertyValue('method', MethodList, value)
  else if (propName = 'device') then DeviceElement := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference', 'Id'])) then ValueElement := nil
  else if (propName = 'offset') then OffsetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'method') then replacePropertyValue('method', MethodList, existing, new)
  else if (propName = 'device') then DeviceElement := new as TFhirReference
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference', 'Id'])) then ValueElement := new as TFhirDataType
  else if (propName = 'offset') then OffsetElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'method') then MethodList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.fhirType : string;
begin
  result := 'EvidenceVariable.characteristic.definitionByTypeAndValue';
end;

function TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.Link : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue;
begin
  result := TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue(inherited Link);
end;

function TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.Clone : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue;
begin
  result := TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue(inherited Clone);
end;

function TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue)) then
    result := false
  else
  begin
    o := TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(methodList, o.methodList, true) and 
      compareDeep(deviceElement, o.deviceElement, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(offsetElement, o.offsetElement, true);
  end;
end;

function TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FmethodList) and isEmptyProp(FDevice) and isEmptyProp(FValue) and isEmptyProp(FOffset);
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('method');
  fields.add('device');
  fields.add('value[x]');
  fields.add('offset');
end;

function TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FMethodList.sizeInBytes(magic));
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.GetMethodList : TFhirCodeableConceptList;
begin
  if FMethodList = nil then
    FMethodList := TFhirCodeableConceptList.Create;
  result := FMethodList;
end;

function TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.GetHasMethodList : boolean;
begin
  result := (FMethodList <> nil) and (FMethodList.count > 0);
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.SetDevice(value : TFhirReference);
begin
  FDevice.free;
  FDevice := value;
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.SetOffset(value : TFhirCodeableConcept);
begin
  FOffset.free;
  FOffset := value;
end;

{ TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueListEnumerator }

constructor TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueListEnumerator.Create(list : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueListEnumerator.GetCurrent : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList }

function TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList.AddItem(value: TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue): TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue;
begin
  assert(value.ClassName = 'TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue');
  add(value);
  result := value;
end;

function TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList.Append: TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue;
begin
  result := TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList.GetEnumerator : TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueListEnumerator;
begin
  result := TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueListEnumerator.Create(self.link);
end;

function TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList.Clone: TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList;
begin
  result := TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList(inherited Clone);
end;

function TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList.GetItemN(index: Integer): TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue;
begin
  result := TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue;
end;
function TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList.IndexOf(value: TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList.Insert(index: Integer): TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue;
begin
  result := TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList.InsertItem(index: Integer; value: TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue);
begin
  assert(value is TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue);
  Inherited Insert(index, value);
end;

function TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList.Item(index: Integer): TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue;
begin
  result := TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList.Link: TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList;
begin
  result := TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList(inherited Link);
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList.SetItemByIndex(index: Integer; value: TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue);
begin
  assert(value is TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue);
  FhirEvidenceVariableCharacteristicDefinitionByTypeAndValues[index] := value;
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValueList.SetItemN(index: Integer; value: TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue);
begin
  assert(value is TFhirEvidenceVariableCharacteristicDefinitionByTypeAndValue);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceVariableCharacteristicDefinitionByCombination }

constructor TFhirEvidenceVariableCharacteristicDefinitionByCombination.Create;
begin
  inherited;
end;

destructor TFhirEvidenceVariableCharacteristicDefinitionByCombination.Destroy;
begin
  FCode.free;
  FThreshold.free;
  FCharacteristicList.Free;
  inherited;
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByCombination.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirEvidenceVariableCharacteristicDefinitionByCombination(oSource).codeElement.Clone;
  thresholdElement := TFhirEvidenceVariableCharacteristicDefinitionByCombination(oSource).thresholdElement.Clone;
  if (TFhirEvidenceVariableCharacteristicDefinitionByCombination(oSource).FCharacteristicList = nil) then
  begin
    FCharacteristicList.free;
    FCharacteristicList := nil;
  end
  else
  begin
    if FCharacteristicList = nil then
      FCharacteristicList := TFhirEvidenceVariableCharacteristicList.Create;
    FCharacteristicList.Assign(TFhirEvidenceVariableCharacteristicDefinitionByCombination(oSource).FCharacteristicList);
  end;
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByCombination.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'threshold') Then
     list.add(self.link, 'threshold', FThreshold.Link);
  if (child_name = 'characteristic') Then
    list.addAll(self, 'characteristic', FCharacteristicList);
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByCombination.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirEnum, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'threshold', 'positiveInt', false, TFhirPositiveInt, FThreshold.Link));
  oList.add(TFHIRProperty.create(self, 'characteristic', '', true, TFhirEvidenceVariableCharacteristic, FCharacteristicList.Link));
end;

function TFhirEvidenceVariableCharacteristicDefinitionByCombination.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirCharacteristicCombinationEnum, CODES_TFhirCharacteristicCombinationEnum, propValue);
    result := propValue;
  end
  else if (propName = 'threshold') then
  begin
    ThresholdElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'characteristic') then
  begin
    CharacteristicList.add(propValue as TFhirEvidenceVariableCharacteristic);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByCombination.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'characteristic') then CharacteristicList.insertItem(index, propValue as TFhirEvidenceVariableCharacteristic)
  else inherited;
end;

function TFhirEvidenceVariableCharacteristicDefinitionByCombination.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirEnum.create(SYSTEMS_TFhirCharacteristicCombinationEnum[CharacteristicCombinationNull], CODES_TFhirCharacteristicCombinationEnum[CharacteristicCombinationNull]) 
  else if (propName = 'threshold') then result := TFhirPositiveInt.create()
  else if (propName = 'characteristic') then result := CharacteristicList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceVariableCharacteristicDefinitionByCombination.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'threshold') then result := 'positiveInt'
  else if (propName = 'characteristic') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByCombination.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'threshold') then ThresholdElement := nil
  else if (propName = 'characteristic') then deletePropertyValue('characteristic', CharacteristicList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByCombination.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirCharacteristicCombinationEnum, CODES_TFhirCharacteristicCombinationEnum, new)
  else if (propName = 'threshold') then ThresholdElement := asPositiveInt(new)
  else if (propName = 'characteristic') then replacePropertyValue('characteristic', CharacteristicList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByCombination.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'characteristic') then CharacteristicList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceVariableCharacteristicDefinitionByCombination.fhirType : string;
begin
  result := 'EvidenceVariable.characteristic.definitionByCombination';
end;

function TFhirEvidenceVariableCharacteristicDefinitionByCombination.Link : TFhirEvidenceVariableCharacteristicDefinitionByCombination;
begin
  result := TFhirEvidenceVariableCharacteristicDefinitionByCombination(inherited Link);
end;

function TFhirEvidenceVariableCharacteristicDefinitionByCombination.Clone : TFhirEvidenceVariableCharacteristicDefinitionByCombination;
begin
  result := TFhirEvidenceVariableCharacteristicDefinitionByCombination(inherited Clone);
end;

function TFhirEvidenceVariableCharacteristicDefinitionByCombination.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceVariableCharacteristicDefinitionByCombination;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceVariableCharacteristicDefinitionByCombination)) then
    result := false
  else
  begin
    o := TFhirEvidenceVariableCharacteristicDefinitionByCombination(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(thresholdElement, o.thresholdElement, true) and 
      compareDeep(characteristicList, o.characteristicList, true);
  end;
end;

function TFhirEvidenceVariableCharacteristicDefinitionByCombination.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FThreshold) and isEmptyProp(FcharacteristicList);
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByCombination.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('threshold');
  fields.add('characteristic');
end;

function TFhirEvidenceVariableCharacteristicDefinitionByCombination.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCharacteristicList.sizeInBytes(magic));
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByCombination.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

function TFhirEvidenceVariableCharacteristicDefinitionByCombination.GetCodeST : TFhirCharacteristicCombinationEnum;
begin
  if FCode = nil then
    result := TFhirCharacteristicCombinationEnum(0)
  else
    result := TFhirCharacteristicCombinationEnum(StringArrayIndexOfSensitive(CODES_TFhirCharacteristicCombinationEnum, FCode.value));
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByCombination.SetCodeST(value : TFhirCharacteristicCombinationEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirCharacteristicCombinationEnum[value], CODES_TFhirCharacteristicCombinationEnum[value]);
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByCombination.SetThreshold(value : TFhirPositiveInt);
begin
  FThreshold.free;
  FThreshold := value;
end;

function TFhirEvidenceVariableCharacteristicDefinitionByCombination.GetThresholdST : String;
begin
  if FThreshold = nil then
    result := ''
  else
    result := FThreshold.value;
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByCombination.SetThresholdST(value : String);
begin
  if value <> '' then
  begin
    if FThreshold = nil then
      FThreshold := TFhirPositiveInt.create;
    FThreshold.value := value
  end
  else if FThreshold <> nil then
    FThreshold.value := '';
end;

function TFhirEvidenceVariableCharacteristicDefinitionByCombination.GetCharacteristicList : TFhirEvidenceVariableCharacteristicList;
begin
  if FCharacteristicList = nil then
    FCharacteristicList := TFhirEvidenceVariableCharacteristicList.Create;
  result := FCharacteristicList;
end;

function TFhirEvidenceVariableCharacteristicDefinitionByCombination.GetHasCharacteristicList : boolean;
begin
  result := (FCharacteristicList <> nil) and (FCharacteristicList.count > 0);
end;

{ TFhirEvidenceVariableCharacteristicDefinitionByCombinationListEnumerator }

constructor TFhirEvidenceVariableCharacteristicDefinitionByCombinationListEnumerator.Create(list : TFhirEvidenceVariableCharacteristicDefinitionByCombinationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceVariableCharacteristicDefinitionByCombinationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceVariableCharacteristicDefinitionByCombinationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceVariableCharacteristicDefinitionByCombinationListEnumerator.GetCurrent : TFhirEvidenceVariableCharacteristicDefinitionByCombination;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceVariableCharacteristicDefinitionByCombinationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceVariableCharacteristicDefinitionByCombinationList }

function TFhirEvidenceVariableCharacteristicDefinitionByCombinationList.AddItem(value: TFhirEvidenceVariableCharacteristicDefinitionByCombination): TFhirEvidenceVariableCharacteristicDefinitionByCombination;
begin
  assert(value.ClassName = 'TFhirEvidenceVariableCharacteristicDefinitionByCombination', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceVariableCharacteristicDefinitionByCombination');
  add(value);
  result := value;
end;

function TFhirEvidenceVariableCharacteristicDefinitionByCombinationList.Append: TFhirEvidenceVariableCharacteristicDefinitionByCombination;
begin
  result := TFhirEvidenceVariableCharacteristicDefinitionByCombination.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByCombinationList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceVariableCharacteristicDefinitionByCombinationList.GetEnumerator : TFhirEvidenceVariableCharacteristicDefinitionByCombinationListEnumerator;
begin
  result := TFhirEvidenceVariableCharacteristicDefinitionByCombinationListEnumerator.Create(self.link);
end;

function TFhirEvidenceVariableCharacteristicDefinitionByCombinationList.Clone: TFhirEvidenceVariableCharacteristicDefinitionByCombinationList;
begin
  result := TFhirEvidenceVariableCharacteristicDefinitionByCombinationList(inherited Clone);
end;

function TFhirEvidenceVariableCharacteristicDefinitionByCombinationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceVariableCharacteristicDefinitionByCombinationList.GetItemN(index: Integer): TFhirEvidenceVariableCharacteristicDefinitionByCombination;
begin
  result := TFhirEvidenceVariableCharacteristicDefinitionByCombination(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableCharacteristicDefinitionByCombinationList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceVariableCharacteristicDefinitionByCombination;
end;
function TFhirEvidenceVariableCharacteristicDefinitionByCombinationList.IndexOf(value: TFhirEvidenceVariableCharacteristicDefinitionByCombination): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceVariableCharacteristicDefinitionByCombinationList.Insert(index: Integer): TFhirEvidenceVariableCharacteristicDefinitionByCombination;
begin
  result := TFhirEvidenceVariableCharacteristicDefinitionByCombination.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByCombinationList.InsertItem(index: Integer; value: TFhirEvidenceVariableCharacteristicDefinitionByCombination);
begin
  assert(value is TFhirEvidenceVariableCharacteristicDefinitionByCombination);
  Inherited Insert(index, value);
end;

function TFhirEvidenceVariableCharacteristicDefinitionByCombinationList.Item(index: Integer): TFhirEvidenceVariableCharacteristicDefinitionByCombination;
begin
  result := TFhirEvidenceVariableCharacteristicDefinitionByCombination(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableCharacteristicDefinitionByCombinationList.Link: TFhirEvidenceVariableCharacteristicDefinitionByCombinationList;
begin
  result := TFhirEvidenceVariableCharacteristicDefinitionByCombinationList(inherited Link);
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByCombinationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByCombinationList.SetItemByIndex(index: Integer; value: TFhirEvidenceVariableCharacteristicDefinitionByCombination);
begin
  assert(value is TFhirEvidenceVariableCharacteristicDefinitionByCombination);
  FhirEvidenceVariableCharacteristicDefinitionByCombinations[index] := value;
end;

procedure TFhirEvidenceVariableCharacteristicDefinitionByCombinationList.SetItemN(index: Integer; value: TFhirEvidenceVariableCharacteristicDefinitionByCombination);
begin
  assert(value is TFhirEvidenceVariableCharacteristicDefinitionByCombination);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceVariableCharacteristicTimeFromEvent }

constructor TFhirEvidenceVariableCharacteristicTimeFromEvent.Create;
begin
  inherited;
end;

destructor TFhirEvidenceVariableCharacteristicTimeFromEvent.Destroy;
begin
  FDescription.free;
  FNoteList.Free;
  FEvent.free;
  FQuantity.free;
  FRange.free;
  inherited;
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromEvent.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirEvidenceVariableCharacteristicTimeFromEvent(oSource).descriptionElement.Clone;
  if (TFhirEvidenceVariableCharacteristicTimeFromEvent(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEvidenceVariableCharacteristicTimeFromEvent(oSource).FNoteList);
  end;
  event := TFhirEvidenceVariableCharacteristicTimeFromEvent(oSource).event.Clone;
  quantity := TFhirEvidenceVariableCharacteristicTimeFromEvent(oSource).quantity.Clone;
  range := TFhirEvidenceVariableCharacteristicTimeFromEvent(oSource).range.Clone;
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromEvent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'event[x]') or (child_name = 'event') Then
     list.add(self.link, 'event[x]', FEvent.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'range') Then
     list.add(self.link, 'range', FRange.Link);
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'event[x]', 'CodeableConcept|Reference|dateTime|id', false, TFhirDataType, FEvent.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'range', 'Range', false, TFhirRange, FRange.Link));
end;

function TFhirEvidenceVariableCharacteristicTimeFromEvent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (isMatchingName(propName, 'event', ['CodeableConcept', 'Reference', 'DateTime', 'Id'])) then
  begin
    Event := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'range') then
  begin
    Range := propValue as TFhirRange;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromEvent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirEvidenceVariableCharacteristicTimeFromEvent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'note') then result := NoteList.new()
  else if (isMatchingName(propName, 'event', ['CodeableConcept', 'Reference', 'DateTime', 'Id'])) then raise EFHIRException.create('Cannot make property Event')
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'range') then result := TFhirRange.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceVariableCharacteristicTimeFromEvent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'event[x]') then result := 'CodeableConcept|Reference|dateTime|id'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'range') then result := 'Range'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromEvent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (isMatchingName(propName, 'event', ['CodeableConcept', 'Reference', 'DateTime', 'Id'])) then EventElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'range') then RangeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromEvent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (isMatchingName(propName, 'event', ['CodeableConcept', 'Reference', 'DateTime', 'Id'])) then EventElement := new as TFhirDataType
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'range') then RangeElement := new as TFhirRange
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromEvent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceVariableCharacteristicTimeFromEvent.fhirType : string;
begin
  result := 'EvidenceVariable.characteristic.timeFromEvent';
end;

function TFhirEvidenceVariableCharacteristicTimeFromEvent.Link : TFhirEvidenceVariableCharacteristicTimeFromEvent;
begin
  result := TFhirEvidenceVariableCharacteristicTimeFromEvent(inherited Link);
end;

function TFhirEvidenceVariableCharacteristicTimeFromEvent.Clone : TFhirEvidenceVariableCharacteristicTimeFromEvent;
begin
  result := TFhirEvidenceVariableCharacteristicTimeFromEvent(inherited Clone);
end;

function TFhirEvidenceVariableCharacteristicTimeFromEvent.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceVariableCharacteristicTimeFromEvent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceVariableCharacteristicTimeFromEvent)) then
    result := false
  else
  begin
    o := TFhirEvidenceVariableCharacteristicTimeFromEvent(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(eventElement, o.eventElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(rangeElement, o.rangeElement, true);
  end;
end;

function TFhirEvidenceVariableCharacteristicTimeFromEvent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FnoteList) and isEmptyProp(FEvent) and isEmptyProp(FQuantity) and isEmptyProp(FRange);
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromEvent.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('note');
  fields.add('event[x]');
  fields.add('quantity');
  fields.add('range');
end;

function TFhirEvidenceVariableCharacteristicTimeFromEvent.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FNoteList.sizeInBytes(magic));
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromEvent.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirEvidenceVariableCharacteristicTimeFromEvent.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromEvent.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirEvidenceVariableCharacteristicTimeFromEvent.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirEvidenceVariableCharacteristicTimeFromEvent.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromEvent.SetEvent(value : TFhirDataType);
begin
  FEvent.free;
  FEvent := value;
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromEvent.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromEvent.SetRange(value : TFhirRange);
begin
  FRange.free;
  FRange := value;
end;

{ TFhirEvidenceVariableCharacteristicTimeFromEventListEnumerator }

constructor TFhirEvidenceVariableCharacteristicTimeFromEventListEnumerator.Create(list : TFhirEvidenceVariableCharacteristicTimeFromEventList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceVariableCharacteristicTimeFromEventListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceVariableCharacteristicTimeFromEventListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceVariableCharacteristicTimeFromEventListEnumerator.GetCurrent : TFhirEvidenceVariableCharacteristicTimeFromEvent;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceVariableCharacteristicTimeFromEventListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceVariableCharacteristicTimeFromEventList }

function TFhirEvidenceVariableCharacteristicTimeFromEventList.AddItem(value: TFhirEvidenceVariableCharacteristicTimeFromEvent): TFhirEvidenceVariableCharacteristicTimeFromEvent;
begin
  assert(value.ClassName = 'TFhirEvidenceVariableCharacteristicTimeFromEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceVariableCharacteristicTimeFromEvent');
  add(value);
  result := value;
end;

function TFhirEvidenceVariableCharacteristicTimeFromEventList.Append: TFhirEvidenceVariableCharacteristicTimeFromEvent;
begin
  result := TFhirEvidenceVariableCharacteristicTimeFromEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromEventList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceVariableCharacteristicTimeFromEventList.GetEnumerator : TFhirEvidenceVariableCharacteristicTimeFromEventListEnumerator;
begin
  result := TFhirEvidenceVariableCharacteristicTimeFromEventListEnumerator.Create(self.link);
end;

function TFhirEvidenceVariableCharacteristicTimeFromEventList.Clone: TFhirEvidenceVariableCharacteristicTimeFromEventList;
begin
  result := TFhirEvidenceVariableCharacteristicTimeFromEventList(inherited Clone);
end;

function TFhirEvidenceVariableCharacteristicTimeFromEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceVariableCharacteristicTimeFromEventList.GetItemN(index: Integer): TFhirEvidenceVariableCharacteristicTimeFromEvent;
begin
  result := TFhirEvidenceVariableCharacteristicTimeFromEvent(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableCharacteristicTimeFromEventList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceVariableCharacteristicTimeFromEvent;
end;
function TFhirEvidenceVariableCharacteristicTimeFromEventList.IndexOf(value: TFhirEvidenceVariableCharacteristicTimeFromEvent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceVariableCharacteristicTimeFromEventList.Insert(index: Integer): TFhirEvidenceVariableCharacteristicTimeFromEvent;
begin
  result := TFhirEvidenceVariableCharacteristicTimeFromEvent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromEventList.InsertItem(index: Integer; value: TFhirEvidenceVariableCharacteristicTimeFromEvent);
begin
  assert(value is TFhirEvidenceVariableCharacteristicTimeFromEvent);
  Inherited Insert(index, value);
end;

function TFhirEvidenceVariableCharacteristicTimeFromEventList.Item(index: Integer): TFhirEvidenceVariableCharacteristicTimeFromEvent;
begin
  result := TFhirEvidenceVariableCharacteristicTimeFromEvent(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableCharacteristicTimeFromEventList.Link: TFhirEvidenceVariableCharacteristicTimeFromEventList;
begin
  result := TFhirEvidenceVariableCharacteristicTimeFromEventList(inherited Link);
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromEventList.SetItemByIndex(index: Integer; value: TFhirEvidenceVariableCharacteristicTimeFromEvent);
begin
  assert(value is TFhirEvidenceVariableCharacteristicTimeFromEvent);
  FhirEvidenceVariableCharacteristicTimeFromEvents[index] := value;
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromEventList.SetItemN(index: Integer; value: TFhirEvidenceVariableCharacteristicTimeFromEvent);
begin
  assert(value is TFhirEvidenceVariableCharacteristicTimeFromEvent);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceVariableCategory }

constructor TFhirEvidenceVariableCategory.Create;
begin
  inherited;
end;

destructor TFhirEvidenceVariableCategory.Destroy;
begin
  FName.free;
  FValue.free;
  inherited;
end;

procedure TFhirEvidenceVariableCategory.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirEvidenceVariableCategory(oSource).nameElement.Clone;
  value := TFhirEvidenceVariableCategory(oSource).value.Clone;
end;

procedure TFhirEvidenceVariableCategory.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirEvidenceVariableCategory.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|Quantity|Range', false, TFhirDataType, FValue.Link));
end;

function TFhirEvidenceVariableCategory.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceVariableCategory.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEvidenceVariableCategory.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceVariableCategory.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'value[x]') then result := 'CodeableConcept|Quantity|Range'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceVariableCategory.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceVariableCategory.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceVariableCategory.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceVariableCategory.fhirType : string;
begin
  result := 'EvidenceVariable.category';
end;

function TFhirEvidenceVariableCategory.Link : TFhirEvidenceVariableCategory;
begin
  result := TFhirEvidenceVariableCategory(inherited Link);
end;

function TFhirEvidenceVariableCategory.Clone : TFhirEvidenceVariableCategory;
begin
  result := TFhirEvidenceVariableCategory(inherited Clone);
end;

function TFhirEvidenceVariableCategory.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceVariableCategory;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceVariableCategory)) then
    result := false
  else
  begin
    o := TFhirEvidenceVariableCategory(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirEvidenceVariableCategory.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FValue);
end;

procedure TFhirEvidenceVariableCategory.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('value[x]');
end;

function TFhirEvidenceVariableCategory.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirEvidenceVariableCategory.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirEvidenceVariableCategory.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirEvidenceVariableCategory.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirEvidenceVariableCategory.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirEvidenceVariableCategoryListEnumerator }

constructor TFhirEvidenceVariableCategoryListEnumerator.Create(list : TFhirEvidenceVariableCategoryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceVariableCategoryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceVariableCategoryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceVariableCategoryListEnumerator.GetCurrent : TFhirEvidenceVariableCategory;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceVariableCategoryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceVariableCategoryList }

function TFhirEvidenceVariableCategoryList.AddItem(value: TFhirEvidenceVariableCategory): TFhirEvidenceVariableCategory;
begin
  assert(value.ClassName = 'TFhirEvidenceVariableCategory', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceVariableCategory');
  add(value);
  result := value;
end;

function TFhirEvidenceVariableCategoryList.Append: TFhirEvidenceVariableCategory;
begin
  result := TFhirEvidenceVariableCategory.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableCategoryList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceVariableCategoryList.GetEnumerator : TFhirEvidenceVariableCategoryListEnumerator;
begin
  result := TFhirEvidenceVariableCategoryListEnumerator.Create(self.link);
end;

function TFhirEvidenceVariableCategoryList.Clone: TFhirEvidenceVariableCategoryList;
begin
  result := TFhirEvidenceVariableCategoryList(inherited Clone);
end;

function TFhirEvidenceVariableCategoryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceVariableCategoryList.GetItemN(index: Integer): TFhirEvidenceVariableCategory;
begin
  result := TFhirEvidenceVariableCategory(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableCategoryList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceVariableCategory;
end;
function TFhirEvidenceVariableCategoryList.IndexOf(value: TFhirEvidenceVariableCategory): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceVariableCategoryList.Insert(index: Integer): TFhirEvidenceVariableCategory;
begin
  result := TFhirEvidenceVariableCategory.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableCategoryList.InsertItem(index: Integer; value: TFhirEvidenceVariableCategory);
begin
  assert(value is TFhirEvidenceVariableCategory);
  Inherited Insert(index, value);
end;

function TFhirEvidenceVariableCategoryList.Item(index: Integer): TFhirEvidenceVariableCategory;
begin
  result := TFhirEvidenceVariableCategory(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableCategoryList.Link: TFhirEvidenceVariableCategoryList;
begin
  result := TFhirEvidenceVariableCategoryList(inherited Link);
end;

procedure TFhirEvidenceVariableCategoryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceVariableCategoryList.SetItemByIndex(index: Integer; value: TFhirEvidenceVariableCategory);
begin
  assert(value is TFhirEvidenceVariableCategory);
  FhirEvidenceVariableCategories[index] := value;
end;

procedure TFhirEvidenceVariableCategoryList.SetItemN(index: Integer; value: TFhirEvidenceVariableCategory);
begin
  assert(value is TFhirEvidenceVariableCategory);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceVariable }

constructor TFhirEvidenceVariable.Create;
begin
  inherited;
end;

destructor TFhirEvidenceVariable.Destroy;
begin
  FShortTitle.free;
  FSubtitle.free;
  FNoteList.Free;
  FActual.free;
  FCharacteristicList.Free;
  FHandling.free;
  FCategoryList.Free;
  inherited;
end;

procedure TFhirEvidenceVariable.Assign(oSource : TFslObject);
begin
  inherited;
  shortTitleElement := TFhirEvidenceVariable(oSource).shortTitleElement.Clone;
  subtitleElement := TFhirEvidenceVariable(oSource).subtitleElement.Clone;
  if (TFhirEvidenceVariable(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEvidenceVariable(oSource).FNoteList);
  end;
  actualElement := TFhirEvidenceVariable(oSource).actualElement.Clone;
  if (TFhirEvidenceVariable(oSource).FCharacteristicList = nil) then
  begin
    FCharacteristicList.free;
    FCharacteristicList := nil;
  end
  else
  begin
    if FCharacteristicList = nil then
      FCharacteristicList := TFhirEvidenceVariableCharacteristicList.Create;
    FCharacteristicList.Assign(TFhirEvidenceVariable(oSource).FCharacteristicList);
  end;
  handlingElement := TFhirEvidenceVariable(oSource).handlingElement.Clone;
  if (TFhirEvidenceVariable(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirEvidenceVariableCategoryList.Create;
    FCategoryList.Assign(TFhirEvidenceVariable(oSource).FCategoryList);
  end;
end;

function TFhirEvidenceVariable.GetResourceType : TFhirResourceType;
begin
  result := frtEvidenceVariable;
end;

procedure TFhirEvidenceVariable.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'shortTitle') Then
     list.add(self.link, 'shortTitle', FShortTitle.Link);
  if (child_name = 'subtitle') Then
     list.add(self.link, 'subtitle', FSubtitle.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'actual') Then
     list.add(self.link, 'actual', FActual.Link);
  if (child_name = 'characteristic') Then
    list.addAll(self, 'characteristic', FCharacteristicList);
  if (child_name = 'handling') Then
     list.add(self.link, 'handling', FHandling.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
end;

procedure TFhirEvidenceVariable.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'shortTitle', 'string', false, TFhirString, FShortTitle.Link));
  oList.add(TFHIRProperty.create(self, 'subtitle', 'string', false, TFhirString, FSubtitle.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'actual', 'boolean', false, TFhirBoolean, FActual.Link));
  oList.add(TFHIRProperty.create(self, 'characteristic', 'BackboneElement', true, TFhirEvidenceVariableCharacteristic, FCharacteristicList.Link));
  oList.add(TFHIRProperty.create(self, 'handling', 'code', false, TFhirEnum, FHandling.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'BackboneElement', true, TFhirEvidenceVariableCategory, FCategoryList.Link));
end;

function TFhirEvidenceVariable.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'shortTitle') then
  begin
    ShortTitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'subtitle') then
  begin
    SubtitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'actual') then
  begin
    ActualElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'characteristic') then
  begin
    CharacteristicList.add(propValue as TFhirEvidenceVariableCharacteristic);
    result := propValue;
  end
  else if (propName = 'handling') then
  begin
    HandlingElement := asEnum(SYSTEMS_TFhirEvidenceVariableHandlingEnum, CODES_TFhirEvidenceVariableHandlingEnum, propValue);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirEvidenceVariableCategory);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceVariable.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'characteristic') then CharacteristicList.insertItem(index, propValue as TFhirEvidenceVariableCharacteristic)
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirEvidenceVariableCategory)
  else inherited;
end;

function TFhirEvidenceVariable.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'shortTitle') then result := TFhirString.create()
  else if (propName = 'subtitle') then result := TFhirString.create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'actual') then result := TFhirBoolean.create()
  else if (propName = 'characteristic') then result := CharacteristicList.new()
  else if (propName = 'handling') then result := TFhirEnum.create(SYSTEMS_TFhirEvidenceVariableHandlingEnum[EvidenceVariableHandlingNull], CODES_TFhirEvidenceVariableHandlingEnum[EvidenceVariableHandlingNull]) 
  else if (propName = 'category') then result := CategoryList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceVariable.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'shortTitle') then result := 'string'
  else if (propName = 'subtitle') then result := 'string'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'actual') then result := 'boolean'
  else if (propName = 'characteristic') then result := 'BackboneElement'
  else if (propName = 'handling') then result := 'code'
  else if (propName = 'category') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceVariable.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'shortTitle') then ShortTitleElement := nil
  else if (propName = 'subtitle') then SubtitleElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'actual') then ActualElement := nil
  else if (propName = 'characteristic') then deletePropertyValue('characteristic', CharacteristicList, value)
  else if (propName = 'handling') then HandlingElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceVariable.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'shortTitle') then ShortTitleElement := asString(new)
  else if (propName = 'subtitle') then SubtitleElement := asString(new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'actual') then ActualElement := asBoolean(new)
  else if (propName = 'characteristic') then replacePropertyValue('characteristic', CharacteristicList, existing, new)
  else if (propName = 'handling') then HandlingElement := asEnum(SYSTEMS_TFhirEvidenceVariableHandlingEnum, CODES_TFhirEvidenceVariableHandlingEnum, new)
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceVariable.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'characteristic') then CharacteristicList.move(source, destination)
  else if (propName = 'category') then CategoryList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceVariable.fhirType : string;
begin
  result := 'EvidenceVariable';
end;

function TFhirEvidenceVariable.Link : TFhirEvidenceVariable;
begin
  result := TFhirEvidenceVariable(inherited Link);
end;

function TFhirEvidenceVariable.Clone : TFhirEvidenceVariable;
begin
  result := TFhirEvidenceVariable(inherited Clone);
end;

function TFhirEvidenceVariable.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceVariable;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceVariable)) then
    result := false
  else
  begin
    o := TFhirEvidenceVariable(other);
    result := compareDeep(shortTitleElement, o.shortTitleElement, true) and compareDeep(subtitleElement, o.subtitleElement, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(actualElement, o.actualElement, true) and 
      compareDeep(characteristicList, o.characteristicList, true) and compareDeep(handlingElement, o.handlingElement, true) and 
      compareDeep(categoryList, o.categoryList, true);
  end;
end;

function TFhirEvidenceVariable.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FShortTitle) and isEmptyProp(FSubtitle) and isEmptyProp(FnoteList) and isEmptyProp(FActual) and isEmptyProp(FcharacteristicList) and isEmptyProp(FHandling) and isEmptyProp(FcategoryList);
end;

procedure TFhirEvidenceVariable.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('shortTitle');
  fields.add('subtitle');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('note');
  fields.add('useContext');
  fields.add('copyright');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('author');
  fields.add('editor');
  fields.add('reviewer');
  fields.add('endorser');
  fields.add('relatedArtifact');
  fields.add('actual');
  fields.add('characteristic');
  fields.add('handling');
  fields.add('category');
end;

function TFhirEvidenceVariable.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FCharacteristicList.sizeInBytes(magic));
  inc(result, FCategoryList.sizeInBytes(magic));
end;

procedure TFhirEvidenceVariable.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirEvidenceVariable.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirEvidenceVariable.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirEvidenceVariable.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirEvidenceVariable.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirEvidenceVariable.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirEvidenceVariable.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirEvidenceVariable.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirEvidenceVariable.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirEvidenceVariable.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirEvidenceVariable.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirEvidenceVariable.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirEvidenceVariable.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirEvidenceVariable.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirEvidenceVariable.SetShortTitle(value : TFhirString);
begin
  FShortTitle.free;
  FShortTitle := value;
end;

function TFhirEvidenceVariable.GetShortTitleST : String;
begin
  if FShortTitle = nil then
    result := ''
  else
    result := FShortTitle.value;
end;

procedure TFhirEvidenceVariable.SetShortTitleST(value : String);
begin
  if value <> '' then
  begin
    if FShortTitle = nil then
      FShortTitle := TFhirString.create;
    FShortTitle.value := value
  end
  else if FShortTitle <> nil then
    FShortTitle.value := '';
end;

procedure TFhirEvidenceVariable.SetSubtitle(value : TFhirString);
begin
  FSubtitle.free;
  FSubtitle := value;
end;

function TFhirEvidenceVariable.GetSubtitleST : String;
begin
  if FSubtitle = nil then
    result := ''
  else
    result := FSubtitle.value;
end;

procedure TFhirEvidenceVariable.SetSubtitleST(value : String);
begin
  if value <> '' then
  begin
    if FSubtitle = nil then
      FSubtitle := TFhirString.create;
    FSubtitle.value := value
  end
  else if FSubtitle <> nil then
    FSubtitle.value := '';
end;

procedure TFhirEvidenceVariable.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEvidenceVariable.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirEvidenceVariable.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirEvidenceVariable.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirEvidenceVariable.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirEvidenceVariable.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirEvidenceVariable.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirEvidenceVariable.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirEvidenceVariable.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirEvidenceVariable.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirEvidenceVariable.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirEvidenceVariable.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirEvidenceVariable.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirEvidenceVariable.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirEvidenceVariable.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirEvidenceVariable.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirEvidenceVariable.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirEvidenceVariable.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirEvidenceVariable.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirEvidenceVariable.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirEvidenceVariable.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

procedure TFhirEvidenceVariable.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirEvidenceVariable.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirEvidenceVariable.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

procedure TFhirEvidenceVariable.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

function TFhirEvidenceVariable.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

procedure TFhirEvidenceVariable.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

procedure TFhirEvidenceVariable.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

function TFhirEvidenceVariable.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

procedure TFhirEvidenceVariable.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

procedure TFhirEvidenceVariable.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

function TFhirEvidenceVariable.GetAuthorList : TFhirContactDetailList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirContactDetailList.Create;
  result := FAuthorList;
end;

function TFhirEvidenceVariable.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

function TFhirEvidenceVariable.GetEditorList : TFhirContactDetailList;
begin
  if FEditorList = nil then
    FEditorList := TFhirContactDetailList.Create;
  result := FEditorList;
end;

function TFhirEvidenceVariable.GetHasEditorList : boolean;
begin
  result := (FEditorList <> nil) and (FEditorList.count > 0);
end;

function TFhirEvidenceVariable.GetReviewerList : TFhirContactDetailList;
begin
  if FReviewerList = nil then
    FReviewerList := TFhirContactDetailList.Create;
  result := FReviewerList;
end;

function TFhirEvidenceVariable.GetHasReviewerList : boolean;
begin
  result := (FReviewerList <> nil) and (FReviewerList.count > 0);
end;

function TFhirEvidenceVariable.GetEndorserList : TFhirContactDetailList;
begin
  if FEndorserList = nil then
    FEndorserList := TFhirContactDetailList.Create;
  result := FEndorserList;
end;

function TFhirEvidenceVariable.GetHasEndorserList : boolean;
begin
  result := (FEndorserList <> nil) and (FEndorserList.count > 0);
end;

function TFhirEvidenceVariable.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

function TFhirEvidenceVariable.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

procedure TFhirEvidenceVariable.SetActual(value : TFhirBoolean);
begin
  FActual.free;
  FActual := value;
end;

function TFhirEvidenceVariable.GetActualST : Boolean;
begin
  if FActual = nil then
    result := false
  else
    result := FActual.value;
end;

procedure TFhirEvidenceVariable.SetActualST(value : Boolean);
begin
  if FActual = nil then
    FActual := TFhirBoolean.create;
  FActual.value := value
end;

function TFhirEvidenceVariable.GetCharacteristicList : TFhirEvidenceVariableCharacteristicList;
begin
  if FCharacteristicList = nil then
    FCharacteristicList := TFhirEvidenceVariableCharacteristicList.Create;
  result := FCharacteristicList;
end;

function TFhirEvidenceVariable.GetHasCharacteristicList : boolean;
begin
  result := (FCharacteristicList <> nil) and (FCharacteristicList.count > 0);
end;

procedure TFhirEvidenceVariable.SetHandling(value : TFhirEnum);
begin
  FHandling.free;
  FHandling := value;
end;

function TFhirEvidenceVariable.GetHandlingST : TFhirEvidenceVariableHandlingEnum;
begin
  if FHandling = nil then
    result := TFhirEvidenceVariableHandlingEnum(0)
  else
    result := TFhirEvidenceVariableHandlingEnum(StringArrayIndexOfSensitive(CODES_TFhirEvidenceVariableHandlingEnum, FHandling.value));
end;

procedure TFhirEvidenceVariable.SetHandlingST(value : TFhirEvidenceVariableHandlingEnum);
begin
  if ord(value) = 0 then
    HandlingElement := nil
  else
    HandlingElement := TFhirEnum.create(SYSTEMS_TFhirEvidenceVariableHandlingEnum[value], CODES_TFhirEvidenceVariableHandlingEnum[value]);
end;

function TFhirEvidenceVariable.GetCategoryList : TFhirEvidenceVariableCategoryList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirEvidenceVariableCategoryList.Create;
  result := FCategoryList;
end;

function TFhirEvidenceVariable.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

{ TFhirEvidenceVariableListEnumerator }

constructor TFhirEvidenceVariableListEnumerator.Create(list : TFhirEvidenceVariableList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceVariableListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceVariableListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceVariableListEnumerator.GetCurrent : TFhirEvidenceVariable;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceVariableListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceVariableList }

function TFhirEvidenceVariableList.AddItem(value: TFhirEvidenceVariable): TFhirEvidenceVariable;
begin
  assert(value.ClassName = 'TFhirEvidenceVariable', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceVariable');
  add(value);
  result := value;
end;

function TFhirEvidenceVariableList.Append: TFhirEvidenceVariable;
begin
  result := TFhirEvidenceVariable.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceVariableList.GetEnumerator : TFhirEvidenceVariableListEnumerator;
begin
  result := TFhirEvidenceVariableListEnumerator.Create(self.link);
end;

function TFhirEvidenceVariableList.Clone: TFhirEvidenceVariableList;
begin
  result := TFhirEvidenceVariableList(inherited Clone);
end;

function TFhirEvidenceVariableList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceVariableList.GetItemN(index: Integer): TFhirEvidenceVariable;
begin
  result := TFhirEvidenceVariable(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceVariable;
end;
function TFhirEvidenceVariableList.IndexOf(value: TFhirEvidenceVariable): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceVariableList.Insert(index: Integer): TFhirEvidenceVariable;
begin
  result := TFhirEvidenceVariable.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableList.InsertItem(index: Integer; value: TFhirEvidenceVariable);
begin
  assert(value is TFhirEvidenceVariable);
  Inherited Insert(index, value);
end;

function TFhirEvidenceVariableList.Item(index: Integer): TFhirEvidenceVariable;
begin
  result := TFhirEvidenceVariable(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableList.Link: TFhirEvidenceVariableList;
begin
  result := TFhirEvidenceVariableList(inherited Link);
end;

procedure TFhirEvidenceVariableList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceVariableList.SetItemByIndex(index: Integer; value: TFhirEvidenceVariable);
begin
  assert(value is TFhirEvidenceVariable);
  FhirEvidenceVariables[index] := value;
end;

procedure TFhirEvidenceVariableList.SetItemN(index: Integer; value: TFhirEvidenceVariable);
begin
  assert(value is TFhirEvidenceVariable);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_GUIDANCERESPONSE}
{ TFhirGuidanceResponse }

constructor TFhirGuidanceResponse.Create;
begin
  inherited;
end;

destructor TFhirGuidanceResponse.Destroy;
begin
  FRequestIdentifier.free;
  FIdentifierList.Free;
  FModule.free;
  FStatus.free;
  FSubject.free;
  FEncounter.free;
  FOccurrenceDateTime.free;
  FPerformer.free;
  FReasonList.Free;
  FNoteList.Free;
  FEvaluationMessageList.Free;
  FOutputParameters.free;
  FResult.free;
  FDataRequirementList.Free;
  inherited;
end;

procedure TFhirGuidanceResponse.Assign(oSource : TFslObject);
begin
  inherited;
  requestIdentifier := TFhirGuidanceResponse(oSource).requestIdentifier.Clone;
  if (TFhirGuidanceResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirGuidanceResponse(oSource).FIdentifierList);
  end;
  module := TFhirGuidanceResponse(oSource).module.Clone;
  statusElement := TFhirGuidanceResponse(oSource).statusElement.Clone;
  subject := TFhirGuidanceResponse(oSource).subject.Clone;
  encounter := TFhirGuidanceResponse(oSource).encounter.Clone;
  occurrenceDateTimeElement := TFhirGuidanceResponse(oSource).occurrenceDateTimeElement.Clone;
  performer := TFhirGuidanceResponse(oSource).performer.Clone;
  if (TFhirGuidanceResponse(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableReferenceList.Create;
    FReasonList.Assign(TFhirGuidanceResponse(oSource).FReasonList);
  end;
  if (TFhirGuidanceResponse(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirGuidanceResponse(oSource).FNoteList);
  end;
  if (TFhirGuidanceResponse(oSource).FEvaluationMessageList = nil) then
  begin
    FEvaluationMessageList.free;
    FEvaluationMessageList := nil;
  end
  else
  begin
    if FEvaluationMessageList = nil then
      FEvaluationMessageList := TFhirReferenceList.Create;
    FEvaluationMessageList.Assign(TFhirGuidanceResponse(oSource).FEvaluationMessageList);
  end;
  outputParameters := TFhirGuidanceResponse(oSource).outputParameters.Clone;
  result := TFhirGuidanceResponse(oSource).result.Clone;
  if (TFhirGuidanceResponse(oSource).FDataRequirementList = nil) then
  begin
    FDataRequirementList.free;
    FDataRequirementList := nil;
  end
  else
  begin
    if FDataRequirementList = nil then
      FDataRequirementList := TFhirDataRequirementList.Create;
    FDataRequirementList.Assign(TFhirGuidanceResponse(oSource).FDataRequirementList);
  end;
end;

function TFhirGuidanceResponse.GetResourceType : TFhirResourceType;
begin
  result := frtGuidanceResponse;
end;

procedure TFhirGuidanceResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'requestIdentifier') Then
     list.add(self.link, 'requestIdentifier', FRequestIdentifier.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'module[x]') or (child_name = 'module') Then
     list.add(self.link, 'module[x]', FModule.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'occurrenceDateTime') Then
     list.add(self.link, 'occurrenceDateTime', FOccurrenceDateTime.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'evaluationMessage') Then
    list.addAll(self, 'evaluationMessage', FEvaluationMessageList);
  if (child_name = 'outputParameters') Then
     list.add(self.link, 'outputParameters', FOutputParameters.Link);
  if (child_name = 'result') Then
     list.add(self.link, 'result', FResult.Link);
  if (child_name = 'dataRequirement') Then
    list.addAll(self, 'dataRequirement', FDataRequirementList);
end;

procedure TFhirGuidanceResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'requestIdentifier', 'Identifier', false, TFhirIdentifier, FRequestIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'module[x]', 'uri|canonical|CodeableConcept', false, TFhirDataType, FModule.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'occurrenceDateTime', 'dateTime', false, TFhirDateTime, FOccurrenceDateTime.Link));
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference', false, TFhirReference, FPerformer.Link));
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableReference', true, TFhirCodeableReference, FReasonList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'evaluationMessage', 'Reference', true, TFhirReference, FEvaluationMessageList.Link));
  oList.add(TFHIRProperty.create(self, 'outputParameters', 'Reference', false, TFhirReference, FOutputParameters.Link));
  oList.add(TFHIRProperty.create(self, 'result', 'Reference', false, TFhirReference, FResult.Link));
  oList.add(TFHIRProperty.create(self, 'dataRequirement', 'DataRequirement', true, TFhirDataRequirement, FDataRequirementList.Link));
end;

function TFhirGuidanceResponse.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'requestIdentifier') then
  begin
    RequestIdentifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (isMatchingName(propName, 'module', ['Uri', 'Canonical', 'CodeableConcept'])) then
  begin
    Module := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirGuidanceResponseStatusEnum, CODES_TFhirGuidanceResponseStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'occurrenceDateTime') then
  begin
    OccurrenceDateTimeElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableReference);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'evaluationMessage') then
  begin
    EvaluationMessageList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'outputParameters') then
  begin
    OutputParameters := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'result') then
  begin
    Result := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'dataRequirement') then
  begin
    DataRequirementList.add(propValue as TFhirDataRequirement);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGuidanceResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableReference)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'evaluationMessage') then EvaluationMessageList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'dataRequirement') then DataRequirementList.insertItem(index, propValue as TFhirDataRequirement)
  else inherited;
end;

function TFhirGuidanceResponse.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'requestIdentifier') then result := TFhirIdentifier.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (isMatchingName(propName, 'module', ['Uri', 'Canonical', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Module')
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirGuidanceResponseStatusEnum[GuidanceResponseStatusNull], CODES_TFhirGuidanceResponseStatusEnum[GuidanceResponseStatusNull]) 
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (propName = 'occurrenceDateTime') then result := TFhirDateTime.create()
  else if (propName = 'performer') then result := TFhirReference.create()
  else if (propName = 'reason') then result := ReasonList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'evaluationMessage') then result := EvaluationMessageList.new()
  else if (propName = 'outputParameters') then result := TFhirReference.create()
  else if (propName = 'result') then result := TFhirReference.create()
  else if (propName = 'dataRequirement') then result := DataRequirementList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirGuidanceResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'requestIdentifier') then result := 'Identifier'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'module[x]') then result := 'uri|canonical|CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'occurrenceDateTime') then result := 'dateTime'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'reason') then result := 'CodeableReference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'evaluationMessage') then result := 'Reference'
  else if (propName = 'outputParameters') then result := 'Reference'
  else if (propName = 'result') then result := 'Reference'
  else if (propName = 'dataRequirement') then result := 'DataRequirement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGuidanceResponse.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'requestIdentifier') then RequestIdentifierElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (isMatchingName(propName, 'module', ['Uri', 'Canonical', 'CodeableConcept'])) then ModuleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'occurrenceDateTime') then OccurrenceDateTimeElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'evaluationMessage') then deletePropertyValue('evaluationMessage', EvaluationMessageList, value)
  else if (propName = 'outputParameters') then OutputParametersElement := nil
  else if (propName = 'result') then ResultElement := nil
  else if (propName = 'dataRequirement') then deletePropertyValue('dataRequirement', DataRequirementList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGuidanceResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'requestIdentifier') then RequestIdentifierElement := new as TFhirIdentifier
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (isMatchingName(propName, 'module', ['Uri', 'Canonical', 'CodeableConcept'])) then ModuleElement := new as TFhirDataType
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirGuidanceResponseStatusEnum, CODES_TFhirGuidanceResponseStatusEnum, new)
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (propName = 'occurrenceDateTime') then OccurrenceDateTimeElement := asDateTime(new)
  else if (propName = 'performer') then PerformerElement := new as TFhirReference
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'evaluationMessage') then replacePropertyValue('evaluationMessage', EvaluationMessageList, existing, new)
  else if (propName = 'outputParameters') then OutputParametersElement := new as TFhirReference
  else if (propName = 'result') then ResultElement := new as TFhirReference
  else if (propName = 'dataRequirement') then replacePropertyValue('dataRequirement', DataRequirementList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGuidanceResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'reason') then ReasonList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'evaluationMessage') then EvaluationMessageList.move(source, destination)
  else if (propName = 'dataRequirement') then DataRequirementList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirGuidanceResponse.fhirType : string;
begin
  result := 'GuidanceResponse';
end;

function TFhirGuidanceResponse.Link : TFhirGuidanceResponse;
begin
  result := TFhirGuidanceResponse(inherited Link);
end;

function TFhirGuidanceResponse.Clone : TFhirGuidanceResponse;
begin
  result := TFhirGuidanceResponse(inherited Clone);
end;

function TFhirGuidanceResponse.equals(other : TObject) : boolean; 
var
  o : TFhirGuidanceResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGuidanceResponse)) then
    result := false
  else
  begin
    o := TFhirGuidanceResponse(other);
    result := compareDeep(requestIdentifierElement, o.requestIdentifierElement, true) and 
      compareDeep(identifierList, o.identifierList, true) and compareDeep(moduleElement, o.moduleElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(occurrenceDateTimeElement, o.occurrenceDateTimeElement, true) and 
      compareDeep(performerElement, o.performerElement, true) and compareDeep(reasonList, o.reasonList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(evaluationMessageList, o.evaluationMessageList, true) and 
      compareDeep(outputParametersElement, o.outputParametersElement, true) and compareDeep(resultElement, o.resultElement, true) and 
      compareDeep(dataRequirementList, o.dataRequirementList, true);
  end;
end;

function TFhirGuidanceResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRequestIdentifier) and isEmptyProp(FidentifierList) and isEmptyProp(FModule) and isEmptyProp(FStatus) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FOccurrenceDateTime) and isEmptyProp(FPerformer) and isEmptyProp(FreasonList) and isEmptyProp(FnoteList) and isEmptyProp(FevaluationMessageList) and isEmptyProp(FOutputParameters) and isEmptyProp(FResult) and isEmptyProp(FdataRequirementList);
end;

procedure TFhirGuidanceResponse.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('requestIdentifier');
  fields.add('identifier');
  fields.add('module[x]');
  fields.add('status');
  fields.add('subject');
  fields.add('encounter');
  fields.add('occurrenceDateTime');
  fields.add('performer');
  fields.add('reason');
  fields.add('note');
  fields.add('evaluationMessage');
  fields.add('outputParameters');
  fields.add('result');
  fields.add('dataRequirement');
end;

function TFhirGuidanceResponse.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FReasonList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FEvaluationMessageList.sizeInBytes(magic));
  inc(result, FDataRequirementList.sizeInBytes(magic));
end;

procedure TFhirGuidanceResponse.SetRequestIdentifier(value : TFhirIdentifier);
begin
  FRequestIdentifier.free;
  FRequestIdentifier := value;
end;

function TFhirGuidanceResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirGuidanceResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirGuidanceResponse.SetModule(value : TFhirDataType);
begin
  FModule.free;
  FModule := value;
end;

procedure TFhirGuidanceResponse.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirGuidanceResponse.GetStatusST : TFhirGuidanceResponseStatusEnum;
begin
  if FStatus = nil then
    result := TFhirGuidanceResponseStatusEnum(0)
  else
    result := TFhirGuidanceResponseStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirGuidanceResponseStatusEnum, FStatus.value));
end;

procedure TFhirGuidanceResponse.SetStatusST(value : TFhirGuidanceResponseStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirGuidanceResponseStatusEnum[value], CODES_TFhirGuidanceResponseStatusEnum[value]);
end;

procedure TFhirGuidanceResponse.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirGuidanceResponse.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirGuidanceResponse.SetOccurrenceDateTime(value : TFhirDateTime);
begin
  FOccurrenceDateTime.free;
  FOccurrenceDateTime := value;
end;

function TFhirGuidanceResponse.GetOccurrenceDateTimeST : TFslDateTime;
begin
  if FOccurrenceDateTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FOccurrenceDateTime.value;
end;

procedure TFhirGuidanceResponse.SetOccurrenceDateTimeST(value : TFslDateTime);
begin
  if FOccurrenceDateTime = nil then
    FOccurrenceDateTime := TFhirDateTime.create;
  FOccurrenceDateTime.value := value
end;

procedure TFhirGuidanceResponse.SetPerformer(value : TFhirReference);
begin
  FPerformer.free;
  FPerformer := value;
end;

function TFhirGuidanceResponse.GetReasonList : TFhirCodeableReferenceList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableReferenceList.Create;
  result := FReasonList;
end;

function TFhirGuidanceResponse.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirGuidanceResponse.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirGuidanceResponse.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirGuidanceResponse.GetEvaluationMessageList : TFhirReferenceList;
begin
  if FEvaluationMessageList = nil then
    FEvaluationMessageList := TFhirReferenceList.Create;
  result := FEvaluationMessageList;
end;

function TFhirGuidanceResponse.GetHasEvaluationMessageList : boolean;
begin
  result := (FEvaluationMessageList <> nil) and (FEvaluationMessageList.count > 0);
end;

procedure TFhirGuidanceResponse.SetOutputParameters(value : TFhirReference);
begin
  FOutputParameters.free;
  FOutputParameters := value;
end;

procedure TFhirGuidanceResponse.SetResult(value : TFhirReference);
begin
  FResult.free;
  FResult := value;
end;

function TFhirGuidanceResponse.GetDataRequirementList : TFhirDataRequirementList;
begin
  if FDataRequirementList = nil then
    FDataRequirementList := TFhirDataRequirementList.Create;
  result := FDataRequirementList;
end;

function TFhirGuidanceResponse.GetHasDataRequirementList : boolean;
begin
  result := (FDataRequirementList <> nil) and (FDataRequirementList.count > 0);
end;

{ TFhirGuidanceResponseListEnumerator }

constructor TFhirGuidanceResponseListEnumerator.Create(list : TFhirGuidanceResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGuidanceResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGuidanceResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGuidanceResponseListEnumerator.GetCurrent : TFhirGuidanceResponse;
begin
  Result := FList[FIndex];
end;

function TFhirGuidanceResponseListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirGuidanceResponseList }

function TFhirGuidanceResponseList.AddItem(value: TFhirGuidanceResponse): TFhirGuidanceResponse;
begin
  assert(value.ClassName = 'TFhirGuidanceResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGuidanceResponse');
  add(value);
  result := value;
end;

function TFhirGuidanceResponseList.Append: TFhirGuidanceResponse;
begin
  result := TFhirGuidanceResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGuidanceResponseList.ClearItems;
begin
  Clear;
end;

function TFhirGuidanceResponseList.GetEnumerator : TFhirGuidanceResponseListEnumerator;
begin
  result := TFhirGuidanceResponseListEnumerator.Create(self.link);
end;

function TFhirGuidanceResponseList.Clone: TFhirGuidanceResponseList;
begin
  result := TFhirGuidanceResponseList(inherited Clone);
end;

function TFhirGuidanceResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGuidanceResponseList.GetItemN(index: Integer): TFhirGuidanceResponse;
begin
  result := TFhirGuidanceResponse(ObjectByIndex[index]);
end;

function TFhirGuidanceResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirGuidanceResponse;
end;
function TFhirGuidanceResponseList.IndexOf(value: TFhirGuidanceResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGuidanceResponseList.Insert(index: Integer): TFhirGuidanceResponse;
begin
  result := TFhirGuidanceResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGuidanceResponseList.InsertItem(index: Integer; value: TFhirGuidanceResponse);
begin
  assert(value is TFhirGuidanceResponse);
  Inherited Insert(index, value);
end;

function TFhirGuidanceResponseList.Item(index: Integer): TFhirGuidanceResponse;
begin
  result := TFhirGuidanceResponse(ObjectByIndex[index]);
end;

function TFhirGuidanceResponseList.Link: TFhirGuidanceResponseList;
begin
  result := TFhirGuidanceResponseList(inherited Link);
end;

procedure TFhirGuidanceResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGuidanceResponseList.SetItemByIndex(index: Integer; value: TFhirGuidanceResponse);
begin
  assert(value is TFhirGuidanceResponse);
  FhirGuidanceResponses[index] := value;
end;

procedure TFhirGuidanceResponseList.SetItemN(index: Integer; value: TFhirGuidanceResponse);
begin
  assert(value is TFhirGuidanceResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_INVENTORYREPORT}
{ TFhirInventoryReportInventoryListing }

constructor TFhirInventoryReportInventoryListing.Create;
begin
  inherited;
end;

destructor TFhirInventoryReportInventoryListing.Destroy;
begin
  FLocation.free;
  FItemStatus.free;
  FCountingDateTime.free;
  FItemsList.Free;
  inherited;
end;

procedure TFhirInventoryReportInventoryListing.Assign(oSource : TFslObject);
begin
  inherited;
  location := TFhirInventoryReportInventoryListing(oSource).location.Clone;
  itemStatus := TFhirInventoryReportInventoryListing(oSource).itemStatus.Clone;
  countingDateTimeElement := TFhirInventoryReportInventoryListing(oSource).countingDateTimeElement.Clone;
  if (TFhirInventoryReportInventoryListing(oSource).FItemsList = nil) then
  begin
    FItemsList.free;
    FItemsList := nil;
  end
  else
  begin
    if FItemsList = nil then
      FItemsList := TFhirInventoryReportInventoryListingItemsList.Create;
    FItemsList.Assign(TFhirInventoryReportInventoryListing(oSource).FItemsList);
  end;
end;

procedure TFhirInventoryReportInventoryListing.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'itemStatus') Then
     list.add(self.link, 'itemStatus', FItemStatus.Link);
  if (child_name = 'countingDateTime') Then
     list.add(self.link, 'countingDateTime', FCountingDateTime.Link);
  if (child_name = 'items') Then
    list.addAll(self, 'items', FItemsList);
end;

procedure TFhirInventoryReportInventoryListing.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'itemStatus', 'CodeableConcept', false, TFhirCodeableConcept, FItemStatus.Link));
  oList.add(TFHIRProperty.create(self, 'countingDateTime', 'dateTime', false, TFhirDateTime, FCountingDateTime.Link));
  oList.add(TFHIRProperty.create(self, 'items', 'BackboneElement', true, TFhirInventoryReportInventoryListingItems, FItemsList.Link));
end;

function TFhirInventoryReportInventoryListing.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'location') then
  begin
    Location := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'itemStatus') then
  begin
    ItemStatus := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'countingDateTime') then
  begin
    CountingDateTimeElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'items') then
  begin
    ItemsList.add(propValue as TFhirInventoryReportInventoryListingItems);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInventoryReportInventoryListing.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'items') then ItemsList.insertItem(index, propValue as TFhirInventoryReportInventoryListingItems)
  else inherited;
end;

function TFhirInventoryReportInventoryListing.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'location') then result := TFhirReference.create()
  else if (propName = 'itemStatus') then result := TFhirCodeableConcept.create()
  else if (propName = 'countingDateTime') then result := TFhirDateTime.create()
  else if (propName = 'items') then result := ItemsList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirInventoryReportInventoryListing.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'location') then result := 'Reference'
  else if (propName = 'itemStatus') then result := 'CodeableConcept'
  else if (propName = 'countingDateTime') then result := 'dateTime'
  else if (propName = 'items') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInventoryReportInventoryListing.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'location') then LocationElement := nil
  else if (propName = 'itemStatus') then ItemStatusElement := nil
  else if (propName = 'countingDateTime') then CountingDateTimeElement := nil
  else if (propName = 'items') then deletePropertyValue('items', ItemsList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInventoryReportInventoryListing.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'location') then LocationElement := new as TFhirReference
  else if (propName = 'itemStatus') then ItemStatusElement := new as TFhirCodeableConcept
  else if (propName = 'countingDateTime') then CountingDateTimeElement := asDateTime(new)
  else if (propName = 'items') then replacePropertyValue('items', ItemsList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInventoryReportInventoryListing.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'items') then ItemsList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInventoryReportInventoryListing.fhirType : string;
begin
  result := 'InventoryReport.inventoryListing';
end;

function TFhirInventoryReportInventoryListing.Link : TFhirInventoryReportInventoryListing;
begin
  result := TFhirInventoryReportInventoryListing(inherited Link);
end;

function TFhirInventoryReportInventoryListing.Clone : TFhirInventoryReportInventoryListing;
begin
  result := TFhirInventoryReportInventoryListing(inherited Clone);
end;

function TFhirInventoryReportInventoryListing.equals(other : TObject) : boolean; 
var
  o : TFhirInventoryReportInventoryListing;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInventoryReportInventoryListing)) then
    result := false
  else
  begin
    o := TFhirInventoryReportInventoryListing(other);
    result := compareDeep(locationElement, o.locationElement, true) and compareDeep(itemStatusElement, o.itemStatusElement, true) and 
      compareDeep(countingDateTimeElement, o.countingDateTimeElement, true) and compareDeep(itemsList, o.itemsList, true);
  end;
end;

function TFhirInventoryReportInventoryListing.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLocation) and isEmptyProp(FItemStatus) and isEmptyProp(FCountingDateTime) and isEmptyProp(FitemsList);
end;

procedure TFhirInventoryReportInventoryListing.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('location');
  fields.add('itemStatus');
  fields.add('countingDateTime');
  fields.add('items');
end;

function TFhirInventoryReportInventoryListing.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FItemsList.sizeInBytes(magic));
end;

procedure TFhirInventoryReportInventoryListing.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value;
end;

procedure TFhirInventoryReportInventoryListing.SetItemStatus(value : TFhirCodeableConcept);
begin
  FItemStatus.free;
  FItemStatus := value;
end;

procedure TFhirInventoryReportInventoryListing.SetCountingDateTime(value : TFhirDateTime);
begin
  FCountingDateTime.free;
  FCountingDateTime := value;
end;

function TFhirInventoryReportInventoryListing.GetCountingDateTimeST : TFslDateTime;
begin
  if FCountingDateTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FCountingDateTime.value;
end;

procedure TFhirInventoryReportInventoryListing.SetCountingDateTimeST(value : TFslDateTime);
begin
  if FCountingDateTime = nil then
    FCountingDateTime := TFhirDateTime.create;
  FCountingDateTime.value := value
end;

function TFhirInventoryReportInventoryListing.GetItemsList : TFhirInventoryReportInventoryListingItemsList;
begin
  if FItemsList = nil then
    FItemsList := TFhirInventoryReportInventoryListingItemsList.Create;
  result := FItemsList;
end;

function TFhirInventoryReportInventoryListing.GetHasItemsList : boolean;
begin
  result := (FItemsList <> nil) and (FItemsList.count > 0);
end;

{ TFhirInventoryReportInventoryListingListEnumerator }

constructor TFhirInventoryReportInventoryListingListEnumerator.Create(list : TFhirInventoryReportInventoryListingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInventoryReportInventoryListingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInventoryReportInventoryListingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInventoryReportInventoryListingListEnumerator.GetCurrent : TFhirInventoryReportInventoryListing;
begin
  Result := FList[FIndex];
end;

function TFhirInventoryReportInventoryListingListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirInventoryReportInventoryListingList }

function TFhirInventoryReportInventoryListingList.AddItem(value: TFhirInventoryReportInventoryListing): TFhirInventoryReportInventoryListing;
begin
  assert(value.ClassName = 'TFhirInventoryReportInventoryListing', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInventoryReportInventoryListing');
  add(value);
  result := value;
end;

function TFhirInventoryReportInventoryListingList.Append: TFhirInventoryReportInventoryListing;
begin
  result := TFhirInventoryReportInventoryListing.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInventoryReportInventoryListingList.ClearItems;
begin
  Clear;
end;

function TFhirInventoryReportInventoryListingList.GetEnumerator : TFhirInventoryReportInventoryListingListEnumerator;
begin
  result := TFhirInventoryReportInventoryListingListEnumerator.Create(self.link);
end;

function TFhirInventoryReportInventoryListingList.Clone: TFhirInventoryReportInventoryListingList;
begin
  result := TFhirInventoryReportInventoryListingList(inherited Clone);
end;

function TFhirInventoryReportInventoryListingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInventoryReportInventoryListingList.GetItemN(index: Integer): TFhirInventoryReportInventoryListing;
begin
  result := TFhirInventoryReportInventoryListing(ObjectByIndex[index]);
end;

function TFhirInventoryReportInventoryListingList.ItemClass: TFslObjectClass;
begin
  result := TFhirInventoryReportInventoryListing;
end;
function TFhirInventoryReportInventoryListingList.IndexOf(value: TFhirInventoryReportInventoryListing): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInventoryReportInventoryListingList.Insert(index: Integer): TFhirInventoryReportInventoryListing;
begin
  result := TFhirInventoryReportInventoryListing.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInventoryReportInventoryListingList.InsertItem(index: Integer; value: TFhirInventoryReportInventoryListing);
begin
  assert(value is TFhirInventoryReportInventoryListing);
  Inherited Insert(index, value);
end;

function TFhirInventoryReportInventoryListingList.Item(index: Integer): TFhirInventoryReportInventoryListing;
begin
  result := TFhirInventoryReportInventoryListing(ObjectByIndex[index]);
end;

function TFhirInventoryReportInventoryListingList.Link: TFhirInventoryReportInventoryListingList;
begin
  result := TFhirInventoryReportInventoryListingList(inherited Link);
end;

procedure TFhirInventoryReportInventoryListingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInventoryReportInventoryListingList.SetItemByIndex(index: Integer; value: TFhirInventoryReportInventoryListing);
begin
  assert(value is TFhirInventoryReportInventoryListing);
  FhirInventoryReportInventoryListings[index] := value;
end;

procedure TFhirInventoryReportInventoryListingList.SetItemN(index: Integer; value: TFhirInventoryReportInventoryListing);
begin
  assert(value is TFhirInventoryReportInventoryListing);
  ObjectByIndex[index] := value;
end;

{ TFhirInventoryReportInventoryListingItems }

constructor TFhirInventoryReportInventoryListingItems.Create;
begin
  inherited;
end;

destructor TFhirInventoryReportInventoryListingItems.Destroy;
begin
  FCategory.free;
  FQuantity.free;
  FItem.free;
  FLot.free;
  FSerial.free;
  FExpiry.free;
  FManufacturingDate.free;
  inherited;
end;

procedure TFhirInventoryReportInventoryListingItems.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirInventoryReportInventoryListingItems(oSource).category.Clone;
  quantity := TFhirInventoryReportInventoryListingItems(oSource).quantity.Clone;
  item := TFhirInventoryReportInventoryListingItems(oSource).item.Clone;
  lotElement := TFhirInventoryReportInventoryListingItems(oSource).lotElement.Clone;
  serialElement := TFhirInventoryReportInventoryListingItems(oSource).serialElement.Clone;
  expiryElement := TFhirInventoryReportInventoryListingItems(oSource).expiryElement.Clone;
  manufacturingDateElement := TFhirInventoryReportInventoryListingItems(oSource).manufacturingDateElement.Clone;
end;

procedure TFhirInventoryReportInventoryListingItems.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
  if (child_name = 'lot') Then
     list.add(self.link, 'lot', FLot.Link);
  if (child_name = 'serial') Then
     list.add(self.link, 'serial', FSerial.Link);
  if (child_name = 'expiry') Then
     list.add(self.link, 'expiry', FExpiry.Link);
  if (child_name = 'manufacturingDate') Then
     list.add(self.link, 'manufacturingDate', FManufacturingDate.Link);
end;

procedure TFhirInventoryReportInventoryListingItems.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'item', 'CodeableReference', false, TFhirCodeableReference, FItem.Link));
  oList.add(TFHIRProperty.create(self, 'lot', 'string', false, TFhirString, FLot.Link));
  oList.add(TFHIRProperty.create(self, 'serial', 'string', false, TFhirString, FSerial.Link));
  oList.add(TFHIRProperty.create(self, 'expiry', 'dateTime', false, TFhirDateTime, FExpiry.Link));
  oList.add(TFHIRProperty.create(self, 'manufacturingDate', 'dateTime', false, TFhirDateTime, FManufacturingDate.Link));
end;

function TFhirInventoryReportInventoryListingItems.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    Item := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'lot') then
  begin
    LotElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'serial') then
  begin
    SerialElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'expiry') then
  begin
    ExpiryElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'manufacturingDate') then
  begin
    ManufacturingDateElement := asDateTime(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInventoryReportInventoryListingItems.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirInventoryReportInventoryListingItems.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'item') then result := TFhirCodeableReference.create()
  else if (propName = 'lot') then result := TFhirString.create()
  else if (propName = 'serial') then result := TFhirString.create()
  else if (propName = 'expiry') then result := TFhirDateTime.create()
  else if (propName = 'manufacturingDate') then result := TFhirDateTime.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirInventoryReportInventoryListingItems.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'item') then result := 'CodeableReference'
  else if (propName = 'lot') then result := 'string'
  else if (propName = 'serial') then result := 'string'
  else if (propName = 'expiry') then result := 'dateTime'
  else if (propName = 'manufacturingDate') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInventoryReportInventoryListingItems.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'item') then ItemElement := nil
  else if (propName = 'lot') then LotElement := nil
  else if (propName = 'serial') then SerialElement := nil
  else if (propName = 'expiry') then ExpiryElement := nil
  else if (propName = 'manufacturingDate') then ManufacturingDateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInventoryReportInventoryListingItems.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'item') then ItemElement := new as TFhirCodeableReference
  else if (propName = 'lot') then LotElement := asString(new)
  else if (propName = 'serial') then SerialElement := asString(new)
  else if (propName = 'expiry') then ExpiryElement := asDateTime(new)
  else if (propName = 'manufacturingDate') then ManufacturingDateElement := asDateTime(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInventoryReportInventoryListingItems.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirInventoryReportInventoryListingItems.fhirType : string;
begin
  result := 'InventoryReport.inventoryListing.items';
end;

function TFhirInventoryReportInventoryListingItems.Link : TFhirInventoryReportInventoryListingItems;
begin
  result := TFhirInventoryReportInventoryListingItems(inherited Link);
end;

function TFhirInventoryReportInventoryListingItems.Clone : TFhirInventoryReportInventoryListingItems;
begin
  result := TFhirInventoryReportInventoryListingItems(inherited Clone);
end;

function TFhirInventoryReportInventoryListingItems.equals(other : TObject) : boolean; 
var
  o : TFhirInventoryReportInventoryListingItems;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInventoryReportInventoryListingItems)) then
    result := false
  else
  begin
    o := TFhirInventoryReportInventoryListingItems(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(itemElement, o.itemElement, true) and compareDeep(lotElement, o.lotElement, true) and 
      compareDeep(serialElement, o.serialElement, true) and compareDeep(expiryElement, o.expiryElement, true) and 
      compareDeep(manufacturingDateElement, o.manufacturingDateElement, true);
  end;
end;

function TFhirInventoryReportInventoryListingItems.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FQuantity) and isEmptyProp(FItem) and isEmptyProp(FLot) and isEmptyProp(FSerial) and isEmptyProp(FExpiry) and isEmptyProp(FManufacturingDate);
end;

procedure TFhirInventoryReportInventoryListingItems.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('category');
  fields.add('quantity');
  fields.add('item');
  fields.add('lot');
  fields.add('serial');
  fields.add('expiry');
  fields.add('manufacturingDate');
end;

function TFhirInventoryReportInventoryListingItems.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirInventoryReportInventoryListingItems.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirInventoryReportInventoryListingItems.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirInventoryReportInventoryListingItems.SetItem(value : TFhirCodeableReference);
begin
  FItem.free;
  FItem := value;
end;

procedure TFhirInventoryReportInventoryListingItems.SetLot(value : TFhirString);
begin
  FLot.free;
  FLot := value;
end;

function TFhirInventoryReportInventoryListingItems.GetLotST : String;
begin
  if FLot = nil then
    result := ''
  else
    result := FLot.value;
end;

procedure TFhirInventoryReportInventoryListingItems.SetLotST(value : String);
begin
  if value <> '' then
  begin
    if FLot = nil then
      FLot := TFhirString.create;
    FLot.value := value
  end
  else if FLot <> nil then
    FLot.value := '';
end;

procedure TFhirInventoryReportInventoryListingItems.SetSerial(value : TFhirString);
begin
  FSerial.free;
  FSerial := value;
end;

function TFhirInventoryReportInventoryListingItems.GetSerialST : String;
begin
  if FSerial = nil then
    result := ''
  else
    result := FSerial.value;
end;

procedure TFhirInventoryReportInventoryListingItems.SetSerialST(value : String);
begin
  if value <> '' then
  begin
    if FSerial = nil then
      FSerial := TFhirString.create;
    FSerial.value := value
  end
  else if FSerial <> nil then
    FSerial.value := '';
end;

procedure TFhirInventoryReportInventoryListingItems.SetExpiry(value : TFhirDateTime);
begin
  FExpiry.free;
  FExpiry := value;
end;

function TFhirInventoryReportInventoryListingItems.GetExpiryST : TFslDateTime;
begin
  if FExpiry = nil then
    result := TFslDateTime.makeNull
  else
    result := FExpiry.value;
end;

procedure TFhirInventoryReportInventoryListingItems.SetExpiryST(value : TFslDateTime);
begin
  if FExpiry = nil then
    FExpiry := TFhirDateTime.create;
  FExpiry.value := value
end;

procedure TFhirInventoryReportInventoryListingItems.SetManufacturingDate(value : TFhirDateTime);
begin
  FManufacturingDate.free;
  FManufacturingDate := value;
end;

function TFhirInventoryReportInventoryListingItems.GetManufacturingDateST : TFslDateTime;
begin
  if FManufacturingDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FManufacturingDate.value;
end;

procedure TFhirInventoryReportInventoryListingItems.SetManufacturingDateST(value : TFslDateTime);
begin
  if FManufacturingDate = nil then
    FManufacturingDate := TFhirDateTime.create;
  FManufacturingDate.value := value
end;

{ TFhirInventoryReportInventoryListingItemsListEnumerator }

constructor TFhirInventoryReportInventoryListingItemsListEnumerator.Create(list : TFhirInventoryReportInventoryListingItemsList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInventoryReportInventoryListingItemsListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInventoryReportInventoryListingItemsListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInventoryReportInventoryListingItemsListEnumerator.GetCurrent : TFhirInventoryReportInventoryListingItems;
begin
  Result := FList[FIndex];
end;

function TFhirInventoryReportInventoryListingItemsListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirInventoryReportInventoryListingItemsList }

function TFhirInventoryReportInventoryListingItemsList.AddItem(value: TFhirInventoryReportInventoryListingItems): TFhirInventoryReportInventoryListingItems;
begin
  assert(value.ClassName = 'TFhirInventoryReportInventoryListingItems', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInventoryReportInventoryListingItems');
  add(value);
  result := value;
end;

function TFhirInventoryReportInventoryListingItemsList.Append: TFhirInventoryReportInventoryListingItems;
begin
  result := TFhirInventoryReportInventoryListingItems.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInventoryReportInventoryListingItemsList.ClearItems;
begin
  Clear;
end;

function TFhirInventoryReportInventoryListingItemsList.GetEnumerator : TFhirInventoryReportInventoryListingItemsListEnumerator;
begin
  result := TFhirInventoryReportInventoryListingItemsListEnumerator.Create(self.link);
end;

function TFhirInventoryReportInventoryListingItemsList.Clone: TFhirInventoryReportInventoryListingItemsList;
begin
  result := TFhirInventoryReportInventoryListingItemsList(inherited Clone);
end;

function TFhirInventoryReportInventoryListingItemsList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInventoryReportInventoryListingItemsList.GetItemN(index: Integer): TFhirInventoryReportInventoryListingItems;
begin
  result := TFhirInventoryReportInventoryListingItems(ObjectByIndex[index]);
end;

function TFhirInventoryReportInventoryListingItemsList.ItemClass: TFslObjectClass;
begin
  result := TFhirInventoryReportInventoryListingItems;
end;
function TFhirInventoryReportInventoryListingItemsList.IndexOf(value: TFhirInventoryReportInventoryListingItems): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInventoryReportInventoryListingItemsList.Insert(index: Integer): TFhirInventoryReportInventoryListingItems;
begin
  result := TFhirInventoryReportInventoryListingItems.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInventoryReportInventoryListingItemsList.InsertItem(index: Integer; value: TFhirInventoryReportInventoryListingItems);
begin
  assert(value is TFhirInventoryReportInventoryListingItems);
  Inherited Insert(index, value);
end;

function TFhirInventoryReportInventoryListingItemsList.Item(index: Integer): TFhirInventoryReportInventoryListingItems;
begin
  result := TFhirInventoryReportInventoryListingItems(ObjectByIndex[index]);
end;

function TFhirInventoryReportInventoryListingItemsList.Link: TFhirInventoryReportInventoryListingItemsList;
begin
  result := TFhirInventoryReportInventoryListingItemsList(inherited Link);
end;

procedure TFhirInventoryReportInventoryListingItemsList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInventoryReportInventoryListingItemsList.SetItemByIndex(index: Integer; value: TFhirInventoryReportInventoryListingItems);
begin
  assert(value is TFhirInventoryReportInventoryListingItems);
  FhirInventoryReportInventoryListingItems[index] := value;
end;

procedure TFhirInventoryReportInventoryListingItemsList.SetItemN(index: Integer; value: TFhirInventoryReportInventoryListingItems);
begin
  assert(value is TFhirInventoryReportInventoryListingItems);
  ObjectByIndex[index] := value;
end;

{ TFhirInventoryReport }

constructor TFhirInventoryReport.Create;
begin
  inherited;
end;

destructor TFhirInventoryReport.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCountType.free;
  FOperationType.free;
  FOperationTypeReason.free;
  FReportedDateTime.free;
  FReporter.free;
  FReportingPeriod.free;
  FInventoryListingList.Free;
  FNote.free;
  inherited;
end;

procedure TFhirInventoryReport.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirInventoryReport(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirInventoryReport(oSource).FIdentifierList);
  end;
  statusElement := TFhirInventoryReport(oSource).statusElement.Clone;
  countTypeElement := TFhirInventoryReport(oSource).countTypeElement.Clone;
  operationType := TFhirInventoryReport(oSource).operationType.Clone;
  operationTypeReason := TFhirInventoryReport(oSource).operationTypeReason.Clone;
  reportedDateTimeElement := TFhirInventoryReport(oSource).reportedDateTimeElement.Clone;
  reporter := TFhirInventoryReport(oSource).reporter.Clone;
  reportingPeriod := TFhirInventoryReport(oSource).reportingPeriod.Clone;
  if (TFhirInventoryReport(oSource).FInventoryListingList = nil) then
  begin
    FInventoryListingList.free;
    FInventoryListingList := nil;
  end
  else
  begin
    if FInventoryListingList = nil then
      FInventoryListingList := TFhirInventoryReportInventoryListingList.Create;
    FInventoryListingList.Assign(TFhirInventoryReport(oSource).FInventoryListingList);
  end;
  note := TFhirInventoryReport(oSource).note.Clone;
end;

function TFhirInventoryReport.GetResourceType : TFhirResourceType;
begin
  result := frtInventoryReport;
end;

procedure TFhirInventoryReport.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'countType') Then
     list.add(self.link, 'countType', FCountType.Link);
  if (child_name = 'operationType') Then
     list.add(self.link, 'operationType', FOperationType.Link);
  if (child_name = 'operationTypeReason') Then
     list.add(self.link, 'operationTypeReason', FOperationTypeReason.Link);
  if (child_name = 'reportedDateTime') Then
     list.add(self.link, 'reportedDateTime', FReportedDateTime.Link);
  if (child_name = 'reporter') Then
     list.add(self.link, 'reporter', FReporter.Link);
  if (child_name = 'reportingPeriod') Then
     list.add(self.link, 'reportingPeriod', FReportingPeriod.Link);
  if (child_name = 'inventoryListing') Then
    list.addAll(self, 'inventoryListing', FInventoryListingList);
  if (child_name = 'note') Then
     list.add(self.link, 'note', FNote.Link);
end;

procedure TFhirInventoryReport.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'countType', 'code', false, TFhirEnum, FCountType.Link));
  oList.add(TFHIRProperty.create(self, 'operationType', 'CodeableConcept', false, TFhirCodeableConcept, FOperationType.Link));
  oList.add(TFHIRProperty.create(self, 'operationTypeReason', 'CodeableConcept', false, TFhirCodeableConcept, FOperationTypeReason.Link));
  oList.add(TFHIRProperty.create(self, 'reportedDateTime', 'dateTime', false, TFhirDateTime, FReportedDateTime.Link));
  oList.add(TFHIRProperty.create(self, 'reporter', 'Reference', false, TFhirReference, FReporter.Link));
  oList.add(TFHIRProperty.create(self, 'reportingPeriod', 'Period', false, TFhirPeriod, FReportingPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'inventoryListing', 'BackboneElement', true, TFhirInventoryReportInventoryListing, FInventoryListingList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', false, TFhirAnnotation, FNote.Link));
end;

function TFhirInventoryReport.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirInventoryReportStatusEnum, CODES_TFhirInventoryReportStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'countType') then
  begin
    CountTypeElement := asEnum(SYSTEMS_TFhirInventoryCountTypeEnum, CODES_TFhirInventoryCountTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'operationType') then
  begin
    OperationType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'operationTypeReason') then
  begin
    OperationTypeReason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'reportedDateTime') then
  begin
    ReportedDateTimeElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'reporter') then
  begin
    Reporter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'reportingPeriod') then
  begin
    ReportingPeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'inventoryListing') then
  begin
    InventoryListingList.add(propValue as TFhirInventoryReportInventoryListing);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    Note := propValue as TFhirAnnotation;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInventoryReport.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'inventoryListing') then InventoryListingList.insertItem(index, propValue as TFhirInventoryReportInventoryListing)
  else inherited;
end;

function TFhirInventoryReport.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirInventoryReportStatusEnum[InventoryReportStatusNull], CODES_TFhirInventoryReportStatusEnum[InventoryReportStatusNull]) 
  else if (propName = 'countType') then result := TFhirEnum.create(SYSTEMS_TFhirInventoryCountTypeEnum[InventoryCountTypeNull], CODES_TFhirInventoryCountTypeEnum[InventoryCountTypeNull]) 
  else if (propName = 'operationType') then result := TFhirCodeableConcept.create()
  else if (propName = 'operationTypeReason') then result := TFhirCodeableConcept.create()
  else if (propName = 'reportedDateTime') then result := TFhirDateTime.create()
  else if (propName = 'reporter') then result := TFhirReference.create()
  else if (propName = 'reportingPeriod') then result := TFhirPeriod.create()
  else if (propName = 'inventoryListing') then result := InventoryListingList.new()
  else if (propName = 'note') then result := TFhirAnnotation.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirInventoryReport.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'countType') then result := 'code'
  else if (propName = 'operationType') then result := 'CodeableConcept'
  else if (propName = 'operationTypeReason') then result := 'CodeableConcept'
  else if (propName = 'reportedDateTime') then result := 'dateTime'
  else if (propName = 'reporter') then result := 'Reference'
  else if (propName = 'reportingPeriod') then result := 'Period'
  else if (propName = 'inventoryListing') then result := 'BackboneElement'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInventoryReport.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'countType') then CountTypeElement := nil
  else if (propName = 'operationType') then OperationTypeElement := nil
  else if (propName = 'operationTypeReason') then OperationTypeReasonElement := nil
  else if (propName = 'reportedDateTime') then ReportedDateTimeElement := nil
  else if (propName = 'reporter') then ReporterElement := nil
  else if (propName = 'reportingPeriod') then ReportingPeriodElement := nil
  else if (propName = 'inventoryListing') then deletePropertyValue('inventoryListing', InventoryListingList, value)
  else if (propName = 'note') then NoteElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInventoryReport.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirInventoryReportStatusEnum, CODES_TFhirInventoryReportStatusEnum, new)
  else if (propName = 'countType') then CountTypeElement := asEnum(SYSTEMS_TFhirInventoryCountTypeEnum, CODES_TFhirInventoryCountTypeEnum, new)
  else if (propName = 'operationType') then OperationTypeElement := new as TFhirCodeableConcept
  else if (propName = 'operationTypeReason') then OperationTypeReasonElement := new as TFhirCodeableConcept
  else if (propName = 'reportedDateTime') then ReportedDateTimeElement := asDateTime(new)
  else if (propName = 'reporter') then ReporterElement := new as TFhirReference
  else if (propName = 'reportingPeriod') then ReportingPeriodElement := new as TFhirPeriod
  else if (propName = 'inventoryListing') then replacePropertyValue('inventoryListing', InventoryListingList, existing, new)
  else if (propName = 'note') then NoteElement := new as TFhirAnnotation
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInventoryReport.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'inventoryListing') then InventoryListingList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInventoryReport.fhirType : string;
begin
  result := 'InventoryReport';
end;

function TFhirInventoryReport.Link : TFhirInventoryReport;
begin
  result := TFhirInventoryReport(inherited Link);
end;

function TFhirInventoryReport.Clone : TFhirInventoryReport;
begin
  result := TFhirInventoryReport(inherited Clone);
end;

function TFhirInventoryReport.equals(other : TObject) : boolean; 
var
  o : TFhirInventoryReport;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInventoryReport)) then
    result := false
  else
  begin
    o := TFhirInventoryReport(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(countTypeElement, o.countTypeElement, true) and compareDeep(operationTypeElement, o.operationTypeElement, true) and 
      compareDeep(operationTypeReasonElement, o.operationTypeReasonElement, true) and 
      compareDeep(reportedDateTimeElement, o.reportedDateTimeElement, true) and compareDeep(reporterElement, o.reporterElement, true) and 
      compareDeep(reportingPeriodElement, o.reportingPeriodElement, true) and compareDeep(inventoryListingList, o.inventoryListingList, true) and 
      compareDeep(noteElement, o.noteElement, true);
  end;
end;

function TFhirInventoryReport.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FCountType) and isEmptyProp(FOperationType) and isEmptyProp(FOperationTypeReason) and isEmptyProp(FReportedDateTime) and isEmptyProp(FReporter) and isEmptyProp(FReportingPeriod) and isEmptyProp(FinventoryListingList) and isEmptyProp(FNote);
end;

procedure TFhirInventoryReport.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('countType');
  fields.add('operationType');
  fields.add('operationTypeReason');
  fields.add('reportedDateTime');
  fields.add('reporter');
  fields.add('reportingPeriod');
  fields.add('inventoryListing');
  fields.add('note');
end;

function TFhirInventoryReport.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FInventoryListingList.sizeInBytes(magic));
end;

function TFhirInventoryReport.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirInventoryReport.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirInventoryReport.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirInventoryReport.GetStatusST : TFhirInventoryReportStatusEnum;
begin
  if FStatus = nil then
    result := TFhirInventoryReportStatusEnum(0)
  else
    result := TFhirInventoryReportStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirInventoryReportStatusEnum, FStatus.value));
end;

procedure TFhirInventoryReport.SetStatusST(value : TFhirInventoryReportStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirInventoryReportStatusEnum[value], CODES_TFhirInventoryReportStatusEnum[value]);
end;

procedure TFhirInventoryReport.SetCountType(value : TFhirEnum);
begin
  FCountType.free;
  FCountType := value;
end;

function TFhirInventoryReport.GetCountTypeST : TFhirInventoryCountTypeEnum;
begin
  if FCountType = nil then
    result := TFhirInventoryCountTypeEnum(0)
  else
    result := TFhirInventoryCountTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirInventoryCountTypeEnum, FCountType.value));
end;

procedure TFhirInventoryReport.SetCountTypeST(value : TFhirInventoryCountTypeEnum);
begin
  if ord(value) = 0 then
    CountTypeElement := nil
  else
    CountTypeElement := TFhirEnum.create(SYSTEMS_TFhirInventoryCountTypeEnum[value], CODES_TFhirInventoryCountTypeEnum[value]);
end;

procedure TFhirInventoryReport.SetOperationType(value : TFhirCodeableConcept);
begin
  FOperationType.free;
  FOperationType := value;
end;

procedure TFhirInventoryReport.SetOperationTypeReason(value : TFhirCodeableConcept);
begin
  FOperationTypeReason.free;
  FOperationTypeReason := value;
end;

procedure TFhirInventoryReport.SetReportedDateTime(value : TFhirDateTime);
begin
  FReportedDateTime.free;
  FReportedDateTime := value;
end;

function TFhirInventoryReport.GetReportedDateTimeST : TFslDateTime;
begin
  if FReportedDateTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FReportedDateTime.value;
end;

procedure TFhirInventoryReport.SetReportedDateTimeST(value : TFslDateTime);
begin
  if FReportedDateTime = nil then
    FReportedDateTime := TFhirDateTime.create;
  FReportedDateTime.value := value
end;

procedure TFhirInventoryReport.SetReporter(value : TFhirReference);
begin
  FReporter.free;
  FReporter := value;
end;

procedure TFhirInventoryReport.SetReportingPeriod(value : TFhirPeriod);
begin
  FReportingPeriod.free;
  FReportingPeriod := value;
end;

function TFhirInventoryReport.GetInventoryListingList : TFhirInventoryReportInventoryListingList;
begin
  if FInventoryListingList = nil then
    FInventoryListingList := TFhirInventoryReportInventoryListingList.Create;
  result := FInventoryListingList;
end;

function TFhirInventoryReport.GetHasInventoryListingList : boolean;
begin
  result := (FInventoryListingList <> nil) and (FInventoryListingList.count > 0);
end;

procedure TFhirInventoryReport.SetNote(value : TFhirAnnotation);
begin
  FNote.free;
  FNote := value;
end;

{ TFhirInventoryReportListEnumerator }

constructor TFhirInventoryReportListEnumerator.Create(list : TFhirInventoryReportList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInventoryReportListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInventoryReportListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInventoryReportListEnumerator.GetCurrent : TFhirInventoryReport;
begin
  Result := FList[FIndex];
end;

function TFhirInventoryReportListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirInventoryReportList }

function TFhirInventoryReportList.AddItem(value: TFhirInventoryReport): TFhirInventoryReport;
begin
  assert(value.ClassName = 'TFhirInventoryReport', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInventoryReport');
  add(value);
  result := value;
end;

function TFhirInventoryReportList.Append: TFhirInventoryReport;
begin
  result := TFhirInventoryReport.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInventoryReportList.ClearItems;
begin
  Clear;
end;

function TFhirInventoryReportList.GetEnumerator : TFhirInventoryReportListEnumerator;
begin
  result := TFhirInventoryReportListEnumerator.Create(self.link);
end;

function TFhirInventoryReportList.Clone: TFhirInventoryReportList;
begin
  result := TFhirInventoryReportList(inherited Clone);
end;

function TFhirInventoryReportList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInventoryReportList.GetItemN(index: Integer): TFhirInventoryReport;
begin
  result := TFhirInventoryReport(ObjectByIndex[index]);
end;

function TFhirInventoryReportList.ItemClass: TFslObjectClass;
begin
  result := TFhirInventoryReport;
end;
function TFhirInventoryReportList.IndexOf(value: TFhirInventoryReport): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInventoryReportList.Insert(index: Integer): TFhirInventoryReport;
begin
  result := TFhirInventoryReport.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInventoryReportList.InsertItem(index: Integer; value: TFhirInventoryReport);
begin
  assert(value is TFhirInventoryReport);
  Inherited Insert(index, value);
end;

function TFhirInventoryReportList.Item(index: Integer): TFhirInventoryReport;
begin
  result := TFhirInventoryReport(ObjectByIndex[index]);
end;

function TFhirInventoryReportList.Link: TFhirInventoryReportList;
begin
  result := TFhirInventoryReportList(inherited Link);
end;

procedure TFhirInventoryReportList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInventoryReportList.SetItemByIndex(index: Integer; value: TFhirInventoryReport);
begin
  assert(value is TFhirInventoryReport);
  FhirInventoryReports[index] := value;
end;

procedure TFhirInventoryReportList.SetItemN(index: Integer; value: TFhirInventoryReport);
begin
  assert(value is TFhirInventoryReport);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_INVENTORYREPORT}
{$IFDEF FHIR_LINKAGE}
{ TFhirLinkageItem }

constructor TFhirLinkageItem.Create;
begin
  inherited;
end;

destructor TFhirLinkageItem.Destroy;
begin
  FType_.free;
  FResource.free;
  inherited;
end;

procedure TFhirLinkageItem.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirLinkageItem(oSource).type_Element.Clone;
  resource := TFhirLinkageItem(oSource).resource.Clone;
end;

procedure TFhirLinkageItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
end;

procedure TFhirLinkageItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'resource', 'Reference', false, TFhirReference, FResource.Link));
end;

function TFhirLinkageItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirLinkageTypeEnum, CODES_TFhirLinkageTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    Resource := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirLinkageItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirLinkageItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirLinkageTypeEnum[LinkageTypeNull], CODES_TFhirLinkageTypeEnum[LinkageTypeNull]) 
  else if (propName = 'resource') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirLinkageItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'resource') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirLinkageItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'resource') then ResourceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirLinkageItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirLinkageTypeEnum, CODES_TFhirLinkageTypeEnum, new)
  else if (propName = 'resource') then ResourceElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirLinkageItem.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirLinkageItem.fhirType : string;
begin
  result := 'Linkage.item';
end;

function TFhirLinkageItem.Link : TFhirLinkageItem;
begin
  result := TFhirLinkageItem(inherited Link);
end;

function TFhirLinkageItem.Clone : TFhirLinkageItem;
begin
  result := TFhirLinkageItem(inherited Clone);
end;

function TFhirLinkageItem.equals(other : TObject) : boolean; 
var
  o : TFhirLinkageItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirLinkageItem)) then
    result := false
  else
  begin
    o := TFhirLinkageItem(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(resourceElement, o.resourceElement, true);
  end;
end;

function TFhirLinkageItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FResource);
end;

procedure TFhirLinkageItem.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('resource');
end;

function TFhirLinkageItem.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirLinkageItem.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirLinkageItem.GetType_ST : TFhirLinkageTypeEnum;
begin
  if FType_ = nil then
    result := TFhirLinkageTypeEnum(0)
  else
    result := TFhirLinkageTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirLinkageTypeEnum, FType_.value));
end;

procedure TFhirLinkageItem.SetType_ST(value : TFhirLinkageTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirLinkageTypeEnum[value], CODES_TFhirLinkageTypeEnum[value]);
end;

procedure TFhirLinkageItem.SetResource(value : TFhirReference);
begin
  FResource.free;
  FResource := value;
end;

{ TFhirLinkageItemListEnumerator }

constructor TFhirLinkageItemListEnumerator.Create(list : TFhirLinkageItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirLinkageItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirLinkageItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirLinkageItemListEnumerator.GetCurrent : TFhirLinkageItem;
begin
  Result := FList[FIndex];
end;

function TFhirLinkageItemListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirLinkageItemList }

function TFhirLinkageItemList.AddItem(value: TFhirLinkageItem): TFhirLinkageItem;
begin
  assert(value.ClassName = 'TFhirLinkageItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirLinkageItem');
  add(value);
  result := value;
end;

function TFhirLinkageItemList.Append: TFhirLinkageItem;
begin
  result := TFhirLinkageItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLinkageItemList.ClearItems;
begin
  Clear;
end;

function TFhirLinkageItemList.GetEnumerator : TFhirLinkageItemListEnumerator;
begin
  result := TFhirLinkageItemListEnumerator.Create(self.link);
end;

function TFhirLinkageItemList.Clone: TFhirLinkageItemList;
begin
  result := TFhirLinkageItemList(inherited Clone);
end;

function TFhirLinkageItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirLinkageItemList.GetItemN(index: Integer): TFhirLinkageItem;
begin
  result := TFhirLinkageItem(ObjectByIndex[index]);
end;

function TFhirLinkageItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirLinkageItem;
end;
function TFhirLinkageItemList.IndexOf(value: TFhirLinkageItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirLinkageItemList.Insert(index: Integer): TFhirLinkageItem;
begin
  result := TFhirLinkageItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLinkageItemList.InsertItem(index: Integer; value: TFhirLinkageItem);
begin
  assert(value is TFhirLinkageItem);
  Inherited Insert(index, value);
end;

function TFhirLinkageItemList.Item(index: Integer): TFhirLinkageItem;
begin
  result := TFhirLinkageItem(ObjectByIndex[index]);
end;

function TFhirLinkageItemList.Link: TFhirLinkageItemList;
begin
  result := TFhirLinkageItemList(inherited Link);
end;

procedure TFhirLinkageItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirLinkageItemList.SetItemByIndex(index: Integer; value: TFhirLinkageItem);
begin
  assert(value is TFhirLinkageItem);
  FhirLinkageItems[index] := value;
end;

procedure TFhirLinkageItemList.SetItemN(index: Integer; value: TFhirLinkageItem);
begin
  assert(value is TFhirLinkageItem);
  ObjectByIndex[index] := value;
end;

{ TFhirLinkage }

constructor TFhirLinkage.Create;
begin
  inherited;
end;

destructor TFhirLinkage.Destroy;
begin
  FActive.free;
  FAuthor.free;
  FItemList.Free;
  inherited;
end;

procedure TFhirLinkage.Assign(oSource : TFslObject);
begin
  inherited;
  activeElement := TFhirLinkage(oSource).activeElement.Clone;
  author := TFhirLinkage(oSource).author.Clone;
  if (TFhirLinkage(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirLinkageItemList.Create;
    FItemList.Assign(TFhirLinkage(oSource).FItemList);
  end;
end;

function TFhirLinkage.GetResourceType : TFhirResourceType;
begin
  result := frtLinkage;
end;

procedure TFhirLinkage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirLinkage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', false, TFhirReference, FAuthor.Link));
  oList.add(TFHIRProperty.create(self, 'item', 'BackboneElement', true, TFhirLinkageItem, FItemList.Link));
end;

function TFhirLinkage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirLinkageItem);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirLinkage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirLinkageItem)
  else inherited;
end;

function TFhirLinkage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'active') then result := TFhirBoolean.create()
  else if (propName = 'author') then result := TFhirReference.create()
  else if (propName = 'item') then result := ItemList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirLinkage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'active') then result := 'boolean'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'item') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirLinkage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'active') then ActiveElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirLinkage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'active') then ActiveElement := asBoolean(new)
  else if (propName = 'author') then AuthorElement := new as TFhirReference
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirLinkage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'item') then ItemList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirLinkage.fhirType : string;
begin
  result := 'Linkage';
end;

function TFhirLinkage.Link : TFhirLinkage;
begin
  result := TFhirLinkage(inherited Link);
end;

function TFhirLinkage.Clone : TFhirLinkage;
begin
  result := TFhirLinkage(inherited Clone);
end;

function TFhirLinkage.equals(other : TObject) : boolean; 
var
  o : TFhirLinkage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirLinkage)) then
    result := false
  else
  begin
    o := TFhirLinkage(other);
    result := compareDeep(activeElement, o.activeElement, true) and compareDeep(authorElement, o.authorElement, true) and 
      compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirLinkage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FActive) and isEmptyProp(FAuthor) and isEmptyProp(FitemList);
end;

procedure TFhirLinkage.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('active');
  fields.add('author');
  fields.add('item');
end;

function TFhirLinkage.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FItemList.sizeInBytes(magic));
end;

procedure TFhirLinkage.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

function TFhirLinkage.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirLinkage.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

procedure TFhirLinkage.SetAuthor(value : TFhirReference);
begin
  FAuthor.free;
  FAuthor := value;
end;

function TFhirLinkage.GetItemList : TFhirLinkageItemList;
begin
  if FItemList = nil then
    FItemList := TFhirLinkageItemList.Create;
  result := FItemList;
end;

function TFhirLinkage.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

{ TFhirLinkageListEnumerator }

constructor TFhirLinkageListEnumerator.Create(list : TFhirLinkageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirLinkageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirLinkageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirLinkageListEnumerator.GetCurrent : TFhirLinkage;
begin
  Result := FList[FIndex];
end;

function TFhirLinkageListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirLinkageList }

function TFhirLinkageList.AddItem(value: TFhirLinkage): TFhirLinkage;
begin
  assert(value.ClassName = 'TFhirLinkage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirLinkage');
  add(value);
  result := value;
end;

function TFhirLinkageList.Append: TFhirLinkage;
begin
  result := TFhirLinkage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLinkageList.ClearItems;
begin
  Clear;
end;

function TFhirLinkageList.GetEnumerator : TFhirLinkageListEnumerator;
begin
  result := TFhirLinkageListEnumerator.Create(self.link);
end;

function TFhirLinkageList.Clone: TFhirLinkageList;
begin
  result := TFhirLinkageList(inherited Clone);
end;

function TFhirLinkageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirLinkageList.GetItemN(index: Integer): TFhirLinkage;
begin
  result := TFhirLinkage(ObjectByIndex[index]);
end;

function TFhirLinkageList.ItemClass: TFslObjectClass;
begin
  result := TFhirLinkage;
end;
function TFhirLinkageList.IndexOf(value: TFhirLinkage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirLinkageList.Insert(index: Integer): TFhirLinkage;
begin
  result := TFhirLinkage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLinkageList.InsertItem(index: Integer; value: TFhirLinkage);
begin
  assert(value is TFhirLinkage);
  Inherited Insert(index, value);
end;

function TFhirLinkageList.Item(index: Integer): TFhirLinkage;
begin
  result := TFhirLinkage(ObjectByIndex[index]);
end;

function TFhirLinkageList.Link: TFhirLinkageList;
begin
  result := TFhirLinkageList(inherited Link);
end;

procedure TFhirLinkageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirLinkageList.SetItemByIndex(index: Integer; value: TFhirLinkage);
begin
  assert(value is TFhirLinkage);
  FhirLinkages[index] := value;
end;

procedure TFhirLinkageList.SetItemN(index: Integer; value: TFhirLinkage);
begin
  assert(value is TFhirLinkage);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
{ TFhirListEntry }

constructor TFhirListEntry.Create;
begin
  inherited;
end;

destructor TFhirListEntry.Destroy;
begin
  FFlag.free;
  FDeleted.free;
  FDate.free;
  FItem.free;
  inherited;
end;

procedure TFhirListEntry.Assign(oSource : TFslObject);
begin
  inherited;
  flag := TFhirListEntry(oSource).flag.Clone;
  deletedElement := TFhirListEntry(oSource).deletedElement.Clone;
  dateElement := TFhirListEntry(oSource).dateElement.Clone;
  item := TFhirListEntry(oSource).item.Clone;
end;

procedure TFhirListEntry.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'flag') Then
     list.add(self.link, 'flag', FFlag.Link);
  if (child_name = 'deleted') Then
     list.add(self.link, 'deleted', FDeleted.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
end;

procedure TFhirListEntry.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'flag', 'CodeableConcept', false, TFhirCodeableConcept, FFlag.Link));
  oList.add(TFHIRProperty.create(self, 'deleted', 'boolean', false, TFhirBoolean, FDeleted.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'item', 'Reference', false, TFhirReference, FItem.Link));
end;

function TFhirListEntry.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'flag') then
  begin
    Flag := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'deleted') then
  begin
    DeletedElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    Item := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirListEntry.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirListEntry.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'flag') then result := TFhirCodeableConcept.create()
  else if (propName = 'deleted') then result := TFhirBoolean.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'item') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirListEntry.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'flag') then result := 'CodeableConcept'
  else if (propName = 'deleted') then result := 'boolean'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'item') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirListEntry.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'flag') then FlagElement := nil
  else if (propName = 'deleted') then DeletedElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'item') then ItemElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirListEntry.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'flag') then FlagElement := new as TFhirCodeableConcept
  else if (propName = 'deleted') then DeletedElement := asBoolean(new)
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'item') then ItemElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirListEntry.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirListEntry.fhirType : string;
begin
  result := 'List.entry';
end;

function TFhirListEntry.Link : TFhirListEntry;
begin
  result := TFhirListEntry(inherited Link);
end;

function TFhirListEntry.Clone : TFhirListEntry;
begin
  result := TFhirListEntry(inherited Clone);
end;

function TFhirListEntry.equals(other : TObject) : boolean; 
var
  o : TFhirListEntry;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirListEntry)) then
    result := false
  else
  begin
    o := TFhirListEntry(other);
    result := compareDeep(flagElement, o.flagElement, true) and compareDeep(deletedElement, o.deletedElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(itemElement, o.itemElement, true);
  end;
end;

function TFhirListEntry.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFlag) and isEmptyProp(FDeleted) and isEmptyProp(FDate) and isEmptyProp(FItem);
end;

procedure TFhirListEntry.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('flag');
  fields.add('deleted');
  fields.add('date');
  fields.add('item');
end;

function TFhirListEntry.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirListEntry.SetFlag(value : TFhirCodeableConcept);
begin
  FFlag.free;
  FFlag := value;
end;

procedure TFhirListEntry.SetDeleted(value : TFhirBoolean);
begin
  FDeleted.free;
  FDeleted := value;
end;

function TFhirListEntry.GetDeletedST : Boolean;
begin
  if FDeleted = nil then
    result := false
  else
    result := FDeleted.value;
end;

procedure TFhirListEntry.SetDeletedST(value : Boolean);
begin
  if FDeleted = nil then
    FDeleted := TFhirBoolean.create;
  FDeleted.value := value
end;

procedure TFhirListEntry.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirListEntry.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirListEntry.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirListEntry.SetItem(value : TFhirReference);
begin
  FItem.free;
  FItem := value;
end;

{ TFhirListEntryListEnumerator }

constructor TFhirListEntryListEnumerator.Create(list : TFhirListEntryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirListEntryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirListEntryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirListEntryListEnumerator.GetCurrent : TFhirListEntry;
begin
  Result := FList[FIndex];
end;

function TFhirListEntryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirListEntryList }

function TFhirListEntryList.AddItem(value: TFhirListEntry): TFhirListEntry;
begin
  assert(value.ClassName = 'TFhirListEntry', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirListEntry');
  add(value);
  result := value;
end;

function TFhirListEntryList.Append: TFhirListEntry;
begin
  result := TFhirListEntry.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirListEntryList.ClearItems;
begin
  Clear;
end;

function TFhirListEntryList.GetEnumerator : TFhirListEntryListEnumerator;
begin
  result := TFhirListEntryListEnumerator.Create(self.link);
end;

function TFhirListEntryList.Clone: TFhirListEntryList;
begin
  result := TFhirListEntryList(inherited Clone);
end;

function TFhirListEntryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirListEntryList.GetItemN(index: Integer): TFhirListEntry;
begin
  result := TFhirListEntry(ObjectByIndex[index]);
end;

function TFhirListEntryList.ItemClass: TFslObjectClass;
begin
  result := TFhirListEntry;
end;
function TFhirListEntryList.IndexOf(value: TFhirListEntry): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirListEntryList.Insert(index: Integer): TFhirListEntry;
begin
  result := TFhirListEntry.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirListEntryList.InsertItem(index: Integer; value: TFhirListEntry);
begin
  assert(value is TFhirListEntry);
  Inherited Insert(index, value);
end;

function TFhirListEntryList.Item(index: Integer): TFhirListEntry;
begin
  result := TFhirListEntry(ObjectByIndex[index]);
end;

function TFhirListEntryList.Link: TFhirListEntryList;
begin
  result := TFhirListEntryList(inherited Link);
end;

procedure TFhirListEntryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirListEntryList.SetItemByIndex(index: Integer; value: TFhirListEntry);
begin
  assert(value is TFhirListEntry);
  FhirListEntries[index] := value;
end;

procedure TFhirListEntryList.SetItemN(index: Integer; value: TFhirListEntry);
begin
  assert(value is TFhirListEntry);
  ObjectByIndex[index] := value;
end;

{ TFhirList }

constructor TFhirList.Create;
begin
  inherited;
end;

destructor TFhirList.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FMode.free;
  FTitle.free;
  FCode.free;
  FSubject.free;
  FEncounter.free;
  FDate.free;
  FSource.free;
  FOrderedBy.free;
  FNoteList.Free;
  FEntryList.Free;
  FEmptyReason.free;
  inherited;
end;

procedure TFhirList.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirList(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirList(oSource).FIdentifierList);
  end;
  statusElement := TFhirList(oSource).statusElement.Clone;
  modeElement := TFhirList(oSource).modeElement.Clone;
  titleElement := TFhirList(oSource).titleElement.Clone;
  code := TFhirList(oSource).code.Clone;
  subject := TFhirList(oSource).subject.Clone;
  encounter := TFhirList(oSource).encounter.Clone;
  dateElement := TFhirList(oSource).dateElement.Clone;
  source := TFhirList(oSource).source.Clone;
  orderedBy := TFhirList(oSource).orderedBy.Clone;
  if (TFhirList(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirList(oSource).FNoteList);
  end;
  if (TFhirList(oSource).FEntryList = nil) then
  begin
    FEntryList.free;
    FEntryList := nil;
  end
  else
  begin
    if FEntryList = nil then
      FEntryList := TFhirListEntryList.Create;
    FEntryList.Assign(TFhirList(oSource).FEntryList);
  end;
  emptyReason := TFhirList(oSource).emptyReason.Clone;
end;

function TFhirList.GetResourceType : TFhirResourceType;
begin
  result := frtList;
end;

procedure TFhirList.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'orderedBy') Then
     list.add(self.link, 'orderedBy', FOrderedBy.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'entry') Then
    list.addAll(self, 'entry', FEntryList);
  if (child_name = 'emptyReason') Then
     list.add(self.link, 'emptyReason', FEmptyReason.Link);
end;

procedure TFhirList.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFhirEnum, FMode.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', false, TFhirReference, FSource.Link));
  oList.add(TFHIRProperty.create(self, 'orderedBy', 'CodeableConcept', false, TFhirCodeableConcept, FOrderedBy.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'entry', 'BackboneElement', true, TFhirListEntry, FEntryList.Link));
  oList.add(TFHIRProperty.create(self, 'emptyReason', 'CodeableConcept', false, TFhirCodeableConcept, FEmptyReason.Link));
end;

function TFhirList.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirListStatusEnum, CODES_TFhirListStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirListModeEnum, CODES_TFhirListModeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'orderedBy') then
  begin
    OrderedBy := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'entry') then
  begin
    EntryList.add(propValue as TFhirListEntry);
    result := propValue;
  end
  else if (propName = 'emptyReason') then
  begin
    EmptyReason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirList.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'entry') then EntryList.insertItem(index, propValue as TFhirListEntry)
  else inherited;
end;

function TFhirList.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirListStatusEnum[ListStatusNull], CODES_TFhirListStatusEnum[ListStatusNull]) 
  else if (propName = 'mode') then result := TFhirEnum.create(SYSTEMS_TFhirListModeEnum[ListModeNull], CODES_TFhirListModeEnum[ListModeNull]) 
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'source') then result := TFhirReference.create()
  else if (propName = 'orderedBy') then result := TFhirCodeableConcept.create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'entry') then result := EntryList.new()
  else if (propName = 'emptyReason') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirList.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'mode') then result := 'code'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'source') then result := 'Reference'
  else if (propName = 'orderedBy') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'entry') then result := 'BackboneElement'
  else if (propName = 'emptyReason') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirList.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'mode') then ModeElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'orderedBy') then OrderedByElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'entry') then deletePropertyValue('entry', EntryList, value)
  else if (propName = 'emptyReason') then EmptyReasonElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirList.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirListStatusEnum, CODES_TFhirListStatusEnum, new)
  else if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirListModeEnum, CODES_TFhirListModeEnum, new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'source') then SourceElement := new as TFhirReference
  else if (propName = 'orderedBy') then OrderedByElement := new as TFhirCodeableConcept
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'entry') then replacePropertyValue('entry', EntryList, existing, new)
  else if (propName = 'emptyReason') then EmptyReasonElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirList.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'entry') then EntryList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirList.fhirType : string;
begin
  result := 'List';
end;

function TFhirList.Link : TFhirList;
begin
  result := TFhirList(inherited Link);
end;

function TFhirList.Clone : TFhirList;
begin
  result := TFhirList(inherited Clone);
end;

function TFhirList.equals(other : TObject) : boolean; 
var
  o : TFhirList;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirList)) then
    result := false
  else
  begin
    o := TFhirList(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(modeElement, o.modeElement, true) and compareDeep(titleElement, o.titleElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(sourceElement, o.sourceElement, true) and compareDeep(orderedByElement, o.orderedByElement, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(entryList, o.entryList, true) and 
      compareDeep(emptyReasonElement, o.emptyReasonElement, true);
  end;
end;

function TFhirList.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FMode) and isEmptyProp(FTitle) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FDate) and isEmptyProp(FSource) and isEmptyProp(FOrderedBy) and isEmptyProp(FnoteList) and isEmptyProp(FentryList) and isEmptyProp(FEmptyReason);
end;

procedure TFhirList.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('mode');
  fields.add('title');
  fields.add('code');
  fields.add('subject');
  fields.add('encounter');
  fields.add('date');
  fields.add('source');
  fields.add('orderedBy');
  fields.add('note');
  fields.add('entry');
  fields.add('emptyReason');
end;

function TFhirList.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FEntryList.sizeInBytes(magic));
end;

function TFhirList.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirList.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirList.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirList.GetStatusST : TFhirListStatusEnum;
begin
  if FStatus = nil then
    result := TFhirListStatusEnum(0)
  else
    result := TFhirListStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirListStatusEnum, FStatus.value));
end;

procedure TFhirList.SetStatusST(value : TFhirListStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirListStatusEnum[value], CODES_TFhirListStatusEnum[value]);
end;

procedure TFhirList.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

function TFhirList.GetModeST : TFhirListModeEnum;
begin
  if FMode = nil then
    result := TFhirListModeEnum(0)
  else
    result := TFhirListModeEnum(StringArrayIndexOfSensitive(CODES_TFhirListModeEnum, FMode.value));
end;

procedure TFhirList.SetModeST(value : TFhirListModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirListModeEnum[value], CODES_TFhirListModeEnum[value]);
end;

procedure TFhirList.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirList.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirList.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirList.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirList.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirList.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirList.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirList.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirList.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirList.SetSource(value : TFhirReference);
begin
  FSource.free;
  FSource := value;
end;

procedure TFhirList.SetOrderedBy(value : TFhirCodeableConcept);
begin
  FOrderedBy.free;
  FOrderedBy := value;
end;

function TFhirList.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirList.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirList.GetEntryList : TFhirListEntryList;
begin
  if FEntryList = nil then
    FEntryList := TFhirListEntryList.Create;
  result := FEntryList;
end;

function TFhirList.GetHasEntryList : boolean;
begin
  result := (FEntryList <> nil) and (FEntryList.count > 0);
end;

procedure TFhirList.SetEmptyReason(value : TFhirCodeableConcept);
begin
  FEmptyReason.free;
  FEmptyReason := value;
end;

{ TFhirListListEnumerator }

constructor TFhirListListEnumerator.Create(list : TFhirListList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirListListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirListListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirListListEnumerator.GetCurrent : TFhirList;
begin
  Result := FList[FIndex];
end;

function TFhirListListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirListList }

function TFhirListList.AddItem(value: TFhirList): TFhirList;
begin
  assert(value.ClassName = 'TFhirList', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirList');
  add(value);
  result := value;
end;

function TFhirListList.Append: TFhirList;
begin
  result := TFhirList.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirListList.ClearItems;
begin
  Clear;
end;

function TFhirListList.GetEnumerator : TFhirListListEnumerator;
begin
  result := TFhirListListEnumerator.Create(self.link);
end;

function TFhirListList.Clone: TFhirListList;
begin
  result := TFhirListList(inherited Clone);
end;

function TFhirListList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirListList.GetItemN(index: Integer): TFhirList;
begin
  result := TFhirList(ObjectByIndex[index]);
end;

function TFhirListList.ItemClass: TFslObjectClass;
begin
  result := TFhirList;
end;
function TFhirListList.IndexOf(value: TFhirList): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirListList.Insert(index: Integer): TFhirList;
begin
  result := TFhirList.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirListList.InsertItem(index: Integer; value: TFhirList);
begin
  assert(value is TFhirList);
  Inherited Insert(index, value);
end;

function TFhirListList.Item(index: Integer): TFhirList;
begin
  result := TFhirList(ObjectByIndex[index]);
end;

function TFhirListList.Link: TFhirListList;
begin
  result := TFhirListList(inherited Link);
end;

procedure TFhirListList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirListList.SetItemByIndex(index: Integer; value: TFhirList);
begin
  assert(value is TFhirList);
  FhirLists[index] := value;
end;

procedure TFhirListList.SetItemN(index: Integer; value: TFhirList);
begin
  assert(value is TFhirList);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_LIST}
{$IFDEF FHIR_MEASUREREPORT}
{ TFhirMeasureReportGroup }

constructor TFhirMeasureReportGroup.Create;
begin
  inherited;
end;

destructor TFhirMeasureReportGroup.Destroy;
begin
  FCode.free;
  FPopulationList.Free;
  FMeasureScore.free;
  FStratifierList.Free;
  inherited;
end;

procedure TFhirMeasureReportGroup.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMeasureReportGroup(oSource).code.Clone;
  if (TFhirMeasureReportGroup(oSource).FPopulationList = nil) then
  begin
    FPopulationList.free;
    FPopulationList := nil;
  end
  else
  begin
    if FPopulationList = nil then
      FPopulationList := TFhirMeasureReportGroupPopulationList.Create;
    FPopulationList.Assign(TFhirMeasureReportGroup(oSource).FPopulationList);
  end;
  measureScore := TFhirMeasureReportGroup(oSource).measureScore.Clone;
  if (TFhirMeasureReportGroup(oSource).FStratifierList = nil) then
  begin
    FStratifierList.free;
    FStratifierList := nil;
  end
  else
  begin
    if FStratifierList = nil then
      FStratifierList := TFhirMeasureReportGroupStratifierList.Create;
    FStratifierList.Assign(TFhirMeasureReportGroup(oSource).FStratifierList);
  end;
end;

procedure TFhirMeasureReportGroup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'population') Then
    list.addAll(self, 'population', FPopulationList);
  if (child_name = 'measureScore[x]') or (child_name = 'measureScore') Then
     list.add(self.link, 'measureScore[x]', FMeasureScore.Link);
  if (child_name = 'stratifier') Then
    list.addAll(self, 'stratifier', FStratifierList);
end;

procedure TFhirMeasureReportGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'population', 'BackboneElement', true, TFhirMeasureReportGroupPopulation, FPopulationList.Link));
  oList.add(TFHIRProperty.create(self, 'measureScore[x]', 'Quantity|dateTime|CodeableConcept|Period|Range|Duration', false, TFhirDataType, FMeasureScore.Link));
  oList.add(TFHIRProperty.create(self, 'stratifier', 'BackboneElement', true, TFhirMeasureReportGroupStratifier, FStratifierList.Link));
end;

function TFhirMeasureReportGroup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'population') then
  begin
    PopulationList.add(propValue as TFhirMeasureReportGroupPopulation);
    result := propValue;
  end
  else if (isMatchingName(propName, 'measureScore', ['Quantity', 'DateTime', 'CodeableConcept', 'Period', 'Range', 'Duration'])) then
  begin
    MeasureScore := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'stratifier') then
  begin
    StratifierList.add(propValue as TFhirMeasureReportGroupStratifier);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureReportGroup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'population') then PopulationList.insertItem(index, propValue as TFhirMeasureReportGroupPopulation)
  else if (propName = 'stratifier') then StratifierList.insertItem(index, propValue as TFhirMeasureReportGroupStratifier)
  else inherited;
end;

function TFhirMeasureReportGroup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'population') then result := PopulationList.new()
  else if (isMatchingName(propName, 'measureScore', ['Quantity', 'DateTime', 'CodeableConcept', 'Period', 'Range', 'Duration'])) then raise EFHIRException.create('Cannot make property MeasureScore')
  else if (propName = 'stratifier') then result := StratifierList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReportGroup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'population') then result := 'BackboneElement'
  else if (propName = 'measureScore[x]') then result := 'Quantity|dateTime|CodeableConcept|Period|Range|Duration'
  else if (propName = 'stratifier') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReportGroup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'population') then deletePropertyValue('population', PopulationList, value)
  else if (isMatchingName(propName, 'measureScore', ['Quantity', 'DateTime', 'CodeableConcept', 'Period', 'Range', 'Duration'])) then MeasureScoreElement := nil
  else if (propName = 'stratifier') then deletePropertyValue('stratifier', StratifierList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReportGroup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'population') then replacePropertyValue('population', PopulationList, existing, new)
  else if (isMatchingName(propName, 'measureScore', ['Quantity', 'DateTime', 'CodeableConcept', 'Period', 'Range', 'Duration'])) then MeasureScoreElement := new as TFhirDataType
  else if (propName = 'stratifier') then replacePropertyValue('stratifier', StratifierList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReportGroup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'population') then PopulationList.move(source, destination)
  else if (propName = 'stratifier') then StratifierList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReportGroup.fhirType : string;
begin
  result := 'MeasureReport.group';
end;

function TFhirMeasureReportGroup.Link : TFhirMeasureReportGroup;
begin
  result := TFhirMeasureReportGroup(inherited Link);
end;

function TFhirMeasureReportGroup.Clone : TFhirMeasureReportGroup;
begin
  result := TFhirMeasureReportGroup(inherited Clone);
end;

function TFhirMeasureReportGroup.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureReportGroup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReportGroup)) then
    result := false
  else
  begin
    o := TFhirMeasureReportGroup(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(populationList, o.populationList, true) and 
      compareDeep(measureScoreElement, o.measureScoreElement, true) and compareDeep(stratifierList, o.stratifierList, true);
  end;
end;

function TFhirMeasureReportGroup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FpopulationList) and isEmptyProp(FMeasureScore) and isEmptyProp(FstratifierList);
end;

procedure TFhirMeasureReportGroup.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('population');
  fields.add('measureScore[x]');
  fields.add('stratifier');
end;

function TFhirMeasureReportGroup.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FPopulationList.sizeInBytes(magic));
  inc(result, FStratifierList.sizeInBytes(magic));
end;

procedure TFhirMeasureReportGroup.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

function TFhirMeasureReportGroup.GetPopulationList : TFhirMeasureReportGroupPopulationList;
begin
  if FPopulationList = nil then
    FPopulationList := TFhirMeasureReportGroupPopulationList.Create;
  result := FPopulationList;
end;

function TFhirMeasureReportGroup.GetHasPopulationList : boolean;
begin
  result := (FPopulationList <> nil) and (FPopulationList.count > 0);
end;

procedure TFhirMeasureReportGroup.SetMeasureScore(value : TFhirDataType);
begin
  FMeasureScore.free;
  FMeasureScore := value;
end;

function TFhirMeasureReportGroup.GetStratifierList : TFhirMeasureReportGroupStratifierList;
begin
  if FStratifierList = nil then
    FStratifierList := TFhirMeasureReportGroupStratifierList.Create;
  result := FStratifierList;
end;

function TFhirMeasureReportGroup.GetHasStratifierList : boolean;
begin
  result := (FStratifierList <> nil) and (FStratifierList.count > 0);
end;

{ TFhirMeasureReportGroupListEnumerator }

constructor TFhirMeasureReportGroupListEnumerator.Create(list : TFhirMeasureReportGroupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportGroupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportGroupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportGroupListEnumerator.GetCurrent : TFhirMeasureReportGroup;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportGroupListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMeasureReportGroupList }

function TFhirMeasureReportGroupList.AddItem(value: TFhirMeasureReportGroup): TFhirMeasureReportGroup;
begin
  assert(value.ClassName = 'TFhirMeasureReportGroup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReportGroup');
  add(value);
  result := value;
end;

function TFhirMeasureReportGroupList.Append: TFhirMeasureReportGroup;
begin
  result := TFhirMeasureReportGroup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportGroupList.GetEnumerator : TFhirMeasureReportGroupListEnumerator;
begin
  result := TFhirMeasureReportGroupListEnumerator.Create(self.link);
end;

function TFhirMeasureReportGroupList.Clone: TFhirMeasureReportGroupList;
begin
  result := TFhirMeasureReportGroupList(inherited Clone);
end;

function TFhirMeasureReportGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportGroupList.GetItemN(index: Integer): TFhirMeasureReportGroup;
begin
  result := TFhirMeasureReportGroup(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReportGroup;
end;
function TFhirMeasureReportGroupList.IndexOf(value: TFhirMeasureReportGroup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportGroupList.Insert(index: Integer): TFhirMeasureReportGroup;
begin
  result := TFhirMeasureReportGroup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupList.InsertItem(index: Integer; value: TFhirMeasureReportGroup);
begin
  assert(value is TFhirMeasureReportGroup);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportGroupList.Item(index: Integer): TFhirMeasureReportGroup;
begin
  result := TFhirMeasureReportGroup(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupList.Link: TFhirMeasureReportGroupList;
begin
  result := TFhirMeasureReportGroupList(inherited Link);
end;

procedure TFhirMeasureReportGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportGroupList.SetItemByIndex(index: Integer; value: TFhirMeasureReportGroup);
begin
  assert(value is TFhirMeasureReportGroup);
  FhirMeasureReportGroups[index] := value;
end;

procedure TFhirMeasureReportGroupList.SetItemN(index: Integer; value: TFhirMeasureReportGroup);
begin
  assert(value is TFhirMeasureReportGroup);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureReportGroupPopulation }

constructor TFhirMeasureReportGroupPopulation.Create;
begin
  inherited;
end;

destructor TFhirMeasureReportGroupPopulation.Destroy;
begin
  FCode.free;
  FCount.free;
  FSubjectResults.free;
  inherited;
end;

procedure TFhirMeasureReportGroupPopulation.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMeasureReportGroupPopulation(oSource).code.Clone;
  countElement := TFhirMeasureReportGroupPopulation(oSource).countElement.Clone;
  subjectResults := TFhirMeasureReportGroupPopulation(oSource).subjectResults.Clone;
end;

procedure TFhirMeasureReportGroupPopulation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'count') Then
     list.add(self.link, 'count', FCount.Link);
  if (child_name = 'subjectResults') Then
     list.add(self.link, 'subjectResults', FSubjectResults.Link);
end;

procedure TFhirMeasureReportGroupPopulation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'count', 'integer', false, TFhirInteger, FCount.Link));
  oList.add(TFHIRProperty.create(self, 'subjectResults', 'Reference', false, TFhirReference, FSubjectResults.Link));
end;

function TFhirMeasureReportGroupPopulation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'count') then
  begin
    CountElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'subjectResults') then
  begin
    SubjectResults := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureReportGroupPopulation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMeasureReportGroupPopulation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'count') then result := TFhirInteger.create()
  else if (propName = 'subjectResults') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReportGroupPopulation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'count') then result := 'integer'
  else if (propName = 'subjectResults') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReportGroupPopulation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'count') then CountElement := nil
  else if (propName = 'subjectResults') then SubjectResultsElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReportGroupPopulation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'count') then CountElement := asInteger(new)
  else if (propName = 'subjectResults') then SubjectResultsElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReportGroupPopulation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReportGroupPopulation.fhirType : string;
begin
  result := 'MeasureReport.group.population';
end;

function TFhirMeasureReportGroupPopulation.Link : TFhirMeasureReportGroupPopulation;
begin
  result := TFhirMeasureReportGroupPopulation(inherited Link);
end;

function TFhirMeasureReportGroupPopulation.Clone : TFhirMeasureReportGroupPopulation;
begin
  result := TFhirMeasureReportGroupPopulation(inherited Clone);
end;

function TFhirMeasureReportGroupPopulation.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureReportGroupPopulation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReportGroupPopulation)) then
    result := false
  else
  begin
    o := TFhirMeasureReportGroupPopulation(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(countElement, o.countElement, true) and 
      compareDeep(subjectResultsElement, o.subjectResultsElement, true);
  end;
end;

function TFhirMeasureReportGroupPopulation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FCount) and isEmptyProp(FSubjectResults);
end;

procedure TFhirMeasureReportGroupPopulation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('count');
  fields.add('subjectResults');
end;

function TFhirMeasureReportGroupPopulation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMeasureReportGroupPopulation.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirMeasureReportGroupPopulation.SetCount(value : TFhirInteger);
begin
  FCount.free;
  FCount := value;
end;

function TFhirMeasureReportGroupPopulation.GetCountST : String;
begin
  if FCount = nil then
    result := ''
  else
    result := FCount.value;
end;

procedure TFhirMeasureReportGroupPopulation.SetCountST(value : String);
begin
  if value <> '' then
  begin
    if FCount = nil then
      FCount := TFhirInteger.create;
    FCount.value := value
  end
  else if FCount <> nil then
    FCount.value := '';
end;

procedure TFhirMeasureReportGroupPopulation.SetSubjectResults(value : TFhirReference);
begin
  FSubjectResults.free;
  FSubjectResults := value;
end;

{ TFhirMeasureReportGroupPopulationListEnumerator }

constructor TFhirMeasureReportGroupPopulationListEnumerator.Create(list : TFhirMeasureReportGroupPopulationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportGroupPopulationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportGroupPopulationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportGroupPopulationListEnumerator.GetCurrent : TFhirMeasureReportGroupPopulation;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportGroupPopulationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMeasureReportGroupPopulationList }

function TFhirMeasureReportGroupPopulationList.AddItem(value: TFhirMeasureReportGroupPopulation): TFhirMeasureReportGroupPopulation;
begin
  assert(value.ClassName = 'TFhirMeasureReportGroupPopulation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReportGroupPopulation');
  add(value);
  result := value;
end;

function TFhirMeasureReportGroupPopulationList.Append: TFhirMeasureReportGroupPopulation;
begin
  result := TFhirMeasureReportGroupPopulation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupPopulationList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportGroupPopulationList.GetEnumerator : TFhirMeasureReportGroupPopulationListEnumerator;
begin
  result := TFhirMeasureReportGroupPopulationListEnumerator.Create(self.link);
end;

function TFhirMeasureReportGroupPopulationList.Clone: TFhirMeasureReportGroupPopulationList;
begin
  result := TFhirMeasureReportGroupPopulationList(inherited Clone);
end;

function TFhirMeasureReportGroupPopulationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportGroupPopulationList.GetItemN(index: Integer): TFhirMeasureReportGroupPopulation;
begin
  result := TFhirMeasureReportGroupPopulation(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupPopulationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReportGroupPopulation;
end;
function TFhirMeasureReportGroupPopulationList.IndexOf(value: TFhirMeasureReportGroupPopulation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportGroupPopulationList.Insert(index: Integer): TFhirMeasureReportGroupPopulation;
begin
  result := TFhirMeasureReportGroupPopulation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupPopulationList.InsertItem(index: Integer; value: TFhirMeasureReportGroupPopulation);
begin
  assert(value is TFhirMeasureReportGroupPopulation);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportGroupPopulationList.Item(index: Integer): TFhirMeasureReportGroupPopulation;
begin
  result := TFhirMeasureReportGroupPopulation(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupPopulationList.Link: TFhirMeasureReportGroupPopulationList;
begin
  result := TFhirMeasureReportGroupPopulationList(inherited Link);
end;

procedure TFhirMeasureReportGroupPopulationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportGroupPopulationList.SetItemByIndex(index: Integer; value: TFhirMeasureReportGroupPopulation);
begin
  assert(value is TFhirMeasureReportGroupPopulation);
  FhirMeasureReportGroupPopulations[index] := value;
end;

procedure TFhirMeasureReportGroupPopulationList.SetItemN(index: Integer; value: TFhirMeasureReportGroupPopulation);
begin
  assert(value is TFhirMeasureReportGroupPopulation);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureReportGroupStratifier }

constructor TFhirMeasureReportGroupStratifier.Create;
begin
  inherited;
end;

destructor TFhirMeasureReportGroupStratifier.Destroy;
begin
  FCode.free;
  FStratumList.Free;
  inherited;
end;

procedure TFhirMeasureReportGroupStratifier.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMeasureReportGroupStratifier(oSource).code.Clone;
  if (TFhirMeasureReportGroupStratifier(oSource).FStratumList = nil) then
  begin
    FStratumList.free;
    FStratumList := nil;
  end
  else
  begin
    if FStratumList = nil then
      FStratumList := TFhirMeasureReportGroupStratifierStratumList.Create;
    FStratumList.Assign(TFhirMeasureReportGroupStratifier(oSource).FStratumList);
  end;
end;

procedure TFhirMeasureReportGroupStratifier.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'stratum') Then
    list.addAll(self, 'stratum', FStratumList);
end;

procedure TFhirMeasureReportGroupStratifier.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'stratum', 'BackboneElement', true, TFhirMeasureReportGroupStratifierStratum, FStratumList.Link));
end;

function TFhirMeasureReportGroupStratifier.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'stratum') then
  begin
    StratumList.add(propValue as TFhirMeasureReportGroupStratifierStratum);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureReportGroupStratifier.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'stratum') then StratumList.insertItem(index, propValue as TFhirMeasureReportGroupStratifierStratum)
  else inherited;
end;

function TFhirMeasureReportGroupStratifier.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'stratum') then result := StratumList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReportGroupStratifier.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'stratum') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReportGroupStratifier.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'stratum') then deletePropertyValue('stratum', StratumList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReportGroupStratifier.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'stratum') then replacePropertyValue('stratum', StratumList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReportGroupStratifier.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'stratum') then StratumList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReportGroupStratifier.fhirType : string;
begin
  result := 'MeasureReport.group.stratifier';
end;

function TFhirMeasureReportGroupStratifier.Link : TFhirMeasureReportGroupStratifier;
begin
  result := TFhirMeasureReportGroupStratifier(inherited Link);
end;

function TFhirMeasureReportGroupStratifier.Clone : TFhirMeasureReportGroupStratifier;
begin
  result := TFhirMeasureReportGroupStratifier(inherited Clone);
end;

function TFhirMeasureReportGroupStratifier.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureReportGroupStratifier;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReportGroupStratifier)) then
    result := false
  else
  begin
    o := TFhirMeasureReportGroupStratifier(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(stratumList, o.stratumList, true);
  end;
end;

function TFhirMeasureReportGroupStratifier.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FstratumList);
end;

procedure TFhirMeasureReportGroupStratifier.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('stratum');
end;

function TFhirMeasureReportGroupStratifier.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FStratumList.sizeInBytes(magic));
end;

procedure TFhirMeasureReportGroupStratifier.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

function TFhirMeasureReportGroupStratifier.GetStratumList : TFhirMeasureReportGroupStratifierStratumList;
begin
  if FStratumList = nil then
    FStratumList := TFhirMeasureReportGroupStratifierStratumList.Create;
  result := FStratumList;
end;

function TFhirMeasureReportGroupStratifier.GetHasStratumList : boolean;
begin
  result := (FStratumList <> nil) and (FStratumList.count > 0);
end;

{ TFhirMeasureReportGroupStratifierListEnumerator }

constructor TFhirMeasureReportGroupStratifierListEnumerator.Create(list : TFhirMeasureReportGroupStratifierList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportGroupStratifierListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportGroupStratifierListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportGroupStratifierListEnumerator.GetCurrent : TFhirMeasureReportGroupStratifier;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportGroupStratifierListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMeasureReportGroupStratifierList }

function TFhirMeasureReportGroupStratifierList.AddItem(value: TFhirMeasureReportGroupStratifier): TFhirMeasureReportGroupStratifier;
begin
  assert(value.ClassName = 'TFhirMeasureReportGroupStratifier', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReportGroupStratifier');
  add(value);
  result := value;
end;

function TFhirMeasureReportGroupStratifierList.Append: TFhirMeasureReportGroupStratifier;
begin
  result := TFhirMeasureReportGroupStratifier.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportGroupStratifierList.GetEnumerator : TFhirMeasureReportGroupStratifierListEnumerator;
begin
  result := TFhirMeasureReportGroupStratifierListEnumerator.Create(self.link);
end;

function TFhirMeasureReportGroupStratifierList.Clone: TFhirMeasureReportGroupStratifierList;
begin
  result := TFhirMeasureReportGroupStratifierList(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportGroupStratifierList.GetItemN(index: Integer): TFhirMeasureReportGroupStratifier;
begin
  result := TFhirMeasureReportGroupStratifier(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReportGroupStratifier;
end;
function TFhirMeasureReportGroupStratifierList.IndexOf(value: TFhirMeasureReportGroupStratifier): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportGroupStratifierList.Insert(index: Integer): TFhirMeasureReportGroupStratifier;
begin
  result := TFhirMeasureReportGroupStratifier.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierList.InsertItem(index: Integer; value: TFhirMeasureReportGroupStratifier);
begin
  assert(value is TFhirMeasureReportGroupStratifier);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportGroupStratifierList.Item(index: Integer): TFhirMeasureReportGroupStratifier;
begin
  result := TFhirMeasureReportGroupStratifier(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierList.Link: TFhirMeasureReportGroupStratifierList;
begin
  result := TFhirMeasureReportGroupStratifierList(inherited Link);
end;

procedure TFhirMeasureReportGroupStratifierList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportGroupStratifierList.SetItemByIndex(index: Integer; value: TFhirMeasureReportGroupStratifier);
begin
  assert(value is TFhirMeasureReportGroupStratifier);
  FhirMeasureReportGroupStratifiers[index] := value;
end;

procedure TFhirMeasureReportGroupStratifierList.SetItemN(index: Integer; value: TFhirMeasureReportGroupStratifier);
begin
  assert(value is TFhirMeasureReportGroupStratifier);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureReportGroupStratifierStratum }

constructor TFhirMeasureReportGroupStratifierStratum.Create;
begin
  inherited;
end;

destructor TFhirMeasureReportGroupStratifierStratum.Destroy;
begin
  FValue.free;
  FComponentList.Free;
  FPopulationList.Free;
  FMeasureScore.free;
  inherited;
end;

procedure TFhirMeasureReportGroupStratifierStratum.Assign(oSource : TFslObject);
begin
  inherited;
  value := TFhirMeasureReportGroupStratifierStratum(oSource).value.Clone;
  if (TFhirMeasureReportGroupStratifierStratum(oSource).FComponentList = nil) then
  begin
    FComponentList.free;
    FComponentList := nil;
  end
  else
  begin
    if FComponentList = nil then
      FComponentList := TFhirMeasureReportGroupStratifierStratumComponentList.Create;
    FComponentList.Assign(TFhirMeasureReportGroupStratifierStratum(oSource).FComponentList);
  end;
  if (TFhirMeasureReportGroupStratifierStratum(oSource).FPopulationList = nil) then
  begin
    FPopulationList.free;
    FPopulationList := nil;
  end
  else
  begin
    if FPopulationList = nil then
      FPopulationList := TFhirMeasureReportGroupStratifierStratumPopulationList.Create;
    FPopulationList.Assign(TFhirMeasureReportGroupStratifierStratum(oSource).FPopulationList);
  end;
  measureScore := TFhirMeasureReportGroupStratifierStratum(oSource).measureScore.Clone;
end;

procedure TFhirMeasureReportGroupStratifierStratum.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'component') Then
    list.addAll(self, 'component', FComponentList);
  if (child_name = 'population') Then
    list.addAll(self, 'population', FPopulationList);
  if (child_name = 'measureScore[x]') or (child_name = 'measureScore') Then
     list.add(self.link, 'measureScore[x]', FMeasureScore.Link);
end;

procedure TFhirMeasureReportGroupStratifierStratum.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|boolean|Quantity|Range|Reference', false, TFhirDataType, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'component', 'BackboneElement', true, TFhirMeasureReportGroupStratifierStratumComponent, FComponentList.Link));
  oList.add(TFHIRProperty.create(self, 'population', 'BackboneElement', true, TFhirMeasureReportGroupStratifierStratumPopulation, FPopulationList.Link));
  oList.add(TFHIRProperty.create(self, 'measureScore[x]', 'Quantity|dateTime|CodeableConcept|Period|Range|Duration', false, TFhirDataType, FMeasureScore.Link));
end;

function TFhirMeasureReportGroupStratifierStratum.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'component') then
  begin
    ComponentList.add(propValue as TFhirMeasureReportGroupStratifierStratumComponent);
    result := propValue;
  end
  else if (propName = 'population') then
  begin
    PopulationList.add(propValue as TFhirMeasureReportGroupStratifierStratumPopulation);
    result := propValue;
  end
  else if (isMatchingName(propName, 'measureScore', ['Quantity', 'DateTime', 'CodeableConcept', 'Period', 'Range', 'Duration'])) then
  begin
    MeasureScore := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureReportGroupStratifierStratum.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'component') then ComponentList.insertItem(index, propValue as TFhirMeasureReportGroupStratifierStratumComponent)
  else if (propName = 'population') then PopulationList.insertItem(index, propValue as TFhirMeasureReportGroupStratifierStratumPopulation)
  else inherited;
end;

function TFhirMeasureReportGroupStratifierStratum.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference'])) then raise EFHIRException.create('Cannot make property Value')
  else if (propName = 'component') then result := ComponentList.new()
  else if (propName = 'population') then result := PopulationList.new()
  else if (isMatchingName(propName, 'measureScore', ['Quantity', 'DateTime', 'CodeableConcept', 'Period', 'Range', 'Duration'])) then raise EFHIRException.create('Cannot make property MeasureScore')
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReportGroupStratifierStratum.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'value[x]') then result := 'CodeableConcept|boolean|Quantity|Range|Reference'
  else if (propName = 'component') then result := 'BackboneElement'
  else if (propName = 'population') then result := 'BackboneElement'
  else if (propName = 'measureScore[x]') then result := 'Quantity|dateTime|CodeableConcept|Period|Range|Duration'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReportGroupStratifierStratum.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference'])) then ValueElement := nil
  else if (propName = 'component') then deletePropertyValue('component', ComponentList, value)
  else if (propName = 'population') then deletePropertyValue('population', PopulationList, value)
  else if (isMatchingName(propName, 'measureScore', ['Quantity', 'DateTime', 'CodeableConcept', 'Period', 'Range', 'Duration'])) then MeasureScoreElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReportGroupStratifierStratum.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference'])) then ValueElement := new as TFhirDataType
  else if (propName = 'component') then replacePropertyValue('component', ComponentList, existing, new)
  else if (propName = 'population') then replacePropertyValue('population', PopulationList, existing, new)
  else if (isMatchingName(propName, 'measureScore', ['Quantity', 'DateTime', 'CodeableConcept', 'Period', 'Range', 'Duration'])) then MeasureScoreElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReportGroupStratifierStratum.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'component') then ComponentList.move(source, destination)
  else if (propName = 'population') then PopulationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReportGroupStratifierStratum.fhirType : string;
begin
  result := 'MeasureReport.group.stratifier.stratum';
end;

function TFhirMeasureReportGroupStratifierStratum.Link : TFhirMeasureReportGroupStratifierStratum;
begin
  result := TFhirMeasureReportGroupStratifierStratum(inherited Link);
end;

function TFhirMeasureReportGroupStratifierStratum.Clone : TFhirMeasureReportGroupStratifierStratum;
begin
  result := TFhirMeasureReportGroupStratifierStratum(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierStratum.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureReportGroupStratifierStratum;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReportGroupStratifierStratum)) then
    result := false
  else
  begin
    o := TFhirMeasureReportGroupStratifierStratum(other);
    result := compareDeep(valueElement, o.valueElement, true) and compareDeep(componentList, o.componentList, true) and 
      compareDeep(populationList, o.populationList, true) and compareDeep(measureScoreElement, o.measureScoreElement, true);
  end;
end;

function TFhirMeasureReportGroupStratifierStratum.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValue) and isEmptyProp(FcomponentList) and isEmptyProp(FpopulationList) and isEmptyProp(FMeasureScore);
end;

procedure TFhirMeasureReportGroupStratifierStratum.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('value[x]');
  fields.add('component');
  fields.add('population');
  fields.add('measureScore[x]');
end;

function TFhirMeasureReportGroupStratifierStratum.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FComponentList.sizeInBytes(magic));
  inc(result, FPopulationList.sizeInBytes(magic));
end;

procedure TFhirMeasureReportGroupStratifierStratum.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

function TFhirMeasureReportGroupStratifierStratum.GetComponentList : TFhirMeasureReportGroupStratifierStratumComponentList;
begin
  if FComponentList = nil then
    FComponentList := TFhirMeasureReportGroupStratifierStratumComponentList.Create;
  result := FComponentList;
end;

function TFhirMeasureReportGroupStratifierStratum.GetHasComponentList : boolean;
begin
  result := (FComponentList <> nil) and (FComponentList.count > 0);
end;

function TFhirMeasureReportGroupStratifierStratum.GetPopulationList : TFhirMeasureReportGroupStratifierStratumPopulationList;
begin
  if FPopulationList = nil then
    FPopulationList := TFhirMeasureReportGroupStratifierStratumPopulationList.Create;
  result := FPopulationList;
end;

function TFhirMeasureReportGroupStratifierStratum.GetHasPopulationList : boolean;
begin
  result := (FPopulationList <> nil) and (FPopulationList.count > 0);
end;

procedure TFhirMeasureReportGroupStratifierStratum.SetMeasureScore(value : TFhirDataType);
begin
  FMeasureScore.free;
  FMeasureScore := value;
end;

{ TFhirMeasureReportGroupStratifierStratumListEnumerator }

constructor TFhirMeasureReportGroupStratifierStratumListEnumerator.Create(list : TFhirMeasureReportGroupStratifierStratumList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportGroupStratifierStratumListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportGroupStratifierStratumListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportGroupStratifierStratumListEnumerator.GetCurrent : TFhirMeasureReportGroupStratifierStratum;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportGroupStratifierStratumListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMeasureReportGroupStratifierStratumList }

function TFhirMeasureReportGroupStratifierStratumList.AddItem(value: TFhirMeasureReportGroupStratifierStratum): TFhirMeasureReportGroupStratifierStratum;
begin
  assert(value.ClassName = 'TFhirMeasureReportGroupStratifierStratum', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReportGroupStratifierStratum');
  add(value);
  result := value;
end;

function TFhirMeasureReportGroupStratifierStratumList.Append: TFhirMeasureReportGroupStratifierStratum;
begin
  result := TFhirMeasureReportGroupStratifierStratum.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierStratumList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportGroupStratifierStratumList.GetEnumerator : TFhirMeasureReportGroupStratifierStratumListEnumerator;
begin
  result := TFhirMeasureReportGroupStratifierStratumListEnumerator.Create(self.link);
end;

function TFhirMeasureReportGroupStratifierStratumList.Clone: TFhirMeasureReportGroupStratifierStratumList;
begin
  result := TFhirMeasureReportGroupStratifierStratumList(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierStratumList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportGroupStratifierStratumList.GetItemN(index: Integer): TFhirMeasureReportGroupStratifierStratum;
begin
  result := TFhirMeasureReportGroupStratifierStratum(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierStratumList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReportGroupStratifierStratum;
end;
function TFhirMeasureReportGroupStratifierStratumList.IndexOf(value: TFhirMeasureReportGroupStratifierStratum): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportGroupStratifierStratumList.Insert(index: Integer): TFhirMeasureReportGroupStratifierStratum;
begin
  result := TFhirMeasureReportGroupStratifierStratum.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierStratumList.InsertItem(index: Integer; value: TFhirMeasureReportGroupStratifierStratum);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratum);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportGroupStratifierStratumList.Item(index: Integer): TFhirMeasureReportGroupStratifierStratum;
begin
  result := TFhirMeasureReportGroupStratifierStratum(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierStratumList.Link: TFhirMeasureReportGroupStratifierStratumList;
begin
  result := TFhirMeasureReportGroupStratifierStratumList(inherited Link);
end;

procedure TFhirMeasureReportGroupStratifierStratumList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportGroupStratifierStratumList.SetItemByIndex(index: Integer; value: TFhirMeasureReportGroupStratifierStratum);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratum);
  FhirMeasureReportGroupStratifierStrata[index] := value;
end;

procedure TFhirMeasureReportGroupStratifierStratumList.SetItemN(index: Integer; value: TFhirMeasureReportGroupStratifierStratum);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratum);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureReportGroupStratifierStratumComponent }

constructor TFhirMeasureReportGroupStratifierStratumComponent.Create;
begin
  inherited;
end;

destructor TFhirMeasureReportGroupStratifierStratumComponent.Destroy;
begin
  FCode.free;
  FValue.free;
  inherited;
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMeasureReportGroupStratifierStratumComponent(oSource).code.Clone;
  value := TFhirMeasureReportGroupStratifierStratumComponent(oSource).value.Clone;
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|boolean|Quantity|Range|Reference', false, TFhirDataType, FValue.Link));
end;

function TFhirMeasureReportGroupStratifierStratumComponent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMeasureReportGroupStratifierStratumComponent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReportGroupStratifierStratumComponent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|boolean|Quantity|Range|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReportGroupStratifierStratumComponent.fhirType : string;
begin
  result := 'MeasureReport.group.stratifier.stratum.component';
end;

function TFhirMeasureReportGroupStratifierStratumComponent.Link : TFhirMeasureReportGroupStratifierStratumComponent;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponent(inherited Link);
end;

function TFhirMeasureReportGroupStratifierStratumComponent.Clone : TFhirMeasureReportGroupStratifierStratumComponent;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponent(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierStratumComponent.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureReportGroupStratifierStratumComponent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReportGroupStratifierStratumComponent)) then
    result := false
  else
  begin
    o := TFhirMeasureReportGroupStratifierStratumComponent(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirMeasureReportGroupStratifierStratumComponent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('value[x]');
end;

function TFhirMeasureReportGroupStratifierStratumComponent.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirMeasureReportGroupStratifierStratumComponentListEnumerator }

constructor TFhirMeasureReportGroupStratifierStratumComponentListEnumerator.Create(list : TFhirMeasureReportGroupStratifierStratumComponentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportGroupStratifierStratumComponentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportGroupStratifierStratumComponentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportGroupStratifierStratumComponentListEnumerator.GetCurrent : TFhirMeasureReportGroupStratifierStratumComponent;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportGroupStratifierStratumComponentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMeasureReportGroupStratifierStratumComponentList }

function TFhirMeasureReportGroupStratifierStratumComponentList.AddItem(value: TFhirMeasureReportGroupStratifierStratumComponent): TFhirMeasureReportGroupStratifierStratumComponent;
begin
  assert(value.ClassName = 'TFhirMeasureReportGroupStratifierStratumComponent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReportGroupStratifierStratumComponent');
  add(value);
  result := value;
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.Append: TFhirMeasureReportGroupStratifierStratumComponent;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierStratumComponentList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.GetEnumerator : TFhirMeasureReportGroupStratifierStratumComponentListEnumerator;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponentListEnumerator.Create(self.link);
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.Clone: TFhirMeasureReportGroupStratifierStratumComponentList;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponentList(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.GetItemN(index: Integer): TFhirMeasureReportGroupStratifierStratumComponent;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponent(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponent;
end;
function TFhirMeasureReportGroupStratifierStratumComponentList.IndexOf(value: TFhirMeasureReportGroupStratifierStratumComponent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.Insert(index: Integer): TFhirMeasureReportGroupStratifierStratumComponent;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierStratumComponentList.InsertItem(index: Integer; value: TFhirMeasureReportGroupStratifierStratumComponent);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratumComponent);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.Item(index: Integer): TFhirMeasureReportGroupStratifierStratumComponent;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponent(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.Link: TFhirMeasureReportGroupStratifierStratumComponentList;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponentList(inherited Link);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponentList.SetItemByIndex(index: Integer; value: TFhirMeasureReportGroupStratifierStratumComponent);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratumComponent);
  FhirMeasureReportGroupStratifierStratumComponents[index] := value;
end;

procedure TFhirMeasureReportGroupStratifierStratumComponentList.SetItemN(index: Integer; value: TFhirMeasureReportGroupStratifierStratumComponent);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratumComponent);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureReportGroupStratifierStratumPopulation }

constructor TFhirMeasureReportGroupStratifierStratumPopulation.Create;
begin
  inherited;
end;

destructor TFhirMeasureReportGroupStratifierStratumPopulation.Destroy;
begin
  FCode.free;
  FCount.free;
  FSubjectResults.free;
  inherited;
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMeasureReportGroupStratifierStratumPopulation(oSource).code.Clone;
  countElement := TFhirMeasureReportGroupStratifierStratumPopulation(oSource).countElement.Clone;
  subjectResults := TFhirMeasureReportGroupStratifierStratumPopulation(oSource).subjectResults.Clone;
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'count') Then
     list.add(self.link, 'count', FCount.Link);
  if (child_name = 'subjectResults') Then
     list.add(self.link, 'subjectResults', FSubjectResults.Link);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'count', 'integer', false, TFhirInteger, FCount.Link));
  oList.add(TFHIRProperty.create(self, 'subjectResults', 'Reference', false, TFhirReference, FSubjectResults.Link));
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'count') then
  begin
    CountElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'subjectResults') then
  begin
    SubjectResults := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'count') then result := TFhirInteger.create()
  else if (propName = 'subjectResults') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'count') then result := 'integer'
  else if (propName = 'subjectResults') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'count') then CountElement := nil
  else if (propName = 'subjectResults') then SubjectResultsElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'count') then CountElement := asInteger(new)
  else if (propName = 'subjectResults') then SubjectResultsElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.fhirType : string;
begin
  result := 'MeasureReport.group.stratifier.stratum.population';
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.Link : TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation(inherited Link);
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.Clone : TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReportGroupStratifierStratumPopulation)) then
    result := false
  else
  begin
    o := TFhirMeasureReportGroupStratifierStratumPopulation(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(countElement, o.countElement, true) and 
      compareDeep(subjectResultsElement, o.subjectResultsElement, true);
  end;
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FCount) and isEmptyProp(FSubjectResults);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('count');
  fields.add('subjectResults');
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.SetCount(value : TFhirInteger);
begin
  FCount.free;
  FCount := value;
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.GetCountST : String;
begin
  if FCount = nil then
    result := ''
  else
    result := FCount.value;
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.SetCountST(value : String);
begin
  if value <> '' then
  begin
    if FCount = nil then
      FCount := TFhirInteger.create;
    FCount.value := value
  end
  else if FCount <> nil then
    FCount.value := '';
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.SetSubjectResults(value : TFhirReference);
begin
  FSubjectResults.free;
  FSubjectResults := value;
end;

{ TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator }

constructor TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator.Create(list : TFhirMeasureReportGroupStratifierStratumPopulationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator.GetCurrent : TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMeasureReportGroupStratifierStratumPopulationList }

function TFhirMeasureReportGroupStratifierStratumPopulationList.AddItem(value: TFhirMeasureReportGroupStratifierStratumPopulation): TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  assert(value.ClassName = 'TFhirMeasureReportGroupStratifierStratumPopulation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReportGroupStratifierStratumPopulation');
  add(value);
  result := value;
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.Append: TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulationList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.GetEnumerator : TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator.Create(self.link);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.Clone: TFhirMeasureReportGroupStratifierStratumPopulationList;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulationList(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.GetItemN(index: Integer): TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation;
end;
function TFhirMeasureReportGroupStratifierStratumPopulationList.IndexOf(value: TFhirMeasureReportGroupStratifierStratumPopulation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.Insert(index: Integer): TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulationList.InsertItem(index: Integer; value: TFhirMeasureReportGroupStratifierStratumPopulation);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratumPopulation);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.Item(index: Integer): TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.Link: TFhirMeasureReportGroupStratifierStratumPopulationList;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulationList(inherited Link);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulationList.SetItemByIndex(index: Integer; value: TFhirMeasureReportGroupStratifierStratumPopulation);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratumPopulation);
  FhirMeasureReportGroupStratifierStratumPopulations[index] := value;
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulationList.SetItemN(index: Integer; value: TFhirMeasureReportGroupStratifierStratumPopulation);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratumPopulation);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureReport }

constructor TFhirMeasureReport.Create;
begin
  inherited;
end;

destructor TFhirMeasureReport.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FDataUpdateType.free;
  FMeasure.free;
  FSubject.free;
  FDate.free;
  FReporter.free;
  FReportingVendor.free;
  FLocation.free;
  FPeriod.free;
  FInputParameters.free;
  FScoring.free;
  FImprovementNotation.free;
  FGroupList.Free;
  FEvaluatedResourceList.Free;
  inherited;
end;

procedure TFhirMeasureReport.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMeasureReport(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMeasureReport(oSource).FIdentifierList);
  end;
  statusElement := TFhirMeasureReport(oSource).statusElement.Clone;
  type_Element := TFhirMeasureReport(oSource).type_Element.Clone;
  dataUpdateTypeElement := TFhirMeasureReport(oSource).dataUpdateTypeElement.Clone;
  measureElement := TFhirMeasureReport(oSource).measureElement.Clone;
  subject := TFhirMeasureReport(oSource).subject.Clone;
  dateElement := TFhirMeasureReport(oSource).dateElement.Clone;
  reporter := TFhirMeasureReport(oSource).reporter.Clone;
  reportingVendor := TFhirMeasureReport(oSource).reportingVendor.Clone;
  location := TFhirMeasureReport(oSource).location.Clone;
  period := TFhirMeasureReport(oSource).period.Clone;
  inputParameters := TFhirMeasureReport(oSource).inputParameters.Clone;
  scoring := TFhirMeasureReport(oSource).scoring.Clone;
  improvementNotation := TFhirMeasureReport(oSource).improvementNotation.Clone;
  if (TFhirMeasureReport(oSource).FGroupList = nil) then
  begin
    FGroupList.free;
    FGroupList := nil;
  end
  else
  begin
    if FGroupList = nil then
      FGroupList := TFhirMeasureReportGroupList.Create;
    FGroupList.Assign(TFhirMeasureReport(oSource).FGroupList);
  end;
  if (TFhirMeasureReport(oSource).FEvaluatedResourceList = nil) then
  begin
    FEvaluatedResourceList.free;
    FEvaluatedResourceList := nil;
  end
  else
  begin
    if FEvaluatedResourceList = nil then
      FEvaluatedResourceList := TFhirReferenceList.Create;
    FEvaluatedResourceList.Assign(TFhirMeasureReport(oSource).FEvaluatedResourceList);
  end;
end;

function TFhirMeasureReport.GetResourceType : TFhirResourceType;
begin
  result := frtMeasureReport;
end;

procedure TFhirMeasureReport.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'dataUpdateType') Then
     list.add(self.link, 'dataUpdateType', FDataUpdateType.Link);
  if (child_name = 'measure') Then
     list.add(self.link, 'measure', FMeasure.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'reporter') Then
     list.add(self.link, 'reporter', FReporter.Link);
  if (child_name = 'reportingVendor') Then
     list.add(self.link, 'reportingVendor', FReportingVendor.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'inputParameters') Then
     list.add(self.link, 'inputParameters', FInputParameters.Link);
  if (child_name = 'scoring') Then
     list.add(self.link, 'scoring', FScoring.Link);
  if (child_name = 'improvementNotation') Then
     list.add(self.link, 'improvementNotation', FImprovementNotation.Link);
  if (child_name = 'group') Then
    list.addAll(self, 'group', FGroupList);
  if (child_name = 'evaluatedResource') Then
    list.addAll(self, 'evaluatedResource', FEvaluatedResourceList);
end;

procedure TFhirMeasureReport.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'dataUpdateType', 'code', false, TFhirEnum, FDataUpdateType.Link));
  oList.add(TFHIRProperty.create(self, 'measure', 'canonical', false, TFhirCanonical, FMeasure.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'reporter', 'Reference', false, TFhirReference, FReporter.Link));
  oList.add(TFHIRProperty.create(self, 'reportingVendor', 'Reference', false, TFhirReference, FReportingVendor.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'inputParameters', 'Reference', false, TFhirReference, FInputParameters.Link));
  oList.add(TFHIRProperty.create(self, 'scoring', 'CodeableConcept', false, TFhirCodeableConcept, FScoring.Link));
  oList.add(TFHIRProperty.create(self, 'improvementNotation', 'CodeableConcept', false, TFhirCodeableConcept, FImprovementNotation.Link));
  oList.add(TFHIRProperty.create(self, 'group', 'BackboneElement', true, TFhirMeasureReportGroup, FGroupList.Link));
  oList.add(TFHIRProperty.create(self, 'evaluatedResource', 'Reference', true, TFhirReference, FEvaluatedResourceList.Link));
end;

function TFhirMeasureReport.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMeasureReportStatusEnum, CODES_TFhirMeasureReportStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirMeasureReportTypeEnum, CODES_TFhirMeasureReportTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'dataUpdateType') then
  begin
    DataUpdateTypeElement := asEnum(SYSTEMS_TFhirSubmitDataUpdateTypeEnum, CODES_TFhirSubmitDataUpdateTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'measure') then
  begin
    MeasureElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'reporter') then
  begin
    Reporter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'reportingVendor') then
  begin
    ReportingVendor := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'inputParameters') then
  begin
    InputParameters := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'scoring') then
  begin
    Scoring := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'improvementNotation') then
  begin
    ImprovementNotation := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'group') then
  begin
    GroupList.add(propValue as TFhirMeasureReportGroup);
    result := propValue;
  end
  else if (propName = 'evaluatedResource') then
  begin
    EvaluatedResourceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureReport.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'group') then GroupList.insertItem(index, propValue as TFhirMeasureReportGroup)
  else if (propName = 'evaluatedResource') then EvaluatedResourceList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirMeasureReport.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirMeasureReportStatusEnum[MeasureReportStatusNull], CODES_TFhirMeasureReportStatusEnum[MeasureReportStatusNull]) 
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirMeasureReportTypeEnum[MeasureReportTypeNull], CODES_TFhirMeasureReportTypeEnum[MeasureReportTypeNull]) 
  else if (propName = 'dataUpdateType') then result := TFhirEnum.create(SYSTEMS_TFhirSubmitDataUpdateTypeEnum[SubmitDataUpdateTypeNull], CODES_TFhirSubmitDataUpdateTypeEnum[SubmitDataUpdateTypeNull]) 
  else if (propName = 'measure') then result := TFhirCanonical.create()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'reporter') then result := TFhirReference.create()
  else if (propName = 'reportingVendor') then result := TFhirReference.create()
  else if (propName = 'location') then result := TFhirReference.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'inputParameters') then result := TFhirReference.create()
  else if (propName = 'scoring') then result := TFhirCodeableConcept.create()
  else if (propName = 'improvementNotation') then result := TFhirCodeableConcept.create()
  else if (propName = 'group') then result := GroupList.new()
  else if (propName = 'evaluatedResource') then result := EvaluatedResourceList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReport.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'dataUpdateType') then result := 'code'
  else if (propName = 'measure') then result := 'canonical'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'reporter') then result := 'Reference'
  else if (propName = 'reportingVendor') then result := 'Reference'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'inputParameters') then result := 'Reference'
  else if (propName = 'scoring') then result := 'CodeableConcept'
  else if (propName = 'improvementNotation') then result := 'CodeableConcept'
  else if (propName = 'group') then result := 'BackboneElement'
  else if (propName = 'evaluatedResource') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReport.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'dataUpdateType') then DataUpdateTypeElement := nil
  else if (propName = 'measure') then MeasureElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'reporter') then ReporterElement := nil
  else if (propName = 'reportingVendor') then ReportingVendorElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'inputParameters') then InputParametersElement := nil
  else if (propName = 'scoring') then ScoringElement := nil
  else if (propName = 'improvementNotation') then ImprovementNotationElement := nil
  else if (propName = 'group') then deletePropertyValue('group', GroupList, value)
  else if (propName = 'evaluatedResource') then deletePropertyValue('evaluatedResource', EvaluatedResourceList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReport.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMeasureReportStatusEnum, CODES_TFhirMeasureReportStatusEnum, new)
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirMeasureReportTypeEnum, CODES_TFhirMeasureReportTypeEnum, new)
  else if (propName = 'dataUpdateType') then DataUpdateTypeElement := asEnum(SYSTEMS_TFhirSubmitDataUpdateTypeEnum, CODES_TFhirSubmitDataUpdateTypeEnum, new)
  else if (propName = 'measure') then MeasureElement := asCanonical(new)
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'reporter') then ReporterElement := new as TFhirReference
  else if (propName = 'reportingVendor') then ReportingVendorElement := new as TFhirReference
  else if (propName = 'location') then LocationElement := new as TFhirReference
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'inputParameters') then InputParametersElement := new as TFhirReference
  else if (propName = 'scoring') then ScoringElement := new as TFhirCodeableConcept
  else if (propName = 'improvementNotation') then ImprovementNotationElement := new as TFhirCodeableConcept
  else if (propName = 'group') then replacePropertyValue('group', GroupList, existing, new)
  else if (propName = 'evaluatedResource') then replacePropertyValue('evaluatedResource', EvaluatedResourceList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReport.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'group') then GroupList.move(source, destination)
  else if (propName = 'evaluatedResource') then EvaluatedResourceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReport.fhirType : string;
begin
  result := 'MeasureReport';
end;

function TFhirMeasureReport.Link : TFhirMeasureReport;
begin
  result := TFhirMeasureReport(inherited Link);
end;

function TFhirMeasureReport.Clone : TFhirMeasureReport;
begin
  result := TFhirMeasureReport(inherited Clone);
end;

function TFhirMeasureReport.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureReport;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReport)) then
    result := false
  else
  begin
    o := TFhirMeasureReport(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(dataUpdateTypeElement, o.dataUpdateTypeElement, true) and 
      compareDeep(measureElement, o.measureElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(reporterElement, o.reporterElement, true) and 
      compareDeep(reportingVendorElement, o.reportingVendorElement, true) and compareDeep(locationElement, o.locationElement, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(inputParametersElement, o.inputParametersElement, true) and 
      compareDeep(scoringElement, o.scoringElement, true) and compareDeep(improvementNotationElement, o.improvementNotationElement, true) and 
      compareDeep(groupList, o.groupList, true) and compareDeep(evaluatedResourceList, o.evaluatedResourceList, true);
  end;
end;

function TFhirMeasureReport.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FDataUpdateType) and isEmptyProp(FMeasure) and isEmptyProp(FSubject) and isEmptyProp(FDate) and isEmptyProp(FReporter) and isEmptyProp(FReportingVendor) and isEmptyProp(FLocation) and isEmptyProp(FPeriod) and isEmptyProp(FInputParameters) and isEmptyProp(FScoring) and isEmptyProp(FImprovementNotation) and isEmptyProp(FgroupList) and isEmptyProp(FevaluatedResourceList);
end;

procedure TFhirMeasureReport.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('dataUpdateType');
  fields.add('measure');
  fields.add('subject');
  fields.add('date');
  fields.add('reporter');
  fields.add('reportingVendor');
  fields.add('location');
  fields.add('period');
  fields.add('inputParameters');
  fields.add('scoring');
  fields.add('improvementNotation');
  fields.add('group');
  fields.add('evaluatedResource');
end;

function TFhirMeasureReport.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FGroupList.sizeInBytes(magic));
  inc(result, FEvaluatedResourceList.sizeInBytes(magic));
end;

function TFhirMeasureReport.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirMeasureReport.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirMeasureReport.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirMeasureReport.GetStatusST : TFhirMeasureReportStatusEnum;
begin
  if FStatus = nil then
    result := TFhirMeasureReportStatusEnum(0)
  else
    result := TFhirMeasureReportStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirMeasureReportStatusEnum, FStatus.value));
end;

procedure TFhirMeasureReport.SetStatusST(value : TFhirMeasureReportStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMeasureReportStatusEnum[value], CODES_TFhirMeasureReportStatusEnum[value]);
end;

procedure TFhirMeasureReport.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirMeasureReport.GetType_ST : TFhirMeasureReportTypeEnum;
begin
  if FType_ = nil then
    result := TFhirMeasureReportTypeEnum(0)
  else
    result := TFhirMeasureReportTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirMeasureReportTypeEnum, FType_.value));
end;

procedure TFhirMeasureReport.SetType_ST(value : TFhirMeasureReportTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirMeasureReportTypeEnum[value], CODES_TFhirMeasureReportTypeEnum[value]);
end;

procedure TFhirMeasureReport.SetDataUpdateType(value : TFhirEnum);
begin
  FDataUpdateType.free;
  FDataUpdateType := value;
end;

function TFhirMeasureReport.GetDataUpdateTypeST : TFhirSubmitDataUpdateTypeEnum;
begin
  if FDataUpdateType = nil then
    result := TFhirSubmitDataUpdateTypeEnum(0)
  else
    result := TFhirSubmitDataUpdateTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirSubmitDataUpdateTypeEnum, FDataUpdateType.value));
end;

procedure TFhirMeasureReport.SetDataUpdateTypeST(value : TFhirSubmitDataUpdateTypeEnum);
begin
  if ord(value) = 0 then
    DataUpdateTypeElement := nil
  else
    DataUpdateTypeElement := TFhirEnum.create(SYSTEMS_TFhirSubmitDataUpdateTypeEnum[value], CODES_TFhirSubmitDataUpdateTypeEnum[value]);
end;

procedure TFhirMeasureReport.SetMeasure(value : TFhirCanonical);
begin
  FMeasure.free;
  FMeasure := value;
end;

function TFhirMeasureReport.GetMeasureST : String;
begin
  if FMeasure = nil then
    result := ''
  else
    result := FMeasure.value;
end;

procedure TFhirMeasureReport.SetMeasureST(value : String);
begin
  if value <> '' then
  begin
    if FMeasure = nil then
      FMeasure := TFhirCanonical.create;
    FMeasure.value := value
  end
  else if FMeasure <> nil then
    FMeasure.value := '';
end;

procedure TFhirMeasureReport.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirMeasureReport.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirMeasureReport.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirMeasureReport.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirMeasureReport.SetReporter(value : TFhirReference);
begin
  FReporter.free;
  FReporter := value;
end;

procedure TFhirMeasureReport.SetReportingVendor(value : TFhirReference);
begin
  FReportingVendor.free;
  FReportingVendor := value;
end;

procedure TFhirMeasureReport.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value;
end;

procedure TFhirMeasureReport.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

procedure TFhirMeasureReport.SetInputParameters(value : TFhirReference);
begin
  FInputParameters.free;
  FInputParameters := value;
end;

procedure TFhirMeasureReport.SetScoring(value : TFhirCodeableConcept);
begin
  FScoring.free;
  FScoring := value;
end;

procedure TFhirMeasureReport.SetImprovementNotation(value : TFhirCodeableConcept);
begin
  FImprovementNotation.free;
  FImprovementNotation := value;
end;

function TFhirMeasureReport.GetGroupList : TFhirMeasureReportGroupList;
begin
  if FGroupList = nil then
    FGroupList := TFhirMeasureReportGroupList.Create;
  result := FGroupList;
end;

function TFhirMeasureReport.GetHasGroupList : boolean;
begin
  result := (FGroupList <> nil) and (FGroupList.count > 0);
end;

function TFhirMeasureReport.GetEvaluatedResourceList : TFhirReferenceList;
begin
  if FEvaluatedResourceList = nil then
    FEvaluatedResourceList := TFhirReferenceList.Create;
  result := FEvaluatedResourceList;
end;

function TFhirMeasureReport.GetHasEvaluatedResourceList : boolean;
begin
  result := (FEvaluatedResourceList <> nil) and (FEvaluatedResourceList.count > 0);
end;

{ TFhirMeasureReportListEnumerator }

constructor TFhirMeasureReportListEnumerator.Create(list : TFhirMeasureReportList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportListEnumerator.GetCurrent : TFhirMeasureReport;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMeasureReportList }

function TFhirMeasureReportList.AddItem(value: TFhirMeasureReport): TFhirMeasureReport;
begin
  assert(value.ClassName = 'TFhirMeasureReport', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReport');
  add(value);
  result := value;
end;

function TFhirMeasureReportList.Append: TFhirMeasureReport;
begin
  result := TFhirMeasureReport.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportList.GetEnumerator : TFhirMeasureReportListEnumerator;
begin
  result := TFhirMeasureReportListEnumerator.Create(self.link);
end;

function TFhirMeasureReportList.Clone: TFhirMeasureReportList;
begin
  result := TFhirMeasureReportList(inherited Clone);
end;

function TFhirMeasureReportList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportList.GetItemN(index: Integer): TFhirMeasureReport;
begin
  result := TFhirMeasureReport(ObjectByIndex[index]);
end;

function TFhirMeasureReportList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReport;
end;
function TFhirMeasureReportList.IndexOf(value: TFhirMeasureReport): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportList.Insert(index: Integer): TFhirMeasureReport;
begin
  result := TFhirMeasureReport.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportList.InsertItem(index: Integer; value: TFhirMeasureReport);
begin
  assert(value is TFhirMeasureReport);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportList.Item(index: Integer): TFhirMeasureReport;
begin
  result := TFhirMeasureReport(ObjectByIndex[index]);
end;

function TFhirMeasureReportList.Link: TFhirMeasureReportList;
begin
  result := TFhirMeasureReportList(inherited Link);
end;

procedure TFhirMeasureReportList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportList.SetItemByIndex(index: Integer; value: TFhirMeasureReport);
begin
  assert(value is TFhirMeasureReport);
  FhirMeasureReports[index] := value;
end;

procedure TFhirMeasureReportList.SetItemN(index: Integer; value: TFhirMeasureReport);
begin
  assert(value is TFhirMeasureReport);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MESSAGEHEADER}
{ TFhirMessageHeaderDestination }

constructor TFhirMessageHeaderDestination.Create;
begin
  inherited;
end;

destructor TFhirMessageHeaderDestination.Destroy;
begin
  FName.free;
  FTarget.free;
  FEndpoint.free;
  FReceiver.free;
  inherited;
end;

procedure TFhirMessageHeaderDestination.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirMessageHeaderDestination(oSource).nameElement.Clone;
  target := TFhirMessageHeaderDestination(oSource).target.Clone;
  endpointElement := TFhirMessageHeaderDestination(oSource).endpointElement.Clone;
  receiver := TFhirMessageHeaderDestination(oSource).receiver.Clone;
end;

procedure TFhirMessageHeaderDestination.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
  if (child_name = 'endpoint') Then
     list.add(self.link, 'endpoint', FEndpoint.Link);
  if (child_name = 'receiver') Then
     list.add(self.link, 'receiver', FReceiver.Link);
end;

procedure TFhirMessageHeaderDestination.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'target', 'Reference', false, TFhirReference, FTarget.Link));
  oList.add(TFHIRProperty.create(self, 'endpoint', 'url', false, TFhirUrl, FEndpoint.Link));
  oList.add(TFHIRProperty.create(self, 'receiver', 'Reference', false, TFhirReference, FReceiver.Link));
end;

function TFhirMessageHeaderDestination.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    Target := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointElement := asUrl(propValue);
    result := propValue;
  end
  else if (propName = 'receiver') then
  begin
    Receiver := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMessageHeaderDestination.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMessageHeaderDestination.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'target') then result := TFhirReference.create()
  else if (propName = 'endpoint') then result := TFhirUrl.create()
  else if (propName = 'receiver') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageHeaderDestination.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'target') then result := 'Reference'
  else if (propName = 'endpoint') then result := 'url'
  else if (propName = 'receiver') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageHeaderDestination.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'target') then TargetElement := nil
  else if (propName = 'endpoint') then EndpointElement := nil
  else if (propName = 'receiver') then ReceiverElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageHeaderDestination.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'target') then TargetElement := new as TFhirReference
  else if (propName = 'endpoint') then EndpointElement := asUrl(new)
  else if (propName = 'receiver') then ReceiverElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageHeaderDestination.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageHeaderDestination.fhirType : string;
begin
  result := 'MessageHeader.destination';
end;

function TFhirMessageHeaderDestination.Link : TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(inherited Link);
end;

function TFhirMessageHeaderDestination.Clone : TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(inherited Clone);
end;

function TFhirMessageHeaderDestination.equals(other : TObject) : boolean; 
var
  o : TFhirMessageHeaderDestination;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageHeaderDestination)) then
    result := false
  else
  begin
    o := TFhirMessageHeaderDestination(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(targetElement, o.targetElement, true) and 
      compareDeep(endpointElement, o.endpointElement, true) and compareDeep(receiverElement, o.receiverElement, true);
  end;
end;

function TFhirMessageHeaderDestination.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FTarget) and isEmptyProp(FEndpoint) and isEmptyProp(FReceiver);
end;

procedure TFhirMessageHeaderDestination.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('target');
  fields.add('endpoint');
  fields.add('receiver');
end;

function TFhirMessageHeaderDestination.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMessageHeaderDestination.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirMessageHeaderDestination.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirMessageHeaderDestination.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirMessageHeaderDestination.SetTarget(value : TFhirReference);
begin
  FTarget.free;
  FTarget := value;
end;

procedure TFhirMessageHeaderDestination.SetEndpoint(value : TFhirUrl);
begin
  FEndpoint.free;
  FEndpoint := value;
end;

function TFhirMessageHeaderDestination.GetEndpointST : String;
begin
  if FEndpoint = nil then
    result := ''
  else
    result := FEndpoint.value;
end;

procedure TFhirMessageHeaderDestination.SetEndpointST(value : String);
begin
  if value <> '' then
  begin
    if FEndpoint = nil then
      FEndpoint := TFhirUrl.create;
    FEndpoint.value := value
  end
  else if FEndpoint <> nil then
    FEndpoint.value := '';
end;

procedure TFhirMessageHeaderDestination.SetReceiver(value : TFhirReference);
begin
  FReceiver.free;
  FReceiver := value;
end;

{ TFhirMessageHeaderDestinationListEnumerator }

constructor TFhirMessageHeaderDestinationListEnumerator.Create(list : TFhirMessageHeaderDestinationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageHeaderDestinationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageHeaderDestinationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageHeaderDestinationListEnumerator.GetCurrent : TFhirMessageHeaderDestination;
begin
  Result := FList[FIndex];
end;

function TFhirMessageHeaderDestinationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMessageHeaderDestinationList }

function TFhirMessageHeaderDestinationList.AddItem(value: TFhirMessageHeaderDestination): TFhirMessageHeaderDestination;
begin
  assert(value.ClassName = 'TFhirMessageHeaderDestination', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeaderDestination');
  add(value);
  result := value;
end;

function TFhirMessageHeaderDestinationList.Append: TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderDestinationList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderDestinationList.GetEnumerator : TFhirMessageHeaderDestinationListEnumerator;
begin
  result := TFhirMessageHeaderDestinationListEnumerator.Create(self.link);
end;

function TFhirMessageHeaderDestinationList.Clone: TFhirMessageHeaderDestinationList;
begin
  result := TFhirMessageHeaderDestinationList(inherited Clone);
end;

function TFhirMessageHeaderDestinationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderDestinationList.GetItemN(index: Integer): TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(ObjectByIndex[index]);
end;

function TFhirMessageHeaderDestinationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageHeaderDestination;
end;
function TFhirMessageHeaderDestinationList.IndexOf(value: TFhirMessageHeaderDestination): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageHeaderDestinationList.Insert(index: Integer): TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderDestinationList.InsertItem(index: Integer; value: TFhirMessageHeaderDestination);
begin
  assert(value is TFhirMessageHeaderDestination);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderDestinationList.Item(index: Integer): TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(ObjectByIndex[index]);
end;

function TFhirMessageHeaderDestinationList.Link: TFhirMessageHeaderDestinationList;
begin
  result := TFhirMessageHeaderDestinationList(inherited Link);
end;

procedure TFhirMessageHeaderDestinationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderDestinationList.SetItemByIndex(index: Integer; value: TFhirMessageHeaderDestination);
begin
  assert(value is TFhirMessageHeaderDestination);
  FhirMessageHeaderDestinations[index] := value;
end;

procedure TFhirMessageHeaderDestinationList.SetItemN(index: Integer; value: TFhirMessageHeaderDestination);
begin
  assert(value is TFhirMessageHeaderDestination);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageHeaderSource }

constructor TFhirMessageHeaderSource.Create;
begin
  inherited;
end;

destructor TFhirMessageHeaderSource.Destroy;
begin
  FName.free;
  FSoftware.free;
  FVersion.free;
  FContact.free;
  FEndpoint.free;
  inherited;
end;

procedure TFhirMessageHeaderSource.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirMessageHeaderSource(oSource).nameElement.Clone;
  softwareElement := TFhirMessageHeaderSource(oSource).softwareElement.Clone;
  versionElement := TFhirMessageHeaderSource(oSource).versionElement.Clone;
  contact := TFhirMessageHeaderSource(oSource).contact.Clone;
  endpointElement := TFhirMessageHeaderSource(oSource).endpointElement.Clone;
end;

procedure TFhirMessageHeaderSource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'software') Then
     list.add(self.link, 'software', FSoftware.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'contact') Then
     list.add(self.link, 'contact', FContact.Link);
  if (child_name = 'endpoint') Then
     list.add(self.link, 'endpoint', FEndpoint.Link);
end;

procedure TFhirMessageHeaderSource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'software', 'string', false, TFhirString, FSoftware.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactPoint', false, TFhirContactPoint, FContact.Link));
  oList.add(TFHIRProperty.create(self, 'endpoint', 'url', false, TFhirUrl, FEndpoint.Link));
end;

function TFhirMessageHeaderSource.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'software') then
  begin
    SoftwareElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    Contact := propValue as TFhirContactPoint;
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointElement := asUrl(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMessageHeaderSource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMessageHeaderSource.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'software') then result := TFhirString.create()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'contact') then result := TFhirContactPoint.create()
  else if (propName = 'endpoint') then result := TFhirUrl.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageHeaderSource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'software') then result := 'string'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'contact') then result := 'ContactPoint'
  else if (propName = 'endpoint') then result := 'url'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageHeaderSource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'software') then SoftwareElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'contact') then ContactElement := nil
  else if (propName = 'endpoint') then EndpointElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageHeaderSource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'software') then SoftwareElement := asString(new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'contact') then ContactElement := new as TFhirContactPoint
  else if (propName = 'endpoint') then EndpointElement := asUrl(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageHeaderSource.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageHeaderSource.fhirType : string;
begin
  result := 'MessageHeader.source';
end;

function TFhirMessageHeaderSource.Link : TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(inherited Link);
end;

function TFhirMessageHeaderSource.Clone : TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(inherited Clone);
end;

function TFhirMessageHeaderSource.equals(other : TObject) : boolean; 
var
  o : TFhirMessageHeaderSource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageHeaderSource)) then
    result := false
  else
  begin
    o := TFhirMessageHeaderSource(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(softwareElement, o.softwareElement, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(contactElement, o.contactElement, true) and 
      compareDeep(endpointElement, o.endpointElement, true);
  end;
end;

function TFhirMessageHeaderSource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FSoftware) and isEmptyProp(FVersion) and isEmptyProp(FContact) and isEmptyProp(FEndpoint);
end;

procedure TFhirMessageHeaderSource.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('software');
  fields.add('version');
  fields.add('contact');
  fields.add('endpoint');
end;

function TFhirMessageHeaderSource.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMessageHeaderSource.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirMessageHeaderSource.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirMessageHeaderSource.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirMessageHeaderSource.SetSoftware(value : TFhirString);
begin
  FSoftware.free;
  FSoftware := value;
end;

function TFhirMessageHeaderSource.GetSoftwareST : String;
begin
  if FSoftware = nil then
    result := ''
  else
    result := FSoftware.value;
end;

procedure TFhirMessageHeaderSource.SetSoftwareST(value : String);
begin
  if value <> '' then
  begin
    if FSoftware = nil then
      FSoftware := TFhirString.create;
    FSoftware.value := value
  end
  else if FSoftware <> nil then
    FSoftware.value := '';
end;

procedure TFhirMessageHeaderSource.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirMessageHeaderSource.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirMessageHeaderSource.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirMessageHeaderSource.SetContact(value : TFhirContactPoint);
begin
  FContact.free;
  FContact := value;
end;

procedure TFhirMessageHeaderSource.SetEndpoint(value : TFhirUrl);
begin
  FEndpoint.free;
  FEndpoint := value;
end;

function TFhirMessageHeaderSource.GetEndpointST : String;
begin
  if FEndpoint = nil then
    result := ''
  else
    result := FEndpoint.value;
end;

procedure TFhirMessageHeaderSource.SetEndpointST(value : String);
begin
  if value <> '' then
  begin
    if FEndpoint = nil then
      FEndpoint := TFhirUrl.create;
    FEndpoint.value := value
  end
  else if FEndpoint <> nil then
    FEndpoint.value := '';
end;

{ TFhirMessageHeaderSourceListEnumerator }

constructor TFhirMessageHeaderSourceListEnumerator.Create(list : TFhirMessageHeaderSourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageHeaderSourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageHeaderSourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageHeaderSourceListEnumerator.GetCurrent : TFhirMessageHeaderSource;
begin
  Result := FList[FIndex];
end;

function TFhirMessageHeaderSourceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMessageHeaderSourceList }

function TFhirMessageHeaderSourceList.AddItem(value: TFhirMessageHeaderSource): TFhirMessageHeaderSource;
begin
  assert(value.ClassName = 'TFhirMessageHeaderSource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeaderSource');
  add(value);
  result := value;
end;

function TFhirMessageHeaderSourceList.Append: TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderSourceList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderSourceList.GetEnumerator : TFhirMessageHeaderSourceListEnumerator;
begin
  result := TFhirMessageHeaderSourceListEnumerator.Create(self.link);
end;

function TFhirMessageHeaderSourceList.Clone: TFhirMessageHeaderSourceList;
begin
  result := TFhirMessageHeaderSourceList(inherited Clone);
end;

function TFhirMessageHeaderSourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderSourceList.GetItemN(index: Integer): TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(ObjectByIndex[index]);
end;

function TFhirMessageHeaderSourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageHeaderSource;
end;
function TFhirMessageHeaderSourceList.IndexOf(value: TFhirMessageHeaderSource): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageHeaderSourceList.Insert(index: Integer): TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderSourceList.InsertItem(index: Integer; value: TFhirMessageHeaderSource);
begin
  assert(value is TFhirMessageHeaderSource);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderSourceList.Item(index: Integer): TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(ObjectByIndex[index]);
end;

function TFhirMessageHeaderSourceList.Link: TFhirMessageHeaderSourceList;
begin
  result := TFhirMessageHeaderSourceList(inherited Link);
end;

procedure TFhirMessageHeaderSourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderSourceList.SetItemByIndex(index: Integer; value: TFhirMessageHeaderSource);
begin
  assert(value is TFhirMessageHeaderSource);
  FhirMessageHeaderSources[index] := value;
end;

procedure TFhirMessageHeaderSourceList.SetItemN(index: Integer; value: TFhirMessageHeaderSource);
begin
  assert(value is TFhirMessageHeaderSource);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageHeaderResponse }

constructor TFhirMessageHeaderResponse.Create;
begin
  inherited;
end;

destructor TFhirMessageHeaderResponse.Destroy;
begin
  FIdentifier.free;
  FCode.free;
  FDetails.free;
  inherited;
end;

procedure TFhirMessageHeaderResponse.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirMessageHeaderResponse(oSource).identifier.Clone;
  codeElement := TFhirMessageHeaderResponse(oSource).codeElement.Clone;
  details := TFhirMessageHeaderResponse(oSource).details.Clone;
end;

procedure TFhirMessageHeaderResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'details') Then
     list.add(self.link, 'details', FDetails.Link);
end;

procedure TFhirMessageHeaderResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirEnum, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'details', 'Reference', false, TFhirReference, FDetails.Link));
end;

function TFhirMessageHeaderResponse.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirResponseTypeEnum, CODES_TFhirResponseTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'details') then
  begin
    Details := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMessageHeaderResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMessageHeaderResponse.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'code') then result := TFhirEnum.create(SYSTEMS_TFhirResponseTypeEnum[ResponseTypeNull], CODES_TFhirResponseTypeEnum[ResponseTypeNull]) 
  else if (propName = 'details') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageHeaderResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'details') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageHeaderResponse.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'details') then DetailsElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageHeaderResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirResponseTypeEnum, CODES_TFhirResponseTypeEnum, new)
  else if (propName = 'details') then DetailsElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageHeaderResponse.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageHeaderResponse.fhirType : string;
begin
  result := 'MessageHeader.response';
end;

function TFhirMessageHeaderResponse.Link : TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(inherited Link);
end;

function TFhirMessageHeaderResponse.Clone : TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(inherited Clone);
end;

function TFhirMessageHeaderResponse.equals(other : TObject) : boolean; 
var
  o : TFhirMessageHeaderResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageHeaderResponse)) then
    result := false
  else
  begin
    o := TFhirMessageHeaderResponse(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(detailsElement, o.detailsElement, true);
  end;
end;

function TFhirMessageHeaderResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FCode) and isEmptyProp(FDetails);
end;

procedure TFhirMessageHeaderResponse.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('code');
  fields.add('details');
end;

function TFhirMessageHeaderResponse.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMessageHeaderResponse.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirMessageHeaderResponse.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

function TFhirMessageHeaderResponse.GetCodeST : TFhirResponseTypeEnum;
begin
  if FCode = nil then
    result := TFhirResponseTypeEnum(0)
  else
    result := TFhirResponseTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirResponseTypeEnum, FCode.value));
end;

procedure TFhirMessageHeaderResponse.SetCodeST(value : TFhirResponseTypeEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirResponseTypeEnum[value], CODES_TFhirResponseTypeEnum[value]);
end;

procedure TFhirMessageHeaderResponse.SetDetails(value : TFhirReference);
begin
  FDetails.free;
  FDetails := value;
end;

{ TFhirMessageHeaderResponseListEnumerator }

constructor TFhirMessageHeaderResponseListEnumerator.Create(list : TFhirMessageHeaderResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageHeaderResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageHeaderResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageHeaderResponseListEnumerator.GetCurrent : TFhirMessageHeaderResponse;
begin
  Result := FList[FIndex];
end;

function TFhirMessageHeaderResponseListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMessageHeaderResponseList }

function TFhirMessageHeaderResponseList.AddItem(value: TFhirMessageHeaderResponse): TFhirMessageHeaderResponse;
begin
  assert(value.ClassName = 'TFhirMessageHeaderResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeaderResponse');
  add(value);
  result := value;
end;

function TFhirMessageHeaderResponseList.Append: TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderResponseList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderResponseList.GetEnumerator : TFhirMessageHeaderResponseListEnumerator;
begin
  result := TFhirMessageHeaderResponseListEnumerator.Create(self.link);
end;

function TFhirMessageHeaderResponseList.Clone: TFhirMessageHeaderResponseList;
begin
  result := TFhirMessageHeaderResponseList(inherited Clone);
end;

function TFhirMessageHeaderResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderResponseList.GetItemN(index: Integer): TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(ObjectByIndex[index]);
end;

function TFhirMessageHeaderResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageHeaderResponse;
end;
function TFhirMessageHeaderResponseList.IndexOf(value: TFhirMessageHeaderResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageHeaderResponseList.Insert(index: Integer): TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderResponseList.InsertItem(index: Integer; value: TFhirMessageHeaderResponse);
begin
  assert(value is TFhirMessageHeaderResponse);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderResponseList.Item(index: Integer): TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(ObjectByIndex[index]);
end;

function TFhirMessageHeaderResponseList.Link: TFhirMessageHeaderResponseList;
begin
  result := TFhirMessageHeaderResponseList(inherited Link);
end;

procedure TFhirMessageHeaderResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderResponseList.SetItemByIndex(index: Integer; value: TFhirMessageHeaderResponse);
begin
  assert(value is TFhirMessageHeaderResponse);
  FhirMessageHeaderResponses[index] := value;
end;

procedure TFhirMessageHeaderResponseList.SetItemN(index: Integer; value: TFhirMessageHeaderResponse);
begin
  assert(value is TFhirMessageHeaderResponse);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageHeader }

constructor TFhirMessageHeader.Create;
begin
  inherited;
end;

destructor TFhirMessageHeader.Destroy;
begin
  FEvent.free;
  FDestinationList.Free;
  FSender.free;
  FEnterer.free;
  FAuthor.free;
  FSource.free;
  FResponsible.free;
  FReason.free;
  FResponse.free;
  FFocusList.Free;
  FDefinition.free;
  inherited;
end;

procedure TFhirMessageHeader.Assign(oSource : TFslObject);
begin
  inherited;
  event := TFhirMessageHeader(oSource).event.Clone;
  if (TFhirMessageHeader(oSource).FDestinationList = nil) then
  begin
    FDestinationList.free;
    FDestinationList := nil;
  end
  else
  begin
    if FDestinationList = nil then
      FDestinationList := TFhirMessageHeaderDestinationList.Create;
    FDestinationList.Assign(TFhirMessageHeader(oSource).FDestinationList);
  end;
  sender := TFhirMessageHeader(oSource).sender.Clone;
  enterer := TFhirMessageHeader(oSource).enterer.Clone;
  author := TFhirMessageHeader(oSource).author.Clone;
  source := TFhirMessageHeader(oSource).source.Clone;
  responsible := TFhirMessageHeader(oSource).responsible.Clone;
  reason := TFhirMessageHeader(oSource).reason.Clone;
  response := TFhirMessageHeader(oSource).response.Clone;
  if (TFhirMessageHeader(oSource).FFocusList = nil) then
  begin
    FFocusList.free;
    FFocusList := nil;
  end
  else
  begin
    if FFocusList = nil then
      FFocusList := TFhirReferenceList.Create;
    FFocusList.Assign(TFhirMessageHeader(oSource).FFocusList);
  end;
  definitionElement := TFhirMessageHeader(oSource).definitionElement.Clone;
end;

function TFhirMessageHeader.GetResourceType : TFhirResourceType;
begin
  result := frtMessageHeader;
end;

procedure TFhirMessageHeader.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'event[x]') or (child_name = 'event') Then
     list.add(self.link, 'event[x]', FEvent.Link);
  if (child_name = 'destination') Then
    list.addAll(self, 'destination', FDestinationList);
  if (child_name = 'sender') Then
     list.add(self.link, 'sender', FSender.Link);
  if (child_name = 'enterer') Then
     list.add(self.link, 'enterer', FEnterer.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'responsible') Then
     list.add(self.link, 'responsible', FResponsible.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
  if (child_name = 'focus') Then
    list.addAll(self, 'focus', FFocusList);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
end;

procedure TFhirMessageHeader.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'event[x]', 'Coding|canonical', false, TFhirDataType, FEvent.Link));
  oList.add(TFHIRProperty.create(self, 'destination', 'BackboneElement', true, TFhirMessageHeaderDestination, FDestinationList.Link));
  oList.add(TFHIRProperty.create(self, 'sender', 'Reference', false, TFhirReference, FSender.Link));
  oList.add(TFHIRProperty.create(self, 'enterer', 'Reference', false, TFhirReference, FEnterer.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', false, TFhirReference, FAuthor.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'BackboneElement', false, TFhirMessageHeaderSource, FSource.Link));
  oList.add(TFHIRProperty.create(self, 'responsible', 'Reference', false, TFhirReference, FResponsible.Link));
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link));
  oList.add(TFHIRProperty.create(self, 'response', 'BackboneElement', false, TFhirMessageHeaderResponse, FResponse.Link));
  oList.add(TFHIRProperty.create(self, 'focus', 'Reference', true, TFhirReference, FFocusList.Link));
  oList.add(TFHIRProperty.create(self, 'definition', 'canonical', false, TFhirCanonical, FDefinition.Link));
end;

function TFhirMessageHeader.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'event', ['Coding', 'Canonical'])) then
  begin
    Event := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'destination') then
  begin
    DestinationList.add(propValue as TFhirMessageHeaderDestination);
    result := propValue;
  end
  else if (propName = 'sender') then
  begin
    Sender := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'enterer') then
  begin
    Enterer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirMessageHeaderSource;
    result := propValue;
  end
  else if (propName = 'responsible') then
  begin
    Responsible := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    Response := propValue as TFhirMessageHeaderResponse;
    result := propValue;
  end
  else if (propName = 'focus') then
  begin
    FocusList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionElement := asCanonical(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMessageHeader.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'destination') then DestinationList.insertItem(index, propValue as TFhirMessageHeaderDestination)
  else if (propName = 'focus') then FocusList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirMessageHeader.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'event', ['Coding', 'Canonical'])) then raise EFHIRException.create('Cannot make property Event')
  else if (propName = 'destination') then result := DestinationList.new()
  else if (propName = 'sender') then result := TFhirReference.create()
  else if (propName = 'enterer') then result := TFhirReference.create()
  else if (propName = 'author') then result := TFhirReference.create()
  else if (propName = 'source') then result := TFhirMessageHeaderSource.create()
  else if (propName = 'responsible') then result := TFhirReference.create()
  else if (propName = 'reason') then result := TFhirCodeableConcept.create()
  else if (propName = 'response') then result := TFhirMessageHeaderResponse.create()
  else if (propName = 'focus') then result := FocusList.new()
  else if (propName = 'definition') then result := TFhirCanonical.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageHeader.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'event[x]') then result := 'Coding|canonical'
  else if (propName = 'destination') then result := 'BackboneElement'
  else if (propName = 'sender') then result := 'Reference'
  else if (propName = 'enterer') then result := 'Reference'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'source') then result := 'BackboneElement'
  else if (propName = 'responsible') then result := 'Reference'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'response') then result := 'BackboneElement'
  else if (propName = 'focus') then result := 'Reference'
  else if (propName = 'definition') then result := 'canonical'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageHeader.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'event', ['Coding', 'Canonical'])) then EventElement := nil
  else if (propName = 'destination') then deletePropertyValue('destination', DestinationList, value)
  else if (propName = 'sender') then SenderElement := nil
  else if (propName = 'enterer') then EntererElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'responsible') then ResponsibleElement := nil
  else if (propName = 'reason') then ReasonElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else if (propName = 'focus') then deletePropertyValue('focus', FocusList, value)
  else if (propName = 'definition') then DefinitionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageHeader.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'event', ['Coding', 'Canonical'])) then EventElement := new as TFhirDataType
  else if (propName = 'destination') then replacePropertyValue('destination', DestinationList, existing, new)
  else if (propName = 'sender') then SenderElement := new as TFhirReference
  else if (propName = 'enterer') then EntererElement := new as TFhirReference
  else if (propName = 'author') then AuthorElement := new as TFhirReference
  else if (propName = 'source') then SourceElement := new as TFhirMessageHeaderSource
  else if (propName = 'responsible') then ResponsibleElement := new as TFhirReference
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept
  else if (propName = 'response') then ResponseElement := new as TFhirMessageHeaderResponse
  else if (propName = 'focus') then replacePropertyValue('focus', FocusList, existing, new)
  else if (propName = 'definition') then DefinitionElement := asCanonical(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageHeader.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'destination') then DestinationList.move(source, destination)
  else if (propName = 'focus') then FocusList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageHeader.fhirType : string;
begin
  result := 'MessageHeader';
end;

function TFhirMessageHeader.Link : TFhirMessageHeader;
begin
  result := TFhirMessageHeader(inherited Link);
end;

function TFhirMessageHeader.Clone : TFhirMessageHeader;
begin
  result := TFhirMessageHeader(inherited Clone);
end;

function TFhirMessageHeader.equals(other : TObject) : boolean; 
var
  o : TFhirMessageHeader;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageHeader)) then
    result := false
  else
  begin
    o := TFhirMessageHeader(other);
    result := compareDeep(eventElement, o.eventElement, true) and compareDeep(destinationList, o.destinationList, true) and 
      compareDeep(senderElement, o.senderElement, true) and compareDeep(entererElement, o.entererElement, true) and 
      compareDeep(authorElement, o.authorElement, true) and compareDeep(sourceElement, o.sourceElement, true) and 
      compareDeep(responsibleElement, o.responsibleElement, true) and compareDeep(reasonElement, o.reasonElement, true) and 
      compareDeep(responseElement, o.responseElement, true) and compareDeep(focusList, o.focusList, true) and 
      compareDeep(definitionElement, o.definitionElement, true);
  end;
end;

function TFhirMessageHeader.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FEvent) and isEmptyProp(FdestinationList) and isEmptyProp(FSender) and isEmptyProp(FEnterer) and isEmptyProp(FAuthor) and isEmptyProp(FSource) and isEmptyProp(FResponsible) and isEmptyProp(FReason) and isEmptyProp(FResponse) and isEmptyProp(FfocusList) and isEmptyProp(FDefinition);
end;

procedure TFhirMessageHeader.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('event[x]');
  fields.add('destination');
  fields.add('sender');
  fields.add('enterer');
  fields.add('author');
  fields.add('source');
  fields.add('responsible');
  fields.add('reason');
  fields.add('response');
  fields.add('focus');
  fields.add('definition');
end;

function TFhirMessageHeader.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FDestinationList.sizeInBytes(magic));
  inc(result, FFocusList.sizeInBytes(magic));
end;

procedure TFhirMessageHeader.SetEvent(value : TFhirDataType);
begin
  FEvent.free;
  FEvent := value;
end;

function TFhirMessageHeader.GetDestinationList : TFhirMessageHeaderDestinationList;
begin
  if FDestinationList = nil then
    FDestinationList := TFhirMessageHeaderDestinationList.Create;
  result := FDestinationList;
end;

function TFhirMessageHeader.GetHasDestinationList : boolean;
begin
  result := (FDestinationList <> nil) and (FDestinationList.count > 0);
end;

procedure TFhirMessageHeader.SetSender(value : TFhirReference);
begin
  FSender.free;
  FSender := value;
end;

procedure TFhirMessageHeader.SetEnterer(value : TFhirReference);
begin
  FEnterer.free;
  FEnterer := value;
end;

procedure TFhirMessageHeader.SetAuthor(value : TFhirReference);
begin
  FAuthor.free;
  FAuthor := value;
end;

procedure TFhirMessageHeader.SetSource(value : TFhirMessageHeaderSource);
begin
  FSource.free;
  FSource := value;
end;

procedure TFhirMessageHeader.SetResponsible(value : TFhirReference);
begin
  FResponsible.free;
  FResponsible := value;
end;

procedure TFhirMessageHeader.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value;
end;

procedure TFhirMessageHeader.SetResponse(value : TFhirMessageHeaderResponse);
begin
  FResponse.free;
  FResponse := value;
end;

function TFhirMessageHeader.GetFocusList : TFhirReferenceList;
begin
  if FFocusList = nil then
    FFocusList := TFhirReferenceList.Create;
  result := FFocusList;
end;

function TFhirMessageHeader.GetHasFocusList : boolean;
begin
  result := (FFocusList <> nil) and (FFocusList.count > 0);
end;

procedure TFhirMessageHeader.SetDefinition(value : TFhirCanonical);
begin
  FDefinition.free;
  FDefinition := value;
end;

function TFhirMessageHeader.GetDefinitionST : String;
begin
  if FDefinition = nil then
    result := ''
  else
    result := FDefinition.value;
end;

procedure TFhirMessageHeader.SetDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FDefinition = nil then
      FDefinition := TFhirCanonical.create;
    FDefinition.value := value
  end
  else if FDefinition <> nil then
    FDefinition.value := '';
end;

{ TFhirMessageHeaderListEnumerator }

constructor TFhirMessageHeaderListEnumerator.Create(list : TFhirMessageHeaderList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageHeaderListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageHeaderListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageHeaderListEnumerator.GetCurrent : TFhirMessageHeader;
begin
  Result := FList[FIndex];
end;

function TFhirMessageHeaderListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMessageHeaderList }

function TFhirMessageHeaderList.AddItem(value: TFhirMessageHeader): TFhirMessageHeader;
begin
  assert(value.ClassName = 'TFhirMessageHeader', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeader');
  add(value);
  result := value;
end;

function TFhirMessageHeaderList.Append: TFhirMessageHeader;
begin
  result := TFhirMessageHeader.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderList.GetEnumerator : TFhirMessageHeaderListEnumerator;
begin
  result := TFhirMessageHeaderListEnumerator.Create(self.link);
end;

function TFhirMessageHeaderList.Clone: TFhirMessageHeaderList;
begin
  result := TFhirMessageHeaderList(inherited Clone);
end;

function TFhirMessageHeaderList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderList.GetItemN(index: Integer): TFhirMessageHeader;
begin
  result := TFhirMessageHeader(ObjectByIndex[index]);
end;

function TFhirMessageHeaderList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageHeader;
end;
function TFhirMessageHeaderList.IndexOf(value: TFhirMessageHeader): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageHeaderList.Insert(index: Integer): TFhirMessageHeader;
begin
  result := TFhirMessageHeader.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderList.InsertItem(index: Integer; value: TFhirMessageHeader);
begin
  assert(value is TFhirMessageHeader);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderList.Item(index: Integer): TFhirMessageHeader;
begin
  result := TFhirMessageHeader(ObjectByIndex[index]);
end;

function TFhirMessageHeaderList.Link: TFhirMessageHeaderList;
begin
  result := TFhirMessageHeaderList(inherited Link);
end;

procedure TFhirMessageHeaderList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderList.SetItemByIndex(index: Integer; value: TFhirMessageHeader);
begin
  assert(value is TFhirMessageHeader);
  FhirMessageHeaders[index] := value;
end;

procedure TFhirMessageHeaderList.SetItemN(index: Integer; value: TFhirMessageHeader);
begin
  assert(value is TFhirMessageHeader);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_OPERATIONOUTCOME}
{ TFhirOperationOutcomeIssue }

constructor TFhirOperationOutcomeIssue.Create;
begin
  inherited;
end;

destructor TFhirOperationOutcomeIssue.Destroy;
begin
  FSeverity.free;
  FCode.free;
  FDetails.free;
  FDiagnostics.free;
  FLocationList.Free;
  FExpressionList.Free;
  inherited;
end;

procedure TFhirOperationOutcomeIssue.Assign(oSource : TFslObject);
begin
  inherited;
  severityElement := TFhirOperationOutcomeIssue(oSource).severityElement.Clone;
  codeElement := TFhirOperationOutcomeIssue(oSource).codeElement.Clone;
  details := TFhirOperationOutcomeIssue(oSource).details.Clone;
  diagnosticsElement := TFhirOperationOutcomeIssue(oSource).diagnosticsElement.Clone;
  if (TFhirOperationOutcomeIssue(oSource).FLocationList = nil) then
  begin
    FLocationList.free;
    FLocationList := nil;
  end
  else
  begin
    if FLocationList = nil then
      FLocationList := TFhirStringList.Create;
    FLocationList.Assign(TFhirOperationOutcomeIssue(oSource).FLocationList);
  end;
  if (TFhirOperationOutcomeIssue(oSource).FExpressionList = nil) then
  begin
    FExpressionList.free;
    FExpressionList := nil;
  end
  else
  begin
    if FExpressionList = nil then
      FExpressionList := TFhirStringList.Create;
    FExpressionList.Assign(TFhirOperationOutcomeIssue(oSource).FExpressionList);
  end;
end;

procedure TFhirOperationOutcomeIssue.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'severity') Then
     list.add(self.link, 'severity', FSeverity.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'details') Then
     list.add(self.link, 'details', FDetails.Link);
  if (child_name = 'diagnostics') Then
     list.add(self.link, 'diagnostics', FDiagnostics.Link);
  if (child_name = 'location') Then
    list.addAll(self, 'location', FLocationList);
  if (child_name = 'expression') Then
    list.addAll(self, 'expression', FExpressionList);
end;

procedure TFhirOperationOutcomeIssue.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'severity', 'code', false, TFhirEnum, FSeverity.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirEnum, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'details', 'CodeableConcept', false, TFhirCodeableConcept, FDetails.Link));
  oList.add(TFHIRProperty.create(self, 'diagnostics', 'string', false, TFhirString, FDiagnostics.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'string', true, TFhirString, FLocationList.Link));
  oList.add(TFHIRProperty.create(self, 'expression', 'string', true, TFhirString, FExpressionList.Link));
end;

function TFhirOperationOutcomeIssue.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'severity') then
  begin
    SeverityElement := asEnum(SYSTEMS_TFhirIssueSeverityEnum, CODES_TFhirIssueSeverityEnum, propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirIssueTypeEnum, CODES_TFhirIssueTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'details') then
  begin
    Details := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'diagnostics') then
  begin
    DiagnosticsElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'expression') then
  begin
    ExpressionList.add(asString(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOperationOutcomeIssue.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'location') then LocationList.insertItem(index, asString(propValue))
  else if (propName = 'expression') then ExpressionList.insertItem(index, asString(propValue))
  else inherited;
end;

function TFhirOperationOutcomeIssue.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'severity') then result := TFhirEnum.create(SYSTEMS_TFhirIssueSeverityEnum[IssueSeverityNull], CODES_TFhirIssueSeverityEnum[IssueSeverityNull]) 
  else if (propName = 'code') then result := TFhirEnum.create(SYSTEMS_TFhirIssueTypeEnum[IssueTypeNull], CODES_TFhirIssueTypeEnum[IssueTypeNull]) 
  else if (propName = 'details') then result := TFhirCodeableConcept.create()
  else if (propName = 'diagnostics') then result := TFhirString.create()
  else if (propName = 'location') then result := LocationList.new()
  else if (propName = 'expression') then result := ExpressionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirOperationOutcomeIssue.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'severity') then result := 'code'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'details') then result := 'CodeableConcept'
  else if (propName = 'diagnostics') then result := 'string'
  else if (propName = 'location') then result := 'string'
  else if (propName = 'expression') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOperationOutcomeIssue.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'severity') then SeverityElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'details') then DetailsElement := nil
  else if (propName = 'diagnostics') then DiagnosticsElement := nil
  else if (propName = 'location') then deletePropertyValue('location', LocationList, value)
  else if (propName = 'expression') then deletePropertyValue('expression', ExpressionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOperationOutcomeIssue.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'severity') then SeverityElement := asEnum(SYSTEMS_TFhirIssueSeverityEnum, CODES_TFhirIssueSeverityEnum, new)
  else if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirIssueTypeEnum, CODES_TFhirIssueTypeEnum, new)
  else if (propName = 'details') then DetailsElement := new as TFhirCodeableConcept
  else if (propName = 'diagnostics') then DiagnosticsElement := asString(new)
  else if (propName = 'location') then replacePropertyValue('location', LocationList, existing, new)
  else if (propName = 'expression') then replacePropertyValue('expression', ExpressionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOperationOutcomeIssue.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'location') then LocationList.move(source, destination)
  else if (propName = 'expression') then ExpressionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOperationOutcomeIssue.fhirType : string;
begin
  result := 'OperationOutcome.issue';
end;

function TFhirOperationOutcomeIssue.Link : TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(inherited Link);
end;

function TFhirOperationOutcomeIssue.Clone : TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(inherited Clone);
end;

function TFhirOperationOutcomeIssue.equals(other : TObject) : boolean; 
var
  o : TFhirOperationOutcomeIssue;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOperationOutcomeIssue)) then
    result := false
  else
  begin
    o := TFhirOperationOutcomeIssue(other);
    result := compareDeep(severityElement, o.severityElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(detailsElement, o.detailsElement, true) and compareDeep(diagnosticsElement, o.diagnosticsElement, true) and 
      compareDeep(locationList, o.locationList, true) and compareDeep(expressionList, o.expressionList, true);
  end;
end;

function TFhirOperationOutcomeIssue.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSeverity) and isEmptyProp(FCode) and isEmptyProp(FDetails) and isEmptyProp(FDiagnostics) and isEmptyProp(FlocationList) and isEmptyProp(FexpressionList);
end;

procedure TFhirOperationOutcomeIssue.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('severity');
  fields.add('code');
  fields.add('details');
  fields.add('diagnostics');
  fields.add('location');
  fields.add('expression');
end;

function TFhirOperationOutcomeIssue.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FLocationList.sizeInBytes(magic));
  inc(result, FExpressionList.sizeInBytes(magic));
end;

procedure TFhirOperationOutcomeIssue.SetSeverity(value : TFhirEnum);
begin
  FSeverity.free;
  FSeverity := value;
end;

function TFhirOperationOutcomeIssue.GetSeverityST : TFhirIssueSeverityEnum;
begin
  if FSeverity = nil then
    result := TFhirIssueSeverityEnum(0)
  else
    result := TFhirIssueSeverityEnum(StringArrayIndexOfSensitive(CODES_TFhirIssueSeverityEnum, FSeverity.value));
end;

procedure TFhirOperationOutcomeIssue.SetSeverityST(value : TFhirIssueSeverityEnum);
begin
  if ord(value) = 0 then
    SeverityElement := nil
  else
    SeverityElement := TFhirEnum.create(SYSTEMS_TFhirIssueSeverityEnum[value], CODES_TFhirIssueSeverityEnum[value]);
end;

procedure TFhirOperationOutcomeIssue.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

function TFhirOperationOutcomeIssue.GetCodeST : TFhirIssueTypeEnum;
begin
  if FCode = nil then
    result := TFhirIssueTypeEnum(0)
  else
    result := TFhirIssueTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirIssueTypeEnum, FCode.value));
end;

procedure TFhirOperationOutcomeIssue.SetCodeST(value : TFhirIssueTypeEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirIssueTypeEnum[value], CODES_TFhirIssueTypeEnum[value]);
end;

procedure TFhirOperationOutcomeIssue.SetDetails(value : TFhirCodeableConcept);
begin
  FDetails.free;
  FDetails := value;
end;

procedure TFhirOperationOutcomeIssue.SetDiagnostics(value : TFhirString);
begin
  FDiagnostics.free;
  FDiagnostics := value;
end;

function TFhirOperationOutcomeIssue.GetDiagnosticsST : String;
begin
  if FDiagnostics = nil then
    result := ''
  else
    result := FDiagnostics.value;
end;

procedure TFhirOperationOutcomeIssue.SetDiagnosticsST(value : String);
begin
  if value <> '' then
  begin
    if FDiagnostics = nil then
      FDiagnostics := TFhirString.create;
    FDiagnostics.value := value
  end
  else if FDiagnostics <> nil then
    FDiagnostics.value := '';
end;

function TFhirOperationOutcomeIssue.GetLocationList : TFhirStringList;
begin
  if FLocationList = nil then
    FLocationList := TFhirStringList.Create;
  result := FLocationList;
end;

function TFhirOperationOutcomeIssue.GetHasLocationList : boolean;
begin
  result := (FLocationList <> nil) and (FLocationList.count > 0);
end;

function TFhirOperationOutcomeIssue.GetExpressionList : TFhirStringList;
begin
  if FExpressionList = nil then
    FExpressionList := TFhirStringList.Create;
  result := FExpressionList;
end;

function TFhirOperationOutcomeIssue.GetHasExpressionList : boolean;
begin
  result := (FExpressionList <> nil) and (FExpressionList.count > 0);
end;

{ TFhirOperationOutcomeIssueListEnumerator }

constructor TFhirOperationOutcomeIssueListEnumerator.Create(list : TFhirOperationOutcomeIssueList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOperationOutcomeIssueListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOperationOutcomeIssueListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOperationOutcomeIssueListEnumerator.GetCurrent : TFhirOperationOutcomeIssue;
begin
  Result := FList[FIndex];
end;

function TFhirOperationOutcomeIssueListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirOperationOutcomeIssueList }

function TFhirOperationOutcomeIssueList.AddItem(value: TFhirOperationOutcomeIssue): TFhirOperationOutcomeIssue;
begin
  assert(value.ClassName = 'TFhirOperationOutcomeIssue', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationOutcomeIssue');
  add(value);
  result := value;
end;

function TFhirOperationOutcomeIssueList.Append: TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationOutcomeIssueList.ClearItems;
begin
  Clear;
end;

function TFhirOperationOutcomeIssueList.GetEnumerator : TFhirOperationOutcomeIssueListEnumerator;
begin
  result := TFhirOperationOutcomeIssueListEnumerator.Create(self.link);
end;

function TFhirOperationOutcomeIssueList.Clone: TFhirOperationOutcomeIssueList;
begin
  result := TFhirOperationOutcomeIssueList(inherited Clone);
end;

function TFhirOperationOutcomeIssueList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationOutcomeIssueList.GetItemN(index: Integer): TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeIssueList.ItemClass: TFslObjectClass;
begin
  result := TFhirOperationOutcomeIssue;
end;
function TFhirOperationOutcomeIssueList.IndexOf(value: TFhirOperationOutcomeIssue): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOperationOutcomeIssueList.Insert(index: Integer): TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationOutcomeIssueList.InsertItem(index: Integer; value: TFhirOperationOutcomeIssue);
begin
  assert(value is TFhirOperationOutcomeIssue);
  Inherited Insert(index, value);
end;

function TFhirOperationOutcomeIssueList.Item(index: Integer): TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeIssueList.Link: TFhirOperationOutcomeIssueList;
begin
  result := TFhirOperationOutcomeIssueList(inherited Link);
end;

procedure TFhirOperationOutcomeIssueList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationOutcomeIssueList.SetItemByIndex(index: Integer; value: TFhirOperationOutcomeIssue);
begin
  assert(value is TFhirOperationOutcomeIssue);
  FhirOperationOutcomeIssues[index] := value;
end;

procedure TFhirOperationOutcomeIssueList.SetItemN(index: Integer; value: TFhirOperationOutcomeIssue);
begin
  assert(value is TFhirOperationOutcomeIssue);
  ObjectByIndex[index] := value;
end;

{ TFhirOperationOutcome }

constructor TFhirOperationOutcome.Create;
begin
  inherited;
end;

destructor TFhirOperationOutcome.Destroy;
begin
  FIssueList.Free;
  inherited;
end;

procedure TFhirOperationOutcome.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirOperationOutcome(oSource).FIssueList = nil) then
  begin
    FIssueList.free;
    FIssueList := nil;
  end
  else
  begin
    if FIssueList = nil then
      FIssueList := TFhirOperationOutcomeIssueList.Create;
    FIssueList.Assign(TFhirOperationOutcome(oSource).FIssueList);
  end;
end;

function TFhirOperationOutcome.GetResourceType : TFhirResourceType;
begin
  result := frtOperationOutcome;
end;

procedure TFhirOperationOutcome.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'issue') Then
    list.addAll(self, 'issue', FIssueList);
end;

procedure TFhirOperationOutcome.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'issue', 'BackboneElement', true, TFhirOperationOutcomeIssue, FIssueList.Link));
end;

function TFhirOperationOutcome.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'issue') then
  begin
    IssueList.add(propValue as TFhirOperationOutcomeIssue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOperationOutcome.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'issue') then IssueList.insertItem(index, propValue as TFhirOperationOutcomeIssue)
  else inherited;
end;

function TFhirOperationOutcome.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'issue') then result := IssueList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirOperationOutcome.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'issue') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOperationOutcome.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'issue') then deletePropertyValue('issue', IssueList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOperationOutcome.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'issue') then replacePropertyValue('issue', IssueList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOperationOutcome.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'issue') then IssueList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOperationOutcome.fhirType : string;
begin
  result := 'OperationOutcome';
end;

function TFhirOperationOutcome.Link : TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome(inherited Link);
end;

function TFhirOperationOutcome.Clone : TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome(inherited Clone);
end;

function TFhirOperationOutcome.equals(other : TObject) : boolean; 
var
  o : TFhirOperationOutcome;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOperationOutcome)) then
    result := false
  else
  begin
    o := TFhirOperationOutcome(other);
    result := compareDeep(issueList, o.issueList, true);
  end;
end;

function TFhirOperationOutcome.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FissueList);
end;

procedure TFhirOperationOutcome.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('issue');
end;

function TFhirOperationOutcome.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIssueList.sizeInBytes(magic));
end;

function TFhirOperationOutcome.GetIssueList : TFhirOperationOutcomeIssueList;
begin
  if FIssueList = nil then
    FIssueList := TFhirOperationOutcomeIssueList.Create;
  result := FIssueList;
end;

function TFhirOperationOutcome.GetHasIssueList : boolean;
begin
  result := (FIssueList <> nil) and (FIssueList.count > 0);
end;

{ TFhirOperationOutcomeListEnumerator }

constructor TFhirOperationOutcomeListEnumerator.Create(list : TFhirOperationOutcomeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOperationOutcomeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOperationOutcomeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOperationOutcomeListEnumerator.GetCurrent : TFhirOperationOutcome;
begin
  Result := FList[FIndex];
end;

function TFhirOperationOutcomeListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirOperationOutcomeList }

function TFhirOperationOutcomeList.AddItem(value: TFhirOperationOutcome): TFhirOperationOutcome;
begin
  assert(value.ClassName = 'TFhirOperationOutcome', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationOutcome');
  add(value);
  result := value;
end;

function TFhirOperationOutcomeList.Append: TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationOutcomeList.ClearItems;
begin
  Clear;
end;

function TFhirOperationOutcomeList.GetEnumerator : TFhirOperationOutcomeListEnumerator;
begin
  result := TFhirOperationOutcomeListEnumerator.Create(self.link);
end;

function TFhirOperationOutcomeList.Clone: TFhirOperationOutcomeList;
begin
  result := TFhirOperationOutcomeList(inherited Clone);
end;

function TFhirOperationOutcomeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationOutcomeList.GetItemN(index: Integer): TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeList.ItemClass: TFslObjectClass;
begin
  result := TFhirOperationOutcome;
end;
function TFhirOperationOutcomeList.IndexOf(value: TFhirOperationOutcome): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOperationOutcomeList.Insert(index: Integer): TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationOutcomeList.InsertItem(index: Integer; value: TFhirOperationOutcome);
begin
  assert(value is TFhirOperationOutcome);
  Inherited Insert(index, value);
end;

function TFhirOperationOutcomeList.Item(index: Integer): TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeList.Link: TFhirOperationOutcomeList;
begin
  result := TFhirOperationOutcomeList(inherited Link);
end;

procedure TFhirOperationOutcomeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationOutcomeList.SetItemByIndex(index: Integer; value: TFhirOperationOutcome);
begin
  assert(value is TFhirOperationOutcome);
  FhirOperationOutcomes[index] := value;
end;

procedure TFhirOperationOutcomeList.SetItemN(index: Integer; value: TFhirOperationOutcome);
begin
  assert(value is TFhirOperationOutcome);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_PARAMETERS}
{ TFhirParametersParameter }

constructor TFhirParametersParameter.Create;
begin
  inherited;
end;

destructor TFhirParametersParameter.Destroy;
begin
  FName.free;
  FValue.free;
  FResource.free;
  FPartList.Free;
  inherited;
end;

procedure TFhirParametersParameter.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirParametersParameter(oSource).nameElement.Clone;
  value := TFhirParametersParameter(oSource).value.Clone;
  resource := TFhirParametersParameter(oSource).resource.Clone;
  if (TFhirParametersParameter(oSource).FPartList = nil) then
  begin
    FPartList.free;
    FPartList := nil;
  end
  else
  begin
    if FPartList = nil then
      FPartList := TFhirParametersParameterList.Create;
    FPartList.Assign(TFhirParametersParameter(oSource).FPartList);
  end;
end;

procedure TFhirParametersParameter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'part') Then
    list.addAll(self, 'part', FPartList);
end;

procedure TFhirParametersParameter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|integer64|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|CodeableReference|Coding|ContactPoint|Count|Distanc'+'e|Duration|HumanName|Identifier|Money|Period|Quantity|Range|Ratio|RatioRange|Reference|SampledData|Signature|Timing|ContactDetail|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|'+'UsageContext|Availability|ExtendedContactDetail|Dosage|Meta', false, TFhirDataType, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'resource', 'Resource', false, TFhirResource, FResource.Link));
  oList.add(TFHIRProperty.create(self, 'part', '', true, TFhirParametersParameter, FPartList.Link));
end;

function TFhirParametersParameter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Integer64', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'CodeableReference', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'RatioRange', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Availability', 'ExtendedContactDetail', 'Dosage', 'Meta'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    Resource := propValue as TFhirResource;
    result := propValue;
  end
  else if (propName = 'part') then
  begin
    PartList.add(propValue as TFhirParametersParameter);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirParametersParameter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'part') then PartList.insertItem(index, propValue as TFhirParametersParameter)
  else inherited;
end;

function TFhirParametersParameter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Integer64', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'CodeableReference', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'RatioRange', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Availability', 'ExtendedContactDetail', 'Dosage', 'Meta'])) then raise EFHIRException.create('Cannot make property Value')
  else if (propName = 'resource') then raise EFHIRException.create('Cannot make property Resource')
  else if (propName = 'part') then result := PartList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirParametersParameter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'value[x]') then result := 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|integer64|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|CodeableReference|Coding|ContactPoint|Count|Distanc'+'e|Duration|HumanName|Identifier|Money|Period|Quantity|Range|Ratio|RatioRange|Reference|SampledData|Signature|Timing|ContactDetail|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|'+'UsageContext|Availability|ExtendedContactDetail|Dosage|Meta'
  else if (propName = 'resource') then result := 'Resource'
  else if (propName = 'part') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirParametersParameter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Integer64', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'CodeableReference', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'RatioRange', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Availability', 'ExtendedContactDetail', 'Dosage', 'Meta'])) then ValueElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'part') then deletePropertyValue('part', PartList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirParametersParameter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Integer64', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'CodeableReference', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'RatioRange', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Availability', 'ExtendedContactDetail', 'Dosage', 'Meta'])) then ValueElement := new as TFhirDataType
  else if (propName = 'resource') then ResourceElement := new as TFhirResource
  else if (propName = 'part') then replacePropertyValue('part', PartList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirParametersParameter.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'part') then PartList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirParametersParameter.fhirType : string;
begin
  result := 'Parameters.parameter';
end;

function TFhirParametersParameter.Link : TFhirParametersParameter;
begin
  result := TFhirParametersParameter(inherited Link);
end;

function TFhirParametersParameter.Clone : TFhirParametersParameter;
begin
  result := TFhirParametersParameter(inherited Clone);
end;

function TFhirParametersParameter.equals(other : TObject) : boolean; 
var
  o : TFhirParametersParameter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirParametersParameter)) then
    result := false
  else
  begin
    o := TFhirParametersParameter(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(resourceElement, o.resourceElement, true) and compareDeep(partList, o.partList, true);
  end;
end;

function TFhirParametersParameter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FValue) and isEmptyProp(FResource) and isEmptyProp(FpartList);
end;

procedure TFhirParametersParameter.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('value[x]');
  fields.add('resource');
  fields.add('part');
end;

function TFhirParametersParameter.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FPartList.sizeInBytes(magic));
end;

procedure TFhirParametersParameter.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirParametersParameter.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirParametersParameter.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirParametersParameter.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

procedure TFhirParametersParameter.SetResource(value : TFhirResource);
begin
  FResource.free;
  FResource := value;
end;

function TFhirParametersParameter.GetPartList : TFhirParametersParameterList;
begin
  if FPartList = nil then
    FPartList := TFhirParametersParameterList.Create;
  result := FPartList;
end;

function TFhirParametersParameter.GetHasPartList : boolean;
begin
  result := (FPartList <> nil) and (FPartList.count > 0);
end;

{ TFhirParametersParameterListEnumerator }

constructor TFhirParametersParameterListEnumerator.Create(list : TFhirParametersParameterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirParametersParameterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirParametersParameterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirParametersParameterListEnumerator.GetCurrent : TFhirParametersParameter;
begin
  Result := FList[FIndex];
end;

function TFhirParametersParameterListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirParametersParameterList }

function TFhirParametersParameterList.AddItem(value: TFhirParametersParameter): TFhirParametersParameter;
begin
  assert(value.ClassName = 'TFhirParametersParameter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirParametersParameter');
  add(value);
  result := value;
end;

function TFhirParametersParameterList.Append: TFhirParametersParameter;
begin
  result := TFhirParametersParameter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirParametersParameterList.ClearItems;
begin
  Clear;
end;

function TFhirParametersParameterList.GetEnumerator : TFhirParametersParameterListEnumerator;
begin
  result := TFhirParametersParameterListEnumerator.Create(self.link);
end;

function TFhirParametersParameterList.Clone: TFhirParametersParameterList;
begin
  result := TFhirParametersParameterList(inherited Clone);
end;

function TFhirParametersParameterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirParametersParameterList.GetItemN(index: Integer): TFhirParametersParameter;
begin
  result := TFhirParametersParameter(ObjectByIndex[index]);
end;

function TFhirParametersParameterList.ItemClass: TFslObjectClass;
begin
  result := TFhirParametersParameter;
end;
function TFhirParametersParameterList.IndexOf(value: TFhirParametersParameter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirParametersParameterList.Insert(index: Integer): TFhirParametersParameter;
begin
  result := TFhirParametersParameter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirParametersParameterList.InsertItem(index: Integer; value: TFhirParametersParameter);
begin
  assert(value is TFhirParametersParameter);
  Inherited Insert(index, value);
end;

function TFhirParametersParameterList.Item(index: Integer): TFhirParametersParameter;
begin
  result := TFhirParametersParameter(ObjectByIndex[index]);
end;

function TFhirParametersParameterList.Link: TFhirParametersParameterList;
begin
  result := TFhirParametersParameterList(inherited Link);
end;

procedure TFhirParametersParameterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirParametersParameterList.SetItemByIndex(index: Integer; value: TFhirParametersParameter);
begin
  assert(value is TFhirParametersParameter);
  FhirParametersParameters[index] := value;
end;

procedure TFhirParametersParameterList.SetItemN(index: Integer; value: TFhirParametersParameter);
begin
  assert(value is TFhirParametersParameter);
  ObjectByIndex[index] := value;
end;

{ TFhirParameters }

constructor TFhirParameters.Create;
begin
  inherited;
end;

destructor TFhirParameters.Destroy;
begin
  FParameterList.Free;
  inherited;
end;

procedure TFhirParameters.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirParameters(oSource).FParameterList = nil) then
  begin
    FParameterList.free;
    FParameterList := nil;
  end
  else
  begin
    if FParameterList = nil then
      FParameterList := TFhirParametersParameterList.Create;
    FParameterList.Assign(TFhirParameters(oSource).FParameterList);
  end;
end;

function TFhirParameters.GetResourceType : TFhirResourceType;
begin
  result := frtParameters;
end;

procedure TFhirParameters.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'parameter') Then
    list.addAll(self, 'parameter', FParameterList);
end;

procedure TFhirParameters.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'parameter', 'BackboneElement', true, TFhirParametersParameter, FParameterList.Link));
end;

function TFhirParameters.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'parameter') then
  begin
    ParameterList.add(propValue as TFhirParametersParameter);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirParameters.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'parameter') then ParameterList.insertItem(index, propValue as TFhirParametersParameter)
  else inherited;
end;

function TFhirParameters.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'parameter') then result := ParameterList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirParameters.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'parameter') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirParameters.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'parameter') then deletePropertyValue('parameter', ParameterList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirParameters.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'parameter') then replacePropertyValue('parameter', ParameterList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirParameters.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'parameter') then ParameterList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirParameters.fhirType : string;
begin
  result := 'Parameters';
end;

function TFhirParameters.Link : TFhirParameters;
begin
  result := TFhirParameters(inherited Link);
end;

function TFhirParameters.Clone : TFhirParameters;
begin
  result := TFhirParameters(inherited Clone);
end;

function TFhirParameters.equals(other : TObject) : boolean; 
var
  o : TFhirParameters;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirParameters)) then
    result := false
  else
  begin
    o := TFhirParameters(other);
    result := compareDeep(parameterList, o.parameterList, true);
  end;
end;

function TFhirParameters.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FparameterList);
end;

procedure TFhirParameters.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('parameter');
end;

function TFhirParameters.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FParameterList.sizeInBytes(magic));
end;

function TFhirParameters.GetParameterList : TFhirParametersParameterList;
begin
  if FParameterList = nil then
    FParameterList := TFhirParametersParameterList.Create;
  result := FParameterList;
end;

function TFhirParameters.GetHasParameterList : boolean;
begin
  result := (FParameterList <> nil) and (FParameterList.count > 0);
end;

{ TFhirParametersListEnumerator }

constructor TFhirParametersListEnumerator.Create(list : TFhirParametersList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirParametersListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirParametersListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirParametersListEnumerator.GetCurrent : TFhirParameters;
begin
  Result := FList[FIndex];
end;

function TFhirParametersListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirParametersList }

function TFhirParametersList.AddItem(value: TFhirParameters): TFhirParameters;
begin
  assert(value.ClassName = 'TFhirParameters', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirParameters');
  add(value);
  result := value;
end;

function TFhirParametersList.Append: TFhirParameters;
begin
  result := TFhirParameters.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirParametersList.ClearItems;
begin
  Clear;
end;

function TFhirParametersList.GetEnumerator : TFhirParametersListEnumerator;
begin
  result := TFhirParametersListEnumerator.Create(self.link);
end;

function TFhirParametersList.Clone: TFhirParametersList;
begin
  result := TFhirParametersList(inherited Clone);
end;

function TFhirParametersList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirParametersList.GetItemN(index: Integer): TFhirParameters;
begin
  result := TFhirParameters(ObjectByIndex[index]);
end;

function TFhirParametersList.ItemClass: TFslObjectClass;
begin
  result := TFhirParameters;
end;
function TFhirParametersList.IndexOf(value: TFhirParameters): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirParametersList.Insert(index: Integer): TFhirParameters;
begin
  result := TFhirParameters.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirParametersList.InsertItem(index: Integer; value: TFhirParameters);
begin
  assert(value is TFhirParameters);
  Inherited Insert(index, value);
end;

function TFhirParametersList.Item(index: Integer): TFhirParameters;
begin
  result := TFhirParameters(ObjectByIndex[index]);
end;

function TFhirParametersList.Link: TFhirParametersList;
begin
  result := TFhirParametersList(inherited Link);
end;

procedure TFhirParametersList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirParametersList.SetItemByIndex(index: Integer; value: TFhirParameters);
begin
  assert(value is TFhirParameters);
  FhirParameters[index] := value;
end;

procedure TFhirParametersList.SetItemN(index: Integer; value: TFhirParameters);
begin
  assert(value is TFhirParameters);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_PERMISSION}
{ TFhirPermissionJustification }

constructor TFhirPermissionJustification.Create;
begin
  inherited;
end;

destructor TFhirPermissionJustification.Destroy;
begin
  FBasisList.Free;
  FEvidenceList.Free;
  inherited;
end;

procedure TFhirPermissionJustification.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPermissionJustification(oSource).FBasisList = nil) then
  begin
    FBasisList.free;
    FBasisList := nil;
  end
  else
  begin
    if FBasisList = nil then
      FBasisList := TFhirCodeableConceptList.Create;
    FBasisList.Assign(TFhirPermissionJustification(oSource).FBasisList);
  end;
  if (TFhirPermissionJustification(oSource).FEvidenceList = nil) then
  begin
    FEvidenceList.free;
    FEvidenceList := nil;
  end
  else
  begin
    if FEvidenceList = nil then
      FEvidenceList := TFhirReferenceList.Create;
    FEvidenceList.Assign(TFhirPermissionJustification(oSource).FEvidenceList);
  end;
end;

procedure TFhirPermissionJustification.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'basis') Then
    list.addAll(self, 'basis', FBasisList);
  if (child_name = 'evidence') Then
    list.addAll(self, 'evidence', FEvidenceList);
end;

procedure TFhirPermissionJustification.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'basis', 'CodeableConcept', true, TFhirCodeableConcept, FBasisList.Link));
  oList.add(TFHIRProperty.create(self, 'evidence', 'Reference', true, TFhirReference, FEvidenceList.Link));
end;

function TFhirPermissionJustification.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'basis') then
  begin
    BasisList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'evidence') then
  begin
    EvidenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPermissionJustification.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'basis') then BasisList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'evidence') then EvidenceList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirPermissionJustification.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'basis') then result := BasisList.new()
  else if (propName = 'evidence') then result := EvidenceList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPermissionJustification.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'basis') then result := 'CodeableConcept'
  else if (propName = 'evidence') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPermissionJustification.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'basis') then deletePropertyValue('basis', BasisList, value)
  else if (propName = 'evidence') then deletePropertyValue('evidence', EvidenceList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPermissionJustification.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'basis') then replacePropertyValue('basis', BasisList, existing, new)
  else if (propName = 'evidence') then replacePropertyValue('evidence', EvidenceList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPermissionJustification.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'basis') then BasisList.move(source, destination)
  else if (propName = 'evidence') then EvidenceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPermissionJustification.fhirType : string;
begin
  result := 'Permission.justification';
end;

function TFhirPermissionJustification.Link : TFhirPermissionJustification;
begin
  result := TFhirPermissionJustification(inherited Link);
end;

function TFhirPermissionJustification.Clone : TFhirPermissionJustification;
begin
  result := TFhirPermissionJustification(inherited Clone);
end;

function TFhirPermissionJustification.equals(other : TObject) : boolean; 
var
  o : TFhirPermissionJustification;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPermissionJustification)) then
    result := false
  else
  begin
    o := TFhirPermissionJustification(other);
    result := compareDeep(basisList, o.basisList, true) and compareDeep(evidenceList, o.evidenceList, true);
  end;
end;

function TFhirPermissionJustification.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FbasisList) and isEmptyProp(FevidenceList);
end;

procedure TFhirPermissionJustification.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('basis');
  fields.add('evidence');
end;

function TFhirPermissionJustification.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FBasisList.sizeInBytes(magic));
  inc(result, FEvidenceList.sizeInBytes(magic));
end;

function TFhirPermissionJustification.GetBasisList : TFhirCodeableConceptList;
begin
  if FBasisList = nil then
    FBasisList := TFhirCodeableConceptList.Create;
  result := FBasisList;
end;

function TFhirPermissionJustification.GetHasBasisList : boolean;
begin
  result := (FBasisList <> nil) and (FBasisList.count > 0);
end;

function TFhirPermissionJustification.GetEvidenceList : TFhirReferenceList;
begin
  if FEvidenceList = nil then
    FEvidenceList := TFhirReferenceList.Create;
  result := FEvidenceList;
end;

function TFhirPermissionJustification.GetHasEvidenceList : boolean;
begin
  result := (FEvidenceList <> nil) and (FEvidenceList.count > 0);
end;

{ TFhirPermissionJustificationListEnumerator }

constructor TFhirPermissionJustificationListEnumerator.Create(list : TFhirPermissionJustificationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPermissionJustificationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPermissionJustificationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPermissionJustificationListEnumerator.GetCurrent : TFhirPermissionJustification;
begin
  Result := FList[FIndex];
end;

function TFhirPermissionJustificationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPermissionJustificationList }

function TFhirPermissionJustificationList.AddItem(value: TFhirPermissionJustification): TFhirPermissionJustification;
begin
  assert(value.ClassName = 'TFhirPermissionJustification', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPermissionJustification');
  add(value);
  result := value;
end;

function TFhirPermissionJustificationList.Append: TFhirPermissionJustification;
begin
  result := TFhirPermissionJustification.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPermissionJustificationList.ClearItems;
begin
  Clear;
end;

function TFhirPermissionJustificationList.GetEnumerator : TFhirPermissionJustificationListEnumerator;
begin
  result := TFhirPermissionJustificationListEnumerator.Create(self.link);
end;

function TFhirPermissionJustificationList.Clone: TFhirPermissionJustificationList;
begin
  result := TFhirPermissionJustificationList(inherited Clone);
end;

function TFhirPermissionJustificationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPermissionJustificationList.GetItemN(index: Integer): TFhirPermissionJustification;
begin
  result := TFhirPermissionJustification(ObjectByIndex[index]);
end;

function TFhirPermissionJustificationList.ItemClass: TFslObjectClass;
begin
  result := TFhirPermissionJustification;
end;
function TFhirPermissionJustificationList.IndexOf(value: TFhirPermissionJustification): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPermissionJustificationList.Insert(index: Integer): TFhirPermissionJustification;
begin
  result := TFhirPermissionJustification.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPermissionJustificationList.InsertItem(index: Integer; value: TFhirPermissionJustification);
begin
  assert(value is TFhirPermissionJustification);
  Inherited Insert(index, value);
end;

function TFhirPermissionJustificationList.Item(index: Integer): TFhirPermissionJustification;
begin
  result := TFhirPermissionJustification(ObjectByIndex[index]);
end;

function TFhirPermissionJustificationList.Link: TFhirPermissionJustificationList;
begin
  result := TFhirPermissionJustificationList(inherited Link);
end;

procedure TFhirPermissionJustificationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPermissionJustificationList.SetItemByIndex(index: Integer; value: TFhirPermissionJustification);
begin
  assert(value is TFhirPermissionJustification);
  FhirPermissionJustifications[index] := value;
end;

procedure TFhirPermissionJustificationList.SetItemN(index: Integer; value: TFhirPermissionJustification);
begin
  assert(value is TFhirPermissionJustification);
  ObjectByIndex[index] := value;
end;

{ TFhirPermissionRule }

constructor TFhirPermissionRule.Create;
begin
  inherited;
end;

destructor TFhirPermissionRule.Destroy;
begin
  FType_.free;
  FDataList.Free;
  FActivityList.Free;
  FLimitList.Free;
  inherited;
end;

procedure TFhirPermissionRule.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirPermissionRule(oSource).type_Element.Clone;
  if (TFhirPermissionRule(oSource).FDataList = nil) then
  begin
    FDataList.free;
    FDataList := nil;
  end
  else
  begin
    if FDataList = nil then
      FDataList := TFhirPermissionRuleDataList.Create;
    FDataList.Assign(TFhirPermissionRule(oSource).FDataList);
  end;
  if (TFhirPermissionRule(oSource).FActivityList = nil) then
  begin
    FActivityList.free;
    FActivityList := nil;
  end
  else
  begin
    if FActivityList = nil then
      FActivityList := TFhirPermissionRuleActivityList.Create;
    FActivityList.Assign(TFhirPermissionRule(oSource).FActivityList);
  end;
  if (TFhirPermissionRule(oSource).FLimitList = nil) then
  begin
    FLimitList.free;
    FLimitList := nil;
  end
  else
  begin
    if FLimitList = nil then
      FLimitList := TFhirCodeableConceptList.Create;
    FLimitList.Assign(TFhirPermissionRule(oSource).FLimitList);
  end;
end;

procedure TFhirPermissionRule.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'data') Then
    list.addAll(self, 'data', FDataList);
  if (child_name = 'activity') Then
    list.addAll(self, 'activity', FActivityList);
  if (child_name = 'limit') Then
    list.addAll(self, 'limit', FLimitList);
end;

procedure TFhirPermissionRule.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'data', 'BackboneElement', true, TFhirPermissionRuleData, FDataList.Link));
  oList.add(TFHIRProperty.create(self, 'activity', 'BackboneElement', true, TFhirPermissionRuleActivity, FActivityList.Link));
  oList.add(TFHIRProperty.create(self, 'limit', 'CodeableConcept', true, TFhirCodeableConcept, FLimitList.Link));
end;

function TFhirPermissionRule.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirConsentProvisionTypeEnum, CODES_TFhirConsentProvisionTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'data') then
  begin
    DataList.add(propValue as TFhirPermissionRuleData);
    result := propValue;
  end
  else if (propName = 'activity') then
  begin
    ActivityList.add(propValue as TFhirPermissionRuleActivity);
    result := propValue;
  end
  else if (propName = 'limit') then
  begin
    LimitList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPermissionRule.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'data') then DataList.insertItem(index, propValue as TFhirPermissionRuleData)
  else if (propName = 'activity') then ActivityList.insertItem(index, propValue as TFhirPermissionRuleActivity)
  else if (propName = 'limit') then LimitList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirPermissionRule.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirConsentProvisionTypeEnum[ConsentProvisionTypeNull], CODES_TFhirConsentProvisionTypeEnum[ConsentProvisionTypeNull]) 
  else if (propName = 'data') then result := DataList.new()
  else if (propName = 'activity') then result := ActivityList.new()
  else if (propName = 'limit') then result := LimitList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPermissionRule.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'data') then result := 'BackboneElement'
  else if (propName = 'activity') then result := 'BackboneElement'
  else if (propName = 'limit') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPermissionRule.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'data') then deletePropertyValue('data', DataList, value)
  else if (propName = 'activity') then deletePropertyValue('activity', ActivityList, value)
  else if (propName = 'limit') then deletePropertyValue('limit', LimitList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPermissionRule.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirConsentProvisionTypeEnum, CODES_TFhirConsentProvisionTypeEnum, new)
  else if (propName = 'data') then replacePropertyValue('data', DataList, existing, new)
  else if (propName = 'activity') then replacePropertyValue('activity', ActivityList, existing, new)
  else if (propName = 'limit') then replacePropertyValue('limit', LimitList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPermissionRule.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'data') then DataList.move(source, destination)
  else if (propName = 'activity') then ActivityList.move(source, destination)
  else if (propName = 'limit') then LimitList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPermissionRule.fhirType : string;
begin
  result := 'Permission.rule';
end;

function TFhirPermissionRule.Link : TFhirPermissionRule;
begin
  result := TFhirPermissionRule(inherited Link);
end;

function TFhirPermissionRule.Clone : TFhirPermissionRule;
begin
  result := TFhirPermissionRule(inherited Clone);
end;

function TFhirPermissionRule.equals(other : TObject) : boolean; 
var
  o : TFhirPermissionRule;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPermissionRule)) then
    result := false
  else
  begin
    o := TFhirPermissionRule(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(dataList, o.dataList, true) and 
      compareDeep(activityList, o.activityList, true) and compareDeep(limitList, o.limitList, true);
  end;
end;

function TFhirPermissionRule.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FdataList) and isEmptyProp(FactivityList) and isEmptyProp(FlimitList);
end;

procedure TFhirPermissionRule.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('data');
  fields.add('activity');
  fields.add('limit');
end;

function TFhirPermissionRule.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FDataList.sizeInBytes(magic));
  inc(result, FActivityList.sizeInBytes(magic));
  inc(result, FLimitList.sizeInBytes(magic));
end;

procedure TFhirPermissionRule.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirPermissionRule.GetType_ST : TFhirConsentProvisionTypeEnum;
begin
  if FType_ = nil then
    result := TFhirConsentProvisionTypeEnum(0)
  else
    result := TFhirConsentProvisionTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirConsentProvisionTypeEnum, FType_.value));
end;

procedure TFhirPermissionRule.SetType_ST(value : TFhirConsentProvisionTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirConsentProvisionTypeEnum[value], CODES_TFhirConsentProvisionTypeEnum[value]);
end;

function TFhirPermissionRule.GetDataList : TFhirPermissionRuleDataList;
begin
  if FDataList = nil then
    FDataList := TFhirPermissionRuleDataList.Create;
  result := FDataList;
end;

function TFhirPermissionRule.GetHasDataList : boolean;
begin
  result := (FDataList <> nil) and (FDataList.count > 0);
end;

function TFhirPermissionRule.GetActivityList : TFhirPermissionRuleActivityList;
begin
  if FActivityList = nil then
    FActivityList := TFhirPermissionRuleActivityList.Create;
  result := FActivityList;
end;

function TFhirPermissionRule.GetHasActivityList : boolean;
begin
  result := (FActivityList <> nil) and (FActivityList.count > 0);
end;

function TFhirPermissionRule.GetLimitList : TFhirCodeableConceptList;
begin
  if FLimitList = nil then
    FLimitList := TFhirCodeableConceptList.Create;
  result := FLimitList;
end;

function TFhirPermissionRule.GetHasLimitList : boolean;
begin
  result := (FLimitList <> nil) and (FLimitList.count > 0);
end;

{ TFhirPermissionRuleListEnumerator }

constructor TFhirPermissionRuleListEnumerator.Create(list : TFhirPermissionRuleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPermissionRuleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPermissionRuleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPermissionRuleListEnumerator.GetCurrent : TFhirPermissionRule;
begin
  Result := FList[FIndex];
end;

function TFhirPermissionRuleListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPermissionRuleList }

function TFhirPermissionRuleList.AddItem(value: TFhirPermissionRule): TFhirPermissionRule;
begin
  assert(value.ClassName = 'TFhirPermissionRule', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPermissionRule');
  add(value);
  result := value;
end;

function TFhirPermissionRuleList.Append: TFhirPermissionRule;
begin
  result := TFhirPermissionRule.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPermissionRuleList.ClearItems;
begin
  Clear;
end;

function TFhirPermissionRuleList.GetEnumerator : TFhirPermissionRuleListEnumerator;
begin
  result := TFhirPermissionRuleListEnumerator.Create(self.link);
end;

function TFhirPermissionRuleList.Clone: TFhirPermissionRuleList;
begin
  result := TFhirPermissionRuleList(inherited Clone);
end;

function TFhirPermissionRuleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPermissionRuleList.GetItemN(index: Integer): TFhirPermissionRule;
begin
  result := TFhirPermissionRule(ObjectByIndex[index]);
end;

function TFhirPermissionRuleList.ItemClass: TFslObjectClass;
begin
  result := TFhirPermissionRule;
end;
function TFhirPermissionRuleList.IndexOf(value: TFhirPermissionRule): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPermissionRuleList.Insert(index: Integer): TFhirPermissionRule;
begin
  result := TFhirPermissionRule.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPermissionRuleList.InsertItem(index: Integer; value: TFhirPermissionRule);
begin
  assert(value is TFhirPermissionRule);
  Inherited Insert(index, value);
end;

function TFhirPermissionRuleList.Item(index: Integer): TFhirPermissionRule;
begin
  result := TFhirPermissionRule(ObjectByIndex[index]);
end;

function TFhirPermissionRuleList.Link: TFhirPermissionRuleList;
begin
  result := TFhirPermissionRuleList(inherited Link);
end;

procedure TFhirPermissionRuleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPermissionRuleList.SetItemByIndex(index: Integer; value: TFhirPermissionRule);
begin
  assert(value is TFhirPermissionRule);
  FhirPermissionRules[index] := value;
end;

procedure TFhirPermissionRuleList.SetItemN(index: Integer; value: TFhirPermissionRule);
begin
  assert(value is TFhirPermissionRule);
  ObjectByIndex[index] := value;
end;

{ TFhirPermissionRuleData }

constructor TFhirPermissionRuleData.Create;
begin
  inherited;
end;

destructor TFhirPermissionRuleData.Destroy;
begin
  FResourceList.Free;
  FSecurityList.Free;
  FPeriodList.Free;
  FExpression.free;
  inherited;
end;

procedure TFhirPermissionRuleData.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPermissionRuleData(oSource).FResourceList = nil) then
  begin
    FResourceList.free;
    FResourceList := nil;
  end
  else
  begin
    if FResourceList = nil then
      FResourceList := TFhirPermissionRuleDataResourceList.Create;
    FResourceList.Assign(TFhirPermissionRuleData(oSource).FResourceList);
  end;
  if (TFhirPermissionRuleData(oSource).FSecurityList = nil) then
  begin
    FSecurityList.free;
    FSecurityList := nil;
  end
  else
  begin
    if FSecurityList = nil then
      FSecurityList := TFhirCodingList.Create;
    FSecurityList.Assign(TFhirPermissionRuleData(oSource).FSecurityList);
  end;
  if (TFhirPermissionRuleData(oSource).FPeriodList = nil) then
  begin
    FPeriodList.free;
    FPeriodList := nil;
  end
  else
  begin
    if FPeriodList = nil then
      FPeriodList := TFhirPeriodList.Create;
    FPeriodList.Assign(TFhirPermissionRuleData(oSource).FPeriodList);
  end;
  expression := TFhirPermissionRuleData(oSource).expression.Clone;
end;

procedure TFhirPermissionRuleData.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'resource') Then
    list.addAll(self, 'resource', FResourceList);
  if (child_name = 'security') Then
    list.addAll(self, 'security', FSecurityList);
  if (child_name = 'period') Then
    list.addAll(self, 'period', FPeriodList);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
end;

procedure TFhirPermissionRuleData.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'resource', 'BackboneElement', true, TFhirPermissionRuleDataResource, FResourceList.Link));
  oList.add(TFHIRProperty.create(self, 'security', 'Coding', true, TFhirCoding, FSecurityList.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', true, TFhirPeriod, FPeriodList.Link));
  oList.add(TFHIRProperty.create(self, 'expression', 'Expression', false, TFhirExpression, FExpression.Link));
end;

function TFhirPermissionRuleData.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'resource') then
  begin
    ResourceList.add(propValue as TFhirPermissionRuleDataResource);
    result := propValue;
  end
  else if (propName = 'security') then
  begin
    SecurityList.add(propValue as TFhirCoding);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    PeriodList.add(propValue as TFhirPeriod);
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    Expression := propValue as TFhirExpression;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPermissionRuleData.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'resource') then ResourceList.insertItem(index, propValue as TFhirPermissionRuleDataResource)
  else if (propName = 'security') then SecurityList.insertItem(index, propValue as TFhirCoding)
  else if (propName = 'period') then PeriodList.insertItem(index, propValue as TFhirPeriod)
  else inherited;
end;

function TFhirPermissionRuleData.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'resource') then result := ResourceList.new()
  else if (propName = 'security') then result := SecurityList.new()
  else if (propName = 'period') then result := PeriodList.new()
  else if (propName = 'expression') then result := TFhirExpression.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPermissionRuleData.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'resource') then result := 'BackboneElement'
  else if (propName = 'security') then result := 'Coding'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'expression') then result := 'Expression'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPermissionRuleData.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'resource') then deletePropertyValue('resource', ResourceList, value)
  else if (propName = 'security') then deletePropertyValue('security', SecurityList, value)
  else if (propName = 'period') then deletePropertyValue('period', PeriodList, value)
  else if (propName = 'expression') then ExpressionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPermissionRuleData.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'resource') then replacePropertyValue('resource', ResourceList, existing, new)
  else if (propName = 'security') then replacePropertyValue('security', SecurityList, existing, new)
  else if (propName = 'period') then replacePropertyValue('period', PeriodList, existing, new)
  else if (propName = 'expression') then ExpressionElement := new as TFhirExpression
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPermissionRuleData.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'resource') then ResourceList.move(source, destination)
  else if (propName = 'security') then SecurityList.move(source, destination)
  else if (propName = 'period') then PeriodList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPermissionRuleData.fhirType : string;
begin
  result := 'Permission.rule.data';
end;

function TFhirPermissionRuleData.Link : TFhirPermissionRuleData;
begin
  result := TFhirPermissionRuleData(inherited Link);
end;

function TFhirPermissionRuleData.Clone : TFhirPermissionRuleData;
begin
  result := TFhirPermissionRuleData(inherited Clone);
end;

function TFhirPermissionRuleData.equals(other : TObject) : boolean; 
var
  o : TFhirPermissionRuleData;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPermissionRuleData)) then
    result := false
  else
  begin
    o := TFhirPermissionRuleData(other);
    result := compareDeep(resourceList, o.resourceList, true) and compareDeep(securityList, o.securityList, true) and 
      compareDeep(periodList, o.periodList, true) and compareDeep(expressionElement, o.expressionElement, true);
  end;
end;

function TFhirPermissionRuleData.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FresourceList) and isEmptyProp(FsecurityList) and isEmptyProp(FperiodList) and isEmptyProp(FExpression);
end;

procedure TFhirPermissionRuleData.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('resource');
  fields.add('security');
  fields.add('period');
  fields.add('expression');
end;

function TFhirPermissionRuleData.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FResourceList.sizeInBytes(magic));
  inc(result, FSecurityList.sizeInBytes(magic));
  inc(result, FPeriodList.sizeInBytes(magic));
end;

function TFhirPermissionRuleData.GetResourceList : TFhirPermissionRuleDataResourceList;
begin
  if FResourceList = nil then
    FResourceList := TFhirPermissionRuleDataResourceList.Create;
  result := FResourceList;
end;

function TFhirPermissionRuleData.GetHasResourceList : boolean;
begin
  result := (FResourceList <> nil) and (FResourceList.count > 0);
end;

function TFhirPermissionRuleData.GetSecurityList : TFhirCodingList;
begin
  if FSecurityList = nil then
    FSecurityList := TFhirCodingList.Create;
  result := FSecurityList;
end;

function TFhirPermissionRuleData.GetHasSecurityList : boolean;
begin
  result := (FSecurityList <> nil) and (FSecurityList.count > 0);
end;

function TFhirPermissionRuleData.GetPeriodList : TFhirPeriodList;
begin
  if FPeriodList = nil then
    FPeriodList := TFhirPeriodList.Create;
  result := FPeriodList;
end;

function TFhirPermissionRuleData.GetHasPeriodList : boolean;
begin
  result := (FPeriodList <> nil) and (FPeriodList.count > 0);
end;

procedure TFhirPermissionRuleData.SetExpression(value : TFhirExpression);
begin
  FExpression.free;
  FExpression := value;
end;

{ TFhirPermissionRuleDataListEnumerator }

constructor TFhirPermissionRuleDataListEnumerator.Create(list : TFhirPermissionRuleDataList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPermissionRuleDataListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPermissionRuleDataListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPermissionRuleDataListEnumerator.GetCurrent : TFhirPermissionRuleData;
begin
  Result := FList[FIndex];
end;

function TFhirPermissionRuleDataListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPermissionRuleDataList }

function TFhirPermissionRuleDataList.AddItem(value: TFhirPermissionRuleData): TFhirPermissionRuleData;
begin
  assert(value.ClassName = 'TFhirPermissionRuleData', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPermissionRuleData');
  add(value);
  result := value;
end;

function TFhirPermissionRuleDataList.Append: TFhirPermissionRuleData;
begin
  result := TFhirPermissionRuleData.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPermissionRuleDataList.ClearItems;
begin
  Clear;
end;

function TFhirPermissionRuleDataList.GetEnumerator : TFhirPermissionRuleDataListEnumerator;
begin
  result := TFhirPermissionRuleDataListEnumerator.Create(self.link);
end;

function TFhirPermissionRuleDataList.Clone: TFhirPermissionRuleDataList;
begin
  result := TFhirPermissionRuleDataList(inherited Clone);
end;

function TFhirPermissionRuleDataList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPermissionRuleDataList.GetItemN(index: Integer): TFhirPermissionRuleData;
begin
  result := TFhirPermissionRuleData(ObjectByIndex[index]);
end;

function TFhirPermissionRuleDataList.ItemClass: TFslObjectClass;
begin
  result := TFhirPermissionRuleData;
end;
function TFhirPermissionRuleDataList.IndexOf(value: TFhirPermissionRuleData): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPermissionRuleDataList.Insert(index: Integer): TFhirPermissionRuleData;
begin
  result := TFhirPermissionRuleData.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPermissionRuleDataList.InsertItem(index: Integer; value: TFhirPermissionRuleData);
begin
  assert(value is TFhirPermissionRuleData);
  Inherited Insert(index, value);
end;

function TFhirPermissionRuleDataList.Item(index: Integer): TFhirPermissionRuleData;
begin
  result := TFhirPermissionRuleData(ObjectByIndex[index]);
end;

function TFhirPermissionRuleDataList.Link: TFhirPermissionRuleDataList;
begin
  result := TFhirPermissionRuleDataList(inherited Link);
end;

procedure TFhirPermissionRuleDataList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPermissionRuleDataList.SetItemByIndex(index: Integer; value: TFhirPermissionRuleData);
begin
  assert(value is TFhirPermissionRuleData);
  FhirPermissionRuleData[index] := value;
end;

procedure TFhirPermissionRuleDataList.SetItemN(index: Integer; value: TFhirPermissionRuleData);
begin
  assert(value is TFhirPermissionRuleData);
  ObjectByIndex[index] := value;
end;

{ TFhirPermissionRuleDataResource }

constructor TFhirPermissionRuleDataResource.Create;
begin
  inherited;
end;

destructor TFhirPermissionRuleDataResource.Destroy;
begin
  FMeaning.free;
  FReference.free;
  inherited;
end;

procedure TFhirPermissionRuleDataResource.Assign(oSource : TFslObject);
begin
  inherited;
  meaningElement := TFhirPermissionRuleDataResource(oSource).meaningElement.Clone;
  reference := TFhirPermissionRuleDataResource(oSource).reference.Clone;
end;

procedure TFhirPermissionRuleDataResource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'meaning') Then
     list.add(self.link, 'meaning', FMeaning.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
end;

procedure TFhirPermissionRuleDataResource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'meaning', 'code', false, TFhirEnum, FMeaning.Link));
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference', false, TFhirReference, FReference.Link));
end;

function TFhirPermissionRuleDataResource.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'meaning') then
  begin
    MeaningElement := asEnum(SYSTEMS_TFhirConsentDataMeaningEnum, CODES_TFhirConsentDataMeaningEnum, propValue);
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPermissionRuleDataResource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPermissionRuleDataResource.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'meaning') then result := TFhirEnum.create(SYSTEMS_TFhirConsentDataMeaningEnum[ConsentDataMeaningNull], CODES_TFhirConsentDataMeaningEnum[ConsentDataMeaningNull]) 
  else if (propName = 'reference') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPermissionRuleDataResource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'meaning') then result := 'code'
  else if (propName = 'reference') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPermissionRuleDataResource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'meaning') then MeaningElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPermissionRuleDataResource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'meaning') then MeaningElement := asEnum(SYSTEMS_TFhirConsentDataMeaningEnum, CODES_TFhirConsentDataMeaningEnum, new)
  else if (propName = 'reference') then ReferenceElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPermissionRuleDataResource.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPermissionRuleDataResource.fhirType : string;
begin
  result := 'Permission.rule.data.resource';
end;

function TFhirPermissionRuleDataResource.Link : TFhirPermissionRuleDataResource;
begin
  result := TFhirPermissionRuleDataResource(inherited Link);
end;

function TFhirPermissionRuleDataResource.Clone : TFhirPermissionRuleDataResource;
begin
  result := TFhirPermissionRuleDataResource(inherited Clone);
end;

function TFhirPermissionRuleDataResource.equals(other : TObject) : boolean; 
var
  o : TFhirPermissionRuleDataResource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPermissionRuleDataResource)) then
    result := false
  else
  begin
    o := TFhirPermissionRuleDataResource(other);
    result := compareDeep(meaningElement, o.meaningElement, true) and compareDeep(referenceElement, o.referenceElement, true);
  end;
end;

function TFhirPermissionRuleDataResource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMeaning) and isEmptyProp(FReference);
end;

procedure TFhirPermissionRuleDataResource.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('meaning');
  fields.add('reference');
end;

function TFhirPermissionRuleDataResource.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPermissionRuleDataResource.SetMeaning(value : TFhirEnum);
begin
  FMeaning.free;
  FMeaning := value;
end;

function TFhirPermissionRuleDataResource.GetMeaningST : TFhirConsentDataMeaningEnum;
begin
  if FMeaning = nil then
    result := TFhirConsentDataMeaningEnum(0)
  else
    result := TFhirConsentDataMeaningEnum(StringArrayIndexOfSensitive(CODES_TFhirConsentDataMeaningEnum, FMeaning.value));
end;

procedure TFhirPermissionRuleDataResource.SetMeaningST(value : TFhirConsentDataMeaningEnum);
begin
  if ord(value) = 0 then
    MeaningElement := nil
  else
    MeaningElement := TFhirEnum.create(SYSTEMS_TFhirConsentDataMeaningEnum[value], CODES_TFhirConsentDataMeaningEnum[value]);
end;

procedure TFhirPermissionRuleDataResource.SetReference(value : TFhirReference);
begin
  FReference.free;
  FReference := value;
end;

{ TFhirPermissionRuleDataResourceListEnumerator }

constructor TFhirPermissionRuleDataResourceListEnumerator.Create(list : TFhirPermissionRuleDataResourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPermissionRuleDataResourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPermissionRuleDataResourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPermissionRuleDataResourceListEnumerator.GetCurrent : TFhirPermissionRuleDataResource;
begin
  Result := FList[FIndex];
end;

function TFhirPermissionRuleDataResourceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPermissionRuleDataResourceList }

function TFhirPermissionRuleDataResourceList.AddItem(value: TFhirPermissionRuleDataResource): TFhirPermissionRuleDataResource;
begin
  assert(value.ClassName = 'TFhirPermissionRuleDataResource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPermissionRuleDataResource');
  add(value);
  result := value;
end;

function TFhirPermissionRuleDataResourceList.Append: TFhirPermissionRuleDataResource;
begin
  result := TFhirPermissionRuleDataResource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPermissionRuleDataResourceList.ClearItems;
begin
  Clear;
end;

function TFhirPermissionRuleDataResourceList.GetEnumerator : TFhirPermissionRuleDataResourceListEnumerator;
begin
  result := TFhirPermissionRuleDataResourceListEnumerator.Create(self.link);
end;

function TFhirPermissionRuleDataResourceList.Clone: TFhirPermissionRuleDataResourceList;
begin
  result := TFhirPermissionRuleDataResourceList(inherited Clone);
end;

function TFhirPermissionRuleDataResourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPermissionRuleDataResourceList.GetItemN(index: Integer): TFhirPermissionRuleDataResource;
begin
  result := TFhirPermissionRuleDataResource(ObjectByIndex[index]);
end;

function TFhirPermissionRuleDataResourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirPermissionRuleDataResource;
end;
function TFhirPermissionRuleDataResourceList.IndexOf(value: TFhirPermissionRuleDataResource): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPermissionRuleDataResourceList.Insert(index: Integer): TFhirPermissionRuleDataResource;
begin
  result := TFhirPermissionRuleDataResource.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPermissionRuleDataResourceList.InsertItem(index: Integer; value: TFhirPermissionRuleDataResource);
begin
  assert(value is TFhirPermissionRuleDataResource);
  Inherited Insert(index, value);
end;

function TFhirPermissionRuleDataResourceList.Item(index: Integer): TFhirPermissionRuleDataResource;
begin
  result := TFhirPermissionRuleDataResource(ObjectByIndex[index]);
end;

function TFhirPermissionRuleDataResourceList.Link: TFhirPermissionRuleDataResourceList;
begin
  result := TFhirPermissionRuleDataResourceList(inherited Link);
end;

procedure TFhirPermissionRuleDataResourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPermissionRuleDataResourceList.SetItemByIndex(index: Integer; value: TFhirPermissionRuleDataResource);
begin
  assert(value is TFhirPermissionRuleDataResource);
  FhirPermissionRuleDataResources[index] := value;
end;

procedure TFhirPermissionRuleDataResourceList.SetItemN(index: Integer; value: TFhirPermissionRuleDataResource);
begin
  assert(value is TFhirPermissionRuleDataResource);
  ObjectByIndex[index] := value;
end;

{ TFhirPermissionRuleActivity }

constructor TFhirPermissionRuleActivity.Create;
begin
  inherited;
end;

destructor TFhirPermissionRuleActivity.Destroy;
begin
  FActorList.Free;
  FActionList.Free;
  FPurposeList.Free;
  inherited;
end;

procedure TFhirPermissionRuleActivity.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPermissionRuleActivity(oSource).FActorList = nil) then
  begin
    FActorList.free;
    FActorList := nil;
  end
  else
  begin
    if FActorList = nil then
      FActorList := TFhirReferenceList.Create;
    FActorList.Assign(TFhirPermissionRuleActivity(oSource).FActorList);
  end;
  if (TFhirPermissionRuleActivity(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirCodeableConceptList.Create;
    FActionList.Assign(TFhirPermissionRuleActivity(oSource).FActionList);
  end;
  if (TFhirPermissionRuleActivity(oSource).FPurposeList = nil) then
  begin
    FPurposeList.free;
    FPurposeList := nil;
  end
  else
  begin
    if FPurposeList = nil then
      FPurposeList := TFhirCodeableConceptList.Create;
    FPurposeList.Assign(TFhirPermissionRuleActivity(oSource).FPurposeList);
  end;
end;

procedure TFhirPermissionRuleActivity.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'actor') Then
    list.addAll(self, 'actor', FActorList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
  if (child_name = 'purpose') Then
    list.addAll(self, 'purpose', FPurposeList);
end;

procedure TFhirPermissionRuleActivity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference', true, TFhirReference, FActorList.Link));
  oList.add(TFHIRProperty.create(self, 'action', 'CodeableConcept', true, TFhirCodeableConcept, FActionList.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'CodeableConcept', true, TFhirCodeableConcept, FPurposeList.Link));
end;

function TFhirPermissionRuleActivity.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'actor') then
  begin
    ActorList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPermissionRuleActivity.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'actor') then ActorList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'purpose') then PurposeList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirPermissionRuleActivity.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'actor') then result := ActorList.new()
  else if (propName = 'action') then result := ActionList.new()
  else if (propName = 'purpose') then result := PurposeList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPermissionRuleActivity.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'actor') then result := 'Reference'
  else if (propName = 'action') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPermissionRuleActivity.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'actor') then deletePropertyValue('actor', ActorList, value)
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value)
  else if (propName = 'purpose') then deletePropertyValue('purpose', PurposeList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPermissionRuleActivity.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'actor') then replacePropertyValue('actor', ActorList, existing, new)
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new)
  else if (propName = 'purpose') then replacePropertyValue('purpose', PurposeList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPermissionRuleActivity.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'actor') then ActorList.move(source, destination)
  else if (propName = 'action') then ActionList.move(source, destination)
  else if (propName = 'purpose') then PurposeList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPermissionRuleActivity.fhirType : string;
begin
  result := 'Permission.rule.activity';
end;

function TFhirPermissionRuleActivity.Link : TFhirPermissionRuleActivity;
begin
  result := TFhirPermissionRuleActivity(inherited Link);
end;

function TFhirPermissionRuleActivity.Clone : TFhirPermissionRuleActivity;
begin
  result := TFhirPermissionRuleActivity(inherited Clone);
end;

function TFhirPermissionRuleActivity.equals(other : TObject) : boolean; 
var
  o : TFhirPermissionRuleActivity;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPermissionRuleActivity)) then
    result := false
  else
  begin
    o := TFhirPermissionRuleActivity(other);
    result := compareDeep(actorList, o.actorList, true) and compareDeep(actionList, o.actionList, true) and 
      compareDeep(purposeList, o.purposeList, true);
  end;
end;

function TFhirPermissionRuleActivity.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FactorList) and isEmptyProp(FactionList) and isEmptyProp(FpurposeList);
end;

procedure TFhirPermissionRuleActivity.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('actor');
  fields.add('action');
  fields.add('purpose');
end;

function TFhirPermissionRuleActivity.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FActorList.sizeInBytes(magic));
  inc(result, FActionList.sizeInBytes(magic));
  inc(result, FPurposeList.sizeInBytes(magic));
end;

function TFhirPermissionRuleActivity.GetActorList : TFhirReferenceList;
begin
  if FActorList = nil then
    FActorList := TFhirReferenceList.Create;
  result := FActorList;
end;

function TFhirPermissionRuleActivity.GetHasActorList : boolean;
begin
  result := (FActorList <> nil) and (FActorList.count > 0);
end;

function TFhirPermissionRuleActivity.GetActionList : TFhirCodeableConceptList;
begin
  if FActionList = nil then
    FActionList := TFhirCodeableConceptList.Create;
  result := FActionList;
end;

function TFhirPermissionRuleActivity.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

function TFhirPermissionRuleActivity.GetPurposeList : TFhirCodeableConceptList;
begin
  if FPurposeList = nil then
    FPurposeList := TFhirCodeableConceptList.Create;
  result := FPurposeList;
end;

function TFhirPermissionRuleActivity.GetHasPurposeList : boolean;
begin
  result := (FPurposeList <> nil) and (FPurposeList.count > 0);
end;

{ TFhirPermissionRuleActivityListEnumerator }

constructor TFhirPermissionRuleActivityListEnumerator.Create(list : TFhirPermissionRuleActivityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPermissionRuleActivityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPermissionRuleActivityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPermissionRuleActivityListEnumerator.GetCurrent : TFhirPermissionRuleActivity;
begin
  Result := FList[FIndex];
end;

function TFhirPermissionRuleActivityListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPermissionRuleActivityList }

function TFhirPermissionRuleActivityList.AddItem(value: TFhirPermissionRuleActivity): TFhirPermissionRuleActivity;
begin
  assert(value.ClassName = 'TFhirPermissionRuleActivity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPermissionRuleActivity');
  add(value);
  result := value;
end;

function TFhirPermissionRuleActivityList.Append: TFhirPermissionRuleActivity;
begin
  result := TFhirPermissionRuleActivity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPermissionRuleActivityList.ClearItems;
begin
  Clear;
end;

function TFhirPermissionRuleActivityList.GetEnumerator : TFhirPermissionRuleActivityListEnumerator;
begin
  result := TFhirPermissionRuleActivityListEnumerator.Create(self.link);
end;

function TFhirPermissionRuleActivityList.Clone: TFhirPermissionRuleActivityList;
begin
  result := TFhirPermissionRuleActivityList(inherited Clone);
end;

function TFhirPermissionRuleActivityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPermissionRuleActivityList.GetItemN(index: Integer): TFhirPermissionRuleActivity;
begin
  result := TFhirPermissionRuleActivity(ObjectByIndex[index]);
end;

function TFhirPermissionRuleActivityList.ItemClass: TFslObjectClass;
begin
  result := TFhirPermissionRuleActivity;
end;
function TFhirPermissionRuleActivityList.IndexOf(value: TFhirPermissionRuleActivity): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPermissionRuleActivityList.Insert(index: Integer): TFhirPermissionRuleActivity;
begin
  result := TFhirPermissionRuleActivity.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPermissionRuleActivityList.InsertItem(index: Integer; value: TFhirPermissionRuleActivity);
begin
  assert(value is TFhirPermissionRuleActivity);
  Inherited Insert(index, value);
end;

function TFhirPermissionRuleActivityList.Item(index: Integer): TFhirPermissionRuleActivity;
begin
  result := TFhirPermissionRuleActivity(ObjectByIndex[index]);
end;

function TFhirPermissionRuleActivityList.Link: TFhirPermissionRuleActivityList;
begin
  result := TFhirPermissionRuleActivityList(inherited Link);
end;

procedure TFhirPermissionRuleActivityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPermissionRuleActivityList.SetItemByIndex(index: Integer; value: TFhirPermissionRuleActivity);
begin
  assert(value is TFhirPermissionRuleActivity);
  FhirPermissionRuleActivities[index] := value;
end;

procedure TFhirPermissionRuleActivityList.SetItemN(index: Integer; value: TFhirPermissionRuleActivity);
begin
  assert(value is TFhirPermissionRuleActivity);
  ObjectByIndex[index] := value;
end;

{ TFhirPermission }

constructor TFhirPermission.Create;
begin
  inherited;
end;

destructor TFhirPermission.Destroy;
begin
  FStatus.free;
  FAsserter.free;
  FDateList.Free;
  FValidity.free;
  FJustification.free;
  FCombining.free;
  FRuleList.Free;
  inherited;
end;

procedure TFhirPermission.Assign(oSource : TFslObject);
begin
  inherited;
  statusElement := TFhirPermission(oSource).statusElement.Clone;
  asserter := TFhirPermission(oSource).asserter.Clone;
  if (TFhirPermission(oSource).FDateList = nil) then
  begin
    FDateList.free;
    FDateList := nil;
  end
  else
  begin
    if FDateList = nil then
      FDateList := TFhirDateTimeList.Create;
    FDateList.Assign(TFhirPermission(oSource).FDateList);
  end;
  validity := TFhirPermission(oSource).validity.Clone;
  justification := TFhirPermission(oSource).justification.Clone;
  combiningElement := TFhirPermission(oSource).combiningElement.Clone;
  if (TFhirPermission(oSource).FRuleList = nil) then
  begin
    FRuleList.free;
    FRuleList := nil;
  end
  else
  begin
    if FRuleList = nil then
      FRuleList := TFhirPermissionRuleList.Create;
    FRuleList.Assign(TFhirPermission(oSource).FRuleList);
  end;
end;

function TFhirPermission.GetResourceType : TFhirResourceType;
begin
  result := frtPermission;
end;

procedure TFhirPermission.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'asserter') Then
     list.add(self.link, 'asserter', FAsserter.Link);
  if (child_name = 'date') Then
    list.addAll(self, 'date', FDateList);
  if (child_name = 'validity') Then
     list.add(self.link, 'validity', FValidity.Link);
  if (child_name = 'justification') Then
     list.add(self.link, 'justification', FJustification.Link);
  if (child_name = 'combining') Then
     list.add(self.link, 'combining', FCombining.Link);
  if (child_name = 'rule') Then
    list.addAll(self, 'rule', FRuleList);
end;

procedure TFhirPermission.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'asserter', 'Reference', false, TFhirReference, FAsserter.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', true, TFhirDateTime, FDateList.Link));
  oList.add(TFHIRProperty.create(self, 'validity', 'Period', false, TFhirPeriod, FValidity.Link));
  oList.add(TFHIRProperty.create(self, 'justification', 'BackboneElement', false, TFhirPermissionJustification, FJustification.Link));
  oList.add(TFHIRProperty.create(self, 'combining', 'code', false, TFhirEnum, FCombining.Link));
  oList.add(TFHIRProperty.create(self, 'rule', 'BackboneElement', true, TFhirPermissionRule, FRuleList.Link));
end;

function TFhirPermission.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPermissionStatusEnum, CODES_TFhirPermissionStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'asserter') then
  begin
    Asserter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateList.add(asDateTime(propValue)){2};     result := propValue;

  end
  else if (propName = 'validity') then
  begin
    Validity := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'justification') then
  begin
    Justification := propValue as TFhirPermissionJustification;
    result := propValue;
  end
  else if (propName = 'combining') then
  begin
    CombiningElement := asEnum(SYSTEMS_TFhirPermissionRuleCombiningEnum, CODES_TFhirPermissionRuleCombiningEnum, propValue);
    result := propValue;
  end
  else if (propName = 'rule') then
  begin
    RuleList.add(propValue as TFhirPermissionRule);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPermission.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'date') then DateList.insertItem(index, asDateTime(propValue))
  else if (propName = 'rule') then RuleList.insertItem(index, propValue as TFhirPermissionRule)
  else inherited;
end;

function TFhirPermission.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPermissionStatusEnum[PermissionStatusNull], CODES_TFhirPermissionStatusEnum[PermissionStatusNull]) 
  else if (propName = 'asserter') then result := TFhirReference.create()
  else if (propName = 'date') then result := DateList.new()
  else if (propName = 'validity') then result := TFhirPeriod.create()
  else if (propName = 'justification') then result := TFhirPermissionJustification.create()
  else if (propName = 'combining') then result := TFhirEnum.create(SYSTEMS_TFhirPermissionRuleCombiningEnum[PermissionRuleCombiningNull], CODES_TFhirPermissionRuleCombiningEnum[PermissionRuleCombiningNull]) 
  else if (propName = 'rule') then result := RuleList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPermission.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'status') then result := 'code'
  else if (propName = 'asserter') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'validity') then result := 'Period'
  else if (propName = 'justification') then result := 'BackboneElement'
  else if (propName = 'combining') then result := 'code'
  else if (propName = 'rule') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPermission.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := nil
  else if (propName = 'asserter') then AsserterElement := nil
  else if (propName = 'date') then deletePropertyValue('date', DateList, value)
  else if (propName = 'validity') then ValidityElement := nil
  else if (propName = 'justification') then JustificationElement := nil
  else if (propName = 'combining') then CombiningElement := nil
  else if (propName = 'rule') then deletePropertyValue('rule', RuleList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPermission.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPermissionStatusEnum, CODES_TFhirPermissionStatusEnum, new)
  else if (propName = 'asserter') then AsserterElement := new as TFhirReference
  else if (propName = 'date') then replacePropertyValue('date', DateList, existing, new)
  else if (propName = 'validity') then ValidityElement := new as TFhirPeriod
  else if (propName = 'justification') then JustificationElement := new as TFhirPermissionJustification
  else if (propName = 'combining') then CombiningElement := asEnum(SYSTEMS_TFhirPermissionRuleCombiningEnum, CODES_TFhirPermissionRuleCombiningEnum, new)
  else if (propName = 'rule') then replacePropertyValue('rule', RuleList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPermission.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'date') then DateList.move(source, destination)
  else if (propName = 'rule') then RuleList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPermission.fhirType : string;
begin
  result := 'Permission';
end;

function TFhirPermission.Link : TFhirPermission;
begin
  result := TFhirPermission(inherited Link);
end;

function TFhirPermission.Clone : TFhirPermission;
begin
  result := TFhirPermission(inherited Clone);
end;

function TFhirPermission.equals(other : TObject) : boolean; 
var
  o : TFhirPermission;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPermission)) then
    result := false
  else
  begin
    o := TFhirPermission(other);
    result := compareDeep(statusElement, o.statusElement, true) and compareDeep(asserterElement, o.asserterElement, true) and 
      compareDeep(dateList, o.dateList, true) and compareDeep(validityElement, o.validityElement, true) and 
      compareDeep(justificationElement, o.justificationElement, true) and compareDeep(combiningElement, o.combiningElement, true) and 
      compareDeep(ruleList, o.ruleList, true);
  end;
end;

function TFhirPermission.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStatus) and isEmptyProp(FAsserter) and isEmptyProp(FdateList) and isEmptyProp(FValidity) and isEmptyProp(FJustification) and isEmptyProp(FCombining) and isEmptyProp(FruleList);
end;

procedure TFhirPermission.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('status');
  fields.add('asserter');
  fields.add('date');
  fields.add('validity');
  fields.add('justification');
  fields.add('combining');
  fields.add('rule');
end;

function TFhirPermission.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FDateList.sizeInBytes(magic));
  inc(result, FRuleList.sizeInBytes(magic));
end;

procedure TFhirPermission.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirPermission.GetStatusST : TFhirPermissionStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPermissionStatusEnum(0)
  else
    result := TFhirPermissionStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPermissionStatusEnum, FStatus.value));
end;

procedure TFhirPermission.SetStatusST(value : TFhirPermissionStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPermissionStatusEnum[value], CODES_TFhirPermissionStatusEnum[value]);
end;

procedure TFhirPermission.SetAsserter(value : TFhirReference);
begin
  FAsserter.free;
  FAsserter := value;
end;

function TFhirPermission.GetDateList : TFhirDateTimeList;
begin
  if FDateList = nil then
    FDateList := TFhirDateTimeList.Create;
  result := FDateList;
end;

function TFhirPermission.GetHasDateList : boolean;
begin
  result := (FDateList <> nil) and (FDateList.count > 0);
end;

procedure TFhirPermission.SetValidity(value : TFhirPeriod);
begin
  FValidity.free;
  FValidity := value;
end;

procedure TFhirPermission.SetJustification(value : TFhirPermissionJustification);
begin
  FJustification.free;
  FJustification := value;
end;

procedure TFhirPermission.SetCombining(value : TFhirEnum);
begin
  FCombining.free;
  FCombining := value;
end;

function TFhirPermission.GetCombiningST : TFhirPermissionRuleCombiningEnum;
begin
  if FCombining = nil then
    result := TFhirPermissionRuleCombiningEnum(0)
  else
    result := TFhirPermissionRuleCombiningEnum(StringArrayIndexOfSensitive(CODES_TFhirPermissionRuleCombiningEnum, FCombining.value));
end;

procedure TFhirPermission.SetCombiningST(value : TFhirPermissionRuleCombiningEnum);
begin
  if ord(value) = 0 then
    CombiningElement := nil
  else
    CombiningElement := TFhirEnum.create(SYSTEMS_TFhirPermissionRuleCombiningEnum[value], CODES_TFhirPermissionRuleCombiningEnum[value]);
end;

function TFhirPermission.GetRuleList : TFhirPermissionRuleList;
begin
  if FRuleList = nil then
    FRuleList := TFhirPermissionRuleList.Create;
  result := FRuleList;
end;

function TFhirPermission.GetHasRuleList : boolean;
begin
  result := (FRuleList <> nil) and (FRuleList.count > 0);
end;

{ TFhirPermissionListEnumerator }

constructor TFhirPermissionListEnumerator.Create(list : TFhirPermissionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPermissionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPermissionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPermissionListEnumerator.GetCurrent : TFhirPermission;
begin
  Result := FList[FIndex];
end;

function TFhirPermissionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPermissionList }

function TFhirPermissionList.AddItem(value: TFhirPermission): TFhirPermission;
begin
  assert(value.ClassName = 'TFhirPermission', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPermission');
  add(value);
  result := value;
end;

function TFhirPermissionList.Append: TFhirPermission;
begin
  result := TFhirPermission.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPermissionList.ClearItems;
begin
  Clear;
end;

function TFhirPermissionList.GetEnumerator : TFhirPermissionListEnumerator;
begin
  result := TFhirPermissionListEnumerator.Create(self.link);
end;

function TFhirPermissionList.Clone: TFhirPermissionList;
begin
  result := TFhirPermissionList(inherited Clone);
end;

function TFhirPermissionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPermissionList.GetItemN(index: Integer): TFhirPermission;
begin
  result := TFhirPermission(ObjectByIndex[index]);
end;

function TFhirPermissionList.ItemClass: TFslObjectClass;
begin
  result := TFhirPermission;
end;
function TFhirPermissionList.IndexOf(value: TFhirPermission): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPermissionList.Insert(index: Integer): TFhirPermission;
begin
  result := TFhirPermission.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPermissionList.InsertItem(index: Integer; value: TFhirPermission);
begin
  assert(value is TFhirPermission);
  Inherited Insert(index, value);
end;

function TFhirPermissionList.Item(index: Integer): TFhirPermission;
begin
  result := TFhirPermission(ObjectByIndex[index]);
end;

function TFhirPermissionList.Link: TFhirPermissionList;
begin
  result := TFhirPermissionList(inherited Link);
end;

procedure TFhirPermissionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPermissionList.SetItemByIndex(index: Integer; value: TFhirPermission);
begin
  assert(value is TFhirPermission);
  FhirPermissions[index] := value;
end;

procedure TFhirPermissionList.SetItemN(index: Integer; value: TFhirPermission);
begin
  assert(value is TFhirPermission);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PERMISSION}
{$IFDEF FHIR_PLANDEFINITION}
{ TFhirPlanDefinitionGoal }

constructor TFhirPlanDefinitionGoal.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinitionGoal.Destroy;
begin
  FCategory.free;
  FDescription.free;
  FPriority.free;
  FStart.free;
  FAddressesList.Free;
  FDocumentationList.Free;
  FTargetList.Free;
  inherited;
end;

procedure TFhirPlanDefinitionGoal.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirPlanDefinitionGoal(oSource).category.Clone;
  description := TFhirPlanDefinitionGoal(oSource).description.Clone;
  priority := TFhirPlanDefinitionGoal(oSource).priority.Clone;
  start := TFhirPlanDefinitionGoal(oSource).start.Clone;
  if (TFhirPlanDefinitionGoal(oSource).FAddressesList = nil) then
  begin
    FAddressesList.free;
    FAddressesList := nil;
  end
  else
  begin
    if FAddressesList = nil then
      FAddressesList := TFhirCodeableConceptList.Create;
    FAddressesList.Assign(TFhirPlanDefinitionGoal(oSource).FAddressesList);
  end;
  if (TFhirPlanDefinitionGoal(oSource).FDocumentationList = nil) then
  begin
    FDocumentationList.free;
    FDocumentationList := nil;
  end
  else
  begin
    if FDocumentationList = nil then
      FDocumentationList := TFhirRelatedArtifactList.Create;
    FDocumentationList.Assign(TFhirPlanDefinitionGoal(oSource).FDocumentationList);
  end;
  if (TFhirPlanDefinitionGoal(oSource).FTargetList = nil) then
  begin
    FTargetList.free;
    FTargetList := nil;
  end
  else
  begin
    if FTargetList = nil then
      FTargetList := TFhirPlanDefinitionGoalTargetList.Create;
    FTargetList.Assign(TFhirPlanDefinitionGoal(oSource).FTargetList);
  end;
end;

procedure TFhirPlanDefinitionGoal.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'addresses') Then
    list.addAll(self, 'addresses', FAddressesList);
  if (child_name = 'documentation') Then
    list.addAll(self, 'documentation', FDocumentationList);
  if (child_name = 'target') Then
    list.addAll(self, 'target', FTargetList);
end;

procedure TFhirPlanDefinitionGoal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'CodeableConcept', false, TFhirCodeableConcept, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'CodeableConcept', false, TFhirCodeableConcept, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'start', 'CodeableConcept', false, TFhirCodeableConcept, FStart.Link));
  oList.add(TFHIRProperty.create(self, 'addresses', 'CodeableConcept', true, TFhirCodeableConcept, FAddressesList.Link));
  oList.add(TFHIRProperty.create(self, 'documentation', 'RelatedArtifact', true, TFhirRelatedArtifact, FDocumentationList.Link));
  oList.add(TFHIRProperty.create(self, 'target', 'BackboneElement', true, TFhirPlanDefinitionGoalTarget, FTargetList.Link));
end;

function TFhirPlanDefinitionGoal.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    Description := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    Priority := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'start') then
  begin
    Start := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'addresses') then
  begin
    AddressesList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationList.add(propValue as TFhirRelatedArtifact);
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    TargetList.add(propValue as TFhirPlanDefinitionGoalTarget);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinitionGoal.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'addresses') then AddressesList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'documentation') then DocumentationList.insertItem(index, propValue as TFhirRelatedArtifact)
  else if (propName = 'target') then TargetList.insertItem(index, propValue as TFhirPlanDefinitionGoalTarget)
  else inherited;
end;

function TFhirPlanDefinitionGoal.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (propName = 'description') then result := TFhirCodeableConcept.create()
  else if (propName = 'priority') then result := TFhirCodeableConcept.create()
  else if (propName = 'start') then result := TFhirCodeableConcept.create()
  else if (propName = 'addresses') then result := AddressesList.new()
  else if (propName = 'documentation') then result := DocumentationList.new()
  else if (propName = 'target') then result := TargetList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinitionGoal.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'CodeableConcept'
  else if (propName = 'priority') then result := 'CodeableConcept'
  else if (propName = 'start') then result := 'CodeableConcept'
  else if (propName = 'addresses') then result := 'CodeableConcept'
  else if (propName = 'documentation') then result := 'RelatedArtifact'
  else if (propName = 'target') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinitionGoal.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'start') then StartElement := nil
  else if (propName = 'addresses') then deletePropertyValue('addresses', AddressesList, value)
  else if (propName = 'documentation') then deletePropertyValue('documentation', DocumentationList, value)
  else if (propName = 'target') then deletePropertyValue('target', TargetList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinitionGoal.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (propName = 'description') then DescriptionElement := new as TFhirCodeableConcept
  else if (propName = 'priority') then PriorityElement := new as TFhirCodeableConcept
  else if (propName = 'start') then StartElement := new as TFhirCodeableConcept
  else if (propName = 'addresses') then replacePropertyValue('addresses', AddressesList, existing, new)
  else if (propName = 'documentation') then replacePropertyValue('documentation', DocumentationList, existing, new)
  else if (propName = 'target') then replacePropertyValue('target', TargetList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinitionGoal.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'addresses') then AddressesList.move(source, destination)
  else if (propName = 'documentation') then DocumentationList.move(source, destination)
  else if (propName = 'target') then TargetList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinitionGoal.fhirType : string;
begin
  result := 'PlanDefinition.goal';
end;

function TFhirPlanDefinitionGoal.Link : TFhirPlanDefinitionGoal;
begin
  result := TFhirPlanDefinitionGoal(inherited Link);
end;

function TFhirPlanDefinitionGoal.Clone : TFhirPlanDefinitionGoal;
begin
  result := TFhirPlanDefinitionGoal(inherited Clone);
end;

function TFhirPlanDefinitionGoal.equals(other : TObject) : boolean; 
var
  o : TFhirPlanDefinitionGoal;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinitionGoal)) then
    result := false
  else
  begin
    o := TFhirPlanDefinitionGoal(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(startElement, o.startElement, true) and 
      compareDeep(addressesList, o.addressesList, true) and compareDeep(documentationList, o.documentationList, true) and 
      compareDeep(targetList, o.targetList, true);
  end;
end;

function TFhirPlanDefinitionGoal.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FDescription) and isEmptyProp(FPriority) and isEmptyProp(FStart) and isEmptyProp(FaddressesList) and isEmptyProp(FdocumentationList) and isEmptyProp(FtargetList);
end;

procedure TFhirPlanDefinitionGoal.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('category');
  fields.add('description');
  fields.add('priority');
  fields.add('start');
  fields.add('addresses');
  fields.add('documentation');
  fields.add('target');
end;

function TFhirPlanDefinitionGoal.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FAddressesList.sizeInBytes(magic));
  inc(result, FDocumentationList.sizeInBytes(magic));
  inc(result, FTargetList.sizeInBytes(magic));
end;

procedure TFhirPlanDefinitionGoal.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirPlanDefinitionGoal.SetDescription(value : TFhirCodeableConcept);
begin
  FDescription.free;
  FDescription := value;
end;

procedure TFhirPlanDefinitionGoal.SetPriority(value : TFhirCodeableConcept);
begin
  FPriority.free;
  FPriority := value;
end;

procedure TFhirPlanDefinitionGoal.SetStart(value : TFhirCodeableConcept);
begin
  FStart.free;
  FStart := value;
end;

function TFhirPlanDefinitionGoal.GetAddressesList : TFhirCodeableConceptList;
begin
  if FAddressesList = nil then
    FAddressesList := TFhirCodeableConceptList.Create;
  result := FAddressesList;
end;

function TFhirPlanDefinitionGoal.GetHasAddressesList : boolean;
begin
  result := (FAddressesList <> nil) and (FAddressesList.count > 0);
end;

function TFhirPlanDefinitionGoal.GetDocumentationList : TFhirRelatedArtifactList;
begin
  if FDocumentationList = nil then
    FDocumentationList := TFhirRelatedArtifactList.Create;
  result := FDocumentationList;
end;

function TFhirPlanDefinitionGoal.GetHasDocumentationList : boolean;
begin
  result := (FDocumentationList <> nil) and (FDocumentationList.count > 0);
end;

function TFhirPlanDefinitionGoal.GetTargetList : TFhirPlanDefinitionGoalTargetList;
begin
  if FTargetList = nil then
    FTargetList := TFhirPlanDefinitionGoalTargetList.Create;
  result := FTargetList;
end;

function TFhirPlanDefinitionGoal.GetHasTargetList : boolean;
begin
  result := (FTargetList <> nil) and (FTargetList.count > 0);
end;

{ TFhirPlanDefinitionGoalListEnumerator }

constructor TFhirPlanDefinitionGoalListEnumerator.Create(list : TFhirPlanDefinitionGoalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionGoalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionGoalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionGoalListEnumerator.GetCurrent : TFhirPlanDefinitionGoal;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionGoalListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPlanDefinitionGoalList }

function TFhirPlanDefinitionGoalList.AddItem(value: TFhirPlanDefinitionGoal): TFhirPlanDefinitionGoal;
begin
  assert(value.ClassName = 'TFhirPlanDefinitionGoal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinitionGoal');
  add(value);
  result := value;
end;

function TFhirPlanDefinitionGoalList.Append: TFhirPlanDefinitionGoal;
begin
  result := TFhirPlanDefinitionGoal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionGoalList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionGoalList.GetEnumerator : TFhirPlanDefinitionGoalListEnumerator;
begin
  result := TFhirPlanDefinitionGoalListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionGoalList.Clone: TFhirPlanDefinitionGoalList;
begin
  result := TFhirPlanDefinitionGoalList(inherited Clone);
end;

function TFhirPlanDefinitionGoalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionGoalList.GetItemN(index: Integer): TFhirPlanDefinitionGoal;
begin
  result := TFhirPlanDefinitionGoal(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionGoalList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinitionGoal;
end;
function TFhirPlanDefinitionGoalList.IndexOf(value: TFhirPlanDefinitionGoal): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionGoalList.Insert(index: Integer): TFhirPlanDefinitionGoal;
begin
  result := TFhirPlanDefinitionGoal.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionGoalList.InsertItem(index: Integer; value: TFhirPlanDefinitionGoal);
begin
  assert(value is TFhirPlanDefinitionGoal);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionGoalList.Item(index: Integer): TFhirPlanDefinitionGoal;
begin
  result := TFhirPlanDefinitionGoal(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionGoalList.Link: TFhirPlanDefinitionGoalList;
begin
  result := TFhirPlanDefinitionGoalList(inherited Link);
end;

procedure TFhirPlanDefinitionGoalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionGoalList.SetItemByIndex(index: Integer; value: TFhirPlanDefinitionGoal);
begin
  assert(value is TFhirPlanDefinitionGoal);
  FhirPlanDefinitionGoals[index] := value;
end;

procedure TFhirPlanDefinitionGoalList.SetItemN(index: Integer; value: TFhirPlanDefinitionGoal);
begin
  assert(value is TFhirPlanDefinitionGoal);
  ObjectByIndex[index] := value;
end;

{ TFhirPlanDefinitionGoalTarget }

constructor TFhirPlanDefinitionGoalTarget.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinitionGoalTarget.Destroy;
begin
  FMeasure.free;
  FDetail.free;
  FDue.free;
  inherited;
end;

procedure TFhirPlanDefinitionGoalTarget.Assign(oSource : TFslObject);
begin
  inherited;
  measure := TFhirPlanDefinitionGoalTarget(oSource).measure.Clone;
  detail := TFhirPlanDefinitionGoalTarget(oSource).detail.Clone;
  due := TFhirPlanDefinitionGoalTarget(oSource).due.Clone;
end;

procedure TFhirPlanDefinitionGoalTarget.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'measure') Then
     list.add(self.link, 'measure', FMeasure.Link);
  if (child_name = 'detail[x]') or (child_name = 'detail') Then
     list.add(self.link, 'detail[x]', FDetail.Link);
  if (child_name = 'due') Then
     list.add(self.link, 'due', FDue.Link);
end;

procedure TFhirPlanDefinitionGoalTarget.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'measure', 'CodeableConcept', false, TFhirCodeableConcept, FMeasure.Link));
  oList.add(TFHIRProperty.create(self, 'detail[x]', 'Quantity|Range|CodeableConcept|string|boolean|integer|Ratio', false, TFhirDataType, FDetail.Link));
  oList.add(TFHIRProperty.create(self, 'due', 'Duration', false, TFhirDuration, FDue.Link));
end;

function TFhirPlanDefinitionGoalTarget.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'measure') then
  begin
    Measure := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'detail', ['Quantity', 'Range', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Ratio'])) then
  begin
    Detail := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'due') then
  begin
    Due := propValue as TFhirDuration;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinitionGoalTarget.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPlanDefinitionGoalTarget.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'measure') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'detail', ['Quantity', 'Range', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Ratio'])) then raise EFHIRException.create('Cannot make property Detail')
  else if (propName = 'due') then result := TFhirDuration.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinitionGoalTarget.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'measure') then result := 'CodeableConcept'
  else if (propName = 'detail[x]') then result := 'Quantity|Range|CodeableConcept|string|boolean|integer|Ratio'
  else if (propName = 'due') then result := 'Duration'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinitionGoalTarget.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'measure') then MeasureElement := nil
  else if (isMatchingName(propName, 'detail', ['Quantity', 'Range', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Ratio'])) then DetailElement := nil
  else if (propName = 'due') then DueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinitionGoalTarget.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'measure') then MeasureElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'detail', ['Quantity', 'Range', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Ratio'])) then DetailElement := new as TFhirDataType
  else if (propName = 'due') then DueElement := new as TFhirDuration
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinitionGoalTarget.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinitionGoalTarget.fhirType : string;
begin
  result := 'PlanDefinition.goal.target';
end;

function TFhirPlanDefinitionGoalTarget.Link : TFhirPlanDefinitionGoalTarget;
begin
  result := TFhirPlanDefinitionGoalTarget(inherited Link);
end;

function TFhirPlanDefinitionGoalTarget.Clone : TFhirPlanDefinitionGoalTarget;
begin
  result := TFhirPlanDefinitionGoalTarget(inherited Clone);
end;

function TFhirPlanDefinitionGoalTarget.equals(other : TObject) : boolean; 
var
  o : TFhirPlanDefinitionGoalTarget;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinitionGoalTarget)) then
    result := false
  else
  begin
    o := TFhirPlanDefinitionGoalTarget(other);
    result := compareDeep(measureElement, o.measureElement, true) and compareDeep(detailElement, o.detailElement, true) and 
      compareDeep(dueElement, o.dueElement, true);
  end;
end;

function TFhirPlanDefinitionGoalTarget.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMeasure) and isEmptyProp(FDetail) and isEmptyProp(FDue);
end;

procedure TFhirPlanDefinitionGoalTarget.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('measure');
  fields.add('detail[x]');
  fields.add('due');
end;

function TFhirPlanDefinitionGoalTarget.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPlanDefinitionGoalTarget.SetMeasure(value : TFhirCodeableConcept);
begin
  FMeasure.free;
  FMeasure := value;
end;

procedure TFhirPlanDefinitionGoalTarget.SetDetail(value : TFhirDataType);
begin
  FDetail.free;
  FDetail := value;
end;

procedure TFhirPlanDefinitionGoalTarget.SetDue(value : TFhirDuration);
begin
  FDue.free;
  FDue := value;
end;

{ TFhirPlanDefinitionGoalTargetListEnumerator }

constructor TFhirPlanDefinitionGoalTargetListEnumerator.Create(list : TFhirPlanDefinitionGoalTargetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionGoalTargetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionGoalTargetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionGoalTargetListEnumerator.GetCurrent : TFhirPlanDefinitionGoalTarget;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionGoalTargetListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPlanDefinitionGoalTargetList }

function TFhirPlanDefinitionGoalTargetList.AddItem(value: TFhirPlanDefinitionGoalTarget): TFhirPlanDefinitionGoalTarget;
begin
  assert(value.ClassName = 'TFhirPlanDefinitionGoalTarget', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinitionGoalTarget');
  add(value);
  result := value;
end;

function TFhirPlanDefinitionGoalTargetList.Append: TFhirPlanDefinitionGoalTarget;
begin
  result := TFhirPlanDefinitionGoalTarget.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionGoalTargetList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionGoalTargetList.GetEnumerator : TFhirPlanDefinitionGoalTargetListEnumerator;
begin
  result := TFhirPlanDefinitionGoalTargetListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionGoalTargetList.Clone: TFhirPlanDefinitionGoalTargetList;
begin
  result := TFhirPlanDefinitionGoalTargetList(inherited Clone);
end;

function TFhirPlanDefinitionGoalTargetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionGoalTargetList.GetItemN(index: Integer): TFhirPlanDefinitionGoalTarget;
begin
  result := TFhirPlanDefinitionGoalTarget(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionGoalTargetList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinitionGoalTarget;
end;
function TFhirPlanDefinitionGoalTargetList.IndexOf(value: TFhirPlanDefinitionGoalTarget): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionGoalTargetList.Insert(index: Integer): TFhirPlanDefinitionGoalTarget;
begin
  result := TFhirPlanDefinitionGoalTarget.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionGoalTargetList.InsertItem(index: Integer; value: TFhirPlanDefinitionGoalTarget);
begin
  assert(value is TFhirPlanDefinitionGoalTarget);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionGoalTargetList.Item(index: Integer): TFhirPlanDefinitionGoalTarget;
begin
  result := TFhirPlanDefinitionGoalTarget(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionGoalTargetList.Link: TFhirPlanDefinitionGoalTargetList;
begin
  result := TFhirPlanDefinitionGoalTargetList(inherited Link);
end;

procedure TFhirPlanDefinitionGoalTargetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionGoalTargetList.SetItemByIndex(index: Integer; value: TFhirPlanDefinitionGoalTarget);
begin
  assert(value is TFhirPlanDefinitionGoalTarget);
  FhirPlanDefinitionGoalTargets[index] := value;
end;

procedure TFhirPlanDefinitionGoalTargetList.SetItemN(index: Integer; value: TFhirPlanDefinitionGoalTarget);
begin
  assert(value is TFhirPlanDefinitionGoalTarget);
  ObjectByIndex[index] := value;
end;

{ TFhirPlanDefinitionActor }

constructor TFhirPlanDefinitionActor.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinitionActor.Destroy;
begin
  FTitle.free;
  FDescription.free;
  FOptionList.Free;
  inherited;
end;

procedure TFhirPlanDefinitionActor.Assign(oSource : TFslObject);
begin
  inherited;
  titleElement := TFhirPlanDefinitionActor(oSource).titleElement.Clone;
  descriptionElement := TFhirPlanDefinitionActor(oSource).descriptionElement.Clone;
  if (TFhirPlanDefinitionActor(oSource).FOptionList = nil) then
  begin
    FOptionList.free;
    FOptionList := nil;
  end
  else
  begin
    if FOptionList = nil then
      FOptionList := TFhirPlanDefinitionActorOptionList.Create;
    FOptionList.Assign(TFhirPlanDefinitionActor(oSource).FOptionList);
  end;
end;

procedure TFhirPlanDefinitionActor.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'option') Then
    list.addAll(self, 'option', FOptionList);
end;

procedure TFhirPlanDefinitionActor.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'option', 'BackboneElement', true, TFhirPlanDefinitionActorOption, FOptionList.Link));
end;

function TFhirPlanDefinitionActor.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'option') then
  begin
    OptionList.add(propValue as TFhirPlanDefinitionActorOption);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinitionActor.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'option') then OptionList.insertItem(index, propValue as TFhirPlanDefinitionActorOption)
  else inherited;
end;

function TFhirPlanDefinitionActor.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'option') then result := OptionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinitionActor.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'title') then result := 'string'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'option') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinitionActor.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'option') then deletePropertyValue('option', OptionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinitionActor.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'option') then replacePropertyValue('option', OptionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinitionActor.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'option') then OptionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinitionActor.fhirType : string;
begin
  result := 'PlanDefinition.actor';
end;

function TFhirPlanDefinitionActor.Link : TFhirPlanDefinitionActor;
begin
  result := TFhirPlanDefinitionActor(inherited Link);
end;

function TFhirPlanDefinitionActor.Clone : TFhirPlanDefinitionActor;
begin
  result := TFhirPlanDefinitionActor(inherited Clone);
end;

function TFhirPlanDefinitionActor.equals(other : TObject) : boolean; 
var
  o : TFhirPlanDefinitionActor;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinitionActor)) then
    result := false
  else
  begin
    o := TFhirPlanDefinitionActor(other);
    result := compareDeep(titleElement, o.titleElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(optionList, o.optionList, true);
  end;
end;

function TFhirPlanDefinitionActor.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTitle) and isEmptyProp(FDescription) and isEmptyProp(FoptionList);
end;

procedure TFhirPlanDefinitionActor.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('title');
  fields.add('description');
  fields.add('option');
end;

function TFhirPlanDefinitionActor.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FOptionList.sizeInBytes(magic));
end;

procedure TFhirPlanDefinitionActor.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirPlanDefinitionActor.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirPlanDefinitionActor.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirPlanDefinitionActor.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirPlanDefinitionActor.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirPlanDefinitionActor.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirPlanDefinitionActor.GetOptionList : TFhirPlanDefinitionActorOptionList;
begin
  if FOptionList = nil then
    FOptionList := TFhirPlanDefinitionActorOptionList.Create;
  result := FOptionList;
end;

function TFhirPlanDefinitionActor.GetHasOptionList : boolean;
begin
  result := (FOptionList <> nil) and (FOptionList.count > 0);
end;

{ TFhirPlanDefinitionActorListEnumerator }

constructor TFhirPlanDefinitionActorListEnumerator.Create(list : TFhirPlanDefinitionActorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionActorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionActorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionActorListEnumerator.GetCurrent : TFhirPlanDefinitionActor;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionActorListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPlanDefinitionActorList }

function TFhirPlanDefinitionActorList.AddItem(value: TFhirPlanDefinitionActor): TFhirPlanDefinitionActor;
begin
  assert(value.ClassName = 'TFhirPlanDefinitionActor', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinitionActor');
  add(value);
  result := value;
end;

function TFhirPlanDefinitionActorList.Append: TFhirPlanDefinitionActor;
begin
  result := TFhirPlanDefinitionActor.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActorList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionActorList.GetEnumerator : TFhirPlanDefinitionActorListEnumerator;
begin
  result := TFhirPlanDefinitionActorListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionActorList.Clone: TFhirPlanDefinitionActorList;
begin
  result := TFhirPlanDefinitionActorList(inherited Clone);
end;

function TFhirPlanDefinitionActorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionActorList.GetItemN(index: Integer): TFhirPlanDefinitionActor;
begin
  result := TFhirPlanDefinitionActor(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActorList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinitionActor;
end;
function TFhirPlanDefinitionActorList.IndexOf(value: TFhirPlanDefinitionActor): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionActorList.Insert(index: Integer): TFhirPlanDefinitionActor;
begin
  result := TFhirPlanDefinitionActor.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActorList.InsertItem(index: Integer; value: TFhirPlanDefinitionActor);
begin
  assert(value is TFhirPlanDefinitionActor);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionActorList.Item(index: Integer): TFhirPlanDefinitionActor;
begin
  result := TFhirPlanDefinitionActor(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActorList.Link: TFhirPlanDefinitionActorList;
begin
  result := TFhirPlanDefinitionActorList(inherited Link);
end;

procedure TFhirPlanDefinitionActorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionActorList.SetItemByIndex(index: Integer; value: TFhirPlanDefinitionActor);
begin
  assert(value is TFhirPlanDefinitionActor);
  FhirPlanDefinitionActors[index] := value;
end;

procedure TFhirPlanDefinitionActorList.SetItemN(index: Integer; value: TFhirPlanDefinitionActor);
begin
  assert(value is TFhirPlanDefinitionActor);
  ObjectByIndex[index] := value;
end;

{ TFhirPlanDefinitionActorOption }

constructor TFhirPlanDefinitionActorOption.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinitionActorOption.Destroy;
begin
  FType_.free;
  FTypeCanonical.free;
  FTypeReference.free;
  FRole.free;
  inherited;
end;

procedure TFhirPlanDefinitionActorOption.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirPlanDefinitionActorOption(oSource).type_Element.Clone;
  typeCanonicalElement := TFhirPlanDefinitionActorOption(oSource).typeCanonicalElement.Clone;
  typeReference := TFhirPlanDefinitionActorOption(oSource).typeReference.Clone;
  role := TFhirPlanDefinitionActorOption(oSource).role.Clone;
end;

procedure TFhirPlanDefinitionActorOption.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'typeCanonical') Then
     list.add(self.link, 'typeCanonical', FTypeCanonical.Link);
  if (child_name = 'typeReference') Then
     list.add(self.link, 'typeReference', FTypeReference.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
end;

procedure TFhirPlanDefinitionActorOption.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'typeCanonical', 'canonical', false, TFhirCanonical, FTypeCanonical.Link));
  oList.add(TFHIRProperty.create(self, 'typeReference', 'Reference', false, TFhirReference, FTypeReference.Link));
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));
end;

function TFhirPlanDefinitionActorOption.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirActionParticipantTypeEnum, CODES_TFhirActionParticipantTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'typeCanonical') then
  begin
    TypeCanonicalElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'typeReference') then
  begin
    TypeReference := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinitionActorOption.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPlanDefinitionActorOption.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirActionParticipantTypeEnum[ActionParticipantTypeNull], CODES_TFhirActionParticipantTypeEnum[ActionParticipantTypeNull]) 
  else if (propName = 'typeCanonical') then result := TFhirCanonical.create()
  else if (propName = 'typeReference') then result := TFhirReference.create()
  else if (propName = 'role') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinitionActorOption.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'typeCanonical') then result := 'canonical'
  else if (propName = 'typeReference') then result := 'Reference'
  else if (propName = 'role') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinitionActorOption.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'typeCanonical') then TypeCanonicalElement := nil
  else if (propName = 'typeReference') then TypeReferenceElement := nil
  else if (propName = 'role') then RoleElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinitionActorOption.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirActionParticipantTypeEnum, CODES_TFhirActionParticipantTypeEnum, new)
  else if (propName = 'typeCanonical') then TypeCanonicalElement := asCanonical(new)
  else if (propName = 'typeReference') then TypeReferenceElement := new as TFhirReference
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinitionActorOption.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinitionActorOption.fhirType : string;
begin
  result := 'PlanDefinition.actor.option';
end;

function TFhirPlanDefinitionActorOption.Link : TFhirPlanDefinitionActorOption;
begin
  result := TFhirPlanDefinitionActorOption(inherited Link);
end;

function TFhirPlanDefinitionActorOption.Clone : TFhirPlanDefinitionActorOption;
begin
  result := TFhirPlanDefinitionActorOption(inherited Clone);
end;

function TFhirPlanDefinitionActorOption.equals(other : TObject) : boolean; 
var
  o : TFhirPlanDefinitionActorOption;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinitionActorOption)) then
    result := false
  else
  begin
    o := TFhirPlanDefinitionActorOption(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(typeCanonicalElement, o.typeCanonicalElement, true) and 
      compareDeep(typeReferenceElement, o.typeReferenceElement, true) and compareDeep(roleElement, o.roleElement, true);
  end;
end;

function TFhirPlanDefinitionActorOption.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FTypeCanonical) and isEmptyProp(FTypeReference) and isEmptyProp(FRole);
end;

procedure TFhirPlanDefinitionActorOption.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('typeCanonical');
  fields.add('typeReference');
  fields.add('role');
end;

function TFhirPlanDefinitionActorOption.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPlanDefinitionActorOption.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirPlanDefinitionActorOption.GetType_ST : TFhirActionParticipantTypeEnum;
begin
  if FType_ = nil then
    result := TFhirActionParticipantTypeEnum(0)
  else
    result := TFhirActionParticipantTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirActionParticipantTypeEnum, FType_.value));
end;

procedure TFhirPlanDefinitionActorOption.SetType_ST(value : TFhirActionParticipantTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirActionParticipantTypeEnum[value], CODES_TFhirActionParticipantTypeEnum[value]);
end;

procedure TFhirPlanDefinitionActorOption.SetTypeCanonical(value : TFhirCanonical);
begin
  FTypeCanonical.free;
  FTypeCanonical := value;
end;

function TFhirPlanDefinitionActorOption.GetTypeCanonicalST : String;
begin
  if FTypeCanonical = nil then
    result := ''
  else
    result := FTypeCanonical.value;
end;

procedure TFhirPlanDefinitionActorOption.SetTypeCanonicalST(value : String);
begin
  if value <> '' then
  begin
    if FTypeCanonical = nil then
      FTypeCanonical := TFhirCanonical.create;
    FTypeCanonical.value := value
  end
  else if FTypeCanonical <> nil then
    FTypeCanonical.value := '';
end;

procedure TFhirPlanDefinitionActorOption.SetTypeReference(value : TFhirReference);
begin
  FTypeReference.free;
  FTypeReference := value;
end;

procedure TFhirPlanDefinitionActorOption.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

{ TFhirPlanDefinitionActorOptionListEnumerator }

constructor TFhirPlanDefinitionActorOptionListEnumerator.Create(list : TFhirPlanDefinitionActorOptionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionActorOptionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionActorOptionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionActorOptionListEnumerator.GetCurrent : TFhirPlanDefinitionActorOption;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionActorOptionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPlanDefinitionActorOptionList }

function TFhirPlanDefinitionActorOptionList.AddItem(value: TFhirPlanDefinitionActorOption): TFhirPlanDefinitionActorOption;
begin
  assert(value.ClassName = 'TFhirPlanDefinitionActorOption', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinitionActorOption');
  add(value);
  result := value;
end;

function TFhirPlanDefinitionActorOptionList.Append: TFhirPlanDefinitionActorOption;
begin
  result := TFhirPlanDefinitionActorOption.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActorOptionList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionActorOptionList.GetEnumerator : TFhirPlanDefinitionActorOptionListEnumerator;
begin
  result := TFhirPlanDefinitionActorOptionListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionActorOptionList.Clone: TFhirPlanDefinitionActorOptionList;
begin
  result := TFhirPlanDefinitionActorOptionList(inherited Clone);
end;

function TFhirPlanDefinitionActorOptionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionActorOptionList.GetItemN(index: Integer): TFhirPlanDefinitionActorOption;
begin
  result := TFhirPlanDefinitionActorOption(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActorOptionList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinitionActorOption;
end;
function TFhirPlanDefinitionActorOptionList.IndexOf(value: TFhirPlanDefinitionActorOption): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionActorOptionList.Insert(index: Integer): TFhirPlanDefinitionActorOption;
begin
  result := TFhirPlanDefinitionActorOption.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActorOptionList.InsertItem(index: Integer; value: TFhirPlanDefinitionActorOption);
begin
  assert(value is TFhirPlanDefinitionActorOption);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionActorOptionList.Item(index: Integer): TFhirPlanDefinitionActorOption;
begin
  result := TFhirPlanDefinitionActorOption(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActorOptionList.Link: TFhirPlanDefinitionActorOptionList;
begin
  result := TFhirPlanDefinitionActorOptionList(inherited Link);
end;

procedure TFhirPlanDefinitionActorOptionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionActorOptionList.SetItemByIndex(index: Integer; value: TFhirPlanDefinitionActorOption);
begin
  assert(value is TFhirPlanDefinitionActorOption);
  FhirPlanDefinitionActorOptions[index] := value;
end;

procedure TFhirPlanDefinitionActorOptionList.SetItemN(index: Integer; value: TFhirPlanDefinitionActorOption);
begin
  assert(value is TFhirPlanDefinitionActorOption);
  ObjectByIndex[index] := value;
end;

{ TFhirPlanDefinitionAction }

constructor TFhirPlanDefinitionAction.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinitionAction.Destroy;
begin
  FLinkId.free;
  FPrefix.free;
  FTitle.free;
  FDescription.free;
  FTextEquivalent.free;
  FPriority.free;
  FCode.free;
  FReasonList.Free;
  FDocumentationList.Free;
  FGoalIdList.Free;
  FSubject.free;
  FTriggerList.Free;
  FConditionList.Free;
  FInputList.Free;
  FOutputList.Free;
  FRelatedActionList.Free;
  FTiming.free;
  FLocation.free;
  FParticipantList.Free;
  FType_.free;
  FGroupingBehavior.free;
  FSelectionBehavior.free;
  FRequiredBehavior.free;
  FPrecheckBehavior.free;
  FCardinalityBehavior.free;
  FDefinition.free;
  FTransform.free;
  FDynamicValueList.Free;
  FActionList.Free;
  inherited;
end;

procedure TFhirPlanDefinitionAction.Assign(oSource : TFslObject);
begin
  inherited;
  linkIdElement := TFhirPlanDefinitionAction(oSource).linkIdElement.Clone;
  prefixElement := TFhirPlanDefinitionAction(oSource).prefixElement.Clone;
  titleElement := TFhirPlanDefinitionAction(oSource).titleElement.Clone;
  descriptionElement := TFhirPlanDefinitionAction(oSource).descriptionElement.Clone;
  textEquivalentElement := TFhirPlanDefinitionAction(oSource).textEquivalentElement.Clone;
  priorityElement := TFhirPlanDefinitionAction(oSource).priorityElement.Clone;
  code := TFhirPlanDefinitionAction(oSource).code.Clone;
  if (TFhirPlanDefinitionAction(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableConceptList.Create;
    FReasonList.Assign(TFhirPlanDefinitionAction(oSource).FReasonList);
  end;
  if (TFhirPlanDefinitionAction(oSource).FDocumentationList = nil) then
  begin
    FDocumentationList.free;
    FDocumentationList := nil;
  end
  else
  begin
    if FDocumentationList = nil then
      FDocumentationList := TFhirRelatedArtifactList.Create;
    FDocumentationList.Assign(TFhirPlanDefinitionAction(oSource).FDocumentationList);
  end;
  if (TFhirPlanDefinitionAction(oSource).FGoalIdList = nil) then
  begin
    FGoalIdList.free;
    FGoalIdList := nil;
  end
  else
  begin
    if FGoalIdList = nil then
      FGoalIdList := TFhirIdList.Create;
    FGoalIdList.Assign(TFhirPlanDefinitionAction(oSource).FGoalIdList);
  end;
  subject := TFhirPlanDefinitionAction(oSource).subject.Clone;
  if (TFhirPlanDefinitionAction(oSource).FTriggerList = nil) then
  begin
    FTriggerList.free;
    FTriggerList := nil;
  end
  else
  begin
    if FTriggerList = nil then
      FTriggerList := TFhirTriggerDefinitionList.Create;
    FTriggerList.Assign(TFhirPlanDefinitionAction(oSource).FTriggerList);
  end;
  if (TFhirPlanDefinitionAction(oSource).FConditionList = nil) then
  begin
    FConditionList.free;
    FConditionList := nil;
  end
  else
  begin
    if FConditionList = nil then
      FConditionList := TFhirPlanDefinitionActionConditionList.Create;
    FConditionList.Assign(TFhirPlanDefinitionAction(oSource).FConditionList);
  end;
  if (TFhirPlanDefinitionAction(oSource).FInputList = nil) then
  begin
    FInputList.free;
    FInputList := nil;
  end
  else
  begin
    if FInputList = nil then
      FInputList := TFhirPlanDefinitionActionInputList.Create;
    FInputList.Assign(TFhirPlanDefinitionAction(oSource).FInputList);
  end;
  if (TFhirPlanDefinitionAction(oSource).FOutputList = nil) then
  begin
    FOutputList.free;
    FOutputList := nil;
  end
  else
  begin
    if FOutputList = nil then
      FOutputList := TFhirPlanDefinitionActionOutputList.Create;
    FOutputList.Assign(TFhirPlanDefinitionAction(oSource).FOutputList);
  end;
  if (TFhirPlanDefinitionAction(oSource).FRelatedActionList = nil) then
  begin
    FRelatedActionList.free;
    FRelatedActionList := nil;
  end
  else
  begin
    if FRelatedActionList = nil then
      FRelatedActionList := TFhirPlanDefinitionActionRelatedActionList.Create;
    FRelatedActionList.Assign(TFhirPlanDefinitionAction(oSource).FRelatedActionList);
  end;
  timing := TFhirPlanDefinitionAction(oSource).timing.Clone;
  location := TFhirPlanDefinitionAction(oSource).location.Clone;
  if (TFhirPlanDefinitionAction(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirPlanDefinitionActionParticipantList.Create;
    FParticipantList.Assign(TFhirPlanDefinitionAction(oSource).FParticipantList);
  end;
  type_ := TFhirPlanDefinitionAction(oSource).type_.Clone;
  groupingBehaviorElement := TFhirPlanDefinitionAction(oSource).groupingBehaviorElement.Clone;
  selectionBehaviorElement := TFhirPlanDefinitionAction(oSource).selectionBehaviorElement.Clone;
  requiredBehaviorElement := TFhirPlanDefinitionAction(oSource).requiredBehaviorElement.Clone;
  precheckBehaviorElement := TFhirPlanDefinitionAction(oSource).precheckBehaviorElement.Clone;
  cardinalityBehaviorElement := TFhirPlanDefinitionAction(oSource).cardinalityBehaviorElement.Clone;
  definition := TFhirPlanDefinitionAction(oSource).definition.Clone;
  transformElement := TFhirPlanDefinitionAction(oSource).transformElement.Clone;
  if (TFhirPlanDefinitionAction(oSource).FDynamicValueList = nil) then
  begin
    FDynamicValueList.free;
    FDynamicValueList := nil;
  end
  else
  begin
    if FDynamicValueList = nil then
      FDynamicValueList := TFhirPlanDefinitionActionDynamicValueList.Create;
    FDynamicValueList.Assign(TFhirPlanDefinitionAction(oSource).FDynamicValueList);
  end;
  if (TFhirPlanDefinitionAction(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirPlanDefinitionActionList.Create;
    FActionList.Assign(TFhirPlanDefinitionAction(oSource).FActionList);
  end;
end;

procedure TFhirPlanDefinitionAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'linkId') Then
     list.add(self.link, 'linkId', FLinkId.Link);
  if (child_name = 'prefix') Then
     list.add(self.link, 'prefix', FPrefix.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'textEquivalent') Then
     list.add(self.link, 'textEquivalent', FTextEquivalent.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'documentation') Then
    list.addAll(self, 'documentation', FDocumentationList);
  if (child_name = 'goalId') Then
    list.addAll(self, 'goalId', FGoalIdList);
  if (child_name = 'subject[x]') or (child_name = 'subject') Then
     list.add(self.link, 'subject[x]', FSubject.Link);
  if (child_name = 'trigger') Then
    list.addAll(self, 'trigger', FTriggerList);
  if (child_name = 'condition') Then
    list.addAll(self, 'condition', FConditionList);
  if (child_name = 'input') Then
    list.addAll(self, 'input', FInputList);
  if (child_name = 'output') Then
    list.addAll(self, 'output', FOutputList);
  if (child_name = 'relatedAction') Then
    list.addAll(self, 'relatedAction', FRelatedActionList);
  if (child_name = 'timing[x]') or (child_name = 'timing') Then
     list.add(self.link, 'timing[x]', FTiming.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'groupingBehavior') Then
     list.add(self.link, 'groupingBehavior', FGroupingBehavior.Link);
  if (child_name = 'selectionBehavior') Then
     list.add(self.link, 'selectionBehavior', FSelectionBehavior.Link);
  if (child_name = 'requiredBehavior') Then
     list.add(self.link, 'requiredBehavior', FRequiredBehavior.Link);
  if (child_name = 'precheckBehavior') Then
     list.add(self.link, 'precheckBehavior', FPrecheckBehavior.Link);
  if (child_name = 'cardinalityBehavior') Then
     list.add(self.link, 'cardinalityBehavior', FCardinalityBehavior.Link);
  if (child_name = 'definition[x]') or (child_name = 'definition') Then
     list.add(self.link, 'definition[x]', FDefinition.Link);
  if (child_name = 'transform') Then
     list.add(self.link, 'transform', FTransform.Link);
  if (child_name = 'dynamicValue') Then
    list.addAll(self, 'dynamicValue', FDynamicValueList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirPlanDefinitionAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'linkId', 'string', false, TFhirString, FLinkId.Link));
  oList.add(TFHIRProperty.create(self, 'prefix', 'string', false, TFhirString, FPrefix.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'textEquivalent', 'string', false, TFhirString, FTextEquivalent.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFhirEnum, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', true, TFhirCodeableConcept, FReasonList.Link));
  oList.add(TFHIRProperty.create(self, 'documentation', 'RelatedArtifact', true, TFhirRelatedArtifact, FDocumentationList.Link));
  oList.add(TFHIRProperty.create(self, 'goalId', 'id', true, TFhirId, FGoalIdList.Link));
  oList.add(TFHIRProperty.create(self, 'subject[x]', 'CodeableConcept|Reference|canonical', false, TFhirDataType, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'trigger', 'TriggerDefinition', true, TFhirTriggerDefinition, FTriggerList.Link));
  oList.add(TFHIRProperty.create(self, 'condition', 'BackboneElement', true, TFhirPlanDefinitionActionCondition, FConditionList.Link));
  oList.add(TFHIRProperty.create(self, 'input', 'BackboneElement', true, TFhirPlanDefinitionActionInput, FInputList.Link));
  oList.add(TFHIRProperty.create(self, 'output', 'BackboneElement', true, TFhirPlanDefinitionActionOutput, FOutputList.Link));
  oList.add(TFHIRProperty.create(self, 'relatedAction', 'BackboneElement', true, TFhirPlanDefinitionActionRelatedAction, FRelatedActionList.Link));
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'Age|Duration|Range|Timing', false, TFhirDataType, FTiming.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'CodeableReference', false, TFhirCodeableReference, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'participant', 'BackboneElement', true, TFhirPlanDefinitionActionParticipant, FParticipantList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'groupingBehavior', 'code', false, TFhirEnum, FGroupingBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'selectionBehavior', 'code', false, TFhirEnum, FSelectionBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'requiredBehavior', 'code', false, TFhirEnum, FRequiredBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'precheckBehavior', 'code', false, TFhirEnum, FPrecheckBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'cardinalityBehavior', 'code', false, TFhirEnum, FCardinalityBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'definition[x]', 'canonical|uri', false, TFhirDataType, FDefinition.Link));
  oList.add(TFHIRProperty.create(self, 'transform', 'canonical', false, TFhirCanonical, FTransform.Link));
  oList.add(TFHIRProperty.create(self, 'dynamicValue', 'BackboneElement', true, TFhirPlanDefinitionActionDynamicValue, FDynamicValueList.Link));
  oList.add(TFHIRProperty.create(self, 'action', '', true, TFhirPlanDefinitionAction, FActionList.Link));
end;

function TFhirPlanDefinitionAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'linkId') then
  begin
    LinkIdElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'prefix') then
  begin
    PrefixElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'textEquivalent') then
  begin
    TextEquivalentElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationList.add(propValue as TFhirRelatedArtifact);
    result := propValue;
  end
  else if (propName = 'goalId') then
  begin
    GoalIdList.add(asId(propValue)){2};     result := propValue;

  end
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference', 'Canonical'])) then
  begin
    Subject := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'trigger') then
  begin
    TriggerList.add(propValue as TFhirTriggerDefinition);
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    ConditionList.add(propValue as TFhirPlanDefinitionActionCondition);
    result := propValue;
  end
  else if (propName = 'input') then
  begin
    InputList.add(propValue as TFhirPlanDefinitionActionInput);
    result := propValue;
  end
  else if (propName = 'output') then
  begin
    OutputList.add(propValue as TFhirPlanDefinitionActionOutput);
    result := propValue;
  end
  else if (propName = 'relatedAction') then
  begin
    RelatedActionList.add(propValue as TFhirPlanDefinitionActionRelatedAction);
    result := propValue;
  end
  else if (isMatchingName(propName, 'timing', ['Age', 'Duration', 'Range', 'Timing'])) then
  begin
    Timing := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirPlanDefinitionActionParticipant);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'groupingBehavior') then
  begin
    GroupingBehaviorElement := asEnum(SYSTEMS_TFhirActionGroupingBehaviorEnum, CODES_TFhirActionGroupingBehaviorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'selectionBehavior') then
  begin
    SelectionBehaviorElement := asEnum(SYSTEMS_TFhirActionSelectionBehaviorEnum, CODES_TFhirActionSelectionBehaviorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'requiredBehavior') then
  begin
    RequiredBehaviorElement := asEnum(SYSTEMS_TFhirActionRequiredBehaviorEnum, CODES_TFhirActionRequiredBehaviorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'precheckBehavior') then
  begin
    PrecheckBehaviorElement := asEnum(SYSTEMS_TFhirActionPrecheckBehaviorEnum, CODES_TFhirActionPrecheckBehaviorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'cardinalityBehavior') then
  begin
    CardinalityBehaviorElement := asEnum(SYSTEMS_TFhirActionCardinalityBehaviorEnum, CODES_TFhirActionCardinalityBehaviorEnum, propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'definition', ['Canonical', 'Uri'])) then
  begin
    Definition := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'transform') then
  begin
    TransformElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'dynamicValue') then
  begin
    DynamicValueList.add(propValue as TFhirPlanDefinitionActionDynamicValue);
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirPlanDefinitionAction);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinitionAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'documentation') then DocumentationList.insertItem(index, propValue as TFhirRelatedArtifact)
  else if (propName = 'goalId') then GoalIdList.insertItem(index, asId(propValue))
  else if (propName = 'trigger') then TriggerList.insertItem(index, propValue as TFhirTriggerDefinition)
  else if (propName = 'condition') then ConditionList.insertItem(index, propValue as TFhirPlanDefinitionActionCondition)
  else if (propName = 'input') then InputList.insertItem(index, propValue as TFhirPlanDefinitionActionInput)
  else if (propName = 'output') then OutputList.insertItem(index, propValue as TFhirPlanDefinitionActionOutput)
  else if (propName = 'relatedAction') then RelatedActionList.insertItem(index, propValue as TFhirPlanDefinitionActionRelatedAction)
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirPlanDefinitionActionParticipant)
  else if (propName = 'dynamicValue') then DynamicValueList.insertItem(index, propValue as TFhirPlanDefinitionActionDynamicValue)
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirPlanDefinitionAction)
  else inherited;
end;

function TFhirPlanDefinitionAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'linkId') then result := TFhirString.create()
  else if (propName = 'prefix') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'textEquivalent') then result := TFhirString.create()
  else if (propName = 'priority') then result := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[RequestPriorityNull], CODES_TFhirRequestPriorityEnum[RequestPriorityNull]) 
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'reason') then result := ReasonList.new()
  else if (propName = 'documentation') then result := DocumentationList.new()
  else if (propName = 'goalId') then result := GoalIdList.new()
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference', 'Canonical'])) then raise EFHIRException.create('Cannot make property Subject')
  else if (propName = 'trigger') then result := TriggerList.new()
  else if (propName = 'condition') then result := ConditionList.new()
  else if (propName = 'input') then result := InputList.new()
  else if (propName = 'output') then result := OutputList.new()
  else if (propName = 'relatedAction') then result := RelatedActionList.new()
  else if (isMatchingName(propName, 'timing', ['Age', 'Duration', 'Range', 'Timing'])) then raise EFHIRException.create('Cannot make property Timing')
  else if (propName = 'location') then result := TFhirCodeableReference.create()
  else if (propName = 'participant') then result := ParticipantList.new()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'groupingBehavior') then result := TFhirEnum.create(SYSTEMS_TFhirActionGroupingBehaviorEnum[ActionGroupingBehaviorNull], CODES_TFhirActionGroupingBehaviorEnum[ActionGroupingBehaviorNull]) 
  else if (propName = 'selectionBehavior') then result := TFhirEnum.create(SYSTEMS_TFhirActionSelectionBehaviorEnum[ActionSelectionBehaviorNull], CODES_TFhirActionSelectionBehaviorEnum[ActionSelectionBehaviorNull]) 
  else if (propName = 'requiredBehavior') then result := TFhirEnum.create(SYSTEMS_TFhirActionRequiredBehaviorEnum[ActionRequiredBehaviorNull], CODES_TFhirActionRequiredBehaviorEnum[ActionRequiredBehaviorNull]) 
  else if (propName = 'precheckBehavior') then result := TFhirEnum.create(SYSTEMS_TFhirActionPrecheckBehaviorEnum[ActionPrecheckBehaviorNull], CODES_TFhirActionPrecheckBehaviorEnum[ActionPrecheckBehaviorNull]) 
  else if (propName = 'cardinalityBehavior') then result := TFhirEnum.create(SYSTEMS_TFhirActionCardinalityBehaviorEnum[ActionCardinalityBehaviorNull], CODES_TFhirActionCardinalityBehaviorEnum[ActionCardinalityBehaviorNull]) 
  else if (isMatchingName(propName, 'definition', ['Canonical', 'Uri'])) then raise EFHIRException.create('Cannot make property Definition')
  else if (propName = 'transform') then result := TFhirCanonical.create()
  else if (propName = 'dynamicValue') then result := DynamicValueList.new()
  else if (propName = 'action') then result := ActionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinitionAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'linkId') then result := 'string'
  else if (propName = 'prefix') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'textEquivalent') then result := 'string'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'documentation') then result := 'RelatedArtifact'
  else if (propName = 'goalId') then result := 'id'
  else if (propName = 'subject[x]') then result := 'CodeableConcept|Reference|canonical'
  else if (propName = 'trigger') then result := 'TriggerDefinition'
  else if (propName = 'condition') then result := 'BackboneElement'
  else if (propName = 'input') then result := 'BackboneElement'
  else if (propName = 'output') then result := 'BackboneElement'
  else if (propName = 'relatedAction') then result := 'BackboneElement'
  else if (propName = 'timing[x]') then result := 'Age|Duration|Range|Timing'
  else if (propName = 'location') then result := 'CodeableReference'
  else if (propName = 'participant') then result := 'BackboneElement'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'groupingBehavior') then result := 'code'
  else if (propName = 'selectionBehavior') then result := 'code'
  else if (propName = 'requiredBehavior') then result := 'code'
  else if (propName = 'precheckBehavior') then result := 'code'
  else if (propName = 'cardinalityBehavior') then result := 'code'
  else if (propName = 'definition[x]') then result := 'canonical|uri'
  else if (propName = 'transform') then result := 'canonical'
  else if (propName = 'dynamicValue') then result := 'BackboneElement'
  else if (propName = 'action') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinitionAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := nil
  else if (propName = 'prefix') then PrefixElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'textEquivalent') then TextEquivalentElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value)
  else if (propName = 'documentation') then deletePropertyValue('documentation', DocumentationList, value)
  else if (propName = 'goalId') then deletePropertyValue('goalId', GoalIdList, value)
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference', 'Canonical'])) then SubjectElement := nil
  else if (propName = 'trigger') then deletePropertyValue('trigger', TriggerList, value)
  else if (propName = 'condition') then deletePropertyValue('condition', ConditionList, value)
  else if (propName = 'input') then deletePropertyValue('input', InputList, value)
  else if (propName = 'output') then deletePropertyValue('output', OutputList, value)
  else if (propName = 'relatedAction') then deletePropertyValue('relatedAction', RelatedActionList, value)
  else if (isMatchingName(propName, 'timing', ['Age', 'Duration', 'Range', 'Timing'])) then TimingElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'groupingBehavior') then GroupingBehaviorElement := nil
  else if (propName = 'selectionBehavior') then SelectionBehaviorElement := nil
  else if (propName = 'requiredBehavior') then RequiredBehaviorElement := nil
  else if (propName = 'precheckBehavior') then PrecheckBehaviorElement := nil
  else if (propName = 'cardinalityBehavior') then CardinalityBehaviorElement := nil
  else if (isMatchingName(propName, 'definition', ['Canonical', 'Uri'])) then DefinitionElement := nil
  else if (propName = 'transform') then TransformElement := nil
  else if (propName = 'dynamicValue') then deletePropertyValue('dynamicValue', DynamicValueList, value)
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinitionAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := asString(new)
  else if (propName = 'prefix') then PrefixElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'textEquivalent') then TextEquivalentElement := asString(new)
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new)
  else if (propName = 'documentation') then replacePropertyValue('documentation', DocumentationList, existing, new)
  else if (propName = 'goalId') then replacePropertyValue('goalId', GoalIdList, existing, new)
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference', 'Canonical'])) then SubjectElement := new as TFhirDataType
  else if (propName = 'trigger') then replacePropertyValue('trigger', TriggerList, existing, new)
  else if (propName = 'condition') then replacePropertyValue('condition', ConditionList, existing, new)
  else if (propName = 'input') then replacePropertyValue('input', InputList, existing, new)
  else if (propName = 'output') then replacePropertyValue('output', OutputList, existing, new)
  else if (propName = 'relatedAction') then replacePropertyValue('relatedAction', RelatedActionList, existing, new)
  else if (isMatchingName(propName, 'timing', ['Age', 'Duration', 'Range', 'Timing'])) then TimingElement := new as TFhirDataType
  else if (propName = 'location') then LocationElement := new as TFhirCodeableReference
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'groupingBehavior') then GroupingBehaviorElement := asEnum(SYSTEMS_TFhirActionGroupingBehaviorEnum, CODES_TFhirActionGroupingBehaviorEnum, new)
  else if (propName = 'selectionBehavior') then SelectionBehaviorElement := asEnum(SYSTEMS_TFhirActionSelectionBehaviorEnum, CODES_TFhirActionSelectionBehaviorEnum, new)
  else if (propName = 'requiredBehavior') then RequiredBehaviorElement := asEnum(SYSTEMS_TFhirActionRequiredBehaviorEnum, CODES_TFhirActionRequiredBehaviorEnum, new)
  else if (propName = 'precheckBehavior') then PrecheckBehaviorElement := asEnum(SYSTEMS_TFhirActionPrecheckBehaviorEnum, CODES_TFhirActionPrecheckBehaviorEnum, new)
  else if (propName = 'cardinalityBehavior') then CardinalityBehaviorElement := asEnum(SYSTEMS_TFhirActionCardinalityBehaviorEnum, CODES_TFhirActionCardinalityBehaviorEnum, new)
  else if (isMatchingName(propName, 'definition', ['Canonical', 'Uri'])) then DefinitionElement := new as TFhirDataType
  else if (propName = 'transform') then TransformElement := asCanonical(new)
  else if (propName = 'dynamicValue') then replacePropertyValue('dynamicValue', DynamicValueList, existing, new)
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinitionAction.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'reason') then ReasonList.move(source, destination)
  else if (propName = 'documentation') then DocumentationList.move(source, destination)
  else if (propName = 'goalId') then GoalIdList.move(source, destination)
  else if (propName = 'trigger') then TriggerList.move(source, destination)
  else if (propName = 'condition') then ConditionList.move(source, destination)
  else if (propName = 'input') then InputList.move(source, destination)
  else if (propName = 'output') then OutputList.move(source, destination)
  else if (propName = 'relatedAction') then RelatedActionList.move(source, destination)
  else if (propName = 'participant') then ParticipantList.move(source, destination)
  else if (propName = 'dynamicValue') then DynamicValueList.move(source, destination)
  else if (propName = 'action') then ActionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinitionAction.fhirType : string;
begin
  result := 'PlanDefinition.action';
end;

function TFhirPlanDefinitionAction.Link : TFhirPlanDefinitionAction;
begin
  result := TFhirPlanDefinitionAction(inherited Link);
end;

function TFhirPlanDefinitionAction.Clone : TFhirPlanDefinitionAction;
begin
  result := TFhirPlanDefinitionAction(inherited Clone);
end;

function TFhirPlanDefinitionAction.equals(other : TObject) : boolean; 
var
  o : TFhirPlanDefinitionAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinitionAction)) then
    result := false
  else
  begin
    o := TFhirPlanDefinitionAction(other);
    result := compareDeep(linkIdElement, o.linkIdElement, true) and compareDeep(prefixElement, o.prefixElement, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(textEquivalentElement, o.textEquivalentElement, true) and compareDeep(priorityElement, o.priorityElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(reasonList, o.reasonList, true) and 
      compareDeep(documentationList, o.documentationList, true) and compareDeep(goalIdList, o.goalIdList, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(triggerList, o.triggerList, true) and 
      compareDeep(conditionList, o.conditionList, true) and compareDeep(inputList, o.inputList, true) and 
      compareDeep(outputList, o.outputList, true) and compareDeep(relatedActionList, o.relatedActionList, true) and 
      compareDeep(timingElement, o.timingElement, true) and compareDeep(locationElement, o.locationElement, true) and 
      compareDeep(participantList, o.participantList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(groupingBehaviorElement, o.groupingBehaviorElement, true) and compareDeep(selectionBehaviorElement, o.selectionBehaviorElement, true) and 
      compareDeep(requiredBehaviorElement, o.requiredBehaviorElement, true) and compareDeep(precheckBehaviorElement, o.precheckBehaviorElement, true) and 
      compareDeep(cardinalityBehaviorElement, o.cardinalityBehaviorElement, true) and 
      compareDeep(definitionElement, o.definitionElement, true) and compareDeep(transformElement, o.transformElement, true) and 
      compareDeep(dynamicValueList, o.dynamicValueList, true) and compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirPlanDefinitionAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLinkId) and isEmptyProp(FPrefix) and isEmptyProp(FTitle) and isEmptyProp(FDescription) and isEmptyProp(FTextEquivalent) and isEmptyProp(FPriority) and isEmptyProp(FCode) and isEmptyProp(FreasonList) and isEmptyProp(FdocumentationList) and isEmptyProp(FgoalIdList) and isEmptyProp(FSubject) and isEmptyProp(FtriggerList) and isEmptyProp(FconditionList) and isEmptyProp(FinputList) and isEmptyProp(FoutputList) and isEmptyProp(FrelatedActionList) and isEmptyProp(FTiming) and isEmptyProp(FLocation) and isEmptyProp(FparticipantList) and isEmptyProp(FType_) and isEmptyProp(FGroupingBehavior) and isEmptyProp(FSelectionBehavior) and isEmptyProp(FRequiredBehavior) and isEmptyProp(FPrecheckBehavior) and isEmptyProp(FCardinalityBehavior) and isEmptyProp(FDefinition) and isEmptyProp(FTransform) and isEmptyProp(FdynamicValueList) and isEmptyProp(FactionList);
end;

procedure TFhirPlanDefinitionAction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('linkId');
  fields.add('prefix');
  fields.add('title');
  fields.add('description');
  fields.add('textEquivalent');
  fields.add('priority');
  fields.add('code');
  fields.add('reason');
  fields.add('documentation');
  fields.add('goalId');
  fields.add('subject[x]');
  fields.add('trigger');
  fields.add('condition');
  fields.add('input');
  fields.add('output');
  fields.add('relatedAction');
  fields.add('timing[x]');
  fields.add('location');
  fields.add('participant');
  fields.add('type');
  fields.add('groupingBehavior');
  fields.add('selectionBehavior');
  fields.add('requiredBehavior');
  fields.add('precheckBehavior');
  fields.add('cardinalityBehavior');
  fields.add('definition[x]');
  fields.add('transform');
  fields.add('dynamicValue');
  fields.add('action');
end;

function TFhirPlanDefinitionAction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FReasonList.sizeInBytes(magic));
  inc(result, FDocumentationList.sizeInBytes(magic));
  inc(result, FGoalIdList.sizeInBytes(magic));
  inc(result, FTriggerList.sizeInBytes(magic));
  inc(result, FConditionList.sizeInBytes(magic));
  inc(result, FInputList.sizeInBytes(magic));
  inc(result, FOutputList.sizeInBytes(magic));
  inc(result, FRelatedActionList.sizeInBytes(magic));
  inc(result, FParticipantList.sizeInBytes(magic));
  inc(result, FDynamicValueList.sizeInBytes(magic));
  inc(result, FActionList.sizeInBytes(magic));
end;

procedure TFhirPlanDefinitionAction.SetLinkId(value : TFhirString);
begin
  FLinkId.free;
  FLinkId := value;
end;

function TFhirPlanDefinitionAction.GetLinkIdST : String;
begin
  if FLinkId = nil then
    result := ''
  else
    result := FLinkId.value;
end;

procedure TFhirPlanDefinitionAction.SetLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FLinkId = nil then
      FLinkId := TFhirString.create;
    FLinkId.value := value
  end
  else if FLinkId <> nil then
    FLinkId.value := '';
end;

procedure TFhirPlanDefinitionAction.SetPrefix(value : TFhirString);
begin
  FPrefix.free;
  FPrefix := value;
end;

function TFhirPlanDefinitionAction.GetPrefixST : String;
begin
  if FPrefix = nil then
    result := ''
  else
    result := FPrefix.value;
end;

procedure TFhirPlanDefinitionAction.SetPrefixST(value : String);
begin
  if value <> '' then
  begin
    if FPrefix = nil then
      FPrefix := TFhirString.create;
    FPrefix.value := value
  end
  else if FPrefix <> nil then
    FPrefix.value := '';
end;

procedure TFhirPlanDefinitionAction.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirPlanDefinitionAction.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirPlanDefinitionAction.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirPlanDefinitionAction.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirPlanDefinitionAction.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirPlanDefinitionAction.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirPlanDefinitionAction.SetTextEquivalent(value : TFhirString);
begin
  FTextEquivalent.free;
  FTextEquivalent := value;
end;

function TFhirPlanDefinitionAction.GetTextEquivalentST : String;
begin
  if FTextEquivalent = nil then
    result := ''
  else
    result := FTextEquivalent.value;
end;

procedure TFhirPlanDefinitionAction.SetTextEquivalentST(value : String);
begin
  if value <> '' then
  begin
    if FTextEquivalent = nil then
      FTextEquivalent := TFhirString.create;
    FTextEquivalent.value := value
  end
  else if FTextEquivalent <> nil then
    FTextEquivalent.value := '';
end;

procedure TFhirPlanDefinitionAction.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirPlanDefinitionAction.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

procedure TFhirPlanDefinitionAction.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

procedure TFhirPlanDefinitionAction.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

function TFhirPlanDefinitionAction.GetReasonList : TFhirCodeableConceptList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableConceptList.Create;
  result := FReasonList;
end;

function TFhirPlanDefinitionAction.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirPlanDefinitionAction.GetDocumentationList : TFhirRelatedArtifactList;
begin
  if FDocumentationList = nil then
    FDocumentationList := TFhirRelatedArtifactList.Create;
  result := FDocumentationList;
end;

function TFhirPlanDefinitionAction.GetHasDocumentationList : boolean;
begin
  result := (FDocumentationList <> nil) and (FDocumentationList.count > 0);
end;

function TFhirPlanDefinitionAction.GetGoalIdList : TFhirIdList;
begin
  if FGoalIdList = nil then
    FGoalIdList := TFhirIdList.Create;
  result := FGoalIdList;
end;

function TFhirPlanDefinitionAction.GetHasGoalIdList : boolean;
begin
  result := (FGoalIdList <> nil) and (FGoalIdList.count > 0);
end;

procedure TFhirPlanDefinitionAction.SetSubject(value : TFhirDataType);
begin
  FSubject.free;
  FSubject := value;
end;

function TFhirPlanDefinitionAction.GetTriggerList : TFhirTriggerDefinitionList;
begin
  if FTriggerList = nil then
    FTriggerList := TFhirTriggerDefinitionList.Create;
  result := FTriggerList;
end;

function TFhirPlanDefinitionAction.GetHasTriggerList : boolean;
begin
  result := (FTriggerList <> nil) and (FTriggerList.count > 0);
end;

function TFhirPlanDefinitionAction.GetConditionList : TFhirPlanDefinitionActionConditionList;
begin
  if FConditionList = nil then
    FConditionList := TFhirPlanDefinitionActionConditionList.Create;
  result := FConditionList;
end;

function TFhirPlanDefinitionAction.GetHasConditionList : boolean;
begin
  result := (FConditionList <> nil) and (FConditionList.count > 0);
end;

function TFhirPlanDefinitionAction.GetInputList : TFhirPlanDefinitionActionInputList;
begin
  if FInputList = nil then
    FInputList := TFhirPlanDefinitionActionInputList.Create;
  result := FInputList;
end;

function TFhirPlanDefinitionAction.GetHasInputList : boolean;
begin
  result := (FInputList <> nil) and (FInputList.count > 0);
end;

function TFhirPlanDefinitionAction.GetOutputList : TFhirPlanDefinitionActionOutputList;
begin
  if FOutputList = nil then
    FOutputList := TFhirPlanDefinitionActionOutputList.Create;
  result := FOutputList;
end;

function TFhirPlanDefinitionAction.GetHasOutputList : boolean;
begin
  result := (FOutputList <> nil) and (FOutputList.count > 0);
end;

function TFhirPlanDefinitionAction.GetRelatedActionList : TFhirPlanDefinitionActionRelatedActionList;
begin
  if FRelatedActionList = nil then
    FRelatedActionList := TFhirPlanDefinitionActionRelatedActionList.Create;
  result := FRelatedActionList;
end;

function TFhirPlanDefinitionAction.GetHasRelatedActionList : boolean;
begin
  result := (FRelatedActionList <> nil) and (FRelatedActionList.count > 0);
end;

procedure TFhirPlanDefinitionAction.SetTiming(value : TFhirDataType);
begin
  FTiming.free;
  FTiming := value;
end;

procedure TFhirPlanDefinitionAction.SetLocation(value : TFhirCodeableReference);
begin
  FLocation.free;
  FLocation := value;
end;

function TFhirPlanDefinitionAction.GetParticipantList : TFhirPlanDefinitionActionParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirPlanDefinitionActionParticipantList.Create;
  result := FParticipantList;
end;

function TFhirPlanDefinitionAction.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

procedure TFhirPlanDefinitionAction.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirPlanDefinitionAction.SetGroupingBehavior(value : TFhirEnum);
begin
  FGroupingBehavior.free;
  FGroupingBehavior := value;
end;

function TFhirPlanDefinitionAction.GetGroupingBehaviorST : TFhirActionGroupingBehaviorEnum;
begin
  if FGroupingBehavior = nil then
    result := TFhirActionGroupingBehaviorEnum(0)
  else
    result := TFhirActionGroupingBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionGroupingBehaviorEnum, FGroupingBehavior.value));
end;

procedure TFhirPlanDefinitionAction.SetGroupingBehaviorST(value : TFhirActionGroupingBehaviorEnum);
begin
  if ord(value) = 0 then
    GroupingBehaviorElement := nil
  else
    GroupingBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionGroupingBehaviorEnum[value], CODES_TFhirActionGroupingBehaviorEnum[value]);
end;

procedure TFhirPlanDefinitionAction.SetSelectionBehavior(value : TFhirEnum);
begin
  FSelectionBehavior.free;
  FSelectionBehavior := value;
end;

function TFhirPlanDefinitionAction.GetSelectionBehaviorST : TFhirActionSelectionBehaviorEnum;
begin
  if FSelectionBehavior = nil then
    result := TFhirActionSelectionBehaviorEnum(0)
  else
    result := TFhirActionSelectionBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionSelectionBehaviorEnum, FSelectionBehavior.value));
end;

procedure TFhirPlanDefinitionAction.SetSelectionBehaviorST(value : TFhirActionSelectionBehaviorEnum);
begin
  if ord(value) = 0 then
    SelectionBehaviorElement := nil
  else
    SelectionBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionSelectionBehaviorEnum[value], CODES_TFhirActionSelectionBehaviorEnum[value]);
end;

procedure TFhirPlanDefinitionAction.SetRequiredBehavior(value : TFhirEnum);
begin
  FRequiredBehavior.free;
  FRequiredBehavior := value;
end;

function TFhirPlanDefinitionAction.GetRequiredBehaviorST : TFhirActionRequiredBehaviorEnum;
begin
  if FRequiredBehavior = nil then
    result := TFhirActionRequiredBehaviorEnum(0)
  else
    result := TFhirActionRequiredBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionRequiredBehaviorEnum, FRequiredBehavior.value));
end;

procedure TFhirPlanDefinitionAction.SetRequiredBehaviorST(value : TFhirActionRequiredBehaviorEnum);
begin
  if ord(value) = 0 then
    RequiredBehaviorElement := nil
  else
    RequiredBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionRequiredBehaviorEnum[value], CODES_TFhirActionRequiredBehaviorEnum[value]);
end;

procedure TFhirPlanDefinitionAction.SetPrecheckBehavior(value : TFhirEnum);
begin
  FPrecheckBehavior.free;
  FPrecheckBehavior := value;
end;

function TFhirPlanDefinitionAction.GetPrecheckBehaviorST : TFhirActionPrecheckBehaviorEnum;
begin
  if FPrecheckBehavior = nil then
    result := TFhirActionPrecheckBehaviorEnum(0)
  else
    result := TFhirActionPrecheckBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionPrecheckBehaviorEnum, FPrecheckBehavior.value));
end;

procedure TFhirPlanDefinitionAction.SetPrecheckBehaviorST(value : TFhirActionPrecheckBehaviorEnum);
begin
  if ord(value) = 0 then
    PrecheckBehaviorElement := nil
  else
    PrecheckBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionPrecheckBehaviorEnum[value], CODES_TFhirActionPrecheckBehaviorEnum[value]);
end;

procedure TFhirPlanDefinitionAction.SetCardinalityBehavior(value : TFhirEnum);
begin
  FCardinalityBehavior.free;
  FCardinalityBehavior := value;
end;

function TFhirPlanDefinitionAction.GetCardinalityBehaviorST : TFhirActionCardinalityBehaviorEnum;
begin
  if FCardinalityBehavior = nil then
    result := TFhirActionCardinalityBehaviorEnum(0)
  else
    result := TFhirActionCardinalityBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionCardinalityBehaviorEnum, FCardinalityBehavior.value));
end;

procedure TFhirPlanDefinitionAction.SetCardinalityBehaviorST(value : TFhirActionCardinalityBehaviorEnum);
begin
  if ord(value) = 0 then
    CardinalityBehaviorElement := nil
  else
    CardinalityBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionCardinalityBehaviorEnum[value], CODES_TFhirActionCardinalityBehaviorEnum[value]);
end;

procedure TFhirPlanDefinitionAction.SetDefinition(value : TFhirDataType);
begin
  FDefinition.free;
  FDefinition := value;
end;

procedure TFhirPlanDefinitionAction.SetTransform(value : TFhirCanonical);
begin
  FTransform.free;
  FTransform := value;
end;

function TFhirPlanDefinitionAction.GetTransformST : String;
begin
  if FTransform = nil then
    result := ''
  else
    result := FTransform.value;
end;

procedure TFhirPlanDefinitionAction.SetTransformST(value : String);
begin
  if value <> '' then
  begin
    if FTransform = nil then
      FTransform := TFhirCanonical.create;
    FTransform.value := value
  end
  else if FTransform <> nil then
    FTransform.value := '';
end;

function TFhirPlanDefinitionAction.GetDynamicValueList : TFhirPlanDefinitionActionDynamicValueList;
begin
  if FDynamicValueList = nil then
    FDynamicValueList := TFhirPlanDefinitionActionDynamicValueList.Create;
  result := FDynamicValueList;
end;

function TFhirPlanDefinitionAction.GetHasDynamicValueList : boolean;
begin
  result := (FDynamicValueList <> nil) and (FDynamicValueList.count > 0);
end;

function TFhirPlanDefinitionAction.GetActionList : TFhirPlanDefinitionActionList;
begin
  if FActionList = nil then
    FActionList := TFhirPlanDefinitionActionList.Create;
  result := FActionList;
end;

function TFhirPlanDefinitionAction.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

{ TFhirPlanDefinitionActionListEnumerator }

constructor TFhirPlanDefinitionActionListEnumerator.Create(list : TFhirPlanDefinitionActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionActionListEnumerator.GetCurrent : TFhirPlanDefinitionAction;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionActionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPlanDefinitionActionList }

function TFhirPlanDefinitionActionList.AddItem(value: TFhirPlanDefinitionAction): TFhirPlanDefinitionAction;
begin
  assert(value.ClassName = 'TFhirPlanDefinitionAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinitionAction');
  add(value);
  result := value;
end;

function TFhirPlanDefinitionActionList.Append: TFhirPlanDefinitionAction;
begin
  result := TFhirPlanDefinitionAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionActionList.GetEnumerator : TFhirPlanDefinitionActionListEnumerator;
begin
  result := TFhirPlanDefinitionActionListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionActionList.Clone: TFhirPlanDefinitionActionList;
begin
  result := TFhirPlanDefinitionActionList(inherited Clone);
end;

function TFhirPlanDefinitionActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionActionList.GetItemN(index: Integer): TFhirPlanDefinitionAction;
begin
  result := TFhirPlanDefinitionAction(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinitionAction;
end;
function TFhirPlanDefinitionActionList.IndexOf(value: TFhirPlanDefinitionAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionActionList.Insert(index: Integer): TFhirPlanDefinitionAction;
begin
  result := TFhirPlanDefinitionAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionList.InsertItem(index: Integer; value: TFhirPlanDefinitionAction);
begin
  assert(value is TFhirPlanDefinitionAction);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionActionList.Item(index: Integer): TFhirPlanDefinitionAction;
begin
  result := TFhirPlanDefinitionAction(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionList.Link: TFhirPlanDefinitionActionList;
begin
  result := TFhirPlanDefinitionActionList(inherited Link);
end;

procedure TFhirPlanDefinitionActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionActionList.SetItemByIndex(index: Integer; value: TFhirPlanDefinitionAction);
begin
  assert(value is TFhirPlanDefinitionAction);
  FhirPlanDefinitionActions[index] := value;
end;

procedure TFhirPlanDefinitionActionList.SetItemN(index: Integer; value: TFhirPlanDefinitionAction);
begin
  assert(value is TFhirPlanDefinitionAction);
  ObjectByIndex[index] := value;
end;

{ TFhirPlanDefinitionActionCondition }

constructor TFhirPlanDefinitionActionCondition.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinitionActionCondition.Destroy;
begin
  FKind.free;
  FExpression.free;
  inherited;
end;

procedure TFhirPlanDefinitionActionCondition.Assign(oSource : TFslObject);
begin
  inherited;
  kindElement := TFhirPlanDefinitionActionCondition(oSource).kindElement.Clone;
  expression := TFhirPlanDefinitionActionCondition(oSource).expression.Clone;
end;

procedure TFhirPlanDefinitionActionCondition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
end;

procedure TFhirPlanDefinitionActionCondition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFhirEnum, FKind.Link));
  oList.add(TFHIRProperty.create(self, 'expression', 'Expression', false, TFhirExpression, FExpression.Link));
end;

function TFhirPlanDefinitionActionCondition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirActionConditionKindEnum, CODES_TFhirActionConditionKindEnum, propValue);
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    Expression := propValue as TFhirExpression;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinitionActionCondition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPlanDefinitionActionCondition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'kind') then result := TFhirEnum.create(SYSTEMS_TFhirActionConditionKindEnum[ActionConditionKindNull], CODES_TFhirActionConditionKindEnum[ActionConditionKindNull]) 
  else if (propName = 'expression') then result := TFhirExpression.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinitionActionCondition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'kind') then result := 'code'
  else if (propName = 'expression') then result := 'Expression'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinitionActionCondition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'kind') then KindElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinitionActionCondition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirActionConditionKindEnum, CODES_TFhirActionConditionKindEnum, new)
  else if (propName = 'expression') then ExpressionElement := new as TFhirExpression
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinitionActionCondition.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinitionActionCondition.fhirType : string;
begin
  result := 'PlanDefinition.action.condition';
end;

function TFhirPlanDefinitionActionCondition.Link : TFhirPlanDefinitionActionCondition;
begin
  result := TFhirPlanDefinitionActionCondition(inherited Link);
end;

function TFhirPlanDefinitionActionCondition.Clone : TFhirPlanDefinitionActionCondition;
begin
  result := TFhirPlanDefinitionActionCondition(inherited Clone);
end;

function TFhirPlanDefinitionActionCondition.equals(other : TObject) : boolean; 
var
  o : TFhirPlanDefinitionActionCondition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinitionActionCondition)) then
    result := false
  else
  begin
    o := TFhirPlanDefinitionActionCondition(other);
    result := compareDeep(kindElement, o.kindElement, true) and compareDeep(expressionElement, o.expressionElement, true);
  end;
end;

function TFhirPlanDefinitionActionCondition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FKind) and isEmptyProp(FExpression);
end;

procedure TFhirPlanDefinitionActionCondition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('kind');
  fields.add('expression');
end;

function TFhirPlanDefinitionActionCondition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPlanDefinitionActionCondition.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

function TFhirPlanDefinitionActionCondition.GetKindST : TFhirActionConditionKindEnum;
begin
  if FKind = nil then
    result := TFhirActionConditionKindEnum(0)
  else
    result := TFhirActionConditionKindEnum(StringArrayIndexOfSensitive(CODES_TFhirActionConditionKindEnum, FKind.value));
end;

procedure TFhirPlanDefinitionActionCondition.SetKindST(value : TFhirActionConditionKindEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirActionConditionKindEnum[value], CODES_TFhirActionConditionKindEnum[value]);
end;

procedure TFhirPlanDefinitionActionCondition.SetExpression(value : TFhirExpression);
begin
  FExpression.free;
  FExpression := value;
end;

{ TFhirPlanDefinitionActionConditionListEnumerator }

constructor TFhirPlanDefinitionActionConditionListEnumerator.Create(list : TFhirPlanDefinitionActionConditionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionActionConditionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionActionConditionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionActionConditionListEnumerator.GetCurrent : TFhirPlanDefinitionActionCondition;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionActionConditionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPlanDefinitionActionConditionList }

function TFhirPlanDefinitionActionConditionList.AddItem(value: TFhirPlanDefinitionActionCondition): TFhirPlanDefinitionActionCondition;
begin
  assert(value.ClassName = 'TFhirPlanDefinitionActionCondition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinitionActionCondition');
  add(value);
  result := value;
end;

function TFhirPlanDefinitionActionConditionList.Append: TFhirPlanDefinitionActionCondition;
begin
  result := TFhirPlanDefinitionActionCondition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionConditionList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionActionConditionList.GetEnumerator : TFhirPlanDefinitionActionConditionListEnumerator;
begin
  result := TFhirPlanDefinitionActionConditionListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionActionConditionList.Clone: TFhirPlanDefinitionActionConditionList;
begin
  result := TFhirPlanDefinitionActionConditionList(inherited Clone);
end;

function TFhirPlanDefinitionActionConditionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionActionConditionList.GetItemN(index: Integer): TFhirPlanDefinitionActionCondition;
begin
  result := TFhirPlanDefinitionActionCondition(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionConditionList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinitionActionCondition;
end;
function TFhirPlanDefinitionActionConditionList.IndexOf(value: TFhirPlanDefinitionActionCondition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionActionConditionList.Insert(index: Integer): TFhirPlanDefinitionActionCondition;
begin
  result := TFhirPlanDefinitionActionCondition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionConditionList.InsertItem(index: Integer; value: TFhirPlanDefinitionActionCondition);
begin
  assert(value is TFhirPlanDefinitionActionCondition);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionActionConditionList.Item(index: Integer): TFhirPlanDefinitionActionCondition;
begin
  result := TFhirPlanDefinitionActionCondition(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionConditionList.Link: TFhirPlanDefinitionActionConditionList;
begin
  result := TFhirPlanDefinitionActionConditionList(inherited Link);
end;

procedure TFhirPlanDefinitionActionConditionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionActionConditionList.SetItemByIndex(index: Integer; value: TFhirPlanDefinitionActionCondition);
begin
  assert(value is TFhirPlanDefinitionActionCondition);
  FhirPlanDefinitionActionConditions[index] := value;
end;

procedure TFhirPlanDefinitionActionConditionList.SetItemN(index: Integer; value: TFhirPlanDefinitionActionCondition);
begin
  assert(value is TFhirPlanDefinitionActionCondition);
  ObjectByIndex[index] := value;
end;

{ TFhirPlanDefinitionActionInput }

constructor TFhirPlanDefinitionActionInput.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinitionActionInput.Destroy;
begin
  FTitle.free;
  FRequirement.free;
  FRelatedData.free;
  inherited;
end;

procedure TFhirPlanDefinitionActionInput.Assign(oSource : TFslObject);
begin
  inherited;
  titleElement := TFhirPlanDefinitionActionInput(oSource).titleElement.Clone;
  requirement := TFhirPlanDefinitionActionInput(oSource).requirement.Clone;
  relatedDataElement := TFhirPlanDefinitionActionInput(oSource).relatedDataElement.Clone;
end;

procedure TFhirPlanDefinitionActionInput.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'requirement') Then
     list.add(self.link, 'requirement', FRequirement.Link);
  if (child_name = 'relatedData') Then
     list.add(self.link, 'relatedData', FRelatedData.Link);
end;

procedure TFhirPlanDefinitionActionInput.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'requirement', 'DataRequirement', false, TFhirDataRequirement, FRequirement.Link));
  oList.add(TFHIRProperty.create(self, 'relatedData', 'id', false, TFhirId, FRelatedData.Link));
end;

function TFhirPlanDefinitionActionInput.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'requirement') then
  begin
    Requirement := propValue as TFhirDataRequirement;
    result := propValue;
  end
  else if (propName = 'relatedData') then
  begin
    RelatedDataElement := asId(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinitionActionInput.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPlanDefinitionActionInput.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'requirement') then result := TFhirDataRequirement.create()
  else if (propName = 'relatedData') then result := TFhirId.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinitionActionInput.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'title') then result := 'string'
  else if (propName = 'requirement') then result := 'DataRequirement'
  else if (propName = 'relatedData') then result := 'id'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinitionActionInput.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := nil
  else if (propName = 'requirement') then RequirementElement := nil
  else if (propName = 'relatedData') then RelatedDataElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinitionActionInput.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'requirement') then RequirementElement := new as TFhirDataRequirement
  else if (propName = 'relatedData') then RelatedDataElement := asId(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinitionActionInput.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinitionActionInput.fhirType : string;
begin
  result := 'PlanDefinition.action.input';
end;

function TFhirPlanDefinitionActionInput.Link : TFhirPlanDefinitionActionInput;
begin
  result := TFhirPlanDefinitionActionInput(inherited Link);
end;

function TFhirPlanDefinitionActionInput.Clone : TFhirPlanDefinitionActionInput;
begin
  result := TFhirPlanDefinitionActionInput(inherited Clone);
end;

function TFhirPlanDefinitionActionInput.equals(other : TObject) : boolean; 
var
  o : TFhirPlanDefinitionActionInput;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinitionActionInput)) then
    result := false
  else
  begin
    o := TFhirPlanDefinitionActionInput(other);
    result := compareDeep(titleElement, o.titleElement, true) and compareDeep(requirementElement, o.requirementElement, true) and 
      compareDeep(relatedDataElement, o.relatedDataElement, true);
  end;
end;

function TFhirPlanDefinitionActionInput.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTitle) and isEmptyProp(FRequirement) and isEmptyProp(FRelatedData);
end;

procedure TFhirPlanDefinitionActionInput.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('title');
  fields.add('requirement');
  fields.add('relatedData');
end;

function TFhirPlanDefinitionActionInput.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPlanDefinitionActionInput.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirPlanDefinitionActionInput.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirPlanDefinitionActionInput.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirPlanDefinitionActionInput.SetRequirement(value : TFhirDataRequirement);
begin
  FRequirement.free;
  FRequirement := value;
end;

procedure TFhirPlanDefinitionActionInput.SetRelatedData(value : TFhirId);
begin
  FRelatedData.free;
  FRelatedData := value;
end;

function TFhirPlanDefinitionActionInput.GetRelatedDataST : String;
begin
  if FRelatedData = nil then
    result := ''
  else
    result := FRelatedData.value;
end;

procedure TFhirPlanDefinitionActionInput.SetRelatedDataST(value : String);
begin
  if value <> '' then
  begin
    if FRelatedData = nil then
      FRelatedData := TFhirId.create;
    FRelatedData.value := value
  end
  else if FRelatedData <> nil then
    FRelatedData.value := '';
end;

{ TFhirPlanDefinitionActionInputListEnumerator }

constructor TFhirPlanDefinitionActionInputListEnumerator.Create(list : TFhirPlanDefinitionActionInputList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionActionInputListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionActionInputListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionActionInputListEnumerator.GetCurrent : TFhirPlanDefinitionActionInput;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionActionInputListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPlanDefinitionActionInputList }

function TFhirPlanDefinitionActionInputList.AddItem(value: TFhirPlanDefinitionActionInput): TFhirPlanDefinitionActionInput;
begin
  assert(value.ClassName = 'TFhirPlanDefinitionActionInput', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinitionActionInput');
  add(value);
  result := value;
end;

function TFhirPlanDefinitionActionInputList.Append: TFhirPlanDefinitionActionInput;
begin
  result := TFhirPlanDefinitionActionInput.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionInputList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionActionInputList.GetEnumerator : TFhirPlanDefinitionActionInputListEnumerator;
begin
  result := TFhirPlanDefinitionActionInputListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionActionInputList.Clone: TFhirPlanDefinitionActionInputList;
begin
  result := TFhirPlanDefinitionActionInputList(inherited Clone);
end;

function TFhirPlanDefinitionActionInputList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionActionInputList.GetItemN(index: Integer): TFhirPlanDefinitionActionInput;
begin
  result := TFhirPlanDefinitionActionInput(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionInputList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinitionActionInput;
end;
function TFhirPlanDefinitionActionInputList.IndexOf(value: TFhirPlanDefinitionActionInput): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionActionInputList.Insert(index: Integer): TFhirPlanDefinitionActionInput;
begin
  result := TFhirPlanDefinitionActionInput.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionInputList.InsertItem(index: Integer; value: TFhirPlanDefinitionActionInput);
begin
  assert(value is TFhirPlanDefinitionActionInput);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionActionInputList.Item(index: Integer): TFhirPlanDefinitionActionInput;
begin
  result := TFhirPlanDefinitionActionInput(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionInputList.Link: TFhirPlanDefinitionActionInputList;
begin
  result := TFhirPlanDefinitionActionInputList(inherited Link);
end;

procedure TFhirPlanDefinitionActionInputList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionActionInputList.SetItemByIndex(index: Integer; value: TFhirPlanDefinitionActionInput);
begin
  assert(value is TFhirPlanDefinitionActionInput);
  FhirPlanDefinitionActionInputs[index] := value;
end;

procedure TFhirPlanDefinitionActionInputList.SetItemN(index: Integer; value: TFhirPlanDefinitionActionInput);
begin
  assert(value is TFhirPlanDefinitionActionInput);
  ObjectByIndex[index] := value;
end;

{ TFhirPlanDefinitionActionOutput }

constructor TFhirPlanDefinitionActionOutput.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinitionActionOutput.Destroy;
begin
  FTitle.free;
  FRequirement.free;
  FRelatedData.free;
  inherited;
end;

procedure TFhirPlanDefinitionActionOutput.Assign(oSource : TFslObject);
begin
  inherited;
  titleElement := TFhirPlanDefinitionActionOutput(oSource).titleElement.Clone;
  requirement := TFhirPlanDefinitionActionOutput(oSource).requirement.Clone;
  relatedDataElement := TFhirPlanDefinitionActionOutput(oSource).relatedDataElement.Clone;
end;

procedure TFhirPlanDefinitionActionOutput.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'requirement') Then
     list.add(self.link, 'requirement', FRequirement.Link);
  if (child_name = 'relatedData') Then
     list.add(self.link, 'relatedData', FRelatedData.Link);
end;

procedure TFhirPlanDefinitionActionOutput.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'requirement', 'DataRequirement', false, TFhirDataRequirement, FRequirement.Link));
  oList.add(TFHIRProperty.create(self, 'relatedData', 'string', false, TFhirString, FRelatedData.Link));
end;

function TFhirPlanDefinitionActionOutput.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'requirement') then
  begin
    Requirement := propValue as TFhirDataRequirement;
    result := propValue;
  end
  else if (propName = 'relatedData') then
  begin
    RelatedDataElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinitionActionOutput.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPlanDefinitionActionOutput.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'requirement') then result := TFhirDataRequirement.create()
  else if (propName = 'relatedData') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinitionActionOutput.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'title') then result := 'string'
  else if (propName = 'requirement') then result := 'DataRequirement'
  else if (propName = 'relatedData') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinitionActionOutput.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := nil
  else if (propName = 'requirement') then RequirementElement := nil
  else if (propName = 'relatedData') then RelatedDataElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinitionActionOutput.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'requirement') then RequirementElement := new as TFhirDataRequirement
  else if (propName = 'relatedData') then RelatedDataElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinitionActionOutput.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinitionActionOutput.fhirType : string;
begin
  result := 'PlanDefinition.action.output';
end;

function TFhirPlanDefinitionActionOutput.Link : TFhirPlanDefinitionActionOutput;
begin
  result := TFhirPlanDefinitionActionOutput(inherited Link);
end;

function TFhirPlanDefinitionActionOutput.Clone : TFhirPlanDefinitionActionOutput;
begin
  result := TFhirPlanDefinitionActionOutput(inherited Clone);
end;

function TFhirPlanDefinitionActionOutput.equals(other : TObject) : boolean; 
var
  o : TFhirPlanDefinitionActionOutput;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinitionActionOutput)) then
    result := false
  else
  begin
    o := TFhirPlanDefinitionActionOutput(other);
    result := compareDeep(titleElement, o.titleElement, true) and compareDeep(requirementElement, o.requirementElement, true) and 
      compareDeep(relatedDataElement, o.relatedDataElement, true);
  end;
end;

function TFhirPlanDefinitionActionOutput.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTitle) and isEmptyProp(FRequirement) and isEmptyProp(FRelatedData);
end;

procedure TFhirPlanDefinitionActionOutput.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('title');
  fields.add('requirement');
  fields.add('relatedData');
end;

function TFhirPlanDefinitionActionOutput.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPlanDefinitionActionOutput.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirPlanDefinitionActionOutput.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirPlanDefinitionActionOutput.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirPlanDefinitionActionOutput.SetRequirement(value : TFhirDataRequirement);
begin
  FRequirement.free;
  FRequirement := value;
end;

procedure TFhirPlanDefinitionActionOutput.SetRelatedData(value : TFhirString);
begin
  FRelatedData.free;
  FRelatedData := value;
end;

function TFhirPlanDefinitionActionOutput.GetRelatedDataST : String;
begin
  if FRelatedData = nil then
    result := ''
  else
    result := FRelatedData.value;
end;

procedure TFhirPlanDefinitionActionOutput.SetRelatedDataST(value : String);
begin
  if value <> '' then
  begin
    if FRelatedData = nil then
      FRelatedData := TFhirString.create;
    FRelatedData.value := value
  end
  else if FRelatedData <> nil then
    FRelatedData.value := '';
end;

{ TFhirPlanDefinitionActionOutputListEnumerator }

constructor TFhirPlanDefinitionActionOutputListEnumerator.Create(list : TFhirPlanDefinitionActionOutputList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionActionOutputListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionActionOutputListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionActionOutputListEnumerator.GetCurrent : TFhirPlanDefinitionActionOutput;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionActionOutputListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPlanDefinitionActionOutputList }

function TFhirPlanDefinitionActionOutputList.AddItem(value: TFhirPlanDefinitionActionOutput): TFhirPlanDefinitionActionOutput;
begin
  assert(value.ClassName = 'TFhirPlanDefinitionActionOutput', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinitionActionOutput');
  add(value);
  result := value;
end;

function TFhirPlanDefinitionActionOutputList.Append: TFhirPlanDefinitionActionOutput;
begin
  result := TFhirPlanDefinitionActionOutput.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionOutputList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionActionOutputList.GetEnumerator : TFhirPlanDefinitionActionOutputListEnumerator;
begin
  result := TFhirPlanDefinitionActionOutputListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionActionOutputList.Clone: TFhirPlanDefinitionActionOutputList;
begin
  result := TFhirPlanDefinitionActionOutputList(inherited Clone);
end;

function TFhirPlanDefinitionActionOutputList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionActionOutputList.GetItemN(index: Integer): TFhirPlanDefinitionActionOutput;
begin
  result := TFhirPlanDefinitionActionOutput(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionOutputList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinitionActionOutput;
end;
function TFhirPlanDefinitionActionOutputList.IndexOf(value: TFhirPlanDefinitionActionOutput): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionActionOutputList.Insert(index: Integer): TFhirPlanDefinitionActionOutput;
begin
  result := TFhirPlanDefinitionActionOutput.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionOutputList.InsertItem(index: Integer; value: TFhirPlanDefinitionActionOutput);
begin
  assert(value is TFhirPlanDefinitionActionOutput);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionActionOutputList.Item(index: Integer): TFhirPlanDefinitionActionOutput;
begin
  result := TFhirPlanDefinitionActionOutput(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionOutputList.Link: TFhirPlanDefinitionActionOutputList;
begin
  result := TFhirPlanDefinitionActionOutputList(inherited Link);
end;

procedure TFhirPlanDefinitionActionOutputList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionActionOutputList.SetItemByIndex(index: Integer; value: TFhirPlanDefinitionActionOutput);
begin
  assert(value is TFhirPlanDefinitionActionOutput);
  FhirPlanDefinitionActionOutputs[index] := value;
end;

procedure TFhirPlanDefinitionActionOutputList.SetItemN(index: Integer; value: TFhirPlanDefinitionActionOutput);
begin
  assert(value is TFhirPlanDefinitionActionOutput);
  ObjectByIndex[index] := value;
end;

{ TFhirPlanDefinitionActionRelatedAction }

constructor TFhirPlanDefinitionActionRelatedAction.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinitionActionRelatedAction.Destroy;
begin
  FTargetId.free;
  FRelationship.free;
  FOffset.free;
  inherited;
end;

procedure TFhirPlanDefinitionActionRelatedAction.Assign(oSource : TFslObject);
begin
  inherited;
  targetIdElement := TFhirPlanDefinitionActionRelatedAction(oSource).targetIdElement.Clone;
  relationshipElement := TFhirPlanDefinitionActionRelatedAction(oSource).relationshipElement.Clone;
  offset := TFhirPlanDefinitionActionRelatedAction(oSource).offset.Clone;
end;

procedure TFhirPlanDefinitionActionRelatedAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'targetId') Then
     list.add(self.link, 'targetId', FTargetId.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'offset[x]') or (child_name = 'offset') Then
     list.add(self.link, 'offset[x]', FOffset.Link);
end;

procedure TFhirPlanDefinitionActionRelatedAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'targetId', 'id', false, TFhirId, FTargetId.Link));
  oList.add(TFHIRProperty.create(self, 'relationship', 'code', false, TFhirEnum, FRelationship.Link));
  oList.add(TFHIRProperty.create(self, 'offset[x]', 'Duration|Range', false, TFhirDataType, FOffset.Link));
end;

function TFhirPlanDefinitionActionRelatedAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'targetId') then
  begin
    TargetIdElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    RelationshipElement := asEnum(SYSTEMS_TFhirActionRelationshipTypeEnum, CODES_TFhirActionRelationshipTypeEnum, propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then
  begin
    Offset := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinitionActionRelatedAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPlanDefinitionActionRelatedAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'targetId') then result := TFhirId.create()
  else if (propName = 'relationship') then result := TFhirEnum.create(SYSTEMS_TFhirActionRelationshipTypeEnum[ActionRelationshipTypeNull], CODES_TFhirActionRelationshipTypeEnum[ActionRelationshipTypeNull]) 
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then raise EFHIRException.create('Cannot make property Offset')
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinitionActionRelatedAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'targetId') then result := 'id'
  else if (propName = 'relationship') then result := 'code'
  else if (propName = 'offset[x]') then result := 'Duration|Range'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinitionActionRelatedAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'targetId') then TargetIdElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then OffsetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinitionActionRelatedAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'targetId') then TargetIdElement := asId(new)
  else if (propName = 'relationship') then RelationshipElement := asEnum(SYSTEMS_TFhirActionRelationshipTypeEnum, CODES_TFhirActionRelationshipTypeEnum, new)
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then OffsetElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinitionActionRelatedAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinitionActionRelatedAction.fhirType : string;
begin
  result := 'PlanDefinition.action.relatedAction';
end;

function TFhirPlanDefinitionActionRelatedAction.Link : TFhirPlanDefinitionActionRelatedAction;
begin
  result := TFhirPlanDefinitionActionRelatedAction(inherited Link);
end;

function TFhirPlanDefinitionActionRelatedAction.Clone : TFhirPlanDefinitionActionRelatedAction;
begin
  result := TFhirPlanDefinitionActionRelatedAction(inherited Clone);
end;

function TFhirPlanDefinitionActionRelatedAction.equals(other : TObject) : boolean; 
var
  o : TFhirPlanDefinitionActionRelatedAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinitionActionRelatedAction)) then
    result := false
  else
  begin
    o := TFhirPlanDefinitionActionRelatedAction(other);
    result := compareDeep(targetIdElement, o.targetIdElement, true) and compareDeep(relationshipElement, o.relationshipElement, true) and 
      compareDeep(offsetElement, o.offsetElement, true);
  end;
end;

function TFhirPlanDefinitionActionRelatedAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTargetId) and isEmptyProp(FRelationship) and isEmptyProp(FOffset);
end;

procedure TFhirPlanDefinitionActionRelatedAction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('targetId');
  fields.add('relationship');
  fields.add('offset[x]');
end;

function TFhirPlanDefinitionActionRelatedAction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPlanDefinitionActionRelatedAction.SetTargetId(value : TFhirId);
begin
  FTargetId.free;
  FTargetId := value;
end;

function TFhirPlanDefinitionActionRelatedAction.GetTargetIdST : String;
begin
  if FTargetId = nil then
    result := ''
  else
    result := FTargetId.value;
end;

procedure TFhirPlanDefinitionActionRelatedAction.SetTargetIdST(value : String);
begin
  if value <> '' then
  begin
    if FTargetId = nil then
      FTargetId := TFhirId.create;
    FTargetId.value := value
  end
  else if FTargetId <> nil then
    FTargetId.value := '';
end;

procedure TFhirPlanDefinitionActionRelatedAction.SetRelationship(value : TFhirEnum);
begin
  FRelationship.free;
  FRelationship := value;
end;

function TFhirPlanDefinitionActionRelatedAction.GetRelationshipST : TFhirActionRelationshipTypeEnum;
begin
  if FRelationship = nil then
    result := TFhirActionRelationshipTypeEnum(0)
  else
    result := TFhirActionRelationshipTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirActionRelationshipTypeEnum, FRelationship.value));
end;

procedure TFhirPlanDefinitionActionRelatedAction.SetRelationshipST(value : TFhirActionRelationshipTypeEnum);
begin
  if ord(value) = 0 then
    RelationshipElement := nil
  else
    RelationshipElement := TFhirEnum.create(SYSTEMS_TFhirActionRelationshipTypeEnum[value], CODES_TFhirActionRelationshipTypeEnum[value]);
end;

procedure TFhirPlanDefinitionActionRelatedAction.SetOffset(value : TFhirDataType);
begin
  FOffset.free;
  FOffset := value;
end;

{ TFhirPlanDefinitionActionRelatedActionListEnumerator }

constructor TFhirPlanDefinitionActionRelatedActionListEnumerator.Create(list : TFhirPlanDefinitionActionRelatedActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionActionRelatedActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionActionRelatedActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionActionRelatedActionListEnumerator.GetCurrent : TFhirPlanDefinitionActionRelatedAction;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionActionRelatedActionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPlanDefinitionActionRelatedActionList }

function TFhirPlanDefinitionActionRelatedActionList.AddItem(value: TFhirPlanDefinitionActionRelatedAction): TFhirPlanDefinitionActionRelatedAction;
begin
  assert(value.ClassName = 'TFhirPlanDefinitionActionRelatedAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinitionActionRelatedAction');
  add(value);
  result := value;
end;

function TFhirPlanDefinitionActionRelatedActionList.Append: TFhirPlanDefinitionActionRelatedAction;
begin
  result := TFhirPlanDefinitionActionRelatedAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionRelatedActionList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionActionRelatedActionList.GetEnumerator : TFhirPlanDefinitionActionRelatedActionListEnumerator;
begin
  result := TFhirPlanDefinitionActionRelatedActionListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionActionRelatedActionList.Clone: TFhirPlanDefinitionActionRelatedActionList;
begin
  result := TFhirPlanDefinitionActionRelatedActionList(inherited Clone);
end;

function TFhirPlanDefinitionActionRelatedActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionActionRelatedActionList.GetItemN(index: Integer): TFhirPlanDefinitionActionRelatedAction;
begin
  result := TFhirPlanDefinitionActionRelatedAction(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionRelatedActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinitionActionRelatedAction;
end;
function TFhirPlanDefinitionActionRelatedActionList.IndexOf(value: TFhirPlanDefinitionActionRelatedAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionActionRelatedActionList.Insert(index: Integer): TFhirPlanDefinitionActionRelatedAction;
begin
  result := TFhirPlanDefinitionActionRelatedAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionRelatedActionList.InsertItem(index: Integer; value: TFhirPlanDefinitionActionRelatedAction);
begin
  assert(value is TFhirPlanDefinitionActionRelatedAction);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionActionRelatedActionList.Item(index: Integer): TFhirPlanDefinitionActionRelatedAction;
begin
  result := TFhirPlanDefinitionActionRelatedAction(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionRelatedActionList.Link: TFhirPlanDefinitionActionRelatedActionList;
begin
  result := TFhirPlanDefinitionActionRelatedActionList(inherited Link);
end;

procedure TFhirPlanDefinitionActionRelatedActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionActionRelatedActionList.SetItemByIndex(index: Integer; value: TFhirPlanDefinitionActionRelatedAction);
begin
  assert(value is TFhirPlanDefinitionActionRelatedAction);
  FhirPlanDefinitionActionRelatedActions[index] := value;
end;

procedure TFhirPlanDefinitionActionRelatedActionList.SetItemN(index: Integer; value: TFhirPlanDefinitionActionRelatedAction);
begin
  assert(value is TFhirPlanDefinitionActionRelatedAction);
  ObjectByIndex[index] := value;
end;

{ TFhirPlanDefinitionActionParticipant }

constructor TFhirPlanDefinitionActionParticipant.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinitionActionParticipant.Destroy;
begin
  FActorId.free;
  FType_.free;
  FTypeCanonical.free;
  FTypeReference.free;
  FRole.free;
  FFunction_.free;
  inherited;
end;

procedure TFhirPlanDefinitionActionParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  actorIdElement := TFhirPlanDefinitionActionParticipant(oSource).actorIdElement.Clone;
  type_Element := TFhirPlanDefinitionActionParticipant(oSource).type_Element.Clone;
  typeCanonicalElement := TFhirPlanDefinitionActionParticipant(oSource).typeCanonicalElement.Clone;
  typeReference := TFhirPlanDefinitionActionParticipant(oSource).typeReference.Clone;
  role := TFhirPlanDefinitionActionParticipant(oSource).role.Clone;
  function_ := TFhirPlanDefinitionActionParticipant(oSource).function_.Clone;
end;

procedure TFhirPlanDefinitionActionParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'actorId') Then
     list.add(self.link, 'actorId', FActorId.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'typeCanonical') Then
     list.add(self.link, 'typeCanonical', FTypeCanonical.Link);
  if (child_name = 'typeReference') Then
     list.add(self.link, 'typeReference', FTypeReference.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'function') Then
     list.add(self.link, 'function', FFunction_.Link);
end;

procedure TFhirPlanDefinitionActionParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'actorId', 'string', false, TFhirString, FActorId.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'typeCanonical', 'canonical', false, TFhirCanonical, FTypeCanonical.Link));
  oList.add(TFHIRProperty.create(self, 'typeReference', 'Reference', false, TFhirReference, FTypeReference.Link));
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));
  oList.add(TFHIRProperty.create(self, 'function', 'CodeableConcept', false, TFhirCodeableConcept, FFunction_.Link));
end;

function TFhirPlanDefinitionActionParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'actorId') then
  begin
    ActorIdElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirActionParticipantTypeEnum, CODES_TFhirActionParticipantTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'typeCanonical') then
  begin
    TypeCanonicalElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'typeReference') then
  begin
    TypeReference := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'function') then
  begin
    Function_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinitionActionParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPlanDefinitionActionParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'actorId') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirActionParticipantTypeEnum[ActionParticipantTypeNull], CODES_TFhirActionParticipantTypeEnum[ActionParticipantTypeNull]) 
  else if (propName = 'typeCanonical') then result := TFhirCanonical.create()
  else if (propName = 'typeReference') then result := TFhirReference.create()
  else if (propName = 'role') then result := TFhirCodeableConcept.create()
  else if (propName = 'function') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinitionActionParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'actorId') then result := 'string'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'typeCanonical') then result := 'canonical'
  else if (propName = 'typeReference') then result := 'Reference'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'function') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinitionActionParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'actorId') then ActorIdElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'typeCanonical') then TypeCanonicalElement := nil
  else if (propName = 'typeReference') then TypeReferenceElement := nil
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'function') then Function_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinitionActionParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'actorId') then ActorIdElement := asString(new)
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirActionParticipantTypeEnum, CODES_TFhirActionParticipantTypeEnum, new)
  else if (propName = 'typeCanonical') then TypeCanonicalElement := asCanonical(new)
  else if (propName = 'typeReference') then TypeReferenceElement := new as TFhirReference
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept
  else if (propName = 'function') then Function_Element := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinitionActionParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinitionActionParticipant.fhirType : string;
begin
  result := 'PlanDefinition.action.participant';
end;

function TFhirPlanDefinitionActionParticipant.Link : TFhirPlanDefinitionActionParticipant;
begin
  result := TFhirPlanDefinitionActionParticipant(inherited Link);
end;

function TFhirPlanDefinitionActionParticipant.Clone : TFhirPlanDefinitionActionParticipant;
begin
  result := TFhirPlanDefinitionActionParticipant(inherited Clone);
end;

function TFhirPlanDefinitionActionParticipant.equals(other : TObject) : boolean; 
var
  o : TFhirPlanDefinitionActionParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinitionActionParticipant)) then
    result := false
  else
  begin
    o := TFhirPlanDefinitionActionParticipant(other);
    result := compareDeep(actorIdElement, o.actorIdElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(typeCanonicalElement, o.typeCanonicalElement, true) and compareDeep(typeReferenceElement, o.typeReferenceElement, true) and 
      compareDeep(roleElement, o.roleElement, true) and compareDeep(function_Element, o.function_Element, true);
  end;
end;

function TFhirPlanDefinitionActionParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FActorId) and isEmptyProp(FType_) and isEmptyProp(FTypeCanonical) and isEmptyProp(FTypeReference) and isEmptyProp(FRole) and isEmptyProp(FFunction_);
end;

procedure TFhirPlanDefinitionActionParticipant.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('actorId');
  fields.add('type');
  fields.add('typeCanonical');
  fields.add('typeReference');
  fields.add('role');
  fields.add('function');
end;

function TFhirPlanDefinitionActionParticipant.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPlanDefinitionActionParticipant.SetActorId(value : TFhirString);
begin
  FActorId.free;
  FActorId := value;
end;

function TFhirPlanDefinitionActionParticipant.GetActorIdST : String;
begin
  if FActorId = nil then
    result := ''
  else
    result := FActorId.value;
end;

procedure TFhirPlanDefinitionActionParticipant.SetActorIdST(value : String);
begin
  if value <> '' then
  begin
    if FActorId = nil then
      FActorId := TFhirString.create;
    FActorId.value := value
  end
  else if FActorId <> nil then
    FActorId.value := '';
end;

procedure TFhirPlanDefinitionActionParticipant.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirPlanDefinitionActionParticipant.GetType_ST : TFhirActionParticipantTypeEnum;
begin
  if FType_ = nil then
    result := TFhirActionParticipantTypeEnum(0)
  else
    result := TFhirActionParticipantTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirActionParticipantTypeEnum, FType_.value));
end;

procedure TFhirPlanDefinitionActionParticipant.SetType_ST(value : TFhirActionParticipantTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirActionParticipantTypeEnum[value], CODES_TFhirActionParticipantTypeEnum[value]);
end;

procedure TFhirPlanDefinitionActionParticipant.SetTypeCanonical(value : TFhirCanonical);
begin
  FTypeCanonical.free;
  FTypeCanonical := value;
end;

function TFhirPlanDefinitionActionParticipant.GetTypeCanonicalST : String;
begin
  if FTypeCanonical = nil then
    result := ''
  else
    result := FTypeCanonical.value;
end;

procedure TFhirPlanDefinitionActionParticipant.SetTypeCanonicalST(value : String);
begin
  if value <> '' then
  begin
    if FTypeCanonical = nil then
      FTypeCanonical := TFhirCanonical.create;
    FTypeCanonical.value := value
  end
  else if FTypeCanonical <> nil then
    FTypeCanonical.value := '';
end;

procedure TFhirPlanDefinitionActionParticipant.SetTypeReference(value : TFhirReference);
begin
  FTypeReference.free;
  FTypeReference := value;
end;

procedure TFhirPlanDefinitionActionParticipant.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

procedure TFhirPlanDefinitionActionParticipant.SetFunction_(value : TFhirCodeableConcept);
begin
  FFunction_.free;
  FFunction_ := value;
end;

{ TFhirPlanDefinitionActionParticipantListEnumerator }

constructor TFhirPlanDefinitionActionParticipantListEnumerator.Create(list : TFhirPlanDefinitionActionParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionActionParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionActionParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionActionParticipantListEnumerator.GetCurrent : TFhirPlanDefinitionActionParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionActionParticipantListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPlanDefinitionActionParticipantList }

function TFhirPlanDefinitionActionParticipantList.AddItem(value: TFhirPlanDefinitionActionParticipant): TFhirPlanDefinitionActionParticipant;
begin
  assert(value.ClassName = 'TFhirPlanDefinitionActionParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinitionActionParticipant');
  add(value);
  result := value;
end;

function TFhirPlanDefinitionActionParticipantList.Append: TFhirPlanDefinitionActionParticipant;
begin
  result := TFhirPlanDefinitionActionParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionActionParticipantList.GetEnumerator : TFhirPlanDefinitionActionParticipantListEnumerator;
begin
  result := TFhirPlanDefinitionActionParticipantListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionActionParticipantList.Clone: TFhirPlanDefinitionActionParticipantList;
begin
  result := TFhirPlanDefinitionActionParticipantList(inherited Clone);
end;

function TFhirPlanDefinitionActionParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionActionParticipantList.GetItemN(index: Integer): TFhirPlanDefinitionActionParticipant;
begin
  result := TFhirPlanDefinitionActionParticipant(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinitionActionParticipant;
end;
function TFhirPlanDefinitionActionParticipantList.IndexOf(value: TFhirPlanDefinitionActionParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionActionParticipantList.Insert(index: Integer): TFhirPlanDefinitionActionParticipant;
begin
  result := TFhirPlanDefinitionActionParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionParticipantList.InsertItem(index: Integer; value: TFhirPlanDefinitionActionParticipant);
begin
  assert(value is TFhirPlanDefinitionActionParticipant);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionActionParticipantList.Item(index: Integer): TFhirPlanDefinitionActionParticipant;
begin
  result := TFhirPlanDefinitionActionParticipant(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionParticipantList.Link: TFhirPlanDefinitionActionParticipantList;
begin
  result := TFhirPlanDefinitionActionParticipantList(inherited Link);
end;

procedure TFhirPlanDefinitionActionParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionActionParticipantList.SetItemByIndex(index: Integer; value: TFhirPlanDefinitionActionParticipant);
begin
  assert(value is TFhirPlanDefinitionActionParticipant);
  FhirPlanDefinitionActionParticipants[index] := value;
end;

procedure TFhirPlanDefinitionActionParticipantList.SetItemN(index: Integer; value: TFhirPlanDefinitionActionParticipant);
begin
  assert(value is TFhirPlanDefinitionActionParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirPlanDefinitionActionDynamicValue }

constructor TFhirPlanDefinitionActionDynamicValue.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinitionActionDynamicValue.Destroy;
begin
  FPath.free;
  FExpression.free;
  inherited;
end;

procedure TFhirPlanDefinitionActionDynamicValue.Assign(oSource : TFslObject);
begin
  inherited;
  pathElement := TFhirPlanDefinitionActionDynamicValue(oSource).pathElement.Clone;
  expression := TFhirPlanDefinitionActionDynamicValue(oSource).expression.Clone;
end;

procedure TFhirPlanDefinitionActionDynamicValue.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'path') Then
     list.add(self.link, 'path', FPath.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
end;

procedure TFhirPlanDefinitionActionDynamicValue.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'path', 'string', false, TFhirString, FPath.Link));
  oList.add(TFHIRProperty.create(self, 'expression', 'Expression', false, TFhirExpression, FExpression.Link));
end;

function TFhirPlanDefinitionActionDynamicValue.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'path') then
  begin
    PathElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    Expression := propValue as TFhirExpression;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinitionActionDynamicValue.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPlanDefinitionActionDynamicValue.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'path') then result := TFhirString.create()
  else if (propName = 'expression') then result := TFhirExpression.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinitionActionDynamicValue.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'path') then result := 'string'
  else if (propName = 'expression') then result := 'Expression'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinitionActionDynamicValue.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'path') then PathElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinitionActionDynamicValue.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'path') then PathElement := asString(new)
  else if (propName = 'expression') then ExpressionElement := new as TFhirExpression
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinitionActionDynamicValue.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinitionActionDynamicValue.fhirType : string;
begin
  result := 'PlanDefinition.action.dynamicValue';
end;

function TFhirPlanDefinitionActionDynamicValue.Link : TFhirPlanDefinitionActionDynamicValue;
begin
  result := TFhirPlanDefinitionActionDynamicValue(inherited Link);
end;

function TFhirPlanDefinitionActionDynamicValue.Clone : TFhirPlanDefinitionActionDynamicValue;
begin
  result := TFhirPlanDefinitionActionDynamicValue(inherited Clone);
end;

function TFhirPlanDefinitionActionDynamicValue.equals(other : TObject) : boolean; 
var
  o : TFhirPlanDefinitionActionDynamicValue;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinitionActionDynamicValue)) then
    result := false
  else
  begin
    o := TFhirPlanDefinitionActionDynamicValue(other);
    result := compareDeep(pathElement, o.pathElement, true) and compareDeep(expressionElement, o.expressionElement, true);
  end;
end;

function TFhirPlanDefinitionActionDynamicValue.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPath) and isEmptyProp(FExpression);
end;

procedure TFhirPlanDefinitionActionDynamicValue.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('path');
  fields.add('expression');
end;

function TFhirPlanDefinitionActionDynamicValue.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPlanDefinitionActionDynamicValue.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

function TFhirPlanDefinitionActionDynamicValue.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := FPath.value;
end;

procedure TFhirPlanDefinitionActionDynamicValue.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

procedure TFhirPlanDefinitionActionDynamicValue.SetExpression(value : TFhirExpression);
begin
  FExpression.free;
  FExpression := value;
end;

{ TFhirPlanDefinitionActionDynamicValueListEnumerator }

constructor TFhirPlanDefinitionActionDynamicValueListEnumerator.Create(list : TFhirPlanDefinitionActionDynamicValueList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionActionDynamicValueListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionActionDynamicValueListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionActionDynamicValueListEnumerator.GetCurrent : TFhirPlanDefinitionActionDynamicValue;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionActionDynamicValueListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPlanDefinitionActionDynamicValueList }

function TFhirPlanDefinitionActionDynamicValueList.AddItem(value: TFhirPlanDefinitionActionDynamicValue): TFhirPlanDefinitionActionDynamicValue;
begin
  assert(value.ClassName = 'TFhirPlanDefinitionActionDynamicValue', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinitionActionDynamicValue');
  add(value);
  result := value;
end;

function TFhirPlanDefinitionActionDynamicValueList.Append: TFhirPlanDefinitionActionDynamicValue;
begin
  result := TFhirPlanDefinitionActionDynamicValue.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionDynamicValueList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionActionDynamicValueList.GetEnumerator : TFhirPlanDefinitionActionDynamicValueListEnumerator;
begin
  result := TFhirPlanDefinitionActionDynamicValueListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionActionDynamicValueList.Clone: TFhirPlanDefinitionActionDynamicValueList;
begin
  result := TFhirPlanDefinitionActionDynamicValueList(inherited Clone);
end;

function TFhirPlanDefinitionActionDynamicValueList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionActionDynamicValueList.GetItemN(index: Integer): TFhirPlanDefinitionActionDynamicValue;
begin
  result := TFhirPlanDefinitionActionDynamicValue(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionDynamicValueList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinitionActionDynamicValue;
end;
function TFhirPlanDefinitionActionDynamicValueList.IndexOf(value: TFhirPlanDefinitionActionDynamicValue): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionActionDynamicValueList.Insert(index: Integer): TFhirPlanDefinitionActionDynamicValue;
begin
  result := TFhirPlanDefinitionActionDynamicValue.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionDynamicValueList.InsertItem(index: Integer; value: TFhirPlanDefinitionActionDynamicValue);
begin
  assert(value is TFhirPlanDefinitionActionDynamicValue);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionActionDynamicValueList.Item(index: Integer): TFhirPlanDefinitionActionDynamicValue;
begin
  result := TFhirPlanDefinitionActionDynamicValue(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionDynamicValueList.Link: TFhirPlanDefinitionActionDynamicValueList;
begin
  result := TFhirPlanDefinitionActionDynamicValueList(inherited Link);
end;

procedure TFhirPlanDefinitionActionDynamicValueList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionActionDynamicValueList.SetItemByIndex(index: Integer; value: TFhirPlanDefinitionActionDynamicValue);
begin
  assert(value is TFhirPlanDefinitionActionDynamicValue);
  FhirPlanDefinitionActionDynamicValues[index] := value;
end;

procedure TFhirPlanDefinitionActionDynamicValueList.SetItemN(index: Integer; value: TFhirPlanDefinitionActionDynamicValue);
begin
  assert(value is TFhirPlanDefinitionActionDynamicValue);
  ObjectByIndex[index] := value;
end;

{ TFhirPlanDefinition }

constructor TFhirPlanDefinition.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinition.Destroy;
begin
  FSubtitle.free;
  FType_.free;
  FSubject.free;
  FUsage.free;
  FLibrary_List.Free;
  FGoalList.Free;
  FActorList.Free;
  FActionList.Free;
  FAsNeeded.free;
  inherited;
end;

procedure TFhirPlanDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  subtitleElement := TFhirPlanDefinition(oSource).subtitleElement.Clone;
  type_ := TFhirPlanDefinition(oSource).type_.Clone;
  subject := TFhirPlanDefinition(oSource).subject.Clone;
  usageElement := TFhirPlanDefinition(oSource).usageElement.Clone;
  if (TFhirPlanDefinition(oSource).FLibrary_List = nil) then
  begin
    FLibrary_List.free;
    FLibrary_List := nil;
  end
  else
  begin
    if FLibrary_List = nil then
      FLibrary_List := TFhirCanonicalList.Create;
    FLibrary_List.Assign(TFhirPlanDefinition(oSource).FLibrary_List);
  end;
  if (TFhirPlanDefinition(oSource).FGoalList = nil) then
  begin
    FGoalList.free;
    FGoalList := nil;
  end
  else
  begin
    if FGoalList = nil then
      FGoalList := TFhirPlanDefinitionGoalList.Create;
    FGoalList.Assign(TFhirPlanDefinition(oSource).FGoalList);
  end;
  if (TFhirPlanDefinition(oSource).FActorList = nil) then
  begin
    FActorList.free;
    FActorList := nil;
  end
  else
  begin
    if FActorList = nil then
      FActorList := TFhirPlanDefinitionActorList.Create;
    FActorList.Assign(TFhirPlanDefinition(oSource).FActorList);
  end;
  if (TFhirPlanDefinition(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirPlanDefinitionActionList.Create;
    FActionList.Assign(TFhirPlanDefinition(oSource).FActionList);
  end;
  asNeeded := TFhirPlanDefinition(oSource).asNeeded.Clone;
end;

function TFhirPlanDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtPlanDefinition;
end;

procedure TFhirPlanDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'subtitle') Then
     list.add(self.link, 'subtitle', FSubtitle.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subject[x]') or (child_name = 'subject') Then
     list.add(self.link, 'subject[x]', FSubject.Link);
  if (child_name = 'usage') Then
     list.add(self.link, 'usage', FUsage.Link);
  if (child_name = 'library') Then
    list.addAll(self, 'library', FLibrary_List);
  if (child_name = 'goal') Then
    list.addAll(self, 'goal', FGoalList);
  if (child_name = 'actor') Then
    list.addAll(self, 'actor', FActorList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
  if (child_name = 'asNeeded[x]') or (child_name = 'asNeeded') Then
     list.add(self.link, 'asNeeded[x]', FAsNeeded.Link);
end;

procedure TFhirPlanDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'subtitle', 'string', false, TFhirString, FSubtitle.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'subject[x]', 'CodeableConcept|Reference|canonical', false, TFhirDataType, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'usage', 'string', false, TFhirString, FUsage.Link));
  oList.add(TFHIRProperty.create(self, 'library', 'canonical', true, TFhirCanonical, FLibrary_List.Link));
  oList.add(TFHIRProperty.create(self, 'goal', 'BackboneElement', true, TFhirPlanDefinitionGoal, FGoalList.Link));
  oList.add(TFHIRProperty.create(self, 'actor', 'BackboneElement', true, TFhirPlanDefinitionActor, FActorList.Link));
  oList.add(TFHIRProperty.create(self, 'action', 'BackboneElement', true, TFhirPlanDefinitionAction, FActionList.Link));
  oList.add(TFHIRProperty.create(self, 'asNeeded[x]', 'boolean|CodeableConcept', false, TFhirDataType, FAsNeeded.Link));
end;

function TFhirPlanDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'subtitle') then
  begin
    SubtitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference', 'Canonical'])) then
  begin
    Subject := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'usage') then
  begin
    UsageElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'library') then
  begin
    Library_List.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'goal') then
  begin
    GoalList.add(propValue as TFhirPlanDefinitionGoal);
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    ActorList.add(propValue as TFhirPlanDefinitionActor);
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirPlanDefinitionAction);
    result := propValue;
  end
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then
  begin
    AsNeeded := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'library') then Library_List.insertItem(index, asCanonical(propValue))
  else if (propName = 'goal') then GoalList.insertItem(index, propValue as TFhirPlanDefinitionGoal)
  else if (propName = 'actor') then ActorList.insertItem(index, propValue as TFhirPlanDefinitionActor)
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirPlanDefinitionAction)
  else inherited;
end;

function TFhirPlanDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'subtitle') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference', 'Canonical'])) then raise EFHIRException.create('Cannot make property Subject')
  else if (propName = 'usage') then result := TFhirString.create()
  else if (propName = 'library') then result := Library_List.new()
  else if (propName = 'goal') then result := GoalList.new()
  else if (propName = 'actor') then result := ActorList.new()
  else if (propName = 'action') then result := ActionList.new()
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property AsNeeded')
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'subtitle') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subject[x]') then result := 'CodeableConcept|Reference|canonical'
  else if (propName = 'usage') then result := 'string'
  else if (propName = 'library') then result := 'canonical'
  else if (propName = 'goal') then result := 'BackboneElement'
  else if (propName = 'actor') then result := 'BackboneElement'
  else if (propName = 'action') then result := 'BackboneElement'
  else if (propName = 'asNeeded[x]') then result := 'boolean|CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'subtitle') then SubtitleElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference', 'Canonical'])) then SubjectElement := nil
  else if (propName = 'usage') then UsageElement := nil
  else if (propName = 'library') then deletePropertyValue('library', Library_List, value)
  else if (propName = 'goal') then deletePropertyValue('goal', GoalList, value)
  else if (propName = 'actor') then deletePropertyValue('actor', ActorList, value)
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value)
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then AsNeededElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'subtitle') then SubtitleElement := asString(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference', 'Canonical'])) then SubjectElement := new as TFhirDataType
  else if (propName = 'usage') then UsageElement := asString(new)
  else if (propName = 'library') then replacePropertyValue('library', Library_List, existing, new)
  else if (propName = 'goal') then replacePropertyValue('goal', GoalList, existing, new)
  else if (propName = 'actor') then replacePropertyValue('actor', ActorList, existing, new)
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new)
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then AsNeededElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'library') then Library_List.move(source, destination)
  else if (propName = 'goal') then GoalList.move(source, destination)
  else if (propName = 'actor') then ActorList.move(source, destination)
  else if (propName = 'action') then ActionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinition.fhirType : string;
begin
  result := 'PlanDefinition';
end;

function TFhirPlanDefinition.Link : TFhirPlanDefinition;
begin
  result := TFhirPlanDefinition(inherited Link);
end;

function TFhirPlanDefinition.Clone : TFhirPlanDefinition;
begin
  result := TFhirPlanDefinition(inherited Clone);
end;

function TFhirPlanDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirPlanDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinition)) then
    result := false
  else
  begin
    o := TFhirPlanDefinition(other);
    result := compareDeep(subtitleElement, o.subtitleElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(usageElement, o.usageElement, true) and 
      compareDeep(library_List, o.library_List, true) and compareDeep(goalList, o.goalList, true) and 
      compareDeep(actorList, o.actorList, true) and compareDeep(actionList, o.actionList, true) and 
      compareDeep(asNeededElement, o.asNeededElement, true);
  end;
end;

function TFhirPlanDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubtitle) and isEmptyProp(FType_) and isEmptyProp(FSubject) and isEmptyProp(FUsage) and isEmptyProp(Flibrary_List) and isEmptyProp(FgoalList) and isEmptyProp(FactorList) and isEmptyProp(FactionList) and isEmptyProp(FAsNeeded);
end;

procedure TFhirPlanDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('subtitle');
  fields.add('type');
  fields.add('status');
  fields.add('experimental');
  fields.add('subject[x]');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('usage');
  fields.add('copyright');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('topic');
  fields.add('author');
  fields.add('editor');
  fields.add('reviewer');
  fields.add('endorser');
  fields.add('relatedArtifact');
  fields.add('library');
  fields.add('goal');
  fields.add('actor');
  fields.add('action');
  fields.add('asNeeded[x]');
end;

function TFhirPlanDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FLibrary_List.sizeInBytes(magic));
  inc(result, FGoalList.sizeInBytes(magic));
  inc(result, FActorList.sizeInBytes(magic));
  inc(result, FActionList.sizeInBytes(magic));
end;

procedure TFhirPlanDefinition.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirPlanDefinition.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirPlanDefinition.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirPlanDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPlanDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirPlanDefinition.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirPlanDefinition.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirPlanDefinition.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirPlanDefinition.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirPlanDefinition.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirPlanDefinition.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirPlanDefinition.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirPlanDefinition.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirPlanDefinition.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirPlanDefinition.SetSubtitle(value : TFhirString);
begin
  FSubtitle.free;
  FSubtitle := value;
end;

function TFhirPlanDefinition.GetSubtitleST : String;
begin
  if FSubtitle = nil then
    result := ''
  else
    result := FSubtitle.value;
end;

procedure TFhirPlanDefinition.SetSubtitleST(value : String);
begin
  if value <> '' then
  begin
    if FSubtitle = nil then
      FSubtitle := TFhirString.create;
    FSubtitle.value := value
  end
  else if FSubtitle <> nil then
    FSubtitle.value := '';
end;

procedure TFhirPlanDefinition.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirPlanDefinition.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirPlanDefinition.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirPlanDefinition.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirPlanDefinition.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirPlanDefinition.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirPlanDefinition.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirPlanDefinition.SetSubject(value : TFhirDataType);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirPlanDefinition.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirPlanDefinition.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirPlanDefinition.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirPlanDefinition.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirPlanDefinition.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirPlanDefinition.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirPlanDefinition.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirPlanDefinition.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirPlanDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirPlanDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirPlanDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirPlanDefinition.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirPlanDefinition.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirPlanDefinition.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirPlanDefinition.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirPlanDefinition.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirPlanDefinition.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirPlanDefinition.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirPlanDefinition.SetUsage(value : TFhirString);
begin
  FUsage.free;
  FUsage := value;
end;

function TFhirPlanDefinition.GetUsageST : String;
begin
  if FUsage = nil then
    result := ''
  else
    result := FUsage.value;
end;

procedure TFhirPlanDefinition.SetUsageST(value : String);
begin
  if value <> '' then
  begin
    if FUsage = nil then
      FUsage := TFhirString.create;
    FUsage.value := value
  end
  else if FUsage <> nil then
    FUsage.value := '';
end;

procedure TFhirPlanDefinition.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirPlanDefinition.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirPlanDefinition.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

procedure TFhirPlanDefinition.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

function TFhirPlanDefinition.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

procedure TFhirPlanDefinition.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

procedure TFhirPlanDefinition.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

function TFhirPlanDefinition.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

procedure TFhirPlanDefinition.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

procedure TFhirPlanDefinition.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

function TFhirPlanDefinition.GetTopicList : TFhirCodeableConceptList;
begin
  if FTopicList = nil then
    FTopicList := TFhirCodeableConceptList.Create;
  result := FTopicList;
end;

function TFhirPlanDefinition.GetHasTopicList : boolean;
begin
  result := (FTopicList <> nil) and (FTopicList.count > 0);
end;

function TFhirPlanDefinition.GetAuthorList : TFhirContactDetailList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirContactDetailList.Create;
  result := FAuthorList;
end;

function TFhirPlanDefinition.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

function TFhirPlanDefinition.GetEditorList : TFhirContactDetailList;
begin
  if FEditorList = nil then
    FEditorList := TFhirContactDetailList.Create;
  result := FEditorList;
end;

function TFhirPlanDefinition.GetHasEditorList : boolean;
begin
  result := (FEditorList <> nil) and (FEditorList.count > 0);
end;

function TFhirPlanDefinition.GetReviewerList : TFhirContactDetailList;
begin
  if FReviewerList = nil then
    FReviewerList := TFhirContactDetailList.Create;
  result := FReviewerList;
end;

function TFhirPlanDefinition.GetHasReviewerList : boolean;
begin
  result := (FReviewerList <> nil) and (FReviewerList.count > 0);
end;

function TFhirPlanDefinition.GetEndorserList : TFhirContactDetailList;
begin
  if FEndorserList = nil then
    FEndorserList := TFhirContactDetailList.Create;
  result := FEndorserList;
end;

function TFhirPlanDefinition.GetHasEndorserList : boolean;
begin
  result := (FEndorserList <> nil) and (FEndorserList.count > 0);
end;

function TFhirPlanDefinition.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

function TFhirPlanDefinition.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

function TFhirPlanDefinition.GetLibrary_List : TFhirCanonicalList;
begin
  if FLibrary_List = nil then
    FLibrary_List := TFhirCanonicalList.Create;
  result := FLibrary_List;
end;

function TFhirPlanDefinition.GetHasLibrary_List : boolean;
begin
  result := (FLibrary_List <> nil) and (FLibrary_List.count > 0);
end;

function TFhirPlanDefinition.GetGoalList : TFhirPlanDefinitionGoalList;
begin
  if FGoalList = nil then
    FGoalList := TFhirPlanDefinitionGoalList.Create;
  result := FGoalList;
end;

function TFhirPlanDefinition.GetHasGoalList : boolean;
begin
  result := (FGoalList <> nil) and (FGoalList.count > 0);
end;

function TFhirPlanDefinition.GetActorList : TFhirPlanDefinitionActorList;
begin
  if FActorList = nil then
    FActorList := TFhirPlanDefinitionActorList.Create;
  result := FActorList;
end;

function TFhirPlanDefinition.GetHasActorList : boolean;
begin
  result := (FActorList <> nil) and (FActorList.count > 0);
end;

function TFhirPlanDefinition.GetActionList : TFhirPlanDefinitionActionList;
begin
  if FActionList = nil then
    FActionList := TFhirPlanDefinitionActionList.Create;
  result := FActionList;
end;

function TFhirPlanDefinition.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

procedure TFhirPlanDefinition.SetAsNeeded(value : TFhirDataType);
begin
  FAsNeeded.free;
  FAsNeeded := value;
end;

{ TFhirPlanDefinitionListEnumerator }

constructor TFhirPlanDefinitionListEnumerator.Create(list : TFhirPlanDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionListEnumerator.GetCurrent : TFhirPlanDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPlanDefinitionList }

function TFhirPlanDefinitionList.AddItem(value: TFhirPlanDefinition): TFhirPlanDefinition;
begin
  assert(value.ClassName = 'TFhirPlanDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinition');
  add(value);
  result := value;
end;

function TFhirPlanDefinitionList.Append: TFhirPlanDefinition;
begin
  result := TFhirPlanDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionList.GetEnumerator : TFhirPlanDefinitionListEnumerator;
begin
  result := TFhirPlanDefinitionListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionList.Clone: TFhirPlanDefinitionList;
begin
  result := TFhirPlanDefinitionList(inherited Clone);
end;

function TFhirPlanDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionList.GetItemN(index: Integer): TFhirPlanDefinition;
begin
  result := TFhirPlanDefinition(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinition;
end;
function TFhirPlanDefinitionList.IndexOf(value: TFhirPlanDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionList.Insert(index: Integer): TFhirPlanDefinition;
begin
  result := TFhirPlanDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionList.InsertItem(index: Integer; value: TFhirPlanDefinition);
begin
  assert(value is TFhirPlanDefinition);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionList.Item(index: Integer): TFhirPlanDefinition;
begin
  result := TFhirPlanDefinition(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionList.Link: TFhirPlanDefinitionList;
begin
  result := TFhirPlanDefinitionList(inherited Link);
end;

procedure TFhirPlanDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionList.SetItemByIndex(index: Integer; value: TFhirPlanDefinition);
begin
  assert(value is TFhirPlanDefinition);
  FhirPlanDefinitions[index] := value;
end;

procedure TFhirPlanDefinitionList.SetItemN(index: Integer; value: TFhirPlanDefinition);
begin
  assert(value is TFhirPlanDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PROVENANCE}
{ TFhirProvenanceAgent }

constructor TFhirProvenanceAgent.Create;
begin
  inherited;
end;

destructor TFhirProvenanceAgent.Destroy;
begin
  FType_.free;
  FRoleList.Free;
  FWho.free;
  FOnBehalfOf.free;
  inherited;
end;

procedure TFhirProvenanceAgent.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirProvenanceAgent(oSource).type_.Clone;
  if (TFhirProvenanceAgent(oSource).FRoleList = nil) then
  begin
    FRoleList.free;
    FRoleList := nil;
  end
  else
  begin
    if FRoleList = nil then
      FRoleList := TFhirCodeableConceptList.Create;
    FRoleList.Assign(TFhirProvenanceAgent(oSource).FRoleList);
  end;
  who := TFhirProvenanceAgent(oSource).who.Clone;
  onBehalfOf := TFhirProvenanceAgent(oSource).onBehalfOf.Clone;
end;

procedure TFhirProvenanceAgent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'role') Then
    list.addAll(self, 'role', FRoleList);
  if (child_name = 'who') Then
     list.add(self.link, 'who', FWho.Link);
  if (child_name = 'onBehalfOf') Then
     list.add(self.link, 'onBehalfOf', FOnBehalfOf.Link);
end;

procedure TFhirProvenanceAgent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', true, TFhirCodeableConcept, FRoleList.Link));
  oList.add(TFHIRProperty.create(self, 'who', 'Reference', false, TFhirReference, FWho.Link));
  oList.add(TFHIRProperty.create(self, 'onBehalfOf', 'Reference', false, TFhirReference, FOnBehalfOf.Link));
end;

function TFhirProvenanceAgent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    RoleList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'who') then
  begin
    Who := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'onBehalfOf') then
  begin
    OnBehalfOf := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProvenanceAgent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'role') then RoleList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirProvenanceAgent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'role') then result := RoleList.new()
  else if (propName = 'who') then result := TFhirReference.create()
  else if (propName = 'onBehalfOf') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirProvenanceAgent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'who') then result := 'Reference'
  else if (propName = 'onBehalfOf') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProvenanceAgent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'role') then deletePropertyValue('role', RoleList, value)
  else if (propName = 'who') then WhoElement := nil
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProvenanceAgent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'role') then replacePropertyValue('role', RoleList, existing, new)
  else if (propName = 'who') then WhoElement := new as TFhirReference
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProvenanceAgent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'role') then RoleList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProvenanceAgent.fhirType : string;
begin
  result := 'Provenance.agent';
end;

function TFhirProvenanceAgent.Link : TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(inherited Link);
end;

function TFhirProvenanceAgent.Clone : TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(inherited Clone);
end;

function TFhirProvenanceAgent.equals(other : TObject) : boolean; 
var
  o : TFhirProvenanceAgent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProvenanceAgent)) then
    result := false
  else
  begin
    o := TFhirProvenanceAgent(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(roleList, o.roleList, true) and 
      compareDeep(whoElement, o.whoElement, true) and compareDeep(onBehalfOfElement, o.onBehalfOfElement, true);
  end;
end;

function TFhirProvenanceAgent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FroleList) and isEmptyProp(FWho) and isEmptyProp(FOnBehalfOf);
end;

procedure TFhirProvenanceAgent.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('role');
  fields.add('who');
  fields.add('onBehalfOf');
end;

function TFhirProvenanceAgent.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FRoleList.sizeInBytes(magic));
end;

procedure TFhirProvenanceAgent.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirProvenanceAgent.GetRoleList : TFhirCodeableConceptList;
begin
  if FRoleList = nil then
    FRoleList := TFhirCodeableConceptList.Create;
  result := FRoleList;
end;

function TFhirProvenanceAgent.GetHasRoleList : boolean;
begin
  result := (FRoleList <> nil) and (FRoleList.count > 0);
end;

procedure TFhirProvenanceAgent.SetWho(value : TFhirReference);
begin
  FWho.free;
  FWho := value;
end;

procedure TFhirProvenanceAgent.SetOnBehalfOf(value : TFhirReference);
begin
  FOnBehalfOf.free;
  FOnBehalfOf := value;
end;

{ TFhirProvenanceAgentListEnumerator }

constructor TFhirProvenanceAgentListEnumerator.Create(list : TFhirProvenanceAgentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProvenanceAgentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProvenanceAgentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProvenanceAgentListEnumerator.GetCurrent : TFhirProvenanceAgent;
begin
  Result := FList[FIndex];
end;

function TFhirProvenanceAgentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirProvenanceAgentList }

function TFhirProvenanceAgentList.AddItem(value: TFhirProvenanceAgent): TFhirProvenanceAgent;
begin
  assert(value.ClassName = 'TFhirProvenanceAgent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProvenanceAgent');
  add(value);
  result := value;
end;

function TFhirProvenanceAgentList.Append: TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceAgentList.ClearItems;
begin
  Clear;
end;

function TFhirProvenanceAgentList.GetEnumerator : TFhirProvenanceAgentListEnumerator;
begin
  result := TFhirProvenanceAgentListEnumerator.Create(self.link);
end;

function TFhirProvenanceAgentList.Clone: TFhirProvenanceAgentList;
begin
  result := TFhirProvenanceAgentList(inherited Clone);
end;

function TFhirProvenanceAgentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProvenanceAgentList.GetItemN(index: Integer): TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(ObjectByIndex[index]);
end;

function TFhirProvenanceAgentList.ItemClass: TFslObjectClass;
begin
  result := TFhirProvenanceAgent;
end;
function TFhirProvenanceAgentList.IndexOf(value: TFhirProvenanceAgent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProvenanceAgentList.Insert(index: Integer): TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceAgentList.InsertItem(index: Integer; value: TFhirProvenanceAgent);
begin
  assert(value is TFhirProvenanceAgent);
  Inherited Insert(index, value);
end;

function TFhirProvenanceAgentList.Item(index: Integer): TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(ObjectByIndex[index]);
end;

function TFhirProvenanceAgentList.Link: TFhirProvenanceAgentList;
begin
  result := TFhirProvenanceAgentList(inherited Link);
end;

procedure TFhirProvenanceAgentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProvenanceAgentList.SetItemByIndex(index: Integer; value: TFhirProvenanceAgent);
begin
  assert(value is TFhirProvenanceAgent);
  FhirProvenanceAgents[index] := value;
end;

procedure TFhirProvenanceAgentList.SetItemN(index: Integer; value: TFhirProvenanceAgent);
begin
  assert(value is TFhirProvenanceAgent);
  ObjectByIndex[index] := value;
end;

{ TFhirProvenanceEntity }

constructor TFhirProvenanceEntity.Create;
begin
  inherited;
end;

destructor TFhirProvenanceEntity.Destroy;
begin
  FRole.free;
  FWhat.free;
  FAgentList.Free;
  inherited;
end;

procedure TFhirProvenanceEntity.Assign(oSource : TFslObject);
begin
  inherited;
  roleElement := TFhirProvenanceEntity(oSource).roleElement.Clone;
  what := TFhirProvenanceEntity(oSource).what.Clone;
  if (TFhirProvenanceEntity(oSource).FAgentList = nil) then
  begin
    FAgentList.free;
    FAgentList := nil;
  end
  else
  begin
    if FAgentList = nil then
      FAgentList := TFhirProvenanceAgentList.Create;
    FAgentList.Assign(TFhirProvenanceEntity(oSource).FAgentList);
  end;
end;

procedure TFhirProvenanceEntity.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'what') Then
     list.add(self.link, 'what', FWhat.Link);
  if (child_name = 'agent') Then
    list.addAll(self, 'agent', FAgentList);
end;

procedure TFhirProvenanceEntity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'code', false, TFhirEnum, FRole.Link));
  oList.add(TFHIRProperty.create(self, 'what', 'Reference', false, TFhirReference, FWhat.Link));
  oList.add(TFHIRProperty.create(self, 'agent', '', true, TFhirProvenanceAgent, FAgentList.Link));
end;

function TFhirProvenanceEntity.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    RoleElement := asEnum(SYSTEMS_TFhirProvenanceEntityRoleEnum, CODES_TFhirProvenanceEntityRoleEnum, propValue);
    result := propValue;
  end
  else if (propName = 'what') then
  begin
    What := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'agent') then
  begin
    AgentList.add(propValue as TFhirProvenanceAgent);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProvenanceEntity.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'agent') then AgentList.insertItem(index, propValue as TFhirProvenanceAgent)
  else inherited;
end;

function TFhirProvenanceEntity.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirEnum.create(SYSTEMS_TFhirProvenanceEntityRoleEnum[ProvenanceEntityRoleNull], CODES_TFhirProvenanceEntityRoleEnum[ProvenanceEntityRoleNull]) 
  else if (propName = 'what') then result := TFhirReference.create()
  else if (propName = 'agent') then result := AgentList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirProvenanceEntity.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'code'
  else if (propName = 'what') then result := 'Reference'
  else if (propName = 'agent') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProvenanceEntity.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'what') then WhatElement := nil
  else if (propName = 'agent') then deletePropertyValue('agent', AgentList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProvenanceEntity.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := asEnum(SYSTEMS_TFhirProvenanceEntityRoleEnum, CODES_TFhirProvenanceEntityRoleEnum, new)
  else if (propName = 'what') then WhatElement := new as TFhirReference
  else if (propName = 'agent') then replacePropertyValue('agent', AgentList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProvenanceEntity.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'agent') then AgentList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProvenanceEntity.fhirType : string;
begin
  result := 'Provenance.entity';
end;

function TFhirProvenanceEntity.Link : TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(inherited Link);
end;

function TFhirProvenanceEntity.Clone : TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(inherited Clone);
end;

function TFhirProvenanceEntity.equals(other : TObject) : boolean; 
var
  o : TFhirProvenanceEntity;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProvenanceEntity)) then
    result := false
  else
  begin
    o := TFhirProvenanceEntity(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(whatElement, o.whatElement, true) and 
      compareDeep(agentList, o.agentList, true);
  end;
end;

function TFhirProvenanceEntity.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FWhat) and isEmptyProp(FagentList);
end;

procedure TFhirProvenanceEntity.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('role');
  fields.add('what');
  fields.add('agent');
end;

function TFhirProvenanceEntity.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FAgentList.sizeInBytes(magic));
end;

procedure TFhirProvenanceEntity.SetRole(value : TFhirEnum);
begin
  FRole.free;
  FRole := value;
end;

function TFhirProvenanceEntity.GetRoleST : TFhirProvenanceEntityRoleEnum;
begin
  if FRole = nil then
    result := TFhirProvenanceEntityRoleEnum(0)
  else
    result := TFhirProvenanceEntityRoleEnum(StringArrayIndexOfSensitive(CODES_TFhirProvenanceEntityRoleEnum, FRole.value));
end;

procedure TFhirProvenanceEntity.SetRoleST(value : TFhirProvenanceEntityRoleEnum);
begin
  if ord(value) = 0 then
    RoleElement := nil
  else
    RoleElement := TFhirEnum.create(SYSTEMS_TFhirProvenanceEntityRoleEnum[value], CODES_TFhirProvenanceEntityRoleEnum[value]);
end;

procedure TFhirProvenanceEntity.SetWhat(value : TFhirReference);
begin
  FWhat.free;
  FWhat := value;
end;

function TFhirProvenanceEntity.GetAgentList : TFhirProvenanceAgentList;
begin
  if FAgentList = nil then
    FAgentList := TFhirProvenanceAgentList.Create;
  result := FAgentList;
end;

function TFhirProvenanceEntity.GetHasAgentList : boolean;
begin
  result := (FAgentList <> nil) and (FAgentList.count > 0);
end;

{ TFhirProvenanceEntityListEnumerator }

constructor TFhirProvenanceEntityListEnumerator.Create(list : TFhirProvenanceEntityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProvenanceEntityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProvenanceEntityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProvenanceEntityListEnumerator.GetCurrent : TFhirProvenanceEntity;
begin
  Result := FList[FIndex];
end;

function TFhirProvenanceEntityListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirProvenanceEntityList }

function TFhirProvenanceEntityList.AddItem(value: TFhirProvenanceEntity): TFhirProvenanceEntity;
begin
  assert(value.ClassName = 'TFhirProvenanceEntity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProvenanceEntity');
  add(value);
  result := value;
end;

function TFhirProvenanceEntityList.Append: TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceEntityList.ClearItems;
begin
  Clear;
end;

function TFhirProvenanceEntityList.GetEnumerator : TFhirProvenanceEntityListEnumerator;
begin
  result := TFhirProvenanceEntityListEnumerator.Create(self.link);
end;

function TFhirProvenanceEntityList.Clone: TFhirProvenanceEntityList;
begin
  result := TFhirProvenanceEntityList(inherited Clone);
end;

function TFhirProvenanceEntityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProvenanceEntityList.GetItemN(index: Integer): TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(ObjectByIndex[index]);
end;

function TFhirProvenanceEntityList.ItemClass: TFslObjectClass;
begin
  result := TFhirProvenanceEntity;
end;
function TFhirProvenanceEntityList.IndexOf(value: TFhirProvenanceEntity): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProvenanceEntityList.Insert(index: Integer): TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceEntityList.InsertItem(index: Integer; value: TFhirProvenanceEntity);
begin
  assert(value is TFhirProvenanceEntity);
  Inherited Insert(index, value);
end;

function TFhirProvenanceEntityList.Item(index: Integer): TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(ObjectByIndex[index]);
end;

function TFhirProvenanceEntityList.Link: TFhirProvenanceEntityList;
begin
  result := TFhirProvenanceEntityList(inherited Link);
end;

procedure TFhirProvenanceEntityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProvenanceEntityList.SetItemByIndex(index: Integer; value: TFhirProvenanceEntity);
begin
  assert(value is TFhirProvenanceEntity);
  FhirProvenanceEntities[index] := value;
end;

procedure TFhirProvenanceEntityList.SetItemN(index: Integer; value: TFhirProvenanceEntity);
begin
  assert(value is TFhirProvenanceEntity);
  ObjectByIndex[index] := value;
end;

{ TFhirProvenance }

constructor TFhirProvenance.Create;
begin
  inherited;
end;

destructor TFhirProvenance.Destroy;
begin
  FTargetList.Free;
  FOccurred.free;
  FRecorded.free;
  FPolicyList.Free;
  FLocation.free;
  FAuthorizationList.Free;
  FActivity.free;
  FBasedOnList.Free;
  FPatient.free;
  FEncounter.free;
  FAgentList.Free;
  FEntityList.Free;
  FSignatureList.Free;
  inherited;
end;

procedure TFhirProvenance.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirProvenance(oSource).FTargetList = nil) then
  begin
    FTargetList.free;
    FTargetList := nil;
  end
  else
  begin
    if FTargetList = nil then
      FTargetList := TFhirReferenceList.Create;
    FTargetList.Assign(TFhirProvenance(oSource).FTargetList);
  end;
  occurred := TFhirProvenance(oSource).occurred.Clone;
  recordedElement := TFhirProvenance(oSource).recordedElement.Clone;
  if (TFhirProvenance(oSource).FPolicyList = nil) then
  begin
    FPolicyList.free;
    FPolicyList := nil;
  end
  else
  begin
    if FPolicyList = nil then
      FPolicyList := TFhirUriList.Create;
    FPolicyList.Assign(TFhirProvenance(oSource).FPolicyList);
  end;
  location := TFhirProvenance(oSource).location.Clone;
  if (TFhirProvenance(oSource).FAuthorizationList = nil) then
  begin
    FAuthorizationList.free;
    FAuthorizationList := nil;
  end
  else
  begin
    if FAuthorizationList = nil then
      FAuthorizationList := TFhirCodeableReferenceList.Create;
    FAuthorizationList.Assign(TFhirProvenance(oSource).FAuthorizationList);
  end;
  activity := TFhirProvenance(oSource).activity.Clone;
  if (TFhirProvenance(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirProvenance(oSource).FBasedOnList);
  end;
  patient := TFhirProvenance(oSource).patient.Clone;
  encounter := TFhirProvenance(oSource).encounter.Clone;
  if (TFhirProvenance(oSource).FAgentList = nil) then
  begin
    FAgentList.free;
    FAgentList := nil;
  end
  else
  begin
    if FAgentList = nil then
      FAgentList := TFhirProvenanceAgentList.Create;
    FAgentList.Assign(TFhirProvenance(oSource).FAgentList);
  end;
  if (TFhirProvenance(oSource).FEntityList = nil) then
  begin
    FEntityList.free;
    FEntityList := nil;
  end
  else
  begin
    if FEntityList = nil then
      FEntityList := TFhirProvenanceEntityList.Create;
    FEntityList.Assign(TFhirProvenance(oSource).FEntityList);
  end;
  if (TFhirProvenance(oSource).FSignatureList = nil) then
  begin
    FSignatureList.free;
    FSignatureList := nil;
  end
  else
  begin
    if FSignatureList = nil then
      FSignatureList := TFhirSignatureList.Create;
    FSignatureList.Assign(TFhirProvenance(oSource).FSignatureList);
  end;
end;

function TFhirProvenance.GetResourceType : TFhirResourceType;
begin
  result := frtProvenance;
end;

procedure TFhirProvenance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'target') Then
    list.addAll(self, 'target', FTargetList);
  if (child_name = 'occurred[x]') or (child_name = 'occurred') Then
     list.add(self.link, 'occurred[x]', FOccurred.Link);
  if (child_name = 'recorded') Then
     list.add(self.link, 'recorded', FRecorded.Link);
  if (child_name = 'policy') Then
    list.addAll(self, 'policy', FPolicyList);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'authorization') Then
    list.addAll(self, 'authorization', FAuthorizationList);
  if (child_name = 'activity') Then
     list.add(self.link, 'activity', FActivity.Link);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'agent') Then
    list.addAll(self, 'agent', FAgentList);
  if (child_name = 'entity') Then
    list.addAll(self, 'entity', FEntityList);
  if (child_name = 'signature') Then
    list.addAll(self, 'signature', FSignatureList);
end;

procedure TFhirProvenance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'target', 'Reference', true, TFhirReference, FTargetList.Link));
  oList.add(TFHIRProperty.create(self, 'occurred[x]', 'Period|dateTime', false, TFhirDataType, FOccurred.Link));
  oList.add(TFHIRProperty.create(self, 'recorded', 'instant', false, TFhirInstant, FRecorded.Link));
  oList.add(TFHIRProperty.create(self, 'policy', 'uri', true, TFhirUri, FPolicyList.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'authorization', 'CodeableReference', true, TFhirCodeableReference, FAuthorizationList.Link));
  oList.add(TFHIRProperty.create(self, 'activity', 'CodeableConcept', false, TFhirCodeableConcept, FActivity.Link));
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'agent', 'BackboneElement', true, TFhirProvenanceAgent, FAgentList.Link));
  oList.add(TFHIRProperty.create(self, 'entity', 'BackboneElement', true, TFhirProvenanceEntity, FEntityList.Link));
  oList.add(TFHIRProperty.create(self, 'signature', 'Signature', true, TFhirSignature, FSignatureList.Link));
end;

function TFhirProvenance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'target') then
  begin
    TargetList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurred', ['Period', 'DateTime'])) then
  begin
    Occurred := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'recorded') then
  begin
    RecordedElement := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'policy') then
  begin
    PolicyList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'authorization') then
  begin
    AuthorizationList.add(propValue as TFhirCodeableReference);
    result := propValue;
  end
  else if (propName = 'activity') then
  begin
    Activity := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'agent') then
  begin
    AgentList.add(propValue as TFhirProvenanceAgent);
    result := propValue;
  end
  else if (propName = 'entity') then
  begin
    EntityList.add(propValue as TFhirProvenanceEntity);
    result := propValue;
  end
  else if (propName = 'signature') then
  begin
    SignatureList.add(propValue as TFhirSignature);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProvenance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'target') then TargetList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'policy') then PolicyList.insertItem(index, asUri(propValue))
  else if (propName = 'authorization') then AuthorizationList.insertItem(index, propValue as TFhirCodeableReference)
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'agent') then AgentList.insertItem(index, propValue as TFhirProvenanceAgent)
  else if (propName = 'entity') then EntityList.insertItem(index, propValue as TFhirProvenanceEntity)
  else if (propName = 'signature') then SignatureList.insertItem(index, propValue as TFhirSignature)
  else inherited;
end;

function TFhirProvenance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'target') then result := TargetList.new()
  else if (isMatchingName(propName, 'occurred', ['Period', 'DateTime'])) then raise EFHIRException.create('Cannot make property Occurred')
  else if (propName = 'recorded') then result := TFhirInstant.create()
  else if (propName = 'policy') then result := PolicyList.new()
  else if (propName = 'location') then result := TFhirReference.create()
  else if (propName = 'authorization') then result := AuthorizationList.new()
  else if (propName = 'activity') then result := TFhirCodeableConcept.create()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'patient') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (propName = 'agent') then result := AgentList.new()
  else if (propName = 'entity') then result := EntityList.new()
  else if (propName = 'signature') then result := SignatureList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirProvenance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'target') then result := 'Reference'
  else if (propName = 'occurred[x]') then result := 'Period|dateTime'
  else if (propName = 'recorded') then result := 'instant'
  else if (propName = 'policy') then result := 'uri'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'authorization') then result := 'CodeableReference'
  else if (propName = 'activity') then result := 'CodeableConcept'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'agent') then result := 'BackboneElement'
  else if (propName = 'entity') then result := 'BackboneElement'
  else if (propName = 'signature') then result := 'Signature'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProvenance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'target') then deletePropertyValue('target', TargetList, value)
  else if (isMatchingName(propName, 'occurred', ['Period', 'DateTime'])) then OccurredElement := nil
  else if (propName = 'recorded') then RecordedElement := nil
  else if (propName = 'policy') then deletePropertyValue('policy', PolicyList, value)
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'authorization') then deletePropertyValue('authorization', AuthorizationList, value)
  else if (propName = 'activity') then ActivityElement := nil
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'agent') then deletePropertyValue('agent', AgentList, value)
  else if (propName = 'entity') then deletePropertyValue('entity', EntityList, value)
  else if (propName = 'signature') then deletePropertyValue('signature', SignatureList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProvenance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'target') then replacePropertyValue('target', TargetList, existing, new)
  else if (isMatchingName(propName, 'occurred', ['Period', 'DateTime'])) then OccurredElement := new as TFhirDataType
  else if (propName = 'recorded') then RecordedElement := asInstant(new)
  else if (propName = 'policy') then replacePropertyValue('policy', PolicyList, existing, new)
  else if (propName = 'location') then LocationElement := new as TFhirReference
  else if (propName = 'authorization') then replacePropertyValue('authorization', AuthorizationList, existing, new)
  else if (propName = 'activity') then ActivityElement := new as TFhirCodeableConcept
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'patient') then PatientElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (propName = 'agent') then replacePropertyValue('agent', AgentList, existing, new)
  else if (propName = 'entity') then replacePropertyValue('entity', EntityList, existing, new)
  else if (propName = 'signature') then replacePropertyValue('signature', SignatureList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProvenance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'target') then TargetList.move(source, destination)
  else if (propName = 'policy') then PolicyList.move(source, destination)
  else if (propName = 'authorization') then AuthorizationList.move(source, destination)
  else if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'agent') then AgentList.move(source, destination)
  else if (propName = 'entity') then EntityList.move(source, destination)
  else if (propName = 'signature') then SignatureList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProvenance.fhirType : string;
begin
  result := 'Provenance';
end;

function TFhirProvenance.Link : TFhirProvenance;
begin
  result := TFhirProvenance(inherited Link);
end;

function TFhirProvenance.Clone : TFhirProvenance;
begin
  result := TFhirProvenance(inherited Clone);
end;

function TFhirProvenance.equals(other : TObject) : boolean; 
var
  o : TFhirProvenance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProvenance)) then
    result := false
  else
  begin
    o := TFhirProvenance(other);
    result := compareDeep(targetList, o.targetList, true) and compareDeep(occurredElement, o.occurredElement, true) and 
      compareDeep(recordedElement, o.recordedElement, true) and compareDeep(policyList, o.policyList, true) and 
      compareDeep(locationElement, o.locationElement, true) and compareDeep(authorizationList, o.authorizationList, true) and 
      compareDeep(activityElement, o.activityElement, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(patientElement, o.patientElement, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(agentList, o.agentList, true) and compareDeep(entityList, o.entityList, true) and 
      compareDeep(signatureList, o.signatureList, true);
  end;
end;

function TFhirProvenance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FtargetList) and isEmptyProp(FOccurred) and isEmptyProp(FRecorded) and isEmptyProp(FpolicyList) and isEmptyProp(FLocation) and isEmptyProp(FauthorizationList) and isEmptyProp(FActivity) and isEmptyProp(FbasedOnList) and isEmptyProp(FPatient) and isEmptyProp(FEncounter) and isEmptyProp(FagentList) and isEmptyProp(FentityList) and isEmptyProp(FsignatureList);
end;

procedure TFhirProvenance.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('target');
  fields.add('occurred[x]');
  fields.add('recorded');
  fields.add('policy');
  fields.add('location');
  fields.add('authorization');
  fields.add('activity');
  fields.add('basedOn');
  fields.add('patient');
  fields.add('encounter');
  fields.add('agent');
  fields.add('entity');
  fields.add('signature');
end;

function TFhirProvenance.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FTargetList.sizeInBytes(magic));
  inc(result, FPolicyList.sizeInBytes(magic));
  inc(result, FAuthorizationList.sizeInBytes(magic));
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FAgentList.sizeInBytes(magic));
  inc(result, FEntityList.sizeInBytes(magic));
  inc(result, FSignatureList.sizeInBytes(magic));
end;

function TFhirProvenance.GetTargetList : TFhirReferenceList;
begin
  if FTargetList = nil then
    FTargetList := TFhirReferenceList.Create;
  result := FTargetList;
end;

function TFhirProvenance.GetHasTargetList : boolean;
begin
  result := (FTargetList <> nil) and (FTargetList.count > 0);
end;

procedure TFhirProvenance.SetOccurred(value : TFhirDataType);
begin
  FOccurred.free;
  FOccurred := value;
end;

procedure TFhirProvenance.SetRecorded(value : TFhirInstant);
begin
  FRecorded.free;
  FRecorded := value;
end;

function TFhirProvenance.GetRecordedST : TFslDateTime;
begin
  if FRecorded = nil then
    result := TFslDateTime.makeNull
  else
    result := FRecorded.value;
end;

procedure TFhirProvenance.SetRecordedST(value : TFslDateTime);
begin
  if FRecorded = nil then
    FRecorded := TFhirInstant.create;
  FRecorded.value := value
end;

function TFhirProvenance.GetPolicyList : TFhirUriList;
begin
  if FPolicyList = nil then
    FPolicyList := TFhirUriList.Create;
  result := FPolicyList;
end;

function TFhirProvenance.GetHasPolicyList : boolean;
begin
  result := (FPolicyList <> nil) and (FPolicyList.count > 0);
end;

procedure TFhirProvenance.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value;
end;

function TFhirProvenance.GetAuthorizationList : TFhirCodeableReferenceList;
begin
  if FAuthorizationList = nil then
    FAuthorizationList := TFhirCodeableReferenceList.Create;
  result := FAuthorizationList;
end;

function TFhirProvenance.GetHasAuthorizationList : boolean;
begin
  result := (FAuthorizationList <> nil) and (FAuthorizationList.count > 0);
end;

procedure TFhirProvenance.SetActivity(value : TFhirCodeableConcept);
begin
  FActivity.free;
  FActivity := value;
end;

function TFhirProvenance.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirProvenance.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

procedure TFhirProvenance.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value;
end;

procedure TFhirProvenance.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

function TFhirProvenance.GetAgentList : TFhirProvenanceAgentList;
begin
  if FAgentList = nil then
    FAgentList := TFhirProvenanceAgentList.Create;
  result := FAgentList;
end;

function TFhirProvenance.GetHasAgentList : boolean;
begin
  result := (FAgentList <> nil) and (FAgentList.count > 0);
end;

function TFhirProvenance.GetEntityList : TFhirProvenanceEntityList;
begin
  if FEntityList = nil then
    FEntityList := TFhirProvenanceEntityList.Create;
  result := FEntityList;
end;

function TFhirProvenance.GetHasEntityList : boolean;
begin
  result := (FEntityList <> nil) and (FEntityList.count > 0);
end;

function TFhirProvenance.GetSignatureList : TFhirSignatureList;
begin
  if FSignatureList = nil then
    FSignatureList := TFhirSignatureList.Create;
  result := FSignatureList;
end;

function TFhirProvenance.GetHasSignatureList : boolean;
begin
  result := (FSignatureList <> nil) and (FSignatureList.count > 0);
end;

{ TFhirProvenanceListEnumerator }

constructor TFhirProvenanceListEnumerator.Create(list : TFhirProvenanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProvenanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProvenanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProvenanceListEnumerator.GetCurrent : TFhirProvenance;
begin
  Result := FList[FIndex];
end;

function TFhirProvenanceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirProvenanceList }

function TFhirProvenanceList.AddItem(value: TFhirProvenance): TFhirProvenance;
begin
  assert(value.ClassName = 'TFhirProvenance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProvenance');
  add(value);
  result := value;
end;

function TFhirProvenanceList.Append: TFhirProvenance;
begin
  result := TFhirProvenance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceList.ClearItems;
begin
  Clear;
end;

function TFhirProvenanceList.GetEnumerator : TFhirProvenanceListEnumerator;
begin
  result := TFhirProvenanceListEnumerator.Create(self.link);
end;

function TFhirProvenanceList.Clone: TFhirProvenanceList;
begin
  result := TFhirProvenanceList(inherited Clone);
end;

function TFhirProvenanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProvenanceList.GetItemN(index: Integer): TFhirProvenance;
begin
  result := TFhirProvenance(ObjectByIndex[index]);
end;

function TFhirProvenanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirProvenance;
end;
function TFhirProvenanceList.IndexOf(value: TFhirProvenance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProvenanceList.Insert(index: Integer): TFhirProvenance;
begin
  result := TFhirProvenance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceList.InsertItem(index: Integer; value: TFhirProvenance);
begin
  assert(value is TFhirProvenance);
  Inherited Insert(index, value);
end;

function TFhirProvenanceList.Item(index: Integer): TFhirProvenance;
begin
  result := TFhirProvenance(ObjectByIndex[index]);
end;

function TFhirProvenanceList.Link: TFhirProvenanceList;
begin
  result := TFhirProvenanceList(inherited Link);
end;

procedure TFhirProvenanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProvenanceList.SetItemByIndex(index: Integer; value: TFhirProvenance);
begin
  assert(value is TFhirProvenance);
  FhirProvenances[index] := value;
end;

procedure TFhirProvenanceList.SetItemN(index: Integer; value: TFhirProvenance);
begin
  assert(value is TFhirProvenance);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
{ TFhirQuestionnaireResponseItem }

constructor TFhirQuestionnaireResponseItem.Create;
begin
  inherited;
end;

destructor TFhirQuestionnaireResponseItem.Destroy;
begin
  FLinkId.free;
  FDefinition.free;
  FText.free;
  FAnswerList.Free;
  FItemList.Free;
  inherited;
end;

procedure TFhirQuestionnaireResponseItem.Assign(oSource : TFslObject);
begin
  inherited;
  linkIdElement := TFhirQuestionnaireResponseItem(oSource).linkIdElement.Clone;
  definitionElement := TFhirQuestionnaireResponseItem(oSource).definitionElement.Clone;
  textElement := TFhirQuestionnaireResponseItem(oSource).textElement.Clone;
  if (TFhirQuestionnaireResponseItem(oSource).FAnswerList = nil) then
  begin
    FAnswerList.free;
    FAnswerList := nil;
  end
  else
  begin
    if FAnswerList = nil then
      FAnswerList := TFhirQuestionnaireResponseItemAnswerList.Create;
    FAnswerList.Assign(TFhirQuestionnaireResponseItem(oSource).FAnswerList);
  end;
  if (TFhirQuestionnaireResponseItem(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirQuestionnaireResponseItemList.Create;
    FItemList.Assign(TFhirQuestionnaireResponseItem(oSource).FItemList);
  end;
end;

procedure TFhirQuestionnaireResponseItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'linkId') Then
     list.add(self.link, 'linkId', FLinkId.Link);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'answer') Then
    list.addAll(self, 'answer', FAnswerList);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirQuestionnaireResponseItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'linkId', 'string', false, TFhirString, FLinkId.Link));
  oList.add(TFHIRProperty.create(self, 'definition', 'uri', false, TFhirUri, FDefinition.Link));
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));
  oList.add(TFHIRProperty.create(self, 'answer', 'BackboneElement', true, TFhirQuestionnaireResponseItemAnswer, FAnswerList.Link));
  oList.add(TFHIRProperty.create(self, 'item', '', true, TFhirQuestionnaireResponseItem, FItemList.Link));
end;

function TFhirQuestionnaireResponseItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'linkId') then
  begin
    LinkIdElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'answer') then
  begin
    AnswerList.add(propValue as TFhirQuestionnaireResponseItemAnswer);
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirQuestionnaireResponseItem);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirQuestionnaireResponseItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'answer') then AnswerList.insertItem(index, propValue as TFhirQuestionnaireResponseItemAnswer)
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirQuestionnaireResponseItem)
  else inherited;
end;

function TFhirQuestionnaireResponseItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'linkId') then result := TFhirString.create()
  else if (propName = 'definition') then result := TFhirUri.create()
  else if (propName = 'text') then result := TFhirString.create()
  else if (propName = 'answer') then result := AnswerList.new()
  else if (propName = 'item') then result := ItemList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuestionnaireResponseItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'linkId') then result := 'string'
  else if (propName = 'definition') then result := 'uri'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'answer') then result := 'BackboneElement'
  else if (propName = 'item') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuestionnaireResponseItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := nil
  else if (propName = 'definition') then DefinitionElement := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'answer') then deletePropertyValue('answer', AnswerList, value)
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirQuestionnaireResponseItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := asString(new)
  else if (propName = 'definition') then DefinitionElement := asUri(new)
  else if (propName = 'text') then TextElement := asString(new)
  else if (propName = 'answer') then replacePropertyValue('answer', AnswerList, existing, new)
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuestionnaireResponseItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'answer') then AnswerList.move(source, destination)
  else if (propName = 'item') then ItemList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirQuestionnaireResponseItem.fhirType : string;
begin
  result := 'QuestionnaireResponse.item';
end;

function TFhirQuestionnaireResponseItem.Link : TFhirQuestionnaireResponseItem;
begin
  result := TFhirQuestionnaireResponseItem(inherited Link);
end;

function TFhirQuestionnaireResponseItem.Clone : TFhirQuestionnaireResponseItem;
begin
  result := TFhirQuestionnaireResponseItem(inherited Clone);
end;

function TFhirQuestionnaireResponseItem.equals(other : TObject) : boolean; 
var
  o : TFhirQuestionnaireResponseItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuestionnaireResponseItem)) then
    result := false
  else
  begin
    o := TFhirQuestionnaireResponseItem(other);
    result := compareDeep(linkIdElement, o.linkIdElement, true) and compareDeep(definitionElement, o.definitionElement, true) and 
      compareDeep(textElement, o.textElement, true) and compareDeep(answerList, o.answerList, true) and 
      compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirQuestionnaireResponseItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLinkId) and isEmptyProp(FDefinition) and isEmptyProp(FText) and isEmptyProp(FanswerList) and isEmptyProp(FitemList);
end;

procedure TFhirQuestionnaireResponseItem.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('linkId');
  fields.add('definition');
  fields.add('text');
  fields.add('answer');
  fields.add('item');
end;

function TFhirQuestionnaireResponseItem.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FAnswerList.sizeInBytes(magic));
  inc(result, FItemList.sizeInBytes(magic));
end;

procedure TFhirQuestionnaireResponseItem.SetLinkId(value : TFhirString);
begin
  FLinkId.free;
  FLinkId := value;
end;

function TFhirQuestionnaireResponseItem.GetLinkIdST : String;
begin
  if FLinkId = nil then
    result := ''
  else
    result := FLinkId.value;
end;

procedure TFhirQuestionnaireResponseItem.SetLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FLinkId = nil then
      FLinkId := TFhirString.create;
    FLinkId.value := value
  end
  else if FLinkId <> nil then
    FLinkId.value := '';
end;

procedure TFhirQuestionnaireResponseItem.SetDefinition(value : TFhirUri);
begin
  FDefinition.free;
  FDefinition := value;
end;

function TFhirQuestionnaireResponseItem.GetDefinitionST : String;
begin
  if FDefinition = nil then
    result := ''
  else
    result := FDefinition.value;
end;

procedure TFhirQuestionnaireResponseItem.SetDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FDefinition = nil then
      FDefinition := TFhirUri.create;
    FDefinition.value := value
  end
  else if FDefinition <> nil then
    FDefinition.value := '';
end;

procedure TFhirQuestionnaireResponseItem.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

function TFhirQuestionnaireResponseItem.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirQuestionnaireResponseItem.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

function TFhirQuestionnaireResponseItem.GetAnswerList : TFhirQuestionnaireResponseItemAnswerList;
begin
  if FAnswerList = nil then
    FAnswerList := TFhirQuestionnaireResponseItemAnswerList.Create;
  result := FAnswerList;
end;

function TFhirQuestionnaireResponseItem.GetHasAnswerList : boolean;
begin
  result := (FAnswerList <> nil) and (FAnswerList.count > 0);
end;

function TFhirQuestionnaireResponseItem.GetItemList : TFhirQuestionnaireResponseItemList;
begin
  if FItemList = nil then
    FItemList := TFhirQuestionnaireResponseItemList.Create;
  result := FItemList;
end;

function TFhirQuestionnaireResponseItem.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

{ TFhirQuestionnaireResponseItemListEnumerator }

constructor TFhirQuestionnaireResponseItemListEnumerator.Create(list : TFhirQuestionnaireResponseItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuestionnaireResponseItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireResponseItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuestionnaireResponseItemListEnumerator.GetCurrent : TFhirQuestionnaireResponseItem;
begin
  Result := FList[FIndex];
end;

function TFhirQuestionnaireResponseItemListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirQuestionnaireResponseItemList }

function TFhirQuestionnaireResponseItemList.AddItem(value: TFhirQuestionnaireResponseItem): TFhirQuestionnaireResponseItem;
begin
  assert(value.ClassName = 'TFhirQuestionnaireResponseItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireResponseItem');
  add(value);
  result := value;
end;

function TFhirQuestionnaireResponseItemList.Append: TFhirQuestionnaireResponseItem;
begin
  result := TFhirQuestionnaireResponseItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseItemList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireResponseItemList.GetEnumerator : TFhirQuestionnaireResponseItemListEnumerator;
begin
  result := TFhirQuestionnaireResponseItemListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireResponseItemList.Clone: TFhirQuestionnaireResponseItemList;
begin
  result := TFhirQuestionnaireResponseItemList(inherited Clone);
end;

function TFhirQuestionnaireResponseItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireResponseItemList.GetItemN(index: Integer): TFhirQuestionnaireResponseItem;
begin
  result := TFhirQuestionnaireResponseItem(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuestionnaireResponseItem;
end;
function TFhirQuestionnaireResponseItemList.IndexOf(value: TFhirQuestionnaireResponseItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuestionnaireResponseItemList.Insert(index: Integer): TFhirQuestionnaireResponseItem;
begin
  result := TFhirQuestionnaireResponseItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseItemList.InsertItem(index: Integer; value: TFhirQuestionnaireResponseItem);
begin
  assert(value is TFhirQuestionnaireResponseItem);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireResponseItemList.Item(index: Integer): TFhirQuestionnaireResponseItem;
begin
  result := TFhirQuestionnaireResponseItem(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseItemList.Link: TFhirQuestionnaireResponseItemList;
begin
  result := TFhirQuestionnaireResponseItemList(inherited Link);
end;

procedure TFhirQuestionnaireResponseItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireResponseItemList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireResponseItem);
begin
  assert(value is TFhirQuestionnaireResponseItem);
  FhirQuestionnaireResponseItems[index] := value;
end;

procedure TFhirQuestionnaireResponseItemList.SetItemN(index: Integer; value: TFhirQuestionnaireResponseItem);
begin
  assert(value is TFhirQuestionnaireResponseItem);
  ObjectByIndex[index] := value;
end;

{ TFhirQuestionnaireResponseItemAnswer }

constructor TFhirQuestionnaireResponseItemAnswer.Create;
begin
  inherited;
end;

destructor TFhirQuestionnaireResponseItemAnswer.Destroy;
begin
  FValue.free;
  FItemList.Free;
  inherited;
end;

procedure TFhirQuestionnaireResponseItemAnswer.Assign(oSource : TFslObject);
begin
  inherited;
  value := TFhirQuestionnaireResponseItemAnswer(oSource).value.Clone;
  if (TFhirQuestionnaireResponseItemAnswer(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirQuestionnaireResponseItemList.Create;
    FItemList.Assign(TFhirQuestionnaireResponseItemAnswer(oSource).FItemList);
  end;
end;

procedure TFhirQuestionnaireResponseItemAnswer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirQuestionnaireResponseItemAnswer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'value[x]', 'boolean|decimal|integer|date|dateTime|time|string|uri|Attachment|Coding|Quantity|Reference', false, TFhirDataType, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'item', '', true, TFhirQuestionnaireResponseItem, FItemList.Link));
end;

function TFhirQuestionnaireResponseItemAnswer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirQuestionnaireResponseItem);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirQuestionnaireResponseItemAnswer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirQuestionnaireResponseItem)
  else inherited;
end;

function TFhirQuestionnaireResponseItemAnswer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then raise EFHIRException.create('Cannot make property Value')
  else if (propName = 'item') then result := ItemList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuestionnaireResponseItemAnswer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'value[x]') then result := 'boolean|decimal|integer|date|dateTime|time|string|uri|Attachment|Coding|Quantity|Reference'
  else if (propName = 'item') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuestionnaireResponseItemAnswer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then ValueElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirQuestionnaireResponseItemAnswer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then ValueElement := new as TFhirDataType
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuestionnaireResponseItemAnswer.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'item') then ItemList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirQuestionnaireResponseItemAnswer.fhirType : string;
begin
  result := 'QuestionnaireResponse.item.answer';
end;

function TFhirQuestionnaireResponseItemAnswer.Link : TFhirQuestionnaireResponseItemAnswer;
begin
  result := TFhirQuestionnaireResponseItemAnswer(inherited Link);
end;

function TFhirQuestionnaireResponseItemAnswer.Clone : TFhirQuestionnaireResponseItemAnswer;
begin
  result := TFhirQuestionnaireResponseItemAnswer(inherited Clone);
end;

function TFhirQuestionnaireResponseItemAnswer.equals(other : TObject) : boolean; 
var
  o : TFhirQuestionnaireResponseItemAnswer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuestionnaireResponseItemAnswer)) then
    result := false
  else
  begin
    o := TFhirQuestionnaireResponseItemAnswer(other);
    result := compareDeep(valueElement, o.valueElement, true) and compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirQuestionnaireResponseItemAnswer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValue) and isEmptyProp(FitemList);
end;

procedure TFhirQuestionnaireResponseItemAnswer.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('value[x]');
  fields.add('item');
end;

function TFhirQuestionnaireResponseItemAnswer.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FItemList.sizeInBytes(magic));
end;

procedure TFhirQuestionnaireResponseItemAnswer.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

function TFhirQuestionnaireResponseItemAnswer.GetItemList : TFhirQuestionnaireResponseItemList;
begin
  if FItemList = nil then
    FItemList := TFhirQuestionnaireResponseItemList.Create;
  result := FItemList;
end;

function TFhirQuestionnaireResponseItemAnswer.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

{ TFhirQuestionnaireResponseItemAnswerListEnumerator }

constructor TFhirQuestionnaireResponseItemAnswerListEnumerator.Create(list : TFhirQuestionnaireResponseItemAnswerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuestionnaireResponseItemAnswerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireResponseItemAnswerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuestionnaireResponseItemAnswerListEnumerator.GetCurrent : TFhirQuestionnaireResponseItemAnswer;
begin
  Result := FList[FIndex];
end;

function TFhirQuestionnaireResponseItemAnswerListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirQuestionnaireResponseItemAnswerList }

function TFhirQuestionnaireResponseItemAnswerList.AddItem(value: TFhirQuestionnaireResponseItemAnswer): TFhirQuestionnaireResponseItemAnswer;
begin
  assert(value.ClassName = 'TFhirQuestionnaireResponseItemAnswer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireResponseItemAnswer');
  add(value);
  result := value;
end;

function TFhirQuestionnaireResponseItemAnswerList.Append: TFhirQuestionnaireResponseItemAnswer;
begin
  result := TFhirQuestionnaireResponseItemAnswer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseItemAnswerList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireResponseItemAnswerList.GetEnumerator : TFhirQuestionnaireResponseItemAnswerListEnumerator;
begin
  result := TFhirQuestionnaireResponseItemAnswerListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireResponseItemAnswerList.Clone: TFhirQuestionnaireResponseItemAnswerList;
begin
  result := TFhirQuestionnaireResponseItemAnswerList(inherited Clone);
end;

function TFhirQuestionnaireResponseItemAnswerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireResponseItemAnswerList.GetItemN(index: Integer): TFhirQuestionnaireResponseItemAnswer;
begin
  result := TFhirQuestionnaireResponseItemAnswer(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseItemAnswerList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuestionnaireResponseItemAnswer;
end;
function TFhirQuestionnaireResponseItemAnswerList.IndexOf(value: TFhirQuestionnaireResponseItemAnswer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuestionnaireResponseItemAnswerList.Insert(index: Integer): TFhirQuestionnaireResponseItemAnswer;
begin
  result := TFhirQuestionnaireResponseItemAnswer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseItemAnswerList.InsertItem(index: Integer; value: TFhirQuestionnaireResponseItemAnswer);
begin
  assert(value is TFhirQuestionnaireResponseItemAnswer);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireResponseItemAnswerList.Item(index: Integer): TFhirQuestionnaireResponseItemAnswer;
begin
  result := TFhirQuestionnaireResponseItemAnswer(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseItemAnswerList.Link: TFhirQuestionnaireResponseItemAnswerList;
begin
  result := TFhirQuestionnaireResponseItemAnswerList(inherited Link);
end;

procedure TFhirQuestionnaireResponseItemAnswerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireResponseItemAnswerList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireResponseItemAnswer);
begin
  assert(value is TFhirQuestionnaireResponseItemAnswer);
  FhirQuestionnaireResponseItemAnswers[index] := value;
end;

procedure TFhirQuestionnaireResponseItemAnswerList.SetItemN(index: Integer; value: TFhirQuestionnaireResponseItemAnswer);
begin
  assert(value is TFhirQuestionnaireResponseItemAnswer);
  ObjectByIndex[index] := value;
end;

{ TFhirQuestionnaireResponse }

constructor TFhirQuestionnaireResponse.Create;
begin
  inherited;
end;

destructor TFhirQuestionnaireResponse.Destroy;
begin
  FIdentifierList.Free;
  FBasedOnList.Free;
  FPartOfList.Free;
  FQuestionnaire.free;
  FStatus.free;
  FSubject.free;
  FEncounter.free;
  FAuthored.free;
  FAuthor.free;
  FSource.free;
  FItemList.Free;
  inherited;
end;

procedure TFhirQuestionnaireResponse.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirQuestionnaireResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirQuestionnaireResponse(oSource).FIdentifierList);
  end;
  if (TFhirQuestionnaireResponse(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirQuestionnaireResponse(oSource).FBasedOnList);
  end;
  if (TFhirQuestionnaireResponse(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirQuestionnaireResponse(oSource).FPartOfList);
  end;
  questionnaireElement := TFhirQuestionnaireResponse(oSource).questionnaireElement.Clone;
  statusElement := TFhirQuestionnaireResponse(oSource).statusElement.Clone;
  subject := TFhirQuestionnaireResponse(oSource).subject.Clone;
  encounter := TFhirQuestionnaireResponse(oSource).encounter.Clone;
  authoredElement := TFhirQuestionnaireResponse(oSource).authoredElement.Clone;
  author := TFhirQuestionnaireResponse(oSource).author.Clone;
  source := TFhirQuestionnaireResponse(oSource).source.Clone;
  if (TFhirQuestionnaireResponse(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirQuestionnaireResponseItemList.Create;
    FItemList.Assign(TFhirQuestionnaireResponse(oSource).FItemList);
  end;
end;

function TFhirQuestionnaireResponse.GetResourceType : TFhirResourceType;
begin
  result := frtQuestionnaireResponse;
end;

procedure TFhirQuestionnaireResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'questionnaire') Then
     list.add(self.link, 'questionnaire', FQuestionnaire.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'authored') Then
     list.add(self.link, 'authored', FAuthored.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirQuestionnaireResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link));
  oList.add(TFHIRProperty.create(self, 'questionnaire', 'canonical', false, TFhirCanonical, FQuestionnaire.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'authored', 'dateTime', false, TFhirDateTime, FAuthored.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', false, TFhirReference, FAuthor.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', false, TFhirReference, FSource.Link));
  oList.add(TFHIRProperty.create(self, 'item', 'BackboneElement', true, TFhirQuestionnaireResponseItem, FItemList.Link));
end;

function TFhirQuestionnaireResponse.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'questionnaire') then
  begin
    QuestionnaireElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirQuestionnaireResponseStatusEnum, CODES_TFhirQuestionnaireResponseStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'authored') then
  begin
    AuthoredElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirQuestionnaireResponseItem);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirQuestionnaireResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirQuestionnaireResponseItem)
  else inherited;
end;

function TFhirQuestionnaireResponse.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'partOf') then result := PartOfList.new()
  else if (propName = 'questionnaire') then result := TFhirCanonical.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirQuestionnaireResponseStatusEnum[QuestionnaireResponseStatusNull], CODES_TFhirQuestionnaireResponseStatusEnum[QuestionnaireResponseStatusNull]) 
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (propName = 'authored') then result := TFhirDateTime.create()
  else if (propName = 'author') then result := TFhirReference.create()
  else if (propName = 'source') then result := TFhirReference.create()
  else if (propName = 'item') then result := ItemList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuestionnaireResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'questionnaire') then result := 'canonical'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'authored') then result := 'dateTime'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'source') then result := 'Reference'
  else if (propName = 'item') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuestionnaireResponse.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value)
  else if (propName = 'questionnaire') then QuestionnaireElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'authored') then AuthoredElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirQuestionnaireResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new)
  else if (propName = 'questionnaire') then QuestionnaireElement := asCanonical(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirQuestionnaireResponseStatusEnum, CODES_TFhirQuestionnaireResponseStatusEnum, new)
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (propName = 'authored') then AuthoredElement := asDateTime(new)
  else if (propName = 'author') then AuthorElement := new as TFhirReference
  else if (propName = 'source') then SourceElement := new as TFhirReference
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuestionnaireResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'partOf') then PartOfList.move(source, destination)
  else if (propName = 'item') then ItemList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirQuestionnaireResponse.fhirType : string;
begin
  result := 'QuestionnaireResponse';
end;

function TFhirQuestionnaireResponse.Link : TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse(inherited Link);
end;

function TFhirQuestionnaireResponse.Clone : TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse(inherited Clone);
end;

function TFhirQuestionnaireResponse.equals(other : TObject) : boolean; 
var
  o : TFhirQuestionnaireResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuestionnaireResponse)) then
    result := false
  else
  begin
    o := TFhirQuestionnaireResponse(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(partOfList, o.partOfList, true) and compareDeep(questionnaireElement, o.questionnaireElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(authoredElement, o.authoredElement, true) and 
      compareDeep(authorElement, o.authorElement, true) and compareDeep(sourceElement, o.sourceElement, true) and 
      compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirQuestionnaireResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FbasedOnList) and isEmptyProp(FpartOfList) and isEmptyProp(FQuestionnaire) and isEmptyProp(FStatus) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FAuthored) and isEmptyProp(FAuthor) and isEmptyProp(FSource) and isEmptyProp(FitemList);
end;

procedure TFhirQuestionnaireResponse.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('partOf');
  fields.add('questionnaire');
  fields.add('status');
  fields.add('subject');
  fields.add('encounter');
  fields.add('authored');
  fields.add('author');
  fields.add('source');
  fields.add('item');
end;

function TFhirQuestionnaireResponse.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FPartOfList.sizeInBytes(magic));
  inc(result, FItemList.sizeInBytes(magic));
end;

function TFhirQuestionnaireResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirQuestionnaireResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirQuestionnaireResponse.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirQuestionnaireResponse.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirQuestionnaireResponse.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirQuestionnaireResponse.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

procedure TFhirQuestionnaireResponse.SetQuestionnaire(value : TFhirCanonical);
begin
  FQuestionnaire.free;
  FQuestionnaire := value;
end;

function TFhirQuestionnaireResponse.GetQuestionnaireST : String;
begin
  if FQuestionnaire = nil then
    result := ''
  else
    result := FQuestionnaire.value;
end;

procedure TFhirQuestionnaireResponse.SetQuestionnaireST(value : String);
begin
  if value <> '' then
  begin
    if FQuestionnaire = nil then
      FQuestionnaire := TFhirCanonical.create;
    FQuestionnaire.value := value
  end
  else if FQuestionnaire <> nil then
    FQuestionnaire.value := '';
end;

procedure TFhirQuestionnaireResponse.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirQuestionnaireResponse.GetStatusST : TFhirQuestionnaireResponseStatusEnum;
begin
  if FStatus = nil then
    result := TFhirQuestionnaireResponseStatusEnum(0)
  else
    result := TFhirQuestionnaireResponseStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirQuestionnaireResponseStatusEnum, FStatus.value));
end;

procedure TFhirQuestionnaireResponse.SetStatusST(value : TFhirQuestionnaireResponseStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirQuestionnaireResponseStatusEnum[value], CODES_TFhirQuestionnaireResponseStatusEnum[value]);
end;

procedure TFhirQuestionnaireResponse.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirQuestionnaireResponse.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirQuestionnaireResponse.SetAuthored(value : TFhirDateTime);
begin
  FAuthored.free;
  FAuthored := value;
end;

function TFhirQuestionnaireResponse.GetAuthoredST : TFslDateTime;
begin
  if FAuthored = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthored.value;
end;

procedure TFhirQuestionnaireResponse.SetAuthoredST(value : TFslDateTime);
begin
  if FAuthored = nil then
    FAuthored := TFhirDateTime.create;
  FAuthored.value := value
end;

procedure TFhirQuestionnaireResponse.SetAuthor(value : TFhirReference);
begin
  FAuthor.free;
  FAuthor := value;
end;

procedure TFhirQuestionnaireResponse.SetSource(value : TFhirReference);
begin
  FSource.free;
  FSource := value;
end;

function TFhirQuestionnaireResponse.GetItemList : TFhirQuestionnaireResponseItemList;
begin
  if FItemList = nil then
    FItemList := TFhirQuestionnaireResponseItemList.Create;
  result := FItemList;
end;

function TFhirQuestionnaireResponse.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

{ TFhirQuestionnaireResponseListEnumerator }

constructor TFhirQuestionnaireResponseListEnumerator.Create(list : TFhirQuestionnaireResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuestionnaireResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuestionnaireResponseListEnumerator.GetCurrent : TFhirQuestionnaireResponse;
begin
  Result := FList[FIndex];
end;

function TFhirQuestionnaireResponseListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirQuestionnaireResponseList }

function TFhirQuestionnaireResponseList.AddItem(value: TFhirQuestionnaireResponse): TFhirQuestionnaireResponse;
begin
  assert(value.ClassName = 'TFhirQuestionnaireResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireResponse');
  add(value);
  result := value;
end;

function TFhirQuestionnaireResponseList.Append: TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireResponseList.GetEnumerator : TFhirQuestionnaireResponseListEnumerator;
begin
  result := TFhirQuestionnaireResponseListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireResponseList.Clone: TFhirQuestionnaireResponseList;
begin
  result := TFhirQuestionnaireResponseList(inherited Clone);
end;

function TFhirQuestionnaireResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireResponseList.GetItemN(index: Integer): TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuestionnaireResponse;
end;
function TFhirQuestionnaireResponseList.IndexOf(value: TFhirQuestionnaireResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuestionnaireResponseList.Insert(index: Integer): TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseList.InsertItem(index: Integer; value: TFhirQuestionnaireResponse);
begin
  assert(value is TFhirQuestionnaireResponse);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireResponseList.Item(index: Integer): TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseList.Link: TFhirQuestionnaireResponseList;
begin
  result := TFhirQuestionnaireResponseList(inherited Link);
end;

procedure TFhirQuestionnaireResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireResponseList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireResponse);
begin
  assert(value is TFhirQuestionnaireResponse);
  FhirQuestionnaireResponses[index] := value;
end;

procedure TFhirQuestionnaireResponseList.SetItemN(index: Integer; value: TFhirQuestionnaireResponse);
begin
  assert(value is TFhirQuestionnaireResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REQUESTGROUP}
{ TFhirRequestGroupAction }

constructor TFhirRequestGroupAction.Create;
begin
  inherited;
end;

destructor TFhirRequestGroupAction.Destroy;
begin
  FLinkId.free;
  FPrefix.free;
  FTitle.free;
  FDescription.free;
  FTextEquivalent.free;
  FPriority.free;
  FCodeList.Free;
  FDocumentationList.Free;
  FGoalList.Free;
  FConditionList.Free;
  FRelatedActionList.Free;
  FTiming.free;
  FLocation.free;
  FParticipantList.Free;
  FType_.free;
  FGroupingBehavior.free;
  FSelectionBehavior.free;
  FRequiredBehavior.free;
  FPrecheckBehavior.free;
  FCardinalityBehavior.free;
  FResource.free;
  FActionList.Free;
  inherited;
end;

procedure TFhirRequestGroupAction.Assign(oSource : TFslObject);
begin
  inherited;
  linkIdElement := TFhirRequestGroupAction(oSource).linkIdElement.Clone;
  prefixElement := TFhirRequestGroupAction(oSource).prefixElement.Clone;
  titleElement := TFhirRequestGroupAction(oSource).titleElement.Clone;
  descriptionElement := TFhirRequestGroupAction(oSource).descriptionElement.Clone;
  textEquivalentElement := TFhirRequestGroupAction(oSource).textEquivalentElement.Clone;
  priorityElement := TFhirRequestGroupAction(oSource).priorityElement.Clone;
  if (TFhirRequestGroupAction(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirRequestGroupAction(oSource).FCodeList);
  end;
  if (TFhirRequestGroupAction(oSource).FDocumentationList = nil) then
  begin
    FDocumentationList.free;
    FDocumentationList := nil;
  end
  else
  begin
    if FDocumentationList = nil then
      FDocumentationList := TFhirRelatedArtifactList.Create;
    FDocumentationList.Assign(TFhirRequestGroupAction(oSource).FDocumentationList);
  end;
  if (TFhirRequestGroupAction(oSource).FGoalList = nil) then
  begin
    FGoalList.free;
    FGoalList := nil;
  end
  else
  begin
    if FGoalList = nil then
      FGoalList := TFhirReferenceList.Create;
    FGoalList.Assign(TFhirRequestGroupAction(oSource).FGoalList);
  end;
  if (TFhirRequestGroupAction(oSource).FConditionList = nil) then
  begin
    FConditionList.free;
    FConditionList := nil;
  end
  else
  begin
    if FConditionList = nil then
      FConditionList := TFhirRequestGroupActionConditionList.Create;
    FConditionList.Assign(TFhirRequestGroupAction(oSource).FConditionList);
  end;
  if (TFhirRequestGroupAction(oSource).FRelatedActionList = nil) then
  begin
    FRelatedActionList.free;
    FRelatedActionList := nil;
  end
  else
  begin
    if FRelatedActionList = nil then
      FRelatedActionList := TFhirRequestGroupActionRelatedActionList.Create;
    FRelatedActionList.Assign(TFhirRequestGroupAction(oSource).FRelatedActionList);
  end;
  timing := TFhirRequestGroupAction(oSource).timing.Clone;
  location := TFhirRequestGroupAction(oSource).location.Clone;
  if (TFhirRequestGroupAction(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirRequestGroupActionParticipantList.Create;
    FParticipantList.Assign(TFhirRequestGroupAction(oSource).FParticipantList);
  end;
  type_ := TFhirRequestGroupAction(oSource).type_.Clone;
  groupingBehaviorElement := TFhirRequestGroupAction(oSource).groupingBehaviorElement.Clone;
  selectionBehaviorElement := TFhirRequestGroupAction(oSource).selectionBehaviorElement.Clone;
  requiredBehaviorElement := TFhirRequestGroupAction(oSource).requiredBehaviorElement.Clone;
  precheckBehaviorElement := TFhirRequestGroupAction(oSource).precheckBehaviorElement.Clone;
  cardinalityBehaviorElement := TFhirRequestGroupAction(oSource).cardinalityBehaviorElement.Clone;
  resource := TFhirRequestGroupAction(oSource).resource.Clone;
  if (TFhirRequestGroupAction(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirRequestGroupActionList.Create;
    FActionList.Assign(TFhirRequestGroupAction(oSource).FActionList);
  end;
end;

procedure TFhirRequestGroupAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'linkId') Then
     list.add(self.link, 'linkId', FLinkId.Link);
  if (child_name = 'prefix') Then
     list.add(self.link, 'prefix', FPrefix.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'textEquivalent') Then
     list.add(self.link, 'textEquivalent', FTextEquivalent.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'documentation') Then
    list.addAll(self, 'documentation', FDocumentationList);
  if (child_name = 'goal') Then
    list.addAll(self, 'goal', FGoalList);
  if (child_name = 'condition') Then
    list.addAll(self, 'condition', FConditionList);
  if (child_name = 'relatedAction') Then
    list.addAll(self, 'relatedAction', FRelatedActionList);
  if (child_name = 'timing[x]') or (child_name = 'timing') Then
     list.add(self.link, 'timing[x]', FTiming.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'groupingBehavior') Then
     list.add(self.link, 'groupingBehavior', FGroupingBehavior.Link);
  if (child_name = 'selectionBehavior') Then
     list.add(self.link, 'selectionBehavior', FSelectionBehavior.Link);
  if (child_name = 'requiredBehavior') Then
     list.add(self.link, 'requiredBehavior', FRequiredBehavior.Link);
  if (child_name = 'precheckBehavior') Then
     list.add(self.link, 'precheckBehavior', FPrecheckBehavior.Link);
  if (child_name = 'cardinalityBehavior') Then
     list.add(self.link, 'cardinalityBehavior', FCardinalityBehavior.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirRequestGroupAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'linkId', 'string', false, TFhirString, FLinkId.Link));
  oList.add(TFHIRProperty.create(self, 'prefix', 'string', false, TFhirString, FPrefix.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'textEquivalent', 'string', false, TFhirString, FTextEquivalent.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFhirCode, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'documentation', 'RelatedArtifact', true, TFhirRelatedArtifact, FDocumentationList.Link));
  oList.add(TFHIRProperty.create(self, 'goal', 'Reference', true, TFhirReference, FGoalList.Link));
  oList.add(TFHIRProperty.create(self, 'condition', 'BackboneElement', true, TFhirRequestGroupActionCondition, FConditionList.Link));
  oList.add(TFHIRProperty.create(self, 'relatedAction', 'BackboneElement', true, TFhirRequestGroupActionRelatedAction, FRelatedActionList.Link));
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'dateTime|Age|Period|Duration|Range|Timing', false, TFhirDataType, FTiming.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'CodeableReference', false, TFhirCodeableReference, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'participant', 'BackboneElement', true, TFhirRequestGroupActionParticipant, FParticipantList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'groupingBehavior', 'code', false, TFhirCode, FGroupingBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'selectionBehavior', 'code', false, TFhirCode, FSelectionBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'requiredBehavior', 'code', false, TFhirCode, FRequiredBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'precheckBehavior', 'code', false, TFhirCode, FPrecheckBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'cardinalityBehavior', 'code', false, TFhirCode, FCardinalityBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'resource', 'Reference', false, TFhirReference, FResource.Link));
  oList.add(TFHIRProperty.create(self, 'action', '', true, TFhirRequestGroupAction, FActionList.Link));
end;

function TFhirRequestGroupAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'linkId') then
  begin
    LinkIdElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'prefix') then
  begin
    PrefixElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'textEquivalent') then
  begin
    TextEquivalentElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationList.add(propValue as TFhirRelatedArtifact);
    result := propValue;
  end
  else if (propName = 'goal') then
  begin
    GoalList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    ConditionList.add(propValue as TFhirRequestGroupActionCondition);
    result := propValue;
  end
  else if (propName = 'relatedAction') then
  begin
    RelatedActionList.add(propValue as TFhirRequestGroupActionRelatedAction);
    result := propValue;
  end
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Age', 'Period', 'Duration', 'Range', 'Timing'])) then
  begin
    Timing := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirRequestGroupActionParticipant);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'groupingBehavior') then
  begin
    GroupingBehaviorElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'selectionBehavior') then
  begin
    SelectionBehaviorElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'requiredBehavior') then
  begin
    RequiredBehaviorElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'precheckBehavior') then
  begin
    PrecheckBehaviorElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'cardinalityBehavior') then
  begin
    CardinalityBehaviorElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    Resource := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirRequestGroupAction);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRequestGroupAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'documentation') then DocumentationList.insertItem(index, propValue as TFhirRelatedArtifact)
  else if (propName = 'goal') then GoalList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'condition') then ConditionList.insertItem(index, propValue as TFhirRequestGroupActionCondition)
  else if (propName = 'relatedAction') then RelatedActionList.insertItem(index, propValue as TFhirRequestGroupActionRelatedAction)
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirRequestGroupActionParticipant)
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirRequestGroupAction)
  else inherited;
end;

function TFhirRequestGroupAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'linkId') then result := TFhirString.create()
  else if (propName = 'prefix') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'textEquivalent') then result := TFhirString.create()
  else if (propName = 'priority') then result := TFhirCode.create()
  else if (propName = 'code') then result := CodeList.new()
  else if (propName = 'documentation') then result := DocumentationList.new()
  else if (propName = 'goal') then result := GoalList.new()
  else if (propName = 'condition') then result := ConditionList.new()
  else if (propName = 'relatedAction') then result := RelatedActionList.new()
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Age', 'Period', 'Duration', 'Range', 'Timing'])) then raise EFHIRException.create('Cannot make property Timing')
  else if (propName = 'location') then result := TFhirCodeableReference.create()
  else if (propName = 'participant') then result := ParticipantList.new()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'groupingBehavior') then result := TFhirCode.create()
  else if (propName = 'selectionBehavior') then result := TFhirCode.create()
  else if (propName = 'requiredBehavior') then result := TFhirCode.create()
  else if (propName = 'precheckBehavior') then result := TFhirCode.create()
  else if (propName = 'cardinalityBehavior') then result := TFhirCode.create()
  else if (propName = 'resource') then result := TFhirReference.create()
  else if (propName = 'action') then result := ActionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirRequestGroupAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'linkId') then result := 'string'
  else if (propName = 'prefix') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'textEquivalent') then result := 'string'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'documentation') then result := 'RelatedArtifact'
  else if (propName = 'goal') then result := 'Reference'
  else if (propName = 'condition') then result := 'BackboneElement'
  else if (propName = 'relatedAction') then result := 'BackboneElement'
  else if (propName = 'timing[x]') then result := 'dateTime|Age|Period|Duration|Range|Timing'
  else if (propName = 'location') then result := 'CodeableReference'
  else if (propName = 'participant') then result := 'BackboneElement'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'groupingBehavior') then result := 'code'
  else if (propName = 'selectionBehavior') then result := 'code'
  else if (propName = 'requiredBehavior') then result := 'code'
  else if (propName = 'precheckBehavior') then result := 'code'
  else if (propName = 'cardinalityBehavior') then result := 'code'
  else if (propName = 'resource') then result := 'Reference'
  else if (propName = 'action') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRequestGroupAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := nil
  else if (propName = 'prefix') then PrefixElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'textEquivalent') then TextEquivalentElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value)
  else if (propName = 'documentation') then deletePropertyValue('documentation', DocumentationList, value)
  else if (propName = 'goal') then deletePropertyValue('goal', GoalList, value)
  else if (propName = 'condition') then deletePropertyValue('condition', ConditionList, value)
  else if (propName = 'relatedAction') then deletePropertyValue('relatedAction', RelatedActionList, value)
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Age', 'Period', 'Duration', 'Range', 'Timing'])) then TimingElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'groupingBehavior') then GroupingBehaviorElement := nil
  else if (propName = 'selectionBehavior') then SelectionBehaviorElement := nil
  else if (propName = 'requiredBehavior') then RequiredBehaviorElement := nil
  else if (propName = 'precheckBehavior') then PrecheckBehaviorElement := nil
  else if (propName = 'cardinalityBehavior') then CardinalityBehaviorElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRequestGroupAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := asString(new)
  else if (propName = 'prefix') then PrefixElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'textEquivalent') then TextEquivalentElement := asString(new)
  else if (propName = 'priority') then PriorityElement := asCode(new)
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new)
  else if (propName = 'documentation') then replacePropertyValue('documentation', DocumentationList, existing, new)
  else if (propName = 'goal') then replacePropertyValue('goal', GoalList, existing, new)
  else if (propName = 'condition') then replacePropertyValue('condition', ConditionList, existing, new)
  else if (propName = 'relatedAction') then replacePropertyValue('relatedAction', RelatedActionList, existing, new)
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Age', 'Period', 'Duration', 'Range', 'Timing'])) then TimingElement := new as TFhirDataType
  else if (propName = 'location') then LocationElement := new as TFhirCodeableReference
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'groupingBehavior') then GroupingBehaviorElement := asCode(new)
  else if (propName = 'selectionBehavior') then SelectionBehaviorElement := asCode(new)
  else if (propName = 'requiredBehavior') then RequiredBehaviorElement := asCode(new)
  else if (propName = 'precheckBehavior') then PrecheckBehaviorElement := asCode(new)
  else if (propName = 'cardinalityBehavior') then CardinalityBehaviorElement := asCode(new)
  else if (propName = 'resource') then ResourceElement := new as TFhirReference
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRequestGroupAction.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'code') then CodeList.move(source, destination)
  else if (propName = 'documentation') then DocumentationList.move(source, destination)
  else if (propName = 'goal') then GoalList.move(source, destination)
  else if (propName = 'condition') then ConditionList.move(source, destination)
  else if (propName = 'relatedAction') then RelatedActionList.move(source, destination)
  else if (propName = 'participant') then ParticipantList.move(source, destination)
  else if (propName = 'action') then ActionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRequestGroupAction.fhirType : string;
begin
  result := 'RequestGroup.action';
end;

function TFhirRequestGroupAction.Link : TFhirRequestGroupAction;
begin
  result := TFhirRequestGroupAction(inherited Link);
end;

function TFhirRequestGroupAction.Clone : TFhirRequestGroupAction;
begin
  result := TFhirRequestGroupAction(inherited Clone);
end;

function TFhirRequestGroupAction.equals(other : TObject) : boolean; 
var
  o : TFhirRequestGroupAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRequestGroupAction)) then
    result := false
  else
  begin
    o := TFhirRequestGroupAction(other);
    result := compareDeep(linkIdElement, o.linkIdElement, true) and compareDeep(prefixElement, o.prefixElement, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(textEquivalentElement, o.textEquivalentElement, true) and compareDeep(priorityElement, o.priorityElement, true) and 
      compareDeep(codeList, o.codeList, true) and compareDeep(documentationList, o.documentationList, true) and 
      compareDeep(goalList, o.goalList, true) and compareDeep(conditionList, o.conditionList, true) and 
      compareDeep(relatedActionList, o.relatedActionList, true) and compareDeep(timingElement, o.timingElement, true) and 
      compareDeep(locationElement, o.locationElement, true) and compareDeep(participantList, o.participantList, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(groupingBehaviorElement, o.groupingBehaviorElement, true) and 
      compareDeep(selectionBehaviorElement, o.selectionBehaviorElement, true) and compareDeep(requiredBehaviorElement, o.requiredBehaviorElement, true) and 
      compareDeep(precheckBehaviorElement, o.precheckBehaviorElement, true) and compareDeep(cardinalityBehaviorElement, o.cardinalityBehaviorElement, true) and 
      compareDeep(resourceElement, o.resourceElement, true) and compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirRequestGroupAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLinkId) and isEmptyProp(FPrefix) and isEmptyProp(FTitle) and isEmptyProp(FDescription) and isEmptyProp(FTextEquivalent) and isEmptyProp(FPriority) and isEmptyProp(FcodeList) and isEmptyProp(FdocumentationList) and isEmptyProp(FgoalList) and isEmptyProp(FconditionList) and isEmptyProp(FrelatedActionList) and isEmptyProp(FTiming) and isEmptyProp(FLocation) and isEmptyProp(FparticipantList) and isEmptyProp(FType_) and isEmptyProp(FGroupingBehavior) and isEmptyProp(FSelectionBehavior) and isEmptyProp(FRequiredBehavior) and isEmptyProp(FPrecheckBehavior) and isEmptyProp(FCardinalityBehavior) and isEmptyProp(FResource) and isEmptyProp(FactionList);
end;

procedure TFhirRequestGroupAction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('linkId');
  fields.add('prefix');
  fields.add('title');
  fields.add('description');
  fields.add('textEquivalent');
  fields.add('priority');
  fields.add('code');
  fields.add('documentation');
  fields.add('goal');
  fields.add('condition');
  fields.add('relatedAction');
  fields.add('timing[x]');
  fields.add('location');
  fields.add('participant');
  fields.add('type');
  fields.add('groupingBehavior');
  fields.add('selectionBehavior');
  fields.add('requiredBehavior');
  fields.add('precheckBehavior');
  fields.add('cardinalityBehavior');
  fields.add('resource');
  fields.add('action');
end;

function TFhirRequestGroupAction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCodeList.sizeInBytes(magic));
  inc(result, FDocumentationList.sizeInBytes(magic));
  inc(result, FGoalList.sizeInBytes(magic));
  inc(result, FConditionList.sizeInBytes(magic));
  inc(result, FRelatedActionList.sizeInBytes(magic));
  inc(result, FParticipantList.sizeInBytes(magic));
  inc(result, FActionList.sizeInBytes(magic));
end;

procedure TFhirRequestGroupAction.SetLinkId(value : TFhirString);
begin
  FLinkId.free;
  FLinkId := value;
end;

function TFhirRequestGroupAction.GetLinkIdST : String;
begin
  if FLinkId = nil then
    result := ''
  else
    result := FLinkId.value;
end;

procedure TFhirRequestGroupAction.SetLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FLinkId = nil then
      FLinkId := TFhirString.create;
    FLinkId.value := value
  end
  else if FLinkId <> nil then
    FLinkId.value := '';
end;

procedure TFhirRequestGroupAction.SetPrefix(value : TFhirString);
begin
  FPrefix.free;
  FPrefix := value;
end;

function TFhirRequestGroupAction.GetPrefixST : String;
begin
  if FPrefix = nil then
    result := ''
  else
    result := FPrefix.value;
end;

procedure TFhirRequestGroupAction.SetPrefixST(value : String);
begin
  if value <> '' then
  begin
    if FPrefix = nil then
      FPrefix := TFhirString.create;
    FPrefix.value := value
  end
  else if FPrefix <> nil then
    FPrefix.value := '';
end;

procedure TFhirRequestGroupAction.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirRequestGroupAction.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirRequestGroupAction.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirRequestGroupAction.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirRequestGroupAction.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirRequestGroupAction.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirRequestGroupAction.SetTextEquivalent(value : TFhirString);
begin
  FTextEquivalent.free;
  FTextEquivalent := value;
end;

function TFhirRequestGroupAction.GetTextEquivalentST : String;
begin
  if FTextEquivalent = nil then
    result := ''
  else
    result := FTextEquivalent.value;
end;

procedure TFhirRequestGroupAction.SetTextEquivalentST(value : String);
begin
  if value <> '' then
  begin
    if FTextEquivalent = nil then
      FTextEquivalent := TFhirString.create;
    FTextEquivalent.value := value
  end
  else if FTextEquivalent <> nil then
    FTextEquivalent.value := '';
end;

procedure TFhirRequestGroupAction.SetPriority(value : TFhirCode);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirRequestGroupAction.GetPriorityST : String;
begin
  if FPriority = nil then
    result := ''
  else
    result := FPriority.value;
end;

procedure TFhirRequestGroupAction.SetPriorityST(value : String);
begin
  if value <> '' then
  begin
    if FPriority = nil then
      FPriority := TFhirCode.create;
    FPriority.value := value
  end
  else if FPriority <> nil then
    FPriority.value := '';
end;

function TFhirRequestGroupAction.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

function TFhirRequestGroupAction.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

function TFhirRequestGroupAction.GetDocumentationList : TFhirRelatedArtifactList;
begin
  if FDocumentationList = nil then
    FDocumentationList := TFhirRelatedArtifactList.Create;
  result := FDocumentationList;
end;

function TFhirRequestGroupAction.GetHasDocumentationList : boolean;
begin
  result := (FDocumentationList <> nil) and (FDocumentationList.count > 0);
end;

function TFhirRequestGroupAction.GetGoalList : TFhirReferenceList;
begin
  if FGoalList = nil then
    FGoalList := TFhirReferenceList.Create;
  result := FGoalList;
end;

function TFhirRequestGroupAction.GetHasGoalList : boolean;
begin
  result := (FGoalList <> nil) and (FGoalList.count > 0);
end;

function TFhirRequestGroupAction.GetConditionList : TFhirRequestGroupActionConditionList;
begin
  if FConditionList = nil then
    FConditionList := TFhirRequestGroupActionConditionList.Create;
  result := FConditionList;
end;

function TFhirRequestGroupAction.GetHasConditionList : boolean;
begin
  result := (FConditionList <> nil) and (FConditionList.count > 0);
end;

function TFhirRequestGroupAction.GetRelatedActionList : TFhirRequestGroupActionRelatedActionList;
begin
  if FRelatedActionList = nil then
    FRelatedActionList := TFhirRequestGroupActionRelatedActionList.Create;
  result := FRelatedActionList;
end;

function TFhirRequestGroupAction.GetHasRelatedActionList : boolean;
begin
  result := (FRelatedActionList <> nil) and (FRelatedActionList.count > 0);
end;

procedure TFhirRequestGroupAction.SetTiming(value : TFhirDataType);
begin
  FTiming.free;
  FTiming := value;
end;

procedure TFhirRequestGroupAction.SetLocation(value : TFhirCodeableReference);
begin
  FLocation.free;
  FLocation := value;
end;

function TFhirRequestGroupAction.GetParticipantList : TFhirRequestGroupActionParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirRequestGroupActionParticipantList.Create;
  result := FParticipantList;
end;

function TFhirRequestGroupAction.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

procedure TFhirRequestGroupAction.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirRequestGroupAction.SetGroupingBehavior(value : TFhirCode);
begin
  FGroupingBehavior.free;
  FGroupingBehavior := value;
end;

function TFhirRequestGroupAction.GetGroupingBehaviorST : String;
begin
  if FGroupingBehavior = nil then
    result := ''
  else
    result := FGroupingBehavior.value;
end;

procedure TFhirRequestGroupAction.SetGroupingBehaviorST(value : String);
begin
  if value <> '' then
  begin
    if FGroupingBehavior = nil then
      FGroupingBehavior := TFhirCode.create;
    FGroupingBehavior.value := value
  end
  else if FGroupingBehavior <> nil then
    FGroupingBehavior.value := '';
end;

procedure TFhirRequestGroupAction.SetSelectionBehavior(value : TFhirCode);
begin
  FSelectionBehavior.free;
  FSelectionBehavior := value;
end;

function TFhirRequestGroupAction.GetSelectionBehaviorST : String;
begin
  if FSelectionBehavior = nil then
    result := ''
  else
    result := FSelectionBehavior.value;
end;

procedure TFhirRequestGroupAction.SetSelectionBehaviorST(value : String);
begin
  if value <> '' then
  begin
    if FSelectionBehavior = nil then
      FSelectionBehavior := TFhirCode.create;
    FSelectionBehavior.value := value
  end
  else if FSelectionBehavior <> nil then
    FSelectionBehavior.value := '';
end;

procedure TFhirRequestGroupAction.SetRequiredBehavior(value : TFhirCode);
begin
  FRequiredBehavior.free;
  FRequiredBehavior := value;
end;

function TFhirRequestGroupAction.GetRequiredBehaviorST : String;
begin
  if FRequiredBehavior = nil then
    result := ''
  else
    result := FRequiredBehavior.value;
end;

procedure TFhirRequestGroupAction.SetRequiredBehaviorST(value : String);
begin
  if value <> '' then
  begin
    if FRequiredBehavior = nil then
      FRequiredBehavior := TFhirCode.create;
    FRequiredBehavior.value := value
  end
  else if FRequiredBehavior <> nil then
    FRequiredBehavior.value := '';
end;

procedure TFhirRequestGroupAction.SetPrecheckBehavior(value : TFhirCode);
begin
  FPrecheckBehavior.free;
  FPrecheckBehavior := value;
end;

function TFhirRequestGroupAction.GetPrecheckBehaviorST : String;
begin
  if FPrecheckBehavior = nil then
    result := ''
  else
    result := FPrecheckBehavior.value;
end;

procedure TFhirRequestGroupAction.SetPrecheckBehaviorST(value : String);
begin
  if value <> '' then
  begin
    if FPrecheckBehavior = nil then
      FPrecheckBehavior := TFhirCode.create;
    FPrecheckBehavior.value := value
  end
  else if FPrecheckBehavior <> nil then
    FPrecheckBehavior.value := '';
end;

procedure TFhirRequestGroupAction.SetCardinalityBehavior(value : TFhirCode);
begin
  FCardinalityBehavior.free;
  FCardinalityBehavior := value;
end;

function TFhirRequestGroupAction.GetCardinalityBehaviorST : String;
begin
  if FCardinalityBehavior = nil then
    result := ''
  else
    result := FCardinalityBehavior.value;
end;

procedure TFhirRequestGroupAction.SetCardinalityBehaviorST(value : String);
begin
  if value <> '' then
  begin
    if FCardinalityBehavior = nil then
      FCardinalityBehavior := TFhirCode.create;
    FCardinalityBehavior.value := value
  end
  else if FCardinalityBehavior <> nil then
    FCardinalityBehavior.value := '';
end;

procedure TFhirRequestGroupAction.SetResource(value : TFhirReference);
begin
  FResource.free;
  FResource := value;
end;

function TFhirRequestGroupAction.GetActionList : TFhirRequestGroupActionList;
begin
  if FActionList = nil then
    FActionList := TFhirRequestGroupActionList.Create;
  result := FActionList;
end;

function TFhirRequestGroupAction.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

{ TFhirRequestGroupActionListEnumerator }

constructor TFhirRequestGroupActionListEnumerator.Create(list : TFhirRequestGroupActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRequestGroupActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRequestGroupActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRequestGroupActionListEnumerator.GetCurrent : TFhirRequestGroupAction;
begin
  Result := FList[FIndex];
end;

function TFhirRequestGroupActionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRequestGroupActionList }

function TFhirRequestGroupActionList.AddItem(value: TFhirRequestGroupAction): TFhirRequestGroupAction;
begin
  assert(value.ClassName = 'TFhirRequestGroupAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRequestGroupAction');
  add(value);
  result := value;
end;

function TFhirRequestGroupActionList.Append: TFhirRequestGroupAction;
begin
  result := TFhirRequestGroupAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionList.ClearItems;
begin
  Clear;
end;

function TFhirRequestGroupActionList.GetEnumerator : TFhirRequestGroupActionListEnumerator;
begin
  result := TFhirRequestGroupActionListEnumerator.Create(self.link);
end;

function TFhirRequestGroupActionList.Clone: TFhirRequestGroupActionList;
begin
  result := TFhirRequestGroupActionList(inherited Clone);
end;

function TFhirRequestGroupActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRequestGroupActionList.GetItemN(index: Integer): TFhirRequestGroupAction;
begin
  result := TFhirRequestGroupAction(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirRequestGroupAction;
end;
function TFhirRequestGroupActionList.IndexOf(value: TFhirRequestGroupAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRequestGroupActionList.Insert(index: Integer): TFhirRequestGroupAction;
begin
  result := TFhirRequestGroupAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionList.InsertItem(index: Integer; value: TFhirRequestGroupAction);
begin
  assert(value is TFhirRequestGroupAction);
  Inherited Insert(index, value);
end;

function TFhirRequestGroupActionList.Item(index: Integer): TFhirRequestGroupAction;
begin
  result := TFhirRequestGroupAction(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionList.Link: TFhirRequestGroupActionList;
begin
  result := TFhirRequestGroupActionList(inherited Link);
end;

procedure TFhirRequestGroupActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRequestGroupActionList.SetItemByIndex(index: Integer; value: TFhirRequestGroupAction);
begin
  assert(value is TFhirRequestGroupAction);
  FhirRequestGroupActions[index] := value;
end;

procedure TFhirRequestGroupActionList.SetItemN(index: Integer; value: TFhirRequestGroupAction);
begin
  assert(value is TFhirRequestGroupAction);
  ObjectByIndex[index] := value;
end;

{ TFhirRequestGroupActionCondition }

constructor TFhirRequestGroupActionCondition.Create;
begin
  inherited;
end;

destructor TFhirRequestGroupActionCondition.Destroy;
begin
  FKind.free;
  FExpression.free;
  inherited;
end;

procedure TFhirRequestGroupActionCondition.Assign(oSource : TFslObject);
begin
  inherited;
  kindElement := TFhirRequestGroupActionCondition(oSource).kindElement.Clone;
  expression := TFhirRequestGroupActionCondition(oSource).expression.Clone;
end;

procedure TFhirRequestGroupActionCondition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
end;

procedure TFhirRequestGroupActionCondition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFhirCode, FKind.Link));
  oList.add(TFHIRProperty.create(self, 'expression', 'Expression', false, TFhirExpression, FExpression.Link));
end;

function TFhirRequestGroupActionCondition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'kind') then
  begin
    KindElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    Expression := propValue as TFhirExpression;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRequestGroupActionCondition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRequestGroupActionCondition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'kind') then result := TFhirCode.create()
  else if (propName = 'expression') then result := TFhirExpression.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirRequestGroupActionCondition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'kind') then result := 'code'
  else if (propName = 'expression') then result := 'Expression'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRequestGroupActionCondition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'kind') then KindElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRequestGroupActionCondition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'kind') then KindElement := asCode(new)
  else if (propName = 'expression') then ExpressionElement := new as TFhirExpression
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRequestGroupActionCondition.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRequestGroupActionCondition.fhirType : string;
begin
  result := 'RequestGroup.action.condition';
end;

function TFhirRequestGroupActionCondition.Link : TFhirRequestGroupActionCondition;
begin
  result := TFhirRequestGroupActionCondition(inherited Link);
end;

function TFhirRequestGroupActionCondition.Clone : TFhirRequestGroupActionCondition;
begin
  result := TFhirRequestGroupActionCondition(inherited Clone);
end;

function TFhirRequestGroupActionCondition.equals(other : TObject) : boolean; 
var
  o : TFhirRequestGroupActionCondition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRequestGroupActionCondition)) then
    result := false
  else
  begin
    o := TFhirRequestGroupActionCondition(other);
    result := compareDeep(kindElement, o.kindElement, true) and compareDeep(expressionElement, o.expressionElement, true);
  end;
end;

function TFhirRequestGroupActionCondition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FKind) and isEmptyProp(FExpression);
end;

procedure TFhirRequestGroupActionCondition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('kind');
  fields.add('expression');
end;

function TFhirRequestGroupActionCondition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirRequestGroupActionCondition.SetKind(value : TFhirCode);
begin
  FKind.free;
  FKind := value;
end;

function TFhirRequestGroupActionCondition.GetKindST : String;
begin
  if FKind = nil then
    result := ''
  else
    result := FKind.value;
end;

procedure TFhirRequestGroupActionCondition.SetKindST(value : String);
begin
  if value <> '' then
  begin
    if FKind = nil then
      FKind := TFhirCode.create;
    FKind.value := value
  end
  else if FKind <> nil then
    FKind.value := '';
end;

procedure TFhirRequestGroupActionCondition.SetExpression(value : TFhirExpression);
begin
  FExpression.free;
  FExpression := value;
end;

{ TFhirRequestGroupActionConditionListEnumerator }

constructor TFhirRequestGroupActionConditionListEnumerator.Create(list : TFhirRequestGroupActionConditionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRequestGroupActionConditionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRequestGroupActionConditionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRequestGroupActionConditionListEnumerator.GetCurrent : TFhirRequestGroupActionCondition;
begin
  Result := FList[FIndex];
end;

function TFhirRequestGroupActionConditionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRequestGroupActionConditionList }

function TFhirRequestGroupActionConditionList.AddItem(value: TFhirRequestGroupActionCondition): TFhirRequestGroupActionCondition;
begin
  assert(value.ClassName = 'TFhirRequestGroupActionCondition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRequestGroupActionCondition');
  add(value);
  result := value;
end;

function TFhirRequestGroupActionConditionList.Append: TFhirRequestGroupActionCondition;
begin
  result := TFhirRequestGroupActionCondition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionConditionList.ClearItems;
begin
  Clear;
end;

function TFhirRequestGroupActionConditionList.GetEnumerator : TFhirRequestGroupActionConditionListEnumerator;
begin
  result := TFhirRequestGroupActionConditionListEnumerator.Create(self.link);
end;

function TFhirRequestGroupActionConditionList.Clone: TFhirRequestGroupActionConditionList;
begin
  result := TFhirRequestGroupActionConditionList(inherited Clone);
end;

function TFhirRequestGroupActionConditionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRequestGroupActionConditionList.GetItemN(index: Integer): TFhirRequestGroupActionCondition;
begin
  result := TFhirRequestGroupActionCondition(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionConditionList.ItemClass: TFslObjectClass;
begin
  result := TFhirRequestGroupActionCondition;
end;
function TFhirRequestGroupActionConditionList.IndexOf(value: TFhirRequestGroupActionCondition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRequestGroupActionConditionList.Insert(index: Integer): TFhirRequestGroupActionCondition;
begin
  result := TFhirRequestGroupActionCondition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionConditionList.InsertItem(index: Integer; value: TFhirRequestGroupActionCondition);
begin
  assert(value is TFhirRequestGroupActionCondition);
  Inherited Insert(index, value);
end;

function TFhirRequestGroupActionConditionList.Item(index: Integer): TFhirRequestGroupActionCondition;
begin
  result := TFhirRequestGroupActionCondition(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionConditionList.Link: TFhirRequestGroupActionConditionList;
begin
  result := TFhirRequestGroupActionConditionList(inherited Link);
end;

procedure TFhirRequestGroupActionConditionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRequestGroupActionConditionList.SetItemByIndex(index: Integer; value: TFhirRequestGroupActionCondition);
begin
  assert(value is TFhirRequestGroupActionCondition);
  FhirRequestGroupActionConditions[index] := value;
end;

procedure TFhirRequestGroupActionConditionList.SetItemN(index: Integer; value: TFhirRequestGroupActionCondition);
begin
  assert(value is TFhirRequestGroupActionCondition);
  ObjectByIndex[index] := value;
end;

{ TFhirRequestGroupActionRelatedAction }

constructor TFhirRequestGroupActionRelatedAction.Create;
begin
  inherited;
end;

destructor TFhirRequestGroupActionRelatedAction.Destroy;
begin
  FTargetId.free;
  FRelationship.free;
  FOffset.free;
  inherited;
end;

procedure TFhirRequestGroupActionRelatedAction.Assign(oSource : TFslObject);
begin
  inherited;
  targetIdElement := TFhirRequestGroupActionRelatedAction(oSource).targetIdElement.Clone;
  relationshipElement := TFhirRequestGroupActionRelatedAction(oSource).relationshipElement.Clone;
  offset := TFhirRequestGroupActionRelatedAction(oSource).offset.Clone;
end;

procedure TFhirRequestGroupActionRelatedAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'targetId') Then
     list.add(self.link, 'targetId', FTargetId.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'offset[x]') or (child_name = 'offset') Then
     list.add(self.link, 'offset[x]', FOffset.Link);
end;

procedure TFhirRequestGroupActionRelatedAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'targetId', 'id', false, TFhirId, FTargetId.Link));
  oList.add(TFHIRProperty.create(self, 'relationship', 'code', false, TFhirCode, FRelationship.Link));
  oList.add(TFHIRProperty.create(self, 'offset[x]', 'Duration|Range', false, TFhirDataType, FOffset.Link));
end;

function TFhirRequestGroupActionRelatedAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'targetId') then
  begin
    TargetIdElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    RelationshipElement := asCode(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then
  begin
    Offset := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRequestGroupActionRelatedAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRequestGroupActionRelatedAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'targetId') then result := TFhirId.create()
  else if (propName = 'relationship') then result := TFhirCode.create()
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then raise EFHIRException.create('Cannot make property Offset')
  else result := inherited createPropertyValue(propName);
end;

function TFhirRequestGroupActionRelatedAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'targetId') then result := 'id'
  else if (propName = 'relationship') then result := 'code'
  else if (propName = 'offset[x]') then result := 'Duration|Range'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRequestGroupActionRelatedAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'targetId') then TargetIdElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then OffsetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRequestGroupActionRelatedAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'targetId') then TargetIdElement := asId(new)
  else if (propName = 'relationship') then RelationshipElement := asCode(new)
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then OffsetElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRequestGroupActionRelatedAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRequestGroupActionRelatedAction.fhirType : string;
begin
  result := 'RequestGroup.action.relatedAction';
end;

function TFhirRequestGroupActionRelatedAction.Link : TFhirRequestGroupActionRelatedAction;
begin
  result := TFhirRequestGroupActionRelatedAction(inherited Link);
end;

function TFhirRequestGroupActionRelatedAction.Clone : TFhirRequestGroupActionRelatedAction;
begin
  result := TFhirRequestGroupActionRelatedAction(inherited Clone);
end;

function TFhirRequestGroupActionRelatedAction.equals(other : TObject) : boolean; 
var
  o : TFhirRequestGroupActionRelatedAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRequestGroupActionRelatedAction)) then
    result := false
  else
  begin
    o := TFhirRequestGroupActionRelatedAction(other);
    result := compareDeep(targetIdElement, o.targetIdElement, true) and compareDeep(relationshipElement, o.relationshipElement, true) and 
      compareDeep(offsetElement, o.offsetElement, true);
  end;
end;

function TFhirRequestGroupActionRelatedAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTargetId) and isEmptyProp(FRelationship) and isEmptyProp(FOffset);
end;

procedure TFhirRequestGroupActionRelatedAction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('targetId');
  fields.add('relationship');
  fields.add('offset[x]');
end;

function TFhirRequestGroupActionRelatedAction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirRequestGroupActionRelatedAction.SetTargetId(value : TFhirId);
begin
  FTargetId.free;
  FTargetId := value;
end;

function TFhirRequestGroupActionRelatedAction.GetTargetIdST : String;
begin
  if FTargetId = nil then
    result := ''
  else
    result := FTargetId.value;
end;

procedure TFhirRequestGroupActionRelatedAction.SetTargetIdST(value : String);
begin
  if value <> '' then
  begin
    if FTargetId = nil then
      FTargetId := TFhirId.create;
    FTargetId.value := value
  end
  else if FTargetId <> nil then
    FTargetId.value := '';
end;

procedure TFhirRequestGroupActionRelatedAction.SetRelationship(value : TFhirCode);
begin
  FRelationship.free;
  FRelationship := value;
end;

function TFhirRequestGroupActionRelatedAction.GetRelationshipST : String;
begin
  if FRelationship = nil then
    result := ''
  else
    result := FRelationship.value;
end;

procedure TFhirRequestGroupActionRelatedAction.SetRelationshipST(value : String);
begin
  if value <> '' then
  begin
    if FRelationship = nil then
      FRelationship := TFhirCode.create;
    FRelationship.value := value
  end
  else if FRelationship <> nil then
    FRelationship.value := '';
end;

procedure TFhirRequestGroupActionRelatedAction.SetOffset(value : TFhirDataType);
begin
  FOffset.free;
  FOffset := value;
end;

{ TFhirRequestGroupActionRelatedActionListEnumerator }

constructor TFhirRequestGroupActionRelatedActionListEnumerator.Create(list : TFhirRequestGroupActionRelatedActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRequestGroupActionRelatedActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRequestGroupActionRelatedActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRequestGroupActionRelatedActionListEnumerator.GetCurrent : TFhirRequestGroupActionRelatedAction;
begin
  Result := FList[FIndex];
end;

function TFhirRequestGroupActionRelatedActionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRequestGroupActionRelatedActionList }

function TFhirRequestGroupActionRelatedActionList.AddItem(value: TFhirRequestGroupActionRelatedAction): TFhirRequestGroupActionRelatedAction;
begin
  assert(value.ClassName = 'TFhirRequestGroupActionRelatedAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRequestGroupActionRelatedAction');
  add(value);
  result := value;
end;

function TFhirRequestGroupActionRelatedActionList.Append: TFhirRequestGroupActionRelatedAction;
begin
  result := TFhirRequestGroupActionRelatedAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionRelatedActionList.ClearItems;
begin
  Clear;
end;

function TFhirRequestGroupActionRelatedActionList.GetEnumerator : TFhirRequestGroupActionRelatedActionListEnumerator;
begin
  result := TFhirRequestGroupActionRelatedActionListEnumerator.Create(self.link);
end;

function TFhirRequestGroupActionRelatedActionList.Clone: TFhirRequestGroupActionRelatedActionList;
begin
  result := TFhirRequestGroupActionRelatedActionList(inherited Clone);
end;

function TFhirRequestGroupActionRelatedActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRequestGroupActionRelatedActionList.GetItemN(index: Integer): TFhirRequestGroupActionRelatedAction;
begin
  result := TFhirRequestGroupActionRelatedAction(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionRelatedActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirRequestGroupActionRelatedAction;
end;
function TFhirRequestGroupActionRelatedActionList.IndexOf(value: TFhirRequestGroupActionRelatedAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRequestGroupActionRelatedActionList.Insert(index: Integer): TFhirRequestGroupActionRelatedAction;
begin
  result := TFhirRequestGroupActionRelatedAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionRelatedActionList.InsertItem(index: Integer; value: TFhirRequestGroupActionRelatedAction);
begin
  assert(value is TFhirRequestGroupActionRelatedAction);
  Inherited Insert(index, value);
end;

function TFhirRequestGroupActionRelatedActionList.Item(index: Integer): TFhirRequestGroupActionRelatedAction;
begin
  result := TFhirRequestGroupActionRelatedAction(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionRelatedActionList.Link: TFhirRequestGroupActionRelatedActionList;
begin
  result := TFhirRequestGroupActionRelatedActionList(inherited Link);
end;

procedure TFhirRequestGroupActionRelatedActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRequestGroupActionRelatedActionList.SetItemByIndex(index: Integer; value: TFhirRequestGroupActionRelatedAction);
begin
  assert(value is TFhirRequestGroupActionRelatedAction);
  FhirRequestGroupActionRelatedActions[index] := value;
end;

procedure TFhirRequestGroupActionRelatedActionList.SetItemN(index: Integer; value: TFhirRequestGroupActionRelatedAction);
begin
  assert(value is TFhirRequestGroupActionRelatedAction);
  ObjectByIndex[index] := value;
end;

{ TFhirRequestGroupActionParticipant }

constructor TFhirRequestGroupActionParticipant.Create;
begin
  inherited;
end;

destructor TFhirRequestGroupActionParticipant.Destroy;
begin
  FType_.free;
  FTypeReference.free;
  FRole.free;
  FFunction_.free;
  FActor.free;
  inherited;
end;

procedure TFhirRequestGroupActionParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirRequestGroupActionParticipant(oSource).type_Element.Clone;
  typeReference := TFhirRequestGroupActionParticipant(oSource).typeReference.Clone;
  role := TFhirRequestGroupActionParticipant(oSource).role.Clone;
  function_ := TFhirRequestGroupActionParticipant(oSource).function_.Clone;
  actor := TFhirRequestGroupActionParticipant(oSource).actor.Clone;
end;

procedure TFhirRequestGroupActionParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'typeReference') Then
     list.add(self.link, 'typeReference', FTypeReference.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'function') Then
     list.add(self.link, 'function', FFunction_.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
end;

procedure TFhirRequestGroupActionParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirCode, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'typeReference', 'Reference', false, TFhirReference, FTypeReference.Link));
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));
  oList.add(TFHIRProperty.create(self, 'function', 'CodeableConcept', false, TFhirCodeableConcept, FFunction_.Link));
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference', false, TFhirReference, FActor.Link));
end;

function TFhirRequestGroupActionParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'typeReference') then
  begin
    TypeReference := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'function') then
  begin
    Function_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRequestGroupActionParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRequestGroupActionParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCode.create()
  else if (propName = 'typeReference') then result := TFhirReference.create()
  else if (propName = 'role') then result := TFhirCodeableConcept.create()
  else if (propName = 'function') then result := TFhirCodeableConcept.create()
  else if (propName = 'actor') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirRequestGroupActionParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'typeReference') then result := 'Reference'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'function') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRequestGroupActionParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'typeReference') then TypeReferenceElement := nil
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'function') then Function_Element := nil
  else if (propName = 'actor') then ActorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRequestGroupActionParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asCode(new)
  else if (propName = 'typeReference') then TypeReferenceElement := new as TFhirReference
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept
  else if (propName = 'function') then Function_Element := new as TFhirCodeableConcept
  else if (propName = 'actor') then ActorElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRequestGroupActionParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRequestGroupActionParticipant.fhirType : string;
begin
  result := 'RequestGroup.action.participant';
end;

function TFhirRequestGroupActionParticipant.Link : TFhirRequestGroupActionParticipant;
begin
  result := TFhirRequestGroupActionParticipant(inherited Link);
end;

function TFhirRequestGroupActionParticipant.Clone : TFhirRequestGroupActionParticipant;
begin
  result := TFhirRequestGroupActionParticipant(inherited Clone);
end;

function TFhirRequestGroupActionParticipant.equals(other : TObject) : boolean; 
var
  o : TFhirRequestGroupActionParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRequestGroupActionParticipant)) then
    result := false
  else
  begin
    o := TFhirRequestGroupActionParticipant(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(typeReferenceElement, o.typeReferenceElement, true) and 
      compareDeep(roleElement, o.roleElement, true) and compareDeep(function_Element, o.function_Element, true) and 
      compareDeep(actorElement, o.actorElement, true);
  end;
end;

function TFhirRequestGroupActionParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FTypeReference) and isEmptyProp(FRole) and isEmptyProp(FFunction_) and isEmptyProp(FActor);
end;

procedure TFhirRequestGroupActionParticipant.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('typeReference');
  fields.add('role');
  fields.add('function');
  fields.add('actor');
end;

function TFhirRequestGroupActionParticipant.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirRequestGroupActionParticipant.SetType_(value : TFhirCode);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirRequestGroupActionParticipant.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := FType_.value;
end;

procedure TFhirRequestGroupActionParticipant.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirCode.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

procedure TFhirRequestGroupActionParticipant.SetTypeReference(value : TFhirReference);
begin
  FTypeReference.free;
  FTypeReference := value;
end;

procedure TFhirRequestGroupActionParticipant.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

procedure TFhirRequestGroupActionParticipant.SetFunction_(value : TFhirCodeableConcept);
begin
  FFunction_.free;
  FFunction_ := value;
end;

procedure TFhirRequestGroupActionParticipant.SetActor(value : TFhirReference);
begin
  FActor.free;
  FActor := value;
end;

{ TFhirRequestGroupActionParticipantListEnumerator }

constructor TFhirRequestGroupActionParticipantListEnumerator.Create(list : TFhirRequestGroupActionParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRequestGroupActionParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRequestGroupActionParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRequestGroupActionParticipantListEnumerator.GetCurrent : TFhirRequestGroupActionParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirRequestGroupActionParticipantListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRequestGroupActionParticipantList }

function TFhirRequestGroupActionParticipantList.AddItem(value: TFhirRequestGroupActionParticipant): TFhirRequestGroupActionParticipant;
begin
  assert(value.ClassName = 'TFhirRequestGroupActionParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRequestGroupActionParticipant');
  add(value);
  result := value;
end;

function TFhirRequestGroupActionParticipantList.Append: TFhirRequestGroupActionParticipant;
begin
  result := TFhirRequestGroupActionParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirRequestGroupActionParticipantList.GetEnumerator : TFhirRequestGroupActionParticipantListEnumerator;
begin
  result := TFhirRequestGroupActionParticipantListEnumerator.Create(self.link);
end;

function TFhirRequestGroupActionParticipantList.Clone: TFhirRequestGroupActionParticipantList;
begin
  result := TFhirRequestGroupActionParticipantList(inherited Clone);
end;

function TFhirRequestGroupActionParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRequestGroupActionParticipantList.GetItemN(index: Integer): TFhirRequestGroupActionParticipant;
begin
  result := TFhirRequestGroupActionParticipant(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirRequestGroupActionParticipant;
end;
function TFhirRequestGroupActionParticipantList.IndexOf(value: TFhirRequestGroupActionParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRequestGroupActionParticipantList.Insert(index: Integer): TFhirRequestGroupActionParticipant;
begin
  result := TFhirRequestGroupActionParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionParticipantList.InsertItem(index: Integer; value: TFhirRequestGroupActionParticipant);
begin
  assert(value is TFhirRequestGroupActionParticipant);
  Inherited Insert(index, value);
end;

function TFhirRequestGroupActionParticipantList.Item(index: Integer): TFhirRequestGroupActionParticipant;
begin
  result := TFhirRequestGroupActionParticipant(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionParticipantList.Link: TFhirRequestGroupActionParticipantList;
begin
  result := TFhirRequestGroupActionParticipantList(inherited Link);
end;

procedure TFhirRequestGroupActionParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRequestGroupActionParticipantList.SetItemByIndex(index: Integer; value: TFhirRequestGroupActionParticipant);
begin
  assert(value is TFhirRequestGroupActionParticipant);
  FhirRequestGroupActionParticipants[index] := value;
end;

procedure TFhirRequestGroupActionParticipantList.SetItemN(index: Integer; value: TFhirRequestGroupActionParticipant);
begin
  assert(value is TFhirRequestGroupActionParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirRequestGroup }

constructor TFhirRequestGroup.Create;
begin
  inherited;
end;

destructor TFhirRequestGroup.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FBasedOnList.Free;
  FReplacesList.Free;
  FGroupIdentifier.free;
  FStatus.free;
  FIntent.free;
  FPriority.free;
  FCode.free;
  FSubject.free;
  FEncounter.free;
  FAuthoredOn.free;
  FAuthor.free;
  FReasonList.Free;
  FGoalList.Free;
  FNoteList.Free;
  FActionList.Free;
  inherited;
end;

procedure TFhirRequestGroup.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirRequestGroup(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirRequestGroup(oSource).FIdentifierList);
  end;
  if (TFhirRequestGroup(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirRequestGroup(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirRequestGroup(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirRequestGroup(oSource).FInstantiatesUriList);
  end;
  if (TFhirRequestGroup(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirRequestGroup(oSource).FBasedOnList);
  end;
  if (TFhirRequestGroup(oSource).FReplacesList = nil) then
  begin
    FReplacesList.free;
    FReplacesList := nil;
  end
  else
  begin
    if FReplacesList = nil then
      FReplacesList := TFhirReferenceList.Create;
    FReplacesList.Assign(TFhirRequestGroup(oSource).FReplacesList);
  end;
  groupIdentifier := TFhirRequestGroup(oSource).groupIdentifier.Clone;
  statusElement := TFhirRequestGroup(oSource).statusElement.Clone;
  intentElement := TFhirRequestGroup(oSource).intentElement.Clone;
  priorityElement := TFhirRequestGroup(oSource).priorityElement.Clone;
  code := TFhirRequestGroup(oSource).code.Clone;
  subject := TFhirRequestGroup(oSource).subject.Clone;
  encounter := TFhirRequestGroup(oSource).encounter.Clone;
  authoredOnElement := TFhirRequestGroup(oSource).authoredOnElement.Clone;
  author := TFhirRequestGroup(oSource).author.Clone;
  if (TFhirRequestGroup(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableReferenceList.Create;
    FReasonList.Assign(TFhirRequestGroup(oSource).FReasonList);
  end;
  if (TFhirRequestGroup(oSource).FGoalList = nil) then
  begin
    FGoalList.free;
    FGoalList := nil;
  end
  else
  begin
    if FGoalList = nil then
      FGoalList := TFhirReferenceList.Create;
    FGoalList.Assign(TFhirRequestGroup(oSource).FGoalList);
  end;
  if (TFhirRequestGroup(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirRequestGroup(oSource).FNoteList);
  end;
  if (TFhirRequestGroup(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirRequestGroupActionList.Create;
    FActionList.Assign(TFhirRequestGroup(oSource).FActionList);
  end;
end;

function TFhirRequestGroup.GetResourceType : TFhirResourceType;
begin
  result := frtRequestGroup;
end;

procedure TFhirRequestGroup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'replaces') Then
    list.addAll(self, 'replaces', FReplacesList);
  if (child_name = 'groupIdentifier') Then
     list.add(self.link, 'groupIdentifier', FGroupIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'authoredOn') Then
     list.add(self.link, 'authoredOn', FAuthoredOn.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'goal') Then
    list.addAll(self, 'goal', FGoalList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirRequestGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link));
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.create(self, 'replaces', 'Reference', true, TFhirReference, FReplacesList.Link));
  oList.add(TFHIRProperty.create(self, 'groupIdentifier', 'Identifier', false, TFhirIdentifier, FGroupIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirCode, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'intent', 'code', false, TFhirCode, FIntent.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFhirCode, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'authoredOn', 'dateTime', false, TFhirDateTime, FAuthoredOn.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', false, TFhirReference, FAuthor.Link));
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableReference', true, TFhirCodeableReference, FReasonList.Link));
  oList.add(TFHIRProperty.create(self, 'goal', 'Reference', true, TFhirReference, FGoalList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'action', 'BackboneElement', true, TFhirRequestGroupAction, FActionList.Link));
end;

function TFhirRequestGroup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'replaces') then
  begin
    ReplacesList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'groupIdentifier') then
  begin
    GroupIdentifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'intent') then
  begin
    IntentElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'authoredOn') then
  begin
    AuthoredOnElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableReference);
    result := propValue;
  end
  else if (propName = 'goal') then
  begin
    GoalList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirRequestGroupAction);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRequestGroup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue))
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue))
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'replaces') then ReplacesList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableReference)
  else if (propName = 'goal') then GoalList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirRequestGroupAction)
  else inherited;
end;

function TFhirRequestGroup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new()
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'replaces') then result := ReplacesList.new()
  else if (propName = 'groupIdentifier') then result := TFhirIdentifier.create()
  else if (propName = 'status') then result := TFhirCode.create()
  else if (propName = 'intent') then result := TFhirCode.create()
  else if (propName = 'priority') then result := TFhirCode.create()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (propName = 'authoredOn') then result := TFhirDateTime.create()
  else if (propName = 'author') then result := TFhirReference.create()
  else if (propName = 'reason') then result := ReasonList.new()
  else if (propName = 'goal') then result := GoalList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'action') then result := ActionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirRequestGroup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'replaces') then result := 'Reference'
  else if (propName = 'groupIdentifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'intent') then result := 'code'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'authoredOn') then result := 'dateTime'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'reason') then result := 'CodeableReference'
  else if (propName = 'goal') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'action') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRequestGroup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value)
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value)
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'replaces') then deletePropertyValue('replaces', ReplacesList, value)
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'authoredOn') then AuthoredOnElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value)
  else if (propName = 'goal') then deletePropertyValue('goal', GoalList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRequestGroup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new)
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new)
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'replaces') then replacePropertyValue('replaces', ReplacesList, existing, new)
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := new as TFhirIdentifier
  else if (propName = 'status') then StatusElement := asCode(new)
  else if (propName = 'intent') then IntentElement := asCode(new)
  else if (propName = 'priority') then PriorityElement := asCode(new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (propName = 'authoredOn') then AuthoredOnElement := asDateTime(new)
  else if (propName = 'author') then AuthorElement := new as TFhirReference
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new)
  else if (propName = 'goal') then replacePropertyValue('goal', GoalList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRequestGroup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination)
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination)
  else if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'replaces') then ReplacesList.move(source, destination)
  else if (propName = 'reason') then ReasonList.move(source, destination)
  else if (propName = 'goal') then GoalList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'action') then ActionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRequestGroup.fhirType : string;
begin
  result := 'RequestGroup';
end;

function TFhirRequestGroup.Link : TFhirRequestGroup;
begin
  result := TFhirRequestGroup(inherited Link);
end;

function TFhirRequestGroup.Clone : TFhirRequestGroup;
begin
  result := TFhirRequestGroup(inherited Clone);
end;

function TFhirRequestGroup.equals(other : TObject) : boolean; 
var
  o : TFhirRequestGroup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRequestGroup)) then
    result := false
  else
  begin
    o := TFhirRequestGroup(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(replacesList, o.replacesList, true) and compareDeep(groupIdentifierElement, o.groupIdentifierElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(intentElement, o.intentElement, true) and 
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(authoredOnElement, o.authoredOnElement, true) and compareDeep(authorElement, o.authorElement, true) and 
      compareDeep(reasonList, o.reasonList, true) and compareDeep(goalList, o.goalList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirRequestGroup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FbasedOnList) and isEmptyProp(FreplacesList) and isEmptyProp(FGroupIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FIntent) and isEmptyProp(FPriority) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FAuthoredOn) and isEmptyProp(FAuthor) and isEmptyProp(FreasonList) and isEmptyProp(FgoalList) and isEmptyProp(FnoteList) and isEmptyProp(FactionList);
end;

procedure TFhirRequestGroup.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('basedOn');
  fields.add('replaces');
  fields.add('groupIdentifier');
  fields.add('status');
  fields.add('intent');
  fields.add('priority');
  fields.add('code');
  fields.add('subject');
  fields.add('encounter');
  fields.add('authoredOn');
  fields.add('author');
  fields.add('reason');
  fields.add('goal');
  fields.add('note');
  fields.add('action');
end;

function TFhirRequestGroup.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FInstantiatesCanonicalList.sizeInBytes(magic));
  inc(result, FInstantiatesUriList.sizeInBytes(magic));
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FReplacesList.sizeInBytes(magic));
  inc(result, FReasonList.sizeInBytes(magic));
  inc(result, FGoalList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FActionList.sizeInBytes(magic));
end;

function TFhirRequestGroup.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirRequestGroup.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirRequestGroup.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

function TFhirRequestGroup.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

function TFhirRequestGroup.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

function TFhirRequestGroup.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

function TFhirRequestGroup.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirRequestGroup.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirRequestGroup.GetReplacesList : TFhirReferenceList;
begin
  if FReplacesList = nil then
    FReplacesList := TFhirReferenceList.Create;
  result := FReplacesList;
end;

function TFhirRequestGroup.GetHasReplacesList : boolean;
begin
  result := (FReplacesList <> nil) and (FReplacesList.count > 0);
end;

procedure TFhirRequestGroup.SetGroupIdentifier(value : TFhirIdentifier);
begin
  FGroupIdentifier.free;
  FGroupIdentifier := value;
end;

procedure TFhirRequestGroup.SetStatus(value : TFhirCode);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirRequestGroup.GetStatusST : String;
begin
  if FStatus = nil then
    result := ''
  else
    result := FStatus.value;
end;

procedure TFhirRequestGroup.SetStatusST(value : String);
begin
  if value <> '' then
  begin
    if FStatus = nil then
      FStatus := TFhirCode.create;
    FStatus.value := value
  end
  else if FStatus <> nil then
    FStatus.value := '';
end;

procedure TFhirRequestGroup.SetIntent(value : TFhirCode);
begin
  FIntent.free;
  FIntent := value;
end;

function TFhirRequestGroup.GetIntentST : String;
begin
  if FIntent = nil then
    result := ''
  else
    result := FIntent.value;
end;

procedure TFhirRequestGroup.SetIntentST(value : String);
begin
  if value <> '' then
  begin
    if FIntent = nil then
      FIntent := TFhirCode.create;
    FIntent.value := value
  end
  else if FIntent <> nil then
    FIntent.value := '';
end;

procedure TFhirRequestGroup.SetPriority(value : TFhirCode);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirRequestGroup.GetPriorityST : String;
begin
  if FPriority = nil then
    result := ''
  else
    result := FPriority.value;
end;

procedure TFhirRequestGroup.SetPriorityST(value : String);
begin
  if value <> '' then
  begin
    if FPriority = nil then
      FPriority := TFhirCode.create;
    FPriority.value := value
  end
  else if FPriority <> nil then
    FPriority.value := '';
end;

procedure TFhirRequestGroup.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirRequestGroup.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirRequestGroup.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirRequestGroup.SetAuthoredOn(value : TFhirDateTime);
begin
  FAuthoredOn.free;
  FAuthoredOn := value;
end;

function TFhirRequestGroup.GetAuthoredOnST : TFslDateTime;
begin
  if FAuthoredOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoredOn.value;
end;

procedure TFhirRequestGroup.SetAuthoredOnST(value : TFslDateTime);
begin
  if FAuthoredOn = nil then
    FAuthoredOn := TFhirDateTime.create;
  FAuthoredOn.value := value
end;

procedure TFhirRequestGroup.SetAuthor(value : TFhirReference);
begin
  FAuthor.free;
  FAuthor := value;
end;

function TFhirRequestGroup.GetReasonList : TFhirCodeableReferenceList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableReferenceList.Create;
  result := FReasonList;
end;

function TFhirRequestGroup.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirRequestGroup.GetGoalList : TFhirReferenceList;
begin
  if FGoalList = nil then
    FGoalList := TFhirReferenceList.Create;
  result := FGoalList;
end;

function TFhirRequestGroup.GetHasGoalList : boolean;
begin
  result := (FGoalList <> nil) and (FGoalList.count > 0);
end;

function TFhirRequestGroup.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirRequestGroup.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirRequestGroup.GetActionList : TFhirRequestGroupActionList;
begin
  if FActionList = nil then
    FActionList := TFhirRequestGroupActionList.Create;
  result := FActionList;
end;

function TFhirRequestGroup.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

{ TFhirRequestGroupListEnumerator }

constructor TFhirRequestGroupListEnumerator.Create(list : TFhirRequestGroupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRequestGroupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRequestGroupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRequestGroupListEnumerator.GetCurrent : TFhirRequestGroup;
begin
  Result := FList[FIndex];
end;

function TFhirRequestGroupListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRequestGroupList }

function TFhirRequestGroupList.AddItem(value: TFhirRequestGroup): TFhirRequestGroup;
begin
  assert(value.ClassName = 'TFhirRequestGroup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRequestGroup');
  add(value);
  result := value;
end;

function TFhirRequestGroupList.Append: TFhirRequestGroup;
begin
  result := TFhirRequestGroup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupList.ClearItems;
begin
  Clear;
end;

function TFhirRequestGroupList.GetEnumerator : TFhirRequestGroupListEnumerator;
begin
  result := TFhirRequestGroupListEnumerator.Create(self.link);
end;

function TFhirRequestGroupList.Clone: TFhirRequestGroupList;
begin
  result := TFhirRequestGroupList(inherited Clone);
end;

function TFhirRequestGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRequestGroupList.GetItemN(index: Integer): TFhirRequestGroup;
begin
  result := TFhirRequestGroup(ObjectByIndex[index]);
end;

function TFhirRequestGroupList.ItemClass: TFslObjectClass;
begin
  result := TFhirRequestGroup;
end;
function TFhirRequestGroupList.IndexOf(value: TFhirRequestGroup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRequestGroupList.Insert(index: Integer): TFhirRequestGroup;
begin
  result := TFhirRequestGroup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupList.InsertItem(index: Integer; value: TFhirRequestGroup);
begin
  assert(value is TFhirRequestGroup);
  Inherited Insert(index, value);
end;

function TFhirRequestGroupList.Item(index: Integer): TFhirRequestGroup;
begin
  result := TFhirRequestGroup(ObjectByIndex[index]);
end;

function TFhirRequestGroupList.Link: TFhirRequestGroupList;
begin
  result := TFhirRequestGroupList(inherited Link);
end;

procedure TFhirRequestGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRequestGroupList.SetItemByIndex(index: Integer; value: TFhirRequestGroup);
begin
  assert(value is TFhirRequestGroup);
  FhirRequestGroups[index] := value;
end;

procedure TFhirRequestGroupList.SetItemN(index: Integer; value: TFhirRequestGroup);
begin
  assert(value is TFhirRequestGroup);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_REQUESTORCHESTRATION}
{ TFhirRequestOrchestrationAction }

constructor TFhirRequestOrchestrationAction.Create;
begin
  inherited;
end;

destructor TFhirRequestOrchestrationAction.Destroy;
begin
  FLinkId.free;
  FPrefix.free;
  FTitle.free;
  FDescription.free;
  FTextEquivalent.free;
  FPriority.free;
  FCodeList.Free;
  FDocumentationList.Free;
  FGoalList.Free;
  FConditionList.Free;
  FInputList.Free;
  FOutputList.Free;
  FRelatedActionList.Free;
  FTiming.free;
  FLocation.free;
  FParticipantList.Free;
  FType_.free;
  FGroupingBehavior.free;
  FSelectionBehavior.free;
  FRequiredBehavior.free;
  FPrecheckBehavior.free;
  FCardinalityBehavior.free;
  FResource.free;
  FDefinition.free;
  FTransform.free;
  FDynamicValueList.Free;
  FActionList.Free;
  inherited;
end;

procedure TFhirRequestOrchestrationAction.Assign(oSource : TFslObject);
begin
  inherited;
  linkIdElement := TFhirRequestOrchestrationAction(oSource).linkIdElement.Clone;
  prefixElement := TFhirRequestOrchestrationAction(oSource).prefixElement.Clone;
  titleElement := TFhirRequestOrchestrationAction(oSource).titleElement.Clone;
  descriptionElement := TFhirRequestOrchestrationAction(oSource).descriptionElement.Clone;
  textEquivalentElement := TFhirRequestOrchestrationAction(oSource).textEquivalentElement.Clone;
  priorityElement := TFhirRequestOrchestrationAction(oSource).priorityElement.Clone;
  if (TFhirRequestOrchestrationAction(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirRequestOrchestrationAction(oSource).FCodeList);
  end;
  if (TFhirRequestOrchestrationAction(oSource).FDocumentationList = nil) then
  begin
    FDocumentationList.free;
    FDocumentationList := nil;
  end
  else
  begin
    if FDocumentationList = nil then
      FDocumentationList := TFhirRelatedArtifactList.Create;
    FDocumentationList.Assign(TFhirRequestOrchestrationAction(oSource).FDocumentationList);
  end;
  if (TFhirRequestOrchestrationAction(oSource).FGoalList = nil) then
  begin
    FGoalList.free;
    FGoalList := nil;
  end
  else
  begin
    if FGoalList = nil then
      FGoalList := TFhirReferenceList.Create;
    FGoalList.Assign(TFhirRequestOrchestrationAction(oSource).FGoalList);
  end;
  if (TFhirRequestOrchestrationAction(oSource).FConditionList = nil) then
  begin
    FConditionList.free;
    FConditionList := nil;
  end
  else
  begin
    if FConditionList = nil then
      FConditionList := TFhirRequestOrchestrationActionConditionList.Create;
    FConditionList.Assign(TFhirRequestOrchestrationAction(oSource).FConditionList);
  end;
  if (TFhirRequestOrchestrationAction(oSource).FInputList = nil) then
  begin
    FInputList.free;
    FInputList := nil;
  end
  else
  begin
    if FInputList = nil then
      FInputList := TFhirRequestOrchestrationActionInputList.Create;
    FInputList.Assign(TFhirRequestOrchestrationAction(oSource).FInputList);
  end;
  if (TFhirRequestOrchestrationAction(oSource).FOutputList = nil) then
  begin
    FOutputList.free;
    FOutputList := nil;
  end
  else
  begin
    if FOutputList = nil then
      FOutputList := TFhirRequestOrchestrationActionOutputList.Create;
    FOutputList.Assign(TFhirRequestOrchestrationAction(oSource).FOutputList);
  end;
  if (TFhirRequestOrchestrationAction(oSource).FRelatedActionList = nil) then
  begin
    FRelatedActionList.free;
    FRelatedActionList := nil;
  end
  else
  begin
    if FRelatedActionList = nil then
      FRelatedActionList := TFhirRequestOrchestrationActionRelatedActionList.Create;
    FRelatedActionList.Assign(TFhirRequestOrchestrationAction(oSource).FRelatedActionList);
  end;
  timing := TFhirRequestOrchestrationAction(oSource).timing.Clone;
  location := TFhirRequestOrchestrationAction(oSource).location.Clone;
  if (TFhirRequestOrchestrationAction(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirRequestOrchestrationActionParticipantList.Create;
    FParticipantList.Assign(TFhirRequestOrchestrationAction(oSource).FParticipantList);
  end;
  type_ := TFhirRequestOrchestrationAction(oSource).type_.Clone;
  groupingBehaviorElement := TFhirRequestOrchestrationAction(oSource).groupingBehaviorElement.Clone;
  selectionBehaviorElement := TFhirRequestOrchestrationAction(oSource).selectionBehaviorElement.Clone;
  requiredBehaviorElement := TFhirRequestOrchestrationAction(oSource).requiredBehaviorElement.Clone;
  precheckBehaviorElement := TFhirRequestOrchestrationAction(oSource).precheckBehaviorElement.Clone;
  cardinalityBehaviorElement := TFhirRequestOrchestrationAction(oSource).cardinalityBehaviorElement.Clone;
  resource := TFhirRequestOrchestrationAction(oSource).resource.Clone;
  definition := TFhirRequestOrchestrationAction(oSource).definition.Clone;
  transformElement := TFhirRequestOrchestrationAction(oSource).transformElement.Clone;
  if (TFhirRequestOrchestrationAction(oSource).FDynamicValueList = nil) then
  begin
    FDynamicValueList.free;
    FDynamicValueList := nil;
  end
  else
  begin
    if FDynamicValueList = nil then
      FDynamicValueList := TFhirRequestOrchestrationActionDynamicValueList.Create;
    FDynamicValueList.Assign(TFhirRequestOrchestrationAction(oSource).FDynamicValueList);
  end;
  if (TFhirRequestOrchestrationAction(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirRequestOrchestrationActionList.Create;
    FActionList.Assign(TFhirRequestOrchestrationAction(oSource).FActionList);
  end;
end;

procedure TFhirRequestOrchestrationAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'linkId') Then
     list.add(self.link, 'linkId', FLinkId.Link);
  if (child_name = 'prefix') Then
     list.add(self.link, 'prefix', FPrefix.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'textEquivalent') Then
     list.add(self.link, 'textEquivalent', FTextEquivalent.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'documentation') Then
    list.addAll(self, 'documentation', FDocumentationList);
  if (child_name = 'goal') Then
    list.addAll(self, 'goal', FGoalList);
  if (child_name = 'condition') Then
    list.addAll(self, 'condition', FConditionList);
  if (child_name = 'input') Then
    list.addAll(self, 'input', FInputList);
  if (child_name = 'output') Then
    list.addAll(self, 'output', FOutputList);
  if (child_name = 'relatedAction') Then
    list.addAll(self, 'relatedAction', FRelatedActionList);
  if (child_name = 'timing[x]') or (child_name = 'timing') Then
     list.add(self.link, 'timing[x]', FTiming.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'groupingBehavior') Then
     list.add(self.link, 'groupingBehavior', FGroupingBehavior.Link);
  if (child_name = 'selectionBehavior') Then
     list.add(self.link, 'selectionBehavior', FSelectionBehavior.Link);
  if (child_name = 'requiredBehavior') Then
     list.add(self.link, 'requiredBehavior', FRequiredBehavior.Link);
  if (child_name = 'precheckBehavior') Then
     list.add(self.link, 'precheckBehavior', FPrecheckBehavior.Link);
  if (child_name = 'cardinalityBehavior') Then
     list.add(self.link, 'cardinalityBehavior', FCardinalityBehavior.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'definition[x]') or (child_name = 'definition') Then
     list.add(self.link, 'definition[x]', FDefinition.Link);
  if (child_name = 'transform') Then
     list.add(self.link, 'transform', FTransform.Link);
  if (child_name = 'dynamicValue') Then
    list.addAll(self, 'dynamicValue', FDynamicValueList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirRequestOrchestrationAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'linkId', 'string', false, TFhirString, FLinkId.Link));
  oList.add(TFHIRProperty.create(self, 'prefix', 'string', false, TFhirString, FPrefix.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'textEquivalent', 'string', false, TFhirString, FTextEquivalent.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFhirEnum, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'documentation', 'RelatedArtifact', true, TFhirRelatedArtifact, FDocumentationList.Link));
  oList.add(TFHIRProperty.create(self, 'goal', 'Reference', true, TFhirReference, FGoalList.Link));
  oList.add(TFHIRProperty.create(self, 'condition', 'BackboneElement', true, TFhirRequestOrchestrationActionCondition, FConditionList.Link));
  oList.add(TFHIRProperty.create(self, 'input', 'BackboneElement', true, TFhirRequestOrchestrationActionInput, FInputList.Link));
  oList.add(TFHIRProperty.create(self, 'output', 'BackboneElement', true, TFhirRequestOrchestrationActionOutput, FOutputList.Link));
  oList.add(TFHIRProperty.create(self, 'relatedAction', 'BackboneElement', true, TFhirRequestOrchestrationActionRelatedAction, FRelatedActionList.Link));
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'dateTime|Age|Period|Duration|Range|Timing', false, TFhirDataType, FTiming.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'CodeableReference', false, TFhirCodeableReference, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'participant', 'BackboneElement', true, TFhirRequestOrchestrationActionParticipant, FParticipantList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'groupingBehavior', 'code', false, TFhirEnum, FGroupingBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'selectionBehavior', 'code', false, TFhirEnum, FSelectionBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'requiredBehavior', 'code', false, TFhirEnum, FRequiredBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'precheckBehavior', 'code', false, TFhirEnum, FPrecheckBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'cardinalityBehavior', 'code', false, TFhirEnum, FCardinalityBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'resource', 'Reference', false, TFhirReference, FResource.Link));
  oList.add(TFHIRProperty.create(self, 'definition[x]', 'canonical|uri', false, TFhirDataType, FDefinition.Link));
  oList.add(TFHIRProperty.create(self, 'transform', 'canonical', false, TFhirCanonical, FTransform.Link));
  oList.add(TFHIRProperty.create(self, 'dynamicValue', 'BackboneElement', true, TFhirRequestOrchestrationActionDynamicValue, FDynamicValueList.Link));
  oList.add(TFHIRProperty.create(self, 'action', '', true, TFhirRequestOrchestrationAction, FActionList.Link));
end;

function TFhirRequestOrchestrationAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'linkId') then
  begin
    LinkIdElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'prefix') then
  begin
    PrefixElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'textEquivalent') then
  begin
    TextEquivalentElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationList.add(propValue as TFhirRelatedArtifact);
    result := propValue;
  end
  else if (propName = 'goal') then
  begin
    GoalList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    ConditionList.add(propValue as TFhirRequestOrchestrationActionCondition);
    result := propValue;
  end
  else if (propName = 'input') then
  begin
    InputList.add(propValue as TFhirRequestOrchestrationActionInput);
    result := propValue;
  end
  else if (propName = 'output') then
  begin
    OutputList.add(propValue as TFhirRequestOrchestrationActionOutput);
    result := propValue;
  end
  else if (propName = 'relatedAction') then
  begin
    RelatedActionList.add(propValue as TFhirRequestOrchestrationActionRelatedAction);
    result := propValue;
  end
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Age', 'Period', 'Duration', 'Range', 'Timing'])) then
  begin
    Timing := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirRequestOrchestrationActionParticipant);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'groupingBehavior') then
  begin
    GroupingBehaviorElement := asEnum(SYSTEMS_TFhirActionGroupingBehaviorEnum, CODES_TFhirActionGroupingBehaviorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'selectionBehavior') then
  begin
    SelectionBehaviorElement := asEnum(SYSTEMS_TFhirActionSelectionBehaviorEnum, CODES_TFhirActionSelectionBehaviorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'requiredBehavior') then
  begin
    RequiredBehaviorElement := asEnum(SYSTEMS_TFhirActionRequiredBehaviorEnum, CODES_TFhirActionRequiredBehaviorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'precheckBehavior') then
  begin
    PrecheckBehaviorElement := asEnum(SYSTEMS_TFhirActionPrecheckBehaviorEnum, CODES_TFhirActionPrecheckBehaviorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'cardinalityBehavior') then
  begin
    CardinalityBehaviorElement := asEnum(SYSTEMS_TFhirActionCardinalityBehaviorEnum, CODES_TFhirActionCardinalityBehaviorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    Resource := propValue as TFhirReference;
    result := propValue;
  end
  else if (isMatchingName(propName, 'definition', ['Canonical', 'Uri'])) then
  begin
    Definition := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'transform') then
  begin
    TransformElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'dynamicValue') then
  begin
    DynamicValueList.add(propValue as TFhirRequestOrchestrationActionDynamicValue);
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirRequestOrchestrationAction);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRequestOrchestrationAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'documentation') then DocumentationList.insertItem(index, propValue as TFhirRelatedArtifact)
  else if (propName = 'goal') then GoalList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'condition') then ConditionList.insertItem(index, propValue as TFhirRequestOrchestrationActionCondition)
  else if (propName = 'input') then InputList.insertItem(index, propValue as TFhirRequestOrchestrationActionInput)
  else if (propName = 'output') then OutputList.insertItem(index, propValue as TFhirRequestOrchestrationActionOutput)
  else if (propName = 'relatedAction') then RelatedActionList.insertItem(index, propValue as TFhirRequestOrchestrationActionRelatedAction)
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirRequestOrchestrationActionParticipant)
  else if (propName = 'dynamicValue') then DynamicValueList.insertItem(index, propValue as TFhirRequestOrchestrationActionDynamicValue)
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirRequestOrchestrationAction)
  else inherited;
end;

function TFhirRequestOrchestrationAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'linkId') then result := TFhirString.create()
  else if (propName = 'prefix') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'textEquivalent') then result := TFhirString.create()
  else if (propName = 'priority') then result := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[RequestPriorityNull], CODES_TFhirRequestPriorityEnum[RequestPriorityNull]) 
  else if (propName = 'code') then result := CodeList.new()
  else if (propName = 'documentation') then result := DocumentationList.new()
  else if (propName = 'goal') then result := GoalList.new()
  else if (propName = 'condition') then result := ConditionList.new()
  else if (propName = 'input') then result := InputList.new()
  else if (propName = 'output') then result := OutputList.new()
  else if (propName = 'relatedAction') then result := RelatedActionList.new()
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Age', 'Period', 'Duration', 'Range', 'Timing'])) then raise EFHIRException.create('Cannot make property Timing')
  else if (propName = 'location') then result := TFhirCodeableReference.create()
  else if (propName = 'participant') then result := ParticipantList.new()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'groupingBehavior') then result := TFhirEnum.create(SYSTEMS_TFhirActionGroupingBehaviorEnum[ActionGroupingBehaviorNull], CODES_TFhirActionGroupingBehaviorEnum[ActionGroupingBehaviorNull]) 
  else if (propName = 'selectionBehavior') then result := TFhirEnum.create(SYSTEMS_TFhirActionSelectionBehaviorEnum[ActionSelectionBehaviorNull], CODES_TFhirActionSelectionBehaviorEnum[ActionSelectionBehaviorNull]) 
  else if (propName = 'requiredBehavior') then result := TFhirEnum.create(SYSTEMS_TFhirActionRequiredBehaviorEnum[ActionRequiredBehaviorNull], CODES_TFhirActionRequiredBehaviorEnum[ActionRequiredBehaviorNull]) 
  else if (propName = 'precheckBehavior') then result := TFhirEnum.create(SYSTEMS_TFhirActionPrecheckBehaviorEnum[ActionPrecheckBehaviorNull], CODES_TFhirActionPrecheckBehaviorEnum[ActionPrecheckBehaviorNull]) 
  else if (propName = 'cardinalityBehavior') then result := TFhirEnum.create(SYSTEMS_TFhirActionCardinalityBehaviorEnum[ActionCardinalityBehaviorNull], CODES_TFhirActionCardinalityBehaviorEnum[ActionCardinalityBehaviorNull]) 
  else if (propName = 'resource') then result := TFhirReference.create()
  else if (isMatchingName(propName, 'definition', ['Canonical', 'Uri'])) then raise EFHIRException.create('Cannot make property Definition')
  else if (propName = 'transform') then result := TFhirCanonical.create()
  else if (propName = 'dynamicValue') then result := DynamicValueList.new()
  else if (propName = 'action') then result := ActionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirRequestOrchestrationAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'linkId') then result := 'string'
  else if (propName = 'prefix') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'textEquivalent') then result := 'string'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'documentation') then result := 'RelatedArtifact'
  else if (propName = 'goal') then result := 'Reference'
  else if (propName = 'condition') then result := 'BackboneElement'
  else if (propName = 'input') then result := 'BackboneElement'
  else if (propName = 'output') then result := 'BackboneElement'
  else if (propName = 'relatedAction') then result := 'BackboneElement'
  else if (propName = 'timing[x]') then result := 'dateTime|Age|Period|Duration|Range|Timing'
  else if (propName = 'location') then result := 'CodeableReference'
  else if (propName = 'participant') then result := 'BackboneElement'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'groupingBehavior') then result := 'code'
  else if (propName = 'selectionBehavior') then result := 'code'
  else if (propName = 'requiredBehavior') then result := 'code'
  else if (propName = 'precheckBehavior') then result := 'code'
  else if (propName = 'cardinalityBehavior') then result := 'code'
  else if (propName = 'resource') then result := 'Reference'
  else if (propName = 'definition[x]') then result := 'canonical|uri'
  else if (propName = 'transform') then result := 'canonical'
  else if (propName = 'dynamicValue') then result := 'BackboneElement'
  else if (propName = 'action') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRequestOrchestrationAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := nil
  else if (propName = 'prefix') then PrefixElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'textEquivalent') then TextEquivalentElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value)
  else if (propName = 'documentation') then deletePropertyValue('documentation', DocumentationList, value)
  else if (propName = 'goal') then deletePropertyValue('goal', GoalList, value)
  else if (propName = 'condition') then deletePropertyValue('condition', ConditionList, value)
  else if (propName = 'input') then deletePropertyValue('input', InputList, value)
  else if (propName = 'output') then deletePropertyValue('output', OutputList, value)
  else if (propName = 'relatedAction') then deletePropertyValue('relatedAction', RelatedActionList, value)
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Age', 'Period', 'Duration', 'Range', 'Timing'])) then TimingElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'groupingBehavior') then GroupingBehaviorElement := nil
  else if (propName = 'selectionBehavior') then SelectionBehaviorElement := nil
  else if (propName = 'requiredBehavior') then RequiredBehaviorElement := nil
  else if (propName = 'precheckBehavior') then PrecheckBehaviorElement := nil
  else if (propName = 'cardinalityBehavior') then CardinalityBehaviorElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else if (isMatchingName(propName, 'definition', ['Canonical', 'Uri'])) then DefinitionElement := nil
  else if (propName = 'transform') then TransformElement := nil
  else if (propName = 'dynamicValue') then deletePropertyValue('dynamicValue', DynamicValueList, value)
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRequestOrchestrationAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := asString(new)
  else if (propName = 'prefix') then PrefixElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'textEquivalent') then TextEquivalentElement := asString(new)
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new)
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new)
  else if (propName = 'documentation') then replacePropertyValue('documentation', DocumentationList, existing, new)
  else if (propName = 'goal') then replacePropertyValue('goal', GoalList, existing, new)
  else if (propName = 'condition') then replacePropertyValue('condition', ConditionList, existing, new)
  else if (propName = 'input') then replacePropertyValue('input', InputList, existing, new)
  else if (propName = 'output') then replacePropertyValue('output', OutputList, existing, new)
  else if (propName = 'relatedAction') then replacePropertyValue('relatedAction', RelatedActionList, existing, new)
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Age', 'Period', 'Duration', 'Range', 'Timing'])) then TimingElement := new as TFhirDataType
  else if (propName = 'location') then LocationElement := new as TFhirCodeableReference
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'groupingBehavior') then GroupingBehaviorElement := asEnum(SYSTEMS_TFhirActionGroupingBehaviorEnum, CODES_TFhirActionGroupingBehaviorEnum, new)
  else if (propName = 'selectionBehavior') then SelectionBehaviorElement := asEnum(SYSTEMS_TFhirActionSelectionBehaviorEnum, CODES_TFhirActionSelectionBehaviorEnum, new)
  else if (propName = 'requiredBehavior') then RequiredBehaviorElement := asEnum(SYSTEMS_TFhirActionRequiredBehaviorEnum, CODES_TFhirActionRequiredBehaviorEnum, new)
  else if (propName = 'precheckBehavior') then PrecheckBehaviorElement := asEnum(SYSTEMS_TFhirActionPrecheckBehaviorEnum, CODES_TFhirActionPrecheckBehaviorEnum, new)
  else if (propName = 'cardinalityBehavior') then CardinalityBehaviorElement := asEnum(SYSTEMS_TFhirActionCardinalityBehaviorEnum, CODES_TFhirActionCardinalityBehaviorEnum, new)
  else if (propName = 'resource') then ResourceElement := new as TFhirReference
  else if (isMatchingName(propName, 'definition', ['Canonical', 'Uri'])) then DefinitionElement := new as TFhirDataType
  else if (propName = 'transform') then TransformElement := asCanonical(new)
  else if (propName = 'dynamicValue') then replacePropertyValue('dynamicValue', DynamicValueList, existing, new)
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRequestOrchestrationAction.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'code') then CodeList.move(source, destination)
  else if (propName = 'documentation') then DocumentationList.move(source, destination)
  else if (propName = 'goal') then GoalList.move(source, destination)
  else if (propName = 'condition') then ConditionList.move(source, destination)
  else if (propName = 'input') then InputList.move(source, destination)
  else if (propName = 'output') then OutputList.move(source, destination)
  else if (propName = 'relatedAction') then RelatedActionList.move(source, destination)
  else if (propName = 'participant') then ParticipantList.move(source, destination)
  else if (propName = 'dynamicValue') then DynamicValueList.move(source, destination)
  else if (propName = 'action') then ActionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRequestOrchestrationAction.fhirType : string;
begin
  result := 'RequestOrchestration.action';
end;

function TFhirRequestOrchestrationAction.Link : TFhirRequestOrchestrationAction;
begin
  result := TFhirRequestOrchestrationAction(inherited Link);
end;

function TFhirRequestOrchestrationAction.Clone : TFhirRequestOrchestrationAction;
begin
  result := TFhirRequestOrchestrationAction(inherited Clone);
end;

function TFhirRequestOrchestrationAction.equals(other : TObject) : boolean; 
var
  o : TFhirRequestOrchestrationAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRequestOrchestrationAction)) then
    result := false
  else
  begin
    o := TFhirRequestOrchestrationAction(other);
    result := compareDeep(linkIdElement, o.linkIdElement, true) and compareDeep(prefixElement, o.prefixElement, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(textEquivalentElement, o.textEquivalentElement, true) and compareDeep(priorityElement, o.priorityElement, true) and 
      compareDeep(codeList, o.codeList, true) and compareDeep(documentationList, o.documentationList, true) and 
      compareDeep(goalList, o.goalList, true) and compareDeep(conditionList, o.conditionList, true) and 
      compareDeep(inputList, o.inputList, true) and compareDeep(outputList, o.outputList, true) and 
      compareDeep(relatedActionList, o.relatedActionList, true) and compareDeep(timingElement, o.timingElement, true) and 
      compareDeep(locationElement, o.locationElement, true) and compareDeep(participantList, o.participantList, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(groupingBehaviorElement, o.groupingBehaviorElement, true) and 
      compareDeep(selectionBehaviorElement, o.selectionBehaviorElement, true) and compareDeep(requiredBehaviorElement, o.requiredBehaviorElement, true) and 
      compareDeep(precheckBehaviorElement, o.precheckBehaviorElement, true) and compareDeep(cardinalityBehaviorElement, o.cardinalityBehaviorElement, true) and 
      compareDeep(resourceElement, o.resourceElement, true) and compareDeep(definitionElement, o.definitionElement, true) and 
      compareDeep(transformElement, o.transformElement, true) and compareDeep(dynamicValueList, o.dynamicValueList, true) and 
      compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirRequestOrchestrationAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLinkId) and isEmptyProp(FPrefix) and isEmptyProp(FTitle) and isEmptyProp(FDescription) and isEmptyProp(FTextEquivalent) and isEmptyProp(FPriority) and isEmptyProp(FcodeList) and isEmptyProp(FdocumentationList) and isEmptyProp(FgoalList) and isEmptyProp(FconditionList) and isEmptyProp(FinputList) and isEmptyProp(FoutputList) and isEmptyProp(FrelatedActionList) and isEmptyProp(FTiming) and isEmptyProp(FLocation) and isEmptyProp(FparticipantList) and isEmptyProp(FType_) and isEmptyProp(FGroupingBehavior) and isEmptyProp(FSelectionBehavior) and isEmptyProp(FRequiredBehavior) and isEmptyProp(FPrecheckBehavior) and isEmptyProp(FCardinalityBehavior) and isEmptyProp(FResource) and isEmptyProp(FDefinition) and isEmptyProp(FTransform) and isEmptyProp(FdynamicValueList) and isEmptyProp(FactionList);
end;

procedure TFhirRequestOrchestrationAction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('linkId');
  fields.add('prefix');
  fields.add('title');
  fields.add('description');
  fields.add('textEquivalent');
  fields.add('priority');
  fields.add('code');
  fields.add('documentation');
  fields.add('goal');
  fields.add('condition');
  fields.add('input');
  fields.add('output');
  fields.add('relatedAction');
  fields.add('timing[x]');
  fields.add('location');
  fields.add('participant');
  fields.add('type');
  fields.add('groupingBehavior');
  fields.add('selectionBehavior');
  fields.add('requiredBehavior');
  fields.add('precheckBehavior');
  fields.add('cardinalityBehavior');
  fields.add('resource');
  fields.add('definition[x]');
  fields.add('transform');
  fields.add('dynamicValue');
  fields.add('action');
end;

function TFhirRequestOrchestrationAction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCodeList.sizeInBytes(magic));
  inc(result, FDocumentationList.sizeInBytes(magic));
  inc(result, FGoalList.sizeInBytes(magic));
  inc(result, FConditionList.sizeInBytes(magic));
  inc(result, FInputList.sizeInBytes(magic));
  inc(result, FOutputList.sizeInBytes(magic));
  inc(result, FRelatedActionList.sizeInBytes(magic));
  inc(result, FParticipantList.sizeInBytes(magic));
  inc(result, FDynamicValueList.sizeInBytes(magic));
  inc(result, FActionList.sizeInBytes(magic));
end;

procedure TFhirRequestOrchestrationAction.SetLinkId(value : TFhirString);
begin
  FLinkId.free;
  FLinkId := value;
end;

function TFhirRequestOrchestrationAction.GetLinkIdST : String;
begin
  if FLinkId = nil then
    result := ''
  else
    result := FLinkId.value;
end;

procedure TFhirRequestOrchestrationAction.SetLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FLinkId = nil then
      FLinkId := TFhirString.create;
    FLinkId.value := value
  end
  else if FLinkId <> nil then
    FLinkId.value := '';
end;

procedure TFhirRequestOrchestrationAction.SetPrefix(value : TFhirString);
begin
  FPrefix.free;
  FPrefix := value;
end;

function TFhirRequestOrchestrationAction.GetPrefixST : String;
begin
  if FPrefix = nil then
    result := ''
  else
    result := FPrefix.value;
end;

procedure TFhirRequestOrchestrationAction.SetPrefixST(value : String);
begin
  if value <> '' then
  begin
    if FPrefix = nil then
      FPrefix := TFhirString.create;
    FPrefix.value := value
  end
  else if FPrefix <> nil then
    FPrefix.value := '';
end;

procedure TFhirRequestOrchestrationAction.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirRequestOrchestrationAction.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirRequestOrchestrationAction.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirRequestOrchestrationAction.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirRequestOrchestrationAction.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirRequestOrchestrationAction.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirRequestOrchestrationAction.SetTextEquivalent(value : TFhirString);
begin
  FTextEquivalent.free;
  FTextEquivalent := value;
end;

function TFhirRequestOrchestrationAction.GetTextEquivalentST : String;
begin
  if FTextEquivalent = nil then
    result := ''
  else
    result := FTextEquivalent.value;
end;

procedure TFhirRequestOrchestrationAction.SetTextEquivalentST(value : String);
begin
  if value <> '' then
  begin
    if FTextEquivalent = nil then
      FTextEquivalent := TFhirString.create;
    FTextEquivalent.value := value
  end
  else if FTextEquivalent <> nil then
    FTextEquivalent.value := '';
end;

procedure TFhirRequestOrchestrationAction.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirRequestOrchestrationAction.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

procedure TFhirRequestOrchestrationAction.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

function TFhirRequestOrchestrationAction.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

function TFhirRequestOrchestrationAction.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

function TFhirRequestOrchestrationAction.GetDocumentationList : TFhirRelatedArtifactList;
begin
  if FDocumentationList = nil then
    FDocumentationList := TFhirRelatedArtifactList.Create;
  result := FDocumentationList;
end;

function TFhirRequestOrchestrationAction.GetHasDocumentationList : boolean;
begin
  result := (FDocumentationList <> nil) and (FDocumentationList.count > 0);
end;

function TFhirRequestOrchestrationAction.GetGoalList : TFhirReferenceList;
begin
  if FGoalList = nil then
    FGoalList := TFhirReferenceList.Create;
  result := FGoalList;
end;

function TFhirRequestOrchestrationAction.GetHasGoalList : boolean;
begin
  result := (FGoalList <> nil) and (FGoalList.count > 0);
end;

function TFhirRequestOrchestrationAction.GetConditionList : TFhirRequestOrchestrationActionConditionList;
begin
  if FConditionList = nil then
    FConditionList := TFhirRequestOrchestrationActionConditionList.Create;
  result := FConditionList;
end;

function TFhirRequestOrchestrationAction.GetHasConditionList : boolean;
begin
  result := (FConditionList <> nil) and (FConditionList.count > 0);
end;

function TFhirRequestOrchestrationAction.GetInputList : TFhirRequestOrchestrationActionInputList;
begin
  if FInputList = nil then
    FInputList := TFhirRequestOrchestrationActionInputList.Create;
  result := FInputList;
end;

function TFhirRequestOrchestrationAction.GetHasInputList : boolean;
begin
  result := (FInputList <> nil) and (FInputList.count > 0);
end;

function TFhirRequestOrchestrationAction.GetOutputList : TFhirRequestOrchestrationActionOutputList;
begin
  if FOutputList = nil then
    FOutputList := TFhirRequestOrchestrationActionOutputList.Create;
  result := FOutputList;
end;

function TFhirRequestOrchestrationAction.GetHasOutputList : boolean;
begin
  result := (FOutputList <> nil) and (FOutputList.count > 0);
end;

function TFhirRequestOrchestrationAction.GetRelatedActionList : TFhirRequestOrchestrationActionRelatedActionList;
begin
  if FRelatedActionList = nil then
    FRelatedActionList := TFhirRequestOrchestrationActionRelatedActionList.Create;
  result := FRelatedActionList;
end;

function TFhirRequestOrchestrationAction.GetHasRelatedActionList : boolean;
begin
  result := (FRelatedActionList <> nil) and (FRelatedActionList.count > 0);
end;

procedure TFhirRequestOrchestrationAction.SetTiming(value : TFhirDataType);
begin
  FTiming.free;
  FTiming := value;
end;

procedure TFhirRequestOrchestrationAction.SetLocation(value : TFhirCodeableReference);
begin
  FLocation.free;
  FLocation := value;
end;

function TFhirRequestOrchestrationAction.GetParticipantList : TFhirRequestOrchestrationActionParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirRequestOrchestrationActionParticipantList.Create;
  result := FParticipantList;
end;

function TFhirRequestOrchestrationAction.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

procedure TFhirRequestOrchestrationAction.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirRequestOrchestrationAction.SetGroupingBehavior(value : TFhirEnum);
begin
  FGroupingBehavior.free;
  FGroupingBehavior := value;
end;

function TFhirRequestOrchestrationAction.GetGroupingBehaviorST : TFhirActionGroupingBehaviorEnum;
begin
  if FGroupingBehavior = nil then
    result := TFhirActionGroupingBehaviorEnum(0)
  else
    result := TFhirActionGroupingBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionGroupingBehaviorEnum, FGroupingBehavior.value));
end;

procedure TFhirRequestOrchestrationAction.SetGroupingBehaviorST(value : TFhirActionGroupingBehaviorEnum);
begin
  if ord(value) = 0 then
    GroupingBehaviorElement := nil
  else
    GroupingBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionGroupingBehaviorEnum[value], CODES_TFhirActionGroupingBehaviorEnum[value]);
end;

procedure TFhirRequestOrchestrationAction.SetSelectionBehavior(value : TFhirEnum);
begin
  FSelectionBehavior.free;
  FSelectionBehavior := value;
end;

function TFhirRequestOrchestrationAction.GetSelectionBehaviorST : TFhirActionSelectionBehaviorEnum;
begin
  if FSelectionBehavior = nil then
    result := TFhirActionSelectionBehaviorEnum(0)
  else
    result := TFhirActionSelectionBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionSelectionBehaviorEnum, FSelectionBehavior.value));
end;

procedure TFhirRequestOrchestrationAction.SetSelectionBehaviorST(value : TFhirActionSelectionBehaviorEnum);
begin
  if ord(value) = 0 then
    SelectionBehaviorElement := nil
  else
    SelectionBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionSelectionBehaviorEnum[value], CODES_TFhirActionSelectionBehaviorEnum[value]);
end;

procedure TFhirRequestOrchestrationAction.SetRequiredBehavior(value : TFhirEnum);
begin
  FRequiredBehavior.free;
  FRequiredBehavior := value;
end;

function TFhirRequestOrchestrationAction.GetRequiredBehaviorST : TFhirActionRequiredBehaviorEnum;
begin
  if FRequiredBehavior = nil then
    result := TFhirActionRequiredBehaviorEnum(0)
  else
    result := TFhirActionRequiredBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionRequiredBehaviorEnum, FRequiredBehavior.value));
end;

procedure TFhirRequestOrchestrationAction.SetRequiredBehaviorST(value : TFhirActionRequiredBehaviorEnum);
begin
  if ord(value) = 0 then
    RequiredBehaviorElement := nil
  else
    RequiredBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionRequiredBehaviorEnum[value], CODES_TFhirActionRequiredBehaviorEnum[value]);
end;

procedure TFhirRequestOrchestrationAction.SetPrecheckBehavior(value : TFhirEnum);
begin
  FPrecheckBehavior.free;
  FPrecheckBehavior := value;
end;

function TFhirRequestOrchestrationAction.GetPrecheckBehaviorST : TFhirActionPrecheckBehaviorEnum;
begin
  if FPrecheckBehavior = nil then
    result := TFhirActionPrecheckBehaviorEnum(0)
  else
    result := TFhirActionPrecheckBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionPrecheckBehaviorEnum, FPrecheckBehavior.value));
end;

procedure TFhirRequestOrchestrationAction.SetPrecheckBehaviorST(value : TFhirActionPrecheckBehaviorEnum);
begin
  if ord(value) = 0 then
    PrecheckBehaviorElement := nil
  else
    PrecheckBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionPrecheckBehaviorEnum[value], CODES_TFhirActionPrecheckBehaviorEnum[value]);
end;

procedure TFhirRequestOrchestrationAction.SetCardinalityBehavior(value : TFhirEnum);
begin
  FCardinalityBehavior.free;
  FCardinalityBehavior := value;
end;

function TFhirRequestOrchestrationAction.GetCardinalityBehaviorST : TFhirActionCardinalityBehaviorEnum;
begin
  if FCardinalityBehavior = nil then
    result := TFhirActionCardinalityBehaviorEnum(0)
  else
    result := TFhirActionCardinalityBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionCardinalityBehaviorEnum, FCardinalityBehavior.value));
end;

procedure TFhirRequestOrchestrationAction.SetCardinalityBehaviorST(value : TFhirActionCardinalityBehaviorEnum);
begin
  if ord(value) = 0 then
    CardinalityBehaviorElement := nil
  else
    CardinalityBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionCardinalityBehaviorEnum[value], CODES_TFhirActionCardinalityBehaviorEnum[value]);
end;

procedure TFhirRequestOrchestrationAction.SetResource(value : TFhirReference);
begin
  FResource.free;
  FResource := value;
end;

procedure TFhirRequestOrchestrationAction.SetDefinition(value : TFhirDataType);
begin
  FDefinition.free;
  FDefinition := value;
end;

procedure TFhirRequestOrchestrationAction.SetTransform(value : TFhirCanonical);
begin
  FTransform.free;
  FTransform := value;
end;

function TFhirRequestOrchestrationAction.GetTransformST : String;
begin
  if FTransform = nil then
    result := ''
  else
    result := FTransform.value;
end;

procedure TFhirRequestOrchestrationAction.SetTransformST(value : String);
begin
  if value <> '' then
  begin
    if FTransform = nil then
      FTransform := TFhirCanonical.create;
    FTransform.value := value
  end
  else if FTransform <> nil then
    FTransform.value := '';
end;

function TFhirRequestOrchestrationAction.GetDynamicValueList : TFhirRequestOrchestrationActionDynamicValueList;
begin
  if FDynamicValueList = nil then
    FDynamicValueList := TFhirRequestOrchestrationActionDynamicValueList.Create;
  result := FDynamicValueList;
end;

function TFhirRequestOrchestrationAction.GetHasDynamicValueList : boolean;
begin
  result := (FDynamicValueList <> nil) and (FDynamicValueList.count > 0);
end;

function TFhirRequestOrchestrationAction.GetActionList : TFhirRequestOrchestrationActionList;
begin
  if FActionList = nil then
    FActionList := TFhirRequestOrchestrationActionList.Create;
  result := FActionList;
end;

function TFhirRequestOrchestrationAction.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

{ TFhirRequestOrchestrationActionListEnumerator }

constructor TFhirRequestOrchestrationActionListEnumerator.Create(list : TFhirRequestOrchestrationActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRequestOrchestrationActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRequestOrchestrationActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRequestOrchestrationActionListEnumerator.GetCurrent : TFhirRequestOrchestrationAction;
begin
  Result := FList[FIndex];
end;

function TFhirRequestOrchestrationActionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRequestOrchestrationActionList }

function TFhirRequestOrchestrationActionList.AddItem(value: TFhirRequestOrchestrationAction): TFhirRequestOrchestrationAction;
begin
  assert(value.ClassName = 'TFhirRequestOrchestrationAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRequestOrchestrationAction');
  add(value);
  result := value;
end;

function TFhirRequestOrchestrationActionList.Append: TFhirRequestOrchestrationAction;
begin
  result := TFhirRequestOrchestrationAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestOrchestrationActionList.ClearItems;
begin
  Clear;
end;

function TFhirRequestOrchestrationActionList.GetEnumerator : TFhirRequestOrchestrationActionListEnumerator;
begin
  result := TFhirRequestOrchestrationActionListEnumerator.Create(self.link);
end;

function TFhirRequestOrchestrationActionList.Clone: TFhirRequestOrchestrationActionList;
begin
  result := TFhirRequestOrchestrationActionList(inherited Clone);
end;

function TFhirRequestOrchestrationActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRequestOrchestrationActionList.GetItemN(index: Integer): TFhirRequestOrchestrationAction;
begin
  result := TFhirRequestOrchestrationAction(ObjectByIndex[index]);
end;

function TFhirRequestOrchestrationActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirRequestOrchestrationAction;
end;
function TFhirRequestOrchestrationActionList.IndexOf(value: TFhirRequestOrchestrationAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRequestOrchestrationActionList.Insert(index: Integer): TFhirRequestOrchestrationAction;
begin
  result := TFhirRequestOrchestrationAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestOrchestrationActionList.InsertItem(index: Integer; value: TFhirRequestOrchestrationAction);
begin
  assert(value is TFhirRequestOrchestrationAction);
  Inherited Insert(index, value);
end;

function TFhirRequestOrchestrationActionList.Item(index: Integer): TFhirRequestOrchestrationAction;
begin
  result := TFhirRequestOrchestrationAction(ObjectByIndex[index]);
end;

function TFhirRequestOrchestrationActionList.Link: TFhirRequestOrchestrationActionList;
begin
  result := TFhirRequestOrchestrationActionList(inherited Link);
end;

procedure TFhirRequestOrchestrationActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRequestOrchestrationActionList.SetItemByIndex(index: Integer; value: TFhirRequestOrchestrationAction);
begin
  assert(value is TFhirRequestOrchestrationAction);
  FhirRequestOrchestrationActions[index] := value;
end;

procedure TFhirRequestOrchestrationActionList.SetItemN(index: Integer; value: TFhirRequestOrchestrationAction);
begin
  assert(value is TFhirRequestOrchestrationAction);
  ObjectByIndex[index] := value;
end;

{ TFhirRequestOrchestrationActionCondition }

constructor TFhirRequestOrchestrationActionCondition.Create;
begin
  inherited;
end;

destructor TFhirRequestOrchestrationActionCondition.Destroy;
begin
  FKind.free;
  FExpression.free;
  inherited;
end;

procedure TFhirRequestOrchestrationActionCondition.Assign(oSource : TFslObject);
begin
  inherited;
  kindElement := TFhirRequestOrchestrationActionCondition(oSource).kindElement.Clone;
  expression := TFhirRequestOrchestrationActionCondition(oSource).expression.Clone;
end;

procedure TFhirRequestOrchestrationActionCondition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
end;

procedure TFhirRequestOrchestrationActionCondition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFhirEnum, FKind.Link));
  oList.add(TFHIRProperty.create(self, 'expression', 'Expression', false, TFhirExpression, FExpression.Link));
end;

function TFhirRequestOrchestrationActionCondition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirActionConditionKindEnum, CODES_TFhirActionConditionKindEnum, propValue);
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    Expression := propValue as TFhirExpression;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRequestOrchestrationActionCondition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRequestOrchestrationActionCondition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'kind') then result := TFhirEnum.create(SYSTEMS_TFhirActionConditionKindEnum[ActionConditionKindNull], CODES_TFhirActionConditionKindEnum[ActionConditionKindNull]) 
  else if (propName = 'expression') then result := TFhirExpression.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirRequestOrchestrationActionCondition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'kind') then result := 'code'
  else if (propName = 'expression') then result := 'Expression'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRequestOrchestrationActionCondition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'kind') then KindElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRequestOrchestrationActionCondition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirActionConditionKindEnum, CODES_TFhirActionConditionKindEnum, new)
  else if (propName = 'expression') then ExpressionElement := new as TFhirExpression
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRequestOrchestrationActionCondition.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRequestOrchestrationActionCondition.fhirType : string;
begin
  result := 'RequestOrchestration.action.condition';
end;

function TFhirRequestOrchestrationActionCondition.Link : TFhirRequestOrchestrationActionCondition;
begin
  result := TFhirRequestOrchestrationActionCondition(inherited Link);
end;

function TFhirRequestOrchestrationActionCondition.Clone : TFhirRequestOrchestrationActionCondition;
begin
  result := TFhirRequestOrchestrationActionCondition(inherited Clone);
end;

function TFhirRequestOrchestrationActionCondition.equals(other : TObject) : boolean; 
var
  o : TFhirRequestOrchestrationActionCondition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRequestOrchestrationActionCondition)) then
    result := false
  else
  begin
    o := TFhirRequestOrchestrationActionCondition(other);
    result := compareDeep(kindElement, o.kindElement, true) and compareDeep(expressionElement, o.expressionElement, true);
  end;
end;

function TFhirRequestOrchestrationActionCondition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FKind) and isEmptyProp(FExpression);
end;

procedure TFhirRequestOrchestrationActionCondition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('kind');
  fields.add('expression');
end;

function TFhirRequestOrchestrationActionCondition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirRequestOrchestrationActionCondition.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

function TFhirRequestOrchestrationActionCondition.GetKindST : TFhirActionConditionKindEnum;
begin
  if FKind = nil then
    result := TFhirActionConditionKindEnum(0)
  else
    result := TFhirActionConditionKindEnum(StringArrayIndexOfSensitive(CODES_TFhirActionConditionKindEnum, FKind.value));
end;

procedure TFhirRequestOrchestrationActionCondition.SetKindST(value : TFhirActionConditionKindEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirActionConditionKindEnum[value], CODES_TFhirActionConditionKindEnum[value]);
end;

procedure TFhirRequestOrchestrationActionCondition.SetExpression(value : TFhirExpression);
begin
  FExpression.free;
  FExpression := value;
end;

{ TFhirRequestOrchestrationActionConditionListEnumerator }

constructor TFhirRequestOrchestrationActionConditionListEnumerator.Create(list : TFhirRequestOrchestrationActionConditionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRequestOrchestrationActionConditionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRequestOrchestrationActionConditionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRequestOrchestrationActionConditionListEnumerator.GetCurrent : TFhirRequestOrchestrationActionCondition;
begin
  Result := FList[FIndex];
end;

function TFhirRequestOrchestrationActionConditionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRequestOrchestrationActionConditionList }

function TFhirRequestOrchestrationActionConditionList.AddItem(value: TFhirRequestOrchestrationActionCondition): TFhirRequestOrchestrationActionCondition;
begin
  assert(value.ClassName = 'TFhirRequestOrchestrationActionCondition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRequestOrchestrationActionCondition');
  add(value);
  result := value;
end;

function TFhirRequestOrchestrationActionConditionList.Append: TFhirRequestOrchestrationActionCondition;
begin
  result := TFhirRequestOrchestrationActionCondition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestOrchestrationActionConditionList.ClearItems;
begin
  Clear;
end;

function TFhirRequestOrchestrationActionConditionList.GetEnumerator : TFhirRequestOrchestrationActionConditionListEnumerator;
begin
  result := TFhirRequestOrchestrationActionConditionListEnumerator.Create(self.link);
end;

function TFhirRequestOrchestrationActionConditionList.Clone: TFhirRequestOrchestrationActionConditionList;
begin
  result := TFhirRequestOrchestrationActionConditionList(inherited Clone);
end;

function TFhirRequestOrchestrationActionConditionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRequestOrchestrationActionConditionList.GetItemN(index: Integer): TFhirRequestOrchestrationActionCondition;
begin
  result := TFhirRequestOrchestrationActionCondition(ObjectByIndex[index]);
end;

function TFhirRequestOrchestrationActionConditionList.ItemClass: TFslObjectClass;
begin
  result := TFhirRequestOrchestrationActionCondition;
end;
function TFhirRequestOrchestrationActionConditionList.IndexOf(value: TFhirRequestOrchestrationActionCondition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRequestOrchestrationActionConditionList.Insert(index: Integer): TFhirRequestOrchestrationActionCondition;
begin
  result := TFhirRequestOrchestrationActionCondition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestOrchestrationActionConditionList.InsertItem(index: Integer; value: TFhirRequestOrchestrationActionCondition);
begin
  assert(value is TFhirRequestOrchestrationActionCondition);
  Inherited Insert(index, value);
end;

function TFhirRequestOrchestrationActionConditionList.Item(index: Integer): TFhirRequestOrchestrationActionCondition;
begin
  result := TFhirRequestOrchestrationActionCondition(ObjectByIndex[index]);
end;

function TFhirRequestOrchestrationActionConditionList.Link: TFhirRequestOrchestrationActionConditionList;
begin
  result := TFhirRequestOrchestrationActionConditionList(inherited Link);
end;

procedure TFhirRequestOrchestrationActionConditionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRequestOrchestrationActionConditionList.SetItemByIndex(index: Integer; value: TFhirRequestOrchestrationActionCondition);
begin
  assert(value is TFhirRequestOrchestrationActionCondition);
  FhirRequestOrchestrationActionConditions[index] := value;
end;

procedure TFhirRequestOrchestrationActionConditionList.SetItemN(index: Integer; value: TFhirRequestOrchestrationActionCondition);
begin
  assert(value is TFhirRequestOrchestrationActionCondition);
  ObjectByIndex[index] := value;
end;

{ TFhirRequestOrchestrationActionInput }

constructor TFhirRequestOrchestrationActionInput.Create;
begin
  inherited;
end;

destructor TFhirRequestOrchestrationActionInput.Destroy;
begin
  FTitle.free;
  FRequirement.free;
  FRelatedData.free;
  inherited;
end;

procedure TFhirRequestOrchestrationActionInput.Assign(oSource : TFslObject);
begin
  inherited;
  titleElement := TFhirRequestOrchestrationActionInput(oSource).titleElement.Clone;
  requirement := TFhirRequestOrchestrationActionInput(oSource).requirement.Clone;
  relatedDataElement := TFhirRequestOrchestrationActionInput(oSource).relatedDataElement.Clone;
end;

procedure TFhirRequestOrchestrationActionInput.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'requirement') Then
     list.add(self.link, 'requirement', FRequirement.Link);
  if (child_name = 'relatedData') Then
     list.add(self.link, 'relatedData', FRelatedData.Link);
end;

procedure TFhirRequestOrchestrationActionInput.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'requirement', 'DataRequirement', false, TFhirDataRequirement, FRequirement.Link));
  oList.add(TFHIRProperty.create(self, 'relatedData', 'id', false, TFhirId, FRelatedData.Link));
end;

function TFhirRequestOrchestrationActionInput.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'requirement') then
  begin
    Requirement := propValue as TFhirDataRequirement;
    result := propValue;
  end
  else if (propName = 'relatedData') then
  begin
    RelatedDataElement := asId(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRequestOrchestrationActionInput.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRequestOrchestrationActionInput.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'requirement') then result := TFhirDataRequirement.create()
  else if (propName = 'relatedData') then result := TFhirId.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirRequestOrchestrationActionInput.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'title') then result := 'string'
  else if (propName = 'requirement') then result := 'DataRequirement'
  else if (propName = 'relatedData') then result := 'id'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRequestOrchestrationActionInput.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := nil
  else if (propName = 'requirement') then RequirementElement := nil
  else if (propName = 'relatedData') then RelatedDataElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRequestOrchestrationActionInput.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'requirement') then RequirementElement := new as TFhirDataRequirement
  else if (propName = 'relatedData') then RelatedDataElement := asId(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRequestOrchestrationActionInput.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRequestOrchestrationActionInput.fhirType : string;
begin
  result := 'RequestOrchestration.action.input';
end;

function TFhirRequestOrchestrationActionInput.Link : TFhirRequestOrchestrationActionInput;
begin
  result := TFhirRequestOrchestrationActionInput(inherited Link);
end;

function TFhirRequestOrchestrationActionInput.Clone : TFhirRequestOrchestrationActionInput;
begin
  result := TFhirRequestOrchestrationActionInput(inherited Clone);
end;

function TFhirRequestOrchestrationActionInput.equals(other : TObject) : boolean; 
var
  o : TFhirRequestOrchestrationActionInput;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRequestOrchestrationActionInput)) then
    result := false
  else
  begin
    o := TFhirRequestOrchestrationActionInput(other);
    result := compareDeep(titleElement, o.titleElement, true) and compareDeep(requirementElement, o.requirementElement, true) and 
      compareDeep(relatedDataElement, o.relatedDataElement, true);
  end;
end;

function TFhirRequestOrchestrationActionInput.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTitle) and isEmptyProp(FRequirement) and isEmptyProp(FRelatedData);
end;

procedure TFhirRequestOrchestrationActionInput.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('title');
  fields.add('requirement');
  fields.add('relatedData');
end;

function TFhirRequestOrchestrationActionInput.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirRequestOrchestrationActionInput.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirRequestOrchestrationActionInput.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirRequestOrchestrationActionInput.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirRequestOrchestrationActionInput.SetRequirement(value : TFhirDataRequirement);
begin
  FRequirement.free;
  FRequirement := value;
end;

procedure TFhirRequestOrchestrationActionInput.SetRelatedData(value : TFhirId);
begin
  FRelatedData.free;
  FRelatedData := value;
end;

function TFhirRequestOrchestrationActionInput.GetRelatedDataST : String;
begin
  if FRelatedData = nil then
    result := ''
  else
    result := FRelatedData.value;
end;

procedure TFhirRequestOrchestrationActionInput.SetRelatedDataST(value : String);
begin
  if value <> '' then
  begin
    if FRelatedData = nil then
      FRelatedData := TFhirId.create;
    FRelatedData.value := value
  end
  else if FRelatedData <> nil then
    FRelatedData.value := '';
end;

{ TFhirRequestOrchestrationActionInputListEnumerator }

constructor TFhirRequestOrchestrationActionInputListEnumerator.Create(list : TFhirRequestOrchestrationActionInputList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRequestOrchestrationActionInputListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRequestOrchestrationActionInputListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRequestOrchestrationActionInputListEnumerator.GetCurrent : TFhirRequestOrchestrationActionInput;
begin
  Result := FList[FIndex];
end;

function TFhirRequestOrchestrationActionInputListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRequestOrchestrationActionInputList }

function TFhirRequestOrchestrationActionInputList.AddItem(value: TFhirRequestOrchestrationActionInput): TFhirRequestOrchestrationActionInput;
begin
  assert(value.ClassName = 'TFhirRequestOrchestrationActionInput', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRequestOrchestrationActionInput');
  add(value);
  result := value;
end;

function TFhirRequestOrchestrationActionInputList.Append: TFhirRequestOrchestrationActionInput;
begin
  result := TFhirRequestOrchestrationActionInput.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestOrchestrationActionInputList.ClearItems;
begin
  Clear;
end;

function TFhirRequestOrchestrationActionInputList.GetEnumerator : TFhirRequestOrchestrationActionInputListEnumerator;
begin
  result := TFhirRequestOrchestrationActionInputListEnumerator.Create(self.link);
end;

function TFhirRequestOrchestrationActionInputList.Clone: TFhirRequestOrchestrationActionInputList;
begin
  result := TFhirRequestOrchestrationActionInputList(inherited Clone);
end;

function TFhirRequestOrchestrationActionInputList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRequestOrchestrationActionInputList.GetItemN(index: Integer): TFhirRequestOrchestrationActionInput;
begin
  result := TFhirRequestOrchestrationActionInput(ObjectByIndex[index]);
end;

function TFhirRequestOrchestrationActionInputList.ItemClass: TFslObjectClass;
begin
  result := TFhirRequestOrchestrationActionInput;
end;
function TFhirRequestOrchestrationActionInputList.IndexOf(value: TFhirRequestOrchestrationActionInput): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRequestOrchestrationActionInputList.Insert(index: Integer): TFhirRequestOrchestrationActionInput;
begin
  result := TFhirRequestOrchestrationActionInput.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestOrchestrationActionInputList.InsertItem(index: Integer; value: TFhirRequestOrchestrationActionInput);
begin
  assert(value is TFhirRequestOrchestrationActionInput);
  Inherited Insert(index, value);
end;

function TFhirRequestOrchestrationActionInputList.Item(index: Integer): TFhirRequestOrchestrationActionInput;
begin
  result := TFhirRequestOrchestrationActionInput(ObjectByIndex[index]);
end;

function TFhirRequestOrchestrationActionInputList.Link: TFhirRequestOrchestrationActionInputList;
begin
  result := TFhirRequestOrchestrationActionInputList(inherited Link);
end;

procedure TFhirRequestOrchestrationActionInputList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRequestOrchestrationActionInputList.SetItemByIndex(index: Integer; value: TFhirRequestOrchestrationActionInput);
begin
  assert(value is TFhirRequestOrchestrationActionInput);
  FhirRequestOrchestrationActionInputs[index] := value;
end;

procedure TFhirRequestOrchestrationActionInputList.SetItemN(index: Integer; value: TFhirRequestOrchestrationActionInput);
begin
  assert(value is TFhirRequestOrchestrationActionInput);
  ObjectByIndex[index] := value;
end;

{ TFhirRequestOrchestrationActionOutput }

constructor TFhirRequestOrchestrationActionOutput.Create;
begin
  inherited;
end;

destructor TFhirRequestOrchestrationActionOutput.Destroy;
begin
  FTitle.free;
  FRequirement.free;
  FRelatedData.free;
  inherited;
end;

procedure TFhirRequestOrchestrationActionOutput.Assign(oSource : TFslObject);
begin
  inherited;
  titleElement := TFhirRequestOrchestrationActionOutput(oSource).titleElement.Clone;
  requirement := TFhirRequestOrchestrationActionOutput(oSource).requirement.Clone;
  relatedDataElement := TFhirRequestOrchestrationActionOutput(oSource).relatedDataElement.Clone;
end;

procedure TFhirRequestOrchestrationActionOutput.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'requirement') Then
     list.add(self.link, 'requirement', FRequirement.Link);
  if (child_name = 'relatedData') Then
     list.add(self.link, 'relatedData', FRelatedData.Link);
end;

procedure TFhirRequestOrchestrationActionOutput.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'requirement', 'DataRequirement', false, TFhirDataRequirement, FRequirement.Link));
  oList.add(TFHIRProperty.create(self, 'relatedData', 'string', false, TFhirString, FRelatedData.Link));
end;

function TFhirRequestOrchestrationActionOutput.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'requirement') then
  begin
    Requirement := propValue as TFhirDataRequirement;
    result := propValue;
  end
  else if (propName = 'relatedData') then
  begin
    RelatedDataElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRequestOrchestrationActionOutput.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRequestOrchestrationActionOutput.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'requirement') then result := TFhirDataRequirement.create()
  else if (propName = 'relatedData') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirRequestOrchestrationActionOutput.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'title') then result := 'string'
  else if (propName = 'requirement') then result := 'DataRequirement'
  else if (propName = 'relatedData') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRequestOrchestrationActionOutput.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := nil
  else if (propName = 'requirement') then RequirementElement := nil
  else if (propName = 'relatedData') then RelatedDataElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRequestOrchestrationActionOutput.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'requirement') then RequirementElement := new as TFhirDataRequirement
  else if (propName = 'relatedData') then RelatedDataElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRequestOrchestrationActionOutput.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRequestOrchestrationActionOutput.fhirType : string;
begin
  result := 'RequestOrchestration.action.output';
end;

function TFhirRequestOrchestrationActionOutput.Link : TFhirRequestOrchestrationActionOutput;
begin
  result := TFhirRequestOrchestrationActionOutput(inherited Link);
end;

function TFhirRequestOrchestrationActionOutput.Clone : TFhirRequestOrchestrationActionOutput;
begin
  result := TFhirRequestOrchestrationActionOutput(inherited Clone);
end;

function TFhirRequestOrchestrationActionOutput.equals(other : TObject) : boolean; 
var
  o : TFhirRequestOrchestrationActionOutput;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRequestOrchestrationActionOutput)) then
    result := false
  else
  begin
    o := TFhirRequestOrchestrationActionOutput(other);
    result := compareDeep(titleElement, o.titleElement, true) and compareDeep(requirementElement, o.requirementElement, true) and 
      compareDeep(relatedDataElement, o.relatedDataElement, true);
  end;
end;

function TFhirRequestOrchestrationActionOutput.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTitle) and isEmptyProp(FRequirement) and isEmptyProp(FRelatedData);
end;

procedure TFhirRequestOrchestrationActionOutput.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('title');
  fields.add('requirement');
  fields.add('relatedData');
end;

function TFhirRequestOrchestrationActionOutput.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirRequestOrchestrationActionOutput.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirRequestOrchestrationActionOutput.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirRequestOrchestrationActionOutput.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirRequestOrchestrationActionOutput.SetRequirement(value : TFhirDataRequirement);
begin
  FRequirement.free;
  FRequirement := value;
end;

procedure TFhirRequestOrchestrationActionOutput.SetRelatedData(value : TFhirString);
begin
  FRelatedData.free;
  FRelatedData := value;
end;

function TFhirRequestOrchestrationActionOutput.GetRelatedDataST : String;
begin
  if FRelatedData = nil then
    result := ''
  else
    result := FRelatedData.value;
end;

procedure TFhirRequestOrchestrationActionOutput.SetRelatedDataST(value : String);
begin
  if value <> '' then
  begin
    if FRelatedData = nil then
      FRelatedData := TFhirString.create;
    FRelatedData.value := value
  end
  else if FRelatedData <> nil then
    FRelatedData.value := '';
end;

{ TFhirRequestOrchestrationActionOutputListEnumerator }

constructor TFhirRequestOrchestrationActionOutputListEnumerator.Create(list : TFhirRequestOrchestrationActionOutputList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRequestOrchestrationActionOutputListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRequestOrchestrationActionOutputListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRequestOrchestrationActionOutputListEnumerator.GetCurrent : TFhirRequestOrchestrationActionOutput;
begin
  Result := FList[FIndex];
end;

function TFhirRequestOrchestrationActionOutputListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRequestOrchestrationActionOutputList }

function TFhirRequestOrchestrationActionOutputList.AddItem(value: TFhirRequestOrchestrationActionOutput): TFhirRequestOrchestrationActionOutput;
begin
  assert(value.ClassName = 'TFhirRequestOrchestrationActionOutput', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRequestOrchestrationActionOutput');
  add(value);
  result := value;
end;

function TFhirRequestOrchestrationActionOutputList.Append: TFhirRequestOrchestrationActionOutput;
begin
  result := TFhirRequestOrchestrationActionOutput.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestOrchestrationActionOutputList.ClearItems;
begin
  Clear;
end;

function TFhirRequestOrchestrationActionOutputList.GetEnumerator : TFhirRequestOrchestrationActionOutputListEnumerator;
begin
  result := TFhirRequestOrchestrationActionOutputListEnumerator.Create(self.link);
end;

function TFhirRequestOrchestrationActionOutputList.Clone: TFhirRequestOrchestrationActionOutputList;
begin
  result := TFhirRequestOrchestrationActionOutputList(inherited Clone);
end;

function TFhirRequestOrchestrationActionOutputList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRequestOrchestrationActionOutputList.GetItemN(index: Integer): TFhirRequestOrchestrationActionOutput;
begin
  result := TFhirRequestOrchestrationActionOutput(ObjectByIndex[index]);
end;

function TFhirRequestOrchestrationActionOutputList.ItemClass: TFslObjectClass;
begin
  result := TFhirRequestOrchestrationActionOutput;
end;
function TFhirRequestOrchestrationActionOutputList.IndexOf(value: TFhirRequestOrchestrationActionOutput): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRequestOrchestrationActionOutputList.Insert(index: Integer): TFhirRequestOrchestrationActionOutput;
begin
  result := TFhirRequestOrchestrationActionOutput.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestOrchestrationActionOutputList.InsertItem(index: Integer; value: TFhirRequestOrchestrationActionOutput);
begin
  assert(value is TFhirRequestOrchestrationActionOutput);
  Inherited Insert(index, value);
end;

function TFhirRequestOrchestrationActionOutputList.Item(index: Integer): TFhirRequestOrchestrationActionOutput;
begin
  result := TFhirRequestOrchestrationActionOutput(ObjectByIndex[index]);
end;

function TFhirRequestOrchestrationActionOutputList.Link: TFhirRequestOrchestrationActionOutputList;
begin
  result := TFhirRequestOrchestrationActionOutputList(inherited Link);
end;

procedure TFhirRequestOrchestrationActionOutputList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRequestOrchestrationActionOutputList.SetItemByIndex(index: Integer; value: TFhirRequestOrchestrationActionOutput);
begin
  assert(value is TFhirRequestOrchestrationActionOutput);
  FhirRequestOrchestrationActionOutputs[index] := value;
end;

procedure TFhirRequestOrchestrationActionOutputList.SetItemN(index: Integer; value: TFhirRequestOrchestrationActionOutput);
begin
  assert(value is TFhirRequestOrchestrationActionOutput);
  ObjectByIndex[index] := value;
end;

{ TFhirRequestOrchestrationActionRelatedAction }

constructor TFhirRequestOrchestrationActionRelatedAction.Create;
begin
  inherited;
end;

destructor TFhirRequestOrchestrationActionRelatedAction.Destroy;
begin
  FTargetId.free;
  FRelationship.free;
  FOffset.free;
  inherited;
end;

procedure TFhirRequestOrchestrationActionRelatedAction.Assign(oSource : TFslObject);
begin
  inherited;
  targetIdElement := TFhirRequestOrchestrationActionRelatedAction(oSource).targetIdElement.Clone;
  relationshipElement := TFhirRequestOrchestrationActionRelatedAction(oSource).relationshipElement.Clone;
  offset := TFhirRequestOrchestrationActionRelatedAction(oSource).offset.Clone;
end;

procedure TFhirRequestOrchestrationActionRelatedAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'targetId') Then
     list.add(self.link, 'targetId', FTargetId.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'offset[x]') or (child_name = 'offset') Then
     list.add(self.link, 'offset[x]', FOffset.Link);
end;

procedure TFhirRequestOrchestrationActionRelatedAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'targetId', 'id', false, TFhirId, FTargetId.Link));
  oList.add(TFHIRProperty.create(self, 'relationship', 'code', false, TFhirEnum, FRelationship.Link));
  oList.add(TFHIRProperty.create(self, 'offset[x]', 'Duration|Range', false, TFhirDataType, FOffset.Link));
end;

function TFhirRequestOrchestrationActionRelatedAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'targetId') then
  begin
    TargetIdElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    RelationshipElement := asEnum(SYSTEMS_TFhirActionRelationshipTypeEnum, CODES_TFhirActionRelationshipTypeEnum, propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then
  begin
    Offset := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRequestOrchestrationActionRelatedAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRequestOrchestrationActionRelatedAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'targetId') then result := TFhirId.create()
  else if (propName = 'relationship') then result := TFhirEnum.create(SYSTEMS_TFhirActionRelationshipTypeEnum[ActionRelationshipTypeNull], CODES_TFhirActionRelationshipTypeEnum[ActionRelationshipTypeNull]) 
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then raise EFHIRException.create('Cannot make property Offset')
  else result := inherited createPropertyValue(propName);
end;

function TFhirRequestOrchestrationActionRelatedAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'targetId') then result := 'id'
  else if (propName = 'relationship') then result := 'code'
  else if (propName = 'offset[x]') then result := 'Duration|Range'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRequestOrchestrationActionRelatedAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'targetId') then TargetIdElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then OffsetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRequestOrchestrationActionRelatedAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'targetId') then TargetIdElement := asId(new)
  else if (propName = 'relationship') then RelationshipElement := asEnum(SYSTEMS_TFhirActionRelationshipTypeEnum, CODES_TFhirActionRelationshipTypeEnum, new)
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then OffsetElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRequestOrchestrationActionRelatedAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRequestOrchestrationActionRelatedAction.fhirType : string;
begin
  result := 'RequestOrchestration.action.relatedAction';
end;

function TFhirRequestOrchestrationActionRelatedAction.Link : TFhirRequestOrchestrationActionRelatedAction;
begin
  result := TFhirRequestOrchestrationActionRelatedAction(inherited Link);
end;

function TFhirRequestOrchestrationActionRelatedAction.Clone : TFhirRequestOrchestrationActionRelatedAction;
begin
  result := TFhirRequestOrchestrationActionRelatedAction(inherited Clone);
end;

function TFhirRequestOrchestrationActionRelatedAction.equals(other : TObject) : boolean; 
var
  o : TFhirRequestOrchestrationActionRelatedAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRequestOrchestrationActionRelatedAction)) then
    result := false
  else
  begin
    o := TFhirRequestOrchestrationActionRelatedAction(other);
    result := compareDeep(targetIdElement, o.targetIdElement, true) and compareDeep(relationshipElement, o.relationshipElement, true) and 
      compareDeep(offsetElement, o.offsetElement, true);
  end;
end;

function TFhirRequestOrchestrationActionRelatedAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTargetId) and isEmptyProp(FRelationship) and isEmptyProp(FOffset);
end;

procedure TFhirRequestOrchestrationActionRelatedAction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('targetId');
  fields.add('relationship');
  fields.add('offset[x]');
end;

function TFhirRequestOrchestrationActionRelatedAction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirRequestOrchestrationActionRelatedAction.SetTargetId(value : TFhirId);
begin
  FTargetId.free;
  FTargetId := value;
end;

function TFhirRequestOrchestrationActionRelatedAction.GetTargetIdST : String;
begin
  if FTargetId = nil then
    result := ''
  else
    result := FTargetId.value;
end;

procedure TFhirRequestOrchestrationActionRelatedAction.SetTargetIdST(value : String);
begin
  if value <> '' then
  begin
    if FTargetId = nil then
      FTargetId := TFhirId.create;
    FTargetId.value := value
  end
  else if FTargetId <> nil then
    FTargetId.value := '';
end;

procedure TFhirRequestOrchestrationActionRelatedAction.SetRelationship(value : TFhirEnum);
begin
  FRelationship.free;
  FRelationship := value;
end;

function TFhirRequestOrchestrationActionRelatedAction.GetRelationshipST : TFhirActionRelationshipTypeEnum;
begin
  if FRelationship = nil then
    result := TFhirActionRelationshipTypeEnum(0)
  else
    result := TFhirActionRelationshipTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirActionRelationshipTypeEnum, FRelationship.value));
end;

procedure TFhirRequestOrchestrationActionRelatedAction.SetRelationshipST(value : TFhirActionRelationshipTypeEnum);
begin
  if ord(value) = 0 then
    RelationshipElement := nil
  else
    RelationshipElement := TFhirEnum.create(SYSTEMS_TFhirActionRelationshipTypeEnum[value], CODES_TFhirActionRelationshipTypeEnum[value]);
end;

procedure TFhirRequestOrchestrationActionRelatedAction.SetOffset(value : TFhirDataType);
begin
  FOffset.free;
  FOffset := value;
end;

{ TFhirRequestOrchestrationActionRelatedActionListEnumerator }

constructor TFhirRequestOrchestrationActionRelatedActionListEnumerator.Create(list : TFhirRequestOrchestrationActionRelatedActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRequestOrchestrationActionRelatedActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRequestOrchestrationActionRelatedActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRequestOrchestrationActionRelatedActionListEnumerator.GetCurrent : TFhirRequestOrchestrationActionRelatedAction;
begin
  Result := FList[FIndex];
end;

function TFhirRequestOrchestrationActionRelatedActionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRequestOrchestrationActionRelatedActionList }

function TFhirRequestOrchestrationActionRelatedActionList.AddItem(value: TFhirRequestOrchestrationActionRelatedAction): TFhirRequestOrchestrationActionRelatedAction;
begin
  assert(value.ClassName = 'TFhirRequestOrchestrationActionRelatedAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRequestOrchestrationActionRelatedAction');
  add(value);
  result := value;
end;

function TFhirRequestOrchestrationActionRelatedActionList.Append: TFhirRequestOrchestrationActionRelatedAction;
begin
  result := TFhirRequestOrchestrationActionRelatedAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestOrchestrationActionRelatedActionList.ClearItems;
begin
  Clear;
end;

function TFhirRequestOrchestrationActionRelatedActionList.GetEnumerator : TFhirRequestOrchestrationActionRelatedActionListEnumerator;
begin
  result := TFhirRequestOrchestrationActionRelatedActionListEnumerator.Create(self.link);
end;

function TFhirRequestOrchestrationActionRelatedActionList.Clone: TFhirRequestOrchestrationActionRelatedActionList;
begin
  result := TFhirRequestOrchestrationActionRelatedActionList(inherited Clone);
end;

function TFhirRequestOrchestrationActionRelatedActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRequestOrchestrationActionRelatedActionList.GetItemN(index: Integer): TFhirRequestOrchestrationActionRelatedAction;
begin
  result := TFhirRequestOrchestrationActionRelatedAction(ObjectByIndex[index]);
end;

function TFhirRequestOrchestrationActionRelatedActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirRequestOrchestrationActionRelatedAction;
end;
function TFhirRequestOrchestrationActionRelatedActionList.IndexOf(value: TFhirRequestOrchestrationActionRelatedAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRequestOrchestrationActionRelatedActionList.Insert(index: Integer): TFhirRequestOrchestrationActionRelatedAction;
begin
  result := TFhirRequestOrchestrationActionRelatedAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestOrchestrationActionRelatedActionList.InsertItem(index: Integer; value: TFhirRequestOrchestrationActionRelatedAction);
begin
  assert(value is TFhirRequestOrchestrationActionRelatedAction);
  Inherited Insert(index, value);
end;

function TFhirRequestOrchestrationActionRelatedActionList.Item(index: Integer): TFhirRequestOrchestrationActionRelatedAction;
begin
  result := TFhirRequestOrchestrationActionRelatedAction(ObjectByIndex[index]);
end;

function TFhirRequestOrchestrationActionRelatedActionList.Link: TFhirRequestOrchestrationActionRelatedActionList;
begin
  result := TFhirRequestOrchestrationActionRelatedActionList(inherited Link);
end;

procedure TFhirRequestOrchestrationActionRelatedActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRequestOrchestrationActionRelatedActionList.SetItemByIndex(index: Integer; value: TFhirRequestOrchestrationActionRelatedAction);
begin
  assert(value is TFhirRequestOrchestrationActionRelatedAction);
  FhirRequestOrchestrationActionRelatedActions[index] := value;
end;

procedure TFhirRequestOrchestrationActionRelatedActionList.SetItemN(index: Integer; value: TFhirRequestOrchestrationActionRelatedAction);
begin
  assert(value is TFhirRequestOrchestrationActionRelatedAction);
  ObjectByIndex[index] := value;
end;

{ TFhirRequestOrchestrationActionParticipant }

constructor TFhirRequestOrchestrationActionParticipant.Create;
begin
  inherited;
end;

destructor TFhirRequestOrchestrationActionParticipant.Destroy;
begin
  FType_.free;
  FTypeCanonical.free;
  FTypeReference.free;
  FRole.free;
  FFunction_.free;
  FActor.free;
  inherited;
end;

procedure TFhirRequestOrchestrationActionParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirRequestOrchestrationActionParticipant(oSource).type_Element.Clone;
  typeCanonicalElement := TFhirRequestOrchestrationActionParticipant(oSource).typeCanonicalElement.Clone;
  typeReference := TFhirRequestOrchestrationActionParticipant(oSource).typeReference.Clone;
  role := TFhirRequestOrchestrationActionParticipant(oSource).role.Clone;
  function_ := TFhirRequestOrchestrationActionParticipant(oSource).function_.Clone;
  actor := TFhirRequestOrchestrationActionParticipant(oSource).actor.Clone;
end;

procedure TFhirRequestOrchestrationActionParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'typeCanonical') Then
     list.add(self.link, 'typeCanonical', FTypeCanonical.Link);
  if (child_name = 'typeReference') Then
     list.add(self.link, 'typeReference', FTypeReference.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'function') Then
     list.add(self.link, 'function', FFunction_.Link);
  if (child_name = 'actor[x]') or (child_name = 'actor') Then
     list.add(self.link, 'actor[x]', FActor.Link);
end;

procedure TFhirRequestOrchestrationActionParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'typeCanonical', 'canonical', false, TFhirCanonical, FTypeCanonical.Link));
  oList.add(TFHIRProperty.create(self, 'typeReference', 'Reference', false, TFhirReference, FTypeReference.Link));
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));
  oList.add(TFHIRProperty.create(self, 'function', 'CodeableConcept', false, TFhirCodeableConcept, FFunction_.Link));
  oList.add(TFHIRProperty.create(self, 'actor[x]', 'canonical|Reference', false, TFhirDataType, FActor.Link));
end;

function TFhirRequestOrchestrationActionParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirActionParticipantTypeEnum, CODES_TFhirActionParticipantTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'typeCanonical') then
  begin
    TypeCanonicalElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'typeReference') then
  begin
    TypeReference := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'function') then
  begin
    Function_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'actor', ['Canonical', 'Reference'])) then
  begin
    Actor := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRequestOrchestrationActionParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRequestOrchestrationActionParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirActionParticipantTypeEnum[ActionParticipantTypeNull], CODES_TFhirActionParticipantTypeEnum[ActionParticipantTypeNull]) 
  else if (propName = 'typeCanonical') then result := TFhirCanonical.create()
  else if (propName = 'typeReference') then result := TFhirReference.create()
  else if (propName = 'role') then result := TFhirCodeableConcept.create()
  else if (propName = 'function') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'actor', ['Canonical', 'Reference'])) then raise EFHIRException.create('Cannot make property Actor')
  else result := inherited createPropertyValue(propName);
end;

function TFhirRequestOrchestrationActionParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'typeCanonical') then result := 'canonical'
  else if (propName = 'typeReference') then result := 'Reference'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'function') then result := 'CodeableConcept'
  else if (propName = 'actor[x]') then result := 'canonical|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRequestOrchestrationActionParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'typeCanonical') then TypeCanonicalElement := nil
  else if (propName = 'typeReference') then TypeReferenceElement := nil
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'function') then Function_Element := nil
  else if (isMatchingName(propName, 'actor', ['Canonical', 'Reference'])) then ActorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRequestOrchestrationActionParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirActionParticipantTypeEnum, CODES_TFhirActionParticipantTypeEnum, new)
  else if (propName = 'typeCanonical') then TypeCanonicalElement := asCanonical(new)
  else if (propName = 'typeReference') then TypeReferenceElement := new as TFhirReference
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept
  else if (propName = 'function') then Function_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'actor', ['Canonical', 'Reference'])) then ActorElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRequestOrchestrationActionParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRequestOrchestrationActionParticipant.fhirType : string;
begin
  result := 'RequestOrchestration.action.participant';
end;

function TFhirRequestOrchestrationActionParticipant.Link : TFhirRequestOrchestrationActionParticipant;
begin
  result := TFhirRequestOrchestrationActionParticipant(inherited Link);
end;

function TFhirRequestOrchestrationActionParticipant.Clone : TFhirRequestOrchestrationActionParticipant;
begin
  result := TFhirRequestOrchestrationActionParticipant(inherited Clone);
end;

function TFhirRequestOrchestrationActionParticipant.equals(other : TObject) : boolean; 
var
  o : TFhirRequestOrchestrationActionParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRequestOrchestrationActionParticipant)) then
    result := false
  else
  begin
    o := TFhirRequestOrchestrationActionParticipant(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(typeCanonicalElement, o.typeCanonicalElement, true) and 
      compareDeep(typeReferenceElement, o.typeReferenceElement, true) and compareDeep(roleElement, o.roleElement, true) and 
      compareDeep(function_Element, o.function_Element, true) and compareDeep(actorElement, o.actorElement, true);
  end;
end;

function TFhirRequestOrchestrationActionParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FTypeCanonical) and isEmptyProp(FTypeReference) and isEmptyProp(FRole) and isEmptyProp(FFunction_) and isEmptyProp(FActor);
end;

procedure TFhirRequestOrchestrationActionParticipant.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('typeCanonical');
  fields.add('typeReference');
  fields.add('role');
  fields.add('function');
  fields.add('actor[x]');
end;

function TFhirRequestOrchestrationActionParticipant.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirRequestOrchestrationActionParticipant.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirRequestOrchestrationActionParticipant.GetType_ST : TFhirActionParticipantTypeEnum;
begin
  if FType_ = nil then
    result := TFhirActionParticipantTypeEnum(0)
  else
    result := TFhirActionParticipantTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirActionParticipantTypeEnum, FType_.value));
end;

procedure TFhirRequestOrchestrationActionParticipant.SetType_ST(value : TFhirActionParticipantTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirActionParticipantTypeEnum[value], CODES_TFhirActionParticipantTypeEnum[value]);
end;

procedure TFhirRequestOrchestrationActionParticipant.SetTypeCanonical(value : TFhirCanonical);
begin
  FTypeCanonical.free;
  FTypeCanonical := value;
end;

function TFhirRequestOrchestrationActionParticipant.GetTypeCanonicalST : String;
begin
  if FTypeCanonical = nil then
    result := ''
  else
    result := FTypeCanonical.value;
end;

procedure TFhirRequestOrchestrationActionParticipant.SetTypeCanonicalST(value : String);
begin
  if value <> '' then
  begin
    if FTypeCanonical = nil then
      FTypeCanonical := TFhirCanonical.create;
    FTypeCanonical.value := value
  end
  else if FTypeCanonical <> nil then
    FTypeCanonical.value := '';
end;

procedure TFhirRequestOrchestrationActionParticipant.SetTypeReference(value : TFhirReference);
begin
  FTypeReference.free;
  FTypeReference := value;
end;

procedure TFhirRequestOrchestrationActionParticipant.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

procedure TFhirRequestOrchestrationActionParticipant.SetFunction_(value : TFhirCodeableConcept);
begin
  FFunction_.free;
  FFunction_ := value;
end;

procedure TFhirRequestOrchestrationActionParticipant.SetActor(value : TFhirDataType);
begin
  FActor.free;
  FActor := value;
end;

{ TFhirRequestOrchestrationActionParticipantListEnumerator }

constructor TFhirRequestOrchestrationActionParticipantListEnumerator.Create(list : TFhirRequestOrchestrationActionParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRequestOrchestrationActionParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRequestOrchestrationActionParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRequestOrchestrationActionParticipantListEnumerator.GetCurrent : TFhirRequestOrchestrationActionParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirRequestOrchestrationActionParticipantListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRequestOrchestrationActionParticipantList }

function TFhirRequestOrchestrationActionParticipantList.AddItem(value: TFhirRequestOrchestrationActionParticipant): TFhirRequestOrchestrationActionParticipant;
begin
  assert(value.ClassName = 'TFhirRequestOrchestrationActionParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRequestOrchestrationActionParticipant');
  add(value);
  result := value;
end;

function TFhirRequestOrchestrationActionParticipantList.Append: TFhirRequestOrchestrationActionParticipant;
begin
  result := TFhirRequestOrchestrationActionParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestOrchestrationActionParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirRequestOrchestrationActionParticipantList.GetEnumerator : TFhirRequestOrchestrationActionParticipantListEnumerator;
begin
  result := TFhirRequestOrchestrationActionParticipantListEnumerator.Create(self.link);
end;

function TFhirRequestOrchestrationActionParticipantList.Clone: TFhirRequestOrchestrationActionParticipantList;
begin
  result := TFhirRequestOrchestrationActionParticipantList(inherited Clone);
end;

function TFhirRequestOrchestrationActionParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRequestOrchestrationActionParticipantList.GetItemN(index: Integer): TFhirRequestOrchestrationActionParticipant;
begin
  result := TFhirRequestOrchestrationActionParticipant(ObjectByIndex[index]);
end;

function TFhirRequestOrchestrationActionParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirRequestOrchestrationActionParticipant;
end;
function TFhirRequestOrchestrationActionParticipantList.IndexOf(value: TFhirRequestOrchestrationActionParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRequestOrchestrationActionParticipantList.Insert(index: Integer): TFhirRequestOrchestrationActionParticipant;
begin
  result := TFhirRequestOrchestrationActionParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestOrchestrationActionParticipantList.InsertItem(index: Integer; value: TFhirRequestOrchestrationActionParticipant);
begin
  assert(value is TFhirRequestOrchestrationActionParticipant);
  Inherited Insert(index, value);
end;

function TFhirRequestOrchestrationActionParticipantList.Item(index: Integer): TFhirRequestOrchestrationActionParticipant;
begin
  result := TFhirRequestOrchestrationActionParticipant(ObjectByIndex[index]);
end;

function TFhirRequestOrchestrationActionParticipantList.Link: TFhirRequestOrchestrationActionParticipantList;
begin
  result := TFhirRequestOrchestrationActionParticipantList(inherited Link);
end;

procedure TFhirRequestOrchestrationActionParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRequestOrchestrationActionParticipantList.SetItemByIndex(index: Integer; value: TFhirRequestOrchestrationActionParticipant);
begin
  assert(value is TFhirRequestOrchestrationActionParticipant);
  FhirRequestOrchestrationActionParticipants[index] := value;
end;

procedure TFhirRequestOrchestrationActionParticipantList.SetItemN(index: Integer; value: TFhirRequestOrchestrationActionParticipant);
begin
  assert(value is TFhirRequestOrchestrationActionParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirRequestOrchestrationActionDynamicValue }

constructor TFhirRequestOrchestrationActionDynamicValue.Create;
begin
  inherited;
end;

destructor TFhirRequestOrchestrationActionDynamicValue.Destroy;
begin
  FPath.free;
  FExpression.free;
  inherited;
end;

procedure TFhirRequestOrchestrationActionDynamicValue.Assign(oSource : TFslObject);
begin
  inherited;
  pathElement := TFhirRequestOrchestrationActionDynamicValue(oSource).pathElement.Clone;
  expression := TFhirRequestOrchestrationActionDynamicValue(oSource).expression.Clone;
end;

procedure TFhirRequestOrchestrationActionDynamicValue.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'path') Then
     list.add(self.link, 'path', FPath.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
end;

procedure TFhirRequestOrchestrationActionDynamicValue.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'path', 'string', false, TFhirString, FPath.Link));
  oList.add(TFHIRProperty.create(self, 'expression', 'Expression', false, TFhirExpression, FExpression.Link));
end;

function TFhirRequestOrchestrationActionDynamicValue.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'path') then
  begin
    PathElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    Expression := propValue as TFhirExpression;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRequestOrchestrationActionDynamicValue.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRequestOrchestrationActionDynamicValue.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'path') then result := TFhirString.create()
  else if (propName = 'expression') then result := TFhirExpression.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirRequestOrchestrationActionDynamicValue.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'path') then result := 'string'
  else if (propName = 'expression') then result := 'Expression'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRequestOrchestrationActionDynamicValue.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'path') then PathElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRequestOrchestrationActionDynamicValue.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'path') then PathElement := asString(new)
  else if (propName = 'expression') then ExpressionElement := new as TFhirExpression
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRequestOrchestrationActionDynamicValue.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRequestOrchestrationActionDynamicValue.fhirType : string;
begin
  result := 'RequestOrchestration.action.dynamicValue';
end;

function TFhirRequestOrchestrationActionDynamicValue.Link : TFhirRequestOrchestrationActionDynamicValue;
begin
  result := TFhirRequestOrchestrationActionDynamicValue(inherited Link);
end;

function TFhirRequestOrchestrationActionDynamicValue.Clone : TFhirRequestOrchestrationActionDynamicValue;
begin
  result := TFhirRequestOrchestrationActionDynamicValue(inherited Clone);
end;

function TFhirRequestOrchestrationActionDynamicValue.equals(other : TObject) : boolean; 
var
  o : TFhirRequestOrchestrationActionDynamicValue;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRequestOrchestrationActionDynamicValue)) then
    result := false
  else
  begin
    o := TFhirRequestOrchestrationActionDynamicValue(other);
    result := compareDeep(pathElement, o.pathElement, true) and compareDeep(expressionElement, o.expressionElement, true);
  end;
end;

function TFhirRequestOrchestrationActionDynamicValue.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPath) and isEmptyProp(FExpression);
end;

procedure TFhirRequestOrchestrationActionDynamicValue.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('path');
  fields.add('expression');
end;

function TFhirRequestOrchestrationActionDynamicValue.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirRequestOrchestrationActionDynamicValue.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

function TFhirRequestOrchestrationActionDynamicValue.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := FPath.value;
end;

procedure TFhirRequestOrchestrationActionDynamicValue.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

procedure TFhirRequestOrchestrationActionDynamicValue.SetExpression(value : TFhirExpression);
begin
  FExpression.free;
  FExpression := value;
end;

{ TFhirRequestOrchestrationActionDynamicValueListEnumerator }

constructor TFhirRequestOrchestrationActionDynamicValueListEnumerator.Create(list : TFhirRequestOrchestrationActionDynamicValueList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRequestOrchestrationActionDynamicValueListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRequestOrchestrationActionDynamicValueListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRequestOrchestrationActionDynamicValueListEnumerator.GetCurrent : TFhirRequestOrchestrationActionDynamicValue;
begin
  Result := FList[FIndex];
end;

function TFhirRequestOrchestrationActionDynamicValueListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRequestOrchestrationActionDynamicValueList }

function TFhirRequestOrchestrationActionDynamicValueList.AddItem(value: TFhirRequestOrchestrationActionDynamicValue): TFhirRequestOrchestrationActionDynamicValue;
begin
  assert(value.ClassName = 'TFhirRequestOrchestrationActionDynamicValue', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRequestOrchestrationActionDynamicValue');
  add(value);
  result := value;
end;

function TFhirRequestOrchestrationActionDynamicValueList.Append: TFhirRequestOrchestrationActionDynamicValue;
begin
  result := TFhirRequestOrchestrationActionDynamicValue.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestOrchestrationActionDynamicValueList.ClearItems;
begin
  Clear;
end;

function TFhirRequestOrchestrationActionDynamicValueList.GetEnumerator : TFhirRequestOrchestrationActionDynamicValueListEnumerator;
begin
  result := TFhirRequestOrchestrationActionDynamicValueListEnumerator.Create(self.link);
end;

function TFhirRequestOrchestrationActionDynamicValueList.Clone: TFhirRequestOrchestrationActionDynamicValueList;
begin
  result := TFhirRequestOrchestrationActionDynamicValueList(inherited Clone);
end;

function TFhirRequestOrchestrationActionDynamicValueList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRequestOrchestrationActionDynamicValueList.GetItemN(index: Integer): TFhirRequestOrchestrationActionDynamicValue;
begin
  result := TFhirRequestOrchestrationActionDynamicValue(ObjectByIndex[index]);
end;

function TFhirRequestOrchestrationActionDynamicValueList.ItemClass: TFslObjectClass;
begin
  result := TFhirRequestOrchestrationActionDynamicValue;
end;
function TFhirRequestOrchestrationActionDynamicValueList.IndexOf(value: TFhirRequestOrchestrationActionDynamicValue): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRequestOrchestrationActionDynamicValueList.Insert(index: Integer): TFhirRequestOrchestrationActionDynamicValue;
begin
  result := TFhirRequestOrchestrationActionDynamicValue.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestOrchestrationActionDynamicValueList.InsertItem(index: Integer; value: TFhirRequestOrchestrationActionDynamicValue);
begin
  assert(value is TFhirRequestOrchestrationActionDynamicValue);
  Inherited Insert(index, value);
end;

function TFhirRequestOrchestrationActionDynamicValueList.Item(index: Integer): TFhirRequestOrchestrationActionDynamicValue;
begin
  result := TFhirRequestOrchestrationActionDynamicValue(ObjectByIndex[index]);
end;

function TFhirRequestOrchestrationActionDynamicValueList.Link: TFhirRequestOrchestrationActionDynamicValueList;
begin
  result := TFhirRequestOrchestrationActionDynamicValueList(inherited Link);
end;

procedure TFhirRequestOrchestrationActionDynamicValueList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRequestOrchestrationActionDynamicValueList.SetItemByIndex(index: Integer; value: TFhirRequestOrchestrationActionDynamicValue);
begin
  assert(value is TFhirRequestOrchestrationActionDynamicValue);
  FhirRequestOrchestrationActionDynamicValues[index] := value;
end;

procedure TFhirRequestOrchestrationActionDynamicValueList.SetItemN(index: Integer; value: TFhirRequestOrchestrationActionDynamicValue);
begin
  assert(value is TFhirRequestOrchestrationActionDynamicValue);
  ObjectByIndex[index] := value;
end;

{ TFhirRequestOrchestration }

constructor TFhirRequestOrchestration.Create;
begin
  inherited;
end;

destructor TFhirRequestOrchestration.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FBasedOnList.Free;
  FReplacesList.Free;
  FGroupIdentifier.free;
  FStatus.free;
  FIntent.free;
  FPriority.free;
  FCode.free;
  FSubject.free;
  FEncounter.free;
  FAuthoredOn.free;
  FAuthor.free;
  FReasonList.Free;
  FGoalList.Free;
  FNoteList.Free;
  FActionList.Free;
  inherited;
end;

procedure TFhirRequestOrchestration.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirRequestOrchestration(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirRequestOrchestration(oSource).FIdentifierList);
  end;
  if (TFhirRequestOrchestration(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirRequestOrchestration(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirRequestOrchestration(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirRequestOrchestration(oSource).FInstantiatesUriList);
  end;
  if (TFhirRequestOrchestration(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirRequestOrchestration(oSource).FBasedOnList);
  end;
  if (TFhirRequestOrchestration(oSource).FReplacesList = nil) then
  begin
    FReplacesList.free;
    FReplacesList := nil;
  end
  else
  begin
    if FReplacesList = nil then
      FReplacesList := TFhirReferenceList.Create;
    FReplacesList.Assign(TFhirRequestOrchestration(oSource).FReplacesList);
  end;
  groupIdentifier := TFhirRequestOrchestration(oSource).groupIdentifier.Clone;
  statusElement := TFhirRequestOrchestration(oSource).statusElement.Clone;
  intentElement := TFhirRequestOrchestration(oSource).intentElement.Clone;
  priorityElement := TFhirRequestOrchestration(oSource).priorityElement.Clone;
  code := TFhirRequestOrchestration(oSource).code.Clone;
  subject := TFhirRequestOrchestration(oSource).subject.Clone;
  encounter := TFhirRequestOrchestration(oSource).encounter.Clone;
  authoredOnElement := TFhirRequestOrchestration(oSource).authoredOnElement.Clone;
  author := TFhirRequestOrchestration(oSource).author.Clone;
  if (TFhirRequestOrchestration(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableReferenceList.Create;
    FReasonList.Assign(TFhirRequestOrchestration(oSource).FReasonList);
  end;
  if (TFhirRequestOrchestration(oSource).FGoalList = nil) then
  begin
    FGoalList.free;
    FGoalList := nil;
  end
  else
  begin
    if FGoalList = nil then
      FGoalList := TFhirReferenceList.Create;
    FGoalList.Assign(TFhirRequestOrchestration(oSource).FGoalList);
  end;
  if (TFhirRequestOrchestration(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirRequestOrchestration(oSource).FNoteList);
  end;
  if (TFhirRequestOrchestration(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirRequestOrchestrationActionList.Create;
    FActionList.Assign(TFhirRequestOrchestration(oSource).FActionList);
  end;
end;

function TFhirRequestOrchestration.GetResourceType : TFhirResourceType;
begin
  result := frtRequestOrchestration;
end;

procedure TFhirRequestOrchestration.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'replaces') Then
    list.addAll(self, 'replaces', FReplacesList);
  if (child_name = 'groupIdentifier') Then
     list.add(self.link, 'groupIdentifier', FGroupIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'authoredOn') Then
     list.add(self.link, 'authoredOn', FAuthoredOn.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'goal') Then
    list.addAll(self, 'goal', FGoalList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirRequestOrchestration.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link));
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.create(self, 'replaces', 'Reference', true, TFhirReference, FReplacesList.Link));
  oList.add(TFHIRProperty.create(self, 'groupIdentifier', 'Identifier', false, TFhirIdentifier, FGroupIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'intent', 'code', false, TFhirEnum, FIntent.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFhirEnum, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'authoredOn', 'dateTime', false, TFhirDateTime, FAuthoredOn.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', false, TFhirReference, FAuthor.Link));
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableReference', true, TFhirCodeableReference, FReasonList.Link));
  oList.add(TFHIRProperty.create(self, 'goal', 'Reference', true, TFhirReference, FGoalList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'action', 'BackboneElement', true, TFhirRequestOrchestrationAction, FActionList.Link));
end;

function TFhirRequestOrchestration.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'replaces') then
  begin
    ReplacesList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'groupIdentifier') then
  begin
    GroupIdentifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'intent') then
  begin
    IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, propValue);
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'authoredOn') then
  begin
    AuthoredOnElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableReference);
    result := propValue;
  end
  else if (propName = 'goal') then
  begin
    GoalList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirRequestOrchestrationAction);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRequestOrchestration.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue))
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue))
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'replaces') then ReplacesList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableReference)
  else if (propName = 'goal') then GoalList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirRequestOrchestrationAction)
  else inherited;
end;

function TFhirRequestOrchestration.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new()
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'replaces') then result := ReplacesList.new()
  else if (propName = 'groupIdentifier') then result := TFhirIdentifier.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[RequestStatusNull], CODES_TFhirRequestStatusEnum[RequestStatusNull]) 
  else if (propName = 'intent') then result := TFhirEnum.create(SYSTEMS_TFhirRequestIntentEnum[RequestIntentNull], CODES_TFhirRequestIntentEnum[RequestIntentNull]) 
  else if (propName = 'priority') then result := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[RequestPriorityNull], CODES_TFhirRequestPriorityEnum[RequestPriorityNull]) 
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (propName = 'authoredOn') then result := TFhirDateTime.create()
  else if (propName = 'author') then result := TFhirReference.create()
  else if (propName = 'reason') then result := ReasonList.new()
  else if (propName = 'goal') then result := GoalList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'action') then result := ActionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirRequestOrchestration.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'replaces') then result := 'Reference'
  else if (propName = 'groupIdentifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'intent') then result := 'code'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'authoredOn') then result := 'dateTime'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'reason') then result := 'CodeableReference'
  else if (propName = 'goal') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'action') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRequestOrchestration.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value)
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value)
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'replaces') then deletePropertyValue('replaces', ReplacesList, value)
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'authoredOn') then AuthoredOnElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value)
  else if (propName = 'goal') then deletePropertyValue('goal', GoalList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRequestOrchestration.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new)
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new)
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'replaces') then replacePropertyValue('replaces', ReplacesList, existing, new)
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := new as TFhirIdentifier
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, new)
  else if (propName = 'intent') then IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, new)
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (propName = 'authoredOn') then AuthoredOnElement := asDateTime(new)
  else if (propName = 'author') then AuthorElement := new as TFhirReference
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new)
  else if (propName = 'goal') then replacePropertyValue('goal', GoalList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRequestOrchestration.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination)
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination)
  else if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'replaces') then ReplacesList.move(source, destination)
  else if (propName = 'reason') then ReasonList.move(source, destination)
  else if (propName = 'goal') then GoalList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'action') then ActionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRequestOrchestration.fhirType : string;
begin
  result := 'RequestOrchestration';
end;

function TFhirRequestOrchestration.Link : TFhirRequestOrchestration;
begin
  result := TFhirRequestOrchestration(inherited Link);
end;

function TFhirRequestOrchestration.Clone : TFhirRequestOrchestration;
begin
  result := TFhirRequestOrchestration(inherited Clone);
end;

function TFhirRequestOrchestration.equals(other : TObject) : boolean; 
var
  o : TFhirRequestOrchestration;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRequestOrchestration)) then
    result := false
  else
  begin
    o := TFhirRequestOrchestration(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(replacesList, o.replacesList, true) and compareDeep(groupIdentifierElement, o.groupIdentifierElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(intentElement, o.intentElement, true) and 
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(authoredOnElement, o.authoredOnElement, true) and compareDeep(authorElement, o.authorElement, true) and 
      compareDeep(reasonList, o.reasonList, true) and compareDeep(goalList, o.goalList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirRequestOrchestration.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FbasedOnList) and isEmptyProp(FreplacesList) and isEmptyProp(FGroupIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FIntent) and isEmptyProp(FPriority) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FAuthoredOn) and isEmptyProp(FAuthor) and isEmptyProp(FreasonList) and isEmptyProp(FgoalList) and isEmptyProp(FnoteList) and isEmptyProp(FactionList);
end;

procedure TFhirRequestOrchestration.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('basedOn');
  fields.add('replaces');
  fields.add('groupIdentifier');
  fields.add('status');
  fields.add('intent');
  fields.add('priority');
  fields.add('code');
  fields.add('subject');
  fields.add('encounter');
  fields.add('authoredOn');
  fields.add('author');
  fields.add('reason');
  fields.add('goal');
  fields.add('note');
  fields.add('action');
end;

function TFhirRequestOrchestration.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FInstantiatesCanonicalList.sizeInBytes(magic));
  inc(result, FInstantiatesUriList.sizeInBytes(magic));
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FReplacesList.sizeInBytes(magic));
  inc(result, FReasonList.sizeInBytes(magic));
  inc(result, FGoalList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FActionList.sizeInBytes(magic));
end;

function TFhirRequestOrchestration.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirRequestOrchestration.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirRequestOrchestration.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

function TFhirRequestOrchestration.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

function TFhirRequestOrchestration.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

function TFhirRequestOrchestration.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

function TFhirRequestOrchestration.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirRequestOrchestration.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirRequestOrchestration.GetReplacesList : TFhirReferenceList;
begin
  if FReplacesList = nil then
    FReplacesList := TFhirReferenceList.Create;
  result := FReplacesList;
end;

function TFhirRequestOrchestration.GetHasReplacesList : boolean;
begin
  result := (FReplacesList <> nil) and (FReplacesList.count > 0);
end;

procedure TFhirRequestOrchestration.SetGroupIdentifier(value : TFhirIdentifier);
begin
  FGroupIdentifier.free;
  FGroupIdentifier := value;
end;

procedure TFhirRequestOrchestration.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirRequestOrchestration.GetStatusST : TFhirRequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirRequestStatusEnum(0)
  else
    result := TFhirRequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestStatusEnum, FStatus.value));
end;

procedure TFhirRequestOrchestration.SetStatusST(value : TFhirRequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[value], CODES_TFhirRequestStatusEnum[value]);
end;

procedure TFhirRequestOrchestration.SetIntent(value : TFhirEnum);
begin
  FIntent.free;
  FIntent := value;
end;

function TFhirRequestOrchestration.GetIntentST : TFhirRequestIntentEnum;
begin
  if FIntent = nil then
    result := TFhirRequestIntentEnum(0)
  else
    result := TFhirRequestIntentEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestIntentEnum, FIntent.value));
end;

procedure TFhirRequestOrchestration.SetIntentST(value : TFhirRequestIntentEnum);
begin
  if ord(value) = 0 then
    IntentElement := nil
  else
    IntentElement := TFhirEnum.create(SYSTEMS_TFhirRequestIntentEnum[value], CODES_TFhirRequestIntentEnum[value]);
end;

procedure TFhirRequestOrchestration.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirRequestOrchestration.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

procedure TFhirRequestOrchestration.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

procedure TFhirRequestOrchestration.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirRequestOrchestration.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirRequestOrchestration.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirRequestOrchestration.SetAuthoredOn(value : TFhirDateTime);
begin
  FAuthoredOn.free;
  FAuthoredOn := value;
end;

function TFhirRequestOrchestration.GetAuthoredOnST : TFslDateTime;
begin
  if FAuthoredOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoredOn.value;
end;

procedure TFhirRequestOrchestration.SetAuthoredOnST(value : TFslDateTime);
begin
  if FAuthoredOn = nil then
    FAuthoredOn := TFhirDateTime.create;
  FAuthoredOn.value := value
end;

procedure TFhirRequestOrchestration.SetAuthor(value : TFhirReference);
begin
  FAuthor.free;
  FAuthor := value;
end;

function TFhirRequestOrchestration.GetReasonList : TFhirCodeableReferenceList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableReferenceList.Create;
  result := FReasonList;
end;

function TFhirRequestOrchestration.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirRequestOrchestration.GetGoalList : TFhirReferenceList;
begin
  if FGoalList = nil then
    FGoalList := TFhirReferenceList.Create;
  result := FGoalList;
end;

function TFhirRequestOrchestration.GetHasGoalList : boolean;
begin
  result := (FGoalList <> nil) and (FGoalList.count > 0);
end;

function TFhirRequestOrchestration.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirRequestOrchestration.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirRequestOrchestration.GetActionList : TFhirRequestOrchestrationActionList;
begin
  if FActionList = nil then
    FActionList := TFhirRequestOrchestrationActionList.Create;
  result := FActionList;
end;

function TFhirRequestOrchestration.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

{ TFhirRequestOrchestrationListEnumerator }

constructor TFhirRequestOrchestrationListEnumerator.Create(list : TFhirRequestOrchestrationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRequestOrchestrationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRequestOrchestrationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRequestOrchestrationListEnumerator.GetCurrent : TFhirRequestOrchestration;
begin
  Result := FList[FIndex];
end;

function TFhirRequestOrchestrationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRequestOrchestrationList }

function TFhirRequestOrchestrationList.AddItem(value: TFhirRequestOrchestration): TFhirRequestOrchestration;
begin
  assert(value.ClassName = 'TFhirRequestOrchestration', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRequestOrchestration');
  add(value);
  result := value;
end;

function TFhirRequestOrchestrationList.Append: TFhirRequestOrchestration;
begin
  result := TFhirRequestOrchestration.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestOrchestrationList.ClearItems;
begin
  Clear;
end;

function TFhirRequestOrchestrationList.GetEnumerator : TFhirRequestOrchestrationListEnumerator;
begin
  result := TFhirRequestOrchestrationListEnumerator.Create(self.link);
end;

function TFhirRequestOrchestrationList.Clone: TFhirRequestOrchestrationList;
begin
  result := TFhirRequestOrchestrationList(inherited Clone);
end;

function TFhirRequestOrchestrationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRequestOrchestrationList.GetItemN(index: Integer): TFhirRequestOrchestration;
begin
  result := TFhirRequestOrchestration(ObjectByIndex[index]);
end;

function TFhirRequestOrchestrationList.ItemClass: TFslObjectClass;
begin
  result := TFhirRequestOrchestration;
end;
function TFhirRequestOrchestrationList.IndexOf(value: TFhirRequestOrchestration): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRequestOrchestrationList.Insert(index: Integer): TFhirRequestOrchestration;
begin
  result := TFhirRequestOrchestration.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestOrchestrationList.InsertItem(index: Integer; value: TFhirRequestOrchestration);
begin
  assert(value is TFhirRequestOrchestration);
  Inherited Insert(index, value);
end;

function TFhirRequestOrchestrationList.Item(index: Integer): TFhirRequestOrchestration;
begin
  result := TFhirRequestOrchestration(ObjectByIndex[index]);
end;

function TFhirRequestOrchestrationList.Link: TFhirRequestOrchestrationList;
begin
  result := TFhirRequestOrchestrationList(inherited Link);
end;

procedure TFhirRequestOrchestrationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRequestOrchestrationList.SetItemByIndex(index: Integer; value: TFhirRequestOrchestration);
begin
  assert(value is TFhirRequestOrchestration);
  FhirRequestOrchestrations[index] := value;
end;

procedure TFhirRequestOrchestrationList.SetItemN(index: Integer; value: TFhirRequestOrchestration);
begin
  assert(value is TFhirRequestOrchestration);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_REQUESTORCHESTRATION}
{$IFDEF FHIR_RESEARCHSTUDY}
{ TFhirResearchStudyLabel }

constructor TFhirResearchStudyLabel.Create;
begin
  inherited;
end;

destructor TFhirResearchStudyLabel.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirResearchStudyLabel.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirResearchStudyLabel(oSource).type_.Clone;
  valueElement := TFhirResearchStudyLabel(oSource).valueElement.Clone;
end;

procedure TFhirResearchStudyLabel.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirResearchStudyLabel.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));
end;

function TFhirResearchStudyLabel.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirResearchStudyLabel.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirResearchStudyLabel.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'value') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchStudyLabel.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchStudyLabel.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchStudyLabel.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'value') then ValueElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchStudyLabel.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchStudyLabel.fhirType : string;
begin
  result := 'ResearchStudy.label';
end;

function TFhirResearchStudyLabel.Link : TFhirResearchStudyLabel;
begin
  result := TFhirResearchStudyLabel(inherited Link);
end;

function TFhirResearchStudyLabel.Clone : TFhirResearchStudyLabel;
begin
  result := TFhirResearchStudyLabel(inherited Clone);
end;

function TFhirResearchStudyLabel.equals(other : TObject) : boolean; 
var
  o : TFhirResearchStudyLabel;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchStudyLabel)) then
    result := false
  else
  begin
    o := TFhirResearchStudyLabel(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirResearchStudyLabel.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirResearchStudyLabel.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value');
end;

function TFhirResearchStudyLabel.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirResearchStudyLabel.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirResearchStudyLabel.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

function TFhirResearchStudyLabel.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirResearchStudyLabel.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

{ TFhirResearchStudyLabelListEnumerator }

constructor TFhirResearchStudyLabelListEnumerator.Create(list : TFhirResearchStudyLabelList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchStudyLabelListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchStudyLabelListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchStudyLabelListEnumerator.GetCurrent : TFhirResearchStudyLabel;
begin
  Result := FList[FIndex];
end;

function TFhirResearchStudyLabelListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirResearchStudyLabelList }

function TFhirResearchStudyLabelList.AddItem(value: TFhirResearchStudyLabel): TFhirResearchStudyLabel;
begin
  assert(value.ClassName = 'TFhirResearchStudyLabel', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchStudyLabel');
  add(value);
  result := value;
end;

function TFhirResearchStudyLabelList.Append: TFhirResearchStudyLabel;
begin
  result := TFhirResearchStudyLabel.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyLabelList.ClearItems;
begin
  Clear;
end;

function TFhirResearchStudyLabelList.GetEnumerator : TFhirResearchStudyLabelListEnumerator;
begin
  result := TFhirResearchStudyLabelListEnumerator.Create(self.link);
end;

function TFhirResearchStudyLabelList.Clone: TFhirResearchStudyLabelList;
begin
  result := TFhirResearchStudyLabelList(inherited Clone);
end;

function TFhirResearchStudyLabelList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchStudyLabelList.GetItemN(index: Integer): TFhirResearchStudyLabel;
begin
  result := TFhirResearchStudyLabel(ObjectByIndex[index]);
end;

function TFhirResearchStudyLabelList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchStudyLabel;
end;
function TFhirResearchStudyLabelList.IndexOf(value: TFhirResearchStudyLabel): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchStudyLabelList.Insert(index: Integer): TFhirResearchStudyLabel;
begin
  result := TFhirResearchStudyLabel.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyLabelList.InsertItem(index: Integer; value: TFhirResearchStudyLabel);
begin
  assert(value is TFhirResearchStudyLabel);
  Inherited Insert(index, value);
end;

function TFhirResearchStudyLabelList.Item(index: Integer): TFhirResearchStudyLabel;
begin
  result := TFhirResearchStudyLabel(ObjectByIndex[index]);
end;

function TFhirResearchStudyLabelList.Link: TFhirResearchStudyLabelList;
begin
  result := TFhirResearchStudyLabelList(inherited Link);
end;

procedure TFhirResearchStudyLabelList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchStudyLabelList.SetItemByIndex(index: Integer; value: TFhirResearchStudyLabel);
begin
  assert(value is TFhirResearchStudyLabel);
  FhirResearchStudyLabels[index] := value;
end;

procedure TFhirResearchStudyLabelList.SetItemN(index: Integer; value: TFhirResearchStudyLabel);
begin
  assert(value is TFhirResearchStudyLabel);
  ObjectByIndex[index] := value;
end;

{ TFhirResearchStudyFocus }

constructor TFhirResearchStudyFocus.Create;
begin
  inherited;
end;

destructor TFhirResearchStudyFocus.Destroy;
begin
  FProductCode.free;
  FFocusTypeList.Free;
  FFactor.free;
  inherited;
end;

procedure TFhirResearchStudyFocus.Assign(oSource : TFslObject);
begin
  inherited;
  productCode := TFhirResearchStudyFocus(oSource).productCode.Clone;
  if (TFhirResearchStudyFocus(oSource).FFocusTypeList = nil) then
  begin
    FFocusTypeList.free;
    FFocusTypeList := nil;
  end
  else
  begin
    if FFocusTypeList = nil then
      FFocusTypeList := TFhirCodeableConceptList.Create;
    FFocusTypeList.Assign(TFhirResearchStudyFocus(oSource).FFocusTypeList);
  end;
  factorElement := TFhirResearchStudyFocus(oSource).factorElement.Clone;
end;

procedure TFhirResearchStudyFocus.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'productCode') Then
     list.add(self.link, 'productCode', FProductCode.Link);
  if (child_name = 'focusType') Then
    list.addAll(self, 'focusType', FFocusTypeList);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
end;

procedure TFhirResearchStudyFocus.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'productCode', 'CodeableConcept', false, TFhirCodeableConcept, FProductCode.Link));
  oList.add(TFHIRProperty.create(self, 'focusType', 'CodeableConcept', true, TFhirCodeableConcept, FFocusTypeList.Link));
  oList.add(TFHIRProperty.create(self, 'factor', 'markdown', false, TFhirMarkdown, FFactor.Link));
end;

function TFhirResearchStudyFocus.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'productCode') then
  begin
    ProductCode := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'focusType') then
  begin
    FocusTypeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asMarkdown(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirResearchStudyFocus.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'focusType') then FocusTypeList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirResearchStudyFocus.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'productCode') then result := TFhirCodeableConcept.create()
  else if (propName = 'focusType') then result := FocusTypeList.new()
  else if (propName = 'factor') then result := TFhirMarkdown.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchStudyFocus.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'productCode') then result := 'CodeableConcept'
  else if (propName = 'focusType') then result := 'CodeableConcept'
  else if (propName = 'factor') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchStudyFocus.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'productCode') then ProductCodeElement := nil
  else if (propName = 'focusType') then deletePropertyValue('focusType', FocusTypeList, value)
  else if (propName = 'factor') then FactorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchStudyFocus.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'productCode') then ProductCodeElement := new as TFhirCodeableConcept
  else if (propName = 'focusType') then replacePropertyValue('focusType', FocusTypeList, existing, new)
  else if (propName = 'factor') then FactorElement := asMarkdown(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchStudyFocus.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'focusType') then FocusTypeList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchStudyFocus.fhirType : string;
begin
  result := 'ResearchStudy.focus';
end;

function TFhirResearchStudyFocus.Link : TFhirResearchStudyFocus;
begin
  result := TFhirResearchStudyFocus(inherited Link);
end;

function TFhirResearchStudyFocus.Clone : TFhirResearchStudyFocus;
begin
  result := TFhirResearchStudyFocus(inherited Clone);
end;

function TFhirResearchStudyFocus.equals(other : TObject) : boolean; 
var
  o : TFhirResearchStudyFocus;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchStudyFocus)) then
    result := false
  else
  begin
    o := TFhirResearchStudyFocus(other);
    result := compareDeep(productCodeElement, o.productCodeElement, true) and compareDeep(focusTypeList, o.focusTypeList, true) and 
      compareDeep(factorElement, o.factorElement, true);
  end;
end;

function TFhirResearchStudyFocus.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProductCode) and isEmptyProp(FfocusTypeList) and isEmptyProp(FFactor);
end;

procedure TFhirResearchStudyFocus.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('productCode');
  fields.add('focusType');
  fields.add('factor');
end;

function TFhirResearchStudyFocus.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FFocusTypeList.sizeInBytes(magic));
end;

procedure TFhirResearchStudyFocus.SetProductCode(value : TFhirCodeableConcept);
begin
  FProductCode.free;
  FProductCode := value;
end;

function TFhirResearchStudyFocus.GetFocusTypeList : TFhirCodeableConceptList;
begin
  if FFocusTypeList = nil then
    FFocusTypeList := TFhirCodeableConceptList.Create;
  result := FFocusTypeList;
end;

function TFhirResearchStudyFocus.GetHasFocusTypeList : boolean;
begin
  result := (FFocusTypeList <> nil) and (FFocusTypeList.count > 0);
end;

procedure TFhirResearchStudyFocus.SetFactor(value : TFhirMarkdown);
begin
  FFactor.free;
  FFactor := value;
end;

function TFhirResearchStudyFocus.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirResearchStudyFocus.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirMarkdown.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

{ TFhirResearchStudyFocusListEnumerator }

constructor TFhirResearchStudyFocusListEnumerator.Create(list : TFhirResearchStudyFocusList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchStudyFocusListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchStudyFocusListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchStudyFocusListEnumerator.GetCurrent : TFhirResearchStudyFocus;
begin
  Result := FList[FIndex];
end;

function TFhirResearchStudyFocusListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirResearchStudyFocusList }

function TFhirResearchStudyFocusList.AddItem(value: TFhirResearchStudyFocus): TFhirResearchStudyFocus;
begin
  assert(value.ClassName = 'TFhirResearchStudyFocus', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchStudyFocus');
  add(value);
  result := value;
end;

function TFhirResearchStudyFocusList.Append: TFhirResearchStudyFocus;
begin
  result := TFhirResearchStudyFocus.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyFocusList.ClearItems;
begin
  Clear;
end;

function TFhirResearchStudyFocusList.GetEnumerator : TFhirResearchStudyFocusListEnumerator;
begin
  result := TFhirResearchStudyFocusListEnumerator.Create(self.link);
end;

function TFhirResearchStudyFocusList.Clone: TFhirResearchStudyFocusList;
begin
  result := TFhirResearchStudyFocusList(inherited Clone);
end;

function TFhirResearchStudyFocusList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchStudyFocusList.GetItemN(index: Integer): TFhirResearchStudyFocus;
begin
  result := TFhirResearchStudyFocus(ObjectByIndex[index]);
end;

function TFhirResearchStudyFocusList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchStudyFocus;
end;
function TFhirResearchStudyFocusList.IndexOf(value: TFhirResearchStudyFocus): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchStudyFocusList.Insert(index: Integer): TFhirResearchStudyFocus;
begin
  result := TFhirResearchStudyFocus.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyFocusList.InsertItem(index: Integer; value: TFhirResearchStudyFocus);
begin
  assert(value is TFhirResearchStudyFocus);
  Inherited Insert(index, value);
end;

function TFhirResearchStudyFocusList.Item(index: Integer): TFhirResearchStudyFocus;
begin
  result := TFhirResearchStudyFocus(ObjectByIndex[index]);
end;

function TFhirResearchStudyFocusList.Link: TFhirResearchStudyFocusList;
begin
  result := TFhirResearchStudyFocusList(inherited Link);
end;

procedure TFhirResearchStudyFocusList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchStudyFocusList.SetItemByIndex(index: Integer; value: TFhirResearchStudyFocus);
begin
  assert(value is TFhirResearchStudyFocus);
  FhirResearchStudyFocus[index] := value;
end;

procedure TFhirResearchStudyFocusList.SetItemN(index: Integer; value: TFhirResearchStudyFocus);
begin
  assert(value is TFhirResearchStudyFocus);
  ObjectByIndex[index] := value;
end;

{ TFhirResearchStudyAssociatedParty }

constructor TFhirResearchStudyAssociatedParty.Create;
begin
  inherited;
end;

destructor TFhirResearchStudyAssociatedParty.Destroy;
begin
  FName.free;
  FRole.free;
  FPeriodList.Free;
  FClassifierList.Free;
  FParty.free;
  inherited;
end;

procedure TFhirResearchStudyAssociatedParty.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirResearchStudyAssociatedParty(oSource).nameElement.Clone;
  role := TFhirResearchStudyAssociatedParty(oSource).role.Clone;
  if (TFhirResearchStudyAssociatedParty(oSource).FPeriodList = nil) then
  begin
    FPeriodList.free;
    FPeriodList := nil;
  end
  else
  begin
    if FPeriodList = nil then
      FPeriodList := TFhirPeriodList.Create;
    FPeriodList.Assign(TFhirResearchStudyAssociatedParty(oSource).FPeriodList);
  end;
  if (TFhirResearchStudyAssociatedParty(oSource).FClassifierList = nil) then
  begin
    FClassifierList.free;
    FClassifierList := nil;
  end
  else
  begin
    if FClassifierList = nil then
      FClassifierList := TFhirCodeableConceptList.Create;
    FClassifierList.Assign(TFhirResearchStudyAssociatedParty(oSource).FClassifierList);
  end;
  party := TFhirResearchStudyAssociatedParty(oSource).party.Clone;
end;

procedure TFhirResearchStudyAssociatedParty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'period') Then
    list.addAll(self, 'period', FPeriodList);
  if (child_name = 'classifier') Then
    list.addAll(self, 'classifier', FClassifierList);
  if (child_name = 'party') Then
     list.add(self.link, 'party', FParty.Link);
end;

procedure TFhirResearchStudyAssociatedParty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', true, TFhirPeriod, FPeriodList.Link));
  oList.add(TFHIRProperty.create(self, 'classifier', 'CodeableConcept', true, TFhirCodeableConcept, FClassifierList.Link));
  oList.add(TFHIRProperty.create(self, 'party', 'Reference', false, TFhirReference, FParty.Link));
end;

function TFhirResearchStudyAssociatedParty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    PeriodList.add(propValue as TFhirPeriod);
    result := propValue;
  end
  else if (propName = 'classifier') then
  begin
    ClassifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'party') then
  begin
    Party := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirResearchStudyAssociatedParty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'period') then PeriodList.insertItem(index, propValue as TFhirPeriod)
  else if (propName = 'classifier') then ClassifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirResearchStudyAssociatedParty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'role') then result := TFhirCodeableConcept.create()
  else if (propName = 'period') then result := PeriodList.new()
  else if (propName = 'classifier') then result := ClassifierList.new()
  else if (propName = 'party') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchStudyAssociatedParty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'classifier') then result := 'CodeableConcept'
  else if (propName = 'party') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchStudyAssociatedParty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'period') then deletePropertyValue('period', PeriodList, value)
  else if (propName = 'classifier') then deletePropertyValue('classifier', ClassifierList, value)
  else if (propName = 'party') then PartyElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchStudyAssociatedParty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept
  else if (propName = 'period') then replacePropertyValue('period', PeriodList, existing, new)
  else if (propName = 'classifier') then replacePropertyValue('classifier', ClassifierList, existing, new)
  else if (propName = 'party') then PartyElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchStudyAssociatedParty.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'period') then PeriodList.move(source, destination)
  else if (propName = 'classifier') then ClassifierList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchStudyAssociatedParty.fhirType : string;
begin
  result := 'ResearchStudy.associatedParty';
end;

function TFhirResearchStudyAssociatedParty.Link : TFhirResearchStudyAssociatedParty;
begin
  result := TFhirResearchStudyAssociatedParty(inherited Link);
end;

function TFhirResearchStudyAssociatedParty.Clone : TFhirResearchStudyAssociatedParty;
begin
  result := TFhirResearchStudyAssociatedParty(inherited Clone);
end;

function TFhirResearchStudyAssociatedParty.equals(other : TObject) : boolean; 
var
  o : TFhirResearchStudyAssociatedParty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchStudyAssociatedParty)) then
    result := false
  else
  begin
    o := TFhirResearchStudyAssociatedParty(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(roleElement, o.roleElement, true) and 
      compareDeep(periodList, o.periodList, true) and compareDeep(classifierList, o.classifierList, true) and 
      compareDeep(partyElement, o.partyElement, true);
  end;
end;

function TFhirResearchStudyAssociatedParty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FRole) and isEmptyProp(FperiodList) and isEmptyProp(FclassifierList) and isEmptyProp(FParty);
end;

procedure TFhirResearchStudyAssociatedParty.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('role');
  fields.add('period');
  fields.add('classifier');
  fields.add('party');
end;

function TFhirResearchStudyAssociatedParty.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FPeriodList.sizeInBytes(magic));
  inc(result, FClassifierList.sizeInBytes(magic));
end;

procedure TFhirResearchStudyAssociatedParty.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirResearchStudyAssociatedParty.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirResearchStudyAssociatedParty.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirResearchStudyAssociatedParty.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

function TFhirResearchStudyAssociatedParty.GetPeriodList : TFhirPeriodList;
begin
  if FPeriodList = nil then
    FPeriodList := TFhirPeriodList.Create;
  result := FPeriodList;
end;

function TFhirResearchStudyAssociatedParty.GetHasPeriodList : boolean;
begin
  result := (FPeriodList <> nil) and (FPeriodList.count > 0);
end;

function TFhirResearchStudyAssociatedParty.GetClassifierList : TFhirCodeableConceptList;
begin
  if FClassifierList = nil then
    FClassifierList := TFhirCodeableConceptList.Create;
  result := FClassifierList;
end;

function TFhirResearchStudyAssociatedParty.GetHasClassifierList : boolean;
begin
  result := (FClassifierList <> nil) and (FClassifierList.count > 0);
end;

procedure TFhirResearchStudyAssociatedParty.SetParty(value : TFhirReference);
begin
  FParty.free;
  FParty := value;
end;

{ TFhirResearchStudyAssociatedPartyListEnumerator }

constructor TFhirResearchStudyAssociatedPartyListEnumerator.Create(list : TFhirResearchStudyAssociatedPartyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchStudyAssociatedPartyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchStudyAssociatedPartyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchStudyAssociatedPartyListEnumerator.GetCurrent : TFhirResearchStudyAssociatedParty;
begin
  Result := FList[FIndex];
end;

function TFhirResearchStudyAssociatedPartyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirResearchStudyAssociatedPartyList }

function TFhirResearchStudyAssociatedPartyList.AddItem(value: TFhirResearchStudyAssociatedParty): TFhirResearchStudyAssociatedParty;
begin
  assert(value.ClassName = 'TFhirResearchStudyAssociatedParty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchStudyAssociatedParty');
  add(value);
  result := value;
end;

function TFhirResearchStudyAssociatedPartyList.Append: TFhirResearchStudyAssociatedParty;
begin
  result := TFhirResearchStudyAssociatedParty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyAssociatedPartyList.ClearItems;
begin
  Clear;
end;

function TFhirResearchStudyAssociatedPartyList.GetEnumerator : TFhirResearchStudyAssociatedPartyListEnumerator;
begin
  result := TFhirResearchStudyAssociatedPartyListEnumerator.Create(self.link);
end;

function TFhirResearchStudyAssociatedPartyList.Clone: TFhirResearchStudyAssociatedPartyList;
begin
  result := TFhirResearchStudyAssociatedPartyList(inherited Clone);
end;

function TFhirResearchStudyAssociatedPartyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchStudyAssociatedPartyList.GetItemN(index: Integer): TFhirResearchStudyAssociatedParty;
begin
  result := TFhirResearchStudyAssociatedParty(ObjectByIndex[index]);
end;

function TFhirResearchStudyAssociatedPartyList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchStudyAssociatedParty;
end;
function TFhirResearchStudyAssociatedPartyList.IndexOf(value: TFhirResearchStudyAssociatedParty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchStudyAssociatedPartyList.Insert(index: Integer): TFhirResearchStudyAssociatedParty;
begin
  result := TFhirResearchStudyAssociatedParty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyAssociatedPartyList.InsertItem(index: Integer; value: TFhirResearchStudyAssociatedParty);
begin
  assert(value is TFhirResearchStudyAssociatedParty);
  Inherited Insert(index, value);
end;

function TFhirResearchStudyAssociatedPartyList.Item(index: Integer): TFhirResearchStudyAssociatedParty;
begin
  result := TFhirResearchStudyAssociatedParty(ObjectByIndex[index]);
end;

function TFhirResearchStudyAssociatedPartyList.Link: TFhirResearchStudyAssociatedPartyList;
begin
  result := TFhirResearchStudyAssociatedPartyList(inherited Link);
end;

procedure TFhirResearchStudyAssociatedPartyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchStudyAssociatedPartyList.SetItemByIndex(index: Integer; value: TFhirResearchStudyAssociatedParty);
begin
  assert(value is TFhirResearchStudyAssociatedParty);
  FhirResearchStudyAssociatedParties[index] := value;
end;

procedure TFhirResearchStudyAssociatedPartyList.SetItemN(index: Integer; value: TFhirResearchStudyAssociatedParty);
begin
  assert(value is TFhirResearchStudyAssociatedParty);
  ObjectByIndex[index] := value;
end;

{ TFhirResearchStudyProgressStatus }

constructor TFhirResearchStudyProgressStatus.Create;
begin
  inherited;
end;

destructor TFhirResearchStudyProgressStatus.Destroy;
begin
  FState.free;
  FActual.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirResearchStudyProgressStatus.Assign(oSource : TFslObject);
begin
  inherited;
  state := TFhirResearchStudyProgressStatus(oSource).state.Clone;
  actualElement := TFhirResearchStudyProgressStatus(oSource).actualElement.Clone;
  period := TFhirResearchStudyProgressStatus(oSource).period.Clone;
end;

procedure TFhirResearchStudyProgressStatus.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'state') Then
     list.add(self.link, 'state', FState.Link);
  if (child_name = 'actual') Then
     list.add(self.link, 'actual', FActual.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirResearchStudyProgressStatus.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'state', 'CodeableConcept', false, TFhirCodeableConcept, FState.Link));
  oList.add(TFHIRProperty.create(self, 'actual', 'boolean', false, TFhirBoolean, FActual.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
end;

function TFhirResearchStudyProgressStatus.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'state') then
  begin
    State := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'actual') then
  begin
    ActualElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirResearchStudyProgressStatus.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirResearchStudyProgressStatus.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'state') then result := TFhirCodeableConcept.create()
  else if (propName = 'actual') then result := TFhirBoolean.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchStudyProgressStatus.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'state') then result := 'CodeableConcept'
  else if (propName = 'actual') then result := 'boolean'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchStudyProgressStatus.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'state') then StateElement := nil
  else if (propName = 'actual') then ActualElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchStudyProgressStatus.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'state') then StateElement := new as TFhirCodeableConcept
  else if (propName = 'actual') then ActualElement := asBoolean(new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchStudyProgressStatus.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchStudyProgressStatus.fhirType : string;
begin
  result := 'ResearchStudy.progressStatus';
end;

function TFhirResearchStudyProgressStatus.Link : TFhirResearchStudyProgressStatus;
begin
  result := TFhirResearchStudyProgressStatus(inherited Link);
end;

function TFhirResearchStudyProgressStatus.Clone : TFhirResearchStudyProgressStatus;
begin
  result := TFhirResearchStudyProgressStatus(inherited Clone);
end;

function TFhirResearchStudyProgressStatus.equals(other : TObject) : boolean; 
var
  o : TFhirResearchStudyProgressStatus;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchStudyProgressStatus)) then
    result := false
  else
  begin
    o := TFhirResearchStudyProgressStatus(other);
    result := compareDeep(stateElement, o.stateElement, true) and compareDeep(actualElement, o.actualElement, true) and 
      compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirResearchStudyProgressStatus.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FState) and isEmptyProp(FActual) and isEmptyProp(FPeriod);
end;

procedure TFhirResearchStudyProgressStatus.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('state');
  fields.add('actual');
  fields.add('period');
end;

function TFhirResearchStudyProgressStatus.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirResearchStudyProgressStatus.SetState(value : TFhirCodeableConcept);
begin
  FState.free;
  FState := value;
end;

procedure TFhirResearchStudyProgressStatus.SetActual(value : TFhirBoolean);
begin
  FActual.free;
  FActual := value;
end;

function TFhirResearchStudyProgressStatus.GetActualST : Boolean;
begin
  if FActual = nil then
    result := false
  else
    result := FActual.value;
end;

procedure TFhirResearchStudyProgressStatus.SetActualST(value : Boolean);
begin
  if FActual = nil then
    FActual := TFhirBoolean.create;
  FActual.value := value
end;

procedure TFhirResearchStudyProgressStatus.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

{ TFhirResearchStudyProgressStatusListEnumerator }

constructor TFhirResearchStudyProgressStatusListEnumerator.Create(list : TFhirResearchStudyProgressStatusList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchStudyProgressStatusListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchStudyProgressStatusListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchStudyProgressStatusListEnumerator.GetCurrent : TFhirResearchStudyProgressStatus;
begin
  Result := FList[FIndex];
end;

function TFhirResearchStudyProgressStatusListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirResearchStudyProgressStatusList }

function TFhirResearchStudyProgressStatusList.AddItem(value: TFhirResearchStudyProgressStatus): TFhirResearchStudyProgressStatus;
begin
  assert(value.ClassName = 'TFhirResearchStudyProgressStatus', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchStudyProgressStatus');
  add(value);
  result := value;
end;

function TFhirResearchStudyProgressStatusList.Append: TFhirResearchStudyProgressStatus;
begin
  result := TFhirResearchStudyProgressStatus.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyProgressStatusList.ClearItems;
begin
  Clear;
end;

function TFhirResearchStudyProgressStatusList.GetEnumerator : TFhirResearchStudyProgressStatusListEnumerator;
begin
  result := TFhirResearchStudyProgressStatusListEnumerator.Create(self.link);
end;

function TFhirResearchStudyProgressStatusList.Clone: TFhirResearchStudyProgressStatusList;
begin
  result := TFhirResearchStudyProgressStatusList(inherited Clone);
end;

function TFhirResearchStudyProgressStatusList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchStudyProgressStatusList.GetItemN(index: Integer): TFhirResearchStudyProgressStatus;
begin
  result := TFhirResearchStudyProgressStatus(ObjectByIndex[index]);
end;

function TFhirResearchStudyProgressStatusList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchStudyProgressStatus;
end;
function TFhirResearchStudyProgressStatusList.IndexOf(value: TFhirResearchStudyProgressStatus): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchStudyProgressStatusList.Insert(index: Integer): TFhirResearchStudyProgressStatus;
begin
  result := TFhirResearchStudyProgressStatus.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyProgressStatusList.InsertItem(index: Integer; value: TFhirResearchStudyProgressStatus);
begin
  assert(value is TFhirResearchStudyProgressStatus);
  Inherited Insert(index, value);
end;

function TFhirResearchStudyProgressStatusList.Item(index: Integer): TFhirResearchStudyProgressStatus;
begin
  result := TFhirResearchStudyProgressStatus(ObjectByIndex[index]);
end;

function TFhirResearchStudyProgressStatusList.Link: TFhirResearchStudyProgressStatusList;
begin
  result := TFhirResearchStudyProgressStatusList(inherited Link);
end;

procedure TFhirResearchStudyProgressStatusList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchStudyProgressStatusList.SetItemByIndex(index: Integer; value: TFhirResearchStudyProgressStatus);
begin
  assert(value is TFhirResearchStudyProgressStatus);
  FhirResearchStudyProgressStatuses[index] := value;
end;

procedure TFhirResearchStudyProgressStatusList.SetItemN(index: Integer; value: TFhirResearchStudyProgressStatus);
begin
  assert(value is TFhirResearchStudyProgressStatus);
  ObjectByIndex[index] := value;
end;

{ TFhirResearchStudyRecruitment }

constructor TFhirResearchStudyRecruitment.Create;
begin
  inherited;
end;

destructor TFhirResearchStudyRecruitment.Destroy;
begin
  FTargetNumber.free;
  FActualNumber.free;
  FEligibility.free;
  FActualGroup.free;
  inherited;
end;

procedure TFhirResearchStudyRecruitment.Assign(oSource : TFslObject);
begin
  inherited;
  targetNumberElement := TFhirResearchStudyRecruitment(oSource).targetNumberElement.Clone;
  actualNumberElement := TFhirResearchStudyRecruitment(oSource).actualNumberElement.Clone;
  eligibility := TFhirResearchStudyRecruitment(oSource).eligibility.Clone;
  actualGroup := TFhirResearchStudyRecruitment(oSource).actualGroup.Clone;
end;

procedure TFhirResearchStudyRecruitment.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'targetNumber') Then
     list.add(self.link, 'targetNumber', FTargetNumber.Link);
  if (child_name = 'actualNumber') Then
     list.add(self.link, 'actualNumber', FActualNumber.Link);
  if (child_name = 'eligibility') Then
     list.add(self.link, 'eligibility', FEligibility.Link);
  if (child_name = 'actualGroup') Then
     list.add(self.link, 'actualGroup', FActualGroup.Link);
end;

procedure TFhirResearchStudyRecruitment.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'targetNumber', 'unsignedInt', false, TFhirUnsignedInt, FTargetNumber.Link));
  oList.add(TFHIRProperty.create(self, 'actualNumber', 'unsignedInt', false, TFhirUnsignedInt, FActualNumber.Link));
  oList.add(TFHIRProperty.create(self, 'eligibility', 'Reference', false, TFhirReference, FEligibility.Link));
  oList.add(TFHIRProperty.create(self, 'actualGroup', 'Reference', false, TFhirReference, FActualGroup.Link));
end;

function TFhirResearchStudyRecruitment.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'targetNumber') then
  begin
    TargetNumberElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'actualNumber') then
  begin
    ActualNumberElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'eligibility') then
  begin
    Eligibility := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'actualGroup') then
  begin
    ActualGroup := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirResearchStudyRecruitment.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirResearchStudyRecruitment.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'targetNumber') then result := TFhirUnsignedInt.create()
  else if (propName = 'actualNumber') then result := TFhirUnsignedInt.create()
  else if (propName = 'eligibility') then result := TFhirReference.create()
  else if (propName = 'actualGroup') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchStudyRecruitment.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'targetNumber') then result := 'unsignedInt'
  else if (propName = 'actualNumber') then result := 'unsignedInt'
  else if (propName = 'eligibility') then result := 'Reference'
  else if (propName = 'actualGroup') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchStudyRecruitment.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'targetNumber') then TargetNumberElement := nil
  else if (propName = 'actualNumber') then ActualNumberElement := nil
  else if (propName = 'eligibility') then EligibilityElement := nil
  else if (propName = 'actualGroup') then ActualGroupElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchStudyRecruitment.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'targetNumber') then TargetNumberElement := asUnsignedInt(new)
  else if (propName = 'actualNumber') then ActualNumberElement := asUnsignedInt(new)
  else if (propName = 'eligibility') then EligibilityElement := new as TFhirReference
  else if (propName = 'actualGroup') then ActualGroupElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchStudyRecruitment.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchStudyRecruitment.fhirType : string;
begin
  result := 'ResearchStudy.recruitment';
end;

function TFhirResearchStudyRecruitment.Link : TFhirResearchStudyRecruitment;
begin
  result := TFhirResearchStudyRecruitment(inherited Link);
end;

function TFhirResearchStudyRecruitment.Clone : TFhirResearchStudyRecruitment;
begin
  result := TFhirResearchStudyRecruitment(inherited Clone);
end;

function TFhirResearchStudyRecruitment.equals(other : TObject) : boolean; 
var
  o : TFhirResearchStudyRecruitment;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchStudyRecruitment)) then
    result := false
  else
  begin
    o := TFhirResearchStudyRecruitment(other);
    result := compareDeep(targetNumberElement, o.targetNumberElement, true) and 
      compareDeep(actualNumberElement, o.actualNumberElement, true) and compareDeep(eligibilityElement, o.eligibilityElement, true) and 
      compareDeep(actualGroupElement, o.actualGroupElement, true);
  end;
end;

function TFhirResearchStudyRecruitment.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTargetNumber) and isEmptyProp(FActualNumber) and isEmptyProp(FEligibility) and isEmptyProp(FActualGroup);
end;

procedure TFhirResearchStudyRecruitment.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('targetNumber');
  fields.add('actualNumber');
  fields.add('eligibility');
  fields.add('actualGroup');
end;

function TFhirResearchStudyRecruitment.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirResearchStudyRecruitment.SetTargetNumber(value : TFhirUnsignedInt);
begin
  FTargetNumber.free;
  FTargetNumber := value;
end;

function TFhirResearchStudyRecruitment.GetTargetNumberST : String;
begin
  if FTargetNumber = nil then
    result := ''
  else
    result := FTargetNumber.value;
end;

procedure TFhirResearchStudyRecruitment.SetTargetNumberST(value : String);
begin
  if value <> '' then
  begin
    if FTargetNumber = nil then
      FTargetNumber := TFhirUnsignedInt.create;
    FTargetNumber.value := value
  end
  else if FTargetNumber <> nil then
    FTargetNumber.value := '';
end;

procedure TFhirResearchStudyRecruitment.SetActualNumber(value : TFhirUnsignedInt);
begin
  FActualNumber.free;
  FActualNumber := value;
end;

function TFhirResearchStudyRecruitment.GetActualNumberST : String;
begin
  if FActualNumber = nil then
    result := ''
  else
    result := FActualNumber.value;
end;

procedure TFhirResearchStudyRecruitment.SetActualNumberST(value : String);
begin
  if value <> '' then
  begin
    if FActualNumber = nil then
      FActualNumber := TFhirUnsignedInt.create;
    FActualNumber.value := value
  end
  else if FActualNumber <> nil then
    FActualNumber.value := '';
end;

procedure TFhirResearchStudyRecruitment.SetEligibility(value : TFhirReference);
begin
  FEligibility.free;
  FEligibility := value;
end;

procedure TFhirResearchStudyRecruitment.SetActualGroup(value : TFhirReference);
begin
  FActualGroup.free;
  FActualGroup := value;
end;

{ TFhirResearchStudyRecruitmentListEnumerator }

constructor TFhirResearchStudyRecruitmentListEnumerator.Create(list : TFhirResearchStudyRecruitmentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchStudyRecruitmentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchStudyRecruitmentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchStudyRecruitmentListEnumerator.GetCurrent : TFhirResearchStudyRecruitment;
begin
  Result := FList[FIndex];
end;

function TFhirResearchStudyRecruitmentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirResearchStudyRecruitmentList }

function TFhirResearchStudyRecruitmentList.AddItem(value: TFhirResearchStudyRecruitment): TFhirResearchStudyRecruitment;
begin
  assert(value.ClassName = 'TFhirResearchStudyRecruitment', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchStudyRecruitment');
  add(value);
  result := value;
end;

function TFhirResearchStudyRecruitmentList.Append: TFhirResearchStudyRecruitment;
begin
  result := TFhirResearchStudyRecruitment.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyRecruitmentList.ClearItems;
begin
  Clear;
end;

function TFhirResearchStudyRecruitmentList.GetEnumerator : TFhirResearchStudyRecruitmentListEnumerator;
begin
  result := TFhirResearchStudyRecruitmentListEnumerator.Create(self.link);
end;

function TFhirResearchStudyRecruitmentList.Clone: TFhirResearchStudyRecruitmentList;
begin
  result := TFhirResearchStudyRecruitmentList(inherited Clone);
end;

function TFhirResearchStudyRecruitmentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchStudyRecruitmentList.GetItemN(index: Integer): TFhirResearchStudyRecruitment;
begin
  result := TFhirResearchStudyRecruitment(ObjectByIndex[index]);
end;

function TFhirResearchStudyRecruitmentList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchStudyRecruitment;
end;
function TFhirResearchStudyRecruitmentList.IndexOf(value: TFhirResearchStudyRecruitment): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchStudyRecruitmentList.Insert(index: Integer): TFhirResearchStudyRecruitment;
begin
  result := TFhirResearchStudyRecruitment.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyRecruitmentList.InsertItem(index: Integer; value: TFhirResearchStudyRecruitment);
begin
  assert(value is TFhirResearchStudyRecruitment);
  Inherited Insert(index, value);
end;

function TFhirResearchStudyRecruitmentList.Item(index: Integer): TFhirResearchStudyRecruitment;
begin
  result := TFhirResearchStudyRecruitment(ObjectByIndex[index]);
end;

function TFhirResearchStudyRecruitmentList.Link: TFhirResearchStudyRecruitmentList;
begin
  result := TFhirResearchStudyRecruitmentList(inherited Link);
end;

procedure TFhirResearchStudyRecruitmentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchStudyRecruitmentList.SetItemByIndex(index: Integer; value: TFhirResearchStudyRecruitment);
begin
  assert(value is TFhirResearchStudyRecruitment);
  FhirResearchStudyRecruitments[index] := value;
end;

procedure TFhirResearchStudyRecruitmentList.SetItemN(index: Integer; value: TFhirResearchStudyRecruitment);
begin
  assert(value is TFhirResearchStudyRecruitment);
  ObjectByIndex[index] := value;
end;

{ TFhirResearchStudyComparisonGroup }

constructor TFhirResearchStudyComparisonGroup.Create;
begin
  inherited;
end;

destructor TFhirResearchStudyComparisonGroup.Destroy;
begin
  FIdentifier.free;
  FName.free;
  FType_.free;
  FDescription.free;
  FIntendedExposureList.Free;
  FObservedGroup.free;
  inherited;
end;

procedure TFhirResearchStudyComparisonGroup.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirResearchStudyComparisonGroup(oSource).identifier.Clone;
  nameElement := TFhirResearchStudyComparisonGroup(oSource).nameElement.Clone;
  type_ := TFhirResearchStudyComparisonGroup(oSource).type_.Clone;
  descriptionElement := TFhirResearchStudyComparisonGroup(oSource).descriptionElement.Clone;
  if (TFhirResearchStudyComparisonGroup(oSource).FIntendedExposureList = nil) then
  begin
    FIntendedExposureList.free;
    FIntendedExposureList := nil;
  end
  else
  begin
    if FIntendedExposureList = nil then
      FIntendedExposureList := TFhirReferenceList.Create;
    FIntendedExposureList.Assign(TFhirResearchStudyComparisonGroup(oSource).FIntendedExposureList);
  end;
  observedGroup := TFhirResearchStudyComparisonGroup(oSource).observedGroup.Clone;
end;

procedure TFhirResearchStudyComparisonGroup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier[x]') or (child_name = 'identifier') Then
     list.add(self.link, 'identifier[x]', FIdentifier.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'intendedExposure') Then
    list.addAll(self, 'intendedExposure', FIntendedExposureList);
  if (child_name = 'observedGroup') Then
     list.add(self.link, 'observedGroup', FObservedGroup.Link);
end;

procedure TFhirResearchStudyComparisonGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier[x]', 'uri|Identifier', false, TFhirDataType, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'intendedExposure', 'Reference', true, TFhirReference, FIntendedExposureList.Link));
  oList.add(TFHIRProperty.create(self, 'observedGroup', 'Reference', false, TFhirReference, FObservedGroup.Link));
end;

function TFhirResearchStudyComparisonGroup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'identifier', ['Uri', 'Identifier'])) then
  begin
    Identifier := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'intendedExposure') then
  begin
    IntendedExposureList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'observedGroup') then
  begin
    ObservedGroup := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirResearchStudyComparisonGroup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'intendedExposure') then IntendedExposureList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirResearchStudyComparisonGroup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'identifier', ['Uri', 'Identifier'])) then raise EFHIRException.create('Cannot make property Identifier')
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'intendedExposure') then result := IntendedExposureList.new()
  else if (propName = 'observedGroup') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchStudyComparisonGroup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier[x]') then result := 'uri|Identifier'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'intendedExposure') then result := 'Reference'
  else if (propName = 'observedGroup') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchStudyComparisonGroup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'identifier', ['Uri', 'Identifier'])) then IdentifierElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'intendedExposure') then deletePropertyValue('intendedExposure', IntendedExposureList, value)
  else if (propName = 'observedGroup') then ObservedGroupElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchStudyComparisonGroup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'identifier', ['Uri', 'Identifier'])) then IdentifierElement := new as TFhirDataType
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'intendedExposure') then replacePropertyValue('intendedExposure', IntendedExposureList, existing, new)
  else if (propName = 'observedGroup') then ObservedGroupElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchStudyComparisonGroup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'intendedExposure') then IntendedExposureList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchStudyComparisonGroup.fhirType : string;
begin
  result := 'ResearchStudy.comparisonGroup';
end;

function TFhirResearchStudyComparisonGroup.Link : TFhirResearchStudyComparisonGroup;
begin
  result := TFhirResearchStudyComparisonGroup(inherited Link);
end;

function TFhirResearchStudyComparisonGroup.Clone : TFhirResearchStudyComparisonGroup;
begin
  result := TFhirResearchStudyComparisonGroup(inherited Clone);
end;

function TFhirResearchStudyComparisonGroup.equals(other : TObject) : boolean; 
var
  o : TFhirResearchStudyComparisonGroup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchStudyComparisonGroup)) then
    result := false
  else
  begin
    o := TFhirResearchStudyComparisonGroup(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(intendedExposureList, o.intendedExposureList, true) and compareDeep(observedGroupElement, o.observedGroupElement, true);
  end;
end;

function TFhirResearchStudyComparisonGroup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FName) and isEmptyProp(FType_) and isEmptyProp(FDescription) and isEmptyProp(FintendedExposureList) and isEmptyProp(FObservedGroup);
end;

procedure TFhirResearchStudyComparisonGroup.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier[x]');
  fields.add('name');
  fields.add('type');
  fields.add('description');
  fields.add('intendedExposure');
  fields.add('observedGroup');
end;

function TFhirResearchStudyComparisonGroup.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIntendedExposureList.sizeInBytes(magic));
end;

procedure TFhirResearchStudyComparisonGroup.SetIdentifier(value : TFhirDataType);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirResearchStudyComparisonGroup.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirResearchStudyComparisonGroup.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirResearchStudyComparisonGroup.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirResearchStudyComparisonGroup.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirResearchStudyComparisonGroup.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirResearchStudyComparisonGroup.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirResearchStudyComparisonGroup.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirResearchStudyComparisonGroup.GetIntendedExposureList : TFhirReferenceList;
begin
  if FIntendedExposureList = nil then
    FIntendedExposureList := TFhirReferenceList.Create;
  result := FIntendedExposureList;
end;

function TFhirResearchStudyComparisonGroup.GetHasIntendedExposureList : boolean;
begin
  result := (FIntendedExposureList <> nil) and (FIntendedExposureList.count > 0);
end;

procedure TFhirResearchStudyComparisonGroup.SetObservedGroup(value : TFhirReference);
begin
  FObservedGroup.free;
  FObservedGroup := value;
end;

{ TFhirResearchStudyComparisonGroupListEnumerator }

constructor TFhirResearchStudyComparisonGroupListEnumerator.Create(list : TFhirResearchStudyComparisonGroupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchStudyComparisonGroupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchStudyComparisonGroupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchStudyComparisonGroupListEnumerator.GetCurrent : TFhirResearchStudyComparisonGroup;
begin
  Result := FList[FIndex];
end;

function TFhirResearchStudyComparisonGroupListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirResearchStudyComparisonGroupList }

function TFhirResearchStudyComparisonGroupList.AddItem(value: TFhirResearchStudyComparisonGroup): TFhirResearchStudyComparisonGroup;
begin
  assert(value.ClassName = 'TFhirResearchStudyComparisonGroup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchStudyComparisonGroup');
  add(value);
  result := value;
end;

function TFhirResearchStudyComparisonGroupList.Append: TFhirResearchStudyComparisonGroup;
begin
  result := TFhirResearchStudyComparisonGroup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyComparisonGroupList.ClearItems;
begin
  Clear;
end;

function TFhirResearchStudyComparisonGroupList.GetEnumerator : TFhirResearchStudyComparisonGroupListEnumerator;
begin
  result := TFhirResearchStudyComparisonGroupListEnumerator.Create(self.link);
end;

function TFhirResearchStudyComparisonGroupList.Clone: TFhirResearchStudyComparisonGroupList;
begin
  result := TFhirResearchStudyComparisonGroupList(inherited Clone);
end;

function TFhirResearchStudyComparisonGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchStudyComparisonGroupList.GetItemN(index: Integer): TFhirResearchStudyComparisonGroup;
begin
  result := TFhirResearchStudyComparisonGroup(ObjectByIndex[index]);
end;

function TFhirResearchStudyComparisonGroupList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchStudyComparisonGroup;
end;
function TFhirResearchStudyComparisonGroupList.IndexOf(value: TFhirResearchStudyComparisonGroup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchStudyComparisonGroupList.Insert(index: Integer): TFhirResearchStudyComparisonGroup;
begin
  result := TFhirResearchStudyComparisonGroup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyComparisonGroupList.InsertItem(index: Integer; value: TFhirResearchStudyComparisonGroup);
begin
  assert(value is TFhirResearchStudyComparisonGroup);
  Inherited Insert(index, value);
end;

function TFhirResearchStudyComparisonGroupList.Item(index: Integer): TFhirResearchStudyComparisonGroup;
begin
  result := TFhirResearchStudyComparisonGroup(ObjectByIndex[index]);
end;

function TFhirResearchStudyComparisonGroupList.Link: TFhirResearchStudyComparisonGroupList;
begin
  result := TFhirResearchStudyComparisonGroupList(inherited Link);
end;

procedure TFhirResearchStudyComparisonGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchStudyComparisonGroupList.SetItemByIndex(index: Integer; value: TFhirResearchStudyComparisonGroup);
begin
  assert(value is TFhirResearchStudyComparisonGroup);
  FhirResearchStudyComparisonGroups[index] := value;
end;

procedure TFhirResearchStudyComparisonGroupList.SetItemN(index: Integer; value: TFhirResearchStudyComparisonGroup);
begin
  assert(value is TFhirResearchStudyComparisonGroup);
  ObjectByIndex[index] := value;
end;

{ TFhirResearchStudyObjective }

constructor TFhirResearchStudyObjective.Create;
begin
  inherited;
end;

destructor TFhirResearchStudyObjective.Destroy;
begin
  FName.free;
  FType_.free;
  FDescription.free;
  inherited;
end;

procedure TFhirResearchStudyObjective.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirResearchStudyObjective(oSource).nameElement.Clone;
  type_ := TFhirResearchStudyObjective(oSource).type_.Clone;
  descriptionElement := TFhirResearchStudyObjective(oSource).descriptionElement.Clone;
end;

procedure TFhirResearchStudyObjective.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
end;

procedure TFhirResearchStudyObjective.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
end;

function TFhirResearchStudyObjective.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirResearchStudyObjective.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirResearchStudyObjective.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchStudyObjective.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchStudyObjective.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'description') then DescriptionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchStudyObjective.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchStudyObjective.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchStudyObjective.fhirType : string;
begin
  result := 'ResearchStudy.objective';
end;

function TFhirResearchStudyObjective.Link : TFhirResearchStudyObjective;
begin
  result := TFhirResearchStudyObjective(inherited Link);
end;

function TFhirResearchStudyObjective.Clone : TFhirResearchStudyObjective;
begin
  result := TFhirResearchStudyObjective(inherited Clone);
end;

function TFhirResearchStudyObjective.equals(other : TObject) : boolean; 
var
  o : TFhirResearchStudyObjective;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchStudyObjective)) then
    result := false
  else
  begin
    o := TFhirResearchStudyObjective(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true);
  end;
end;

function TFhirResearchStudyObjective.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FType_) and isEmptyProp(FDescription);
end;

procedure TFhirResearchStudyObjective.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('type');
  fields.add('description');
end;

function TFhirResearchStudyObjective.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirResearchStudyObjective.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirResearchStudyObjective.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirResearchStudyObjective.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirResearchStudyObjective.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirResearchStudyObjective.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirResearchStudyObjective.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirResearchStudyObjective.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

{ TFhirResearchStudyObjectiveListEnumerator }

constructor TFhirResearchStudyObjectiveListEnumerator.Create(list : TFhirResearchStudyObjectiveList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchStudyObjectiveListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchStudyObjectiveListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchStudyObjectiveListEnumerator.GetCurrent : TFhirResearchStudyObjective;
begin
  Result := FList[FIndex];
end;

function TFhirResearchStudyObjectiveListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirResearchStudyObjectiveList }

function TFhirResearchStudyObjectiveList.AddItem(value: TFhirResearchStudyObjective): TFhirResearchStudyObjective;
begin
  assert(value.ClassName = 'TFhirResearchStudyObjective', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchStudyObjective');
  add(value);
  result := value;
end;

function TFhirResearchStudyObjectiveList.Append: TFhirResearchStudyObjective;
begin
  result := TFhirResearchStudyObjective.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyObjectiveList.ClearItems;
begin
  Clear;
end;

function TFhirResearchStudyObjectiveList.GetEnumerator : TFhirResearchStudyObjectiveListEnumerator;
begin
  result := TFhirResearchStudyObjectiveListEnumerator.Create(self.link);
end;

function TFhirResearchStudyObjectiveList.Clone: TFhirResearchStudyObjectiveList;
begin
  result := TFhirResearchStudyObjectiveList(inherited Clone);
end;

function TFhirResearchStudyObjectiveList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchStudyObjectiveList.GetItemN(index: Integer): TFhirResearchStudyObjective;
begin
  result := TFhirResearchStudyObjective(ObjectByIndex[index]);
end;

function TFhirResearchStudyObjectiveList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchStudyObjective;
end;
function TFhirResearchStudyObjectiveList.IndexOf(value: TFhirResearchStudyObjective): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchStudyObjectiveList.Insert(index: Integer): TFhirResearchStudyObjective;
begin
  result := TFhirResearchStudyObjective.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyObjectiveList.InsertItem(index: Integer; value: TFhirResearchStudyObjective);
begin
  assert(value is TFhirResearchStudyObjective);
  Inherited Insert(index, value);
end;

function TFhirResearchStudyObjectiveList.Item(index: Integer): TFhirResearchStudyObjective;
begin
  result := TFhirResearchStudyObjective(ObjectByIndex[index]);
end;

function TFhirResearchStudyObjectiveList.Link: TFhirResearchStudyObjectiveList;
begin
  result := TFhirResearchStudyObjectiveList(inherited Link);
end;

procedure TFhirResearchStudyObjectiveList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchStudyObjectiveList.SetItemByIndex(index: Integer; value: TFhirResearchStudyObjective);
begin
  assert(value is TFhirResearchStudyObjective);
  FhirResearchStudyObjectives[index] := value;
end;

procedure TFhirResearchStudyObjectiveList.SetItemN(index: Integer; value: TFhirResearchStudyObjective);
begin
  assert(value is TFhirResearchStudyObjective);
  ObjectByIndex[index] := value;
end;

{ TFhirResearchStudyOutcomeMeasure }

constructor TFhirResearchStudyOutcomeMeasure.Create;
begin
  inherited;
end;

destructor TFhirResearchStudyOutcomeMeasure.Destroy;
begin
  FName.free;
  FType_List.Free;
  FDescription.free;
  FReference.free;
  inherited;
end;

procedure TFhirResearchStudyOutcomeMeasure.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirResearchStudyOutcomeMeasure(oSource).nameElement.Clone;
  if (TFhirResearchStudyOutcomeMeasure(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirResearchStudyOutcomeMeasure(oSource).FType_List);
  end;
  descriptionElement := TFhirResearchStudyOutcomeMeasure(oSource).descriptionElement.Clone;
  reference := TFhirResearchStudyOutcomeMeasure(oSource).reference.Clone;
end;

procedure TFhirResearchStudyOutcomeMeasure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
end;

procedure TFhirResearchStudyOutcomeMeasure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference', false, TFhirReference, FReference.Link));
end;

function TFhirResearchStudyOutcomeMeasure.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirResearchStudyOutcomeMeasure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirResearchStudyOutcomeMeasure.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'type') then result := Type_List.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'reference') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchStudyOutcomeMeasure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'reference') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchStudyOutcomeMeasure.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchStudyOutcomeMeasure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'reference') then ReferenceElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchStudyOutcomeMeasure.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchStudyOutcomeMeasure.fhirType : string;
begin
  result := 'ResearchStudy.outcomeMeasure';
end;

function TFhirResearchStudyOutcomeMeasure.Link : TFhirResearchStudyOutcomeMeasure;
begin
  result := TFhirResearchStudyOutcomeMeasure(inherited Link);
end;

function TFhirResearchStudyOutcomeMeasure.Clone : TFhirResearchStudyOutcomeMeasure;
begin
  result := TFhirResearchStudyOutcomeMeasure(inherited Clone);
end;

function TFhirResearchStudyOutcomeMeasure.equals(other : TObject) : boolean; 
var
  o : TFhirResearchStudyOutcomeMeasure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchStudyOutcomeMeasure)) then
    result := false
  else
  begin
    o := TFhirResearchStudyOutcomeMeasure(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(referenceElement, o.referenceElement, true);
  end;
end;

function TFhirResearchStudyOutcomeMeasure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(Ftype_List) and isEmptyProp(FDescription) and isEmptyProp(FReference);
end;

procedure TFhirResearchStudyOutcomeMeasure.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('type');
  fields.add('description');
  fields.add('reference');
end;

function TFhirResearchStudyOutcomeMeasure.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FType_List.sizeInBytes(magic));
end;

procedure TFhirResearchStudyOutcomeMeasure.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirResearchStudyOutcomeMeasure.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirResearchStudyOutcomeMeasure.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

function TFhirResearchStudyOutcomeMeasure.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirResearchStudyOutcomeMeasure.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

procedure TFhirResearchStudyOutcomeMeasure.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirResearchStudyOutcomeMeasure.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirResearchStudyOutcomeMeasure.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirResearchStudyOutcomeMeasure.SetReference(value : TFhirReference);
begin
  FReference.free;
  FReference := value;
end;

{ TFhirResearchStudyOutcomeMeasureListEnumerator }

constructor TFhirResearchStudyOutcomeMeasureListEnumerator.Create(list : TFhirResearchStudyOutcomeMeasureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchStudyOutcomeMeasureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchStudyOutcomeMeasureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchStudyOutcomeMeasureListEnumerator.GetCurrent : TFhirResearchStudyOutcomeMeasure;
begin
  Result := FList[FIndex];
end;

function TFhirResearchStudyOutcomeMeasureListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirResearchStudyOutcomeMeasureList }

function TFhirResearchStudyOutcomeMeasureList.AddItem(value: TFhirResearchStudyOutcomeMeasure): TFhirResearchStudyOutcomeMeasure;
begin
  assert(value.ClassName = 'TFhirResearchStudyOutcomeMeasure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchStudyOutcomeMeasure');
  add(value);
  result := value;
end;

function TFhirResearchStudyOutcomeMeasureList.Append: TFhirResearchStudyOutcomeMeasure;
begin
  result := TFhirResearchStudyOutcomeMeasure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyOutcomeMeasureList.ClearItems;
begin
  Clear;
end;

function TFhirResearchStudyOutcomeMeasureList.GetEnumerator : TFhirResearchStudyOutcomeMeasureListEnumerator;
begin
  result := TFhirResearchStudyOutcomeMeasureListEnumerator.Create(self.link);
end;

function TFhirResearchStudyOutcomeMeasureList.Clone: TFhirResearchStudyOutcomeMeasureList;
begin
  result := TFhirResearchStudyOutcomeMeasureList(inherited Clone);
end;

function TFhirResearchStudyOutcomeMeasureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchStudyOutcomeMeasureList.GetItemN(index: Integer): TFhirResearchStudyOutcomeMeasure;
begin
  result := TFhirResearchStudyOutcomeMeasure(ObjectByIndex[index]);
end;

function TFhirResearchStudyOutcomeMeasureList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchStudyOutcomeMeasure;
end;
function TFhirResearchStudyOutcomeMeasureList.IndexOf(value: TFhirResearchStudyOutcomeMeasure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchStudyOutcomeMeasureList.Insert(index: Integer): TFhirResearchStudyOutcomeMeasure;
begin
  result := TFhirResearchStudyOutcomeMeasure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyOutcomeMeasureList.InsertItem(index: Integer; value: TFhirResearchStudyOutcomeMeasure);
begin
  assert(value is TFhirResearchStudyOutcomeMeasure);
  Inherited Insert(index, value);
end;

function TFhirResearchStudyOutcomeMeasureList.Item(index: Integer): TFhirResearchStudyOutcomeMeasure;
begin
  result := TFhirResearchStudyOutcomeMeasure(ObjectByIndex[index]);
end;

function TFhirResearchStudyOutcomeMeasureList.Link: TFhirResearchStudyOutcomeMeasureList;
begin
  result := TFhirResearchStudyOutcomeMeasureList(inherited Link);
end;

procedure TFhirResearchStudyOutcomeMeasureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchStudyOutcomeMeasureList.SetItemByIndex(index: Integer; value: TFhirResearchStudyOutcomeMeasure);
begin
  assert(value is TFhirResearchStudyOutcomeMeasure);
  FhirResearchStudyOutcomeMeasures[index] := value;
end;

procedure TFhirResearchStudyOutcomeMeasureList.SetItemN(index: Integer; value: TFhirResearchStudyOutcomeMeasure);
begin
  assert(value is TFhirResearchStudyOutcomeMeasure);
  ObjectByIndex[index] := value;
end;

{ TFhirResearchStudyWebLocation }

constructor TFhirResearchStudyWebLocation.Create;
begin
  inherited;
end;

destructor TFhirResearchStudyWebLocation.Destroy;
begin
  FClassifier.free;
  FUrl.free;
  inherited;
end;

procedure TFhirResearchStudyWebLocation.Assign(oSource : TFslObject);
begin
  inherited;
  classifier := TFhirResearchStudyWebLocation(oSource).classifier.Clone;
  urlElement := TFhirResearchStudyWebLocation(oSource).urlElement.Clone;
end;

procedure TFhirResearchStudyWebLocation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'classifier') Then
     list.add(self.link, 'classifier', FClassifier.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
end;

procedure TFhirResearchStudyWebLocation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'classifier', 'CodeableConcept', false, TFhirCodeableConcept, FClassifier.Link));
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
end;

function TFhirResearchStudyWebLocation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'classifier') then
  begin
    Classifier := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirResearchStudyWebLocation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirResearchStudyWebLocation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'classifier') then result := TFhirCodeableConcept.create()
  else if (propName = 'url') then result := TFhirUri.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchStudyWebLocation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'classifier') then result := 'CodeableConcept'
  else if (propName = 'url') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchStudyWebLocation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'classifier') then ClassifierElement := nil
  else if (propName = 'url') then UrlElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchStudyWebLocation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'classifier') then ClassifierElement := new as TFhirCodeableConcept
  else if (propName = 'url') then UrlElement := asUri(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchStudyWebLocation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchStudyWebLocation.fhirType : string;
begin
  result := 'ResearchStudy.webLocation';
end;

function TFhirResearchStudyWebLocation.Link : TFhirResearchStudyWebLocation;
begin
  result := TFhirResearchStudyWebLocation(inherited Link);
end;

function TFhirResearchStudyWebLocation.Clone : TFhirResearchStudyWebLocation;
begin
  result := TFhirResearchStudyWebLocation(inherited Clone);
end;

function TFhirResearchStudyWebLocation.equals(other : TObject) : boolean; 
var
  o : TFhirResearchStudyWebLocation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchStudyWebLocation)) then
    result := false
  else
  begin
    o := TFhirResearchStudyWebLocation(other);
    result := compareDeep(classifierElement, o.classifierElement, true) and compareDeep(urlElement, o.urlElement, true);
  end;
end;

function TFhirResearchStudyWebLocation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FClassifier) and isEmptyProp(FUrl);
end;

procedure TFhirResearchStudyWebLocation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('classifier');
  fields.add('url');
end;

function TFhirResearchStudyWebLocation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirResearchStudyWebLocation.SetClassifier(value : TFhirCodeableConcept);
begin
  FClassifier.free;
  FClassifier := value;
end;

procedure TFhirResearchStudyWebLocation.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirResearchStudyWebLocation.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirResearchStudyWebLocation.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

{ TFhirResearchStudyWebLocationListEnumerator }

constructor TFhirResearchStudyWebLocationListEnumerator.Create(list : TFhirResearchStudyWebLocationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchStudyWebLocationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchStudyWebLocationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchStudyWebLocationListEnumerator.GetCurrent : TFhirResearchStudyWebLocation;
begin
  Result := FList[FIndex];
end;

function TFhirResearchStudyWebLocationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirResearchStudyWebLocationList }

function TFhirResearchStudyWebLocationList.AddItem(value: TFhirResearchStudyWebLocation): TFhirResearchStudyWebLocation;
begin
  assert(value.ClassName = 'TFhirResearchStudyWebLocation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchStudyWebLocation');
  add(value);
  result := value;
end;

function TFhirResearchStudyWebLocationList.Append: TFhirResearchStudyWebLocation;
begin
  result := TFhirResearchStudyWebLocation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyWebLocationList.ClearItems;
begin
  Clear;
end;

function TFhirResearchStudyWebLocationList.GetEnumerator : TFhirResearchStudyWebLocationListEnumerator;
begin
  result := TFhirResearchStudyWebLocationListEnumerator.Create(self.link);
end;

function TFhirResearchStudyWebLocationList.Clone: TFhirResearchStudyWebLocationList;
begin
  result := TFhirResearchStudyWebLocationList(inherited Clone);
end;

function TFhirResearchStudyWebLocationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchStudyWebLocationList.GetItemN(index: Integer): TFhirResearchStudyWebLocation;
begin
  result := TFhirResearchStudyWebLocation(ObjectByIndex[index]);
end;

function TFhirResearchStudyWebLocationList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchStudyWebLocation;
end;
function TFhirResearchStudyWebLocationList.IndexOf(value: TFhirResearchStudyWebLocation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchStudyWebLocationList.Insert(index: Integer): TFhirResearchStudyWebLocation;
begin
  result := TFhirResearchStudyWebLocation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyWebLocationList.InsertItem(index: Integer; value: TFhirResearchStudyWebLocation);
begin
  assert(value is TFhirResearchStudyWebLocation);
  Inherited Insert(index, value);
end;

function TFhirResearchStudyWebLocationList.Item(index: Integer): TFhirResearchStudyWebLocation;
begin
  result := TFhirResearchStudyWebLocation(ObjectByIndex[index]);
end;

function TFhirResearchStudyWebLocationList.Link: TFhirResearchStudyWebLocationList;
begin
  result := TFhirResearchStudyWebLocationList(inherited Link);
end;

procedure TFhirResearchStudyWebLocationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchStudyWebLocationList.SetItemByIndex(index: Integer; value: TFhirResearchStudyWebLocation);
begin
  assert(value is TFhirResearchStudyWebLocation);
  FhirResearchStudyWebLocations[index] := value;
end;

procedure TFhirResearchStudyWebLocationList.SetItemN(index: Integer; value: TFhirResearchStudyWebLocation);
begin
  assert(value is TFhirResearchStudyWebLocation);
  ObjectByIndex[index] := value;
end;

{ TFhirResearchStudy }

constructor TFhirResearchStudy.Create;
begin
  inherited;
end;

destructor TFhirResearchStudy.Destroy;
begin
  FUrl.free;
  FIdentifierList.Free;
  FVersion.free;
  FName.free;
  FTitle.free;
  FLabel_List.Free;
  FProtocolList.Free;
  FPartOfList.Free;
  FRelatedArtifactList.Free;
  FDate.free;
  FStatus.free;
  FPrimaryPurposeType.free;
  FPhase.free;
  FStudyDesignList.Free;
  FFocusList.Free;
  FConditionList.Free;
  FKeywordList.Free;
  FRegionList.Free;
  FDescriptionSummary.free;
  FDescription.free;
  FPeriod.free;
  FSiteList.Free;
  FNoteList.Free;
  FClassifierList.Free;
  FAssociatedPartyList.Free;
  FProgressStatusList.Free;
  FWhyStopped.free;
  FRecruitment.free;
  FComparisonGroupList.Free;
  FObjectiveList.Free;
  FOutcomeMeasureList.Free;
  FResultList.Free;
  FWebLocationList.Free;
  inherited;
end;

procedure TFhirResearchStudy.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirResearchStudy(oSource).urlElement.Clone;
  if (TFhirResearchStudy(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirResearchStudy(oSource).FIdentifierList);
  end;
  versionElement := TFhirResearchStudy(oSource).versionElement.Clone;
  nameElement := TFhirResearchStudy(oSource).nameElement.Clone;
  titleElement := TFhirResearchStudy(oSource).titleElement.Clone;
  if (TFhirResearchStudy(oSource).FLabel_List = nil) then
  begin
    FLabel_List.free;
    FLabel_List := nil;
  end
  else
  begin
    if FLabel_List = nil then
      FLabel_List := TFhirResearchStudyLabelList.Create;
    FLabel_List.Assign(TFhirResearchStudy(oSource).FLabel_List);
  end;
  if (TFhirResearchStudy(oSource).FProtocolList = nil) then
  begin
    FProtocolList.free;
    FProtocolList := nil;
  end
  else
  begin
    if FProtocolList = nil then
      FProtocolList := TFhirReferenceList.Create;
    FProtocolList.Assign(TFhirResearchStudy(oSource).FProtocolList);
  end;
  if (TFhirResearchStudy(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirResearchStudy(oSource).FPartOfList);
  end;
  if (TFhirResearchStudy(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirResearchStudy(oSource).FRelatedArtifactList);
  end;
  dateElement := TFhirResearchStudy(oSource).dateElement.Clone;
  statusElement := TFhirResearchStudy(oSource).statusElement.Clone;
  primaryPurposeType := TFhirResearchStudy(oSource).primaryPurposeType.Clone;
  phase := TFhirResearchStudy(oSource).phase.Clone;
  if (TFhirResearchStudy(oSource).FStudyDesignList = nil) then
  begin
    FStudyDesignList.free;
    FStudyDesignList := nil;
  end
  else
  begin
    if FStudyDesignList = nil then
      FStudyDesignList := TFhirCodeableConceptList.Create;
    FStudyDesignList.Assign(TFhirResearchStudy(oSource).FStudyDesignList);
  end;
  if (TFhirResearchStudy(oSource).FFocusList = nil) then
  begin
    FFocusList.free;
    FFocusList := nil;
  end
  else
  begin
    if FFocusList = nil then
      FFocusList := TFhirResearchStudyFocusList.Create;
    FFocusList.Assign(TFhirResearchStudy(oSource).FFocusList);
  end;
  if (TFhirResearchStudy(oSource).FConditionList = nil) then
  begin
    FConditionList.free;
    FConditionList := nil;
  end
  else
  begin
    if FConditionList = nil then
      FConditionList := TFhirCodeableConceptList.Create;
    FConditionList.Assign(TFhirResearchStudy(oSource).FConditionList);
  end;
  if (TFhirResearchStudy(oSource).FKeywordList = nil) then
  begin
    FKeywordList.free;
    FKeywordList := nil;
  end
  else
  begin
    if FKeywordList = nil then
      FKeywordList := TFhirCodeableConceptList.Create;
    FKeywordList.Assign(TFhirResearchStudy(oSource).FKeywordList);
  end;
  if (TFhirResearchStudy(oSource).FRegionList = nil) then
  begin
    FRegionList.free;
    FRegionList := nil;
  end
  else
  begin
    if FRegionList = nil then
      FRegionList := TFhirCodeableConceptList.Create;
    FRegionList.Assign(TFhirResearchStudy(oSource).FRegionList);
  end;
  descriptionSummaryElement := TFhirResearchStudy(oSource).descriptionSummaryElement.Clone;
  descriptionElement := TFhirResearchStudy(oSource).descriptionElement.Clone;
  period := TFhirResearchStudy(oSource).period.Clone;
  if (TFhirResearchStudy(oSource).FSiteList = nil) then
  begin
    FSiteList.free;
    FSiteList := nil;
  end
  else
  begin
    if FSiteList = nil then
      FSiteList := TFhirReferenceList.Create;
    FSiteList.Assign(TFhirResearchStudy(oSource).FSiteList);
  end;
  if (TFhirResearchStudy(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirResearchStudy(oSource).FNoteList);
  end;
  if (TFhirResearchStudy(oSource).FClassifierList = nil) then
  begin
    FClassifierList.free;
    FClassifierList := nil;
  end
  else
  begin
    if FClassifierList = nil then
      FClassifierList := TFhirCodeableConceptList.Create;
    FClassifierList.Assign(TFhirResearchStudy(oSource).FClassifierList);
  end;
  if (TFhirResearchStudy(oSource).FAssociatedPartyList = nil) then
  begin
    FAssociatedPartyList.free;
    FAssociatedPartyList := nil;
  end
  else
  begin
    if FAssociatedPartyList = nil then
      FAssociatedPartyList := TFhirResearchStudyAssociatedPartyList.Create;
    FAssociatedPartyList.Assign(TFhirResearchStudy(oSource).FAssociatedPartyList);
  end;
  if (TFhirResearchStudy(oSource).FProgressStatusList = nil) then
  begin
    FProgressStatusList.free;
    FProgressStatusList := nil;
  end
  else
  begin
    if FProgressStatusList = nil then
      FProgressStatusList := TFhirResearchStudyProgressStatusList.Create;
    FProgressStatusList.Assign(TFhirResearchStudy(oSource).FProgressStatusList);
  end;
  whyStopped := TFhirResearchStudy(oSource).whyStopped.Clone;
  recruitment := TFhirResearchStudy(oSource).recruitment.Clone;
  if (TFhirResearchStudy(oSource).FComparisonGroupList = nil) then
  begin
    FComparisonGroupList.free;
    FComparisonGroupList := nil;
  end
  else
  begin
    if FComparisonGroupList = nil then
      FComparisonGroupList := TFhirResearchStudyComparisonGroupList.Create;
    FComparisonGroupList.Assign(TFhirResearchStudy(oSource).FComparisonGroupList);
  end;
  if (TFhirResearchStudy(oSource).FObjectiveList = nil) then
  begin
    FObjectiveList.free;
    FObjectiveList := nil;
  end
  else
  begin
    if FObjectiveList = nil then
      FObjectiveList := TFhirResearchStudyObjectiveList.Create;
    FObjectiveList.Assign(TFhirResearchStudy(oSource).FObjectiveList);
  end;
  if (TFhirResearchStudy(oSource).FOutcomeMeasureList = nil) then
  begin
    FOutcomeMeasureList.free;
    FOutcomeMeasureList := nil;
  end
  else
  begin
    if FOutcomeMeasureList = nil then
      FOutcomeMeasureList := TFhirResearchStudyOutcomeMeasureList.Create;
    FOutcomeMeasureList.Assign(TFhirResearchStudy(oSource).FOutcomeMeasureList);
  end;
  if (TFhirResearchStudy(oSource).FResultList = nil) then
  begin
    FResultList.free;
    FResultList := nil;
  end
  else
  begin
    if FResultList = nil then
      FResultList := TFhirReferenceList.Create;
    FResultList.Assign(TFhirResearchStudy(oSource).FResultList);
  end;
  if (TFhirResearchStudy(oSource).FWebLocationList = nil) then
  begin
    FWebLocationList.free;
    FWebLocationList := nil;
  end
  else
  begin
    if FWebLocationList = nil then
      FWebLocationList := TFhirResearchStudyWebLocationList.Create;
    FWebLocationList.Assign(TFhirResearchStudy(oSource).FWebLocationList);
  end;
end;

function TFhirResearchStudy.GetResourceType : TFhirResourceType;
begin
  result := frtResearchStudy;
end;

procedure TFhirResearchStudy.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'label') Then
    list.addAll(self, 'label', FLabel_List);
  if (child_name = 'protocol') Then
    list.addAll(self, 'protocol', FProtocolList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'primaryPurposeType') Then
     list.add(self.link, 'primaryPurposeType', FPrimaryPurposeType.Link);
  if (child_name = 'phase') Then
     list.add(self.link, 'phase', FPhase.Link);
  if (child_name = 'studyDesign') Then
    list.addAll(self, 'studyDesign', FStudyDesignList);
  if (child_name = 'focus') Then
    list.addAll(self, 'focus', FFocusList);
  if (child_name = 'condition') Then
    list.addAll(self, 'condition', FConditionList);
  if (child_name = 'keyword') Then
    list.addAll(self, 'keyword', FKeywordList);
  if (child_name = 'region') Then
    list.addAll(self, 'region', FRegionList);
  if (child_name = 'descriptionSummary') Then
     list.add(self.link, 'descriptionSummary', FDescriptionSummary.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'site') Then
    list.addAll(self, 'site', FSiteList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'classifier') Then
    list.addAll(self, 'classifier', FClassifierList);
  if (child_name = 'associatedParty') Then
    list.addAll(self, 'associatedParty', FAssociatedPartyList);
  if (child_name = 'progressStatus') Then
    list.addAll(self, 'progressStatus', FProgressStatusList);
  if (child_name = 'whyStopped') Then
     list.add(self.link, 'whyStopped', FWhyStopped.Link);
  if (child_name = 'recruitment') Then
     list.add(self.link, 'recruitment', FRecruitment.Link);
  if (child_name = 'comparisonGroup') Then
    list.addAll(self, 'comparisonGroup', FComparisonGroupList);
  if (child_name = 'objective') Then
    list.addAll(self, 'objective', FObjectiveList);
  if (child_name = 'outcomeMeasure') Then
    list.addAll(self, 'outcomeMeasure', FOutcomeMeasureList);
  if (child_name = 'result') Then
    list.addAll(self, 'result', FResultList);
  if (child_name = 'webLocation') Then
    list.addAll(self, 'webLocation', FWebLocationList);
end;

procedure TFhirResearchStudy.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'label', 'BackboneElement', true, TFhirResearchStudyLabel, FLabel_List.Link));
  oList.add(TFHIRProperty.create(self, 'protocol', 'Reference', true, TFhirReference, FProtocolList.Link));
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link));
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'primaryPurposeType', 'CodeableConcept', false, TFhirCodeableConcept, FPrimaryPurposeType.Link));
  oList.add(TFHIRProperty.create(self, 'phase', 'CodeableConcept', false, TFhirCodeableConcept, FPhase.Link));
  oList.add(TFHIRProperty.create(self, 'studyDesign', 'CodeableConcept', true, TFhirCodeableConcept, FStudyDesignList.Link));
  oList.add(TFHIRProperty.create(self, 'focus', 'BackboneElement', true, TFhirResearchStudyFocus, FFocusList.Link));
  oList.add(TFHIRProperty.create(self, 'condition', 'CodeableConcept', true, TFhirCodeableConcept, FConditionList.Link));
  oList.add(TFHIRProperty.create(self, 'keyword', 'CodeableConcept', true, TFhirCodeableConcept, FKeywordList.Link));
  oList.add(TFHIRProperty.create(self, 'region', 'CodeableConcept', true, TFhirCodeableConcept, FRegionList.Link));
  oList.add(TFHIRProperty.create(self, 'descriptionSummary', 'markdown', false, TFhirMarkdown, FDescriptionSummary.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'site', 'Reference', true, TFhirReference, FSiteList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'classifier', 'CodeableConcept', true, TFhirCodeableConcept, FClassifierList.Link));
  oList.add(TFHIRProperty.create(self, 'associatedParty', 'BackboneElement', true, TFhirResearchStudyAssociatedParty, FAssociatedPartyList.Link));
  oList.add(TFHIRProperty.create(self, 'progressStatus', 'BackboneElement', true, TFhirResearchStudyProgressStatus, FProgressStatusList.Link));
  oList.add(TFHIRProperty.create(self, 'whyStopped', 'CodeableConcept', false, TFhirCodeableConcept, FWhyStopped.Link));
  oList.add(TFHIRProperty.create(self, 'recruitment', 'BackboneElement', false, TFhirResearchStudyRecruitment, FRecruitment.Link));
  oList.add(TFHIRProperty.create(self, 'comparisonGroup', 'BackboneElement', true, TFhirResearchStudyComparisonGroup, FComparisonGroupList.Link));
  oList.add(TFHIRProperty.create(self, 'objective', 'BackboneElement', true, TFhirResearchStudyObjective, FObjectiveList.Link));
  oList.add(TFHIRProperty.create(self, 'outcomeMeasure', 'BackboneElement', true, TFhirResearchStudyOutcomeMeasure, FOutcomeMeasureList.Link));
  oList.add(TFHIRProperty.create(self, 'result', 'Reference', true, TFhirReference, FResultList.Link));
  oList.add(TFHIRProperty.create(self, 'webLocation', 'BackboneElement', true, TFhirResearchStudyWebLocation, FWebLocationList.Link));
end;

function TFhirResearchStudy.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'label') then
  begin
    Label_List.add(propValue as TFhirResearchStudyLabel);
    result := propValue;
  end
  else if (propName = 'protocol') then
  begin
    ProtocolList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact);
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'primaryPurposeType') then
  begin
    PrimaryPurposeType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'phase') then
  begin
    Phase := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'studyDesign') then
  begin
    StudyDesignList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'focus') then
  begin
    FocusList.add(propValue as TFhirResearchStudyFocus);
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    ConditionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'keyword') then
  begin
    KeywordList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'region') then
  begin
    RegionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'descriptionSummary') then
  begin
    DescriptionSummaryElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'site') then
  begin
    SiteList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'classifier') then
  begin
    ClassifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'associatedParty') then
  begin
    AssociatedPartyList.add(propValue as TFhirResearchStudyAssociatedParty);
    result := propValue;
  end
  else if (propName = 'progressStatus') then
  begin
    ProgressStatusList.add(propValue as TFhirResearchStudyProgressStatus);
    result := propValue;
  end
  else if (propName = 'whyStopped') then
  begin
    WhyStopped := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'recruitment') then
  begin
    Recruitment := propValue as TFhirResearchStudyRecruitment;
    result := propValue;
  end
  else if (propName = 'comparisonGroup') then
  begin
    ComparisonGroupList.add(propValue as TFhirResearchStudyComparisonGroup);
    result := propValue;
  end
  else if (propName = 'objective') then
  begin
    ObjectiveList.add(propValue as TFhirResearchStudyObjective);
    result := propValue;
  end
  else if (propName = 'outcomeMeasure') then
  begin
    OutcomeMeasureList.add(propValue as TFhirResearchStudyOutcomeMeasure);
    result := propValue;
  end
  else if (propName = 'result') then
  begin
    ResultList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'webLocation') then
  begin
    WebLocationList.add(propValue as TFhirResearchStudyWebLocation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirResearchStudy.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'label') then Label_List.insertItem(index, propValue as TFhirResearchStudyLabel)
  else if (propName = 'protocol') then ProtocolList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact)
  else if (propName = 'studyDesign') then StudyDesignList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'focus') then FocusList.insertItem(index, propValue as TFhirResearchStudyFocus)
  else if (propName = 'condition') then ConditionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'keyword') then KeywordList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'region') then RegionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'site') then SiteList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'classifier') then ClassifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'associatedParty') then AssociatedPartyList.insertItem(index, propValue as TFhirResearchStudyAssociatedParty)
  else if (propName = 'progressStatus') then ProgressStatusList.insertItem(index, propValue as TFhirResearchStudyProgressStatus)
  else if (propName = 'comparisonGroup') then ComparisonGroupList.insertItem(index, propValue as TFhirResearchStudyComparisonGroup)
  else if (propName = 'objective') then ObjectiveList.insertItem(index, propValue as TFhirResearchStudyObjective)
  else if (propName = 'outcomeMeasure') then OutcomeMeasureList.insertItem(index, propValue as TFhirResearchStudyOutcomeMeasure)
  else if (propName = 'result') then ResultList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'webLocation') then WebLocationList.insertItem(index, propValue as TFhirResearchStudyWebLocation)
  else inherited;
end;

function TFhirResearchStudy.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'label') then result := Label_List.new()
  else if (propName = 'protocol') then result := ProtocolList.new()
  else if (propName = 'partOf') then result := PartOfList.new()
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'primaryPurposeType') then result := TFhirCodeableConcept.create()
  else if (propName = 'phase') then result := TFhirCodeableConcept.create()
  else if (propName = 'studyDesign') then result := StudyDesignList.new()
  else if (propName = 'focus') then result := FocusList.new()
  else if (propName = 'condition') then result := ConditionList.new()
  else if (propName = 'keyword') then result := KeywordList.new()
  else if (propName = 'region') then result := RegionList.new()
  else if (propName = 'descriptionSummary') then result := TFhirMarkdown.create()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'site') then result := SiteList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'classifier') then result := ClassifierList.new()
  else if (propName = 'associatedParty') then result := AssociatedPartyList.new()
  else if (propName = 'progressStatus') then result := ProgressStatusList.new()
  else if (propName = 'whyStopped') then result := TFhirCodeableConcept.create()
  else if (propName = 'recruitment') then result := TFhirResearchStudyRecruitment.create()
  else if (propName = 'comparisonGroup') then result := ComparisonGroupList.new()
  else if (propName = 'objective') then result := ObjectiveList.new()
  else if (propName = 'outcomeMeasure') then result := OutcomeMeasureList.new()
  else if (propName = 'result') then result := ResultList.new()
  else if (propName = 'webLocation') then result := WebLocationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchStudy.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'label') then result := 'BackboneElement'
  else if (propName = 'protocol') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'primaryPurposeType') then result := 'CodeableConcept'
  else if (propName = 'phase') then result := 'CodeableConcept'
  else if (propName = 'studyDesign') then result := 'CodeableConcept'
  else if (propName = 'focus') then result := 'BackboneElement'
  else if (propName = 'condition') then result := 'CodeableConcept'
  else if (propName = 'keyword') then result := 'CodeableConcept'
  else if (propName = 'region') then result := 'CodeableConcept'
  else if (propName = 'descriptionSummary') then result := 'markdown'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'site') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'classifier') then result := 'CodeableConcept'
  else if (propName = 'associatedParty') then result := 'BackboneElement'
  else if (propName = 'progressStatus') then result := 'BackboneElement'
  else if (propName = 'whyStopped') then result := 'CodeableConcept'
  else if (propName = 'recruitment') then result := 'BackboneElement'
  else if (propName = 'comparisonGroup') then result := 'BackboneElement'
  else if (propName = 'objective') then result := 'BackboneElement'
  else if (propName = 'outcomeMeasure') then result := 'BackboneElement'
  else if (propName = 'result') then result := 'Reference'
  else if (propName = 'webLocation') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchStudy.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'label') then deletePropertyValue('label', Label_List, value)
  else if (propName = 'protocol') then deletePropertyValue('protocol', ProtocolList, value)
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value)
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value)
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'primaryPurposeType') then PrimaryPurposeTypeElement := nil
  else if (propName = 'phase') then PhaseElement := nil
  else if (propName = 'studyDesign') then deletePropertyValue('studyDesign', StudyDesignList, value)
  else if (propName = 'focus') then deletePropertyValue('focus', FocusList, value)
  else if (propName = 'condition') then deletePropertyValue('condition', ConditionList, value)
  else if (propName = 'keyword') then deletePropertyValue('keyword', KeywordList, value)
  else if (propName = 'region') then deletePropertyValue('region', RegionList, value)
  else if (propName = 'descriptionSummary') then DescriptionSummaryElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'site') then deletePropertyValue('site', SiteList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'classifier') then deletePropertyValue('classifier', ClassifierList, value)
  else if (propName = 'associatedParty') then deletePropertyValue('associatedParty', AssociatedPartyList, value)
  else if (propName = 'progressStatus') then deletePropertyValue('progressStatus', ProgressStatusList, value)
  else if (propName = 'whyStopped') then WhyStoppedElement := nil
  else if (propName = 'recruitment') then RecruitmentElement := nil
  else if (propName = 'comparisonGroup') then deletePropertyValue('comparisonGroup', ComparisonGroupList, value)
  else if (propName = 'objective') then deletePropertyValue('objective', ObjectiveList, value)
  else if (propName = 'outcomeMeasure') then deletePropertyValue('outcomeMeasure', OutcomeMeasureList, value)
  else if (propName = 'result') then deletePropertyValue('result', ResultList, value)
  else if (propName = 'webLocation') then deletePropertyValue('webLocation', WebLocationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchStudy.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'label') then replacePropertyValue('label', Label_List, existing, new)
  else if (propName = 'protocol') then replacePropertyValue('protocol', ProtocolList, existing, new)
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new)
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new)
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'primaryPurposeType') then PrimaryPurposeTypeElement := new as TFhirCodeableConcept
  else if (propName = 'phase') then PhaseElement := new as TFhirCodeableConcept
  else if (propName = 'studyDesign') then replacePropertyValue('studyDesign', StudyDesignList, existing, new)
  else if (propName = 'focus') then replacePropertyValue('focus', FocusList, existing, new)
  else if (propName = 'condition') then replacePropertyValue('condition', ConditionList, existing, new)
  else if (propName = 'keyword') then replacePropertyValue('keyword', KeywordList, existing, new)
  else if (propName = 'region') then replacePropertyValue('region', RegionList, existing, new)
  else if (propName = 'descriptionSummary') then DescriptionSummaryElement := asMarkdown(new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'site') then replacePropertyValue('site', SiteList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'classifier') then replacePropertyValue('classifier', ClassifierList, existing, new)
  else if (propName = 'associatedParty') then replacePropertyValue('associatedParty', AssociatedPartyList, existing, new)
  else if (propName = 'progressStatus') then replacePropertyValue('progressStatus', ProgressStatusList, existing, new)
  else if (propName = 'whyStopped') then WhyStoppedElement := new as TFhirCodeableConcept
  else if (propName = 'recruitment') then RecruitmentElement := new as TFhirResearchStudyRecruitment
  else if (propName = 'comparisonGroup') then replacePropertyValue('comparisonGroup', ComparisonGroupList, existing, new)
  else if (propName = 'objective') then replacePropertyValue('objective', ObjectiveList, existing, new)
  else if (propName = 'outcomeMeasure') then replacePropertyValue('outcomeMeasure', OutcomeMeasureList, existing, new)
  else if (propName = 'result') then replacePropertyValue('result', ResultList, existing, new)
  else if (propName = 'webLocation') then replacePropertyValue('webLocation', WebLocationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchStudy.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'label') then Label_List.move(source, destination)
  else if (propName = 'protocol') then ProtocolList.move(source, destination)
  else if (propName = 'partOf') then PartOfList.move(source, destination)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination)
  else if (propName = 'studyDesign') then StudyDesignList.move(source, destination)
  else if (propName = 'focus') then FocusList.move(source, destination)
  else if (propName = 'condition') then ConditionList.move(source, destination)
  else if (propName = 'keyword') then KeywordList.move(source, destination)
  else if (propName = 'region') then RegionList.move(source, destination)
  else if (propName = 'site') then SiteList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'classifier') then ClassifierList.move(source, destination)
  else if (propName = 'associatedParty') then AssociatedPartyList.move(source, destination)
  else if (propName = 'progressStatus') then ProgressStatusList.move(source, destination)
  else if (propName = 'comparisonGroup') then ComparisonGroupList.move(source, destination)
  else if (propName = 'objective') then ObjectiveList.move(source, destination)
  else if (propName = 'outcomeMeasure') then OutcomeMeasureList.move(source, destination)
  else if (propName = 'result') then ResultList.move(source, destination)
  else if (propName = 'webLocation') then WebLocationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchStudy.fhirType : string;
begin
  result := 'ResearchStudy';
end;

function TFhirResearchStudy.Link : TFhirResearchStudy;
begin
  result := TFhirResearchStudy(inherited Link);
end;

function TFhirResearchStudy.Clone : TFhirResearchStudy;
begin
  result := TFhirResearchStudy(inherited Clone);
end;

function TFhirResearchStudy.equals(other : TObject) : boolean; 
var
  o : TFhirResearchStudy;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchStudy)) then
    result := false
  else
  begin
    o := TFhirResearchStudy(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(label_List, o.label_List, true) and 
      compareDeep(protocolList, o.protocolList, true) and compareDeep(partOfList, o.partOfList, true) and 
      compareDeep(relatedArtifactList, o.relatedArtifactList, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(primaryPurposeTypeElement, o.primaryPurposeTypeElement, true) and 
      compareDeep(phaseElement, o.phaseElement, true) and compareDeep(studyDesignList, o.studyDesignList, true) and 
      compareDeep(focusList, o.focusList, true) and compareDeep(conditionList, o.conditionList, true) and 
      compareDeep(keywordList, o.keywordList, true) and compareDeep(regionList, o.regionList, true) and 
      compareDeep(descriptionSummaryElement, o.descriptionSummaryElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(siteList, o.siteList, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(classifierList, o.classifierList, true) and compareDeep(associatedPartyList, o.associatedPartyList, true) and 
      compareDeep(progressStatusList, o.progressStatusList, true) and compareDeep(whyStoppedElement, o.whyStoppedElement, true) and 
      compareDeep(recruitmentElement, o.recruitmentElement, true) and compareDeep(comparisonGroupList, o.comparisonGroupList, true) and 
      compareDeep(objectiveList, o.objectiveList, true) and compareDeep(outcomeMeasureList, o.outcomeMeasureList, true) and 
      compareDeep(resultList, o.resultList, true) and compareDeep(webLocationList, o.webLocationList, true);
  end;
end;

function TFhirResearchStudy.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FidentifierList) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(Flabel_List) and isEmptyProp(FprotocolList) and isEmptyProp(FpartOfList) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(FDate) and isEmptyProp(FStatus) and isEmptyProp(FPrimaryPurposeType) and isEmptyProp(FPhase) and isEmptyProp(FstudyDesignList) and isEmptyProp(FfocusList) and isEmptyProp(FconditionList) and isEmptyProp(FkeywordList) and isEmptyProp(FregionList) and isEmptyProp(FDescriptionSummary) and isEmptyProp(FDescription) and isEmptyProp(FPeriod) and isEmptyProp(FsiteList) and isEmptyProp(FnoteList) and isEmptyProp(FclassifierList) and isEmptyProp(FassociatedPartyList) and isEmptyProp(FprogressStatusList) and isEmptyProp(FWhyStopped) and isEmptyProp(FRecruitment) and isEmptyProp(FcomparisonGroupList) and isEmptyProp(FobjectiveList) and isEmptyProp(FoutcomeMeasureList) and isEmptyProp(FresultList)
       and isEmptyProp(FwebLocationList);
end;

procedure TFhirResearchStudy.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('label');
  fields.add('protocol');
  fields.add('partOf');
  fields.add('relatedArtifact');
  fields.add('date');
  fields.add('status');
  fields.add('primaryPurposeType');
  fields.add('phase');
  fields.add('studyDesign');
  fields.add('focus');
  fields.add('condition');
  fields.add('keyword');
  fields.add('region');
  fields.add('descriptionSummary');
  fields.add('description');
  fields.add('period');
  fields.add('site');
  fields.add('note');
  fields.add('classifier');
  fields.add('associatedParty');
  fields.add('progressStatus');
  fields.add('whyStopped');
  fields.add('recruitment');
  fields.add('comparisonGroup');
  fields.add('objective');
  fields.add('outcomeMeasure');
  fields.add('result');
  fields.add('webLocation');
end;

function TFhirResearchStudy.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FLabel_List.sizeInBytes(magic));
  inc(result, FProtocolList.sizeInBytes(magic));
  inc(result, FPartOfList.sizeInBytes(magic));
  inc(result, FRelatedArtifactList.sizeInBytes(magic));
  inc(result, FStudyDesignList.sizeInBytes(magic));
  inc(result, FFocusList.sizeInBytes(magic));
  inc(result, FConditionList.sizeInBytes(magic));
  inc(result, FKeywordList.sizeInBytes(magic));
  inc(result, FRegionList.sizeInBytes(magic));
  inc(result, FSiteList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FClassifierList.sizeInBytes(magic));
  inc(result, FAssociatedPartyList.sizeInBytes(magic));
  inc(result, FProgressStatusList.sizeInBytes(magic));
  inc(result, FComparisonGroupList.sizeInBytes(magic));
  inc(result, FObjectiveList.sizeInBytes(magic));
  inc(result, FOutcomeMeasureList.sizeInBytes(magic));
  inc(result, FResultList.sizeInBytes(magic));
  inc(result, FWebLocationList.sizeInBytes(magic));
end;

procedure TFhirResearchStudy.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirResearchStudy.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirResearchStudy.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirResearchStudy.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirResearchStudy.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirResearchStudy.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirResearchStudy.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirResearchStudy.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirResearchStudy.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirResearchStudy.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirResearchStudy.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirResearchStudy.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirResearchStudy.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirResearchStudy.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

function TFhirResearchStudy.GetLabel_List : TFhirResearchStudyLabelList;
begin
  if FLabel_List = nil then
    FLabel_List := TFhirResearchStudyLabelList.Create;
  result := FLabel_List;
end;

function TFhirResearchStudy.GetHasLabel_List : boolean;
begin
  result := (FLabel_List <> nil) and (FLabel_List.count > 0);
end;

function TFhirResearchStudy.GetProtocolList : TFhirReferenceList;
begin
  if FProtocolList = nil then
    FProtocolList := TFhirReferenceList.Create;
  result := FProtocolList;
end;

function TFhirResearchStudy.GetHasProtocolList : boolean;
begin
  result := (FProtocolList <> nil) and (FProtocolList.count > 0);
end;

function TFhirResearchStudy.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirResearchStudy.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

function TFhirResearchStudy.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

function TFhirResearchStudy.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

procedure TFhirResearchStudy.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirResearchStudy.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirResearchStudy.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirResearchStudy.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirResearchStudy.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirResearchStudy.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirResearchStudy.SetPrimaryPurposeType(value : TFhirCodeableConcept);
begin
  FPrimaryPurposeType.free;
  FPrimaryPurposeType := value;
end;

procedure TFhirResearchStudy.SetPhase(value : TFhirCodeableConcept);
begin
  FPhase.free;
  FPhase := value;
end;

function TFhirResearchStudy.GetStudyDesignList : TFhirCodeableConceptList;
begin
  if FStudyDesignList = nil then
    FStudyDesignList := TFhirCodeableConceptList.Create;
  result := FStudyDesignList;
end;

function TFhirResearchStudy.GetHasStudyDesignList : boolean;
begin
  result := (FStudyDesignList <> nil) and (FStudyDesignList.count > 0);
end;

function TFhirResearchStudy.GetFocusList : TFhirResearchStudyFocusList;
begin
  if FFocusList = nil then
    FFocusList := TFhirResearchStudyFocusList.Create;
  result := FFocusList;
end;

function TFhirResearchStudy.GetHasFocusList : boolean;
begin
  result := (FFocusList <> nil) and (FFocusList.count > 0);
end;

function TFhirResearchStudy.GetConditionList : TFhirCodeableConceptList;
begin
  if FConditionList = nil then
    FConditionList := TFhirCodeableConceptList.Create;
  result := FConditionList;
end;

function TFhirResearchStudy.GetHasConditionList : boolean;
begin
  result := (FConditionList <> nil) and (FConditionList.count > 0);
end;

function TFhirResearchStudy.GetKeywordList : TFhirCodeableConceptList;
begin
  if FKeywordList = nil then
    FKeywordList := TFhirCodeableConceptList.Create;
  result := FKeywordList;
end;

function TFhirResearchStudy.GetHasKeywordList : boolean;
begin
  result := (FKeywordList <> nil) and (FKeywordList.count > 0);
end;

function TFhirResearchStudy.GetRegionList : TFhirCodeableConceptList;
begin
  if FRegionList = nil then
    FRegionList := TFhirCodeableConceptList.Create;
  result := FRegionList;
end;

function TFhirResearchStudy.GetHasRegionList : boolean;
begin
  result := (FRegionList <> nil) and (FRegionList.count > 0);
end;

procedure TFhirResearchStudy.SetDescriptionSummary(value : TFhirMarkdown);
begin
  FDescriptionSummary.free;
  FDescriptionSummary := value;
end;

function TFhirResearchStudy.GetDescriptionSummaryST : String;
begin
  if FDescriptionSummary = nil then
    result := ''
  else
    result := FDescriptionSummary.value;
end;

procedure TFhirResearchStudy.SetDescriptionSummaryST(value : String);
begin
  if value <> '' then
  begin
    if FDescriptionSummary = nil then
      FDescriptionSummary := TFhirMarkdown.create;
    FDescriptionSummary.value := value
  end
  else if FDescriptionSummary <> nil then
    FDescriptionSummary.value := '';
end;

procedure TFhirResearchStudy.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirResearchStudy.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirResearchStudy.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirResearchStudy.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirResearchStudy.GetSiteList : TFhirReferenceList;
begin
  if FSiteList = nil then
    FSiteList := TFhirReferenceList.Create;
  result := FSiteList;
end;

function TFhirResearchStudy.GetHasSiteList : boolean;
begin
  result := (FSiteList <> nil) and (FSiteList.count > 0);
end;

function TFhirResearchStudy.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirResearchStudy.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirResearchStudy.GetClassifierList : TFhirCodeableConceptList;
begin
  if FClassifierList = nil then
    FClassifierList := TFhirCodeableConceptList.Create;
  result := FClassifierList;
end;

function TFhirResearchStudy.GetHasClassifierList : boolean;
begin
  result := (FClassifierList <> nil) and (FClassifierList.count > 0);
end;

function TFhirResearchStudy.GetAssociatedPartyList : TFhirResearchStudyAssociatedPartyList;
begin
  if FAssociatedPartyList = nil then
    FAssociatedPartyList := TFhirResearchStudyAssociatedPartyList.Create;
  result := FAssociatedPartyList;
end;

function TFhirResearchStudy.GetHasAssociatedPartyList : boolean;
begin
  result := (FAssociatedPartyList <> nil) and (FAssociatedPartyList.count > 0);
end;

function TFhirResearchStudy.GetProgressStatusList : TFhirResearchStudyProgressStatusList;
begin
  if FProgressStatusList = nil then
    FProgressStatusList := TFhirResearchStudyProgressStatusList.Create;
  result := FProgressStatusList;
end;

function TFhirResearchStudy.GetHasProgressStatusList : boolean;
begin
  result := (FProgressStatusList <> nil) and (FProgressStatusList.count > 0);
end;

procedure TFhirResearchStudy.SetWhyStopped(value : TFhirCodeableConcept);
begin
  FWhyStopped.free;
  FWhyStopped := value;
end;

procedure TFhirResearchStudy.SetRecruitment(value : TFhirResearchStudyRecruitment);
begin
  FRecruitment.free;
  FRecruitment := value;
end;

function TFhirResearchStudy.GetComparisonGroupList : TFhirResearchStudyComparisonGroupList;
begin
  if FComparisonGroupList = nil then
    FComparisonGroupList := TFhirResearchStudyComparisonGroupList.Create;
  result := FComparisonGroupList;
end;

function TFhirResearchStudy.GetHasComparisonGroupList : boolean;
begin
  result := (FComparisonGroupList <> nil) and (FComparisonGroupList.count > 0);
end;

function TFhirResearchStudy.GetObjectiveList : TFhirResearchStudyObjectiveList;
begin
  if FObjectiveList = nil then
    FObjectiveList := TFhirResearchStudyObjectiveList.Create;
  result := FObjectiveList;
end;

function TFhirResearchStudy.GetHasObjectiveList : boolean;
begin
  result := (FObjectiveList <> nil) and (FObjectiveList.count > 0);
end;

function TFhirResearchStudy.GetOutcomeMeasureList : TFhirResearchStudyOutcomeMeasureList;
begin
  if FOutcomeMeasureList = nil then
    FOutcomeMeasureList := TFhirResearchStudyOutcomeMeasureList.Create;
  result := FOutcomeMeasureList;
end;

function TFhirResearchStudy.GetHasOutcomeMeasureList : boolean;
begin
  result := (FOutcomeMeasureList <> nil) and (FOutcomeMeasureList.count > 0);
end;

function TFhirResearchStudy.GetResultList : TFhirReferenceList;
begin
  if FResultList = nil then
    FResultList := TFhirReferenceList.Create;
  result := FResultList;
end;

function TFhirResearchStudy.GetHasResultList : boolean;
begin
  result := (FResultList <> nil) and (FResultList.count > 0);
end;

function TFhirResearchStudy.GetWebLocationList : TFhirResearchStudyWebLocationList;
begin
  if FWebLocationList = nil then
    FWebLocationList := TFhirResearchStudyWebLocationList.Create;
  result := FWebLocationList;
end;

function TFhirResearchStudy.GetHasWebLocationList : boolean;
begin
  result := (FWebLocationList <> nil) and (FWebLocationList.count > 0);
end;

{ TFhirResearchStudyListEnumerator }

constructor TFhirResearchStudyListEnumerator.Create(list : TFhirResearchStudyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchStudyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchStudyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchStudyListEnumerator.GetCurrent : TFhirResearchStudy;
begin
  Result := FList[FIndex];
end;

function TFhirResearchStudyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirResearchStudyList }

function TFhirResearchStudyList.AddItem(value: TFhirResearchStudy): TFhirResearchStudy;
begin
  assert(value.ClassName = 'TFhirResearchStudy', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchStudy');
  add(value);
  result := value;
end;

function TFhirResearchStudyList.Append: TFhirResearchStudy;
begin
  result := TFhirResearchStudy.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyList.ClearItems;
begin
  Clear;
end;

function TFhirResearchStudyList.GetEnumerator : TFhirResearchStudyListEnumerator;
begin
  result := TFhirResearchStudyListEnumerator.Create(self.link);
end;

function TFhirResearchStudyList.Clone: TFhirResearchStudyList;
begin
  result := TFhirResearchStudyList(inherited Clone);
end;

function TFhirResearchStudyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchStudyList.GetItemN(index: Integer): TFhirResearchStudy;
begin
  result := TFhirResearchStudy(ObjectByIndex[index]);
end;

function TFhirResearchStudyList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchStudy;
end;
function TFhirResearchStudyList.IndexOf(value: TFhirResearchStudy): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchStudyList.Insert(index: Integer): TFhirResearchStudy;
begin
  result := TFhirResearchStudy.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyList.InsertItem(index: Integer; value: TFhirResearchStudy);
begin
  assert(value is TFhirResearchStudy);
  Inherited Insert(index, value);
end;

function TFhirResearchStudyList.Item(index: Integer): TFhirResearchStudy;
begin
  result := TFhirResearchStudy(ObjectByIndex[index]);
end;

function TFhirResearchStudyList.Link: TFhirResearchStudyList;
begin
  result := TFhirResearchStudyList(inherited Link);
end;

procedure TFhirResearchStudyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchStudyList.SetItemByIndex(index: Integer; value: TFhirResearchStudy);
begin
  assert(value is TFhirResearchStudy);
  FhirResearchStudies[index] := value;
end;

procedure TFhirResearchStudyList.SetItemN(index: Integer; value: TFhirResearchStudy);
begin
  assert(value is TFhirResearchStudy);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
{ TFhirResearchSubjectProgress }

constructor TFhirResearchSubjectProgress.Create;
begin
  inherited;
end;

destructor TFhirResearchSubjectProgress.Destroy;
begin
  FType_.free;
  FSubjectState.free;
  FMilestone.free;
  FReason.free;
  FStartDate.free;
  FEndDate.free;
  inherited;
end;

procedure TFhirResearchSubjectProgress.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirResearchSubjectProgress(oSource).type_.Clone;
  subjectState := TFhirResearchSubjectProgress(oSource).subjectState.Clone;
  milestone := TFhirResearchSubjectProgress(oSource).milestone.Clone;
  reason := TFhirResearchSubjectProgress(oSource).reason.Clone;
  startDateElement := TFhirResearchSubjectProgress(oSource).startDateElement.Clone;
  endDateElement := TFhirResearchSubjectProgress(oSource).endDateElement.Clone;
end;

procedure TFhirResearchSubjectProgress.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subjectState') Then
     list.add(self.link, 'subjectState', FSubjectState.Link);
  if (child_name = 'milestone') Then
     list.add(self.link, 'milestone', FMilestone.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
  if (child_name = 'startDate') Then
     list.add(self.link, 'startDate', FStartDate.Link);
  if (child_name = 'endDate') Then
     list.add(self.link, 'endDate', FEndDate.Link);
end;

procedure TFhirResearchSubjectProgress.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'subjectState', 'CodeableConcept', false, TFhirCodeableConcept, FSubjectState.Link));
  oList.add(TFHIRProperty.create(self, 'milestone', 'CodeableConcept', false, TFhirCodeableConcept, FMilestone.Link));
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link));
  oList.add(TFHIRProperty.create(self, 'startDate', 'dateTime', false, TFhirDateTime, FStartDate.Link));
  oList.add(TFHIRProperty.create(self, 'endDate', 'dateTime', false, TFhirDateTime, FEndDate.Link));
end;

function TFhirResearchSubjectProgress.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subjectState') then
  begin
    SubjectState := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'milestone') then
  begin
    Milestone := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'startDate') then
  begin
    StartDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'endDate') then
  begin
    EndDateElement := asDateTime(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirResearchSubjectProgress.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirResearchSubjectProgress.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'subjectState') then result := TFhirCodeableConcept.create()
  else if (propName = 'milestone') then result := TFhirCodeableConcept.create()
  else if (propName = 'reason') then result := TFhirCodeableConcept.create()
  else if (propName = 'startDate') then result := TFhirDateTime.create()
  else if (propName = 'endDate') then result := TFhirDateTime.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchSubjectProgress.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subjectState') then result := 'CodeableConcept'
  else if (propName = 'milestone') then result := 'CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'startDate') then result := 'dateTime'
  else if (propName = 'endDate') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchSubjectProgress.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'subjectState') then SubjectStateElement := nil
  else if (propName = 'milestone') then MilestoneElement := nil
  else if (propName = 'reason') then ReasonElement := nil
  else if (propName = 'startDate') then StartDateElement := nil
  else if (propName = 'endDate') then EndDateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchSubjectProgress.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'subjectState') then SubjectStateElement := new as TFhirCodeableConcept
  else if (propName = 'milestone') then MilestoneElement := new as TFhirCodeableConcept
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept
  else if (propName = 'startDate') then StartDateElement := asDateTime(new)
  else if (propName = 'endDate') then EndDateElement := asDateTime(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchSubjectProgress.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchSubjectProgress.fhirType : string;
begin
  result := 'ResearchSubject.progress';
end;

function TFhirResearchSubjectProgress.Link : TFhirResearchSubjectProgress;
begin
  result := TFhirResearchSubjectProgress(inherited Link);
end;

function TFhirResearchSubjectProgress.Clone : TFhirResearchSubjectProgress;
begin
  result := TFhirResearchSubjectProgress(inherited Clone);
end;

function TFhirResearchSubjectProgress.equals(other : TObject) : boolean; 
var
  o : TFhirResearchSubjectProgress;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchSubjectProgress)) then
    result := false
  else
  begin
    o := TFhirResearchSubjectProgress(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(subjectStateElement, o.subjectStateElement, true) and 
      compareDeep(milestoneElement, o.milestoneElement, true) and compareDeep(reasonElement, o.reasonElement, true) and 
      compareDeep(startDateElement, o.startDateElement, true) and compareDeep(endDateElement, o.endDateElement, true);
  end;
end;

function TFhirResearchSubjectProgress.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FSubjectState) and isEmptyProp(FMilestone) and isEmptyProp(FReason) and isEmptyProp(FStartDate) and isEmptyProp(FEndDate);
end;

procedure TFhirResearchSubjectProgress.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('subjectState');
  fields.add('milestone');
  fields.add('reason');
  fields.add('startDate');
  fields.add('endDate');
end;

function TFhirResearchSubjectProgress.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirResearchSubjectProgress.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirResearchSubjectProgress.SetSubjectState(value : TFhirCodeableConcept);
begin
  FSubjectState.free;
  FSubjectState := value;
end;

procedure TFhirResearchSubjectProgress.SetMilestone(value : TFhirCodeableConcept);
begin
  FMilestone.free;
  FMilestone := value;
end;

procedure TFhirResearchSubjectProgress.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value;
end;

procedure TFhirResearchSubjectProgress.SetStartDate(value : TFhirDateTime);
begin
  FStartDate.free;
  FStartDate := value;
end;

function TFhirResearchSubjectProgress.GetStartDateST : TFslDateTime;
begin
  if FStartDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FStartDate.value;
end;

procedure TFhirResearchSubjectProgress.SetStartDateST(value : TFslDateTime);
begin
  if FStartDate = nil then
    FStartDate := TFhirDateTime.create;
  FStartDate.value := value
end;

procedure TFhirResearchSubjectProgress.SetEndDate(value : TFhirDateTime);
begin
  FEndDate.free;
  FEndDate := value;
end;

function TFhirResearchSubjectProgress.GetEndDateST : TFslDateTime;
begin
  if FEndDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FEndDate.value;
end;

procedure TFhirResearchSubjectProgress.SetEndDateST(value : TFslDateTime);
begin
  if FEndDate = nil then
    FEndDate := TFhirDateTime.create;
  FEndDate.value := value
end;

{ TFhirResearchSubjectProgressListEnumerator }

constructor TFhirResearchSubjectProgressListEnumerator.Create(list : TFhirResearchSubjectProgressList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchSubjectProgressListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchSubjectProgressListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchSubjectProgressListEnumerator.GetCurrent : TFhirResearchSubjectProgress;
begin
  Result := FList[FIndex];
end;

function TFhirResearchSubjectProgressListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirResearchSubjectProgressList }

function TFhirResearchSubjectProgressList.AddItem(value: TFhirResearchSubjectProgress): TFhirResearchSubjectProgress;
begin
  assert(value.ClassName = 'TFhirResearchSubjectProgress', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchSubjectProgress');
  add(value);
  result := value;
end;

function TFhirResearchSubjectProgressList.Append: TFhirResearchSubjectProgress;
begin
  result := TFhirResearchSubjectProgress.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchSubjectProgressList.ClearItems;
begin
  Clear;
end;

function TFhirResearchSubjectProgressList.GetEnumerator : TFhirResearchSubjectProgressListEnumerator;
begin
  result := TFhirResearchSubjectProgressListEnumerator.Create(self.link);
end;

function TFhirResearchSubjectProgressList.Clone: TFhirResearchSubjectProgressList;
begin
  result := TFhirResearchSubjectProgressList(inherited Clone);
end;

function TFhirResearchSubjectProgressList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchSubjectProgressList.GetItemN(index: Integer): TFhirResearchSubjectProgress;
begin
  result := TFhirResearchSubjectProgress(ObjectByIndex[index]);
end;

function TFhirResearchSubjectProgressList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchSubjectProgress;
end;
function TFhirResearchSubjectProgressList.IndexOf(value: TFhirResearchSubjectProgress): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchSubjectProgressList.Insert(index: Integer): TFhirResearchSubjectProgress;
begin
  result := TFhirResearchSubjectProgress.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchSubjectProgressList.InsertItem(index: Integer; value: TFhirResearchSubjectProgress);
begin
  assert(value is TFhirResearchSubjectProgress);
  Inherited Insert(index, value);
end;

function TFhirResearchSubjectProgressList.Item(index: Integer): TFhirResearchSubjectProgress;
begin
  result := TFhirResearchSubjectProgress(ObjectByIndex[index]);
end;

function TFhirResearchSubjectProgressList.Link: TFhirResearchSubjectProgressList;
begin
  result := TFhirResearchSubjectProgressList(inherited Link);
end;

procedure TFhirResearchSubjectProgressList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchSubjectProgressList.SetItemByIndex(index: Integer; value: TFhirResearchSubjectProgress);
begin
  assert(value is TFhirResearchSubjectProgress);
  FhirResearchSubjectProgresses[index] := value;
end;

procedure TFhirResearchSubjectProgressList.SetItemN(index: Integer; value: TFhirResearchSubjectProgress);
begin
  assert(value is TFhirResearchSubjectProgress);
  ObjectByIndex[index] := value;
end;

{ TFhirResearchSubject }

constructor TFhirResearchSubject.Create;
begin
  inherited;
end;

destructor TFhirResearchSubject.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FProgressList.Free;
  FPeriod.free;
  FStudy.free;
  FSubject.free;
  FAssignedArm.free;
  FActualArm.free;
  FConsent.free;
  inherited;
end;

procedure TFhirResearchSubject.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirResearchSubject(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirResearchSubject(oSource).FIdentifierList);
  end;
  statusElement := TFhirResearchSubject(oSource).statusElement.Clone;
  if (TFhirResearchSubject(oSource).FProgressList = nil) then
  begin
    FProgressList.free;
    FProgressList := nil;
  end
  else
  begin
    if FProgressList = nil then
      FProgressList := TFhirResearchSubjectProgressList.Create;
    FProgressList.Assign(TFhirResearchSubject(oSource).FProgressList);
  end;
  period := TFhirResearchSubject(oSource).period.Clone;
  study := TFhirResearchSubject(oSource).study.Clone;
  subject := TFhirResearchSubject(oSource).subject.Clone;
  assignedArmElement := TFhirResearchSubject(oSource).assignedArmElement.Clone;
  actualArmElement := TFhirResearchSubject(oSource).actualArmElement.Clone;
  consent := TFhirResearchSubject(oSource).consent.Clone;
end;

function TFhirResearchSubject.GetResourceType : TFhirResourceType;
begin
  result := frtResearchSubject;
end;

procedure TFhirResearchSubject.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'progress') Then
    list.addAll(self, 'progress', FProgressList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'study') Then
     list.add(self.link, 'study', FStudy.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'assignedArm') Then
     list.add(self.link, 'assignedArm', FAssignedArm.Link);
  if (child_name = 'actualArm') Then
     list.add(self.link, 'actualArm', FActualArm.Link);
  if (child_name = 'consent') Then
     list.add(self.link, 'consent', FConsent.Link);
end;

procedure TFhirResearchSubject.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'progress', 'BackboneElement', true, TFhirResearchSubjectProgress, FProgressList.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'study', 'Reference', false, TFhirReference, FStudy.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'assignedArm', 'string', false, TFhirString, FAssignedArm.Link));
  oList.add(TFHIRProperty.create(self, 'actualArm', 'string', false, TFhirString, FActualArm.Link));
  oList.add(TFHIRProperty.create(self, 'consent', 'Reference', false, TFhirReference, FConsent.Link));
end;

function TFhirResearchSubject.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'progress') then
  begin
    ProgressList.add(propValue as TFhirResearchSubjectProgress);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'study') then
  begin
    Study := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'assignedArm') then
  begin
    AssignedArmElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'actualArm') then
  begin
    ActualArmElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'consent') then
  begin
    Consent := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirResearchSubject.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'progress') then ProgressList.insertItem(index, propValue as TFhirResearchSubjectProgress)
  else inherited;
end;

function TFhirResearchSubject.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'progress') then result := ProgressList.new()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'study') then result := TFhirReference.create()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'assignedArm') then result := TFhirString.create()
  else if (propName = 'actualArm') then result := TFhirString.create()
  else if (propName = 'consent') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchSubject.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'progress') then result := 'BackboneElement'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'study') then result := 'Reference'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'assignedArm') then result := 'string'
  else if (propName = 'actualArm') then result := 'string'
  else if (propName = 'consent') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchSubject.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'progress') then deletePropertyValue('progress', ProgressList, value)
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'study') then StudyElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'assignedArm') then AssignedArmElement := nil
  else if (propName = 'actualArm') then ActualArmElement := nil
  else if (propName = 'consent') then ConsentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchSubject.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'progress') then replacePropertyValue('progress', ProgressList, existing, new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'study') then StudyElement := new as TFhirReference
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'assignedArm') then AssignedArmElement := asString(new)
  else if (propName = 'actualArm') then ActualArmElement := asString(new)
  else if (propName = 'consent') then ConsentElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchSubject.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'progress') then ProgressList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchSubject.fhirType : string;
begin
  result := 'ResearchSubject';
end;

function TFhirResearchSubject.Link : TFhirResearchSubject;
begin
  result := TFhirResearchSubject(inherited Link);
end;

function TFhirResearchSubject.Clone : TFhirResearchSubject;
begin
  result := TFhirResearchSubject(inherited Clone);
end;

function TFhirResearchSubject.equals(other : TObject) : boolean; 
var
  o : TFhirResearchSubject;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchSubject)) then
    result := false
  else
  begin
    o := TFhirResearchSubject(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(progressList, o.progressList, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(studyElement, o.studyElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(assignedArmElement, o.assignedArmElement, true) and compareDeep(actualArmElement, o.actualArmElement, true) and 
      compareDeep(consentElement, o.consentElement, true);
  end;
end;

function TFhirResearchSubject.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FprogressList) and isEmptyProp(FPeriod) and isEmptyProp(FStudy) and isEmptyProp(FSubject) and isEmptyProp(FAssignedArm) and isEmptyProp(FActualArm) and isEmptyProp(FConsent);
end;

procedure TFhirResearchSubject.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('progress');
  fields.add('period');
  fields.add('study');
  fields.add('subject');
  fields.add('assignedArm');
  fields.add('actualArm');
  fields.add('consent');
end;

function TFhirResearchSubject.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FProgressList.sizeInBytes(magic));
end;

function TFhirResearchSubject.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirResearchSubject.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirResearchSubject.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirResearchSubject.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirResearchSubject.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

function TFhirResearchSubject.GetProgressList : TFhirResearchSubjectProgressList;
begin
  if FProgressList = nil then
    FProgressList := TFhirResearchSubjectProgressList.Create;
  result := FProgressList;
end;

function TFhirResearchSubject.GetHasProgressList : boolean;
begin
  result := (FProgressList <> nil) and (FProgressList.count > 0);
end;

procedure TFhirResearchSubject.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

procedure TFhirResearchSubject.SetStudy(value : TFhirReference);
begin
  FStudy.free;
  FStudy := value;
end;

procedure TFhirResearchSubject.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirResearchSubject.SetAssignedArm(value : TFhirString);
begin
  FAssignedArm.free;
  FAssignedArm := value;
end;

function TFhirResearchSubject.GetAssignedArmST : String;
begin
  if FAssignedArm = nil then
    result := ''
  else
    result := FAssignedArm.value;
end;

procedure TFhirResearchSubject.SetAssignedArmST(value : String);
begin
  if value <> '' then
  begin
    if FAssignedArm = nil then
      FAssignedArm := TFhirString.create;
    FAssignedArm.value := value
  end
  else if FAssignedArm <> nil then
    FAssignedArm.value := '';
end;

procedure TFhirResearchSubject.SetActualArm(value : TFhirString);
begin
  FActualArm.free;
  FActualArm := value;
end;

function TFhirResearchSubject.GetActualArmST : String;
begin
  if FActualArm = nil then
    result := ''
  else
    result := FActualArm.value;
end;

procedure TFhirResearchSubject.SetActualArmST(value : String);
begin
  if value <> '' then
  begin
    if FActualArm = nil then
      FActualArm := TFhirString.create;
    FActualArm.value := value
  end
  else if FActualArm <> nil then
    FActualArm.value := '';
end;

procedure TFhirResearchSubject.SetConsent(value : TFhirReference);
begin
  FConsent.free;
  FConsent := value;
end;

{ TFhirResearchSubjectListEnumerator }

constructor TFhirResearchSubjectListEnumerator.Create(list : TFhirResearchSubjectList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchSubjectListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchSubjectListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchSubjectListEnumerator.GetCurrent : TFhirResearchSubject;
begin
  Result := FList[FIndex];
end;

function TFhirResearchSubjectListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirResearchSubjectList }

function TFhirResearchSubjectList.AddItem(value: TFhirResearchSubject): TFhirResearchSubject;
begin
  assert(value.ClassName = 'TFhirResearchSubject', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchSubject');
  add(value);
  result := value;
end;

function TFhirResearchSubjectList.Append: TFhirResearchSubject;
begin
  result := TFhirResearchSubject.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchSubjectList.ClearItems;
begin
  Clear;
end;

function TFhirResearchSubjectList.GetEnumerator : TFhirResearchSubjectListEnumerator;
begin
  result := TFhirResearchSubjectListEnumerator.Create(self.link);
end;

function TFhirResearchSubjectList.Clone: TFhirResearchSubjectList;
begin
  result := TFhirResearchSubjectList(inherited Clone);
end;

function TFhirResearchSubjectList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchSubjectList.GetItemN(index: Integer): TFhirResearchSubject;
begin
  result := TFhirResearchSubject(ObjectByIndex[index]);
end;

function TFhirResearchSubjectList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchSubject;
end;
function TFhirResearchSubjectList.IndexOf(value: TFhirResearchSubject): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchSubjectList.Insert(index: Integer): TFhirResearchSubject;
begin
  result := TFhirResearchSubject.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchSubjectList.InsertItem(index: Integer; value: TFhirResearchSubject);
begin
  assert(value is TFhirResearchSubject);
  Inherited Insert(index, value);
end;

function TFhirResearchSubjectList.Item(index: Integer): TFhirResearchSubject;
begin
  result := TFhirResearchSubject(ObjectByIndex[index]);
end;

function TFhirResearchSubjectList.Link: TFhirResearchSubjectList;
begin
  result := TFhirResearchSubjectList(inherited Link);
end;

procedure TFhirResearchSubjectList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchSubjectList.SetItemByIndex(index: Integer; value: TFhirResearchSubject);
begin
  assert(value is TFhirResearchSubject);
  FhirResearchSubjects[index] := value;
end;

procedure TFhirResearchSubjectList.SetItemN(index: Integer; value: TFhirResearchSubject);
begin
  assert(value is TFhirResearchSubject);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_SUBSCRIPTION}
{ TFhirSubscriptionFilterBy }

constructor TFhirSubscriptionFilterBy.Create;
begin
  inherited;
end;

destructor TFhirSubscriptionFilterBy.Destroy;
begin
  FResourceType.free;
  FFilterParameter.free;
  FModifier.free;
  FValue.free;
  inherited;
end;

procedure TFhirSubscriptionFilterBy.Assign(oSource : TFslObject);
begin
  inherited;
  resourceTypeElement := TFhirSubscriptionFilterBy(oSource).resourceTypeElement.Clone;
  filterParameterElement := TFhirSubscriptionFilterBy(oSource).filterParameterElement.Clone;
  modifierElement := TFhirSubscriptionFilterBy(oSource).modifierElement.Clone;
  valueElement := TFhirSubscriptionFilterBy(oSource).valueElement.Clone;
end;

procedure TFhirSubscriptionFilterBy.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'resourceType') Then
     list.add(self.link, 'resourceType', FResourceType.Link);
  if (child_name = 'filterParameter') Then
     list.add(self.link, 'filterParameter', FFilterParameter.Link);
  if (child_name = 'modifier') Then
     list.add(self.link, 'modifier', FModifier.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirSubscriptionFilterBy.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'resourceType', 'uri', false, TFhirUri, FResourceType.Link));
  oList.add(TFHIRProperty.create(self, 'filterParameter', 'string', false, TFhirString, FFilterParameter.Link));
  oList.add(TFHIRProperty.create(self, 'modifier', 'code', false, TFhirEnum, FModifier.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));
end;

function TFhirSubscriptionFilterBy.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'resourceType') then
  begin
    ResourceTypeElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'filterParameter') then
  begin
    FilterParameterElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierElement := asEnum(SYSTEMS_TFhirSubscriptionSearchModifierEnum, CODES_TFhirSubscriptionSearchModifierEnum, propValue);
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubscriptionFilterBy.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubscriptionFilterBy.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'resourceType') then result := TFhirUri.create()
  else if (propName = 'filterParameter') then result := TFhirString.create()
  else if (propName = 'modifier') then result := TFhirEnum.create(SYSTEMS_TFhirSubscriptionSearchModifierEnum[SubscriptionSearchModifierNull], CODES_TFhirSubscriptionSearchModifierEnum[SubscriptionSearchModifierNull]) 
  else if (propName = 'value') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscriptionFilterBy.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'resourceType') then result := 'uri'
  else if (propName = 'filterParameter') then result := 'string'
  else if (propName = 'modifier') then result := 'code'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscriptionFilterBy.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'resourceType') then ResourceTypeElement := nil
  else if (propName = 'filterParameter') then FilterParameterElement := nil
  else if (propName = 'modifier') then ModifierElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscriptionFilterBy.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'resourceType') then ResourceTypeElement := asUri(new)
  else if (propName = 'filterParameter') then FilterParameterElement := asString(new)
  else if (propName = 'modifier') then ModifierElement := asEnum(SYSTEMS_TFhirSubscriptionSearchModifierEnum, CODES_TFhirSubscriptionSearchModifierEnum, new)
  else if (propName = 'value') then ValueElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscriptionFilterBy.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscriptionFilterBy.fhirType : string;
begin
  result := 'Subscription.filterBy';
end;

function TFhirSubscriptionFilterBy.Link : TFhirSubscriptionFilterBy;
begin
  result := TFhirSubscriptionFilterBy(inherited Link);
end;

function TFhirSubscriptionFilterBy.Clone : TFhirSubscriptionFilterBy;
begin
  result := TFhirSubscriptionFilterBy(inherited Clone);
end;

function TFhirSubscriptionFilterBy.equals(other : TObject) : boolean; 
var
  o : TFhirSubscriptionFilterBy;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscriptionFilterBy)) then
    result := false
  else
  begin
    o := TFhirSubscriptionFilterBy(other);
    result := compareDeep(resourceTypeElement, o.resourceTypeElement, true) and 
      compareDeep(filterParameterElement, o.filterParameterElement, true) and compareDeep(modifierElement, o.modifierElement, true) and 
      compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirSubscriptionFilterBy.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FResourceType) and isEmptyProp(FFilterParameter) and isEmptyProp(FModifier) and isEmptyProp(FValue);
end;

procedure TFhirSubscriptionFilterBy.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('resourceType');
  fields.add('filterParameter');
  fields.add('modifier');
  fields.add('value');
end;

function TFhirSubscriptionFilterBy.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubscriptionFilterBy.SetResourceType(value : TFhirUri);
begin
  FResourceType.free;
  FResourceType := value;
end;

function TFhirSubscriptionFilterBy.GetResourceTypeST : String;
begin
  if FResourceType = nil then
    result := ''
  else
    result := FResourceType.value;
end;

procedure TFhirSubscriptionFilterBy.SetResourceTypeST(value : String);
begin
  if value <> '' then
  begin
    if FResourceType = nil then
      FResourceType := TFhirUri.create;
    FResourceType.value := value
  end
  else if FResourceType <> nil then
    FResourceType.value := '';
end;

procedure TFhirSubscriptionFilterBy.SetFilterParameter(value : TFhirString);
begin
  FFilterParameter.free;
  FFilterParameter := value;
end;

function TFhirSubscriptionFilterBy.GetFilterParameterST : String;
begin
  if FFilterParameter = nil then
    result := ''
  else
    result := FFilterParameter.value;
end;

procedure TFhirSubscriptionFilterBy.SetFilterParameterST(value : String);
begin
  if value <> '' then
  begin
    if FFilterParameter = nil then
      FFilterParameter := TFhirString.create;
    FFilterParameter.value := value
  end
  else if FFilterParameter <> nil then
    FFilterParameter.value := '';
end;

procedure TFhirSubscriptionFilterBy.SetModifier(value : TFhirEnum);
begin
  FModifier.free;
  FModifier := value;
end;

function TFhirSubscriptionFilterBy.GetModifierST : TFhirSubscriptionSearchModifierEnum;
begin
  if FModifier = nil then
    result := TFhirSubscriptionSearchModifierEnum(0)
  else
    result := TFhirSubscriptionSearchModifierEnum(StringArrayIndexOfSensitive(CODES_TFhirSubscriptionSearchModifierEnum, FModifier.value));
end;

procedure TFhirSubscriptionFilterBy.SetModifierST(value : TFhirSubscriptionSearchModifierEnum);
begin
  if ord(value) = 0 then
    ModifierElement := nil
  else
    ModifierElement := TFhirEnum.create(SYSTEMS_TFhirSubscriptionSearchModifierEnum[value], CODES_TFhirSubscriptionSearchModifierEnum[value]);
end;

procedure TFhirSubscriptionFilterBy.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

function TFhirSubscriptionFilterBy.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirSubscriptionFilterBy.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

{ TFhirSubscriptionFilterByListEnumerator }

constructor TFhirSubscriptionFilterByListEnumerator.Create(list : TFhirSubscriptionFilterByList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionFilterByListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionFilterByListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionFilterByListEnumerator.GetCurrent : TFhirSubscriptionFilterBy;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionFilterByListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubscriptionFilterByList }

function TFhirSubscriptionFilterByList.AddItem(value: TFhirSubscriptionFilterBy): TFhirSubscriptionFilterBy;
begin
  assert(value.ClassName = 'TFhirSubscriptionFilterBy', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscriptionFilterBy');
  add(value);
  result := value;
end;

function TFhirSubscriptionFilterByList.Append: TFhirSubscriptionFilterBy;
begin
  result := TFhirSubscriptionFilterBy.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionFilterByList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionFilterByList.GetEnumerator : TFhirSubscriptionFilterByListEnumerator;
begin
  result := TFhirSubscriptionFilterByListEnumerator.Create(self.link);
end;

function TFhirSubscriptionFilterByList.Clone: TFhirSubscriptionFilterByList;
begin
  result := TFhirSubscriptionFilterByList(inherited Clone);
end;

function TFhirSubscriptionFilterByList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionFilterByList.GetItemN(index: Integer): TFhirSubscriptionFilterBy;
begin
  result := TFhirSubscriptionFilterBy(ObjectByIndex[index]);
end;

function TFhirSubscriptionFilterByList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscriptionFilterBy;
end;
function TFhirSubscriptionFilterByList.IndexOf(value: TFhirSubscriptionFilterBy): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionFilterByList.Insert(index: Integer): TFhirSubscriptionFilterBy;
begin
  result := TFhirSubscriptionFilterBy.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionFilterByList.InsertItem(index: Integer; value: TFhirSubscriptionFilterBy);
begin
  assert(value is TFhirSubscriptionFilterBy);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionFilterByList.Item(index: Integer): TFhirSubscriptionFilterBy;
begin
  result := TFhirSubscriptionFilterBy(ObjectByIndex[index]);
end;

function TFhirSubscriptionFilterByList.Link: TFhirSubscriptionFilterByList;
begin
  result := TFhirSubscriptionFilterByList(inherited Link);
end;

procedure TFhirSubscriptionFilterByList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionFilterByList.SetItemByIndex(index: Integer; value: TFhirSubscriptionFilterBy);
begin
  assert(value is TFhirSubscriptionFilterBy);
  FhirSubscriptionFilterBies[index] := value;
end;

procedure TFhirSubscriptionFilterByList.SetItemN(index: Integer; value: TFhirSubscriptionFilterBy);
begin
  assert(value is TFhirSubscriptionFilterBy);
  ObjectByIndex[index] := value;
end;

{ TFhirSubscription }

constructor TFhirSubscription.Create;
begin
  inherited;
end;

destructor TFhirSubscription.Destroy;
begin
  FIdentifierList.Free;
  FName.free;
  FStatus.free;
  FTopic.free;
  FContactList.Free;
  FEnd_.free;
  FManagingEntity.free;
  FReason.free;
  FFilterByList.Free;
  FChannelType.free;
  FEndpoint.free;
  FHeaderList.Free;
  FHeartbeatPeriod.free;
  FTimeout.free;
  FContentType.free;
  FContent.free;
  FMaxCount.free;
  inherited;
end;

procedure TFhirSubscription.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSubscription(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSubscription(oSource).FIdentifierList);
  end;
  nameElement := TFhirSubscription(oSource).nameElement.Clone;
  statusElement := TFhirSubscription(oSource).statusElement.Clone;
  topicElement := TFhirSubscription(oSource).topicElement.Clone;
  if (TFhirSubscription(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactPointList.Create;
    FContactList.Assign(TFhirSubscription(oSource).FContactList);
  end;
  end_Element := TFhirSubscription(oSource).end_Element.Clone;
  managingEntity := TFhirSubscription(oSource).managingEntity.Clone;
  reasonElement := TFhirSubscription(oSource).reasonElement.Clone;
  if (TFhirSubscription(oSource).FFilterByList = nil) then
  begin
    FFilterByList.free;
    FFilterByList := nil;
  end
  else
  begin
    if FFilterByList = nil then
      FFilterByList := TFhirSubscriptionFilterByList.Create;
    FFilterByList.Assign(TFhirSubscription(oSource).FFilterByList);
  end;
  channelType := TFhirSubscription(oSource).channelType.Clone;
  endpointElement := TFhirSubscription(oSource).endpointElement.Clone;
  if (TFhirSubscription(oSource).FHeaderList = nil) then
  begin
    FHeaderList.free;
    FHeaderList := nil;
  end
  else
  begin
    if FHeaderList = nil then
      FHeaderList := TFhirStringList.Create;
    FHeaderList.Assign(TFhirSubscription(oSource).FHeaderList);
  end;
  heartbeatPeriodElement := TFhirSubscription(oSource).heartbeatPeriodElement.Clone;
  timeoutElement := TFhirSubscription(oSource).timeoutElement.Clone;
  contentTypeElement := TFhirSubscription(oSource).contentTypeElement.Clone;
  contentElement := TFhirSubscription(oSource).contentElement.Clone;
  maxCountElement := TFhirSubscription(oSource).maxCountElement.Clone;
end;

function TFhirSubscription.GetResourceType : TFhirResourceType;
begin
  result := frtSubscription;
end;

procedure TFhirSubscription.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'topic') Then
     list.add(self.link, 'topic', FTopic.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
  if (child_name = 'managingEntity') Then
     list.add(self.link, 'managingEntity', FManagingEntity.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
  if (child_name = 'filterBy') Then
    list.addAll(self, 'filterBy', FFilterByList);
  if (child_name = 'channelType') Then
     list.add(self.link, 'channelType', FChannelType.Link);
  if (child_name = 'endpoint') Then
     list.add(self.link, 'endpoint', FEndpoint.Link);
  if (child_name = 'header') Then
    list.addAll(self, 'header', FHeaderList);
  if (child_name = 'heartbeatPeriod') Then
     list.add(self.link, 'heartbeatPeriod', FHeartbeatPeriod.Link);
  if (child_name = 'timeout') Then
     list.add(self.link, 'timeout', FTimeout.Link);
  if (child_name = 'contentType') Then
     list.add(self.link, 'contentType', FContentType.Link);
  if (child_name = 'content') Then
     list.add(self.link, 'content', FContent.Link);
  if (child_name = 'maxCount') Then
     list.add(self.link, 'maxCount', FMaxCount.Link);
end;

procedure TFhirSubscription.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'topic', 'canonical', false, TFhirCanonical, FTopic.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactPoint', true, TFhirContactPoint, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'end', 'instant', false, TFhirInstant, FEnd_.Link));
  oList.add(TFHIRProperty.create(self, 'managingEntity', 'Reference', false, TFhirReference, FManagingEntity.Link));
  oList.add(TFHIRProperty.create(self, 'reason', 'string', false, TFhirString, FReason.Link));
  oList.add(TFHIRProperty.create(self, 'filterBy', 'BackboneElement', true, TFhirSubscriptionFilterBy, FFilterByList.Link));
  oList.add(TFHIRProperty.create(self, 'channelType', 'Coding', false, TFhirCoding, FChannelType.Link));
  oList.add(TFHIRProperty.create(self, 'endpoint', 'url', false, TFhirUrl, FEndpoint.Link));
  oList.add(TFHIRProperty.create(self, 'header', 'string', true, TFhirString, FHeaderList.Link));
  oList.add(TFHIRProperty.create(self, 'heartbeatPeriod', 'unsignedInt', false, TFhirUnsignedInt, FHeartbeatPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'timeout', 'unsignedInt', false, TFhirUnsignedInt, FTimeout.Link));
  oList.add(TFHIRProperty.create(self, 'contentType', 'code', false, TFhirCode, FContentType.Link));
  oList.add(TFHIRProperty.create(self, 'content', 'code', false, TFhirEnum, FContent.Link));
  oList.add(TFHIRProperty.create(self, 'maxCount', 'positiveInt', false, TFhirPositiveInt, FMaxCount.Link));
end;

function TFhirSubscription.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirSubscriptionStatusCodesEnum, CODES_TFhirSubscriptionStatusCodesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    TopicElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'managingEntity') then
  begin
    ManagingEntity := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'filterBy') then
  begin
    FilterByList.add(propValue as TFhirSubscriptionFilterBy);
    result := propValue;
  end
  else if (propName = 'channelType') then
  begin
    ChannelType := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointElement := asUrl(propValue);
    result := propValue;
  end
  else if (propName = 'header') then
  begin
    HeaderList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'heartbeatPeriod') then
  begin
    HeartbeatPeriodElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'timeout') then
  begin
    TimeoutElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'contentType') then
  begin
    ContentTypeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'content') then
  begin
    ContentElement := asEnum(SYSTEMS_TFhirSubscriptionPayloadContentEnum, CODES_TFhirSubscriptionPayloadContentEnum, propValue);
    result := propValue;
  end
  else if (propName = 'maxCount') then
  begin
    MaxCountElement := asPositiveInt(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubscription.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactPoint)
  else if (propName = 'filterBy') then FilterByList.insertItem(index, propValue as TFhirSubscriptionFilterBy)
  else if (propName = 'header') then HeaderList.insertItem(index, asString(propValue))
  else inherited;
end;

function TFhirSubscription.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirSubscriptionStatusCodesEnum[SubscriptionStatusCodesNull], CODES_TFhirSubscriptionStatusCodesEnum[SubscriptionStatusCodesNull]) 
  else if (propName = 'topic') then result := TFhirCanonical.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'end') then result := TFhirInstant.create()
  else if (propName = 'managingEntity') then result := TFhirReference.create()
  else if (propName = 'reason') then result := TFhirString.create()
  else if (propName = 'filterBy') then result := FilterByList.new()
  else if (propName = 'channelType') then result := TFhirCoding.create()
  else if (propName = 'endpoint') then result := TFhirUrl.create()
  else if (propName = 'header') then result := HeaderList.new()
  else if (propName = 'heartbeatPeriod') then result := TFhirUnsignedInt.create()
  else if (propName = 'timeout') then result := TFhirUnsignedInt.create()
  else if (propName = 'contentType') then result := TFhirCode.create()
  else if (propName = 'content') then result := TFhirEnum.create(SYSTEMS_TFhirSubscriptionPayloadContentEnum[SubscriptionPayloadContentNull], CODES_TFhirSubscriptionPayloadContentEnum[SubscriptionPayloadContentNull]) 
  else if (propName = 'maxCount') then result := TFhirPositiveInt.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscription.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'topic') then result := 'canonical'
  else if (propName = 'contact') then result := 'ContactPoint'
  else if (propName = 'end') then result := 'instant'
  else if (propName = 'managingEntity') then result := 'Reference'
  else if (propName = 'reason') then result := 'string'
  else if (propName = 'filterBy') then result := 'BackboneElement'
  else if (propName = 'channelType') then result := 'Coding'
  else if (propName = 'endpoint') then result := 'url'
  else if (propName = 'header') then result := 'string'
  else if (propName = 'heartbeatPeriod') then result := 'unsignedInt'
  else if (propName = 'timeout') then result := 'unsignedInt'
  else if (propName = 'contentType') then result := 'code'
  else if (propName = 'content') then result := 'code'
  else if (propName = 'maxCount') then result := 'positiveInt'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscription.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'topic') then TopicElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'end') then End_Element := nil
  else if (propName = 'managingEntity') then ManagingEntityElement := nil
  else if (propName = 'reason') then ReasonElement := nil
  else if (propName = 'filterBy') then deletePropertyValue('filterBy', FilterByList, value)
  else if (propName = 'channelType') then ChannelTypeElement := nil
  else if (propName = 'endpoint') then EndpointElement := nil
  else if (propName = 'header') then deletePropertyValue('header', HeaderList, value)
  else if (propName = 'heartbeatPeriod') then HeartbeatPeriodElement := nil
  else if (propName = 'timeout') then TimeoutElement := nil
  else if (propName = 'contentType') then ContentTypeElement := nil
  else if (propName = 'content') then ContentElement := nil
  else if (propName = 'maxCount') then MaxCountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscription.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirSubscriptionStatusCodesEnum, CODES_TFhirSubscriptionStatusCodesEnum, new)
  else if (propName = 'topic') then TopicElement := asCanonical(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'end') then End_Element := asInstant(new)
  else if (propName = 'managingEntity') then ManagingEntityElement := new as TFhirReference
  else if (propName = 'reason') then ReasonElement := asString(new)
  else if (propName = 'filterBy') then replacePropertyValue('filterBy', FilterByList, existing, new)
  else if (propName = 'channelType') then ChannelTypeElement := new as TFhirCoding
  else if (propName = 'endpoint') then EndpointElement := asUrl(new)
  else if (propName = 'header') then replacePropertyValue('header', HeaderList, existing, new)
  else if (propName = 'heartbeatPeriod') then HeartbeatPeriodElement := asUnsignedInt(new)
  else if (propName = 'timeout') then TimeoutElement := asUnsignedInt(new)
  else if (propName = 'contentType') then ContentTypeElement := asCode(new)
  else if (propName = 'content') then ContentElement := asEnum(SYSTEMS_TFhirSubscriptionPayloadContentEnum, CODES_TFhirSubscriptionPayloadContentEnum, new)
  else if (propName = 'maxCount') then MaxCountElement := asPositiveInt(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscription.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'filterBy') then FilterByList.move(source, destination)
  else if (propName = 'header') then HeaderList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscription.fhirType : string;
begin
  result := 'Subscription';
end;

function TFhirSubscription.Link : TFhirSubscription;
begin
  result := TFhirSubscription(inherited Link);
end;

function TFhirSubscription.Clone : TFhirSubscription;
begin
  result := TFhirSubscription(inherited Clone);
end;

function TFhirSubscription.equals(other : TObject) : boolean; 
var
  o : TFhirSubscription;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscription)) then
    result := false
  else
  begin
    o := TFhirSubscription(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(topicElement, o.topicElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(end_Element, o.end_Element, true) and 
      compareDeep(managingEntityElement, o.managingEntityElement, true) and compareDeep(reasonElement, o.reasonElement, true) and 
      compareDeep(filterByList, o.filterByList, true) and compareDeep(channelTypeElement, o.channelTypeElement, true) and 
      compareDeep(endpointElement, o.endpointElement, true) and compareDeep(headerList, o.headerList, true) and 
      compareDeep(heartbeatPeriodElement, o.heartbeatPeriodElement, true) and compareDeep(timeoutElement, o.timeoutElement, true) and 
      compareDeep(contentTypeElement, o.contentTypeElement, true) and compareDeep(contentElement, o.contentElement, true) and 
      compareDeep(maxCountElement, o.maxCountElement, true);
  end;
end;

function TFhirSubscription.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FName) and isEmptyProp(FStatus) and isEmptyProp(FTopic) and isEmptyProp(FcontactList) and isEmptyProp(FEnd_) and isEmptyProp(FManagingEntity) and isEmptyProp(FReason) and isEmptyProp(FfilterByList) and isEmptyProp(FChannelType) and isEmptyProp(FEndpoint) and isEmptyProp(FheaderList) and isEmptyProp(FHeartbeatPeriod) and isEmptyProp(FTimeout) and isEmptyProp(FContentType) and isEmptyProp(FContent) and isEmptyProp(FMaxCount);
end;

procedure TFhirSubscription.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('name');
  fields.add('status');
  fields.add('topic');
  fields.add('contact');
  fields.add('end');
  fields.add('managingEntity');
  fields.add('reason');
  fields.add('filterBy');
  fields.add('channelType');
  fields.add('endpoint');
  fields.add('header');
  fields.add('heartbeatPeriod');
  fields.add('timeout');
  fields.add('contentType');
  fields.add('content');
  fields.add('maxCount');
end;

function TFhirSubscription.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FFilterByList.sizeInBytes(magic));
  inc(result, FHeaderList.sizeInBytes(magic));
end;

function TFhirSubscription.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirSubscription.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirSubscription.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirSubscription.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirSubscription.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirSubscription.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirSubscription.GetStatusST : TFhirSubscriptionStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirSubscriptionStatusCodesEnum(0)
  else
    result := TFhirSubscriptionStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirSubscriptionStatusCodesEnum, FStatus.value));
end;

procedure TFhirSubscription.SetStatusST(value : TFhirSubscriptionStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirSubscriptionStatusCodesEnum[value], CODES_TFhirSubscriptionStatusCodesEnum[value]);
end;

procedure TFhirSubscription.SetTopic(value : TFhirCanonical);
begin
  FTopic.free;
  FTopic := value;
end;

function TFhirSubscription.GetTopicST : String;
begin
  if FTopic = nil then
    result := ''
  else
    result := FTopic.value;
end;

procedure TFhirSubscription.SetTopicST(value : String);
begin
  if value <> '' then
  begin
    if FTopic = nil then
      FTopic := TFhirCanonical.create;
    FTopic.value := value
  end
  else if FTopic <> nil then
    FTopic.value := '';
end;

function TFhirSubscription.GetContactList : TFhirContactPointList;
begin
  if FContactList = nil then
    FContactList := TFhirContactPointList.Create;
  result := FContactList;
end;

function TFhirSubscription.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirSubscription.SetEnd_(value : TFhirInstant);
begin
  FEnd_.free;
  FEnd_ := value;
end;

function TFhirSubscription.GetEnd_ST : TFslDateTime;
begin
  if FEnd_ = nil then
    result := TFslDateTime.makeNull
  else
    result := FEnd_.value;
end;

procedure TFhirSubscription.SetEnd_ST(value : TFslDateTime);
begin
  if FEnd_ = nil then
    FEnd_ := TFhirInstant.create;
  FEnd_.value := value
end;

procedure TFhirSubscription.SetManagingEntity(value : TFhirReference);
begin
  FManagingEntity.free;
  FManagingEntity := value;
end;

procedure TFhirSubscription.SetReason(value : TFhirString);
begin
  FReason.free;
  FReason := value;
end;

function TFhirSubscription.GetReasonST : String;
begin
  if FReason = nil then
    result := ''
  else
    result := FReason.value;
end;

procedure TFhirSubscription.SetReasonST(value : String);
begin
  if value <> '' then
  begin
    if FReason = nil then
      FReason := TFhirString.create;
    FReason.value := value
  end
  else if FReason <> nil then
    FReason.value := '';
end;

function TFhirSubscription.GetFilterByList : TFhirSubscriptionFilterByList;
begin
  if FFilterByList = nil then
    FFilterByList := TFhirSubscriptionFilterByList.Create;
  result := FFilterByList;
end;

function TFhirSubscription.GetHasFilterByList : boolean;
begin
  result := (FFilterByList <> nil) and (FFilterByList.count > 0);
end;

procedure TFhirSubscription.SetChannelType(value : TFhirCoding);
begin
  FChannelType.free;
  FChannelType := value;
end;

procedure TFhirSubscription.SetEndpoint(value : TFhirUrl);
begin
  FEndpoint.free;
  FEndpoint := value;
end;

function TFhirSubscription.GetEndpointST : String;
begin
  if FEndpoint = nil then
    result := ''
  else
    result := FEndpoint.value;
end;

procedure TFhirSubscription.SetEndpointST(value : String);
begin
  if value <> '' then
  begin
    if FEndpoint = nil then
      FEndpoint := TFhirUrl.create;
    FEndpoint.value := value
  end
  else if FEndpoint <> nil then
    FEndpoint.value := '';
end;

function TFhirSubscription.GetHeaderList : TFhirStringList;
begin
  if FHeaderList = nil then
    FHeaderList := TFhirStringList.Create;
  result := FHeaderList;
end;

function TFhirSubscription.GetHasHeaderList : boolean;
begin
  result := (FHeaderList <> nil) and (FHeaderList.count > 0);
end;

procedure TFhirSubscription.SetHeartbeatPeriod(value : TFhirUnsignedInt);
begin
  FHeartbeatPeriod.free;
  FHeartbeatPeriod := value;
end;

function TFhirSubscription.GetHeartbeatPeriodST : String;
begin
  if FHeartbeatPeriod = nil then
    result := ''
  else
    result := FHeartbeatPeriod.value;
end;

procedure TFhirSubscription.SetHeartbeatPeriodST(value : String);
begin
  if value <> '' then
  begin
    if FHeartbeatPeriod = nil then
      FHeartbeatPeriod := TFhirUnsignedInt.create;
    FHeartbeatPeriod.value := value
  end
  else if FHeartbeatPeriod <> nil then
    FHeartbeatPeriod.value := '';
end;

procedure TFhirSubscription.SetTimeout(value : TFhirUnsignedInt);
begin
  FTimeout.free;
  FTimeout := value;
end;

function TFhirSubscription.GetTimeoutST : String;
begin
  if FTimeout = nil then
    result := ''
  else
    result := FTimeout.value;
end;

procedure TFhirSubscription.SetTimeoutST(value : String);
begin
  if value <> '' then
  begin
    if FTimeout = nil then
      FTimeout := TFhirUnsignedInt.create;
    FTimeout.value := value
  end
  else if FTimeout <> nil then
    FTimeout.value := '';
end;

procedure TFhirSubscription.SetContentType(value : TFhirCode);
begin
  FContentType.free;
  FContentType := value;
end;

function TFhirSubscription.GetContentTypeST : String;
begin
  if FContentType = nil then
    result := ''
  else
    result := FContentType.value;
end;

procedure TFhirSubscription.SetContentTypeST(value : String);
begin
  if value <> '' then
  begin
    if FContentType = nil then
      FContentType := TFhirCode.create;
    FContentType.value := value
  end
  else if FContentType <> nil then
    FContentType.value := '';
end;

procedure TFhirSubscription.SetContent(value : TFhirEnum);
begin
  FContent.free;
  FContent := value;
end;

function TFhirSubscription.GetContentST : TFhirSubscriptionPayloadContentEnum;
begin
  if FContent = nil then
    result := TFhirSubscriptionPayloadContentEnum(0)
  else
    result := TFhirSubscriptionPayloadContentEnum(StringArrayIndexOfSensitive(CODES_TFhirSubscriptionPayloadContentEnum, FContent.value));
end;

procedure TFhirSubscription.SetContentST(value : TFhirSubscriptionPayloadContentEnum);
begin
  if ord(value) = 0 then
    ContentElement := nil
  else
    ContentElement := TFhirEnum.create(SYSTEMS_TFhirSubscriptionPayloadContentEnum[value], CODES_TFhirSubscriptionPayloadContentEnum[value]);
end;

procedure TFhirSubscription.SetMaxCount(value : TFhirPositiveInt);
begin
  FMaxCount.free;
  FMaxCount := value;
end;

function TFhirSubscription.GetMaxCountST : String;
begin
  if FMaxCount = nil then
    result := ''
  else
    result := FMaxCount.value;
end;

procedure TFhirSubscription.SetMaxCountST(value : String);
begin
  if value <> '' then
  begin
    if FMaxCount = nil then
      FMaxCount := TFhirPositiveInt.create;
    FMaxCount.value := value
  end
  else if FMaxCount <> nil then
    FMaxCount.value := '';
end;

{ TFhirSubscriptionListEnumerator }

constructor TFhirSubscriptionListEnumerator.Create(list : TFhirSubscriptionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionListEnumerator.GetCurrent : TFhirSubscription;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubscriptionList }

function TFhirSubscriptionList.AddItem(value: TFhirSubscription): TFhirSubscription;
begin
  assert(value.ClassName = 'TFhirSubscription', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscription');
  add(value);
  result := value;
end;

function TFhirSubscriptionList.Append: TFhirSubscription;
begin
  result := TFhirSubscription.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionList.GetEnumerator : TFhirSubscriptionListEnumerator;
begin
  result := TFhirSubscriptionListEnumerator.Create(self.link);
end;

function TFhirSubscriptionList.Clone: TFhirSubscriptionList;
begin
  result := TFhirSubscriptionList(inherited Clone);
end;

function TFhirSubscriptionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionList.GetItemN(index: Integer): TFhirSubscription;
begin
  result := TFhirSubscription(ObjectByIndex[index]);
end;

function TFhirSubscriptionList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscription;
end;
function TFhirSubscriptionList.IndexOf(value: TFhirSubscription): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionList.Insert(index: Integer): TFhirSubscription;
begin
  result := TFhirSubscription.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionList.InsertItem(index: Integer; value: TFhirSubscription);
begin
  assert(value is TFhirSubscription);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionList.Item(index: Integer): TFhirSubscription;
begin
  result := TFhirSubscription(ObjectByIndex[index]);
end;

function TFhirSubscriptionList.Link: TFhirSubscriptionList;
begin
  result := TFhirSubscriptionList(inherited Link);
end;

procedure TFhirSubscriptionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionList.SetItemByIndex(index: Integer; value: TFhirSubscription);
begin
  assert(value is TFhirSubscription);
  FhirSubscriptions[index] := value;
end;

procedure TFhirSubscriptionList.SetItemN(index: Integer; value: TFhirSubscription);
begin
  assert(value is TFhirSubscription);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSCRIPTIONSTATUS}
{ TFhirSubscriptionStatusNotificationEvent }

constructor TFhirSubscriptionStatusNotificationEvent.Create;
begin
  inherited;
end;

destructor TFhirSubscriptionStatusNotificationEvent.Destroy;
begin
  FEventNumber.free;
  FTimestamp.free;
  FFocus.free;
  FAdditionalContextList.Free;
  inherited;
end;

procedure TFhirSubscriptionStatusNotificationEvent.Assign(oSource : TFslObject);
begin
  inherited;
  eventNumberElement := TFhirSubscriptionStatusNotificationEvent(oSource).eventNumberElement.Clone;
  timestampElement := TFhirSubscriptionStatusNotificationEvent(oSource).timestampElement.Clone;
  focus := TFhirSubscriptionStatusNotificationEvent(oSource).focus.Clone;
  if (TFhirSubscriptionStatusNotificationEvent(oSource).FAdditionalContextList = nil) then
  begin
    FAdditionalContextList.free;
    FAdditionalContextList := nil;
  end
  else
  begin
    if FAdditionalContextList = nil then
      FAdditionalContextList := TFhirReferenceList.Create;
    FAdditionalContextList.Assign(TFhirSubscriptionStatusNotificationEvent(oSource).FAdditionalContextList);
  end;
end;

procedure TFhirSubscriptionStatusNotificationEvent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'eventNumber') Then
     list.add(self.link, 'eventNumber', FEventNumber.Link);
  if (child_name = 'timestamp') Then
     list.add(self.link, 'timestamp', FTimestamp.Link);
  if (child_name = 'focus') Then
     list.add(self.link, 'focus', FFocus.Link);
  if (child_name = 'additionalContext') Then
    list.addAll(self, 'additionalContext', FAdditionalContextList);
end;

procedure TFhirSubscriptionStatusNotificationEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'eventNumber', 'integer64', false, TFhirInteger64, FEventNumber.Link));
  oList.add(TFHIRProperty.create(self, 'timestamp', 'instant', false, TFhirInstant, FTimestamp.Link));
  oList.add(TFHIRProperty.create(self, 'focus', 'Reference', false, TFhirReference, FFocus.Link));
  oList.add(TFHIRProperty.create(self, 'additionalContext', 'Reference', true, TFhirReference, FAdditionalContextList.Link));
end;

function TFhirSubscriptionStatusNotificationEvent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'eventNumber') then
  begin
    EventNumberElement := asInteger64(propValue);
    result := propValue;
  end
  else if (propName = 'timestamp') then
  begin
    TimestampElement := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'focus') then
  begin
    Focus := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'additionalContext') then
  begin
    AdditionalContextList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubscriptionStatusNotificationEvent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'additionalContext') then AdditionalContextList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirSubscriptionStatusNotificationEvent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'eventNumber') then result := TFhirInteger64.create()
  else if (propName = 'timestamp') then result := TFhirInstant.create()
  else if (propName = 'focus') then result := TFhirReference.create()
  else if (propName = 'additionalContext') then result := AdditionalContextList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscriptionStatusNotificationEvent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'eventNumber') then result := 'integer64'
  else if (propName = 'timestamp') then result := 'instant'
  else if (propName = 'focus') then result := 'Reference'
  else if (propName = 'additionalContext') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscriptionStatusNotificationEvent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'eventNumber') then EventNumberElement := nil
  else if (propName = 'timestamp') then TimestampElement := nil
  else if (propName = 'focus') then FocusElement := nil
  else if (propName = 'additionalContext') then deletePropertyValue('additionalContext', AdditionalContextList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscriptionStatusNotificationEvent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'eventNumber') then EventNumberElement := asInteger64(new)
  else if (propName = 'timestamp') then TimestampElement := asInstant(new)
  else if (propName = 'focus') then FocusElement := new as TFhirReference
  else if (propName = 'additionalContext') then replacePropertyValue('additionalContext', AdditionalContextList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscriptionStatusNotificationEvent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'additionalContext') then AdditionalContextList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscriptionStatusNotificationEvent.fhirType : string;
begin
  result := 'SubscriptionStatus.notificationEvent';
end;

function TFhirSubscriptionStatusNotificationEvent.Link : TFhirSubscriptionStatusNotificationEvent;
begin
  result := TFhirSubscriptionStatusNotificationEvent(inherited Link);
end;

function TFhirSubscriptionStatusNotificationEvent.Clone : TFhirSubscriptionStatusNotificationEvent;
begin
  result := TFhirSubscriptionStatusNotificationEvent(inherited Clone);
end;

function TFhirSubscriptionStatusNotificationEvent.equals(other : TObject) : boolean; 
var
  o : TFhirSubscriptionStatusNotificationEvent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscriptionStatusNotificationEvent)) then
    result := false
  else
  begin
    o := TFhirSubscriptionStatusNotificationEvent(other);
    result := compareDeep(eventNumberElement, o.eventNumberElement, true) and compareDeep(timestampElement, o.timestampElement, true) and 
      compareDeep(focusElement, o.focusElement, true) and compareDeep(additionalContextList, o.additionalContextList, true);
  end;
end;

function TFhirSubscriptionStatusNotificationEvent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FEventNumber) and isEmptyProp(FTimestamp) and isEmptyProp(FFocus) and isEmptyProp(FadditionalContextList);
end;

procedure TFhirSubscriptionStatusNotificationEvent.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('eventNumber');
  fields.add('timestamp');
  fields.add('focus');
  fields.add('additionalContext');
end;

function TFhirSubscriptionStatusNotificationEvent.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FAdditionalContextList.sizeInBytes(magic));
end;

procedure TFhirSubscriptionStatusNotificationEvent.SetEventNumber(value : TFhirInteger64);
begin
  FEventNumber.free;
  FEventNumber := value;
end;

function TFhirSubscriptionStatusNotificationEvent.GetEventNumberST : String;
begin
  if FEventNumber = nil then
    result := ''
  else
    result := FEventNumber.value;
end;

procedure TFhirSubscriptionStatusNotificationEvent.SetEventNumberST(value : String);
begin
  if value <> '' then
  begin
    if FEventNumber = nil then
      FEventNumber := TFhirInteger64.create;
    FEventNumber.value := value
  end
  else if FEventNumber <> nil then
    FEventNumber.value := '';
end;

procedure TFhirSubscriptionStatusNotificationEvent.SetTimestamp(value : TFhirInstant);
begin
  FTimestamp.free;
  FTimestamp := value;
end;

function TFhirSubscriptionStatusNotificationEvent.GetTimestampST : TFslDateTime;
begin
  if FTimestamp = nil then
    result := TFslDateTime.makeNull
  else
    result := FTimestamp.value;
end;

procedure TFhirSubscriptionStatusNotificationEvent.SetTimestampST(value : TFslDateTime);
begin
  if FTimestamp = nil then
    FTimestamp := TFhirInstant.create;
  FTimestamp.value := value
end;

procedure TFhirSubscriptionStatusNotificationEvent.SetFocus(value : TFhirReference);
begin
  FFocus.free;
  FFocus := value;
end;

function TFhirSubscriptionStatusNotificationEvent.GetAdditionalContextList : TFhirReferenceList;
begin
  if FAdditionalContextList = nil then
    FAdditionalContextList := TFhirReferenceList.Create;
  result := FAdditionalContextList;
end;

function TFhirSubscriptionStatusNotificationEvent.GetHasAdditionalContextList : boolean;
begin
  result := (FAdditionalContextList <> nil) and (FAdditionalContextList.count > 0);
end;

{ TFhirSubscriptionStatusNotificationEventListEnumerator }

constructor TFhirSubscriptionStatusNotificationEventListEnumerator.Create(list : TFhirSubscriptionStatusNotificationEventList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionStatusNotificationEventListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionStatusNotificationEventListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionStatusNotificationEventListEnumerator.GetCurrent : TFhirSubscriptionStatusNotificationEvent;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionStatusNotificationEventListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubscriptionStatusNotificationEventList }

function TFhirSubscriptionStatusNotificationEventList.AddItem(value: TFhirSubscriptionStatusNotificationEvent): TFhirSubscriptionStatusNotificationEvent;
begin
  assert(value.ClassName = 'TFhirSubscriptionStatusNotificationEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscriptionStatusNotificationEvent');
  add(value);
  result := value;
end;

function TFhirSubscriptionStatusNotificationEventList.Append: TFhirSubscriptionStatusNotificationEvent;
begin
  result := TFhirSubscriptionStatusNotificationEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionStatusNotificationEventList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionStatusNotificationEventList.GetEnumerator : TFhirSubscriptionStatusNotificationEventListEnumerator;
begin
  result := TFhirSubscriptionStatusNotificationEventListEnumerator.Create(self.link);
end;

function TFhirSubscriptionStatusNotificationEventList.Clone: TFhirSubscriptionStatusNotificationEventList;
begin
  result := TFhirSubscriptionStatusNotificationEventList(inherited Clone);
end;

function TFhirSubscriptionStatusNotificationEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionStatusNotificationEventList.GetItemN(index: Integer): TFhirSubscriptionStatusNotificationEvent;
begin
  result := TFhirSubscriptionStatusNotificationEvent(ObjectByIndex[index]);
end;

function TFhirSubscriptionStatusNotificationEventList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscriptionStatusNotificationEvent;
end;
function TFhirSubscriptionStatusNotificationEventList.IndexOf(value: TFhirSubscriptionStatusNotificationEvent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionStatusNotificationEventList.Insert(index: Integer): TFhirSubscriptionStatusNotificationEvent;
begin
  result := TFhirSubscriptionStatusNotificationEvent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionStatusNotificationEventList.InsertItem(index: Integer; value: TFhirSubscriptionStatusNotificationEvent);
begin
  assert(value is TFhirSubscriptionStatusNotificationEvent);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionStatusNotificationEventList.Item(index: Integer): TFhirSubscriptionStatusNotificationEvent;
begin
  result := TFhirSubscriptionStatusNotificationEvent(ObjectByIndex[index]);
end;

function TFhirSubscriptionStatusNotificationEventList.Link: TFhirSubscriptionStatusNotificationEventList;
begin
  result := TFhirSubscriptionStatusNotificationEventList(inherited Link);
end;

procedure TFhirSubscriptionStatusNotificationEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionStatusNotificationEventList.SetItemByIndex(index: Integer; value: TFhirSubscriptionStatusNotificationEvent);
begin
  assert(value is TFhirSubscriptionStatusNotificationEvent);
  FhirSubscriptionStatusNotificationEvents[index] := value;
end;

procedure TFhirSubscriptionStatusNotificationEventList.SetItemN(index: Integer; value: TFhirSubscriptionStatusNotificationEvent);
begin
  assert(value is TFhirSubscriptionStatusNotificationEvent);
  ObjectByIndex[index] := value;
end;

{ TFhirSubscriptionStatus }

constructor TFhirSubscriptionStatus.Create;
begin
  inherited;
end;

destructor TFhirSubscriptionStatus.Destroy;
begin
  FStatus.free;
  FType_.free;
  FEventsSinceSubscriptionStart.free;
  FNotificationEventList.Free;
  FSubscription.free;
  FTopic.free;
  FErrorList.Free;
  inherited;
end;

procedure TFhirSubscriptionStatus.Assign(oSource : TFslObject);
begin
  inherited;
  statusElement := TFhirSubscriptionStatus(oSource).statusElement.Clone;
  type_Element := TFhirSubscriptionStatus(oSource).type_Element.Clone;
  eventsSinceSubscriptionStartElement := TFhirSubscriptionStatus(oSource).eventsSinceSubscriptionStartElement.Clone;
  if (TFhirSubscriptionStatus(oSource).FNotificationEventList = nil) then
  begin
    FNotificationEventList.free;
    FNotificationEventList := nil;
  end
  else
  begin
    if FNotificationEventList = nil then
      FNotificationEventList := TFhirSubscriptionStatusNotificationEventList.Create;
    FNotificationEventList.Assign(TFhirSubscriptionStatus(oSource).FNotificationEventList);
  end;
  subscription := TFhirSubscriptionStatus(oSource).subscription.Clone;
  topicElement := TFhirSubscriptionStatus(oSource).topicElement.Clone;
  if (TFhirSubscriptionStatus(oSource).FErrorList = nil) then
  begin
    FErrorList.free;
    FErrorList := nil;
  end
  else
  begin
    if FErrorList = nil then
      FErrorList := TFhirCodeableConceptList.Create;
    FErrorList.Assign(TFhirSubscriptionStatus(oSource).FErrorList);
  end;
end;

function TFhirSubscriptionStatus.GetResourceType : TFhirResourceType;
begin
  result := frtSubscriptionStatus;
end;

procedure TFhirSubscriptionStatus.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'eventsSinceSubscriptionStart') Then
     list.add(self.link, 'eventsSinceSubscriptionStart', FEventsSinceSubscriptionStart.Link);
  if (child_name = 'notificationEvent') Then
    list.addAll(self, 'notificationEvent', FNotificationEventList);
  if (child_name = 'subscription') Then
     list.add(self.link, 'subscription', FSubscription.Link);
  if (child_name = 'topic') Then
     list.add(self.link, 'topic', FTopic.Link);
  if (child_name = 'error') Then
    list.addAll(self, 'error', FErrorList);
end;

procedure TFhirSubscriptionStatus.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'eventsSinceSubscriptionStart', 'integer64', false, TFhirInteger64, FEventsSinceSubscriptionStart.Link));
  oList.add(TFHIRProperty.create(self, 'notificationEvent', 'BackboneElement', true, TFhirSubscriptionStatusNotificationEvent, FNotificationEventList.Link));
  oList.add(TFHIRProperty.create(self, 'subscription', 'Reference', false, TFhirReference, FSubscription.Link));
  oList.add(TFHIRProperty.create(self, 'topic', 'canonical', false, TFhirCanonical, FTopic.Link));
  oList.add(TFHIRProperty.create(self, 'error', 'CodeableConcept', true, TFhirCodeableConcept, FErrorList.Link));
end;

function TFhirSubscriptionStatus.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirSubscriptionStatusCodesEnum, CODES_TFhirSubscriptionStatusCodesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirSubscriptionNotificationTypeEnum, CODES_TFhirSubscriptionNotificationTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'eventsSinceSubscriptionStart') then
  begin
    EventsSinceSubscriptionStartElement := asInteger64(propValue);
    result := propValue;
  end
  else if (propName = 'notificationEvent') then
  begin
    NotificationEventList.add(propValue as TFhirSubscriptionStatusNotificationEvent);
    result := propValue;
  end
  else if (propName = 'subscription') then
  begin
    Subscription := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    TopicElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'error') then
  begin
    ErrorList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubscriptionStatus.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'notificationEvent') then NotificationEventList.insertItem(index, propValue as TFhirSubscriptionStatusNotificationEvent)
  else if (propName = 'error') then ErrorList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirSubscriptionStatus.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirSubscriptionStatusCodesEnum[SubscriptionStatusCodesNull], CODES_TFhirSubscriptionStatusCodesEnum[SubscriptionStatusCodesNull]) 
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirSubscriptionNotificationTypeEnum[SubscriptionNotificationTypeNull], CODES_TFhirSubscriptionNotificationTypeEnum[SubscriptionNotificationTypeNull]) 
  else if (propName = 'eventsSinceSubscriptionStart') then result := TFhirInteger64.create()
  else if (propName = 'notificationEvent') then result := NotificationEventList.new()
  else if (propName = 'subscription') then result := TFhirReference.create()
  else if (propName = 'topic') then result := TFhirCanonical.create()
  else if (propName = 'error') then result := ErrorList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscriptionStatus.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'eventsSinceSubscriptionStart') then result := 'integer64'
  else if (propName = 'notificationEvent') then result := 'BackboneElement'
  else if (propName = 'subscription') then result := 'Reference'
  else if (propName = 'topic') then result := 'canonical'
  else if (propName = 'error') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscriptionStatus.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'eventsSinceSubscriptionStart') then EventsSinceSubscriptionStartElement := nil
  else if (propName = 'notificationEvent') then deletePropertyValue('notificationEvent', NotificationEventList, value)
  else if (propName = 'subscription') then SubscriptionElement := nil
  else if (propName = 'topic') then TopicElement := nil
  else if (propName = 'error') then deletePropertyValue('error', ErrorList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscriptionStatus.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirSubscriptionStatusCodesEnum, CODES_TFhirSubscriptionStatusCodesEnum, new)
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirSubscriptionNotificationTypeEnum, CODES_TFhirSubscriptionNotificationTypeEnum, new)
  else if (propName = 'eventsSinceSubscriptionStart') then EventsSinceSubscriptionStartElement := asInteger64(new)
  else if (propName = 'notificationEvent') then replacePropertyValue('notificationEvent', NotificationEventList, existing, new)
  else if (propName = 'subscription') then SubscriptionElement := new as TFhirReference
  else if (propName = 'topic') then TopicElement := asCanonical(new)
  else if (propName = 'error') then replacePropertyValue('error', ErrorList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscriptionStatus.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'notificationEvent') then NotificationEventList.move(source, destination)
  else if (propName = 'error') then ErrorList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscriptionStatus.fhirType : string;
begin
  result := 'SubscriptionStatus';
end;

function TFhirSubscriptionStatus.Link : TFhirSubscriptionStatus;
begin
  result := TFhirSubscriptionStatus(inherited Link);
end;

function TFhirSubscriptionStatus.Clone : TFhirSubscriptionStatus;
begin
  result := TFhirSubscriptionStatus(inherited Clone);
end;

function TFhirSubscriptionStatus.equals(other : TObject) : boolean; 
var
  o : TFhirSubscriptionStatus;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscriptionStatus)) then
    result := false
  else
  begin
    o := TFhirSubscriptionStatus(other);
    result := compareDeep(statusElement, o.statusElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(eventsSinceSubscriptionStartElement, o.eventsSinceSubscriptionStartElement, true) and 
      compareDeep(notificationEventList, o.notificationEventList, true) and compareDeep(subscriptionElement, o.subscriptionElement, true) and 
      compareDeep(topicElement, o.topicElement, true) and compareDeep(errorList, o.errorList, true);
  end;
end;

function TFhirSubscriptionStatus.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FEventsSinceSubscriptionStart) and isEmptyProp(FnotificationEventList) and isEmptyProp(FSubscription) and isEmptyProp(FTopic) and isEmptyProp(FerrorList);
end;

procedure TFhirSubscriptionStatus.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('status');
  fields.add('type');
  fields.add('eventsSinceSubscriptionStart');
  fields.add('notificationEvent');
  fields.add('subscription');
  fields.add('topic');
  fields.add('error');
end;

function TFhirSubscriptionStatus.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FNotificationEventList.sizeInBytes(magic));
  inc(result, FErrorList.sizeInBytes(magic));
end;

procedure TFhirSubscriptionStatus.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirSubscriptionStatus.GetStatusST : TFhirSubscriptionStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirSubscriptionStatusCodesEnum(0)
  else
    result := TFhirSubscriptionStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirSubscriptionStatusCodesEnum, FStatus.value));
end;

procedure TFhirSubscriptionStatus.SetStatusST(value : TFhirSubscriptionStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirSubscriptionStatusCodesEnum[value], CODES_TFhirSubscriptionStatusCodesEnum[value]);
end;

procedure TFhirSubscriptionStatus.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirSubscriptionStatus.GetType_ST : TFhirSubscriptionNotificationTypeEnum;
begin
  if FType_ = nil then
    result := TFhirSubscriptionNotificationTypeEnum(0)
  else
    result := TFhirSubscriptionNotificationTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirSubscriptionNotificationTypeEnum, FType_.value));
end;

procedure TFhirSubscriptionStatus.SetType_ST(value : TFhirSubscriptionNotificationTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirSubscriptionNotificationTypeEnum[value], CODES_TFhirSubscriptionNotificationTypeEnum[value]);
end;

procedure TFhirSubscriptionStatus.SetEventsSinceSubscriptionStart(value : TFhirInteger64);
begin
  FEventsSinceSubscriptionStart.free;
  FEventsSinceSubscriptionStart := value;
end;

function TFhirSubscriptionStatus.GetEventsSinceSubscriptionStartST : String;
begin
  if FEventsSinceSubscriptionStart = nil then
    result := ''
  else
    result := FEventsSinceSubscriptionStart.value;
end;

procedure TFhirSubscriptionStatus.SetEventsSinceSubscriptionStartST(value : String);
begin
  if value <> '' then
  begin
    if FEventsSinceSubscriptionStart = nil then
      FEventsSinceSubscriptionStart := TFhirInteger64.create;
    FEventsSinceSubscriptionStart.value := value
  end
  else if FEventsSinceSubscriptionStart <> nil then
    FEventsSinceSubscriptionStart.value := '';
end;

function TFhirSubscriptionStatus.GetNotificationEventList : TFhirSubscriptionStatusNotificationEventList;
begin
  if FNotificationEventList = nil then
    FNotificationEventList := TFhirSubscriptionStatusNotificationEventList.Create;
  result := FNotificationEventList;
end;

function TFhirSubscriptionStatus.GetHasNotificationEventList : boolean;
begin
  result := (FNotificationEventList <> nil) and (FNotificationEventList.count > 0);
end;

procedure TFhirSubscriptionStatus.SetSubscription(value : TFhirReference);
begin
  FSubscription.free;
  FSubscription := value;
end;

procedure TFhirSubscriptionStatus.SetTopic(value : TFhirCanonical);
begin
  FTopic.free;
  FTopic := value;
end;

function TFhirSubscriptionStatus.GetTopicST : String;
begin
  if FTopic = nil then
    result := ''
  else
    result := FTopic.value;
end;

procedure TFhirSubscriptionStatus.SetTopicST(value : String);
begin
  if value <> '' then
  begin
    if FTopic = nil then
      FTopic := TFhirCanonical.create;
    FTopic.value := value
  end
  else if FTopic <> nil then
    FTopic.value := '';
end;

function TFhirSubscriptionStatus.GetErrorList : TFhirCodeableConceptList;
begin
  if FErrorList = nil then
    FErrorList := TFhirCodeableConceptList.Create;
  result := FErrorList;
end;

function TFhirSubscriptionStatus.GetHasErrorList : boolean;
begin
  result := (FErrorList <> nil) and (FErrorList.count > 0);
end;

{ TFhirSubscriptionStatusListEnumerator }

constructor TFhirSubscriptionStatusListEnumerator.Create(list : TFhirSubscriptionStatusList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionStatusListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionStatusListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionStatusListEnumerator.GetCurrent : TFhirSubscriptionStatus;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionStatusListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubscriptionStatusList }

function TFhirSubscriptionStatusList.AddItem(value: TFhirSubscriptionStatus): TFhirSubscriptionStatus;
begin
  assert(value.ClassName = 'TFhirSubscriptionStatus', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscriptionStatus');
  add(value);
  result := value;
end;

function TFhirSubscriptionStatusList.Append: TFhirSubscriptionStatus;
begin
  result := TFhirSubscriptionStatus.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionStatusList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionStatusList.GetEnumerator : TFhirSubscriptionStatusListEnumerator;
begin
  result := TFhirSubscriptionStatusListEnumerator.Create(self.link);
end;

function TFhirSubscriptionStatusList.Clone: TFhirSubscriptionStatusList;
begin
  result := TFhirSubscriptionStatusList(inherited Clone);
end;

function TFhirSubscriptionStatusList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionStatusList.GetItemN(index: Integer): TFhirSubscriptionStatus;
begin
  result := TFhirSubscriptionStatus(ObjectByIndex[index]);
end;

function TFhirSubscriptionStatusList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscriptionStatus;
end;
function TFhirSubscriptionStatusList.IndexOf(value: TFhirSubscriptionStatus): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionStatusList.Insert(index: Integer): TFhirSubscriptionStatus;
begin
  result := TFhirSubscriptionStatus.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionStatusList.InsertItem(index: Integer; value: TFhirSubscriptionStatus);
begin
  assert(value is TFhirSubscriptionStatus);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionStatusList.Item(index: Integer): TFhirSubscriptionStatus;
begin
  result := TFhirSubscriptionStatus(ObjectByIndex[index]);
end;

function TFhirSubscriptionStatusList.Link: TFhirSubscriptionStatusList;
begin
  result := TFhirSubscriptionStatusList(inherited Link);
end;

procedure TFhirSubscriptionStatusList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionStatusList.SetItemByIndex(index: Integer; value: TFhirSubscriptionStatus);
begin
  assert(value is TFhirSubscriptionStatus);
  FhirSubscriptionStatuses[index] := value;
end;

procedure TFhirSubscriptionStatusList.SetItemN(index: Integer; value: TFhirSubscriptionStatus);
begin
  assert(value is TFhirSubscriptionStatus);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSCRIPTIONSTATUS}
{$IFDEF FHIR_SUBSCRIPTIONTOPIC}
{ TFhirSubscriptionTopicResourceTrigger }

constructor TFhirSubscriptionTopicResourceTrigger.Create;
begin
  inherited;
end;

destructor TFhirSubscriptionTopicResourceTrigger.Destroy;
begin
  FDescription.free;
  FResource.free;
  FSupportedInteraction.Free;
  FQueryCriteria.free;
  FFhirPathCriteria.free;
  inherited;
end;

procedure TFhirSubscriptionTopicResourceTrigger.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirSubscriptionTopicResourceTrigger(oSource).descriptionElement.Clone;
  resourceElement := TFhirSubscriptionTopicResourceTrigger(oSource).resourceElement.Clone;
  if (TFhirSubscriptionTopicResourceTrigger(oSource).FSupportedInteraction = nil) then
  begin
    FSupportedInteraction.free;
    FSupportedInteraction := nil;
  end
  else
  begin
    FSupportedInteraction := TFhirEnumList.Create(SYSTEMS_TFhirInteractionTriggerEnum, CODES_TFhirInteractionTriggerEnum);
    FSupportedInteraction.Assign(TFhirSubscriptionTopicResourceTrigger(oSource).FSupportedInteraction);
  end;
  queryCriteria := TFhirSubscriptionTopicResourceTrigger(oSource).queryCriteria.Clone;
  fhirPathCriteriaElement := TFhirSubscriptionTopicResourceTrigger(oSource).fhirPathCriteriaElement.Clone;
end;

procedure TFhirSubscriptionTopicResourceTrigger.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'supportedInteraction') Then
     list.addAll(self, 'supportedInteraction', FSupportedInteraction);
  if (child_name = 'queryCriteria') Then
     list.add(self.link, 'queryCriteria', FQueryCriteria.Link);
  if (child_name = 'fhirPathCriteria') Then
     list.add(self.link, 'fhirPathCriteria', FFhirPathCriteria.Link);
end;

procedure TFhirSubscriptionTopicResourceTrigger.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'resource', 'uri', false, TFhirUri, FResource.Link));
  oList.add(TFHIRProperty.create(self, 'supportedInteraction', 'code', true, TFhirEnum, FSupportedInteraction.Link));
  oList.add(TFHIRProperty.create(self, 'queryCriteria', 'BackboneElement', false, TFhirSubscriptionTopicResourceTriggerQueryCriteria, FQueryCriteria.Link));
  oList.add(TFHIRProperty.create(self, 'fhirPathCriteria', 'string', false, TFhirString, FFhirPathCriteria.Link));
end;

function TFhirSubscriptionTopicResourceTrigger.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    ResourceElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'supportedInteraction') then
  begin
    SupportedInteractionList.add(asEnum(SYSTEMS_TFhirInteractionTriggerEnum, CODES_TFhirInteractionTriggerEnum, propValue));
    result := propValue;
  end
  else if (propName = 'queryCriteria') then
  begin
    QueryCriteria := propValue as TFhirSubscriptionTopicResourceTriggerQueryCriteria;
    result := propValue;
  end
  else if (propName = 'fhirPathCriteria') then
  begin
    FhirPathCriteriaElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubscriptionTopicResourceTrigger.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'supportedInteraction') then FSupportedInteraction.insertItem(index, asEnum(SYSTEMS_TFhirInteractionTriggerEnum, CODES_TFhirInteractionTriggerEnum, propValue))
  else inherited;
end;

function TFhirSubscriptionTopicResourceTrigger.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'resource') then result := TFhirUri.create()
  else if (propName = 'queryCriteria') then result := TFhirSubscriptionTopicResourceTriggerQueryCriteria.create()
  else if (propName = 'fhirPathCriteria') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscriptionTopicResourceTrigger.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'markdown'
  else if (propName = 'resource') then result := 'uri'
  else if (propName = 'supportedInteraction') then result := 'code'
  else if (propName = 'queryCriteria') then result := 'BackboneElement'
  else if (propName = 'fhirPathCriteria') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscriptionTopicResourceTrigger.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'queryCriteria') then QueryCriteriaElement := nil
  else if (propName = 'fhirPathCriteria') then FhirPathCriteriaElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscriptionTopicResourceTrigger.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'resource') then ResourceElement := asUri(new)
  else if (propName = 'queryCriteria') then QueryCriteriaElement := new as TFhirSubscriptionTopicResourceTriggerQueryCriteria
  else if (propName = 'fhirPathCriteria') then FhirPathCriteriaElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscriptionTopicResourceTrigger.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'supportedInteraction') then FSupportedInteraction.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscriptionTopicResourceTrigger.fhirType : string;
begin
  result := 'SubscriptionTopic.resourceTrigger';
end;

function TFhirSubscriptionTopicResourceTrigger.Link : TFhirSubscriptionTopicResourceTrigger;
begin
  result := TFhirSubscriptionTopicResourceTrigger(inherited Link);
end;

function TFhirSubscriptionTopicResourceTrigger.Clone : TFhirSubscriptionTopicResourceTrigger;
begin
  result := TFhirSubscriptionTopicResourceTrigger(inherited Clone);
end;

function TFhirSubscriptionTopicResourceTrigger.equals(other : TObject) : boolean; 
var
  o : TFhirSubscriptionTopicResourceTrigger;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscriptionTopicResourceTrigger)) then
    result := false
  else
  begin
    o := TFhirSubscriptionTopicResourceTrigger(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(resourceElement, o.resourceElement, true) and 
      compareDeep(supportedInteractionList, o.supportedInteractionList, true) and compareDeep(queryCriteriaElement, o.queryCriteriaElement, true) and 
      compareDeep(fhirPathCriteriaElement, o.fhirPathCriteriaElement, true);
  end;
end;

function TFhirSubscriptionTopicResourceTrigger.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FResource) and isEmptyProp(FSupportedInteraction) and isEmptyProp(FQueryCriteria) and isEmptyProp(FFhirPathCriteria);
end;

procedure TFhirSubscriptionTopicResourceTrigger.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('resource');
  fields.add('supportedInteraction');
  fields.add('queryCriteria');
  fields.add('fhirPathCriteria');
end;

function TFhirSubscriptionTopicResourceTrigger.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FSupportedInteraction.sizeInBytes(magic));
end;

procedure TFhirSubscriptionTopicResourceTrigger.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirSubscriptionTopicResourceTrigger.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirSubscriptionTopicResourceTrigger.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirSubscriptionTopicResourceTrigger.SetResource(value : TFhirUri);
begin
  FResource.free;
  FResource := value;
end;

function TFhirSubscriptionTopicResourceTrigger.GetResourceST : String;
begin
  if FResource = nil then
    result := ''
  else
    result := FResource.value;
end;

procedure TFhirSubscriptionTopicResourceTrigger.SetResourceST(value : String);
begin
  if value <> '' then
  begin
    if FResource = nil then
      FResource := TFhirUri.create;
    FResource.value := value
  end
  else if FResource <> nil then
    FResource.value := '';
end;

function TFhirSubscriptionTopicResourceTrigger.GetSupportedInteraction : TFhirEnumList;
begin
  if FSupportedInteraction = nil then
    FSupportedInteraction := TFhirEnumList.Create(SYSTEMS_TFhirInteractionTriggerEnum, CODES_TFhirInteractionTriggerEnum);
  result := FSupportedInteraction;
end;

function TFhirSubscriptionTopicResourceTrigger.GetHasSupportedInteraction : boolean;
begin
  result := (FSupportedInteraction <> nil) and (FSupportedInteraction.count > 0);
end;

function TFhirSubscriptionTopicResourceTrigger.GetSupportedInteractionST : TFhirInteractionTriggerEnumList;
  var i : integer;
begin
  result := [];
  if FsupportedInteraction <> nil then
    for i := 0 to FsupportedInteraction.count - 1 do
      result := result + [TFhirInteractionTriggerEnum(StringArrayIndexOfSensitive(CODES_TFhirInteractionTriggerEnum, FsupportedInteraction[i].value))];
end;

procedure TFhirSubscriptionTopicResourceTrigger.SetSupportedInteractionST(value : TFhirInteractionTriggerEnumList);
var a : TFhirInteractionTriggerEnum;
begin
  if FsupportedInteraction = nil then
    FsupportedInteraction := TFhirEnumList.create(SYSTEMS_TFhirInteractionTriggerEnum, CODES_TFhirInteractionTriggerEnum);
  FsupportedInteraction.clear;
  for a := low(TFhirInteractionTriggerEnum) to high(TFhirInteractionTriggerEnum) do
    if a in value then
      begin
         if FsupportedInteraction = nil then
           FsupportedInteraction := TFhirEnumList.create(SYSTEMS_TFhirInteractionTriggerEnum, CODES_TFhirInteractionTriggerEnum);
         FsupportedInteraction.add(TFhirEnum.create(SYSTEMS_TFhirInteractionTriggerEnum[a], CODES_TFhirInteractionTriggerEnum[a]));
      end;
end;

procedure TFhirSubscriptionTopicResourceTrigger.SetQueryCriteria(value : TFhirSubscriptionTopicResourceTriggerQueryCriteria);
begin
  FQueryCriteria.free;
  FQueryCriteria := value;
end;

procedure TFhirSubscriptionTopicResourceTrigger.SetFhirPathCriteria(value : TFhirString);
begin
  FFhirPathCriteria.free;
  FFhirPathCriteria := value;
end;

function TFhirSubscriptionTopicResourceTrigger.GetFhirPathCriteriaST : String;
begin
  if FFhirPathCriteria = nil then
    result := ''
  else
    result := FFhirPathCriteria.value;
end;

procedure TFhirSubscriptionTopicResourceTrigger.SetFhirPathCriteriaST(value : String);
begin
  if value <> '' then
  begin
    if FFhirPathCriteria = nil then
      FFhirPathCriteria := TFhirString.create;
    FFhirPathCriteria.value := value
  end
  else if FFhirPathCriteria <> nil then
    FFhirPathCriteria.value := '';
end;

{ TFhirSubscriptionTopicResourceTriggerListEnumerator }

constructor TFhirSubscriptionTopicResourceTriggerListEnumerator.Create(list : TFhirSubscriptionTopicResourceTriggerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionTopicResourceTriggerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionTopicResourceTriggerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionTopicResourceTriggerListEnumerator.GetCurrent : TFhirSubscriptionTopicResourceTrigger;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionTopicResourceTriggerListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubscriptionTopicResourceTriggerList }

function TFhirSubscriptionTopicResourceTriggerList.AddItem(value: TFhirSubscriptionTopicResourceTrigger): TFhirSubscriptionTopicResourceTrigger;
begin
  assert(value.ClassName = 'TFhirSubscriptionTopicResourceTrigger', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscriptionTopicResourceTrigger');
  add(value);
  result := value;
end;

function TFhirSubscriptionTopicResourceTriggerList.Append: TFhirSubscriptionTopicResourceTrigger;
begin
  result := TFhirSubscriptionTopicResourceTrigger.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionTopicResourceTriggerList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionTopicResourceTriggerList.GetEnumerator : TFhirSubscriptionTopicResourceTriggerListEnumerator;
begin
  result := TFhirSubscriptionTopicResourceTriggerListEnumerator.Create(self.link);
end;

function TFhirSubscriptionTopicResourceTriggerList.Clone: TFhirSubscriptionTopicResourceTriggerList;
begin
  result := TFhirSubscriptionTopicResourceTriggerList(inherited Clone);
end;

function TFhirSubscriptionTopicResourceTriggerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionTopicResourceTriggerList.GetItemN(index: Integer): TFhirSubscriptionTopicResourceTrigger;
begin
  result := TFhirSubscriptionTopicResourceTrigger(ObjectByIndex[index]);
end;

function TFhirSubscriptionTopicResourceTriggerList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscriptionTopicResourceTrigger;
end;
function TFhirSubscriptionTopicResourceTriggerList.IndexOf(value: TFhirSubscriptionTopicResourceTrigger): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionTopicResourceTriggerList.Insert(index: Integer): TFhirSubscriptionTopicResourceTrigger;
begin
  result := TFhirSubscriptionTopicResourceTrigger.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionTopicResourceTriggerList.InsertItem(index: Integer; value: TFhirSubscriptionTopicResourceTrigger);
begin
  assert(value is TFhirSubscriptionTopicResourceTrigger);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionTopicResourceTriggerList.Item(index: Integer): TFhirSubscriptionTopicResourceTrigger;
begin
  result := TFhirSubscriptionTopicResourceTrigger(ObjectByIndex[index]);
end;

function TFhirSubscriptionTopicResourceTriggerList.Link: TFhirSubscriptionTopicResourceTriggerList;
begin
  result := TFhirSubscriptionTopicResourceTriggerList(inherited Link);
end;

procedure TFhirSubscriptionTopicResourceTriggerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionTopicResourceTriggerList.SetItemByIndex(index: Integer; value: TFhirSubscriptionTopicResourceTrigger);
begin
  assert(value is TFhirSubscriptionTopicResourceTrigger);
  FhirSubscriptionTopicResourceTriggers[index] := value;
end;

procedure TFhirSubscriptionTopicResourceTriggerList.SetItemN(index: Integer; value: TFhirSubscriptionTopicResourceTrigger);
begin
  assert(value is TFhirSubscriptionTopicResourceTrigger);
  ObjectByIndex[index] := value;
end;

{ TFhirSubscriptionTopicResourceTriggerQueryCriteria }

constructor TFhirSubscriptionTopicResourceTriggerQueryCriteria.Create;
begin
  inherited;
end;

destructor TFhirSubscriptionTopicResourceTriggerQueryCriteria.Destroy;
begin
  FPrevious.free;
  FResultForCreate.free;
  FCurrent.free;
  FResultForDelete.free;
  FRequireBoth.free;
  inherited;
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.Assign(oSource : TFslObject);
begin
  inherited;
  previousElement := TFhirSubscriptionTopicResourceTriggerQueryCriteria(oSource).previousElement.Clone;
  resultForCreateElement := TFhirSubscriptionTopicResourceTriggerQueryCriteria(oSource).resultForCreateElement.Clone;
  currentElement := TFhirSubscriptionTopicResourceTriggerQueryCriteria(oSource).currentElement.Clone;
  resultForDeleteElement := TFhirSubscriptionTopicResourceTriggerQueryCriteria(oSource).resultForDeleteElement.Clone;
  requireBothElement := TFhirSubscriptionTopicResourceTriggerQueryCriteria(oSource).requireBothElement.Clone;
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'previous') Then
     list.add(self.link, 'previous', FPrevious.Link);
  if (child_name = 'resultForCreate') Then
     list.add(self.link, 'resultForCreate', FResultForCreate.Link);
  if (child_name = 'current') Then
     list.add(self.link, 'current', FCurrent.Link);
  if (child_name = 'resultForDelete') Then
     list.add(self.link, 'resultForDelete', FResultForDelete.Link);
  if (child_name = 'requireBoth') Then
     list.add(self.link, 'requireBoth', FRequireBoth.Link);
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'previous', 'string', false, TFhirString, FPrevious.Link));
  oList.add(TFHIRProperty.create(self, 'resultForCreate', 'code', false, TFhirEnum, FResultForCreate.Link));
  oList.add(TFHIRProperty.create(self, 'current', 'string', false, TFhirString, FCurrent.Link));
  oList.add(TFHIRProperty.create(self, 'resultForDelete', 'code', false, TFhirEnum, FResultForDelete.Link));
  oList.add(TFHIRProperty.create(self, 'requireBoth', 'boolean', false, TFhirBoolean, FRequireBoth.Link));
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'previous') then
  begin
    PreviousElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'resultForCreate') then
  begin
    ResultForCreateElement := asEnum(SYSTEMS_TFhirCriteriaNotExistsBehaviorEnum, CODES_TFhirCriteriaNotExistsBehaviorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'current') then
  begin
    CurrentElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'resultForDelete') then
  begin
    ResultForDeleteElement := asEnum(SYSTEMS_TFhirCriteriaNotExistsBehaviorEnum, CODES_TFhirCriteriaNotExistsBehaviorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'requireBoth') then
  begin
    RequireBothElement := asBoolean(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'previous') then result := TFhirString.create()
  else if (propName = 'resultForCreate') then result := TFhirEnum.create(SYSTEMS_TFhirCriteriaNotExistsBehaviorEnum[CriteriaNotExistsBehaviorNull], CODES_TFhirCriteriaNotExistsBehaviorEnum[CriteriaNotExistsBehaviorNull]) 
  else if (propName = 'current') then result := TFhirString.create()
  else if (propName = 'resultForDelete') then result := TFhirEnum.create(SYSTEMS_TFhirCriteriaNotExistsBehaviorEnum[CriteriaNotExistsBehaviorNull], CODES_TFhirCriteriaNotExistsBehaviorEnum[CriteriaNotExistsBehaviorNull]) 
  else if (propName = 'requireBoth') then result := TFhirBoolean.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'previous') then result := 'string'
  else if (propName = 'resultForCreate') then result := 'code'
  else if (propName = 'current') then result := 'string'
  else if (propName = 'resultForDelete') then result := 'code'
  else if (propName = 'requireBoth') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'previous') then PreviousElement := nil
  else if (propName = 'resultForCreate') then ResultForCreateElement := nil
  else if (propName = 'current') then CurrentElement := nil
  else if (propName = 'resultForDelete') then ResultForDeleteElement := nil
  else if (propName = 'requireBoth') then RequireBothElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'previous') then PreviousElement := asString(new)
  else if (propName = 'resultForCreate') then ResultForCreateElement := asEnum(SYSTEMS_TFhirCriteriaNotExistsBehaviorEnum, CODES_TFhirCriteriaNotExistsBehaviorEnum, new)
  else if (propName = 'current') then CurrentElement := asString(new)
  else if (propName = 'resultForDelete') then ResultForDeleteElement := asEnum(SYSTEMS_TFhirCriteriaNotExistsBehaviorEnum, CODES_TFhirCriteriaNotExistsBehaviorEnum, new)
  else if (propName = 'requireBoth') then RequireBothElement := asBoolean(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.fhirType : string;
begin
  result := 'SubscriptionTopic.resourceTrigger.queryCriteria';
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.Link : TFhirSubscriptionTopicResourceTriggerQueryCriteria;
begin
  result := TFhirSubscriptionTopicResourceTriggerQueryCriteria(inherited Link);
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.Clone : TFhirSubscriptionTopicResourceTriggerQueryCriteria;
begin
  result := TFhirSubscriptionTopicResourceTriggerQueryCriteria(inherited Clone);
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.equals(other : TObject) : boolean; 
var
  o : TFhirSubscriptionTopicResourceTriggerQueryCriteria;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscriptionTopicResourceTriggerQueryCriteria)) then
    result := false
  else
  begin
    o := TFhirSubscriptionTopicResourceTriggerQueryCriteria(other);
    result := compareDeep(previousElement, o.previousElement, true) and compareDeep(resultForCreateElement, o.resultForCreateElement, true) and 
      compareDeep(currentElement, o.currentElement, true) and compareDeep(resultForDeleteElement, o.resultForDeleteElement, true) and 
      compareDeep(requireBothElement, o.requireBothElement, true);
  end;
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPrevious) and isEmptyProp(FResultForCreate) and isEmptyProp(FCurrent) and isEmptyProp(FResultForDelete) and isEmptyProp(FRequireBoth);
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('previous');
  fields.add('resultForCreate');
  fields.add('current');
  fields.add('resultForDelete');
  fields.add('requireBoth');
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.SetPrevious(value : TFhirString);
begin
  FPrevious.free;
  FPrevious := value;
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.GetPreviousST : String;
begin
  if FPrevious = nil then
    result := ''
  else
    result := FPrevious.value;
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.SetPreviousST(value : String);
begin
  if value <> '' then
  begin
    if FPrevious = nil then
      FPrevious := TFhirString.create;
    FPrevious.value := value
  end
  else if FPrevious <> nil then
    FPrevious.value := '';
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.SetResultForCreate(value : TFhirEnum);
begin
  FResultForCreate.free;
  FResultForCreate := value;
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.GetResultForCreateST : TFhirCriteriaNotExistsBehaviorEnum;
begin
  if FResultForCreate = nil then
    result := TFhirCriteriaNotExistsBehaviorEnum(0)
  else
    result := TFhirCriteriaNotExistsBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirCriteriaNotExistsBehaviorEnum, FResultForCreate.value));
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.SetResultForCreateST(value : TFhirCriteriaNotExistsBehaviorEnum);
begin
  if ord(value) = 0 then
    ResultForCreateElement := nil
  else
    ResultForCreateElement := TFhirEnum.create(SYSTEMS_TFhirCriteriaNotExistsBehaviorEnum[value], CODES_TFhirCriteriaNotExistsBehaviorEnum[value]);
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.SetCurrent(value : TFhirString);
begin
  FCurrent.free;
  FCurrent := value;
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.GetCurrentST : String;
begin
  if FCurrent = nil then
    result := ''
  else
    result := FCurrent.value;
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.SetCurrentST(value : String);
begin
  if value <> '' then
  begin
    if FCurrent = nil then
      FCurrent := TFhirString.create;
    FCurrent.value := value
  end
  else if FCurrent <> nil then
    FCurrent.value := '';
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.SetResultForDelete(value : TFhirEnum);
begin
  FResultForDelete.free;
  FResultForDelete := value;
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.GetResultForDeleteST : TFhirCriteriaNotExistsBehaviorEnum;
begin
  if FResultForDelete = nil then
    result := TFhirCriteriaNotExistsBehaviorEnum(0)
  else
    result := TFhirCriteriaNotExistsBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirCriteriaNotExistsBehaviorEnum, FResultForDelete.value));
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.SetResultForDeleteST(value : TFhirCriteriaNotExistsBehaviorEnum);
begin
  if ord(value) = 0 then
    ResultForDeleteElement := nil
  else
    ResultForDeleteElement := TFhirEnum.create(SYSTEMS_TFhirCriteriaNotExistsBehaviorEnum[value], CODES_TFhirCriteriaNotExistsBehaviorEnum[value]);
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.SetRequireBoth(value : TFhirBoolean);
begin
  FRequireBoth.free;
  FRequireBoth := value;
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.GetRequireBothST : Boolean;
begin
  if FRequireBoth = nil then
    result := false
  else
    result := FRequireBoth.value;
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.SetRequireBothST(value : Boolean);
begin
  if FRequireBoth = nil then
    FRequireBoth := TFhirBoolean.create;
  FRequireBoth.value := value
end;

{ TFhirSubscriptionTopicResourceTriggerQueryCriteriaListEnumerator }

constructor TFhirSubscriptionTopicResourceTriggerQueryCriteriaListEnumerator.Create(list : TFhirSubscriptionTopicResourceTriggerQueryCriteriaList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionTopicResourceTriggerQueryCriteriaListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaListEnumerator.GetCurrent : TFhirSubscriptionTopicResourceTriggerQueryCriteria;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubscriptionTopicResourceTriggerQueryCriteriaList }

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.AddItem(value: TFhirSubscriptionTopicResourceTriggerQueryCriteria): TFhirSubscriptionTopicResourceTriggerQueryCriteria;
begin
  assert(value.ClassName = 'TFhirSubscriptionTopicResourceTriggerQueryCriteria', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscriptionTopicResourceTriggerQueryCriteria');
  add(value);
  result := value;
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.Append: TFhirSubscriptionTopicResourceTriggerQueryCriteria;
begin
  result := TFhirSubscriptionTopicResourceTriggerQueryCriteria.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.GetEnumerator : TFhirSubscriptionTopicResourceTriggerQueryCriteriaListEnumerator;
begin
  result := TFhirSubscriptionTopicResourceTriggerQueryCriteriaListEnumerator.Create(self.link);
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.Clone: TFhirSubscriptionTopicResourceTriggerQueryCriteriaList;
begin
  result := TFhirSubscriptionTopicResourceTriggerQueryCriteriaList(inherited Clone);
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.GetItemN(index: Integer): TFhirSubscriptionTopicResourceTriggerQueryCriteria;
begin
  result := TFhirSubscriptionTopicResourceTriggerQueryCriteria(ObjectByIndex[index]);
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscriptionTopicResourceTriggerQueryCriteria;
end;
function TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.IndexOf(value: TFhirSubscriptionTopicResourceTriggerQueryCriteria): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.Insert(index: Integer): TFhirSubscriptionTopicResourceTriggerQueryCriteria;
begin
  result := TFhirSubscriptionTopicResourceTriggerQueryCriteria.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.InsertItem(index: Integer; value: TFhirSubscriptionTopicResourceTriggerQueryCriteria);
begin
  assert(value is TFhirSubscriptionTopicResourceTriggerQueryCriteria);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.Item(index: Integer): TFhirSubscriptionTopicResourceTriggerQueryCriteria;
begin
  result := TFhirSubscriptionTopicResourceTriggerQueryCriteria(ObjectByIndex[index]);
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.Link: TFhirSubscriptionTopicResourceTriggerQueryCriteriaList;
begin
  result := TFhirSubscriptionTopicResourceTriggerQueryCriteriaList(inherited Link);
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.SetItemByIndex(index: Integer; value: TFhirSubscriptionTopicResourceTriggerQueryCriteria);
begin
  assert(value is TFhirSubscriptionTopicResourceTriggerQueryCriteria);
  FhirSubscriptionTopicResourceTriggerQueryCriteria[index] := value;
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.SetItemN(index: Integer; value: TFhirSubscriptionTopicResourceTriggerQueryCriteria);
begin
  assert(value is TFhirSubscriptionTopicResourceTriggerQueryCriteria);
  ObjectByIndex[index] := value;
end;

{ TFhirSubscriptionTopicEventTrigger }

constructor TFhirSubscriptionTopicEventTrigger.Create;
begin
  inherited;
end;

destructor TFhirSubscriptionTopicEventTrigger.Destroy;
begin
  FDescription.free;
  FEvent.free;
  FResource.free;
  inherited;
end;

procedure TFhirSubscriptionTopicEventTrigger.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirSubscriptionTopicEventTrigger(oSource).descriptionElement.Clone;
  event := TFhirSubscriptionTopicEventTrigger(oSource).event.Clone;
  resourceElement := TFhirSubscriptionTopicEventTrigger(oSource).resourceElement.Clone;
end;

procedure TFhirSubscriptionTopicEventTrigger.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'event') Then
     list.add(self.link, 'event', FEvent.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
end;

procedure TFhirSubscriptionTopicEventTrigger.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'event', 'CodeableConcept', false, TFhirCodeableConcept, FEvent.Link));
  oList.add(TFHIRProperty.create(self, 'resource', 'uri', false, TFhirUri, FResource.Link));
end;

function TFhirSubscriptionTopicEventTrigger.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'event') then
  begin
    Event := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    ResourceElement := asUri(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubscriptionTopicEventTrigger.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubscriptionTopicEventTrigger.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'event') then result := TFhirCodeableConcept.create()
  else if (propName = 'resource') then result := TFhirUri.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscriptionTopicEventTrigger.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'markdown'
  else if (propName = 'event') then result := 'CodeableConcept'
  else if (propName = 'resource') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscriptionTopicEventTrigger.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'event') then EventElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscriptionTopicEventTrigger.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'event') then EventElement := new as TFhirCodeableConcept
  else if (propName = 'resource') then ResourceElement := asUri(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscriptionTopicEventTrigger.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscriptionTopicEventTrigger.fhirType : string;
begin
  result := 'SubscriptionTopic.eventTrigger';
end;

function TFhirSubscriptionTopicEventTrigger.Link : TFhirSubscriptionTopicEventTrigger;
begin
  result := TFhirSubscriptionTopicEventTrigger(inherited Link);
end;

function TFhirSubscriptionTopicEventTrigger.Clone : TFhirSubscriptionTopicEventTrigger;
begin
  result := TFhirSubscriptionTopicEventTrigger(inherited Clone);
end;

function TFhirSubscriptionTopicEventTrigger.equals(other : TObject) : boolean; 
var
  o : TFhirSubscriptionTopicEventTrigger;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscriptionTopicEventTrigger)) then
    result := false
  else
  begin
    o := TFhirSubscriptionTopicEventTrigger(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(eventElement, o.eventElement, true) and 
      compareDeep(resourceElement, o.resourceElement, true);
  end;
end;

function TFhirSubscriptionTopicEventTrigger.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FEvent) and isEmptyProp(FResource);
end;

procedure TFhirSubscriptionTopicEventTrigger.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('event');
  fields.add('resource');
end;

function TFhirSubscriptionTopicEventTrigger.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubscriptionTopicEventTrigger.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirSubscriptionTopicEventTrigger.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirSubscriptionTopicEventTrigger.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirSubscriptionTopicEventTrigger.SetEvent(value : TFhirCodeableConcept);
begin
  FEvent.free;
  FEvent := value;
end;

procedure TFhirSubscriptionTopicEventTrigger.SetResource(value : TFhirUri);
begin
  FResource.free;
  FResource := value;
end;

function TFhirSubscriptionTopicEventTrigger.GetResourceST : String;
begin
  if FResource = nil then
    result := ''
  else
    result := FResource.value;
end;

procedure TFhirSubscriptionTopicEventTrigger.SetResourceST(value : String);
begin
  if value <> '' then
  begin
    if FResource = nil then
      FResource := TFhirUri.create;
    FResource.value := value
  end
  else if FResource <> nil then
    FResource.value := '';
end;

{ TFhirSubscriptionTopicEventTriggerListEnumerator }

constructor TFhirSubscriptionTopicEventTriggerListEnumerator.Create(list : TFhirSubscriptionTopicEventTriggerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionTopicEventTriggerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionTopicEventTriggerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionTopicEventTriggerListEnumerator.GetCurrent : TFhirSubscriptionTopicEventTrigger;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionTopicEventTriggerListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubscriptionTopicEventTriggerList }

function TFhirSubscriptionTopicEventTriggerList.AddItem(value: TFhirSubscriptionTopicEventTrigger): TFhirSubscriptionTopicEventTrigger;
begin
  assert(value.ClassName = 'TFhirSubscriptionTopicEventTrigger', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscriptionTopicEventTrigger');
  add(value);
  result := value;
end;

function TFhirSubscriptionTopicEventTriggerList.Append: TFhirSubscriptionTopicEventTrigger;
begin
  result := TFhirSubscriptionTopicEventTrigger.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionTopicEventTriggerList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionTopicEventTriggerList.GetEnumerator : TFhirSubscriptionTopicEventTriggerListEnumerator;
begin
  result := TFhirSubscriptionTopicEventTriggerListEnumerator.Create(self.link);
end;

function TFhirSubscriptionTopicEventTriggerList.Clone: TFhirSubscriptionTopicEventTriggerList;
begin
  result := TFhirSubscriptionTopicEventTriggerList(inherited Clone);
end;

function TFhirSubscriptionTopicEventTriggerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionTopicEventTriggerList.GetItemN(index: Integer): TFhirSubscriptionTopicEventTrigger;
begin
  result := TFhirSubscriptionTopicEventTrigger(ObjectByIndex[index]);
end;

function TFhirSubscriptionTopicEventTriggerList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscriptionTopicEventTrigger;
end;
function TFhirSubscriptionTopicEventTriggerList.IndexOf(value: TFhirSubscriptionTopicEventTrigger): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionTopicEventTriggerList.Insert(index: Integer): TFhirSubscriptionTopicEventTrigger;
begin
  result := TFhirSubscriptionTopicEventTrigger.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionTopicEventTriggerList.InsertItem(index: Integer; value: TFhirSubscriptionTopicEventTrigger);
begin
  assert(value is TFhirSubscriptionTopicEventTrigger);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionTopicEventTriggerList.Item(index: Integer): TFhirSubscriptionTopicEventTrigger;
begin
  result := TFhirSubscriptionTopicEventTrigger(ObjectByIndex[index]);
end;

function TFhirSubscriptionTopicEventTriggerList.Link: TFhirSubscriptionTopicEventTriggerList;
begin
  result := TFhirSubscriptionTopicEventTriggerList(inherited Link);
end;

procedure TFhirSubscriptionTopicEventTriggerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionTopicEventTriggerList.SetItemByIndex(index: Integer; value: TFhirSubscriptionTopicEventTrigger);
begin
  assert(value is TFhirSubscriptionTopicEventTrigger);
  FhirSubscriptionTopicEventTriggers[index] := value;
end;

procedure TFhirSubscriptionTopicEventTriggerList.SetItemN(index: Integer; value: TFhirSubscriptionTopicEventTrigger);
begin
  assert(value is TFhirSubscriptionTopicEventTrigger);
  ObjectByIndex[index] := value;
end;

{ TFhirSubscriptionTopicCanFilterBy }

constructor TFhirSubscriptionTopicCanFilterBy.Create;
begin
  inherited;
end;

destructor TFhirSubscriptionTopicCanFilterBy.Destroy;
begin
  FDescription.free;
  FResource.free;
  FFilterParameter.free;
  FFilterDefinition.free;
  FModifier.Free;
  inherited;
end;

procedure TFhirSubscriptionTopicCanFilterBy.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirSubscriptionTopicCanFilterBy(oSource).descriptionElement.Clone;
  resourceElement := TFhirSubscriptionTopicCanFilterBy(oSource).resourceElement.Clone;
  filterParameterElement := TFhirSubscriptionTopicCanFilterBy(oSource).filterParameterElement.Clone;
  filterDefinitionElement := TFhirSubscriptionTopicCanFilterBy(oSource).filterDefinitionElement.Clone;
  if (TFhirSubscriptionTopicCanFilterBy(oSource).FModifier = nil) then
  begin
    FModifier.free;
    FModifier := nil;
  end
  else
  begin
    FModifier := TFhirEnumList.Create(SYSTEMS_TFhirSubscriptionSearchModifierEnum, CODES_TFhirSubscriptionSearchModifierEnum);
    FModifier.Assign(TFhirSubscriptionTopicCanFilterBy(oSource).FModifier);
  end;
end;

procedure TFhirSubscriptionTopicCanFilterBy.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'filterParameter') Then
     list.add(self.link, 'filterParameter', FFilterParameter.Link);
  if (child_name = 'filterDefinition') Then
     list.add(self.link, 'filterDefinition', FFilterDefinition.Link);
  if (child_name = 'modifier') Then
     list.addAll(self, 'modifier', FModifier);
end;

procedure TFhirSubscriptionTopicCanFilterBy.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'resource', 'uri', false, TFhirUri, FResource.Link));
  oList.add(TFHIRProperty.create(self, 'filterParameter', 'string', false, TFhirString, FFilterParameter.Link));
  oList.add(TFHIRProperty.create(self, 'filterDefinition', 'uri', false, TFhirUri, FFilterDefinition.Link));
  oList.add(TFHIRProperty.create(self, 'modifier', 'code', true, TFhirEnum, FModifier.Link));
end;

function TFhirSubscriptionTopicCanFilterBy.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    ResourceElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'filterParameter') then
  begin
    FilterParameterElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'filterDefinition') then
  begin
    FilterDefinitionElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(asEnum(SYSTEMS_TFhirSubscriptionSearchModifierEnum, CODES_TFhirSubscriptionSearchModifierEnum, propValue));
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubscriptionTopicCanFilterBy.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then FModifier.insertItem(index, asEnum(SYSTEMS_TFhirSubscriptionSearchModifierEnum, CODES_TFhirSubscriptionSearchModifierEnum, propValue))
  else inherited;
end;

function TFhirSubscriptionTopicCanFilterBy.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'resource') then result := TFhirUri.create()
  else if (propName = 'filterParameter') then result := TFhirString.create()
  else if (propName = 'filterDefinition') then result := TFhirUri.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscriptionTopicCanFilterBy.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'markdown'
  else if (propName = 'resource') then result := 'uri'
  else if (propName = 'filterParameter') then result := 'string'
  else if (propName = 'filterDefinition') then result := 'uri'
  else if (propName = 'modifier') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscriptionTopicCanFilterBy.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'filterParameter') then FilterParameterElement := nil
  else if (propName = 'filterDefinition') then FilterDefinitionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscriptionTopicCanFilterBy.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'resource') then ResourceElement := asUri(new)
  else if (propName = 'filterParameter') then FilterParameterElement := asString(new)
  else if (propName = 'filterDefinition') then FilterDefinitionElement := asUri(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscriptionTopicCanFilterBy.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then FModifier.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscriptionTopicCanFilterBy.fhirType : string;
begin
  result := 'SubscriptionTopic.canFilterBy';
end;

function TFhirSubscriptionTopicCanFilterBy.Link : TFhirSubscriptionTopicCanFilterBy;
begin
  result := TFhirSubscriptionTopicCanFilterBy(inherited Link);
end;

function TFhirSubscriptionTopicCanFilterBy.Clone : TFhirSubscriptionTopicCanFilterBy;
begin
  result := TFhirSubscriptionTopicCanFilterBy(inherited Clone);
end;

function TFhirSubscriptionTopicCanFilterBy.equals(other : TObject) : boolean; 
var
  o : TFhirSubscriptionTopicCanFilterBy;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscriptionTopicCanFilterBy)) then
    result := false
  else
  begin
    o := TFhirSubscriptionTopicCanFilterBy(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(resourceElement, o.resourceElement, true) and 
      compareDeep(filterParameterElement, o.filterParameterElement, true) and compareDeep(filterDefinitionElement, o.filterDefinitionElement, true) and 
      compareDeep(modifierList, o.modifierList, true);
  end;
end;

function TFhirSubscriptionTopicCanFilterBy.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FResource) and isEmptyProp(FFilterParameter) and isEmptyProp(FFilterDefinition) and isEmptyProp(FModifier);
end;

procedure TFhirSubscriptionTopicCanFilterBy.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('resource');
  fields.add('filterParameter');
  fields.add('filterDefinition');
  fields.add('modifier');
end;

function TFhirSubscriptionTopicCanFilterBy.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FModifier.sizeInBytes(magic));
end;

procedure TFhirSubscriptionTopicCanFilterBy.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirSubscriptionTopicCanFilterBy.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirSubscriptionTopicCanFilterBy.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirSubscriptionTopicCanFilterBy.SetResource(value : TFhirUri);
begin
  FResource.free;
  FResource := value;
end;

function TFhirSubscriptionTopicCanFilterBy.GetResourceST : String;
begin
  if FResource = nil then
    result := ''
  else
    result := FResource.value;
end;

procedure TFhirSubscriptionTopicCanFilterBy.SetResourceST(value : String);
begin
  if value <> '' then
  begin
    if FResource = nil then
      FResource := TFhirUri.create;
    FResource.value := value
  end
  else if FResource <> nil then
    FResource.value := '';
end;

procedure TFhirSubscriptionTopicCanFilterBy.SetFilterParameter(value : TFhirString);
begin
  FFilterParameter.free;
  FFilterParameter := value;
end;

function TFhirSubscriptionTopicCanFilterBy.GetFilterParameterST : String;
begin
  if FFilterParameter = nil then
    result := ''
  else
    result := FFilterParameter.value;
end;

procedure TFhirSubscriptionTopicCanFilterBy.SetFilterParameterST(value : String);
begin
  if value <> '' then
  begin
    if FFilterParameter = nil then
      FFilterParameter := TFhirString.create;
    FFilterParameter.value := value
  end
  else if FFilterParameter <> nil then
    FFilterParameter.value := '';
end;

procedure TFhirSubscriptionTopicCanFilterBy.SetFilterDefinition(value : TFhirUri);
begin
  FFilterDefinition.free;
  FFilterDefinition := value;
end;

function TFhirSubscriptionTopicCanFilterBy.GetFilterDefinitionST : String;
begin
  if FFilterDefinition = nil then
    result := ''
  else
    result := FFilterDefinition.value;
end;

procedure TFhirSubscriptionTopicCanFilterBy.SetFilterDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FFilterDefinition = nil then
      FFilterDefinition := TFhirUri.create;
    FFilterDefinition.value := value
  end
  else if FFilterDefinition <> nil then
    FFilterDefinition.value := '';
end;

function TFhirSubscriptionTopicCanFilterBy.GetModifier : TFhirEnumList;
begin
  if FModifier = nil then
    FModifier := TFhirEnumList.Create(SYSTEMS_TFhirSubscriptionSearchModifierEnum, CODES_TFhirSubscriptionSearchModifierEnum);
  result := FModifier;
end;

function TFhirSubscriptionTopicCanFilterBy.GetHasModifier : boolean;
begin
  result := (FModifier <> nil) and (FModifier.count > 0);
end;

function TFhirSubscriptionTopicCanFilterBy.GetModifierST : TFhirSubscriptionSearchModifierEnumList;
  var i : integer;
begin
  result := [];
  if Fmodifier <> nil then
    for i := 0 to Fmodifier.count - 1 do
      result := result + [TFhirSubscriptionSearchModifierEnum(StringArrayIndexOfSensitive(CODES_TFhirSubscriptionSearchModifierEnum, Fmodifier[i].value))];
end;

procedure TFhirSubscriptionTopicCanFilterBy.SetModifierST(value : TFhirSubscriptionSearchModifierEnumList);
var a : TFhirSubscriptionSearchModifierEnum;
begin
  if Fmodifier = nil then
    Fmodifier := TFhirEnumList.create(SYSTEMS_TFhirSubscriptionSearchModifierEnum, CODES_TFhirSubscriptionSearchModifierEnum);
  Fmodifier.clear;
  for a := low(TFhirSubscriptionSearchModifierEnum) to high(TFhirSubscriptionSearchModifierEnum) do
    if a in value then
      begin
         if Fmodifier = nil then
           Fmodifier := TFhirEnumList.create(SYSTEMS_TFhirSubscriptionSearchModifierEnum, CODES_TFhirSubscriptionSearchModifierEnum);
         Fmodifier.add(TFhirEnum.create(SYSTEMS_TFhirSubscriptionSearchModifierEnum[a], CODES_TFhirSubscriptionSearchModifierEnum[a]));
      end;
end;

{ TFhirSubscriptionTopicCanFilterByListEnumerator }

constructor TFhirSubscriptionTopicCanFilterByListEnumerator.Create(list : TFhirSubscriptionTopicCanFilterByList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionTopicCanFilterByListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionTopicCanFilterByListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionTopicCanFilterByListEnumerator.GetCurrent : TFhirSubscriptionTopicCanFilterBy;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionTopicCanFilterByListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubscriptionTopicCanFilterByList }

function TFhirSubscriptionTopicCanFilterByList.AddItem(value: TFhirSubscriptionTopicCanFilterBy): TFhirSubscriptionTopicCanFilterBy;
begin
  assert(value.ClassName = 'TFhirSubscriptionTopicCanFilterBy', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscriptionTopicCanFilterBy');
  add(value);
  result := value;
end;

function TFhirSubscriptionTopicCanFilterByList.Append: TFhirSubscriptionTopicCanFilterBy;
begin
  result := TFhirSubscriptionTopicCanFilterBy.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionTopicCanFilterByList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionTopicCanFilterByList.GetEnumerator : TFhirSubscriptionTopicCanFilterByListEnumerator;
begin
  result := TFhirSubscriptionTopicCanFilterByListEnumerator.Create(self.link);
end;

function TFhirSubscriptionTopicCanFilterByList.Clone: TFhirSubscriptionTopicCanFilterByList;
begin
  result := TFhirSubscriptionTopicCanFilterByList(inherited Clone);
end;

function TFhirSubscriptionTopicCanFilterByList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionTopicCanFilterByList.GetItemN(index: Integer): TFhirSubscriptionTopicCanFilterBy;
begin
  result := TFhirSubscriptionTopicCanFilterBy(ObjectByIndex[index]);
end;

function TFhirSubscriptionTopicCanFilterByList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscriptionTopicCanFilterBy;
end;
function TFhirSubscriptionTopicCanFilterByList.IndexOf(value: TFhirSubscriptionTopicCanFilterBy): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionTopicCanFilterByList.Insert(index: Integer): TFhirSubscriptionTopicCanFilterBy;
begin
  result := TFhirSubscriptionTopicCanFilterBy.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionTopicCanFilterByList.InsertItem(index: Integer; value: TFhirSubscriptionTopicCanFilterBy);
begin
  assert(value is TFhirSubscriptionTopicCanFilterBy);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionTopicCanFilterByList.Item(index: Integer): TFhirSubscriptionTopicCanFilterBy;
begin
  result := TFhirSubscriptionTopicCanFilterBy(ObjectByIndex[index]);
end;

function TFhirSubscriptionTopicCanFilterByList.Link: TFhirSubscriptionTopicCanFilterByList;
begin
  result := TFhirSubscriptionTopicCanFilterByList(inherited Link);
end;

procedure TFhirSubscriptionTopicCanFilterByList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionTopicCanFilterByList.SetItemByIndex(index: Integer; value: TFhirSubscriptionTopicCanFilterBy);
begin
  assert(value is TFhirSubscriptionTopicCanFilterBy);
  FhirSubscriptionTopicCanFilterBies[index] := value;
end;

procedure TFhirSubscriptionTopicCanFilterByList.SetItemN(index: Integer; value: TFhirSubscriptionTopicCanFilterBy);
begin
  assert(value is TFhirSubscriptionTopicCanFilterBy);
  ObjectByIndex[index] := value;
end;

{ TFhirSubscriptionTopicNotificationShape }

constructor TFhirSubscriptionTopicNotificationShape.Create;
begin
  inherited;
end;

destructor TFhirSubscriptionTopicNotificationShape.Destroy;
begin
  FResource.free;
  FIncludeList.Free;
  FRevIncludeList.Free;
  inherited;
end;

procedure TFhirSubscriptionTopicNotificationShape.Assign(oSource : TFslObject);
begin
  inherited;
  resourceElement := TFhirSubscriptionTopicNotificationShape(oSource).resourceElement.Clone;
  if (TFhirSubscriptionTopicNotificationShape(oSource).FIncludeList = nil) then
  begin
    FIncludeList.free;
    FIncludeList := nil;
  end
  else
  begin
    if FIncludeList = nil then
      FIncludeList := TFhirStringList.Create;
    FIncludeList.Assign(TFhirSubscriptionTopicNotificationShape(oSource).FIncludeList);
  end;
  if (TFhirSubscriptionTopicNotificationShape(oSource).FRevIncludeList = nil) then
  begin
    FRevIncludeList.free;
    FRevIncludeList := nil;
  end
  else
  begin
    if FRevIncludeList = nil then
      FRevIncludeList := TFhirStringList.Create;
    FRevIncludeList.Assign(TFhirSubscriptionTopicNotificationShape(oSource).FRevIncludeList);
  end;
end;

procedure TFhirSubscriptionTopicNotificationShape.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'include') Then
    list.addAll(self, 'include', FIncludeList);
  if (child_name = 'revInclude') Then
    list.addAll(self, 'revInclude', FRevIncludeList);
end;

procedure TFhirSubscriptionTopicNotificationShape.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'resource', 'uri', false, TFhirUri, FResource.Link));
  oList.add(TFHIRProperty.create(self, 'include', 'string', true, TFhirString, FIncludeList.Link));
  oList.add(TFHIRProperty.create(self, 'revInclude', 'string', true, TFhirString, FRevIncludeList.Link));
end;

function TFhirSubscriptionTopicNotificationShape.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'resource') then
  begin
    ResourceElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'include') then
  begin
    IncludeList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'revInclude') then
  begin
    RevIncludeList.add(asString(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubscriptionTopicNotificationShape.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'include') then IncludeList.insertItem(index, asString(propValue))
  else if (propName = 'revInclude') then RevIncludeList.insertItem(index, asString(propValue))
  else inherited;
end;

function TFhirSubscriptionTopicNotificationShape.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'resource') then result := TFhirUri.create()
  else if (propName = 'include') then result := IncludeList.new()
  else if (propName = 'revInclude') then result := RevIncludeList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscriptionTopicNotificationShape.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'resource') then result := 'uri'
  else if (propName = 'include') then result := 'string'
  else if (propName = 'revInclude') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscriptionTopicNotificationShape.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'include') then deletePropertyValue('include', IncludeList, value)
  else if (propName = 'revInclude') then deletePropertyValue('revInclude', RevIncludeList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscriptionTopicNotificationShape.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'resource') then ResourceElement := asUri(new)
  else if (propName = 'include') then replacePropertyValue('include', IncludeList, existing, new)
  else if (propName = 'revInclude') then replacePropertyValue('revInclude', RevIncludeList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscriptionTopicNotificationShape.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'include') then IncludeList.move(source, destination)
  else if (propName = 'revInclude') then RevIncludeList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscriptionTopicNotificationShape.fhirType : string;
begin
  result := 'SubscriptionTopic.notificationShape';
end;

function TFhirSubscriptionTopicNotificationShape.Link : TFhirSubscriptionTopicNotificationShape;
begin
  result := TFhirSubscriptionTopicNotificationShape(inherited Link);
end;

function TFhirSubscriptionTopicNotificationShape.Clone : TFhirSubscriptionTopicNotificationShape;
begin
  result := TFhirSubscriptionTopicNotificationShape(inherited Clone);
end;

function TFhirSubscriptionTopicNotificationShape.equals(other : TObject) : boolean; 
var
  o : TFhirSubscriptionTopicNotificationShape;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscriptionTopicNotificationShape)) then
    result := false
  else
  begin
    o := TFhirSubscriptionTopicNotificationShape(other);
    result := compareDeep(resourceElement, o.resourceElement, true) and compareDeep(includeList, o.includeList, true) and 
      compareDeep(revIncludeList, o.revIncludeList, true);
  end;
end;

function TFhirSubscriptionTopicNotificationShape.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FResource) and isEmptyProp(FincludeList) and isEmptyProp(FrevIncludeList);
end;

procedure TFhirSubscriptionTopicNotificationShape.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('resource');
  fields.add('include');
  fields.add('revInclude');
end;

function TFhirSubscriptionTopicNotificationShape.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIncludeList.sizeInBytes(magic));
  inc(result, FRevIncludeList.sizeInBytes(magic));
end;

procedure TFhirSubscriptionTopicNotificationShape.SetResource(value : TFhirUri);
begin
  FResource.free;
  FResource := value;
end;

function TFhirSubscriptionTopicNotificationShape.GetResourceST : String;
begin
  if FResource = nil then
    result := ''
  else
    result := FResource.value;
end;

procedure TFhirSubscriptionTopicNotificationShape.SetResourceST(value : String);
begin
  if value <> '' then
  begin
    if FResource = nil then
      FResource := TFhirUri.create;
    FResource.value := value
  end
  else if FResource <> nil then
    FResource.value := '';
end;

function TFhirSubscriptionTopicNotificationShape.GetIncludeList : TFhirStringList;
begin
  if FIncludeList = nil then
    FIncludeList := TFhirStringList.Create;
  result := FIncludeList;
end;

function TFhirSubscriptionTopicNotificationShape.GetHasIncludeList : boolean;
begin
  result := (FIncludeList <> nil) and (FIncludeList.count > 0);
end;

function TFhirSubscriptionTopicNotificationShape.GetRevIncludeList : TFhirStringList;
begin
  if FRevIncludeList = nil then
    FRevIncludeList := TFhirStringList.Create;
  result := FRevIncludeList;
end;

function TFhirSubscriptionTopicNotificationShape.GetHasRevIncludeList : boolean;
begin
  result := (FRevIncludeList <> nil) and (FRevIncludeList.count > 0);
end;

{ TFhirSubscriptionTopicNotificationShapeListEnumerator }

constructor TFhirSubscriptionTopicNotificationShapeListEnumerator.Create(list : TFhirSubscriptionTopicNotificationShapeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionTopicNotificationShapeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionTopicNotificationShapeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionTopicNotificationShapeListEnumerator.GetCurrent : TFhirSubscriptionTopicNotificationShape;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionTopicNotificationShapeListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubscriptionTopicNotificationShapeList }

function TFhirSubscriptionTopicNotificationShapeList.AddItem(value: TFhirSubscriptionTopicNotificationShape): TFhirSubscriptionTopicNotificationShape;
begin
  assert(value.ClassName = 'TFhirSubscriptionTopicNotificationShape', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscriptionTopicNotificationShape');
  add(value);
  result := value;
end;

function TFhirSubscriptionTopicNotificationShapeList.Append: TFhirSubscriptionTopicNotificationShape;
begin
  result := TFhirSubscriptionTopicNotificationShape.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionTopicNotificationShapeList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionTopicNotificationShapeList.GetEnumerator : TFhirSubscriptionTopicNotificationShapeListEnumerator;
begin
  result := TFhirSubscriptionTopicNotificationShapeListEnumerator.Create(self.link);
end;

function TFhirSubscriptionTopicNotificationShapeList.Clone: TFhirSubscriptionTopicNotificationShapeList;
begin
  result := TFhirSubscriptionTopicNotificationShapeList(inherited Clone);
end;

function TFhirSubscriptionTopicNotificationShapeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionTopicNotificationShapeList.GetItemN(index: Integer): TFhirSubscriptionTopicNotificationShape;
begin
  result := TFhirSubscriptionTopicNotificationShape(ObjectByIndex[index]);
end;

function TFhirSubscriptionTopicNotificationShapeList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscriptionTopicNotificationShape;
end;
function TFhirSubscriptionTopicNotificationShapeList.IndexOf(value: TFhirSubscriptionTopicNotificationShape): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionTopicNotificationShapeList.Insert(index: Integer): TFhirSubscriptionTopicNotificationShape;
begin
  result := TFhirSubscriptionTopicNotificationShape.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionTopicNotificationShapeList.InsertItem(index: Integer; value: TFhirSubscriptionTopicNotificationShape);
begin
  assert(value is TFhirSubscriptionTopicNotificationShape);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionTopicNotificationShapeList.Item(index: Integer): TFhirSubscriptionTopicNotificationShape;
begin
  result := TFhirSubscriptionTopicNotificationShape(ObjectByIndex[index]);
end;

function TFhirSubscriptionTopicNotificationShapeList.Link: TFhirSubscriptionTopicNotificationShapeList;
begin
  result := TFhirSubscriptionTopicNotificationShapeList(inherited Link);
end;

procedure TFhirSubscriptionTopicNotificationShapeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionTopicNotificationShapeList.SetItemByIndex(index: Integer; value: TFhirSubscriptionTopicNotificationShape);
begin
  assert(value is TFhirSubscriptionTopicNotificationShape);
  FhirSubscriptionTopicNotificationShapes[index] := value;
end;

procedure TFhirSubscriptionTopicNotificationShapeList.SetItemN(index: Integer; value: TFhirSubscriptionTopicNotificationShape);
begin
  assert(value is TFhirSubscriptionTopicNotificationShape);
  ObjectByIndex[index] := value;
end;

{ TFhirSubscriptionTopic }

constructor TFhirSubscriptionTopic.Create;
begin
  inherited;
end;

destructor TFhirSubscriptionTopic.Destroy;
begin
  FDerivedFromList.Free;
  FApprovalDate.free;
  FLastReviewDate.free;
  FEffectivePeriod.free;
  FResourceTriggerList.Free;
  FEventTriggerList.Free;
  FCanFilterByList.Free;
  FNotificationShapeList.Free;
  inherited;
end;

procedure TFhirSubscriptionTopic.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSubscriptionTopic(oSource).FDerivedFromList = nil) then
  begin
    FDerivedFromList.free;
    FDerivedFromList := nil;
  end
  else
  begin
    if FDerivedFromList = nil then
      FDerivedFromList := TFhirCanonicalList.Create;
    FDerivedFromList.Assign(TFhirSubscriptionTopic(oSource).FDerivedFromList);
  end;
  approvalDateElement := TFhirSubscriptionTopic(oSource).approvalDateElement.Clone;
  lastReviewDateElement := TFhirSubscriptionTopic(oSource).lastReviewDateElement.Clone;
  effectivePeriod := TFhirSubscriptionTopic(oSource).effectivePeriod.Clone;
  if (TFhirSubscriptionTopic(oSource).FResourceTriggerList = nil) then
  begin
    FResourceTriggerList.free;
    FResourceTriggerList := nil;
  end
  else
  begin
    if FResourceTriggerList = nil then
      FResourceTriggerList := TFhirSubscriptionTopicResourceTriggerList.Create;
    FResourceTriggerList.Assign(TFhirSubscriptionTopic(oSource).FResourceTriggerList);
  end;
  if (TFhirSubscriptionTopic(oSource).FEventTriggerList = nil) then
  begin
    FEventTriggerList.free;
    FEventTriggerList := nil;
  end
  else
  begin
    if FEventTriggerList = nil then
      FEventTriggerList := TFhirSubscriptionTopicEventTriggerList.Create;
    FEventTriggerList.Assign(TFhirSubscriptionTopic(oSource).FEventTriggerList);
  end;
  if (TFhirSubscriptionTopic(oSource).FCanFilterByList = nil) then
  begin
    FCanFilterByList.free;
    FCanFilterByList := nil;
  end
  else
  begin
    if FCanFilterByList = nil then
      FCanFilterByList := TFhirSubscriptionTopicCanFilterByList.Create;
    FCanFilterByList.Assign(TFhirSubscriptionTopic(oSource).FCanFilterByList);
  end;
  if (TFhirSubscriptionTopic(oSource).FNotificationShapeList = nil) then
  begin
    FNotificationShapeList.free;
    FNotificationShapeList := nil;
  end
  else
  begin
    if FNotificationShapeList = nil then
      FNotificationShapeList := TFhirSubscriptionTopicNotificationShapeList.Create;
    FNotificationShapeList.Assign(TFhirSubscriptionTopic(oSource).FNotificationShapeList);
  end;
end;

function TFhirSubscriptionTopic.GetResourceType : TFhirResourceType;
begin
  result := frtSubscriptionTopic;
end;

procedure TFhirSubscriptionTopic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'derivedFrom') Then
    list.addAll(self, 'derivedFrom', FDerivedFromList);
  if (child_name = 'approvalDate') Then
     list.add(self.link, 'approvalDate', FApprovalDate.Link);
  if (child_name = 'lastReviewDate') Then
     list.add(self.link, 'lastReviewDate', FLastReviewDate.Link);
  if (child_name = 'effectivePeriod') Then
     list.add(self.link, 'effectivePeriod', FEffectivePeriod.Link);
  if (child_name = 'resourceTrigger') Then
    list.addAll(self, 'resourceTrigger', FResourceTriggerList);
  if (child_name = 'eventTrigger') Then
    list.addAll(self, 'eventTrigger', FEventTriggerList);
  if (child_name = 'canFilterBy') Then
    list.addAll(self, 'canFilterBy', FCanFilterByList);
  if (child_name = 'notificationShape') Then
    list.addAll(self, 'notificationShape', FNotificationShapeList);
end;

procedure TFhirSubscriptionTopic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'derivedFrom', 'canonical', true, TFhirCanonical, FDerivedFromList.Link));
  oList.add(TFHIRProperty.create(self, 'approvalDate', 'date', false, TFhirDate, FApprovalDate.Link));
  oList.add(TFHIRProperty.create(self, 'lastReviewDate', 'date', false, TFhirDate, FLastReviewDate.Link));
  oList.add(TFHIRProperty.create(self, 'effectivePeriod', 'Period', false, TFhirPeriod, FEffectivePeriod.Link));
  oList.add(TFHIRProperty.create(self, 'resourceTrigger', 'BackboneElement', true, TFhirSubscriptionTopicResourceTrigger, FResourceTriggerList.Link));
  oList.add(TFHIRProperty.create(self, 'eventTrigger', 'BackboneElement', true, TFhirSubscriptionTopicEventTrigger, FEventTriggerList.Link));
  oList.add(TFHIRProperty.create(self, 'canFilterBy', 'BackboneElement', true, TFhirSubscriptionTopicCanFilterBy, FCanFilterByList.Link));
  oList.add(TFHIRProperty.create(self, 'notificationShape', 'BackboneElement', true, TFhirSubscriptionTopicNotificationShape, FNotificationShapeList.Link));
end;

function TFhirSubscriptionTopic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'derivedFrom') then
  begin
    DerivedFromList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'approvalDate') then
  begin
    ApprovalDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'lastReviewDate') then
  begin
    LastReviewDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'effectivePeriod') then
  begin
    EffectivePeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'resourceTrigger') then
  begin
    ResourceTriggerList.add(propValue as TFhirSubscriptionTopicResourceTrigger);
    result := propValue;
  end
  else if (propName = 'eventTrigger') then
  begin
    EventTriggerList.add(propValue as TFhirSubscriptionTopicEventTrigger);
    result := propValue;
  end
  else if (propName = 'canFilterBy') then
  begin
    CanFilterByList.add(propValue as TFhirSubscriptionTopicCanFilterBy);
    result := propValue;
  end
  else if (propName = 'notificationShape') then
  begin
    NotificationShapeList.add(propValue as TFhirSubscriptionTopicNotificationShape);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubscriptionTopic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'derivedFrom') then DerivedFromList.insertItem(index, asCanonical(propValue))
  else if (propName = 'resourceTrigger') then ResourceTriggerList.insertItem(index, propValue as TFhirSubscriptionTopicResourceTrigger)
  else if (propName = 'eventTrigger') then EventTriggerList.insertItem(index, propValue as TFhirSubscriptionTopicEventTrigger)
  else if (propName = 'canFilterBy') then CanFilterByList.insertItem(index, propValue as TFhirSubscriptionTopicCanFilterBy)
  else if (propName = 'notificationShape') then NotificationShapeList.insertItem(index, propValue as TFhirSubscriptionTopicNotificationShape)
  else inherited;
end;

function TFhirSubscriptionTopic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'derivedFrom') then result := DerivedFromList.new()
  else if (propName = 'approvalDate') then result := TFhirDate.create()
  else if (propName = 'lastReviewDate') then result := TFhirDate.create()
  else if (propName = 'effectivePeriod') then result := TFhirPeriod.create()
  else if (propName = 'resourceTrigger') then result := ResourceTriggerList.new()
  else if (propName = 'eventTrigger') then result := EventTriggerList.new()
  else if (propName = 'canFilterBy') then result := CanFilterByList.new()
  else if (propName = 'notificationShape') then result := NotificationShapeList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscriptionTopic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'derivedFrom') then result := 'canonical'
  else if (propName = 'approvalDate') then result := 'date'
  else if (propName = 'lastReviewDate') then result := 'date'
  else if (propName = 'effectivePeriod') then result := 'Period'
  else if (propName = 'resourceTrigger') then result := 'BackboneElement'
  else if (propName = 'eventTrigger') then result := 'BackboneElement'
  else if (propName = 'canFilterBy') then result := 'BackboneElement'
  else if (propName = 'notificationShape') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscriptionTopic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'derivedFrom') then deletePropertyValue('derivedFrom', DerivedFromList, value)
  else if (propName = 'approvalDate') then ApprovalDateElement := nil
  else if (propName = 'lastReviewDate') then LastReviewDateElement := nil
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := nil
  else if (propName = 'resourceTrigger') then deletePropertyValue('resourceTrigger', ResourceTriggerList, value)
  else if (propName = 'eventTrigger') then deletePropertyValue('eventTrigger', EventTriggerList, value)
  else if (propName = 'canFilterBy') then deletePropertyValue('canFilterBy', CanFilterByList, value)
  else if (propName = 'notificationShape') then deletePropertyValue('notificationShape', NotificationShapeList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscriptionTopic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'derivedFrom') then replacePropertyValue('derivedFrom', DerivedFromList, existing, new)
  else if (propName = 'approvalDate') then ApprovalDateElement := asDate(new)
  else if (propName = 'lastReviewDate') then LastReviewDateElement := asDate(new)
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := new as TFhirPeriod
  else if (propName = 'resourceTrigger') then replacePropertyValue('resourceTrigger', ResourceTriggerList, existing, new)
  else if (propName = 'eventTrigger') then replacePropertyValue('eventTrigger', EventTriggerList, existing, new)
  else if (propName = 'canFilterBy') then replacePropertyValue('canFilterBy', CanFilterByList, existing, new)
  else if (propName = 'notificationShape') then replacePropertyValue('notificationShape', NotificationShapeList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscriptionTopic.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'derivedFrom') then DerivedFromList.move(source, destination)
  else if (propName = 'resourceTrigger') then ResourceTriggerList.move(source, destination)
  else if (propName = 'eventTrigger') then EventTriggerList.move(source, destination)
  else if (propName = 'canFilterBy') then CanFilterByList.move(source, destination)
  else if (propName = 'notificationShape') then NotificationShapeList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscriptionTopic.fhirType : string;
begin
  result := 'SubscriptionTopic';
end;

function TFhirSubscriptionTopic.Link : TFhirSubscriptionTopic;
begin
  result := TFhirSubscriptionTopic(inherited Link);
end;

function TFhirSubscriptionTopic.Clone : TFhirSubscriptionTopic;
begin
  result := TFhirSubscriptionTopic(inherited Clone);
end;

function TFhirSubscriptionTopic.equals(other : TObject) : boolean; 
var
  o : TFhirSubscriptionTopic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscriptionTopic)) then
    result := false
  else
  begin
    o := TFhirSubscriptionTopic(other);
    result := compareDeep(derivedFromList, o.derivedFromList, true) and compareDeep(approvalDateElement, o.approvalDateElement, true) and 
      compareDeep(lastReviewDateElement, o.lastReviewDateElement, true) and compareDeep(effectivePeriodElement, o.effectivePeriodElement, true) and 
      compareDeep(resourceTriggerList, o.resourceTriggerList, true) and compareDeep(eventTriggerList, o.eventTriggerList, true) and 
      compareDeep(canFilterByList, o.canFilterByList, true) and compareDeep(notificationShapeList, o.notificationShapeList, true);
  end;
end;

function TFhirSubscriptionTopic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FderivedFromList) and isEmptyProp(FApprovalDate) and isEmptyProp(FLastReviewDate) and isEmptyProp(FEffectivePeriod) and isEmptyProp(FresourceTriggerList) and isEmptyProp(FeventTriggerList) and isEmptyProp(FcanFilterByList) and isEmptyProp(FnotificationShapeList);
end;

procedure TFhirSubscriptionTopic.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('title');
  fields.add('derivedFrom');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('copyright');
  fields.add('copyrightLabel');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('resourceTrigger');
  fields.add('eventTrigger');
  fields.add('canFilterBy');
  fields.add('notificationShape');
end;

function TFhirSubscriptionTopic.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FDerivedFromList.sizeInBytes(magic));
  inc(result, FResourceTriggerList.sizeInBytes(magic));
  inc(result, FEventTriggerList.sizeInBytes(magic));
  inc(result, FCanFilterByList.sizeInBytes(magic));
  inc(result, FNotificationShapeList.sizeInBytes(magic));
end;

procedure TFhirSubscriptionTopic.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirSubscriptionTopic.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirSubscriptionTopic.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirSubscriptionTopic.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirSubscriptionTopic.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirSubscriptionTopic.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirSubscriptionTopic.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirSubscriptionTopic.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirSubscriptionTopic.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirSubscriptionTopic.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirSubscriptionTopic.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

function TFhirSubscriptionTopic.GetDerivedFromList : TFhirCanonicalList;
begin
  if FDerivedFromList = nil then
    FDerivedFromList := TFhirCanonicalList.Create;
  result := FDerivedFromList;
end;

function TFhirSubscriptionTopic.GetHasDerivedFromList : boolean;
begin
  result := (FDerivedFromList <> nil) and (FDerivedFromList.count > 0);
end;

procedure TFhirSubscriptionTopic.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirSubscriptionTopic.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirSubscriptionTopic.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirSubscriptionTopic.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirSubscriptionTopic.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirSubscriptionTopic.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirSubscriptionTopic.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirSubscriptionTopic.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirSubscriptionTopic.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirSubscriptionTopic.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirSubscriptionTopic.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirSubscriptionTopic.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirSubscriptionTopic.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirSubscriptionTopic.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirSubscriptionTopic.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirSubscriptionTopic.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirSubscriptionTopic.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirSubscriptionTopic.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirSubscriptionTopic.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirSubscriptionTopic.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirSubscriptionTopic.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirSubscriptionTopic.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirSubscriptionTopic.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirSubscriptionTopic.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirSubscriptionTopic.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirSubscriptionTopic.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirSubscriptionTopic.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

procedure TFhirSubscriptionTopic.SetCopyrightLabel(value : TFhirString);
begin
  FCopyrightLabel.free;
  FCopyrightLabel := value;
end;

function TFhirSubscriptionTopic.GetCopyrightLabelST : String;
begin
  if FCopyrightLabel = nil then
    result := ''
  else
    result := FCopyrightLabel.value;
end;

procedure TFhirSubscriptionTopic.SetCopyrightLabelST(value : String);
begin
  if value <> '' then
  begin
    if FCopyrightLabel = nil then
      FCopyrightLabel := TFhirString.create;
    FCopyrightLabel.value := value
  end
  else if FCopyrightLabel <> nil then
    FCopyrightLabel.value := '';
end;

procedure TFhirSubscriptionTopic.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

function TFhirSubscriptionTopic.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

procedure TFhirSubscriptionTopic.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

procedure TFhirSubscriptionTopic.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

function TFhirSubscriptionTopic.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

procedure TFhirSubscriptionTopic.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

procedure TFhirSubscriptionTopic.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

function TFhirSubscriptionTopic.GetResourceTriggerList : TFhirSubscriptionTopicResourceTriggerList;
begin
  if FResourceTriggerList = nil then
    FResourceTriggerList := TFhirSubscriptionTopicResourceTriggerList.Create;
  result := FResourceTriggerList;
end;

function TFhirSubscriptionTopic.GetHasResourceTriggerList : boolean;
begin
  result := (FResourceTriggerList <> nil) and (FResourceTriggerList.count > 0);
end;

function TFhirSubscriptionTopic.GetEventTriggerList : TFhirSubscriptionTopicEventTriggerList;
begin
  if FEventTriggerList = nil then
    FEventTriggerList := TFhirSubscriptionTopicEventTriggerList.Create;
  result := FEventTriggerList;
end;

function TFhirSubscriptionTopic.GetHasEventTriggerList : boolean;
begin
  result := (FEventTriggerList <> nil) and (FEventTriggerList.count > 0);
end;

function TFhirSubscriptionTopic.GetCanFilterByList : TFhirSubscriptionTopicCanFilterByList;
begin
  if FCanFilterByList = nil then
    FCanFilterByList := TFhirSubscriptionTopicCanFilterByList.Create;
  result := FCanFilterByList;
end;

function TFhirSubscriptionTopic.GetHasCanFilterByList : boolean;
begin
  result := (FCanFilterByList <> nil) and (FCanFilterByList.count > 0);
end;

function TFhirSubscriptionTopic.GetNotificationShapeList : TFhirSubscriptionTopicNotificationShapeList;
begin
  if FNotificationShapeList = nil then
    FNotificationShapeList := TFhirSubscriptionTopicNotificationShapeList.Create;
  result := FNotificationShapeList;
end;

function TFhirSubscriptionTopic.GetHasNotificationShapeList : boolean;
begin
  result := (FNotificationShapeList <> nil) and (FNotificationShapeList.count > 0);
end;

{ TFhirSubscriptionTopicListEnumerator }

constructor TFhirSubscriptionTopicListEnumerator.Create(list : TFhirSubscriptionTopicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionTopicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionTopicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionTopicListEnumerator.GetCurrent : TFhirSubscriptionTopic;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionTopicListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubscriptionTopicList }

function TFhirSubscriptionTopicList.AddItem(value: TFhirSubscriptionTopic): TFhirSubscriptionTopic;
begin
  assert(value.ClassName = 'TFhirSubscriptionTopic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscriptionTopic');
  add(value);
  result := value;
end;

function TFhirSubscriptionTopicList.Append: TFhirSubscriptionTopic;
begin
  result := TFhirSubscriptionTopic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionTopicList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionTopicList.GetEnumerator : TFhirSubscriptionTopicListEnumerator;
begin
  result := TFhirSubscriptionTopicListEnumerator.Create(self.link);
end;

function TFhirSubscriptionTopicList.Clone: TFhirSubscriptionTopicList;
begin
  result := TFhirSubscriptionTopicList(inherited Clone);
end;

function TFhirSubscriptionTopicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionTopicList.GetItemN(index: Integer): TFhirSubscriptionTopic;
begin
  result := TFhirSubscriptionTopic(ObjectByIndex[index]);
end;

function TFhirSubscriptionTopicList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscriptionTopic;
end;
function TFhirSubscriptionTopicList.IndexOf(value: TFhirSubscriptionTopic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionTopicList.Insert(index: Integer): TFhirSubscriptionTopic;
begin
  result := TFhirSubscriptionTopic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionTopicList.InsertItem(index: Integer; value: TFhirSubscriptionTopic);
begin
  assert(value is TFhirSubscriptionTopic);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionTopicList.Item(index: Integer): TFhirSubscriptionTopic;
begin
  result := TFhirSubscriptionTopic(ObjectByIndex[index]);
end;

function TFhirSubscriptionTopicList.Link: TFhirSubscriptionTopicList;
begin
  result := TFhirSubscriptionTopicList(inherited Link);
end;

procedure TFhirSubscriptionTopicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionTopicList.SetItemByIndex(index: Integer; value: TFhirSubscriptionTopic);
begin
  assert(value is TFhirSubscriptionTopic);
  FhirSubscriptionTopics[index] := value;
end;

procedure TFhirSubscriptionTopicList.SetItemN(index: Integer; value: TFhirSubscriptionTopic);
begin
  assert(value is TFhirSubscriptionTopic);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSCRIPTIONTOPIC}
{$IFDEF FHIR_TASK}
{ TFhirTaskRestriction }

constructor TFhirTaskRestriction.Create;
begin
  inherited;
end;

destructor TFhirTaskRestriction.Destroy;
begin
  FRepetitions.free;
  FPeriod.free;
  FRecipientList.Free;
  inherited;
end;

procedure TFhirTaskRestriction.Assign(oSource : TFslObject);
begin
  inherited;
  repetitionsElement := TFhirTaskRestriction(oSource).repetitionsElement.Clone;
  period := TFhirTaskRestriction(oSource).period.Clone;
  if (TFhirTaskRestriction(oSource).FRecipientList = nil) then
  begin
    FRecipientList.free;
    FRecipientList := nil;
  end
  else
  begin
    if FRecipientList = nil then
      FRecipientList := TFhirReferenceList.Create;
    FRecipientList.Assign(TFhirTaskRestriction(oSource).FRecipientList);
  end;
end;

procedure TFhirTaskRestriction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'repetitions') Then
     list.add(self.link, 'repetitions', FRepetitions.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'recipient') Then
    list.addAll(self, 'recipient', FRecipientList);
end;

procedure TFhirTaskRestriction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'repetitions', 'positiveInt', false, TFhirPositiveInt, FRepetitions.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference', true, TFhirReference, FRecipientList.Link));
end;

function TFhirTaskRestriction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'repetitions') then
  begin
    RepetitionsElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    RecipientList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTaskRestriction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'recipient') then RecipientList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirTaskRestriction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'repetitions') then result := TFhirPositiveInt.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'recipient') then result := RecipientList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTaskRestriction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'repetitions') then result := 'positiveInt'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'recipient') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTaskRestriction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'repetitions') then RepetitionsElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'recipient') then deletePropertyValue('recipient', RecipientList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTaskRestriction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'repetitions') then RepetitionsElement := asPositiveInt(new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'recipient') then replacePropertyValue('recipient', RecipientList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTaskRestriction.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'recipient') then RecipientList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTaskRestriction.fhirType : string;
begin
  result := 'Task.restriction';
end;

function TFhirTaskRestriction.Link : TFhirTaskRestriction;
begin
  result := TFhirTaskRestriction(inherited Link);
end;

function TFhirTaskRestriction.Clone : TFhirTaskRestriction;
begin
  result := TFhirTaskRestriction(inherited Clone);
end;

function TFhirTaskRestriction.equals(other : TObject) : boolean; 
var
  o : TFhirTaskRestriction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTaskRestriction)) then
    result := false
  else
  begin
    o := TFhirTaskRestriction(other);
    result := compareDeep(repetitionsElement, o.repetitionsElement, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(recipientList, o.recipientList, true);
  end;
end;

function TFhirTaskRestriction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRepetitions) and isEmptyProp(FPeriod) and isEmptyProp(FrecipientList);
end;

procedure TFhirTaskRestriction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('repetitions');
  fields.add('period');
  fields.add('recipient');
end;

function TFhirTaskRestriction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FRecipientList.sizeInBytes(magic));
end;

procedure TFhirTaskRestriction.SetRepetitions(value : TFhirPositiveInt);
begin
  FRepetitions.free;
  FRepetitions := value;
end;

function TFhirTaskRestriction.GetRepetitionsST : String;
begin
  if FRepetitions = nil then
    result := ''
  else
    result := FRepetitions.value;
end;

procedure TFhirTaskRestriction.SetRepetitionsST(value : String);
begin
  if value <> '' then
  begin
    if FRepetitions = nil then
      FRepetitions := TFhirPositiveInt.create;
    FRepetitions.value := value
  end
  else if FRepetitions <> nil then
    FRepetitions.value := '';
end;

procedure TFhirTaskRestriction.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirTaskRestriction.GetRecipientList : TFhirReferenceList;
begin
  if FRecipientList = nil then
    FRecipientList := TFhirReferenceList.Create;
  result := FRecipientList;
end;

function TFhirTaskRestriction.GetHasRecipientList : boolean;
begin
  result := (FRecipientList <> nil) and (FRecipientList.count > 0);
end;

{ TFhirTaskRestrictionListEnumerator }

constructor TFhirTaskRestrictionListEnumerator.Create(list : TFhirTaskRestrictionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTaskRestrictionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTaskRestrictionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTaskRestrictionListEnumerator.GetCurrent : TFhirTaskRestriction;
begin
  Result := FList[FIndex];
end;

function TFhirTaskRestrictionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTaskRestrictionList }

function TFhirTaskRestrictionList.AddItem(value: TFhirTaskRestriction): TFhirTaskRestriction;
begin
  assert(value.ClassName = 'TFhirTaskRestriction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTaskRestriction');
  add(value);
  result := value;
end;

function TFhirTaskRestrictionList.Append: TFhirTaskRestriction;
begin
  result := TFhirTaskRestriction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskRestrictionList.ClearItems;
begin
  Clear;
end;

function TFhirTaskRestrictionList.GetEnumerator : TFhirTaskRestrictionListEnumerator;
begin
  result := TFhirTaskRestrictionListEnumerator.Create(self.link);
end;

function TFhirTaskRestrictionList.Clone: TFhirTaskRestrictionList;
begin
  result := TFhirTaskRestrictionList(inherited Clone);
end;

function TFhirTaskRestrictionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTaskRestrictionList.GetItemN(index: Integer): TFhirTaskRestriction;
begin
  result := TFhirTaskRestriction(ObjectByIndex[index]);
end;

function TFhirTaskRestrictionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTaskRestriction;
end;
function TFhirTaskRestrictionList.IndexOf(value: TFhirTaskRestriction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTaskRestrictionList.Insert(index: Integer): TFhirTaskRestriction;
begin
  result := TFhirTaskRestriction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskRestrictionList.InsertItem(index: Integer; value: TFhirTaskRestriction);
begin
  assert(value is TFhirTaskRestriction);
  Inherited Insert(index, value);
end;

function TFhirTaskRestrictionList.Item(index: Integer): TFhirTaskRestriction;
begin
  result := TFhirTaskRestriction(ObjectByIndex[index]);
end;

function TFhirTaskRestrictionList.Link: TFhirTaskRestrictionList;
begin
  result := TFhirTaskRestrictionList(inherited Link);
end;

procedure TFhirTaskRestrictionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTaskRestrictionList.SetItemByIndex(index: Integer; value: TFhirTaskRestriction);
begin
  assert(value is TFhirTaskRestriction);
  FhirTaskRestrictions[index] := value;
end;

procedure TFhirTaskRestrictionList.SetItemN(index: Integer; value: TFhirTaskRestriction);
begin
  assert(value is TFhirTaskRestriction);
  ObjectByIndex[index] := value;
end;

{ TFhirTaskInput }

constructor TFhirTaskInput.Create;
begin
  inherited;
end;

destructor TFhirTaskInput.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirTaskInput.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirTaskInput(oSource).type_.Clone;
  value := TFhirTaskInput(oSource).value.Clone;
end;

procedure TFhirTaskInput.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirTaskInput.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|integer64|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|CodeableReference|Coding|ContactPoint|Count|Distanc'+'e|Duration|HumanName|Identifier|Money|Period|Quantity|Range|Ratio|RatioRange|Reference|SampledData|Signature|Timing|ContactDetail|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|'+'UsageContext|Availability|ExtendedContactDetail|Dosage|Meta', false, TFhirDataType, FValue.Link));
end;

function TFhirTaskInput.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Integer64', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'CodeableReference', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'RatioRange', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Availability', 'ExtendedContactDetail', 'Dosage', 'Meta'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTaskInput.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTaskInput.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Integer64', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'CodeableReference', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'RatioRange', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Availability', 'ExtendedContactDetail', 'Dosage', 'Meta'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirTaskInput.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|integer64|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|CodeableReference|Coding|ContactPoint|Count|Distanc'+'e|Duration|HumanName|Identifier|Money|Period|Quantity|Range|Ratio|RatioRange|Reference|SampledData|Signature|Timing|ContactDetail|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|'+'UsageContext|Availability|ExtendedContactDetail|Dosage|Meta'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTaskInput.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Integer64', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'CodeableReference', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'RatioRange', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Availability', 'ExtendedContactDetail', 'Dosage', 'Meta'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTaskInput.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Integer64', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'CodeableReference', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'RatioRange', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Availability', 'ExtendedContactDetail', 'Dosage', 'Meta'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTaskInput.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTaskInput.fhirType : string;
begin
  result := 'Task.input';
end;

function TFhirTaskInput.Link : TFhirTaskInput;
begin
  result := TFhirTaskInput(inherited Link);
end;

function TFhirTaskInput.Clone : TFhirTaskInput;
begin
  result := TFhirTaskInput(inherited Clone);
end;

function TFhirTaskInput.equals(other : TObject) : boolean; 
var
  o : TFhirTaskInput;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTaskInput)) then
    result := false
  else
  begin
    o := TFhirTaskInput(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirTaskInput.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirTaskInput.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirTaskInput.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTaskInput.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirTaskInput.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirTaskInputListEnumerator }

constructor TFhirTaskInputListEnumerator.Create(list : TFhirTaskInputList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTaskInputListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTaskInputListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTaskInputListEnumerator.GetCurrent : TFhirTaskInput;
begin
  Result := FList[FIndex];
end;

function TFhirTaskInputListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTaskInputList }

function TFhirTaskInputList.AddItem(value: TFhirTaskInput): TFhirTaskInput;
begin
  assert(value.ClassName = 'TFhirTaskInput', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTaskInput');
  add(value);
  result := value;
end;

function TFhirTaskInputList.Append: TFhirTaskInput;
begin
  result := TFhirTaskInput.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskInputList.ClearItems;
begin
  Clear;
end;

function TFhirTaskInputList.GetEnumerator : TFhirTaskInputListEnumerator;
begin
  result := TFhirTaskInputListEnumerator.Create(self.link);
end;

function TFhirTaskInputList.Clone: TFhirTaskInputList;
begin
  result := TFhirTaskInputList(inherited Clone);
end;

function TFhirTaskInputList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTaskInputList.GetItemN(index: Integer): TFhirTaskInput;
begin
  result := TFhirTaskInput(ObjectByIndex[index]);
end;

function TFhirTaskInputList.ItemClass: TFslObjectClass;
begin
  result := TFhirTaskInput;
end;
function TFhirTaskInputList.IndexOf(value: TFhirTaskInput): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTaskInputList.Insert(index: Integer): TFhirTaskInput;
begin
  result := TFhirTaskInput.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskInputList.InsertItem(index: Integer; value: TFhirTaskInput);
begin
  assert(value is TFhirTaskInput);
  Inherited Insert(index, value);
end;

function TFhirTaskInputList.Item(index: Integer): TFhirTaskInput;
begin
  result := TFhirTaskInput(ObjectByIndex[index]);
end;

function TFhirTaskInputList.Link: TFhirTaskInputList;
begin
  result := TFhirTaskInputList(inherited Link);
end;

procedure TFhirTaskInputList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTaskInputList.SetItemByIndex(index: Integer; value: TFhirTaskInput);
begin
  assert(value is TFhirTaskInput);
  FhirTaskInputs[index] := value;
end;

procedure TFhirTaskInputList.SetItemN(index: Integer; value: TFhirTaskInput);
begin
  assert(value is TFhirTaskInput);
  ObjectByIndex[index] := value;
end;

{ TFhirTaskOutput }

constructor TFhirTaskOutput.Create;
begin
  inherited;
end;

destructor TFhirTaskOutput.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirTaskOutput.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirTaskOutput(oSource).type_.Clone;
  value := TFhirTaskOutput(oSource).value.Clone;
end;

procedure TFhirTaskOutput.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirTaskOutput.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|integer64|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|CodeableReference|Coding|ContactPoint|Count|Distanc'+'e|Duration|HumanName|Identifier|Money|Period|Quantity|Range|Ratio|RatioRange|Reference|SampledData|Signature|Timing|ContactDetail|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|'+'UsageContext|Availability|ExtendedContactDetail|Dosage|Meta', false, TFhirDataType, FValue.Link));
end;

function TFhirTaskOutput.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Integer64', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'CodeableReference', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'RatioRange', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Availability', 'ExtendedContactDetail', 'Dosage', 'Meta'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTaskOutput.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTaskOutput.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Integer64', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'CodeableReference', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'RatioRange', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Availability', 'ExtendedContactDetail', 'Dosage', 'Meta'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirTaskOutput.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|integer64|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|CodeableReference|Coding|ContactPoint|Count|Distanc'+'e|Duration|HumanName|Identifier|Money|Period|Quantity|Range|Ratio|RatioRange|Reference|SampledData|Signature|Timing|ContactDetail|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|'+'UsageContext|Availability|ExtendedContactDetail|Dosage|Meta'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTaskOutput.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Integer64', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'CodeableReference', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'RatioRange', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Availability', 'ExtendedContactDetail', 'Dosage', 'Meta'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTaskOutput.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Integer64', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'CodeableReference', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'RatioRange', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Availability', 'ExtendedContactDetail', 'Dosage', 'Meta'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTaskOutput.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTaskOutput.fhirType : string;
begin
  result := 'Task.output';
end;

function TFhirTaskOutput.Link : TFhirTaskOutput;
begin
  result := TFhirTaskOutput(inherited Link);
end;

function TFhirTaskOutput.Clone : TFhirTaskOutput;
begin
  result := TFhirTaskOutput(inherited Clone);
end;

function TFhirTaskOutput.equals(other : TObject) : boolean; 
var
  o : TFhirTaskOutput;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTaskOutput)) then
    result := false
  else
  begin
    o := TFhirTaskOutput(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirTaskOutput.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirTaskOutput.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirTaskOutput.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTaskOutput.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirTaskOutput.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirTaskOutputListEnumerator }

constructor TFhirTaskOutputListEnumerator.Create(list : TFhirTaskOutputList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTaskOutputListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTaskOutputListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTaskOutputListEnumerator.GetCurrent : TFhirTaskOutput;
begin
  Result := FList[FIndex];
end;

function TFhirTaskOutputListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTaskOutputList }

function TFhirTaskOutputList.AddItem(value: TFhirTaskOutput): TFhirTaskOutput;
begin
  assert(value.ClassName = 'TFhirTaskOutput', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTaskOutput');
  add(value);
  result := value;
end;

function TFhirTaskOutputList.Append: TFhirTaskOutput;
begin
  result := TFhirTaskOutput.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskOutputList.ClearItems;
begin
  Clear;
end;

function TFhirTaskOutputList.GetEnumerator : TFhirTaskOutputListEnumerator;
begin
  result := TFhirTaskOutputListEnumerator.Create(self.link);
end;

function TFhirTaskOutputList.Clone: TFhirTaskOutputList;
begin
  result := TFhirTaskOutputList(inherited Clone);
end;

function TFhirTaskOutputList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTaskOutputList.GetItemN(index: Integer): TFhirTaskOutput;
begin
  result := TFhirTaskOutput(ObjectByIndex[index]);
end;

function TFhirTaskOutputList.ItemClass: TFslObjectClass;
begin
  result := TFhirTaskOutput;
end;
function TFhirTaskOutputList.IndexOf(value: TFhirTaskOutput): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTaskOutputList.Insert(index: Integer): TFhirTaskOutput;
begin
  result := TFhirTaskOutput.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskOutputList.InsertItem(index: Integer; value: TFhirTaskOutput);
begin
  assert(value is TFhirTaskOutput);
  Inherited Insert(index, value);
end;

function TFhirTaskOutputList.Item(index: Integer): TFhirTaskOutput;
begin
  result := TFhirTaskOutput(ObjectByIndex[index]);
end;

function TFhirTaskOutputList.Link: TFhirTaskOutputList;
begin
  result := TFhirTaskOutputList(inherited Link);
end;

procedure TFhirTaskOutputList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTaskOutputList.SetItemByIndex(index: Integer; value: TFhirTaskOutput);
begin
  assert(value is TFhirTaskOutput);
  FhirTaskOutputs[index] := value;
end;

procedure TFhirTaskOutputList.SetItemN(index: Integer; value: TFhirTaskOutput);
begin
  assert(value is TFhirTaskOutput);
  ObjectByIndex[index] := value;
end;

{ TFhirTask }

constructor TFhirTask.Create;
begin
  inherited;
end;

destructor TFhirTask.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesCanonical.free;
  FInstantiatesUri.free;
  FBasedOnList.Free;
  FGroupIdentifier.free;
  FPartOfList.Free;
  FStatus.free;
  FStatusReason.free;
  FBusinessStatus.free;
  FIntent.free;
  FPriority.free;
  FDoNotPerform.free;
  FCode.free;
  FDescription.free;
  FFocus.free;
  FFor_.free;
  FEncounter.free;
  FRequestedPeriod.free;
  FExecutionPeriod.free;
  FAuthoredOn.free;
  FLastModified.free;
  FRequester.free;
  FRequestedPerformerList.Free;
  FOwner.free;
  FLocation.free;
  FReasonList.Free;
  FInsuranceList.Free;
  FNoteList.Free;
  FRelevantHistoryList.Free;
  FRestriction.free;
  FInputList.Free;
  FOutputList.Free;
  inherited;
end;

procedure TFhirTask.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirTask(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirTask(oSource).FIdentifierList);
  end;
  instantiatesCanonicalElement := TFhirTask(oSource).instantiatesCanonicalElement.Clone;
  instantiatesUriElement := TFhirTask(oSource).instantiatesUriElement.Clone;
  if (TFhirTask(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirTask(oSource).FBasedOnList);
  end;
  groupIdentifier := TFhirTask(oSource).groupIdentifier.Clone;
  if (TFhirTask(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirTask(oSource).FPartOfList);
  end;
  statusElement := TFhirTask(oSource).statusElement.Clone;
  statusReason := TFhirTask(oSource).statusReason.Clone;
  businessStatus := TFhirTask(oSource).businessStatus.Clone;
  intentElement := TFhirTask(oSource).intentElement.Clone;
  priorityElement := TFhirTask(oSource).priorityElement.Clone;
  doNotPerformElement := TFhirTask(oSource).doNotPerformElement.Clone;
  code := TFhirTask(oSource).code.Clone;
  descriptionElement := TFhirTask(oSource).descriptionElement.Clone;
  focus := TFhirTask(oSource).focus.Clone;
  for_ := TFhirTask(oSource).for_.Clone;
  encounter := TFhirTask(oSource).encounter.Clone;
  requestedPeriod := TFhirTask(oSource).requestedPeriod.Clone;
  executionPeriod := TFhirTask(oSource).executionPeriod.Clone;
  authoredOnElement := TFhirTask(oSource).authoredOnElement.Clone;
  lastModifiedElement := TFhirTask(oSource).lastModifiedElement.Clone;
  requester := TFhirTask(oSource).requester.Clone;
  if (TFhirTask(oSource).FRequestedPerformerList = nil) then
  begin
    FRequestedPerformerList.free;
    FRequestedPerformerList := nil;
  end
  else
  begin
    if FRequestedPerformerList = nil then
      FRequestedPerformerList := TFhirCodeableReferenceList.Create;
    FRequestedPerformerList.Assign(TFhirTask(oSource).FRequestedPerformerList);
  end;
  owner := TFhirTask(oSource).owner.Clone;
  location := TFhirTask(oSource).location.Clone;
  if (TFhirTask(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableReferenceList.Create;
    FReasonList.Assign(TFhirTask(oSource).FReasonList);
  end;
  if (TFhirTask(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirReferenceList.Create;
    FInsuranceList.Assign(TFhirTask(oSource).FInsuranceList);
  end;
  if (TFhirTask(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirTask(oSource).FNoteList);
  end;
  if (TFhirTask(oSource).FRelevantHistoryList = nil) then
  begin
    FRelevantHistoryList.free;
    FRelevantHistoryList := nil;
  end
  else
  begin
    if FRelevantHistoryList = nil then
      FRelevantHistoryList := TFhirReferenceList.Create;
    FRelevantHistoryList.Assign(TFhirTask(oSource).FRelevantHistoryList);
  end;
  restriction := TFhirTask(oSource).restriction.Clone;
  if (TFhirTask(oSource).FInputList = nil) then
  begin
    FInputList.free;
    FInputList := nil;
  end
  else
  begin
    if FInputList = nil then
      FInputList := TFhirTaskInputList.Create;
    FInputList.Assign(TFhirTask(oSource).FInputList);
  end;
  if (TFhirTask(oSource).FOutputList = nil) then
  begin
    FOutputList.free;
    FOutputList := nil;
  end
  else
  begin
    if FOutputList = nil then
      FOutputList := TFhirTaskOutputList.Create;
    FOutputList.Assign(TFhirTask(oSource).FOutputList);
  end;
end;

function TFhirTask.GetResourceType : TFhirResourceType;
begin
  result := frtTask;
end;

procedure TFhirTask.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiatesCanonical') Then
     list.add(self.link, 'instantiatesCanonical', FInstantiatesCanonical.Link);
  if (child_name = 'instantiatesUri') Then
     list.add(self.link, 'instantiatesUri', FInstantiatesUri.Link);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'groupIdentifier') Then
     list.add(self.link, 'groupIdentifier', FGroupIdentifier.Link);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason', FStatusReason.Link);
  if (child_name = 'businessStatus') Then
     list.add(self.link, 'businessStatus', FBusinessStatus.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'doNotPerform') Then
     list.add(self.link, 'doNotPerform', FDoNotPerform.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'focus') Then
     list.add(self.link, 'focus', FFocus.Link);
  if (child_name = 'for') Then
     list.add(self.link, 'for', FFor_.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'requestedPeriod') Then
     list.add(self.link, 'requestedPeriod', FRequestedPeriod.Link);
  if (child_name = 'executionPeriod') Then
     list.add(self.link, 'executionPeriod', FExecutionPeriod.Link);
  if (child_name = 'authoredOn') Then
     list.add(self.link, 'authoredOn', FAuthoredOn.Link);
  if (child_name = 'lastModified') Then
     list.add(self.link, 'lastModified', FLastModified.Link);
  if (child_name = 'requester') Then
     list.add(self.link, 'requester', FRequester.Link);
  if (child_name = 'requestedPerformer') Then
    list.addAll(self, 'requestedPerformer', FRequestedPerformerList);
  if (child_name = 'owner') Then
     list.add(self.link, 'owner', FOwner.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'relevantHistory') Then
    list.addAll(self, 'relevantHistory', FRelevantHistoryList);
  if (child_name = 'restriction') Then
     list.add(self.link, 'restriction', FRestriction.Link);
  if (child_name = 'input') Then
    list.addAll(self, 'input', FInputList);
  if (child_name = 'output') Then
    list.addAll(self, 'output', FOutputList);
end;

procedure TFhirTask.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', false, TFhirCanonical, FInstantiatesCanonical.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', false, TFhirUri, FInstantiatesUri.Link));
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.create(self, 'groupIdentifier', 'Identifier', false, TFhirIdentifier, FGroupIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableReference', false, TFhirCodeableReference, FStatusReason.Link));
  oList.add(TFHIRProperty.create(self, 'businessStatus', 'CodeableConcept', false, TFhirCodeableConcept, FBusinessStatus.Link));
  oList.add(TFHIRProperty.create(self, 'intent', 'code', false, TFhirEnum, FIntent.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFhirEnum, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'doNotPerform', 'boolean', false, TFhirBoolean, FDoNotPerform.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'focus', 'Reference', false, TFhirReference, FFocus.Link));
  oList.add(TFHIRProperty.create(self, 'for', 'Reference', false, TFhirReference, FFor_.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'requestedPeriod', 'Period', false, TFhirPeriod, FRequestedPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'executionPeriod', 'Period', false, TFhirPeriod, FExecutionPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'authoredOn', 'dateTime', false, TFhirDateTime, FAuthoredOn.Link));
  oList.add(TFHIRProperty.create(self, 'lastModified', 'dateTime', false, TFhirDateTime, FLastModified.Link));
  oList.add(TFHIRProperty.create(self, 'requester', 'Reference', false, TFhirReference, FRequester.Link));
  oList.add(TFHIRProperty.create(self, 'requestedPerformer', 'CodeableReference', true, TFhirCodeableReference, FRequestedPerformerList.Link));
  oList.add(TFHIRProperty.create(self, 'owner', 'Reference', false, TFhirReference, FOwner.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableReference', true, TFhirCodeableReference, FReasonList.Link));
  oList.add(TFHIRProperty.create(self, 'insurance', 'Reference', true, TFhirReference, FInsuranceList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'relevantHistory', 'Reference', true, TFhirReference, FRelevantHistoryList.Link));
  oList.add(TFHIRProperty.create(self, 'restriction', 'BackboneElement', false, TFhirTaskRestriction, FRestriction.Link));
  oList.add(TFHIRProperty.create(self, 'input', 'BackboneElement', true, TFhirTaskInput, FInputList.Link));
  oList.add(TFHIRProperty.create(self, 'output', 'BackboneElement', true, TFhirTaskOutput, FOutputList.Link));
end;

function TFhirTask.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'groupIdentifier') then
  begin
    GroupIdentifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirTaskStatusEnum, CODES_TFhirTaskStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReason := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'businessStatus') then
  begin
    BusinessStatus := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'intent') then
  begin
    IntentElement := asEnum(SYSTEMS_TFhirTaskIntentEnum, CODES_TFhirTaskIntentEnum, propValue);
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue;
  end
  else if (propName = 'doNotPerform') then
  begin
    DoNotPerformElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'focus') then
  begin
    Focus := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'for') then
  begin
    For_ := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'requestedPeriod') then
  begin
    RequestedPeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'executionPeriod') then
  begin
    ExecutionPeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'authoredOn') then
  begin
    AuthoredOnElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'lastModified') then
  begin
    LastModifiedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    Requester := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'requestedPerformer') then
  begin
    RequestedPerformerList.add(propValue as TFhirCodeableReference);
    result := propValue;
  end
  else if (propName = 'owner') then
  begin
    Owner := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableReference);
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'relevantHistory') then
  begin
    RelevantHistoryList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'restriction') then
  begin
    Restriction := propValue as TFhirTaskRestriction;
    result := propValue;
  end
  else if (propName = 'input') then
  begin
    InputList.add(propValue as TFhirTaskInput);
    result := propValue;
  end
  else if (propName = 'output') then
  begin
    OutputList.add(propValue as TFhirTaskOutput);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTask.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'requestedPerformer') then RequestedPerformerList.insertItem(index, propValue as TFhirCodeableReference)
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableReference)
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'relevantHistory') then RelevantHistoryList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'input') then InputList.insertItem(index, propValue as TFhirTaskInput)
  else if (propName = 'output') then OutputList.insertItem(index, propValue as TFhirTaskOutput)
  else inherited;
end;

function TFhirTask.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'instantiatesCanonical') then result := TFhirCanonical.create()
  else if (propName = 'instantiatesUri') then result := TFhirUri.create()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'groupIdentifier') then result := TFhirIdentifier.create()
  else if (propName = 'partOf') then result := PartOfList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirTaskStatusEnum[TaskStatusNull], CODES_TFhirTaskStatusEnum[TaskStatusNull]) 
  else if (propName = 'statusReason') then result := TFhirCodeableReference.create()
  else if (propName = 'businessStatus') then result := TFhirCodeableConcept.create()
  else if (propName = 'intent') then result := TFhirEnum.create(SYSTEMS_TFhirTaskIntentEnum[TaskIntentNull], CODES_TFhirTaskIntentEnum[TaskIntentNull]) 
  else if (propName = 'priority') then result := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[RequestPriorityNull], CODES_TFhirRequestPriorityEnum[RequestPriorityNull]) 
  else if (propName = 'doNotPerform') then result := TFhirBoolean.create()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'focus') then result := TFhirReference.create()
  else if (propName = 'for') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (propName = 'requestedPeriod') then result := TFhirPeriod.create()
  else if (propName = 'executionPeriod') then result := TFhirPeriod.create()
  else if (propName = 'authoredOn') then result := TFhirDateTime.create()
  else if (propName = 'lastModified') then result := TFhirDateTime.create()
  else if (propName = 'requester') then result := TFhirReference.create()
  else if (propName = 'requestedPerformer') then result := RequestedPerformerList.new()
  else if (propName = 'owner') then result := TFhirReference.create()
  else if (propName = 'location') then result := TFhirReference.create()
  else if (propName = 'reason') then result := ReasonList.new()
  else if (propName = 'insurance') then result := InsuranceList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'relevantHistory') then result := RelevantHistoryList.new()
  else if (propName = 'restriction') then result := TFhirTaskRestriction.create()
  else if (propName = 'input') then result := InputList.new()
  else if (propName = 'output') then result := OutputList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTask.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'groupIdentifier') then result := 'Identifier'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableReference'
  else if (propName = 'businessStatus') then result := 'CodeableConcept'
  else if (propName = 'intent') then result := 'code'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'doNotPerform') then result := 'boolean'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'focus') then result := 'Reference'
  else if (propName = 'for') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'requestedPeriod') then result := 'Period'
  else if (propName = 'executionPeriod') then result := 'Period'
  else if (propName = 'authoredOn') then result := 'dateTime'
  else if (propName = 'lastModified') then result := 'dateTime'
  else if (propName = 'requester') then result := 'Reference'
  else if (propName = 'requestedPerformer') then result := 'CodeableReference'
  else if (propName = 'owner') then result := 'Reference'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'reason') then result := 'CodeableReference'
  else if (propName = 'insurance') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'relevantHistory') then result := 'Reference'
  else if (propName = 'restriction') then result := 'BackboneElement'
  else if (propName = 'input') then result := 'BackboneElement'
  else if (propName = 'output') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTask.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalElement := nil
  else if (propName = 'instantiatesUri') then InstantiatesUriElement := nil
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := nil
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then StatusReasonElement := nil
  else if (propName = 'businessStatus') then BusinessStatusElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'doNotPerform') then DoNotPerformElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'focus') then FocusElement := nil
  else if (propName = 'for') then For_Element := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'requestedPeriod') then RequestedPeriodElement := nil
  else if (propName = 'executionPeriod') then ExecutionPeriodElement := nil
  else if (propName = 'authoredOn') then AuthoredOnElement := nil
  else if (propName = 'lastModified') then LastModifiedElement := nil
  else if (propName = 'requester') then RequesterElement := nil
  else if (propName = 'requestedPerformer') then deletePropertyValue('requestedPerformer', RequestedPerformerList, value)
  else if (propName = 'owner') then OwnerElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value)
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'relevantHistory') then deletePropertyValue('relevantHistory', RelevantHistoryList, value)
  else if (propName = 'restriction') then RestrictionElement := nil
  else if (propName = 'input') then deletePropertyValue('input', InputList, value)
  else if (propName = 'output') then deletePropertyValue('output', OutputList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTask.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalElement := asCanonical(new)
  else if (propName = 'instantiatesUri') then InstantiatesUriElement := asUri(new)
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := new as TFhirIdentifier
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirTaskStatusEnum, CODES_TFhirTaskStatusEnum, new)
  else if (propName = 'statusReason') then StatusReasonElement := new as TFhirCodeableReference
  else if (propName = 'businessStatus') then BusinessStatusElement := new as TFhirCodeableConcept
  else if (propName = 'intent') then IntentElement := asEnum(SYSTEMS_TFhirTaskIntentEnum, CODES_TFhirTaskIntentEnum, new)
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new)
  else if (propName = 'doNotPerform') then DoNotPerformElement := asBoolean(new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'focus') then FocusElement := new as TFhirReference
  else if (propName = 'for') then For_Element := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (propName = 'requestedPeriod') then RequestedPeriodElement := new as TFhirPeriod
  else if (propName = 'executionPeriod') then ExecutionPeriodElement := new as TFhirPeriod
  else if (propName = 'authoredOn') then AuthoredOnElement := asDateTime(new)
  else if (propName = 'lastModified') then LastModifiedElement := asDateTime(new)
  else if (propName = 'requester') then RequesterElement := new as TFhirReference
  else if (propName = 'requestedPerformer') then replacePropertyValue('requestedPerformer', RequestedPerformerList, existing, new)
  else if (propName = 'owner') then OwnerElement := new as TFhirReference
  else if (propName = 'location') then LocationElement := new as TFhirReference
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new)
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'relevantHistory') then replacePropertyValue('relevantHistory', RelevantHistoryList, existing, new)
  else if (propName = 'restriction') then RestrictionElement := new as TFhirTaskRestriction
  else if (propName = 'input') then replacePropertyValue('input', InputList, existing, new)
  else if (propName = 'output') then replacePropertyValue('output', OutputList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTask.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'partOf') then PartOfList.move(source, destination)
  else if (propName = 'requestedPerformer') then RequestedPerformerList.move(source, destination)
  else if (propName = 'reason') then ReasonList.move(source, destination)
  else if (propName = 'insurance') then InsuranceList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'relevantHistory') then RelevantHistoryList.move(source, destination)
  else if (propName = 'input') then InputList.move(source, destination)
  else if (propName = 'output') then OutputList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTask.fhirType : string;
begin
  result := 'Task';
end;

function TFhirTask.Link : TFhirTask;
begin
  result := TFhirTask(inherited Link);
end;

function TFhirTask.Clone : TFhirTask;
begin
  result := TFhirTask(inherited Clone);
end;

function TFhirTask.equals(other : TObject) : boolean; 
var
  o : TFhirTask;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTask)) then
    result := false
  else
  begin
    o := TFhirTask(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesCanonicalElement, o.instantiatesCanonicalElement, true) and 
      compareDeep(instantiatesUriElement, o.instantiatesUriElement, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(groupIdentifierElement, o.groupIdentifierElement, true) and compareDeep(partOfList, o.partOfList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(statusReasonElement, o.statusReasonElement, true) and 
      compareDeep(businessStatusElement, o.businessStatusElement, true) and compareDeep(intentElement, o.intentElement, true) and 
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(doNotPerformElement, o.doNotPerformElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(focusElement, o.focusElement, true) and compareDeep(for_Element, o.for_Element, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(requestedPeriodElement, o.requestedPeriodElement, true) and 
      compareDeep(executionPeriodElement, o.executionPeriodElement, true) and compareDeep(authoredOnElement, o.authoredOnElement, true) and 
      compareDeep(lastModifiedElement, o.lastModifiedElement, true) and compareDeep(requesterElement, o.requesterElement, true) and 
      compareDeep(requestedPerformerList, o.requestedPerformerList, true) and compareDeep(ownerElement, o.ownerElement, true) and 
      compareDeep(locationElement, o.locationElement, true) and compareDeep(reasonList, o.reasonList, true) and 
      compareDeep(insuranceList, o.insuranceList, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(relevantHistoryList, o.relevantHistoryList, true) and compareDeep(restrictionElement, o.restrictionElement, true) and 
      compareDeep(inputList, o.inputList, true) and compareDeep(outputList, o.outputList, true);
  end;
end;

function TFhirTask.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FInstantiatesCanonical) and isEmptyProp(FInstantiatesUri) and isEmptyProp(FbasedOnList) and isEmptyProp(FGroupIdentifier) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FStatusReason) and isEmptyProp(FBusinessStatus) and isEmptyProp(FIntent) and isEmptyProp(FPriority) and isEmptyProp(FDoNotPerform) and isEmptyProp(FCode) and isEmptyProp(FDescription) and isEmptyProp(FFocus) and isEmptyProp(FFor_) and isEmptyProp(FEncounter) and isEmptyProp(FRequestedPeriod) and isEmptyProp(FExecutionPeriod) and isEmptyProp(FAuthoredOn) and isEmptyProp(FLastModified) and isEmptyProp(FRequester) and isEmptyProp(FrequestedPerformerList) and isEmptyProp(FOwner) and isEmptyProp(FLocation) and isEmptyProp(FreasonList) and isEmptyProp(FinsuranceList) and isEmptyProp(FnoteList) and isEmptyProp(FrelevantHistoryList) and isEmptyProp(FRestriction) and isEmptyProp(FinputList) and isEmptyProp(FoutputList);
end;

procedure TFhirTask.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('basedOn');
  fields.add('groupIdentifier');
  fields.add('partOf');
  fields.add('status');
  fields.add('statusReason');
  fields.add('businessStatus');
  fields.add('intent');
  fields.add('priority');
  fields.add('doNotPerform');
  fields.add('code');
  fields.add('description');
  fields.add('focus');
  fields.add('for');
  fields.add('encounter');
  fields.add('requestedPeriod');
  fields.add('executionPeriod');
  fields.add('authoredOn');
  fields.add('lastModified');
  fields.add('requester');
  fields.add('requestedPerformer');
  fields.add('owner');
  fields.add('location');
  fields.add('reason');
  fields.add('insurance');
  fields.add('note');
  fields.add('relevantHistory');
  fields.add('restriction');
  fields.add('input');
  fields.add('output');
end;

function TFhirTask.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FPartOfList.sizeInBytes(magic));
  inc(result, FRequestedPerformerList.sizeInBytes(magic));
  inc(result, FReasonList.sizeInBytes(magic));
  inc(result, FInsuranceList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FRelevantHistoryList.sizeInBytes(magic));
  inc(result, FInputList.sizeInBytes(magic));
  inc(result, FOutputList.sizeInBytes(magic));
end;

function TFhirTask.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirTask.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirTask.SetInstantiatesCanonical(value : TFhirCanonical);
begin
  FInstantiatesCanonical.free;
  FInstantiatesCanonical := value;
end;

function TFhirTask.GetInstantiatesCanonicalST : String;
begin
  if FInstantiatesCanonical = nil then
    result := ''
  else
    result := FInstantiatesCanonical.value;
end;

procedure TFhirTask.SetInstantiatesCanonicalST(value : String);
begin
  if value <> '' then
  begin
    if FInstantiatesCanonical = nil then
      FInstantiatesCanonical := TFhirCanonical.create;
    FInstantiatesCanonical.value := value
  end
  else if FInstantiatesCanonical <> nil then
    FInstantiatesCanonical.value := '';
end;

procedure TFhirTask.SetInstantiatesUri(value : TFhirUri);
begin
  FInstantiatesUri.free;
  FInstantiatesUri := value;
end;

function TFhirTask.GetInstantiatesUriST : String;
begin
  if FInstantiatesUri = nil then
    result := ''
  else
    result := FInstantiatesUri.value;
end;

procedure TFhirTask.SetInstantiatesUriST(value : String);
begin
  if value <> '' then
  begin
    if FInstantiatesUri = nil then
      FInstantiatesUri := TFhirUri.create;
    FInstantiatesUri.value := value
  end
  else if FInstantiatesUri <> nil then
    FInstantiatesUri.value := '';
end;

function TFhirTask.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirTask.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

procedure TFhirTask.SetGroupIdentifier(value : TFhirIdentifier);
begin
  FGroupIdentifier.free;
  FGroupIdentifier := value;
end;

function TFhirTask.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirTask.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

procedure TFhirTask.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirTask.GetStatusST : TFhirTaskStatusEnum;
begin
  if FStatus = nil then
    result := TFhirTaskStatusEnum(0)
  else
    result := TFhirTaskStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirTaskStatusEnum, FStatus.value));
end;

procedure TFhirTask.SetStatusST(value : TFhirTaskStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirTaskStatusEnum[value], CODES_TFhirTaskStatusEnum[value]);
end;

procedure TFhirTask.SetStatusReason(value : TFhirCodeableReference);
begin
  FStatusReason.free;
  FStatusReason := value;
end;

procedure TFhirTask.SetBusinessStatus(value : TFhirCodeableConcept);
begin
  FBusinessStatus.free;
  FBusinessStatus := value;
end;

procedure TFhirTask.SetIntent(value : TFhirEnum);
begin
  FIntent.free;
  FIntent := value;
end;

function TFhirTask.GetIntentST : TFhirTaskIntentEnum;
begin
  if FIntent = nil then
    result := TFhirTaskIntentEnum(0)
  else
    result := TFhirTaskIntentEnum(StringArrayIndexOfSensitive(CODES_TFhirTaskIntentEnum, FIntent.value));
end;

procedure TFhirTask.SetIntentST(value : TFhirTaskIntentEnum);
begin
  if ord(value) = 0 then
    IntentElement := nil
  else
    IntentElement := TFhirEnum.create(SYSTEMS_TFhirTaskIntentEnum[value], CODES_TFhirTaskIntentEnum[value]);
end;

procedure TFhirTask.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirTask.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

procedure TFhirTask.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

procedure TFhirTask.SetDoNotPerform(value : TFhirBoolean);
begin
  FDoNotPerform.free;
  FDoNotPerform := value;
end;

function TFhirTask.GetDoNotPerformST : Boolean;
begin
  if FDoNotPerform = nil then
    result := false
  else
    result := FDoNotPerform.value;
end;

procedure TFhirTask.SetDoNotPerformST(value : Boolean);
begin
  if FDoNotPerform = nil then
    FDoNotPerform := TFhirBoolean.create;
  FDoNotPerform.value := value
end;

procedure TFhirTask.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirTask.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirTask.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirTask.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirTask.SetFocus(value : TFhirReference);
begin
  FFocus.free;
  FFocus := value;
end;

procedure TFhirTask.SetFor_(value : TFhirReference);
begin
  FFor_.free;
  FFor_ := value;
end;

procedure TFhirTask.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirTask.SetRequestedPeriod(value : TFhirPeriod);
begin
  FRequestedPeriod.free;
  FRequestedPeriod := value;
end;

procedure TFhirTask.SetExecutionPeriod(value : TFhirPeriod);
begin
  FExecutionPeriod.free;
  FExecutionPeriod := value;
end;

procedure TFhirTask.SetAuthoredOn(value : TFhirDateTime);
begin
  FAuthoredOn.free;
  FAuthoredOn := value;
end;

function TFhirTask.GetAuthoredOnST : TFslDateTime;
begin
  if FAuthoredOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoredOn.value;
end;

procedure TFhirTask.SetAuthoredOnST(value : TFslDateTime);
begin
  if FAuthoredOn = nil then
    FAuthoredOn := TFhirDateTime.create;
  FAuthoredOn.value := value
end;

procedure TFhirTask.SetLastModified(value : TFhirDateTime);
begin
  FLastModified.free;
  FLastModified := value;
end;

function TFhirTask.GetLastModifiedST : TFslDateTime;
begin
  if FLastModified = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastModified.value;
end;

procedure TFhirTask.SetLastModifiedST(value : TFslDateTime);
begin
  if FLastModified = nil then
    FLastModified := TFhirDateTime.create;
  FLastModified.value := value
end;

procedure TFhirTask.SetRequester(value : TFhirReference);
begin
  FRequester.free;
  FRequester := value;
end;

function TFhirTask.GetRequestedPerformerList : TFhirCodeableReferenceList;
begin
  if FRequestedPerformerList = nil then
    FRequestedPerformerList := TFhirCodeableReferenceList.Create;
  result := FRequestedPerformerList;
end;

function TFhirTask.GetHasRequestedPerformerList : boolean;
begin
  result := (FRequestedPerformerList <> nil) and (FRequestedPerformerList.count > 0);
end;

procedure TFhirTask.SetOwner(value : TFhirReference);
begin
  FOwner.free;
  FOwner := value;
end;

procedure TFhirTask.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value;
end;

function TFhirTask.GetReasonList : TFhirCodeableReferenceList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableReferenceList.Create;
  result := FReasonList;
end;

function TFhirTask.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirTask.GetInsuranceList : TFhirReferenceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirReferenceList.Create;
  result := FInsuranceList;
end;

function TFhirTask.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

function TFhirTask.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirTask.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirTask.GetRelevantHistoryList : TFhirReferenceList;
begin
  if FRelevantHistoryList = nil then
    FRelevantHistoryList := TFhirReferenceList.Create;
  result := FRelevantHistoryList;
end;

function TFhirTask.GetHasRelevantHistoryList : boolean;
begin
  result := (FRelevantHistoryList <> nil) and (FRelevantHistoryList.count > 0);
end;

procedure TFhirTask.SetRestriction(value : TFhirTaskRestriction);
begin
  FRestriction.free;
  FRestriction := value;
end;

function TFhirTask.GetInputList : TFhirTaskInputList;
begin
  if FInputList = nil then
    FInputList := TFhirTaskInputList.Create;
  result := FInputList;
end;

function TFhirTask.GetHasInputList : boolean;
begin
  result := (FInputList <> nil) and (FInputList.count > 0);
end;

function TFhirTask.GetOutputList : TFhirTaskOutputList;
begin
  if FOutputList = nil then
    FOutputList := TFhirTaskOutputList.Create;
  result := FOutputList;
end;

function TFhirTask.GetHasOutputList : boolean;
begin
  result := (FOutputList <> nil) and (FOutputList.count > 0);
end;

{ TFhirTaskListEnumerator }

constructor TFhirTaskListEnumerator.Create(list : TFhirTaskList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTaskListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTaskListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTaskListEnumerator.GetCurrent : TFhirTask;
begin
  Result := FList[FIndex];
end;

function TFhirTaskListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTaskList }

function TFhirTaskList.AddItem(value: TFhirTask): TFhirTask;
begin
  assert(value.ClassName = 'TFhirTask', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTask');
  add(value);
  result := value;
end;

function TFhirTaskList.Append: TFhirTask;
begin
  result := TFhirTask.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskList.ClearItems;
begin
  Clear;
end;

function TFhirTaskList.GetEnumerator : TFhirTaskListEnumerator;
begin
  result := TFhirTaskListEnumerator.Create(self.link);
end;

function TFhirTaskList.Clone: TFhirTaskList;
begin
  result := TFhirTaskList(inherited Clone);
end;

function TFhirTaskList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTaskList.GetItemN(index: Integer): TFhirTask;
begin
  result := TFhirTask(ObjectByIndex[index]);
end;

function TFhirTaskList.ItemClass: TFslObjectClass;
begin
  result := TFhirTask;
end;
function TFhirTaskList.IndexOf(value: TFhirTask): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTaskList.Insert(index: Integer): TFhirTask;
begin
  result := TFhirTask.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskList.InsertItem(index: Integer; value: TFhirTask);
begin
  assert(value is TFhirTask);
  Inherited Insert(index, value);
end;

function TFhirTaskList.Item(index: Integer): TFhirTask;
begin
  result := TFhirTask(ObjectByIndex[index]);
end;

function TFhirTaskList.Link: TFhirTaskList;
begin
  result := TFhirTaskList(inherited Link);
end;

procedure TFhirTaskList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTaskList.SetItemByIndex(index: Integer; value: TFhirTask);
begin
  assert(value is TFhirTask);
  FhirTasks[index] := value;
end;

procedure TFhirTaskList.SetItemN(index: Integer; value: TFhirTask);
begin
  assert(value is TFhirTask);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TESTREPORT}
{ TFhirTestReportParticipant }

constructor TFhirTestReportParticipant.Create;
begin
  inherited;
end;

destructor TFhirTestReportParticipant.Destroy;
begin
  FType_.free;
  FUri.free;
  FDisplay.free;
  inherited;
end;

procedure TFhirTestReportParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirTestReportParticipant(oSource).type_Element.Clone;
  uriElement := TFhirTestReportParticipant(oSource).uriElement.Clone;
  displayElement := TFhirTestReportParticipant(oSource).displayElement.Clone;
end;

procedure TFhirTestReportParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'uri') Then
     list.add(self.link, 'uri', FUri.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
end;

procedure TFhirTestReportParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'uri', 'uri', false, TFhirUri, FUri.Link));
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));
end;

function TFhirTestReportParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirTestReportParticipantTypeEnum, CODES_TFhirTestReportParticipantTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'uri') then
  begin
    UriElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestReportParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirTestReportParticipantTypeEnum[TestReportParticipantTypeNull], CODES_TFhirTestReportParticipantTypeEnum[TestReportParticipantTypeNull]) 
  else if (propName = 'uri') then result := TFhirUri.create()
  else if (propName = 'display') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'uri') then result := 'uri'
  else if (propName = 'display') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'uri') then UriElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirTestReportParticipantTypeEnum, CODES_TFhirTestReportParticipantTypeEnum, new)
  else if (propName = 'uri') then UriElement := asUri(new)
  else if (propName = 'display') then DisplayElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportParticipant.fhirType : string;
begin
  result := 'TestReport.participant';
end;

function TFhirTestReportParticipant.Link : TFhirTestReportParticipant;
begin
  result := TFhirTestReportParticipant(inherited Link);
end;

function TFhirTestReportParticipant.Clone : TFhirTestReportParticipant;
begin
  result := TFhirTestReportParticipant(inherited Clone);
end;

function TFhirTestReportParticipant.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportParticipant)) then
    result := false
  else
  begin
    o := TFhirTestReportParticipant(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(uriElement, o.uriElement, true) and 
      compareDeep(displayElement, o.displayElement, true);
  end;
end;

function TFhirTestReportParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FUri) and isEmptyProp(FDisplay);
end;

procedure TFhirTestReportParticipant.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('uri');
  fields.add('display');
end;

function TFhirTestReportParticipant.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTestReportParticipant.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirTestReportParticipant.GetType_ST : TFhirTestReportParticipantTypeEnum;
begin
  if FType_ = nil then
    result := TFhirTestReportParticipantTypeEnum(0)
  else
    result := TFhirTestReportParticipantTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirTestReportParticipantTypeEnum, FType_.value));
end;

procedure TFhirTestReportParticipant.SetType_ST(value : TFhirTestReportParticipantTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirTestReportParticipantTypeEnum[value], CODES_TFhirTestReportParticipantTypeEnum[value]);
end;

procedure TFhirTestReportParticipant.SetUri(value : TFhirUri);
begin
  FUri.free;
  FUri := value;
end;

function TFhirTestReportParticipant.GetUriST : String;
begin
  if FUri = nil then
    result := ''
  else
    result := FUri.value;
end;

procedure TFhirTestReportParticipant.SetUriST(value : String);
begin
  if value <> '' then
  begin
    if FUri = nil then
      FUri := TFhirUri.create;
    FUri.value := value
  end
  else if FUri <> nil then
    FUri.value := '';
end;

procedure TFhirTestReportParticipant.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

function TFhirTestReportParticipant.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

procedure TFhirTestReportParticipant.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

{ TFhirTestReportParticipantListEnumerator }

constructor TFhirTestReportParticipantListEnumerator.Create(list : TFhirTestReportParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportParticipantListEnumerator.GetCurrent : TFhirTestReportParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportParticipantListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestReportParticipantList }

function TFhirTestReportParticipantList.AddItem(value: TFhirTestReportParticipant): TFhirTestReportParticipant;
begin
  assert(value.ClassName = 'TFhirTestReportParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportParticipant');
  add(value);
  result := value;
end;

function TFhirTestReportParticipantList.Append: TFhirTestReportParticipant;
begin
  result := TFhirTestReportParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportParticipantList.GetEnumerator : TFhirTestReportParticipantListEnumerator;
begin
  result := TFhirTestReportParticipantListEnumerator.Create(self.link);
end;

function TFhirTestReportParticipantList.Clone: TFhirTestReportParticipantList;
begin
  result := TFhirTestReportParticipantList(inherited Clone);
end;

function TFhirTestReportParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportParticipantList.GetItemN(index: Integer): TFhirTestReportParticipant;
begin
  result := TFhirTestReportParticipant(ObjectByIndex[index]);
end;

function TFhirTestReportParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportParticipant;
end;
function TFhirTestReportParticipantList.IndexOf(value: TFhirTestReportParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportParticipantList.Insert(index: Integer): TFhirTestReportParticipant;
begin
  result := TFhirTestReportParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportParticipantList.InsertItem(index: Integer; value: TFhirTestReportParticipant);
begin
  assert(value is TFhirTestReportParticipant);
  Inherited Insert(index, value);
end;

function TFhirTestReportParticipantList.Item(index: Integer): TFhirTestReportParticipant;
begin
  result := TFhirTestReportParticipant(ObjectByIndex[index]);
end;

function TFhirTestReportParticipantList.Link: TFhirTestReportParticipantList;
begin
  result := TFhirTestReportParticipantList(inherited Link);
end;

procedure TFhirTestReportParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportParticipantList.SetItemByIndex(index: Integer; value: TFhirTestReportParticipant);
begin
  assert(value is TFhirTestReportParticipant);
  FhirTestReportParticipants[index] := value;
end;

procedure TFhirTestReportParticipantList.SetItemN(index: Integer; value: TFhirTestReportParticipant);
begin
  assert(value is TFhirTestReportParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportSetup }

constructor TFhirTestReportSetup.Create;
begin
  inherited;
end;

destructor TFhirTestReportSetup.Destroy;
begin
  FActionList.Free;
  inherited;
end;

procedure TFhirTestReportSetup.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirTestReportSetup(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirTestReportSetupActionList.Create;
    FActionList.Assign(TFhirTestReportSetup(oSource).FActionList);
  end;
end;

procedure TFhirTestReportSetup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirTestReportSetup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'action', 'BackboneElement', true, TFhirTestReportSetupAction, FActionList.Link));
end;

function TFhirTestReportSetup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirTestReportSetupAction);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportSetup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirTestReportSetupAction)
  else inherited;
end;

function TFhirTestReportSetup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'action') then result := ActionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportSetup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'action') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportSetup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'action') then deletePropertyValue('action', ActionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportSetup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportSetup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'action') then ActionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportSetup.fhirType : string;
begin
  result := 'TestReport.setup';
end;

function TFhirTestReportSetup.Link : TFhirTestReportSetup;
begin
  result := TFhirTestReportSetup(inherited Link);
end;

function TFhirTestReportSetup.Clone : TFhirTestReportSetup;
begin
  result := TFhirTestReportSetup(inherited Clone);
end;

function TFhirTestReportSetup.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportSetup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportSetup)) then
    result := false
  else
  begin
    o := TFhirTestReportSetup(other);
    result := compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirTestReportSetup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FactionList);
end;

procedure TFhirTestReportSetup.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('action');
end;

function TFhirTestReportSetup.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FActionList.sizeInBytes(magic));
end;

function TFhirTestReportSetup.GetActionList : TFhirTestReportSetupActionList;
begin
  if FActionList = nil then
    FActionList := TFhirTestReportSetupActionList.Create;
  result := FActionList;
end;

function TFhirTestReportSetup.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

{ TFhirTestReportSetupListEnumerator }

constructor TFhirTestReportSetupListEnumerator.Create(list : TFhirTestReportSetupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportSetupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportSetupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportSetupListEnumerator.GetCurrent : TFhirTestReportSetup;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportSetupListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestReportSetupList }

function TFhirTestReportSetupList.AddItem(value: TFhirTestReportSetup): TFhirTestReportSetup;
begin
  assert(value.ClassName = 'TFhirTestReportSetup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportSetup');
  add(value);
  result := value;
end;

function TFhirTestReportSetupList.Append: TFhirTestReportSetup;
begin
  result := TFhirTestReportSetup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportSetupList.GetEnumerator : TFhirTestReportSetupListEnumerator;
begin
  result := TFhirTestReportSetupListEnumerator.Create(self.link);
end;

function TFhirTestReportSetupList.Clone: TFhirTestReportSetupList;
begin
  result := TFhirTestReportSetupList(inherited Clone);
end;

function TFhirTestReportSetupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportSetupList.GetItemN(index: Integer): TFhirTestReportSetup;
begin
  result := TFhirTestReportSetup(ObjectByIndex[index]);
end;

function TFhirTestReportSetupList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportSetup;
end;
function TFhirTestReportSetupList.IndexOf(value: TFhirTestReportSetup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportSetupList.Insert(index: Integer): TFhirTestReportSetup;
begin
  result := TFhirTestReportSetup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupList.InsertItem(index: Integer; value: TFhirTestReportSetup);
begin
  assert(value is TFhirTestReportSetup);
  Inherited Insert(index, value);
end;

function TFhirTestReportSetupList.Item(index: Integer): TFhirTestReportSetup;
begin
  result := TFhirTestReportSetup(ObjectByIndex[index]);
end;

function TFhirTestReportSetupList.Link: TFhirTestReportSetupList;
begin
  result := TFhirTestReportSetupList(inherited Link);
end;

procedure TFhirTestReportSetupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportSetupList.SetItemByIndex(index: Integer; value: TFhirTestReportSetup);
begin
  assert(value is TFhirTestReportSetup);
  FhirTestReportSetups[index] := value;
end;

procedure TFhirTestReportSetupList.SetItemN(index: Integer; value: TFhirTestReportSetup);
begin
  assert(value is TFhirTestReportSetup);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportSetupAction }

constructor TFhirTestReportSetupAction.Create;
begin
  inherited;
end;

destructor TFhirTestReportSetupAction.Destroy;
begin
  FOperation.free;
  FAssert.free;
  inherited;
end;

procedure TFhirTestReportSetupAction.Assign(oSource : TFslObject);
begin
  inherited;
  operation := TFhirTestReportSetupAction(oSource).operation.Clone;
  assert := TFhirTestReportSetupAction(oSource).assert.Clone;
end;

procedure TFhirTestReportSetupAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'operation') Then
     list.add(self.link, 'operation', FOperation.Link);
  if (child_name = 'assert') Then
     list.add(self.link, 'assert', FAssert.Link);
end;

procedure TFhirTestReportSetupAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'operation', 'BackboneElement', false, TFhirTestReportSetupActionOperation, FOperation.Link));
  oList.add(TFHIRProperty.create(self, 'assert', 'BackboneElement', false, TFhirTestReportSetupActionAssert, FAssert.Link));
end;

function TFhirTestReportSetupAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'operation') then
  begin
    Operation := propValue as TFhirTestReportSetupActionOperation;
    result := propValue;
  end
  else if (propName = 'assert') then
  begin
    Assert := propValue as TFhirTestReportSetupActionAssert;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportSetupAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestReportSetupAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'operation') then result := TFhirTestReportSetupActionOperation.create()
  else if (propName = 'assert') then result := TFhirTestReportSetupActionAssert.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportSetupAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'operation') then result := 'BackboneElement'
  else if (propName = 'assert') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportSetupAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := nil
  else if (propName = 'assert') then AssertElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportSetupAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := new as TFhirTestReportSetupActionOperation
  else if (propName = 'assert') then AssertElement := new as TFhirTestReportSetupActionAssert
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportSetupAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportSetupAction.fhirType : string;
begin
  result := 'TestReport.setup.action';
end;

function TFhirTestReportSetupAction.Link : TFhirTestReportSetupAction;
begin
  result := TFhirTestReportSetupAction(inherited Link);
end;

function TFhirTestReportSetupAction.Clone : TFhirTestReportSetupAction;
begin
  result := TFhirTestReportSetupAction(inherited Clone);
end;

function TFhirTestReportSetupAction.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportSetupAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportSetupAction)) then
    result := false
  else
  begin
    o := TFhirTestReportSetupAction(other);
    result := compareDeep(operationElement, o.operationElement, true) and compareDeep(assertElement, o.assertElement, true);
  end;
end;

function TFhirTestReportSetupAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOperation) and isEmptyProp(FAssert);
end;

procedure TFhirTestReportSetupAction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('operation');
  fields.add('assert');
end;

function TFhirTestReportSetupAction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTestReportSetupAction.SetOperation(value : TFhirTestReportSetupActionOperation);
begin
  FOperation.free;
  FOperation := value;
end;

procedure TFhirTestReportSetupAction.SetAssert(value : TFhirTestReportSetupActionAssert);
begin
  FAssert.free;
  FAssert := value;
end;

{ TFhirTestReportSetupActionListEnumerator }

constructor TFhirTestReportSetupActionListEnumerator.Create(list : TFhirTestReportSetupActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportSetupActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportSetupActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportSetupActionListEnumerator.GetCurrent : TFhirTestReportSetupAction;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportSetupActionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestReportSetupActionList }

function TFhirTestReportSetupActionList.AddItem(value: TFhirTestReportSetupAction): TFhirTestReportSetupAction;
begin
  assert(value.ClassName = 'TFhirTestReportSetupAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportSetupAction');
  add(value);
  result := value;
end;

function TFhirTestReportSetupActionList.Append: TFhirTestReportSetupAction;
begin
  result := TFhirTestReportSetupAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupActionList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportSetupActionList.GetEnumerator : TFhirTestReportSetupActionListEnumerator;
begin
  result := TFhirTestReportSetupActionListEnumerator.Create(self.link);
end;

function TFhirTestReportSetupActionList.Clone: TFhirTestReportSetupActionList;
begin
  result := TFhirTestReportSetupActionList(inherited Clone);
end;

function TFhirTestReportSetupActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportSetupActionList.GetItemN(index: Integer): TFhirTestReportSetupAction;
begin
  result := TFhirTestReportSetupAction(ObjectByIndex[index]);
end;

function TFhirTestReportSetupActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportSetupAction;
end;
function TFhirTestReportSetupActionList.IndexOf(value: TFhirTestReportSetupAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportSetupActionList.Insert(index: Integer): TFhirTestReportSetupAction;
begin
  result := TFhirTestReportSetupAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupActionList.InsertItem(index: Integer; value: TFhirTestReportSetupAction);
begin
  assert(value is TFhirTestReportSetupAction);
  Inherited Insert(index, value);
end;

function TFhirTestReportSetupActionList.Item(index: Integer): TFhirTestReportSetupAction;
begin
  result := TFhirTestReportSetupAction(ObjectByIndex[index]);
end;

function TFhirTestReportSetupActionList.Link: TFhirTestReportSetupActionList;
begin
  result := TFhirTestReportSetupActionList(inherited Link);
end;

procedure TFhirTestReportSetupActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportSetupActionList.SetItemByIndex(index: Integer; value: TFhirTestReportSetupAction);
begin
  assert(value is TFhirTestReportSetupAction);
  FhirTestReportSetupActions[index] := value;
end;

procedure TFhirTestReportSetupActionList.SetItemN(index: Integer; value: TFhirTestReportSetupAction);
begin
  assert(value is TFhirTestReportSetupAction);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportSetupActionOperation }

constructor TFhirTestReportSetupActionOperation.Create;
begin
  inherited;
end;

destructor TFhirTestReportSetupActionOperation.Destroy;
begin
  FResult.free;
  FMessage.free;
  FDetail.free;
  inherited;
end;

procedure TFhirTestReportSetupActionOperation.Assign(oSource : TFslObject);
begin
  inherited;
  resultElement := TFhirTestReportSetupActionOperation(oSource).resultElement.Clone;
  messageElement := TFhirTestReportSetupActionOperation(oSource).messageElement.Clone;
  detailElement := TFhirTestReportSetupActionOperation(oSource).detailElement.Clone;
end;

procedure TFhirTestReportSetupActionOperation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'result') Then
     list.add(self.link, 'result', FResult.Link);
  if (child_name = 'message') Then
     list.add(self.link, 'message', FMessage.Link);
  if (child_name = 'detail') Then
     list.add(self.link, 'detail', FDetail.Link);
end;

procedure TFhirTestReportSetupActionOperation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'result', 'code', false, TFhirEnum, FResult.Link));
  oList.add(TFHIRProperty.create(self, 'message', 'markdown', false, TFhirMarkdown, FMessage.Link));
  oList.add(TFHIRProperty.create(self, 'detail', 'uri', false, TFhirUri, FDetail.Link));
end;

function TFhirTestReportSetupActionOperation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'result') then
  begin
    ResultElement := asEnum(SYSTEMS_TFhirTestReportActionResultEnum, CODES_TFhirTestReportActionResultEnum, propValue);
    result := propValue;
  end
  else if (propName = 'message') then
  begin
    MessageElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailElement := asUri(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportSetupActionOperation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestReportSetupActionOperation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'result') then result := TFhirEnum.create(SYSTEMS_TFhirTestReportActionResultEnum[TestReportActionResultNull], CODES_TFhirTestReportActionResultEnum[TestReportActionResultNull]) 
  else if (propName = 'message') then result := TFhirMarkdown.create()
  else if (propName = 'detail') then result := TFhirUri.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportSetupActionOperation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'result') then result := 'code'
  else if (propName = 'message') then result := 'markdown'
  else if (propName = 'detail') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportSetupActionOperation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'result') then ResultElement := nil
  else if (propName = 'message') then MessageElement := nil
  else if (propName = 'detail') then DetailElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportSetupActionOperation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'result') then ResultElement := asEnum(SYSTEMS_TFhirTestReportActionResultEnum, CODES_TFhirTestReportActionResultEnum, new)
  else if (propName = 'message') then MessageElement := asMarkdown(new)
  else if (propName = 'detail') then DetailElement := asUri(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportSetupActionOperation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportSetupActionOperation.fhirType : string;
begin
  result := 'TestReport.setup.action.operation';
end;

function TFhirTestReportSetupActionOperation.Link : TFhirTestReportSetupActionOperation;
begin
  result := TFhirTestReportSetupActionOperation(inherited Link);
end;

function TFhirTestReportSetupActionOperation.Clone : TFhirTestReportSetupActionOperation;
begin
  result := TFhirTestReportSetupActionOperation(inherited Clone);
end;

function TFhirTestReportSetupActionOperation.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportSetupActionOperation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportSetupActionOperation)) then
    result := false
  else
  begin
    o := TFhirTestReportSetupActionOperation(other);
    result := compareDeep(resultElement, o.resultElement, true) and compareDeep(messageElement, o.messageElement, true) and 
      compareDeep(detailElement, o.detailElement, true);
  end;
end;

function TFhirTestReportSetupActionOperation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FResult) and isEmptyProp(FMessage) and isEmptyProp(FDetail);
end;

procedure TFhirTestReportSetupActionOperation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('result');
  fields.add('message');
  fields.add('detail');
end;

function TFhirTestReportSetupActionOperation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTestReportSetupActionOperation.SetResult(value : TFhirEnum);
begin
  FResult.free;
  FResult := value;
end;

function TFhirTestReportSetupActionOperation.GetResultST : TFhirTestReportActionResultEnum;
begin
  if FResult = nil then
    result := TFhirTestReportActionResultEnum(0)
  else
    result := TFhirTestReportActionResultEnum(StringArrayIndexOfSensitive(CODES_TFhirTestReportActionResultEnum, FResult.value));
end;

procedure TFhirTestReportSetupActionOperation.SetResultST(value : TFhirTestReportActionResultEnum);
begin
  if ord(value) = 0 then
    ResultElement := nil
  else
    ResultElement := TFhirEnum.create(SYSTEMS_TFhirTestReportActionResultEnum[value], CODES_TFhirTestReportActionResultEnum[value]);
end;

procedure TFhirTestReportSetupActionOperation.SetMessage(value : TFhirMarkdown);
begin
  FMessage.free;
  FMessage := value;
end;

function TFhirTestReportSetupActionOperation.GetMessageST : String;
begin
  if FMessage = nil then
    result := ''
  else
    result := FMessage.value;
end;

procedure TFhirTestReportSetupActionOperation.SetMessageST(value : String);
begin
  if value <> '' then
  begin
    if FMessage = nil then
      FMessage := TFhirMarkdown.create;
    FMessage.value := value
  end
  else if FMessage <> nil then
    FMessage.value := '';
end;

procedure TFhirTestReportSetupActionOperation.SetDetail(value : TFhirUri);
begin
  FDetail.free;
  FDetail := value;
end;

function TFhirTestReportSetupActionOperation.GetDetailST : String;
begin
  if FDetail = nil then
    result := ''
  else
    result := FDetail.value;
end;

procedure TFhirTestReportSetupActionOperation.SetDetailST(value : String);
begin
  if value <> '' then
  begin
    if FDetail = nil then
      FDetail := TFhirUri.create;
    FDetail.value := value
  end
  else if FDetail <> nil then
    FDetail.value := '';
end;

{ TFhirTestReportSetupActionOperationListEnumerator }

constructor TFhirTestReportSetupActionOperationListEnumerator.Create(list : TFhirTestReportSetupActionOperationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportSetupActionOperationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportSetupActionOperationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportSetupActionOperationListEnumerator.GetCurrent : TFhirTestReportSetupActionOperation;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportSetupActionOperationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestReportSetupActionOperationList }

function TFhirTestReportSetupActionOperationList.AddItem(value: TFhirTestReportSetupActionOperation): TFhirTestReportSetupActionOperation;
begin
  assert(value.ClassName = 'TFhirTestReportSetupActionOperation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportSetupActionOperation');
  add(value);
  result := value;
end;

function TFhirTestReportSetupActionOperationList.Append: TFhirTestReportSetupActionOperation;
begin
  result := TFhirTestReportSetupActionOperation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupActionOperationList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportSetupActionOperationList.GetEnumerator : TFhirTestReportSetupActionOperationListEnumerator;
begin
  result := TFhirTestReportSetupActionOperationListEnumerator.Create(self.link);
end;

function TFhirTestReportSetupActionOperationList.Clone: TFhirTestReportSetupActionOperationList;
begin
  result := TFhirTestReportSetupActionOperationList(inherited Clone);
end;

function TFhirTestReportSetupActionOperationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportSetupActionOperationList.GetItemN(index: Integer): TFhirTestReportSetupActionOperation;
begin
  result := TFhirTestReportSetupActionOperation(ObjectByIndex[index]);
end;

function TFhirTestReportSetupActionOperationList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportSetupActionOperation;
end;
function TFhirTestReportSetupActionOperationList.IndexOf(value: TFhirTestReportSetupActionOperation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportSetupActionOperationList.Insert(index: Integer): TFhirTestReportSetupActionOperation;
begin
  result := TFhirTestReportSetupActionOperation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupActionOperationList.InsertItem(index: Integer; value: TFhirTestReportSetupActionOperation);
begin
  assert(value is TFhirTestReportSetupActionOperation);
  Inherited Insert(index, value);
end;

function TFhirTestReportSetupActionOperationList.Item(index: Integer): TFhirTestReportSetupActionOperation;
begin
  result := TFhirTestReportSetupActionOperation(ObjectByIndex[index]);
end;

function TFhirTestReportSetupActionOperationList.Link: TFhirTestReportSetupActionOperationList;
begin
  result := TFhirTestReportSetupActionOperationList(inherited Link);
end;

procedure TFhirTestReportSetupActionOperationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportSetupActionOperationList.SetItemByIndex(index: Integer; value: TFhirTestReportSetupActionOperation);
begin
  assert(value is TFhirTestReportSetupActionOperation);
  FhirTestReportSetupActionOperations[index] := value;
end;

procedure TFhirTestReportSetupActionOperationList.SetItemN(index: Integer; value: TFhirTestReportSetupActionOperation);
begin
  assert(value is TFhirTestReportSetupActionOperation);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportSetupActionAssert }

constructor TFhirTestReportSetupActionAssert.Create;
begin
  inherited;
end;

destructor TFhirTestReportSetupActionAssert.Destroy;
begin
  FResult.free;
  FMessage.free;
  FDetail.free;
  inherited;
end;

procedure TFhirTestReportSetupActionAssert.Assign(oSource : TFslObject);
begin
  inherited;
  resultElement := TFhirTestReportSetupActionAssert(oSource).resultElement.Clone;
  messageElement := TFhirTestReportSetupActionAssert(oSource).messageElement.Clone;
  detailElement := TFhirTestReportSetupActionAssert(oSource).detailElement.Clone;
end;

procedure TFhirTestReportSetupActionAssert.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'result') Then
     list.add(self.link, 'result', FResult.Link);
  if (child_name = 'message') Then
     list.add(self.link, 'message', FMessage.Link);
  if (child_name = 'detail') Then
     list.add(self.link, 'detail', FDetail.Link);
end;

procedure TFhirTestReportSetupActionAssert.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'result', 'code', false, TFhirEnum, FResult.Link));
  oList.add(TFHIRProperty.create(self, 'message', 'markdown', false, TFhirMarkdown, FMessage.Link));
  oList.add(TFHIRProperty.create(self, 'detail', 'string', false, TFhirString, FDetail.Link));
end;

function TFhirTestReportSetupActionAssert.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'result') then
  begin
    ResultElement := asEnum(SYSTEMS_TFhirTestReportActionResultEnum, CODES_TFhirTestReportActionResultEnum, propValue);
    result := propValue;
  end
  else if (propName = 'message') then
  begin
    MessageElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportSetupActionAssert.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestReportSetupActionAssert.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'result') then result := TFhirEnum.create(SYSTEMS_TFhirTestReportActionResultEnum[TestReportActionResultNull], CODES_TFhirTestReportActionResultEnum[TestReportActionResultNull]) 
  else if (propName = 'message') then result := TFhirMarkdown.create()
  else if (propName = 'detail') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportSetupActionAssert.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'result') then result := 'code'
  else if (propName = 'message') then result := 'markdown'
  else if (propName = 'detail') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportSetupActionAssert.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'result') then ResultElement := nil
  else if (propName = 'message') then MessageElement := nil
  else if (propName = 'detail') then DetailElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportSetupActionAssert.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'result') then ResultElement := asEnum(SYSTEMS_TFhirTestReportActionResultEnum, CODES_TFhirTestReportActionResultEnum, new)
  else if (propName = 'message') then MessageElement := asMarkdown(new)
  else if (propName = 'detail') then DetailElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportSetupActionAssert.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportSetupActionAssert.fhirType : string;
begin
  result := 'TestReport.setup.action.assert';
end;

function TFhirTestReportSetupActionAssert.Link : TFhirTestReportSetupActionAssert;
begin
  result := TFhirTestReportSetupActionAssert(inherited Link);
end;

function TFhirTestReportSetupActionAssert.Clone : TFhirTestReportSetupActionAssert;
begin
  result := TFhirTestReportSetupActionAssert(inherited Clone);
end;

function TFhirTestReportSetupActionAssert.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportSetupActionAssert;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportSetupActionAssert)) then
    result := false
  else
  begin
    o := TFhirTestReportSetupActionAssert(other);
    result := compareDeep(resultElement, o.resultElement, true) and compareDeep(messageElement, o.messageElement, true) and 
      compareDeep(detailElement, o.detailElement, true);
  end;
end;

function TFhirTestReportSetupActionAssert.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FResult) and isEmptyProp(FMessage) and isEmptyProp(FDetail);
end;

procedure TFhirTestReportSetupActionAssert.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('result');
  fields.add('message');
  fields.add('detail');
end;

function TFhirTestReportSetupActionAssert.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTestReportSetupActionAssert.SetResult(value : TFhirEnum);
begin
  FResult.free;
  FResult := value;
end;

function TFhirTestReportSetupActionAssert.GetResultST : TFhirTestReportActionResultEnum;
begin
  if FResult = nil then
    result := TFhirTestReportActionResultEnum(0)
  else
    result := TFhirTestReportActionResultEnum(StringArrayIndexOfSensitive(CODES_TFhirTestReportActionResultEnum, FResult.value));
end;

procedure TFhirTestReportSetupActionAssert.SetResultST(value : TFhirTestReportActionResultEnum);
begin
  if ord(value) = 0 then
    ResultElement := nil
  else
    ResultElement := TFhirEnum.create(SYSTEMS_TFhirTestReportActionResultEnum[value], CODES_TFhirTestReportActionResultEnum[value]);
end;

procedure TFhirTestReportSetupActionAssert.SetMessage(value : TFhirMarkdown);
begin
  FMessage.free;
  FMessage := value;
end;

function TFhirTestReportSetupActionAssert.GetMessageST : String;
begin
  if FMessage = nil then
    result := ''
  else
    result := FMessage.value;
end;

procedure TFhirTestReportSetupActionAssert.SetMessageST(value : String);
begin
  if value <> '' then
  begin
    if FMessage = nil then
      FMessage := TFhirMarkdown.create;
    FMessage.value := value
  end
  else if FMessage <> nil then
    FMessage.value := '';
end;

procedure TFhirTestReportSetupActionAssert.SetDetail(value : TFhirString);
begin
  FDetail.free;
  FDetail := value;
end;

function TFhirTestReportSetupActionAssert.GetDetailST : String;
begin
  if FDetail = nil then
    result := ''
  else
    result := FDetail.value;
end;

procedure TFhirTestReportSetupActionAssert.SetDetailST(value : String);
begin
  if value <> '' then
  begin
    if FDetail = nil then
      FDetail := TFhirString.create;
    FDetail.value := value
  end
  else if FDetail <> nil then
    FDetail.value := '';
end;

{ TFhirTestReportSetupActionAssertListEnumerator }

constructor TFhirTestReportSetupActionAssertListEnumerator.Create(list : TFhirTestReportSetupActionAssertList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportSetupActionAssertListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportSetupActionAssertListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportSetupActionAssertListEnumerator.GetCurrent : TFhirTestReportSetupActionAssert;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportSetupActionAssertListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestReportSetupActionAssertList }

function TFhirTestReportSetupActionAssertList.AddItem(value: TFhirTestReportSetupActionAssert): TFhirTestReportSetupActionAssert;
begin
  assert(value.ClassName = 'TFhirTestReportSetupActionAssert', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportSetupActionAssert');
  add(value);
  result := value;
end;

function TFhirTestReportSetupActionAssertList.Append: TFhirTestReportSetupActionAssert;
begin
  result := TFhirTestReportSetupActionAssert.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupActionAssertList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportSetupActionAssertList.GetEnumerator : TFhirTestReportSetupActionAssertListEnumerator;
begin
  result := TFhirTestReportSetupActionAssertListEnumerator.Create(self.link);
end;

function TFhirTestReportSetupActionAssertList.Clone: TFhirTestReportSetupActionAssertList;
begin
  result := TFhirTestReportSetupActionAssertList(inherited Clone);
end;

function TFhirTestReportSetupActionAssertList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportSetupActionAssertList.GetItemN(index: Integer): TFhirTestReportSetupActionAssert;
begin
  result := TFhirTestReportSetupActionAssert(ObjectByIndex[index]);
end;

function TFhirTestReportSetupActionAssertList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportSetupActionAssert;
end;
function TFhirTestReportSetupActionAssertList.IndexOf(value: TFhirTestReportSetupActionAssert): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportSetupActionAssertList.Insert(index: Integer): TFhirTestReportSetupActionAssert;
begin
  result := TFhirTestReportSetupActionAssert.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupActionAssertList.InsertItem(index: Integer; value: TFhirTestReportSetupActionAssert);
begin
  assert(value is TFhirTestReportSetupActionAssert);
  Inherited Insert(index, value);
end;

function TFhirTestReportSetupActionAssertList.Item(index: Integer): TFhirTestReportSetupActionAssert;
begin
  result := TFhirTestReportSetupActionAssert(ObjectByIndex[index]);
end;

function TFhirTestReportSetupActionAssertList.Link: TFhirTestReportSetupActionAssertList;
begin
  result := TFhirTestReportSetupActionAssertList(inherited Link);
end;

procedure TFhirTestReportSetupActionAssertList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportSetupActionAssertList.SetItemByIndex(index: Integer; value: TFhirTestReportSetupActionAssert);
begin
  assert(value is TFhirTestReportSetupActionAssert);
  FhirTestReportSetupActionAsserts[index] := value;
end;

procedure TFhirTestReportSetupActionAssertList.SetItemN(index: Integer; value: TFhirTestReportSetupActionAssert);
begin
  assert(value is TFhirTestReportSetupActionAssert);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportTest }

constructor TFhirTestReportTest.Create;
begin
  inherited;
end;

destructor TFhirTestReportTest.Destroy;
begin
  FName.free;
  FDescription.free;
  FActionList.Free;
  inherited;
end;

procedure TFhirTestReportTest.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirTestReportTest(oSource).nameElement.Clone;
  descriptionElement := TFhirTestReportTest(oSource).descriptionElement.Clone;
  if (TFhirTestReportTest(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirTestReportTestActionList.Create;
    FActionList.Assign(TFhirTestReportTest(oSource).FActionList);
  end;
end;

procedure TFhirTestReportTest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirTestReportTest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'action', 'BackboneElement', true, TFhirTestReportTestAction, FActionList.Link));
end;

function TFhirTestReportTest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirTestReportTestAction);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportTest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirTestReportTestAction)
  else inherited;
end;

function TFhirTestReportTest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'action') then result := ActionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportTest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'action') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportTest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportTest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportTest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'action') then ActionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportTest.fhirType : string;
begin
  result := 'TestReport.test';
end;

function TFhirTestReportTest.Link : TFhirTestReportTest;
begin
  result := TFhirTestReportTest(inherited Link);
end;

function TFhirTestReportTest.Clone : TFhirTestReportTest;
begin
  result := TFhirTestReportTest(inherited Clone);
end;

function TFhirTestReportTest.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportTest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportTest)) then
    result := false
  else
  begin
    o := TFhirTestReportTest(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirTestReportTest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FactionList);
end;

procedure TFhirTestReportTest.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('description');
  fields.add('action');
end;

function TFhirTestReportTest.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FActionList.sizeInBytes(magic));
end;

procedure TFhirTestReportTest.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirTestReportTest.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirTestReportTest.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirTestReportTest.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirTestReportTest.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirTestReportTest.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirTestReportTest.GetActionList : TFhirTestReportTestActionList;
begin
  if FActionList = nil then
    FActionList := TFhirTestReportTestActionList.Create;
  result := FActionList;
end;

function TFhirTestReportTest.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

{ TFhirTestReportTestListEnumerator }

constructor TFhirTestReportTestListEnumerator.Create(list : TFhirTestReportTestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportTestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportTestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportTestListEnumerator.GetCurrent : TFhirTestReportTest;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportTestListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestReportTestList }

function TFhirTestReportTestList.AddItem(value: TFhirTestReportTest): TFhirTestReportTest;
begin
  assert(value.ClassName = 'TFhirTestReportTest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportTest');
  add(value);
  result := value;
end;

function TFhirTestReportTestList.Append: TFhirTestReportTest;
begin
  result := TFhirTestReportTest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTestList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportTestList.GetEnumerator : TFhirTestReportTestListEnumerator;
begin
  result := TFhirTestReportTestListEnumerator.Create(self.link);
end;

function TFhirTestReportTestList.Clone: TFhirTestReportTestList;
begin
  result := TFhirTestReportTestList(inherited Clone);
end;

function TFhirTestReportTestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportTestList.GetItemN(index: Integer): TFhirTestReportTest;
begin
  result := TFhirTestReportTest(ObjectByIndex[index]);
end;

function TFhirTestReportTestList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportTest;
end;
function TFhirTestReportTestList.IndexOf(value: TFhirTestReportTest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportTestList.Insert(index: Integer): TFhirTestReportTest;
begin
  result := TFhirTestReportTest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTestList.InsertItem(index: Integer; value: TFhirTestReportTest);
begin
  assert(value is TFhirTestReportTest);
  Inherited Insert(index, value);
end;

function TFhirTestReportTestList.Item(index: Integer): TFhirTestReportTest;
begin
  result := TFhirTestReportTest(ObjectByIndex[index]);
end;

function TFhirTestReportTestList.Link: TFhirTestReportTestList;
begin
  result := TFhirTestReportTestList(inherited Link);
end;

procedure TFhirTestReportTestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportTestList.SetItemByIndex(index: Integer; value: TFhirTestReportTest);
begin
  assert(value is TFhirTestReportTest);
  FhirTestReportTests[index] := value;
end;

procedure TFhirTestReportTestList.SetItemN(index: Integer; value: TFhirTestReportTest);
begin
  assert(value is TFhirTestReportTest);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportTestAction }

constructor TFhirTestReportTestAction.Create;
begin
  inherited;
end;

destructor TFhirTestReportTestAction.Destroy;
begin
  FOperation.free;
  FAssert.free;
  inherited;
end;

procedure TFhirTestReportTestAction.Assign(oSource : TFslObject);
begin
  inherited;
  operation := TFhirTestReportTestAction(oSource).operation.Clone;
  assert := TFhirTestReportTestAction(oSource).assert.Clone;
end;

procedure TFhirTestReportTestAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'operation') Then
     list.add(self.link, 'operation', FOperation.Link);
  if (child_name = 'assert') Then
     list.add(self.link, 'assert', FAssert.Link);
end;

procedure TFhirTestReportTestAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'operation', '', false, TFhirTestReportSetupActionOperation, FOperation.Link));
  oList.add(TFHIRProperty.create(self, 'assert', '', false, TFhirTestReportSetupActionAssert, FAssert.Link));
end;

function TFhirTestReportTestAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'operation') then
  begin
    Operation := propValue as TFhirTestReportSetupActionOperation;
    result := propValue;
  end
  else if (propName = 'assert') then
  begin
    Assert := propValue as TFhirTestReportSetupActionAssert;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportTestAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestReportTestAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'operation') then result := TFhirTestReportSetupActionOperation.create()
  else if (propName = 'assert') then result := TFhirTestReportSetupActionAssert.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportTestAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'operation') then result := ''
  else if (propName = 'assert') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportTestAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := nil
  else if (propName = 'assert') then AssertElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportTestAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := new as TFhirTestReportSetupActionOperation
  else if (propName = 'assert') then AssertElement := new as TFhirTestReportSetupActionAssert
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportTestAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportTestAction.fhirType : string;
begin
  result := 'TestReport.test.action';
end;

function TFhirTestReportTestAction.Link : TFhirTestReportTestAction;
begin
  result := TFhirTestReportTestAction(inherited Link);
end;

function TFhirTestReportTestAction.Clone : TFhirTestReportTestAction;
begin
  result := TFhirTestReportTestAction(inherited Clone);
end;

function TFhirTestReportTestAction.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportTestAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportTestAction)) then
    result := false
  else
  begin
    o := TFhirTestReportTestAction(other);
    result := compareDeep(operationElement, o.operationElement, true) and compareDeep(assertElement, o.assertElement, true);
  end;
end;

function TFhirTestReportTestAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOperation) and isEmptyProp(FAssert);
end;

procedure TFhirTestReportTestAction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('operation');
  fields.add('assert');
end;

function TFhirTestReportTestAction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTestReportTestAction.SetOperation(value : TFhirTestReportSetupActionOperation);
begin
  FOperation.free;
  FOperation := value;
end;

procedure TFhirTestReportTestAction.SetAssert(value : TFhirTestReportSetupActionAssert);
begin
  FAssert.free;
  FAssert := value;
end;

{ TFhirTestReportTestActionListEnumerator }

constructor TFhirTestReportTestActionListEnumerator.Create(list : TFhirTestReportTestActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportTestActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportTestActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportTestActionListEnumerator.GetCurrent : TFhirTestReportTestAction;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportTestActionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestReportTestActionList }

function TFhirTestReportTestActionList.AddItem(value: TFhirTestReportTestAction): TFhirTestReportTestAction;
begin
  assert(value.ClassName = 'TFhirTestReportTestAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportTestAction');
  add(value);
  result := value;
end;

function TFhirTestReportTestActionList.Append: TFhirTestReportTestAction;
begin
  result := TFhirTestReportTestAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTestActionList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportTestActionList.GetEnumerator : TFhirTestReportTestActionListEnumerator;
begin
  result := TFhirTestReportTestActionListEnumerator.Create(self.link);
end;

function TFhirTestReportTestActionList.Clone: TFhirTestReportTestActionList;
begin
  result := TFhirTestReportTestActionList(inherited Clone);
end;

function TFhirTestReportTestActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportTestActionList.GetItemN(index: Integer): TFhirTestReportTestAction;
begin
  result := TFhirTestReportTestAction(ObjectByIndex[index]);
end;

function TFhirTestReportTestActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportTestAction;
end;
function TFhirTestReportTestActionList.IndexOf(value: TFhirTestReportTestAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportTestActionList.Insert(index: Integer): TFhirTestReportTestAction;
begin
  result := TFhirTestReportTestAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTestActionList.InsertItem(index: Integer; value: TFhirTestReportTestAction);
begin
  assert(value is TFhirTestReportTestAction);
  Inherited Insert(index, value);
end;

function TFhirTestReportTestActionList.Item(index: Integer): TFhirTestReportTestAction;
begin
  result := TFhirTestReportTestAction(ObjectByIndex[index]);
end;

function TFhirTestReportTestActionList.Link: TFhirTestReportTestActionList;
begin
  result := TFhirTestReportTestActionList(inherited Link);
end;

procedure TFhirTestReportTestActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportTestActionList.SetItemByIndex(index: Integer; value: TFhirTestReportTestAction);
begin
  assert(value is TFhirTestReportTestAction);
  FhirTestReportTestActions[index] := value;
end;

procedure TFhirTestReportTestActionList.SetItemN(index: Integer; value: TFhirTestReportTestAction);
begin
  assert(value is TFhirTestReportTestAction);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportTeardown }

constructor TFhirTestReportTeardown.Create;
begin
  inherited;
end;

destructor TFhirTestReportTeardown.Destroy;
begin
  FActionList.Free;
  inherited;
end;

procedure TFhirTestReportTeardown.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirTestReportTeardown(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirTestReportTeardownActionList.Create;
    FActionList.Assign(TFhirTestReportTeardown(oSource).FActionList);
  end;
end;

procedure TFhirTestReportTeardown.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirTestReportTeardown.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'action', 'BackboneElement', true, TFhirTestReportTeardownAction, FActionList.Link));
end;

function TFhirTestReportTeardown.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirTestReportTeardownAction);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportTeardown.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirTestReportTeardownAction)
  else inherited;
end;

function TFhirTestReportTeardown.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'action') then result := ActionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportTeardown.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'action') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportTeardown.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'action') then deletePropertyValue('action', ActionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportTeardown.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportTeardown.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'action') then ActionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportTeardown.fhirType : string;
begin
  result := 'TestReport.teardown';
end;

function TFhirTestReportTeardown.Link : TFhirTestReportTeardown;
begin
  result := TFhirTestReportTeardown(inherited Link);
end;

function TFhirTestReportTeardown.Clone : TFhirTestReportTeardown;
begin
  result := TFhirTestReportTeardown(inherited Clone);
end;

function TFhirTestReportTeardown.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportTeardown;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportTeardown)) then
    result := false
  else
  begin
    o := TFhirTestReportTeardown(other);
    result := compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirTestReportTeardown.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FactionList);
end;

procedure TFhirTestReportTeardown.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('action');
end;

function TFhirTestReportTeardown.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FActionList.sizeInBytes(magic));
end;

function TFhirTestReportTeardown.GetActionList : TFhirTestReportTeardownActionList;
begin
  if FActionList = nil then
    FActionList := TFhirTestReportTeardownActionList.Create;
  result := FActionList;
end;

function TFhirTestReportTeardown.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

{ TFhirTestReportTeardownListEnumerator }

constructor TFhirTestReportTeardownListEnumerator.Create(list : TFhirTestReportTeardownList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportTeardownListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportTeardownListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportTeardownListEnumerator.GetCurrent : TFhirTestReportTeardown;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportTeardownListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestReportTeardownList }

function TFhirTestReportTeardownList.AddItem(value: TFhirTestReportTeardown): TFhirTestReportTeardown;
begin
  assert(value.ClassName = 'TFhirTestReportTeardown', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportTeardown');
  add(value);
  result := value;
end;

function TFhirTestReportTeardownList.Append: TFhirTestReportTeardown;
begin
  result := TFhirTestReportTeardown.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTeardownList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportTeardownList.GetEnumerator : TFhirTestReportTeardownListEnumerator;
begin
  result := TFhirTestReportTeardownListEnumerator.Create(self.link);
end;

function TFhirTestReportTeardownList.Clone: TFhirTestReportTeardownList;
begin
  result := TFhirTestReportTeardownList(inherited Clone);
end;

function TFhirTestReportTeardownList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportTeardownList.GetItemN(index: Integer): TFhirTestReportTeardown;
begin
  result := TFhirTestReportTeardown(ObjectByIndex[index]);
end;

function TFhirTestReportTeardownList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportTeardown;
end;
function TFhirTestReportTeardownList.IndexOf(value: TFhirTestReportTeardown): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportTeardownList.Insert(index: Integer): TFhirTestReportTeardown;
begin
  result := TFhirTestReportTeardown.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTeardownList.InsertItem(index: Integer; value: TFhirTestReportTeardown);
begin
  assert(value is TFhirTestReportTeardown);
  Inherited Insert(index, value);
end;

function TFhirTestReportTeardownList.Item(index: Integer): TFhirTestReportTeardown;
begin
  result := TFhirTestReportTeardown(ObjectByIndex[index]);
end;

function TFhirTestReportTeardownList.Link: TFhirTestReportTeardownList;
begin
  result := TFhirTestReportTeardownList(inherited Link);
end;

procedure TFhirTestReportTeardownList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportTeardownList.SetItemByIndex(index: Integer; value: TFhirTestReportTeardown);
begin
  assert(value is TFhirTestReportTeardown);
  FhirTestReportTeardowns[index] := value;
end;

procedure TFhirTestReportTeardownList.SetItemN(index: Integer; value: TFhirTestReportTeardown);
begin
  assert(value is TFhirTestReportTeardown);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportTeardownAction }

constructor TFhirTestReportTeardownAction.Create;
begin
  inherited;
end;

destructor TFhirTestReportTeardownAction.Destroy;
begin
  FOperation.free;
  inherited;
end;

procedure TFhirTestReportTeardownAction.Assign(oSource : TFslObject);
begin
  inherited;
  operation := TFhirTestReportTeardownAction(oSource).operation.Clone;
end;

procedure TFhirTestReportTeardownAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'operation') Then
     list.add(self.link, 'operation', FOperation.Link);
end;

procedure TFhirTestReportTeardownAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'operation', '', false, TFhirTestReportSetupActionOperation, FOperation.Link));
end;

function TFhirTestReportTeardownAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'operation') then
  begin
    Operation := propValue as TFhirTestReportSetupActionOperation;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportTeardownAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestReportTeardownAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'operation') then result := TFhirTestReportSetupActionOperation.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportTeardownAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'operation') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportTeardownAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportTeardownAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := new as TFhirTestReportSetupActionOperation
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportTeardownAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportTeardownAction.fhirType : string;
begin
  result := 'TestReport.teardown.action';
end;

function TFhirTestReportTeardownAction.Link : TFhirTestReportTeardownAction;
begin
  result := TFhirTestReportTeardownAction(inherited Link);
end;

function TFhirTestReportTeardownAction.Clone : TFhirTestReportTeardownAction;
begin
  result := TFhirTestReportTeardownAction(inherited Clone);
end;

function TFhirTestReportTeardownAction.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportTeardownAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportTeardownAction)) then
    result := false
  else
  begin
    o := TFhirTestReportTeardownAction(other);
    result := compareDeep(operationElement, o.operationElement, true);
  end;
end;

function TFhirTestReportTeardownAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOperation);
end;

procedure TFhirTestReportTeardownAction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('operation');
end;

function TFhirTestReportTeardownAction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTestReportTeardownAction.SetOperation(value : TFhirTestReportSetupActionOperation);
begin
  FOperation.free;
  FOperation := value;
end;

{ TFhirTestReportTeardownActionListEnumerator }

constructor TFhirTestReportTeardownActionListEnumerator.Create(list : TFhirTestReportTeardownActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportTeardownActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportTeardownActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportTeardownActionListEnumerator.GetCurrent : TFhirTestReportTeardownAction;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportTeardownActionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestReportTeardownActionList }

function TFhirTestReportTeardownActionList.AddItem(value: TFhirTestReportTeardownAction): TFhirTestReportTeardownAction;
begin
  assert(value.ClassName = 'TFhirTestReportTeardownAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportTeardownAction');
  add(value);
  result := value;
end;

function TFhirTestReportTeardownActionList.Append: TFhirTestReportTeardownAction;
begin
  result := TFhirTestReportTeardownAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTeardownActionList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportTeardownActionList.GetEnumerator : TFhirTestReportTeardownActionListEnumerator;
begin
  result := TFhirTestReportTeardownActionListEnumerator.Create(self.link);
end;

function TFhirTestReportTeardownActionList.Clone: TFhirTestReportTeardownActionList;
begin
  result := TFhirTestReportTeardownActionList(inherited Clone);
end;

function TFhirTestReportTeardownActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportTeardownActionList.GetItemN(index: Integer): TFhirTestReportTeardownAction;
begin
  result := TFhirTestReportTeardownAction(ObjectByIndex[index]);
end;

function TFhirTestReportTeardownActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportTeardownAction;
end;
function TFhirTestReportTeardownActionList.IndexOf(value: TFhirTestReportTeardownAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportTeardownActionList.Insert(index: Integer): TFhirTestReportTeardownAction;
begin
  result := TFhirTestReportTeardownAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTeardownActionList.InsertItem(index: Integer; value: TFhirTestReportTeardownAction);
begin
  assert(value is TFhirTestReportTeardownAction);
  Inherited Insert(index, value);
end;

function TFhirTestReportTeardownActionList.Item(index: Integer): TFhirTestReportTeardownAction;
begin
  result := TFhirTestReportTeardownAction(ObjectByIndex[index]);
end;

function TFhirTestReportTeardownActionList.Link: TFhirTestReportTeardownActionList;
begin
  result := TFhirTestReportTeardownActionList(inherited Link);
end;

procedure TFhirTestReportTeardownActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportTeardownActionList.SetItemByIndex(index: Integer; value: TFhirTestReportTeardownAction);
begin
  assert(value is TFhirTestReportTeardownAction);
  FhirTestReportTeardownActions[index] := value;
end;

procedure TFhirTestReportTeardownActionList.SetItemN(index: Integer; value: TFhirTestReportTeardownAction);
begin
  assert(value is TFhirTestReportTeardownAction);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReport }

constructor TFhirTestReport.Create;
begin
  inherited;
end;

destructor TFhirTestReport.Destroy;
begin
  FIdentifier.free;
  FName.free;
  FStatus.free;
  FTestScript.free;
  FResult.free;
  FScore.free;
  FTester.free;
  FIssued.free;
  FParticipantList.Free;
  FSetup.free;
  FTestList.Free;
  FTeardown.free;
  inherited;
end;

procedure TFhirTestReport.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirTestReport(oSource).identifier.Clone;
  nameElement := TFhirTestReport(oSource).nameElement.Clone;
  statusElement := TFhirTestReport(oSource).statusElement.Clone;
  testScriptElement := TFhirTestReport(oSource).testScriptElement.Clone;
  resultElement := TFhirTestReport(oSource).resultElement.Clone;
  scoreElement := TFhirTestReport(oSource).scoreElement.Clone;
  testerElement := TFhirTestReport(oSource).testerElement.Clone;
  issuedElement := TFhirTestReport(oSource).issuedElement.Clone;
  if (TFhirTestReport(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirTestReportParticipantList.Create;
    FParticipantList.Assign(TFhirTestReport(oSource).FParticipantList);
  end;
  setup := TFhirTestReport(oSource).setup.Clone;
  if (TFhirTestReport(oSource).FTestList = nil) then
  begin
    FTestList.free;
    FTestList := nil;
  end
  else
  begin
    if FTestList = nil then
      FTestList := TFhirTestReportTestList.Create;
    FTestList.Assign(TFhirTestReport(oSource).FTestList);
  end;
  teardown := TFhirTestReport(oSource).teardown.Clone;
end;

function TFhirTestReport.GetResourceType : TFhirResourceType;
begin
  result := frtTestReport;
end;

procedure TFhirTestReport.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'testScript') Then
     list.add(self.link, 'testScript', FTestScript.Link);
  if (child_name = 'result') Then
     list.add(self.link, 'result', FResult.Link);
  if (child_name = 'score') Then
     list.add(self.link, 'score', FScore.Link);
  if (child_name = 'tester') Then
     list.add(self.link, 'tester', FTester.Link);
  if (child_name = 'issued') Then
     list.add(self.link, 'issued', FIssued.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'setup') Then
     list.add(self.link, 'setup', FSetup.Link);
  if (child_name = 'test') Then
    list.addAll(self, 'test', FTestList);
  if (child_name = 'teardown') Then
     list.add(self.link, 'teardown', FTeardown.Link);
end;

procedure TFhirTestReport.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'testScript', 'canonical', false, TFhirCanonical, FTestScript.Link));
  oList.add(TFHIRProperty.create(self, 'result', 'code', false, TFhirEnum, FResult.Link));
  oList.add(TFHIRProperty.create(self, 'score', 'decimal', false, TFhirDecimal, FScore.Link));
  oList.add(TFHIRProperty.create(self, 'tester', 'string', false, TFhirString, FTester.Link));
  oList.add(TFHIRProperty.create(self, 'issued', 'dateTime', false, TFhirDateTime, FIssued.Link));
  oList.add(TFHIRProperty.create(self, 'participant', 'BackboneElement', true, TFhirTestReportParticipant, FParticipantList.Link));
  oList.add(TFHIRProperty.create(self, 'setup', 'BackboneElement', false, TFhirTestReportSetup, FSetup.Link));
  oList.add(TFHIRProperty.create(self, 'test', 'BackboneElement', true, TFhirTestReportTest, FTestList.Link));
  oList.add(TFHIRProperty.create(self, 'teardown', 'BackboneElement', false, TFhirTestReportTeardown, FTeardown.Link));
end;

function TFhirTestReport.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirTestReportStatusEnum, CODES_TFhirTestReportStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'testScript') then
  begin
    TestScriptElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'result') then
  begin
    ResultElement := asEnum(SYSTEMS_TFhirTestReportResultEnum, CODES_TFhirTestReportResultEnum, propValue);
    result := propValue;
  end
  else if (propName = 'score') then
  begin
    ScoreElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'tester') then
  begin
    TesterElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'issued') then
  begin
    IssuedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirTestReportParticipant);
    result := propValue;
  end
  else if (propName = 'setup') then
  begin
    Setup := propValue as TFhirTestReportSetup;
    result := propValue;
  end
  else if (propName = 'test') then
  begin
    TestList.add(propValue as TFhirTestReportTest);
    result := propValue;
  end
  else if (propName = 'teardown') then
  begin
    Teardown := propValue as TFhirTestReportTeardown;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReport.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirTestReportParticipant)
  else if (propName = 'test') then TestList.insertItem(index, propValue as TFhirTestReportTest)
  else inherited;
end;

function TFhirTestReport.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirTestReportStatusEnum[TestReportStatusNull], CODES_TFhirTestReportStatusEnum[TestReportStatusNull]) 
  else if (propName = 'testScript') then result := TFhirCanonical.create()
  else if (propName = 'result') then result := TFhirEnum.create(SYSTEMS_TFhirTestReportResultEnum[TestReportResultNull], CODES_TFhirTestReportResultEnum[TestReportResultNull]) 
  else if (propName = 'score') then result := TFhirDecimal.create()
  else if (propName = 'tester') then result := TFhirString.create()
  else if (propName = 'issued') then result := TFhirDateTime.create()
  else if (propName = 'participant') then result := ParticipantList.new()
  else if (propName = 'setup') then result := TFhirTestReportSetup.create()
  else if (propName = 'test') then result := TestList.new()
  else if (propName = 'teardown') then result := TFhirTestReportTeardown.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReport.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'testScript') then result := 'canonical'
  else if (propName = 'result') then result := 'code'
  else if (propName = 'score') then result := 'decimal'
  else if (propName = 'tester') then result := 'string'
  else if (propName = 'issued') then result := 'dateTime'
  else if (propName = 'participant') then result := 'BackboneElement'
  else if (propName = 'setup') then result := 'BackboneElement'
  else if (propName = 'test') then result := 'BackboneElement'
  else if (propName = 'teardown') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReport.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'testScript') then TestScriptElement := nil
  else if (propName = 'result') then ResultElement := nil
  else if (propName = 'score') then ScoreElement := nil
  else if (propName = 'tester') then TesterElement := nil
  else if (propName = 'issued') then IssuedElement := nil
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value)
  else if (propName = 'setup') then SetupElement := nil
  else if (propName = 'test') then deletePropertyValue('test', TestList, value)
  else if (propName = 'teardown') then TeardownElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReport.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirTestReportStatusEnum, CODES_TFhirTestReportStatusEnum, new)
  else if (propName = 'testScript') then TestScriptElement := asCanonical(new)
  else if (propName = 'result') then ResultElement := asEnum(SYSTEMS_TFhirTestReportResultEnum, CODES_TFhirTestReportResultEnum, new)
  else if (propName = 'score') then ScoreElement := asDecimal(new)
  else if (propName = 'tester') then TesterElement := asString(new)
  else if (propName = 'issued') then IssuedElement := asDateTime(new)
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new)
  else if (propName = 'setup') then SetupElement := new as TFhirTestReportSetup
  else if (propName = 'test') then replacePropertyValue('test', TestList, existing, new)
  else if (propName = 'teardown') then TeardownElement := new as TFhirTestReportTeardown
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReport.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'participant') then ParticipantList.move(source, destination)
  else if (propName = 'test') then TestList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReport.fhirType : string;
begin
  result := 'TestReport';
end;

function TFhirTestReport.Link : TFhirTestReport;
begin
  result := TFhirTestReport(inherited Link);
end;

function TFhirTestReport.Clone : TFhirTestReport;
begin
  result := TFhirTestReport(inherited Clone);
end;

function TFhirTestReport.equals(other : TObject) : boolean; 
var
  o : TFhirTestReport;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReport)) then
    result := false
  else
  begin
    o := TFhirTestReport(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(testScriptElement, o.testScriptElement, true) and 
      compareDeep(resultElement, o.resultElement, true) and compareDeep(scoreElement, o.scoreElement, true) and 
      compareDeep(testerElement, o.testerElement, true) and compareDeep(issuedElement, o.issuedElement, true) and 
      compareDeep(participantList, o.participantList, true) and compareDeep(setupElement, o.setupElement, true) and 
      compareDeep(testList, o.testList, true) and compareDeep(teardownElement, o.teardownElement, true);
  end;
end;

function TFhirTestReport.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FName) and isEmptyProp(FStatus) and isEmptyProp(FTestScript) and isEmptyProp(FResult) and isEmptyProp(FScore) and isEmptyProp(FTester) and isEmptyProp(FIssued) and isEmptyProp(FparticipantList) and isEmptyProp(FSetup) and isEmptyProp(FtestList) and isEmptyProp(FTeardown);
end;

procedure TFhirTestReport.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('name');
  fields.add('status');
  fields.add('testScript');
  fields.add('result');
  fields.add('score');
  fields.add('tester');
  fields.add('issued');
  fields.add('participant');
  fields.add('setup');
  fields.add('test');
  fields.add('teardown');
end;

function TFhirTestReport.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FParticipantList.sizeInBytes(magic));
  inc(result, FTestList.sizeInBytes(magic));
end;

procedure TFhirTestReport.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirTestReport.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirTestReport.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirTestReport.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirTestReport.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirTestReport.GetStatusST : TFhirTestReportStatusEnum;
begin
  if FStatus = nil then
    result := TFhirTestReportStatusEnum(0)
  else
    result := TFhirTestReportStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirTestReportStatusEnum, FStatus.value));
end;

procedure TFhirTestReport.SetStatusST(value : TFhirTestReportStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirTestReportStatusEnum[value], CODES_TFhirTestReportStatusEnum[value]);
end;

procedure TFhirTestReport.SetTestScript(value : TFhirCanonical);
begin
  FTestScript.free;
  FTestScript := value;
end;

function TFhirTestReport.GetTestScriptST : String;
begin
  if FTestScript = nil then
    result := ''
  else
    result := FTestScript.value;
end;

procedure TFhirTestReport.SetTestScriptST(value : String);
begin
  if value <> '' then
  begin
    if FTestScript = nil then
      FTestScript := TFhirCanonical.create;
    FTestScript.value := value
  end
  else if FTestScript <> nil then
    FTestScript.value := '';
end;

procedure TFhirTestReport.SetResult(value : TFhirEnum);
begin
  FResult.free;
  FResult := value;
end;

function TFhirTestReport.GetResultST : TFhirTestReportResultEnum;
begin
  if FResult = nil then
    result := TFhirTestReportResultEnum(0)
  else
    result := TFhirTestReportResultEnum(StringArrayIndexOfSensitive(CODES_TFhirTestReportResultEnum, FResult.value));
end;

procedure TFhirTestReport.SetResultST(value : TFhirTestReportResultEnum);
begin
  if ord(value) = 0 then
    ResultElement := nil
  else
    ResultElement := TFhirEnum.create(SYSTEMS_TFhirTestReportResultEnum[value], CODES_TFhirTestReportResultEnum[value]);
end;

procedure TFhirTestReport.SetScore(value : TFhirDecimal);
begin
  FScore.free;
  FScore := value;
end;

function TFhirTestReport.GetScoreST : String;
begin
  if FScore = nil then
    result := ''
  else
    result := FScore.value;
end;

procedure TFhirTestReport.SetScoreST(value : String);
begin
  if value <> '' then
  begin
    if FScore = nil then
      FScore := TFhirDecimal.create;
    FScore.value := value
  end
  else if FScore <> nil then
    FScore.value := '';
end;

procedure TFhirTestReport.SetTester(value : TFhirString);
begin
  FTester.free;
  FTester := value;
end;

function TFhirTestReport.GetTesterST : String;
begin
  if FTester = nil then
    result := ''
  else
    result := FTester.value;
end;

procedure TFhirTestReport.SetTesterST(value : String);
begin
  if value <> '' then
  begin
    if FTester = nil then
      FTester := TFhirString.create;
    FTester.value := value
  end
  else if FTester <> nil then
    FTester.value := '';
end;

procedure TFhirTestReport.SetIssued(value : TFhirDateTime);
begin
  FIssued.free;
  FIssued := value;
end;

function TFhirTestReport.GetIssuedST : TFslDateTime;
begin
  if FIssued = nil then
    result := TFslDateTime.makeNull
  else
    result := FIssued.value;
end;

procedure TFhirTestReport.SetIssuedST(value : TFslDateTime);
begin
  if FIssued = nil then
    FIssued := TFhirDateTime.create;
  FIssued.value := value
end;

function TFhirTestReport.GetParticipantList : TFhirTestReportParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirTestReportParticipantList.Create;
  result := FParticipantList;
end;

function TFhirTestReport.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

procedure TFhirTestReport.SetSetup(value : TFhirTestReportSetup);
begin
  FSetup.free;
  FSetup := value;
end;

function TFhirTestReport.GetTestList : TFhirTestReportTestList;
begin
  if FTestList = nil then
    FTestList := TFhirTestReportTestList.Create;
  result := FTestList;
end;

function TFhirTestReport.GetHasTestList : boolean;
begin
  result := (FTestList <> nil) and (FTestList.count > 0);
end;

procedure TFhirTestReport.SetTeardown(value : TFhirTestReportTeardown);
begin
  FTeardown.free;
  FTeardown := value;
end;

{ TFhirTestReportListEnumerator }

constructor TFhirTestReportListEnumerator.Create(list : TFhirTestReportList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportListEnumerator.GetCurrent : TFhirTestReport;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestReportList }

function TFhirTestReportList.AddItem(value: TFhirTestReport): TFhirTestReport;
begin
  assert(value.ClassName = 'TFhirTestReport', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReport');
  add(value);
  result := value;
end;

function TFhirTestReportList.Append: TFhirTestReport;
begin
  result := TFhirTestReport.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportList.GetEnumerator : TFhirTestReportListEnumerator;
begin
  result := TFhirTestReportListEnumerator.Create(self.link);
end;

function TFhirTestReportList.Clone: TFhirTestReportList;
begin
  result := TFhirTestReportList(inherited Clone);
end;

function TFhirTestReportList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportList.GetItemN(index: Integer): TFhirTestReport;
begin
  result := TFhirTestReport(ObjectByIndex[index]);
end;

function TFhirTestReportList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReport;
end;
function TFhirTestReportList.IndexOf(value: TFhirTestReport): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportList.Insert(index: Integer): TFhirTestReport;
begin
  result := TFhirTestReport.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportList.InsertItem(index: Integer; value: TFhirTestReport);
begin
  assert(value is TFhirTestReport);
  Inherited Insert(index, value);
end;

function TFhirTestReportList.Item(index: Integer): TFhirTestReport;
begin
  result := TFhirTestReport(ObjectByIndex[index]);
end;

function TFhirTestReportList.Link: TFhirTestReportList;
begin
  result := TFhirTestReportList(inherited Link);
end;

procedure TFhirTestReportList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportList.SetItemByIndex(index: Integer; value: TFhirTestReport);
begin
  assert(value is TFhirTestReport);
  FhirTestReports[index] := value;
end;

procedure TFhirTestReportList.SetItemN(index: Integer; value: TFhirTestReport);
begin
  assert(value is TFhirTestReport);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_VERIFICATIONRESULT}
{ TFhirVerificationResultPrimarySource }

constructor TFhirVerificationResultPrimarySource.Create;
begin
  inherited;
end;

destructor TFhirVerificationResultPrimarySource.Destroy;
begin
  FWho.free;
  FType_List.Free;
  FCommunicationMethodList.Free;
  FValidationStatus.free;
  FValidationDate.free;
  FCanPushUpdates.free;
  FPushTypeAvailableList.Free;
  inherited;
end;

procedure TFhirVerificationResultPrimarySource.Assign(oSource : TFslObject);
begin
  inherited;
  who := TFhirVerificationResultPrimarySource(oSource).who.Clone;
  if (TFhirVerificationResultPrimarySource(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirVerificationResultPrimarySource(oSource).FType_List);
  end;
  if (TFhirVerificationResultPrimarySource(oSource).FCommunicationMethodList = nil) then
  begin
    FCommunicationMethodList.free;
    FCommunicationMethodList := nil;
  end
  else
  begin
    if FCommunicationMethodList = nil then
      FCommunicationMethodList := TFhirCodeableConceptList.Create;
    FCommunicationMethodList.Assign(TFhirVerificationResultPrimarySource(oSource).FCommunicationMethodList);
  end;
  validationStatus := TFhirVerificationResultPrimarySource(oSource).validationStatus.Clone;
  validationDateElement := TFhirVerificationResultPrimarySource(oSource).validationDateElement.Clone;
  canPushUpdates := TFhirVerificationResultPrimarySource(oSource).canPushUpdates.Clone;
  if (TFhirVerificationResultPrimarySource(oSource).FPushTypeAvailableList = nil) then
  begin
    FPushTypeAvailableList.free;
    FPushTypeAvailableList := nil;
  end
  else
  begin
    if FPushTypeAvailableList = nil then
      FPushTypeAvailableList := TFhirCodeableConceptList.Create;
    FPushTypeAvailableList.Assign(TFhirVerificationResultPrimarySource(oSource).FPushTypeAvailableList);
  end;
end;

procedure TFhirVerificationResultPrimarySource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'who') Then
     list.add(self.link, 'who', FWho.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'communicationMethod') Then
    list.addAll(self, 'communicationMethod', FCommunicationMethodList);
  if (child_name = 'validationStatus') Then
     list.add(self.link, 'validationStatus', FValidationStatus.Link);
  if (child_name = 'validationDate') Then
     list.add(self.link, 'validationDate', FValidationDate.Link);
  if (child_name = 'canPushUpdates') Then
     list.add(self.link, 'canPushUpdates', FCanPushUpdates.Link);
  if (child_name = 'pushTypeAvailable') Then
    list.addAll(self, 'pushTypeAvailable', FPushTypeAvailableList);
end;

procedure TFhirVerificationResultPrimarySource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'who', 'Reference', false, TFhirReference, FWho.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
  oList.add(TFHIRProperty.create(self, 'communicationMethod', 'CodeableConcept', true, TFhirCodeableConcept, FCommunicationMethodList.Link));
  oList.add(TFHIRProperty.create(self, 'validationStatus', 'CodeableConcept', false, TFhirCodeableConcept, FValidationStatus.Link));
  oList.add(TFHIRProperty.create(self, 'validationDate', 'dateTime', false, TFhirDateTime, FValidationDate.Link));
  oList.add(TFHIRProperty.create(self, 'canPushUpdates', 'CodeableConcept', false, TFhirCodeableConcept, FCanPushUpdates.Link));
  oList.add(TFHIRProperty.create(self, 'pushTypeAvailable', 'CodeableConcept', true, TFhirCodeableConcept, FPushTypeAvailableList.Link));
end;

function TFhirVerificationResultPrimarySource.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'who') then
  begin
    Who := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'communicationMethod') then
  begin
    CommunicationMethodList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'validationStatus') then
  begin
    ValidationStatus := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'validationDate') then
  begin
    ValidationDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'canPushUpdates') then
  begin
    CanPushUpdates := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'pushTypeAvailable') then
  begin
    PushTypeAvailableList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirVerificationResultPrimarySource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'communicationMethod') then CommunicationMethodList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'pushTypeAvailable') then PushTypeAvailableList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirVerificationResultPrimarySource.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'who') then result := TFhirReference.create()
  else if (propName = 'type') then result := Type_List.new()
  else if (propName = 'communicationMethod') then result := CommunicationMethodList.new()
  else if (propName = 'validationStatus') then result := TFhirCodeableConcept.create()
  else if (propName = 'validationDate') then result := TFhirDateTime.create()
  else if (propName = 'canPushUpdates') then result := TFhirCodeableConcept.create()
  else if (propName = 'pushTypeAvailable') then result := PushTypeAvailableList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirVerificationResultPrimarySource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'who') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'communicationMethod') then result := 'CodeableConcept'
  else if (propName = 'validationStatus') then result := 'CodeableConcept'
  else if (propName = 'validationDate') then result := 'dateTime'
  else if (propName = 'canPushUpdates') then result := 'CodeableConcept'
  else if (propName = 'pushTypeAvailable') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirVerificationResultPrimarySource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'who') then WhoElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else if (propName = 'communicationMethod') then deletePropertyValue('communicationMethod', CommunicationMethodList, value)
  else if (propName = 'validationStatus') then ValidationStatusElement := nil
  else if (propName = 'validationDate') then ValidationDateElement := nil
  else if (propName = 'canPushUpdates') then CanPushUpdatesElement := nil
  else if (propName = 'pushTypeAvailable') then deletePropertyValue('pushTypeAvailable', PushTypeAvailableList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirVerificationResultPrimarySource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'who') then WhoElement := new as TFhirReference
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else if (propName = 'communicationMethod') then replacePropertyValue('communicationMethod', CommunicationMethodList, existing, new)
  else if (propName = 'validationStatus') then ValidationStatusElement := new as TFhirCodeableConcept
  else if (propName = 'validationDate') then ValidationDateElement := asDateTime(new)
  else if (propName = 'canPushUpdates') then CanPushUpdatesElement := new as TFhirCodeableConcept
  else if (propName = 'pushTypeAvailable') then replacePropertyValue('pushTypeAvailable', PushTypeAvailableList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirVerificationResultPrimarySource.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination)
  else if (propName = 'communicationMethod') then CommunicationMethodList.move(source, destination)
  else if (propName = 'pushTypeAvailable') then PushTypeAvailableList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirVerificationResultPrimarySource.fhirType : string;
begin
  result := 'VerificationResult.primarySource';
end;

function TFhirVerificationResultPrimarySource.Link : TFhirVerificationResultPrimarySource;
begin
  result := TFhirVerificationResultPrimarySource(inherited Link);
end;

function TFhirVerificationResultPrimarySource.Clone : TFhirVerificationResultPrimarySource;
begin
  result := TFhirVerificationResultPrimarySource(inherited Clone);
end;

function TFhirVerificationResultPrimarySource.equals(other : TObject) : boolean; 
var
  o : TFhirVerificationResultPrimarySource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirVerificationResultPrimarySource)) then
    result := false
  else
  begin
    o := TFhirVerificationResultPrimarySource(other);
    result := compareDeep(whoElement, o.whoElement, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(communicationMethodList, o.communicationMethodList, true) and compareDeep(validationStatusElement, o.validationStatusElement, true) and 
      compareDeep(validationDateElement, o.validationDateElement, true) and compareDeep(canPushUpdatesElement, o.canPushUpdatesElement, true) and 
      compareDeep(pushTypeAvailableList, o.pushTypeAvailableList, true);
  end;
end;

function TFhirVerificationResultPrimarySource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FWho) and isEmptyProp(Ftype_List) and isEmptyProp(FcommunicationMethodList) and isEmptyProp(FValidationStatus) and isEmptyProp(FValidationDate) and isEmptyProp(FCanPushUpdates) and isEmptyProp(FpushTypeAvailableList);
end;

procedure TFhirVerificationResultPrimarySource.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('who');
  fields.add('type');
  fields.add('communicationMethod');
  fields.add('validationStatus');
  fields.add('validationDate');
  fields.add('canPushUpdates');
  fields.add('pushTypeAvailable');
end;

function TFhirVerificationResultPrimarySource.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FType_List.sizeInBytes(magic));
  inc(result, FCommunicationMethodList.sizeInBytes(magic));
  inc(result, FPushTypeAvailableList.sizeInBytes(magic));
end;

procedure TFhirVerificationResultPrimarySource.SetWho(value : TFhirReference);
begin
  FWho.free;
  FWho := value;
end;

function TFhirVerificationResultPrimarySource.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirVerificationResultPrimarySource.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

function TFhirVerificationResultPrimarySource.GetCommunicationMethodList : TFhirCodeableConceptList;
begin
  if FCommunicationMethodList = nil then
    FCommunicationMethodList := TFhirCodeableConceptList.Create;
  result := FCommunicationMethodList;
end;

function TFhirVerificationResultPrimarySource.GetHasCommunicationMethodList : boolean;
begin
  result := (FCommunicationMethodList <> nil) and (FCommunicationMethodList.count > 0);
end;

procedure TFhirVerificationResultPrimarySource.SetValidationStatus(value : TFhirCodeableConcept);
begin
  FValidationStatus.free;
  FValidationStatus := value;
end;

procedure TFhirVerificationResultPrimarySource.SetValidationDate(value : TFhirDateTime);
begin
  FValidationDate.free;
  FValidationDate := value;
end;

function TFhirVerificationResultPrimarySource.GetValidationDateST : TFslDateTime;
begin
  if FValidationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FValidationDate.value;
end;

procedure TFhirVerificationResultPrimarySource.SetValidationDateST(value : TFslDateTime);
begin
  if FValidationDate = nil then
    FValidationDate := TFhirDateTime.create;
  FValidationDate.value := value
end;

procedure TFhirVerificationResultPrimarySource.SetCanPushUpdates(value : TFhirCodeableConcept);
begin
  FCanPushUpdates.free;
  FCanPushUpdates := value;
end;

function TFhirVerificationResultPrimarySource.GetPushTypeAvailableList : TFhirCodeableConceptList;
begin
  if FPushTypeAvailableList = nil then
    FPushTypeAvailableList := TFhirCodeableConceptList.Create;
  result := FPushTypeAvailableList;
end;

function TFhirVerificationResultPrimarySource.GetHasPushTypeAvailableList : boolean;
begin
  result := (FPushTypeAvailableList <> nil) and (FPushTypeAvailableList.count > 0);
end;

{ TFhirVerificationResultPrimarySourceListEnumerator }

constructor TFhirVerificationResultPrimarySourceListEnumerator.Create(list : TFhirVerificationResultPrimarySourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirVerificationResultPrimarySourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirVerificationResultPrimarySourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirVerificationResultPrimarySourceListEnumerator.GetCurrent : TFhirVerificationResultPrimarySource;
begin
  Result := FList[FIndex];
end;

function TFhirVerificationResultPrimarySourceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirVerificationResultPrimarySourceList }

function TFhirVerificationResultPrimarySourceList.AddItem(value: TFhirVerificationResultPrimarySource): TFhirVerificationResultPrimarySource;
begin
  assert(value.ClassName = 'TFhirVerificationResultPrimarySource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirVerificationResultPrimarySource');
  add(value);
  result := value;
end;

function TFhirVerificationResultPrimarySourceList.Append: TFhirVerificationResultPrimarySource;
begin
  result := TFhirVerificationResultPrimarySource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVerificationResultPrimarySourceList.ClearItems;
begin
  Clear;
end;

function TFhirVerificationResultPrimarySourceList.GetEnumerator : TFhirVerificationResultPrimarySourceListEnumerator;
begin
  result := TFhirVerificationResultPrimarySourceListEnumerator.Create(self.link);
end;

function TFhirVerificationResultPrimarySourceList.Clone: TFhirVerificationResultPrimarySourceList;
begin
  result := TFhirVerificationResultPrimarySourceList(inherited Clone);
end;

function TFhirVerificationResultPrimarySourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirVerificationResultPrimarySourceList.GetItemN(index: Integer): TFhirVerificationResultPrimarySource;
begin
  result := TFhirVerificationResultPrimarySource(ObjectByIndex[index]);
end;

function TFhirVerificationResultPrimarySourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirVerificationResultPrimarySource;
end;
function TFhirVerificationResultPrimarySourceList.IndexOf(value: TFhirVerificationResultPrimarySource): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirVerificationResultPrimarySourceList.Insert(index: Integer): TFhirVerificationResultPrimarySource;
begin
  result := TFhirVerificationResultPrimarySource.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVerificationResultPrimarySourceList.InsertItem(index: Integer; value: TFhirVerificationResultPrimarySource);
begin
  assert(value is TFhirVerificationResultPrimarySource);
  Inherited Insert(index, value);
end;

function TFhirVerificationResultPrimarySourceList.Item(index: Integer): TFhirVerificationResultPrimarySource;
begin
  result := TFhirVerificationResultPrimarySource(ObjectByIndex[index]);
end;

function TFhirVerificationResultPrimarySourceList.Link: TFhirVerificationResultPrimarySourceList;
begin
  result := TFhirVerificationResultPrimarySourceList(inherited Link);
end;

procedure TFhirVerificationResultPrimarySourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirVerificationResultPrimarySourceList.SetItemByIndex(index: Integer; value: TFhirVerificationResultPrimarySource);
begin
  assert(value is TFhirVerificationResultPrimarySource);
  FhirVerificationResultPrimarySources[index] := value;
end;

procedure TFhirVerificationResultPrimarySourceList.SetItemN(index: Integer; value: TFhirVerificationResultPrimarySource);
begin
  assert(value is TFhirVerificationResultPrimarySource);
  ObjectByIndex[index] := value;
end;

{ TFhirVerificationResultAttestation }

constructor TFhirVerificationResultAttestation.Create;
begin
  inherited;
end;

destructor TFhirVerificationResultAttestation.Destroy;
begin
  FWho.free;
  FOnBehalfOf.free;
  FCommunicationMethod.free;
  FDate.free;
  FSourceIdentityCertificate.free;
  FProxyIdentityCertificate.free;
  FProxySignature.free;
  FSourceSignature.free;
  inherited;
end;

procedure TFhirVerificationResultAttestation.Assign(oSource : TFslObject);
begin
  inherited;
  who := TFhirVerificationResultAttestation(oSource).who.Clone;
  onBehalfOf := TFhirVerificationResultAttestation(oSource).onBehalfOf.Clone;
  communicationMethod := TFhirVerificationResultAttestation(oSource).communicationMethod.Clone;
  dateElement := TFhirVerificationResultAttestation(oSource).dateElement.Clone;
  sourceIdentityCertificateElement := TFhirVerificationResultAttestation(oSource).sourceIdentityCertificateElement.Clone;
  proxyIdentityCertificateElement := TFhirVerificationResultAttestation(oSource).proxyIdentityCertificateElement.Clone;
  proxySignature := TFhirVerificationResultAttestation(oSource).proxySignature.Clone;
  sourceSignature := TFhirVerificationResultAttestation(oSource).sourceSignature.Clone;
end;

procedure TFhirVerificationResultAttestation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'who') Then
     list.add(self.link, 'who', FWho.Link);
  if (child_name = 'onBehalfOf') Then
     list.add(self.link, 'onBehalfOf', FOnBehalfOf.Link);
  if (child_name = 'communicationMethod') Then
     list.add(self.link, 'communicationMethod', FCommunicationMethod.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'sourceIdentityCertificate') Then
     list.add(self.link, 'sourceIdentityCertificate', FSourceIdentityCertificate.Link);
  if (child_name = 'proxyIdentityCertificate') Then
     list.add(self.link, 'proxyIdentityCertificate', FProxyIdentityCertificate.Link);
  if (child_name = 'proxySignature') Then
     list.add(self.link, 'proxySignature', FProxySignature.Link);
  if (child_name = 'sourceSignature') Then
     list.add(self.link, 'sourceSignature', FSourceSignature.Link);
end;

procedure TFhirVerificationResultAttestation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'who', 'Reference', false, TFhirReference, FWho.Link));
  oList.add(TFHIRProperty.create(self, 'onBehalfOf', 'Reference', false, TFhirReference, FOnBehalfOf.Link));
  oList.add(TFHIRProperty.create(self, 'communicationMethod', 'CodeableConcept', false, TFhirCodeableConcept, FCommunicationMethod.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'sourceIdentityCertificate', 'string', false, TFhirString, FSourceIdentityCertificate.Link));
  oList.add(TFHIRProperty.create(self, 'proxyIdentityCertificate', 'string', false, TFhirString, FProxyIdentityCertificate.Link));
  oList.add(TFHIRProperty.create(self, 'proxySignature', 'Signature', false, TFhirSignature, FProxySignature.Link));
  oList.add(TFHIRProperty.create(self, 'sourceSignature', 'Signature', false, TFhirSignature, FSourceSignature.Link));
end;

function TFhirVerificationResultAttestation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'who') then
  begin
    Who := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'onBehalfOf') then
  begin
    OnBehalfOf := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'communicationMethod') then
  begin
    CommunicationMethod := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'sourceIdentityCertificate') then
  begin
    SourceIdentityCertificateElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'proxyIdentityCertificate') then
  begin
    ProxyIdentityCertificateElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'proxySignature') then
  begin
    ProxySignature := propValue as TFhirSignature;
    result := propValue;
  end
  else if (propName = 'sourceSignature') then
  begin
    SourceSignature := propValue as TFhirSignature;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirVerificationResultAttestation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirVerificationResultAttestation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'who') then result := TFhirReference.create()
  else if (propName = 'onBehalfOf') then result := TFhirReference.create()
  else if (propName = 'communicationMethod') then result := TFhirCodeableConcept.create()
  else if (propName = 'date') then result := TFhirDate.create()
  else if (propName = 'sourceIdentityCertificate') then result := TFhirString.create()
  else if (propName = 'proxyIdentityCertificate') then result := TFhirString.create()
  else if (propName = 'proxySignature') then result := TFhirSignature.create()
  else if (propName = 'sourceSignature') then result := TFhirSignature.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirVerificationResultAttestation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'who') then result := 'Reference'
  else if (propName = 'onBehalfOf') then result := 'Reference'
  else if (propName = 'communicationMethod') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'date'
  else if (propName = 'sourceIdentityCertificate') then result := 'string'
  else if (propName = 'proxyIdentityCertificate') then result := 'string'
  else if (propName = 'proxySignature') then result := 'Signature'
  else if (propName = 'sourceSignature') then result := 'Signature'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirVerificationResultAttestation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'who') then WhoElement := nil
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := nil
  else if (propName = 'communicationMethod') then CommunicationMethodElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'sourceIdentityCertificate') then SourceIdentityCertificateElement := nil
  else if (propName = 'proxyIdentityCertificate') then ProxyIdentityCertificateElement := nil
  else if (propName = 'proxySignature') then ProxySignatureElement := nil
  else if (propName = 'sourceSignature') then SourceSignatureElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirVerificationResultAttestation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'who') then WhoElement := new as TFhirReference
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := new as TFhirReference
  else if (propName = 'communicationMethod') then CommunicationMethodElement := new as TFhirCodeableConcept
  else if (propName = 'date') then DateElement := asDate(new)
  else if (propName = 'sourceIdentityCertificate') then SourceIdentityCertificateElement := asString(new)
  else if (propName = 'proxyIdentityCertificate') then ProxyIdentityCertificateElement := asString(new)
  else if (propName = 'proxySignature') then ProxySignatureElement := new as TFhirSignature
  else if (propName = 'sourceSignature') then SourceSignatureElement := new as TFhirSignature
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirVerificationResultAttestation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirVerificationResultAttestation.fhirType : string;
begin
  result := 'VerificationResult.attestation';
end;

function TFhirVerificationResultAttestation.Link : TFhirVerificationResultAttestation;
begin
  result := TFhirVerificationResultAttestation(inherited Link);
end;

function TFhirVerificationResultAttestation.Clone : TFhirVerificationResultAttestation;
begin
  result := TFhirVerificationResultAttestation(inherited Clone);
end;

function TFhirVerificationResultAttestation.equals(other : TObject) : boolean; 
var
  o : TFhirVerificationResultAttestation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirVerificationResultAttestation)) then
    result := false
  else
  begin
    o := TFhirVerificationResultAttestation(other);
    result := compareDeep(whoElement, o.whoElement, true) and compareDeep(onBehalfOfElement, o.onBehalfOfElement, true) and 
      compareDeep(communicationMethodElement, o.communicationMethodElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(sourceIdentityCertificateElement, o.sourceIdentityCertificateElement, true) and 
      compareDeep(proxyIdentityCertificateElement, o.proxyIdentityCertificateElement, true) and 
      compareDeep(proxySignatureElement, o.proxySignatureElement, true) and compareDeep(sourceSignatureElement, o.sourceSignatureElement, true);
  end;
end;

function TFhirVerificationResultAttestation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FWho) and isEmptyProp(FOnBehalfOf) and isEmptyProp(FCommunicationMethod) and isEmptyProp(FDate) and isEmptyProp(FSourceIdentityCertificate) and isEmptyProp(FProxyIdentityCertificate) and isEmptyProp(FProxySignature) and isEmptyProp(FSourceSignature);
end;

procedure TFhirVerificationResultAttestation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('who');
  fields.add('onBehalfOf');
  fields.add('communicationMethod');
  fields.add('date');
  fields.add('sourceIdentityCertificate');
  fields.add('proxyIdentityCertificate');
  fields.add('proxySignature');
  fields.add('sourceSignature');
end;

function TFhirVerificationResultAttestation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirVerificationResultAttestation.SetWho(value : TFhirReference);
begin
  FWho.free;
  FWho := value;
end;

procedure TFhirVerificationResultAttestation.SetOnBehalfOf(value : TFhirReference);
begin
  FOnBehalfOf.free;
  FOnBehalfOf := value;
end;

procedure TFhirVerificationResultAttestation.SetCommunicationMethod(value : TFhirCodeableConcept);
begin
  FCommunicationMethod.free;
  FCommunicationMethod := value;
end;

procedure TFhirVerificationResultAttestation.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value;
end;

function TFhirVerificationResultAttestation.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirVerificationResultAttestation.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

procedure TFhirVerificationResultAttestation.SetSourceIdentityCertificate(value : TFhirString);
begin
  FSourceIdentityCertificate.free;
  FSourceIdentityCertificate := value;
end;

function TFhirVerificationResultAttestation.GetSourceIdentityCertificateST : String;
begin
  if FSourceIdentityCertificate = nil then
    result := ''
  else
    result := FSourceIdentityCertificate.value;
end;

procedure TFhirVerificationResultAttestation.SetSourceIdentityCertificateST(value : String);
begin
  if value <> '' then
  begin
    if FSourceIdentityCertificate = nil then
      FSourceIdentityCertificate := TFhirString.create;
    FSourceIdentityCertificate.value := value
  end
  else if FSourceIdentityCertificate <> nil then
    FSourceIdentityCertificate.value := '';
end;

procedure TFhirVerificationResultAttestation.SetProxyIdentityCertificate(value : TFhirString);
begin
  FProxyIdentityCertificate.free;
  FProxyIdentityCertificate := value;
end;

function TFhirVerificationResultAttestation.GetProxyIdentityCertificateST : String;
begin
  if FProxyIdentityCertificate = nil then
    result := ''
  else
    result := FProxyIdentityCertificate.value;
end;

procedure TFhirVerificationResultAttestation.SetProxyIdentityCertificateST(value : String);
begin
  if value <> '' then
  begin
    if FProxyIdentityCertificate = nil then
      FProxyIdentityCertificate := TFhirString.create;
    FProxyIdentityCertificate.value := value
  end
  else if FProxyIdentityCertificate <> nil then
    FProxyIdentityCertificate.value := '';
end;

procedure TFhirVerificationResultAttestation.SetProxySignature(value : TFhirSignature);
begin
  FProxySignature.free;
  FProxySignature := value;
end;

procedure TFhirVerificationResultAttestation.SetSourceSignature(value : TFhirSignature);
begin
  FSourceSignature.free;
  FSourceSignature := value;
end;

{ TFhirVerificationResultAttestationListEnumerator }

constructor TFhirVerificationResultAttestationListEnumerator.Create(list : TFhirVerificationResultAttestationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirVerificationResultAttestationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirVerificationResultAttestationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirVerificationResultAttestationListEnumerator.GetCurrent : TFhirVerificationResultAttestation;
begin
  Result := FList[FIndex];
end;

function TFhirVerificationResultAttestationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirVerificationResultAttestationList }

function TFhirVerificationResultAttestationList.AddItem(value: TFhirVerificationResultAttestation): TFhirVerificationResultAttestation;
begin
  assert(value.ClassName = 'TFhirVerificationResultAttestation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirVerificationResultAttestation');
  add(value);
  result := value;
end;

function TFhirVerificationResultAttestationList.Append: TFhirVerificationResultAttestation;
begin
  result := TFhirVerificationResultAttestation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVerificationResultAttestationList.ClearItems;
begin
  Clear;
end;

function TFhirVerificationResultAttestationList.GetEnumerator : TFhirVerificationResultAttestationListEnumerator;
begin
  result := TFhirVerificationResultAttestationListEnumerator.Create(self.link);
end;

function TFhirVerificationResultAttestationList.Clone: TFhirVerificationResultAttestationList;
begin
  result := TFhirVerificationResultAttestationList(inherited Clone);
end;

function TFhirVerificationResultAttestationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirVerificationResultAttestationList.GetItemN(index: Integer): TFhirVerificationResultAttestation;
begin
  result := TFhirVerificationResultAttestation(ObjectByIndex[index]);
end;

function TFhirVerificationResultAttestationList.ItemClass: TFslObjectClass;
begin
  result := TFhirVerificationResultAttestation;
end;
function TFhirVerificationResultAttestationList.IndexOf(value: TFhirVerificationResultAttestation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirVerificationResultAttestationList.Insert(index: Integer): TFhirVerificationResultAttestation;
begin
  result := TFhirVerificationResultAttestation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVerificationResultAttestationList.InsertItem(index: Integer; value: TFhirVerificationResultAttestation);
begin
  assert(value is TFhirVerificationResultAttestation);
  Inherited Insert(index, value);
end;

function TFhirVerificationResultAttestationList.Item(index: Integer): TFhirVerificationResultAttestation;
begin
  result := TFhirVerificationResultAttestation(ObjectByIndex[index]);
end;

function TFhirVerificationResultAttestationList.Link: TFhirVerificationResultAttestationList;
begin
  result := TFhirVerificationResultAttestationList(inherited Link);
end;

procedure TFhirVerificationResultAttestationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirVerificationResultAttestationList.SetItemByIndex(index: Integer; value: TFhirVerificationResultAttestation);
begin
  assert(value is TFhirVerificationResultAttestation);
  FhirVerificationResultAttestations[index] := value;
end;

procedure TFhirVerificationResultAttestationList.SetItemN(index: Integer; value: TFhirVerificationResultAttestation);
begin
  assert(value is TFhirVerificationResultAttestation);
  ObjectByIndex[index] := value;
end;

{ TFhirVerificationResultValidator }

constructor TFhirVerificationResultValidator.Create;
begin
  inherited;
end;

destructor TFhirVerificationResultValidator.Destroy;
begin
  FOrganization.free;
  FIdentityCertificate.free;
  FAttestationSignature.free;
  inherited;
end;

procedure TFhirVerificationResultValidator.Assign(oSource : TFslObject);
begin
  inherited;
  organization := TFhirVerificationResultValidator(oSource).organization.Clone;
  identityCertificateElement := TFhirVerificationResultValidator(oSource).identityCertificateElement.Clone;
  attestationSignature := TFhirVerificationResultValidator(oSource).attestationSignature.Clone;
end;

procedure TFhirVerificationResultValidator.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'identityCertificate') Then
     list.add(self.link, 'identityCertificate', FIdentityCertificate.Link);
  if (child_name = 'attestationSignature') Then
     list.add(self.link, 'attestationSignature', FAttestationSignature.Link);
end;

procedure TFhirVerificationResultValidator.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference', false, TFhirReference, FOrganization.Link));
  oList.add(TFHIRProperty.create(self, 'identityCertificate', 'string', false, TFhirString, FIdentityCertificate.Link));
  oList.add(TFHIRProperty.create(self, 'attestationSignature', 'Signature', false, TFhirSignature, FAttestationSignature.Link));
end;

function TFhirVerificationResultValidator.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'identityCertificate') then
  begin
    IdentityCertificateElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'attestationSignature') then
  begin
    AttestationSignature := propValue as TFhirSignature;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirVerificationResultValidator.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirVerificationResultValidator.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'organization') then result := TFhirReference.create()
  else if (propName = 'identityCertificate') then result := TFhirString.create()
  else if (propName = 'attestationSignature') then result := TFhirSignature.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirVerificationResultValidator.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'organization') then result := 'Reference'
  else if (propName = 'identityCertificate') then result := 'string'
  else if (propName = 'attestationSignature') then result := 'Signature'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirVerificationResultValidator.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'identityCertificate') then IdentityCertificateElement := nil
  else if (propName = 'attestationSignature') then AttestationSignatureElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirVerificationResultValidator.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'organization') then OrganizationElement := new as TFhirReference
  else if (propName = 'identityCertificate') then IdentityCertificateElement := asString(new)
  else if (propName = 'attestationSignature') then AttestationSignatureElement := new as TFhirSignature
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirVerificationResultValidator.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirVerificationResultValidator.fhirType : string;
begin
  result := 'VerificationResult.validator';
end;

function TFhirVerificationResultValidator.Link : TFhirVerificationResultValidator;
begin
  result := TFhirVerificationResultValidator(inherited Link);
end;

function TFhirVerificationResultValidator.Clone : TFhirVerificationResultValidator;
begin
  result := TFhirVerificationResultValidator(inherited Clone);
end;

function TFhirVerificationResultValidator.equals(other : TObject) : boolean; 
var
  o : TFhirVerificationResultValidator;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirVerificationResultValidator)) then
    result := false
  else
  begin
    o := TFhirVerificationResultValidator(other);
    result := compareDeep(organizationElement, o.organizationElement, true) and 
      compareDeep(identityCertificateElement, o.identityCertificateElement, true) and 
      compareDeep(attestationSignatureElement, o.attestationSignatureElement, true);
  end;
end;

function TFhirVerificationResultValidator.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOrganization) and isEmptyProp(FIdentityCertificate) and isEmptyProp(FAttestationSignature);
end;

procedure TFhirVerificationResultValidator.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('organization');
  fields.add('identityCertificate');
  fields.add('attestationSignature');
end;

function TFhirVerificationResultValidator.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirVerificationResultValidator.SetOrganization(value : TFhirReference);
begin
  FOrganization.free;
  FOrganization := value;
end;

procedure TFhirVerificationResultValidator.SetIdentityCertificate(value : TFhirString);
begin
  FIdentityCertificate.free;
  FIdentityCertificate := value;
end;

function TFhirVerificationResultValidator.GetIdentityCertificateST : String;
begin
  if FIdentityCertificate = nil then
    result := ''
  else
    result := FIdentityCertificate.value;
end;

procedure TFhirVerificationResultValidator.SetIdentityCertificateST(value : String);
begin
  if value <> '' then
  begin
    if FIdentityCertificate = nil then
      FIdentityCertificate := TFhirString.create;
    FIdentityCertificate.value := value
  end
  else if FIdentityCertificate <> nil then
    FIdentityCertificate.value := '';
end;

procedure TFhirVerificationResultValidator.SetAttestationSignature(value : TFhirSignature);
begin
  FAttestationSignature.free;
  FAttestationSignature := value;
end;

{ TFhirVerificationResultValidatorListEnumerator }

constructor TFhirVerificationResultValidatorListEnumerator.Create(list : TFhirVerificationResultValidatorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirVerificationResultValidatorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirVerificationResultValidatorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirVerificationResultValidatorListEnumerator.GetCurrent : TFhirVerificationResultValidator;
begin
  Result := FList[FIndex];
end;

function TFhirVerificationResultValidatorListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirVerificationResultValidatorList }

function TFhirVerificationResultValidatorList.AddItem(value: TFhirVerificationResultValidator): TFhirVerificationResultValidator;
begin
  assert(value.ClassName = 'TFhirVerificationResultValidator', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirVerificationResultValidator');
  add(value);
  result := value;
end;

function TFhirVerificationResultValidatorList.Append: TFhirVerificationResultValidator;
begin
  result := TFhirVerificationResultValidator.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVerificationResultValidatorList.ClearItems;
begin
  Clear;
end;

function TFhirVerificationResultValidatorList.GetEnumerator : TFhirVerificationResultValidatorListEnumerator;
begin
  result := TFhirVerificationResultValidatorListEnumerator.Create(self.link);
end;

function TFhirVerificationResultValidatorList.Clone: TFhirVerificationResultValidatorList;
begin
  result := TFhirVerificationResultValidatorList(inherited Clone);
end;

function TFhirVerificationResultValidatorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirVerificationResultValidatorList.GetItemN(index: Integer): TFhirVerificationResultValidator;
begin
  result := TFhirVerificationResultValidator(ObjectByIndex[index]);
end;

function TFhirVerificationResultValidatorList.ItemClass: TFslObjectClass;
begin
  result := TFhirVerificationResultValidator;
end;
function TFhirVerificationResultValidatorList.IndexOf(value: TFhirVerificationResultValidator): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirVerificationResultValidatorList.Insert(index: Integer): TFhirVerificationResultValidator;
begin
  result := TFhirVerificationResultValidator.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVerificationResultValidatorList.InsertItem(index: Integer; value: TFhirVerificationResultValidator);
begin
  assert(value is TFhirVerificationResultValidator);
  Inherited Insert(index, value);
end;

function TFhirVerificationResultValidatorList.Item(index: Integer): TFhirVerificationResultValidator;
begin
  result := TFhirVerificationResultValidator(ObjectByIndex[index]);
end;

function TFhirVerificationResultValidatorList.Link: TFhirVerificationResultValidatorList;
begin
  result := TFhirVerificationResultValidatorList(inherited Link);
end;

procedure TFhirVerificationResultValidatorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirVerificationResultValidatorList.SetItemByIndex(index: Integer; value: TFhirVerificationResultValidator);
begin
  assert(value is TFhirVerificationResultValidator);
  FhirVerificationResultValidators[index] := value;
end;

procedure TFhirVerificationResultValidatorList.SetItemN(index: Integer; value: TFhirVerificationResultValidator);
begin
  assert(value is TFhirVerificationResultValidator);
  ObjectByIndex[index] := value;
end;

{ TFhirVerificationResult }

constructor TFhirVerificationResult.Create;
begin
  inherited;
end;

destructor TFhirVerificationResult.Destroy;
begin
  FTargetList.Free;
  FTargetLocationList.Free;
  FNeed.free;
  FStatus.free;
  FStatusDate.free;
  FValidationType.free;
  FValidationProcessList.Free;
  FFrequency.free;
  FLastPerformed.free;
  FNextScheduled.free;
  FFailureAction.free;
  FPrimarySourceList.Free;
  FAttestation.free;
  FValidatorList.Free;
  inherited;
end;

procedure TFhirVerificationResult.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirVerificationResult(oSource).FTargetList = nil) then
  begin
    FTargetList.free;
    FTargetList := nil;
  end
  else
  begin
    if FTargetList = nil then
      FTargetList := TFhirReferenceList.Create;
    FTargetList.Assign(TFhirVerificationResult(oSource).FTargetList);
  end;
  if (TFhirVerificationResult(oSource).FTargetLocationList = nil) then
  begin
    FTargetLocationList.free;
    FTargetLocationList := nil;
  end
  else
  begin
    if FTargetLocationList = nil then
      FTargetLocationList := TFhirStringList.Create;
    FTargetLocationList.Assign(TFhirVerificationResult(oSource).FTargetLocationList);
  end;
  need := TFhirVerificationResult(oSource).need.Clone;
  statusElement := TFhirVerificationResult(oSource).statusElement.Clone;
  statusDateElement := TFhirVerificationResult(oSource).statusDateElement.Clone;
  validationType := TFhirVerificationResult(oSource).validationType.Clone;
  if (TFhirVerificationResult(oSource).FValidationProcessList = nil) then
  begin
    FValidationProcessList.free;
    FValidationProcessList := nil;
  end
  else
  begin
    if FValidationProcessList = nil then
      FValidationProcessList := TFhirCodeableConceptList.Create;
    FValidationProcessList.Assign(TFhirVerificationResult(oSource).FValidationProcessList);
  end;
  frequency := TFhirVerificationResult(oSource).frequency.Clone;
  lastPerformedElement := TFhirVerificationResult(oSource).lastPerformedElement.Clone;
  nextScheduledElement := TFhirVerificationResult(oSource).nextScheduledElement.Clone;
  failureAction := TFhirVerificationResult(oSource).failureAction.Clone;
  if (TFhirVerificationResult(oSource).FPrimarySourceList = nil) then
  begin
    FPrimarySourceList.free;
    FPrimarySourceList := nil;
  end
  else
  begin
    if FPrimarySourceList = nil then
      FPrimarySourceList := TFhirVerificationResultPrimarySourceList.Create;
    FPrimarySourceList.Assign(TFhirVerificationResult(oSource).FPrimarySourceList);
  end;
  attestation := TFhirVerificationResult(oSource).attestation.Clone;
  if (TFhirVerificationResult(oSource).FValidatorList = nil) then
  begin
    FValidatorList.free;
    FValidatorList := nil;
  end
  else
  begin
    if FValidatorList = nil then
      FValidatorList := TFhirVerificationResultValidatorList.Create;
    FValidatorList.Assign(TFhirVerificationResult(oSource).FValidatorList);
  end;
end;

function TFhirVerificationResult.GetResourceType : TFhirResourceType;
begin
  result := frtVerificationResult;
end;

procedure TFhirVerificationResult.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'target') Then
    list.addAll(self, 'target', FTargetList);
  if (child_name = 'targetLocation') Then
    list.addAll(self, 'targetLocation', FTargetLocationList);
  if (child_name = 'need') Then
     list.add(self.link, 'need', FNeed.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusDate') Then
     list.add(self.link, 'statusDate', FStatusDate.Link);
  if (child_name = 'validationType') Then
     list.add(self.link, 'validationType', FValidationType.Link);
  if (child_name = 'validationProcess') Then
    list.addAll(self, 'validationProcess', FValidationProcessList);
  if (child_name = 'frequency') Then
     list.add(self.link, 'frequency', FFrequency.Link);
  if (child_name = 'lastPerformed') Then
     list.add(self.link, 'lastPerformed', FLastPerformed.Link);
  if (child_name = 'nextScheduled') Then
     list.add(self.link, 'nextScheduled', FNextScheduled.Link);
  if (child_name = 'failureAction') Then
     list.add(self.link, 'failureAction', FFailureAction.Link);
  if (child_name = 'primarySource') Then
    list.addAll(self, 'primarySource', FPrimarySourceList);
  if (child_name = 'attestation') Then
     list.add(self.link, 'attestation', FAttestation.Link);
  if (child_name = 'validator') Then
    list.addAll(self, 'validator', FValidatorList);
end;

procedure TFhirVerificationResult.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'target', 'Reference', true, TFhirReference, FTargetList.Link));
  oList.add(TFHIRProperty.create(self, 'targetLocation', 'string', true, TFhirString, FTargetLocationList.Link));
  oList.add(TFHIRProperty.create(self, 'need', 'CodeableConcept', false, TFhirCodeableConcept, FNeed.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusDate', 'dateTime', false, TFhirDateTime, FStatusDate.Link));
  oList.add(TFHIRProperty.create(self, 'validationType', 'CodeableConcept', false, TFhirCodeableConcept, FValidationType.Link));
  oList.add(TFHIRProperty.create(self, 'validationProcess', 'CodeableConcept', true, TFhirCodeableConcept, FValidationProcessList.Link));
  oList.add(TFHIRProperty.create(self, 'frequency', 'Timing', false, TFhirTiming, FFrequency.Link));
  oList.add(TFHIRProperty.create(self, 'lastPerformed', 'dateTime', false, TFhirDateTime, FLastPerformed.Link));
  oList.add(TFHIRProperty.create(self, 'nextScheduled', 'date', false, TFhirDate, FNextScheduled.Link));
  oList.add(TFHIRProperty.create(self, 'failureAction', 'CodeableConcept', false, TFhirCodeableConcept, FFailureAction.Link));
  oList.add(TFHIRProperty.create(self, 'primarySource', 'BackboneElement', true, TFhirVerificationResultPrimarySource, FPrimarySourceList.Link));
  oList.add(TFHIRProperty.create(self, 'attestation', 'BackboneElement', false, TFhirVerificationResultAttestation, FAttestation.Link));
  oList.add(TFHIRProperty.create(self, 'validator', 'BackboneElement', true, TFhirVerificationResultValidator, FValidatorList.Link));
end;

function TFhirVerificationResult.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'target') then
  begin
    TargetList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'targetLocation') then
  begin
    TargetLocationList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'need') then
  begin
    Need := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirStatusEnum, CODES_TFhirStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'statusDate') then
  begin
    StatusDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'validationType') then
  begin
    ValidationType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'validationProcess') then
  begin
    ValidationProcessList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'frequency') then
  begin
    Frequency := propValue as TFhirTiming;
    result := propValue;
  end
  else if (propName = 'lastPerformed') then
  begin
    LastPerformedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'nextScheduled') then
  begin
    NextScheduledElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'failureAction') then
  begin
    FailureAction := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'primarySource') then
  begin
    PrimarySourceList.add(propValue as TFhirVerificationResultPrimarySource);
    result := propValue;
  end
  else if (propName = 'attestation') then
  begin
    Attestation := propValue as TFhirVerificationResultAttestation;
    result := propValue;
  end
  else if (propName = 'validator') then
  begin
    ValidatorList.add(propValue as TFhirVerificationResultValidator);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirVerificationResult.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'target') then TargetList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'targetLocation') then TargetLocationList.insertItem(index, asString(propValue))
  else if (propName = 'validationProcess') then ValidationProcessList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'primarySource') then PrimarySourceList.insertItem(index, propValue as TFhirVerificationResultPrimarySource)
  else if (propName = 'validator') then ValidatorList.insertItem(index, propValue as TFhirVerificationResultValidator)
  else inherited;
end;

function TFhirVerificationResult.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'target') then result := TargetList.new()
  else if (propName = 'targetLocation') then result := TargetLocationList.new()
  else if (propName = 'need') then result := TFhirCodeableConcept.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirStatusEnum[StatusNull], CODES_TFhirStatusEnum[StatusNull]) 
  else if (propName = 'statusDate') then result := TFhirDateTime.create()
  else if (propName = 'validationType') then result := TFhirCodeableConcept.create()
  else if (propName = 'validationProcess') then result := ValidationProcessList.new()
  else if (propName = 'frequency') then result := TFhirTiming.create()
  else if (propName = 'lastPerformed') then result := TFhirDateTime.create()
  else if (propName = 'nextScheduled') then result := TFhirDate.create()
  else if (propName = 'failureAction') then result := TFhirCodeableConcept.create()
  else if (propName = 'primarySource') then result := PrimarySourceList.new()
  else if (propName = 'attestation') then result := TFhirVerificationResultAttestation.create()
  else if (propName = 'validator') then result := ValidatorList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirVerificationResult.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'target') then result := 'Reference'
  else if (propName = 'targetLocation') then result := 'string'
  else if (propName = 'need') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusDate') then result := 'dateTime'
  else if (propName = 'validationType') then result := 'CodeableConcept'
  else if (propName = 'validationProcess') then result := 'CodeableConcept'
  else if (propName = 'frequency') then result := 'Timing'
  else if (propName = 'lastPerformed') then result := 'dateTime'
  else if (propName = 'nextScheduled') then result := 'date'
  else if (propName = 'failureAction') then result := 'CodeableConcept'
  else if (propName = 'primarySource') then result := 'BackboneElement'
  else if (propName = 'attestation') then result := 'BackboneElement'
  else if (propName = 'validator') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirVerificationResult.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'target') then deletePropertyValue('target', TargetList, value)
  else if (propName = 'targetLocation') then deletePropertyValue('targetLocation', TargetLocationList, value)
  else if (propName = 'need') then NeedElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusDate') then StatusDateElement := nil
  else if (propName = 'validationType') then ValidationTypeElement := nil
  else if (propName = 'validationProcess') then deletePropertyValue('validationProcess', ValidationProcessList, value)
  else if (propName = 'frequency') then FrequencyElement := nil
  else if (propName = 'lastPerformed') then LastPerformedElement := nil
  else if (propName = 'nextScheduled') then NextScheduledElement := nil
  else if (propName = 'failureAction') then FailureActionElement := nil
  else if (propName = 'primarySource') then deletePropertyValue('primarySource', PrimarySourceList, value)
  else if (propName = 'attestation') then AttestationElement := nil
  else if (propName = 'validator') then deletePropertyValue('validator', ValidatorList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirVerificationResult.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'target') then replacePropertyValue('target', TargetList, existing, new)
  else if (propName = 'targetLocation') then replacePropertyValue('targetLocation', TargetLocationList, existing, new)
  else if (propName = 'need') then NeedElement := new as TFhirCodeableConcept
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirStatusEnum, CODES_TFhirStatusEnum, new)
  else if (propName = 'statusDate') then StatusDateElement := asDateTime(new)
  else if (propName = 'validationType') then ValidationTypeElement := new as TFhirCodeableConcept
  else if (propName = 'validationProcess') then replacePropertyValue('validationProcess', ValidationProcessList, existing, new)
  else if (propName = 'frequency') then FrequencyElement := new as TFhirTiming
  else if (propName = 'lastPerformed') then LastPerformedElement := asDateTime(new)
  else if (propName = 'nextScheduled') then NextScheduledElement := asDate(new)
  else if (propName = 'failureAction') then FailureActionElement := new as TFhirCodeableConcept
  else if (propName = 'primarySource') then replacePropertyValue('primarySource', PrimarySourceList, existing, new)
  else if (propName = 'attestation') then AttestationElement := new as TFhirVerificationResultAttestation
  else if (propName = 'validator') then replacePropertyValue('validator', ValidatorList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirVerificationResult.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'target') then TargetList.move(source, destination)
  else if (propName = 'targetLocation') then TargetLocationList.move(source, destination)
  else if (propName = 'validationProcess') then ValidationProcessList.move(source, destination)
  else if (propName = 'primarySource') then PrimarySourceList.move(source, destination)
  else if (propName = 'validator') then ValidatorList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirVerificationResult.fhirType : string;
begin
  result := 'VerificationResult';
end;

function TFhirVerificationResult.Link : TFhirVerificationResult;
begin
  result := TFhirVerificationResult(inherited Link);
end;

function TFhirVerificationResult.Clone : TFhirVerificationResult;
begin
  result := TFhirVerificationResult(inherited Clone);
end;

function TFhirVerificationResult.equals(other : TObject) : boolean; 
var
  o : TFhirVerificationResult;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirVerificationResult)) then
    result := false
  else
  begin
    o := TFhirVerificationResult(other);
    result := compareDeep(targetList, o.targetList, true) and compareDeep(targetLocationList, o.targetLocationList, true) and 
      compareDeep(needElement, o.needElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusDateElement, o.statusDateElement, true) and compareDeep(validationTypeElement, o.validationTypeElement, true) and 
      compareDeep(validationProcessList, o.validationProcessList, true) and compareDeep(frequencyElement, o.frequencyElement, true) and 
      compareDeep(lastPerformedElement, o.lastPerformedElement, true) and compareDeep(nextScheduledElement, o.nextScheduledElement, true) and 
      compareDeep(failureActionElement, o.failureActionElement, true) and compareDeep(primarySourceList, o.primarySourceList, true) and 
      compareDeep(attestationElement, o.attestationElement, true) and compareDeep(validatorList, o.validatorList, true);
  end;
end;

function TFhirVerificationResult.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FtargetList) and isEmptyProp(FtargetLocationList) and isEmptyProp(FNeed) and isEmptyProp(FStatus) and isEmptyProp(FStatusDate) and isEmptyProp(FValidationType) and isEmptyProp(FvalidationProcessList) and isEmptyProp(FFrequency) and isEmptyProp(FLastPerformed) and isEmptyProp(FNextScheduled) and isEmptyProp(FFailureAction) and isEmptyProp(FprimarySourceList) and isEmptyProp(FAttestation) and isEmptyProp(FvalidatorList);
end;

procedure TFhirVerificationResult.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('target');
  fields.add('targetLocation');
  fields.add('need');
  fields.add('status');
  fields.add('statusDate');
  fields.add('validationType');
  fields.add('validationProcess');
  fields.add('frequency');
  fields.add('lastPerformed');
  fields.add('nextScheduled');
  fields.add('failureAction');
  fields.add('primarySource');
  fields.add('attestation');
  fields.add('validator');
end;

function TFhirVerificationResult.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FTargetList.sizeInBytes(magic));
  inc(result, FTargetLocationList.sizeInBytes(magic));
  inc(result, FValidationProcessList.sizeInBytes(magic));
  inc(result, FPrimarySourceList.sizeInBytes(magic));
  inc(result, FValidatorList.sizeInBytes(magic));
end;

function TFhirVerificationResult.GetTargetList : TFhirReferenceList;
begin
  if FTargetList = nil then
    FTargetList := TFhirReferenceList.Create;
  result := FTargetList;
end;

function TFhirVerificationResult.GetHasTargetList : boolean;
begin
  result := (FTargetList <> nil) and (FTargetList.count > 0);
end;

function TFhirVerificationResult.GetTargetLocationList : TFhirStringList;
begin
  if FTargetLocationList = nil then
    FTargetLocationList := TFhirStringList.Create;
  result := FTargetLocationList;
end;

function TFhirVerificationResult.GetHasTargetLocationList : boolean;
begin
  result := (FTargetLocationList <> nil) and (FTargetLocationList.count > 0);
end;

procedure TFhirVerificationResult.SetNeed(value : TFhirCodeableConcept);
begin
  FNeed.free;
  FNeed := value;
end;

procedure TFhirVerificationResult.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirVerificationResult.GetStatusST : TFhirStatusEnum;
begin
  if FStatus = nil then
    result := TFhirStatusEnum(0)
  else
    result := TFhirStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirStatusEnum, FStatus.value));
end;

procedure TFhirVerificationResult.SetStatusST(value : TFhirStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirStatusEnum[value], CODES_TFhirStatusEnum[value]);
end;

procedure TFhirVerificationResult.SetStatusDate(value : TFhirDateTime);
begin
  FStatusDate.free;
  FStatusDate := value;
end;

function TFhirVerificationResult.GetStatusDateST : TFslDateTime;
begin
  if FStatusDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FStatusDate.value;
end;

procedure TFhirVerificationResult.SetStatusDateST(value : TFslDateTime);
begin
  if FStatusDate = nil then
    FStatusDate := TFhirDateTime.create;
  FStatusDate.value := value
end;

procedure TFhirVerificationResult.SetValidationType(value : TFhirCodeableConcept);
begin
  FValidationType.free;
  FValidationType := value;
end;

function TFhirVerificationResult.GetValidationProcessList : TFhirCodeableConceptList;
begin
  if FValidationProcessList = nil then
    FValidationProcessList := TFhirCodeableConceptList.Create;
  result := FValidationProcessList;
end;

function TFhirVerificationResult.GetHasValidationProcessList : boolean;
begin
  result := (FValidationProcessList <> nil) and (FValidationProcessList.count > 0);
end;

procedure TFhirVerificationResult.SetFrequency(value : TFhirTiming);
begin
  FFrequency.free;
  FFrequency := value;
end;

procedure TFhirVerificationResult.SetLastPerformed(value : TFhirDateTime);
begin
  FLastPerformed.free;
  FLastPerformed := value;
end;

function TFhirVerificationResult.GetLastPerformedST : TFslDateTime;
begin
  if FLastPerformed = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastPerformed.value;
end;

procedure TFhirVerificationResult.SetLastPerformedST(value : TFslDateTime);
begin
  if FLastPerformed = nil then
    FLastPerformed := TFhirDateTime.create;
  FLastPerformed.value := value
end;

procedure TFhirVerificationResult.SetNextScheduled(value : TFhirDate);
begin
  FNextScheduled.free;
  FNextScheduled := value;
end;

function TFhirVerificationResult.GetNextScheduledST : TFslDateTime;
begin
  if FNextScheduled = nil then
    result := TFslDateTime.makeNull
  else
    result := FNextScheduled.value;
end;

procedure TFhirVerificationResult.SetNextScheduledST(value : TFslDateTime);
begin
  if FNextScheduled = nil then
    FNextScheduled := TFhirDate.create;
  FNextScheduled.value := value
end;

procedure TFhirVerificationResult.SetFailureAction(value : TFhirCodeableConcept);
begin
  FFailureAction.free;
  FFailureAction := value;
end;

function TFhirVerificationResult.GetPrimarySourceList : TFhirVerificationResultPrimarySourceList;
begin
  if FPrimarySourceList = nil then
    FPrimarySourceList := TFhirVerificationResultPrimarySourceList.Create;
  result := FPrimarySourceList;
end;

function TFhirVerificationResult.GetHasPrimarySourceList : boolean;
begin
  result := (FPrimarySourceList <> nil) and (FPrimarySourceList.count > 0);
end;

procedure TFhirVerificationResult.SetAttestation(value : TFhirVerificationResultAttestation);
begin
  FAttestation.free;
  FAttestation := value;
end;

function TFhirVerificationResult.GetValidatorList : TFhirVerificationResultValidatorList;
begin
  if FValidatorList = nil then
    FValidatorList := TFhirVerificationResultValidatorList.Create;
  result := FValidatorList;
end;

function TFhirVerificationResult.GetHasValidatorList : boolean;
begin
  result := (FValidatorList <> nil) and (FValidatorList.count > 0);
end;

{ TFhirVerificationResultListEnumerator }

constructor TFhirVerificationResultListEnumerator.Create(list : TFhirVerificationResultList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirVerificationResultListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirVerificationResultListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirVerificationResultListEnumerator.GetCurrent : TFhirVerificationResult;
begin
  Result := FList[FIndex];
end;

function TFhirVerificationResultListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirVerificationResultList }

function TFhirVerificationResultList.AddItem(value: TFhirVerificationResult): TFhirVerificationResult;
begin
  assert(value.ClassName = 'TFhirVerificationResult', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirVerificationResult');
  add(value);
  result := value;
end;

function TFhirVerificationResultList.Append: TFhirVerificationResult;
begin
  result := TFhirVerificationResult.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVerificationResultList.ClearItems;
begin
  Clear;
end;

function TFhirVerificationResultList.GetEnumerator : TFhirVerificationResultListEnumerator;
begin
  result := TFhirVerificationResultListEnumerator.Create(self.link);
end;

function TFhirVerificationResultList.Clone: TFhirVerificationResultList;
begin
  result := TFhirVerificationResultList(inherited Clone);
end;

function TFhirVerificationResultList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirVerificationResultList.GetItemN(index: Integer): TFhirVerificationResult;
begin
  result := TFhirVerificationResult(ObjectByIndex[index]);
end;

function TFhirVerificationResultList.ItemClass: TFslObjectClass;
begin
  result := TFhirVerificationResult;
end;
function TFhirVerificationResultList.IndexOf(value: TFhirVerificationResult): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirVerificationResultList.Insert(index: Integer): TFhirVerificationResult;
begin
  result := TFhirVerificationResult.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVerificationResultList.InsertItem(index: Integer; value: TFhirVerificationResult);
begin
  assert(value is TFhirVerificationResult);
  Inherited Insert(index, value);
end;

function TFhirVerificationResultList.Item(index: Integer): TFhirVerificationResult;
begin
  result := TFhirVerificationResult(ObjectByIndex[index]);
end;

function TFhirVerificationResultList.Link: TFhirVerificationResultList;
begin
  result := TFhirVerificationResultList(inherited Link);
end;

procedure TFhirVerificationResultList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirVerificationResultList.SetItemByIndex(index: Integer; value: TFhirVerificationResult);
begin
  assert(value is TFhirVerificationResult);
  FhirVerificationResults[index] := value;
end;

procedure TFhirVerificationResultList.SetItemN(index: Integer; value: TFhirVerificationResult);
begin
  assert(value is TFhirVerificationResult);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_VERIFICATIONRESULT}


end.

