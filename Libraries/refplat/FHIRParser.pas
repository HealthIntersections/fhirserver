unit FHIRParser;

{
  Copyright (c) 2011-2013, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
}

interface

// FHIR v0.80 generated Fri, Apr 18, 2014 22:46+1000

uses
  SysUtils, Classes, ActiveX, StringSupport, DateSupport, IdSoapMsXml, FHIRParserBase, DateAndTime, FHIRBase, FHIRResources, FHIRConstants, FHIRComponents, FHIRTypes, MsXmlParser, XmlBuilder, JSON;

Type

  TFHIRXmlParser = class (TFHIRXmlParserBase)
  protected
    Procedure ParseElementAttributes(value : TFhirElement; path : string; element : IXmlDomElement);
    Function ParseBackboneElementChild(element : TFhirBackboneElement; path : string; child : IXmlDomElement) : boolean;
    Function ParseElementChild(element : TFhirElement; path : string; child : IXmlDomElement) : boolean;

    function ParseEnum(Const aNames : Array Of String; path : String; element : IXmlDomElement) : TFhirEnum;
    function ParseInteger(element : IXmlDomElement; path : string) : TFhirInteger;
    function ParseDateTime(element : IXmlDomElement; path : string) : TFhirDateTime;
    function ParseDate(element : IXmlDomElement; path : string) : TFhirDate;
    function ParseDecimal(element : IXmlDomElement; path : string) : TFhirDecimal;
    function ParseUri(element : IXmlDomElement; path : string) : TFhirUri;
    function ParseBase64Binary(element : IXmlDomElement; path : string) : TFhirBase64Binary;
    function ParseString(element : IXmlDomElement; path : string) : TFhirString;
    function ParseBoolean(element : IXmlDomElement; path : string) : TFhirBoolean;
    function ParseInstant(element : IXmlDomElement; path : string) : TFhirInstant;
    function ParseCode(element : IXmlDomElement; path : string) : TFhirCode;
    function ParseId(element : IXmlDomElement; path : string) : TFhirId;
    function ParseOid(element : IXmlDomElement; path : string) : TFhirOid;
    function ParseUuid(element : IXmlDomElement; path : string) : TFhirUuid;

    Procedure ParseResourceAttributes(resource : TFhirResource; path : string; element : IXmlDomElement);
    Function ParseResourceChild(resource : TFhirResource; path : string; child : IXmlDomElement) : boolean;

    function ParseExtension(element : IXmlDomElement; path : string) : TFhirExtension;
    function ParseNarrative(element : IXmlDomElement; path : string) : TFhirNarrative;
    function ParsePeriod(element : IXmlDomElement; path : string) : TFhirPeriod;
    function ParseCoding(element : IXmlDomElement; path : string) : TFhirCoding;
    function ParseRange(element : IXmlDomElement; path : string) : TFhirRange;
    function ParseQuantity(element : IXmlDomElement; path : string) : TFhirQuantity;
    function ParseAttachment(element : IXmlDomElement; path : string) : TFhirAttachment;
    function ParseRatio(element : IXmlDomElement; path : string) : TFhirRatio;
    function ParseSampledData(element : IXmlDomElement; path : string) : TFhirSampledData;
    function ParseResourceReference(element : IXmlDomElement; path : string) : TFhirResourceReference;
    function ParseCodeableConcept(element : IXmlDomElement; path : string) : TFhirCodeableConcept;
    function ParseIdentifier(element : IXmlDomElement; path : string) : TFhirIdentifier;
    function ParseScheduleRepeat(element : IXmlDomElement; path : string) : TFhirScheduleRepeat;
    function ParseSchedule(element : IXmlDomElement; path : string) : TFhirSchedule;
    function ParseContact(element : IXmlDomElement; path : string) : TFhirContact;
    function ParseAddress(element : IXmlDomElement; path : string) : TFhirAddress;
    function ParseHumanName(element : IXmlDomElement; path : string) : TFhirHumanName;
    function ParseAge(element : IXmlDomElement; path : string) : TFhirAge;
    function ParseCount(element : IXmlDomElement; path : string) : TFhirCount;
    function ParseMoney(element : IXmlDomElement; path : string) : TFhirMoney;
    function ParseDistance(element : IXmlDomElement; path : string) : TFhirDistance;
    function ParseDuration(element : IXmlDomElement; path : string) : TFhirDuration;

    function ParseAdverseReactionSymptom(element : IXmlDomElement; path : string) : TFhirAdverseReactionSymptom;
    function ParseAdverseReactionExposure(element : IXmlDomElement; path : string) : TFhirAdverseReactionExposure;
    function ParseAdverseReaction(element : IXmlDomElement; path : string) : TFhirAdverseReaction;
    function ParseAlert(element : IXmlDomElement; path : string) : TFhirAlert;
    function ParseAllergyIntolerance(element : IXmlDomElement; path : string) : TFhirAllergyIntolerance;
    function ParseCarePlanParticipant(element : IXmlDomElement; path : string) : TFhirCarePlanParticipant;
    function ParseCarePlanGoal(element : IXmlDomElement; path : string) : TFhirCarePlanGoal;
    function ParseCarePlanActivity(element : IXmlDomElement; path : string) : TFhirCarePlanActivity;
    function ParseCarePlanActivitySimple(element : IXmlDomElement; path : string) : TFhirCarePlanActivitySimple;
    function ParseCarePlan(element : IXmlDomElement; path : string) : TFhirCarePlan;
    function ParseCompositionAttester(element : IXmlDomElement; path : string) : TFhirCompositionAttester;
    function ParseCompositionEvent(element : IXmlDomElement; path : string) : TFhirCompositionEvent;
    function ParseCompositionSection(element : IXmlDomElement; path : string) : TFhirCompositionSection;
    function ParseComposition(element : IXmlDomElement; path : string) : TFhirComposition;
    function ParseConceptMapConcept(element : IXmlDomElement; path : string) : TFhirConceptMapConcept;
    function ParseConceptMapConceptDependsOn(element : IXmlDomElement; path : string) : TFhirConceptMapConceptDependsOn;
    function ParseConceptMapConceptMap(element : IXmlDomElement; path : string) : TFhirConceptMapConceptMap;
    function ParseConceptMap(element : IXmlDomElement; path : string) : TFhirConceptMap;
    function ParseConditionStage(element : IXmlDomElement; path : string) : TFhirConditionStage;
    function ParseConditionEvidence(element : IXmlDomElement; path : string) : TFhirConditionEvidence;
    function ParseConditionLocation(element : IXmlDomElement; path : string) : TFhirConditionLocation;
    function ParseConditionRelatedItem(element : IXmlDomElement; path : string) : TFhirConditionRelatedItem;
    function ParseCondition(element : IXmlDomElement; path : string) : TFhirCondition;
    function ParseConformanceSoftware(element : IXmlDomElement; path : string) : TFhirConformanceSoftware;
    function ParseConformanceImplementation(element : IXmlDomElement; path : string) : TFhirConformanceImplementation;
    function ParseConformanceRest(element : IXmlDomElement; path : string) : TFhirConformanceRest;
    function ParseConformanceRestSecurity(element : IXmlDomElement; path : string) : TFhirConformanceRestSecurity;
    function ParseConformanceRestSecurityCertificate(element : IXmlDomElement; path : string) : TFhirConformanceRestSecurityCertificate;
    function ParseConformanceRestResource(element : IXmlDomElement; path : string) : TFhirConformanceRestResource;
    function ParseConformanceRestResourceOperation(element : IXmlDomElement; path : string) : TFhirConformanceRestResourceOperation;
    function ParseConformanceRestResourceSearchParam(element : IXmlDomElement; path : string) : TFhirConformanceRestResourceSearchParam;
    function ParseConformanceRestOperation(element : IXmlDomElement; path : string) : TFhirConformanceRestOperation;
    function ParseConformanceRestQuery(element : IXmlDomElement; path : string) : TFhirConformanceRestQuery;
    function ParseConformanceMessaging(element : IXmlDomElement; path : string) : TFhirConformanceMessaging;
    function ParseConformanceMessagingEvent(element : IXmlDomElement; path : string) : TFhirConformanceMessagingEvent;
    function ParseConformanceDocument(element : IXmlDomElement; path : string) : TFhirConformanceDocument;
    function ParseConformance(element : IXmlDomElement; path : string) : TFhirConformance;
    function ParseDevice(element : IXmlDomElement; path : string) : TFhirDevice;
    function ParseDeviceObservationReportVirtualDevice(element : IXmlDomElement; path : string) : TFhirDeviceObservationReportVirtualDevice;
    function ParseDeviceObservationReportVirtualDeviceChannel(element : IXmlDomElement; path : string) : TFhirDeviceObservationReportVirtualDeviceChannel;
    function ParseDeviceObservationReportVirtualDeviceChannelMetric(element : IXmlDomElement; path : string) : TFhirDeviceObservationReportVirtualDeviceChannelMetric;
    function ParseDeviceObservationReport(element : IXmlDomElement; path : string) : TFhirDeviceObservationReport;
    function ParseDiagnosticOrderEvent(element : IXmlDomElement; path : string) : TFhirDiagnosticOrderEvent;
    function ParseDiagnosticOrderItem(element : IXmlDomElement; path : string) : TFhirDiagnosticOrderItem;
    function ParseDiagnosticOrder(element : IXmlDomElement; path : string) : TFhirDiagnosticOrder;
    function ParseDiagnosticReportImage(element : IXmlDomElement; path : string) : TFhirDiagnosticReportImage;
    function ParseDiagnosticReport(element : IXmlDomElement; path : string) : TFhirDiagnosticReport;
    function ParseDocumentManifest(element : IXmlDomElement; path : string) : TFhirDocumentManifest;
    function ParseDocumentReferenceRelatesTo(element : IXmlDomElement; path : string) : TFhirDocumentReferenceRelatesTo;
    function ParseDocumentReferenceService(element : IXmlDomElement; path : string) : TFhirDocumentReferenceService;
    function ParseDocumentReferenceServiceParameter(element : IXmlDomElement; path : string) : TFhirDocumentReferenceServiceParameter;
    function ParseDocumentReferenceContext(element : IXmlDomElement; path : string) : TFhirDocumentReferenceContext;
    function ParseDocumentReference(element : IXmlDomElement; path : string) : TFhirDocumentReference;
    function ParseEncounterParticipant(element : IXmlDomElement; path : string) : TFhirEncounterParticipant;
    function ParseEncounterHospitalization(element : IXmlDomElement; path : string) : TFhirEncounterHospitalization;
    function ParseEncounterHospitalizationAccomodation(element : IXmlDomElement; path : string) : TFhirEncounterHospitalizationAccomodation;
    function ParseEncounterLocation(element : IXmlDomElement; path : string) : TFhirEncounterLocation;
    function ParseEncounter(element : IXmlDomElement; path : string) : TFhirEncounter;
    function ParseFamilyHistoryRelation(element : IXmlDomElement; path : string) : TFhirFamilyHistoryRelation;
    function ParseFamilyHistoryRelationCondition(element : IXmlDomElement; path : string) : TFhirFamilyHistoryRelationCondition;
    function ParseFamilyHistory(element : IXmlDomElement; path : string) : TFhirFamilyHistory;
    function ParseGroupCharacteristic(element : IXmlDomElement; path : string) : TFhirGroupCharacteristic;
    function ParseGroup(element : IXmlDomElement; path : string) : TFhirGroup;
    function ParseImagingStudySeries(element : IXmlDomElement; path : string) : TFhirImagingStudySeries;
    function ParseImagingStudySeriesInstance(element : IXmlDomElement; path : string) : TFhirImagingStudySeriesInstance;
    function ParseImagingStudy(element : IXmlDomElement; path : string) : TFhirImagingStudy;
    function ParseImmunizationExplanation(element : IXmlDomElement; path : string) : TFhirImmunizationExplanation;
    function ParseImmunizationReaction(element : IXmlDomElement; path : string) : TFhirImmunizationReaction;
    function ParseImmunizationVaccinationProtocol(element : IXmlDomElement; path : string) : TFhirImmunizationVaccinationProtocol;
    function ParseImmunization(element : IXmlDomElement; path : string) : TFhirImmunization;
    function ParseImmunizationRecommendationRecommendation(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendationRecommendation;
    function ParseImmunizationRecommendationRecommendationDateCriterion(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendationRecommendationDateCriterion;
    function ParseImmunizationRecommendationRecommendationProtocol(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendationRecommendationProtocol;
    function ParseImmunizationRecommendation(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendation;
    function ParseListEntry(element : IXmlDomElement; path : string) : TFhirListEntry;
    function ParseList(element : IXmlDomElement; path : string) : TFhirList;
    function ParseLocationPosition(element : IXmlDomElement; path : string) : TFhirLocationPosition;
    function ParseLocation(element : IXmlDomElement; path : string) : TFhirLocation;
    function ParseMedia(element : IXmlDomElement; path : string) : TFhirMedia;
    function ParseMedicationProduct(element : IXmlDomElement; path : string) : TFhirMedicationProduct;
    function ParseMedicationProductIngredient(element : IXmlDomElement; path : string) : TFhirMedicationProductIngredient;
    function ParseMedicationPackage(element : IXmlDomElement; path : string) : TFhirMedicationPackage;
    function ParseMedicationPackageContent(element : IXmlDomElement; path : string) : TFhirMedicationPackageContent;
    function ParseMedication(element : IXmlDomElement; path : string) : TFhirMedication;
    function ParseMedicationAdministrationDosage(element : IXmlDomElement; path : string) : TFhirMedicationAdministrationDosage;
    function ParseMedicationAdministration(element : IXmlDomElement; path : string) : TFhirMedicationAdministration;
    function ParseMedicationDispenseDispense(element : IXmlDomElement; path : string) : TFhirMedicationDispenseDispense;
    function ParseMedicationDispenseDispenseDosage(element : IXmlDomElement; path : string) : TFhirMedicationDispenseDispenseDosage;
    function ParseMedicationDispenseSubstitution(element : IXmlDomElement; path : string) : TFhirMedicationDispenseSubstitution;
    function ParseMedicationDispense(element : IXmlDomElement; path : string) : TFhirMedicationDispense;
    function ParseMedicationPrescriptionDosageInstruction(element : IXmlDomElement; path : string) : TFhirMedicationPrescriptionDosageInstruction;
    function ParseMedicationPrescriptionDispense(element : IXmlDomElement; path : string) : TFhirMedicationPrescriptionDispense;
    function ParseMedicationPrescriptionSubstitution(element : IXmlDomElement; path : string) : TFhirMedicationPrescriptionSubstitution;
    function ParseMedicationPrescription(element : IXmlDomElement; path : string) : TFhirMedicationPrescription;
    function ParseMedicationStatementDosage(element : IXmlDomElement; path : string) : TFhirMedicationStatementDosage;
    function ParseMedicationStatement(element : IXmlDomElement; path : string) : TFhirMedicationStatement;
    function ParseMessageHeaderResponse(element : IXmlDomElement; path : string) : TFhirMessageHeaderResponse;
    function ParseMessageHeaderSource(element : IXmlDomElement; path : string) : TFhirMessageHeaderSource;
    function ParseMessageHeaderDestination(element : IXmlDomElement; path : string) : TFhirMessageHeaderDestination;
    function ParseMessageHeader(element : IXmlDomElement; path : string) : TFhirMessageHeader;
    function ParseObservationReferenceRange(element : IXmlDomElement; path : string) : TFhirObservationReferenceRange;
    function ParseObservationRelated(element : IXmlDomElement; path : string) : TFhirObservationRelated;
    function ParseObservation(element : IXmlDomElement; path : string) : TFhirObservation;
    function ParseOperationOutcomeIssue(element : IXmlDomElement; path : string) : TFhirOperationOutcomeIssue;
    function ParseOperationOutcome(element : IXmlDomElement; path : string) : TFhirOperationOutcome;
    function ParseOrderWhen(element : IXmlDomElement; path : string) : TFhirOrderWhen;
    function ParseOrder(element : IXmlDomElement; path : string) : TFhirOrder;
    function ParseOrderResponse(element : IXmlDomElement; path : string) : TFhirOrderResponse;
    function ParseOrganizationContact(element : IXmlDomElement; path : string) : TFhirOrganizationContact;
    function ParseOrganization(element : IXmlDomElement; path : string) : TFhirOrganization;
    function ParseOther(element : IXmlDomElement; path : string) : TFhirOther;
    function ParsePatientContact(element : IXmlDomElement; path : string) : TFhirPatientContact;
    function ParsePatientAnimal(element : IXmlDomElement; path : string) : TFhirPatientAnimal;
    function ParsePatientLink(element : IXmlDomElement; path : string) : TFhirPatientLink;
    function ParsePatient(element : IXmlDomElement; path : string) : TFhirPatient;
    function ParsePractitionerQualification(element : IXmlDomElement; path : string) : TFhirPractitionerQualification;
    function ParsePractitioner(element : IXmlDomElement; path : string) : TFhirPractitioner;
    function ParseProcedurePerformer(element : IXmlDomElement; path : string) : TFhirProcedurePerformer;
    function ParseProcedureRelatedItem(element : IXmlDomElement; path : string) : TFhirProcedureRelatedItem;
    function ParseProcedure(element : IXmlDomElement; path : string) : TFhirProcedure;
    function ParseProfileMapping(element : IXmlDomElement; path : string) : TFhirProfileMapping;
    function ParseProfileStructure(element : IXmlDomElement; path : string) : TFhirProfileStructure;
    function ParseProfileStructureElement(element : IXmlDomElement; path : string) : TFhirProfileStructureElement;
    function ParseProfileStructureElementSlicing(element : IXmlDomElement; path : string) : TFhirProfileStructureElementSlicing;
    function ParseProfileStructureElementDefinition(element : IXmlDomElement; path : string) : TFhirProfileStructureElementDefinition;
    function ParseProfileStructureElementDefinitionType(element : IXmlDomElement; path : string) : TFhirProfileStructureElementDefinitionType;
    function ParseProfileStructureElementDefinitionConstraint(element : IXmlDomElement; path : string) : TFhirProfileStructureElementDefinitionConstraint;
    function ParseProfileStructureElementDefinitionBinding(element : IXmlDomElement; path : string) : TFhirProfileStructureElementDefinitionBinding;
    function ParseProfileStructureElementDefinitionMapping(element : IXmlDomElement; path : string) : TFhirProfileStructureElementDefinitionMapping;
    function ParseProfileStructureSearchParam(element : IXmlDomElement; path : string) : TFhirProfileStructureSearchParam;
    function ParseProfileExtensionDefn(element : IXmlDomElement; path : string) : TFhirProfileExtensionDefn;
    function ParseProfileQuery(element : IXmlDomElement; path : string) : TFhirProfileQuery;
    function ParseProfile(element : IXmlDomElement; path : string) : TFhirProfile;
    function ParseProvenanceAgent(element : IXmlDomElement; path : string) : TFhirProvenanceAgent;
    function ParseProvenanceEntity(element : IXmlDomElement; path : string) : TFhirProvenanceEntity;
    function ParseProvenance(element : IXmlDomElement; path : string) : TFhirProvenance;
    function ParseQueryResponse(element : IXmlDomElement; path : string) : TFhirQueryResponse;
    function ParseQuery(element : IXmlDomElement; path : string) : TFhirQuery;
    function ParseQuestionnaireGroup(element : IXmlDomElement; path : string) : TFhirQuestionnaireGroup;
    function ParseQuestionnaireGroupQuestion(element : IXmlDomElement; path : string) : TFhirQuestionnaireGroupQuestion;
    function ParseQuestionnaire(element : IXmlDomElement; path : string) : TFhirQuestionnaire;
    function ParseRelatedPerson(element : IXmlDomElement; path : string) : TFhirRelatedPerson;
    function ParseSecurityEventEvent(element : IXmlDomElement; path : string) : TFhirSecurityEventEvent;
    function ParseSecurityEventParticipant(element : IXmlDomElement; path : string) : TFhirSecurityEventParticipant;
    function ParseSecurityEventParticipantNetwork(element : IXmlDomElement; path : string) : TFhirSecurityEventParticipantNetwork;
    function ParseSecurityEventSource(element : IXmlDomElement; path : string) : TFhirSecurityEventSource;
    function ParseSecurityEventObject(element : IXmlDomElement; path : string) : TFhirSecurityEventObject;
    function ParseSecurityEventObjectDetail(element : IXmlDomElement; path : string) : TFhirSecurityEventObjectDetail;
    function ParseSecurityEvent(element : IXmlDomElement; path : string) : TFhirSecurityEvent;
    function ParseSpecimenSource(element : IXmlDomElement; path : string) : TFhirSpecimenSource;
    function ParseSpecimenCollection(element : IXmlDomElement; path : string) : TFhirSpecimenCollection;
    function ParseSpecimenTreatment(element : IXmlDomElement; path : string) : TFhirSpecimenTreatment;
    function ParseSpecimenContainer(element : IXmlDomElement; path : string) : TFhirSpecimenContainer;
    function ParseSpecimen(element : IXmlDomElement; path : string) : TFhirSpecimen;
    function ParseSubstanceInstance(element : IXmlDomElement; path : string) : TFhirSubstanceInstance;
    function ParseSubstanceIngredient(element : IXmlDomElement; path : string) : TFhirSubstanceIngredient;
    function ParseSubstance(element : IXmlDomElement; path : string) : TFhirSubstance;
    function ParseSupplyDispense(element : IXmlDomElement; path : string) : TFhirSupplyDispense;
    function ParseSupply(element : IXmlDomElement; path : string) : TFhirSupply;
    function ParseValueSetDefine(element : IXmlDomElement; path : string) : TFhirValueSetDefine;
    function ParseValueSetDefineConcept(element : IXmlDomElement; path : string) : TFhirValueSetDefineConcept;
    function ParseValueSetCompose(element : IXmlDomElement; path : string) : TFhirValueSetCompose;
    function ParseValueSetComposeInclude(element : IXmlDomElement; path : string) : TFhirValueSetComposeInclude;
    function ParseValueSetComposeIncludeFilter(element : IXmlDomElement; path : string) : TFhirValueSetComposeIncludeFilter;
    function ParseValueSetExpansion(element : IXmlDomElement; path : string) : TFhirValueSetExpansion;
    function ParseValueSetExpansionContains(element : IXmlDomElement; path : string) : TFhirValueSetExpansionContains;
    function ParseValueSet(element : IXmlDomElement; path : string) : TFhirValueSet;
    function ParseResource(element : IxmlDomElement; path : String) : TFhirResource; override;
  public
    function ParseFragment(element : IxmlDomElement) : TFhirElement; overload;
  end;

  TFHIRXmlComposer = class (TFHIRXmlComposerBase)
  protected
    Procedure ComposeElementAttributes(xml : TXmlBuilder; element : TFhirElement);
    Procedure ComposeElementChildren(xml : TXmlBuilder; element : TFhirElement);
    Procedure ComposeBackboneElementChildren(xml : TXmlBuilder; element : TFhirBackboneElement);

    Procedure ComposeEnum(xml : TXmlBuilder; name : String; value : TFhirEnum; Const aNames : Array Of String);
    Procedure ComposeInteger(xml : TXmlBuilder; name : String; value : TFhirInteger);
    Procedure ComposeDateTime(xml : TXmlBuilder; name : String; value : TFhirDateTime);
    Procedure ComposeDate(xml : TXmlBuilder; name : String; value : TFhirDate);
    Procedure ComposeDecimal(xml : TXmlBuilder; name : String; value : TFhirDecimal);
    Procedure ComposeUri(xml : TXmlBuilder; name : String; value : TFhirUri);
    Procedure ComposeBase64Binary(xml : TXmlBuilder; name : String; value : TFhirBase64Binary);
    Procedure ComposeString(xml : TXmlBuilder; name : String; value : TFhirString);
    Procedure ComposeBoolean(xml : TXmlBuilder; name : String; value : TFhirBoolean);
    Procedure ComposeInstant(xml : TXmlBuilder; name : String; value : TFhirInstant);
    Procedure ComposeCode(xml : TXmlBuilder; name : String; value : TFhirCode);
    Procedure ComposeId(xml : TXmlBuilder; name : String; value : TFhirId);
    Procedure ComposeOid(xml : TXmlBuilder; name : String; value : TFhirOid);
    Procedure ComposeUuid(xml : TXmlBuilder; name : String; value : TFhirUuid);

    Procedure ComposeResourceAttributes(xml : TXmlBuilder; resource : TFhirResource);
    Procedure ComposeResourceChildren(xml : TXmlBuilder; resource : TFhirResource);

    procedure ComposeExtension(xml : TXmlBuilder; name : string; elem : TFhirExtension);
    procedure ComposeNarrative(xml : TXmlBuilder; name : string; elem : TFhirNarrative);
    procedure ComposePeriod(xml : TXmlBuilder; name : string; elem : TFhirPeriod);
    procedure ComposeCoding(xml : TXmlBuilder; name : string; elem : TFhirCoding);
    procedure ComposeRange(xml : TXmlBuilder; name : string; elem : TFhirRange);
    procedure ComposeQuantity(xml : TXmlBuilder; name : string; elem : TFhirQuantity);
    procedure ComposeAttachment(xml : TXmlBuilder; name : string; elem : TFhirAttachment);
    procedure ComposeRatio(xml : TXmlBuilder; name : string; elem : TFhirRatio);
    procedure ComposeSampledData(xml : TXmlBuilder; name : string; elem : TFhirSampledData);
    procedure ComposeResourceReference(xml : TXmlBuilder; name : string; elem : TFhirResourceReference);
    procedure ComposeCodeableConcept(xml : TXmlBuilder; name : string; elem : TFhirCodeableConcept);
    procedure ComposeIdentifier(xml : TXmlBuilder; name : string; elem : TFhirIdentifier);
    procedure ComposeScheduleRepeat(xml : TXmlBuilder; name : string; elem : TFhirScheduleRepeat);
    procedure ComposeSchedule(xml : TXmlBuilder; name : string; elem : TFhirSchedule);
    procedure ComposeContact(xml : TXmlBuilder; name : string; elem : TFhirContact);
    procedure ComposeAddress(xml : TXmlBuilder; name : string; elem : TFhirAddress);
    procedure ComposeHumanName(xml : TXmlBuilder; name : string; elem : TFhirHumanName);
    procedure ComposeAge(xml : TXmlBuilder; name : string; elem : TFhirAge);
    procedure ComposeCount(xml : TXmlBuilder; name : string; elem : TFhirCount);
    procedure ComposeMoney(xml : TXmlBuilder; name : string; elem : TFhirMoney);
    procedure ComposeDistance(xml : TXmlBuilder; name : string; elem : TFhirDistance);
    procedure ComposeDuration(xml : TXmlBuilder; name : string; elem : TFhirDuration);

    procedure ComposeAdverseReactionSymptom(xml : TXmlBuilder; name : string; elem : TFhirAdverseReactionSymptom);
    procedure ComposeAdverseReactionExposure(xml : TXmlBuilder; name : string; elem : TFhirAdverseReactionExposure);
    procedure ComposeAdverseReaction(xml : TXmlBuilder; name : string; elem : TFhirAdverseReaction);
    procedure ComposeAlert(xml : TXmlBuilder; name : string; elem : TFhirAlert);
    procedure ComposeAllergyIntolerance(xml : TXmlBuilder; name : string; elem : TFhirAllergyIntolerance);
    procedure ComposeCarePlanParticipant(xml : TXmlBuilder; name : string; elem : TFhirCarePlanParticipant);
    procedure ComposeCarePlanGoal(xml : TXmlBuilder; name : string; elem : TFhirCarePlanGoal);
    procedure ComposeCarePlanActivity(xml : TXmlBuilder; name : string; elem : TFhirCarePlanActivity);
    procedure ComposeCarePlanActivitySimple(xml : TXmlBuilder; name : string; elem : TFhirCarePlanActivitySimple);
    procedure ComposeCarePlan(xml : TXmlBuilder; name : string; elem : TFhirCarePlan);
    procedure ComposeCompositionAttester(xml : TXmlBuilder; name : string; elem : TFhirCompositionAttester);
    procedure ComposeCompositionEvent(xml : TXmlBuilder; name : string; elem : TFhirCompositionEvent);
    procedure ComposeCompositionSection(xml : TXmlBuilder; name : string; elem : TFhirCompositionSection);
    procedure ComposeComposition(xml : TXmlBuilder; name : string; elem : TFhirComposition);
    procedure ComposeConceptMapConcept(xml : TXmlBuilder; name : string; elem : TFhirConceptMapConcept);
    procedure ComposeConceptMapConceptDependsOn(xml : TXmlBuilder; name : string; elem : TFhirConceptMapConceptDependsOn);
    procedure ComposeConceptMapConceptMap(xml : TXmlBuilder; name : string; elem : TFhirConceptMapConceptMap);
    procedure ComposeConceptMap(xml : TXmlBuilder; name : string; elem : TFhirConceptMap);
    procedure ComposeConditionStage(xml : TXmlBuilder; name : string; elem : TFhirConditionStage);
    procedure ComposeConditionEvidence(xml : TXmlBuilder; name : string; elem : TFhirConditionEvidence);
    procedure ComposeConditionLocation(xml : TXmlBuilder; name : string; elem : TFhirConditionLocation);
    procedure ComposeConditionRelatedItem(xml : TXmlBuilder; name : string; elem : TFhirConditionRelatedItem);
    procedure ComposeCondition(xml : TXmlBuilder; name : string; elem : TFhirCondition);
    procedure ComposeConformanceSoftware(xml : TXmlBuilder; name : string; elem : TFhirConformanceSoftware);
    procedure ComposeConformanceImplementation(xml : TXmlBuilder; name : string; elem : TFhirConformanceImplementation);
    procedure ComposeConformanceRest(xml : TXmlBuilder; name : string; elem : TFhirConformanceRest);
    procedure ComposeConformanceRestSecurity(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestSecurity);
    procedure ComposeConformanceRestSecurityCertificate(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestSecurityCertificate);
    procedure ComposeConformanceRestResource(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResource);
    procedure ComposeConformanceRestResourceOperation(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResourceOperation);
    procedure ComposeConformanceRestResourceSearchParam(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResourceSearchParam);
    procedure ComposeConformanceRestOperation(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestOperation);
    procedure ComposeConformanceRestQuery(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestQuery);
    procedure ComposeConformanceMessaging(xml : TXmlBuilder; name : string; elem : TFhirConformanceMessaging);
    procedure ComposeConformanceMessagingEvent(xml : TXmlBuilder; name : string; elem : TFhirConformanceMessagingEvent);
    procedure ComposeConformanceDocument(xml : TXmlBuilder; name : string; elem : TFhirConformanceDocument);
    procedure ComposeConformance(xml : TXmlBuilder; name : string; elem : TFhirConformance);
    procedure ComposeDevice(xml : TXmlBuilder; name : string; elem : TFhirDevice);
    procedure ComposeDeviceObservationReportVirtualDevice(xml : TXmlBuilder; name : string; elem : TFhirDeviceObservationReportVirtualDevice);
    procedure ComposeDeviceObservationReportVirtualDeviceChannel(xml : TXmlBuilder; name : string; elem : TFhirDeviceObservationReportVirtualDeviceChannel);
    procedure ComposeDeviceObservationReportVirtualDeviceChannelMetric(xml : TXmlBuilder; name : string; elem : TFhirDeviceObservationReportVirtualDeviceChannelMetric);
    procedure ComposeDeviceObservationReport(xml : TXmlBuilder; name : string; elem : TFhirDeviceObservationReport);
    procedure ComposeDiagnosticOrderEvent(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrderEvent);
    procedure ComposeDiagnosticOrderItem(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrderItem);
    procedure ComposeDiagnosticOrder(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrder);
    procedure ComposeDiagnosticReportImage(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticReportImage);
    procedure ComposeDiagnosticReport(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticReport);
    procedure ComposeDocumentManifest(xml : TXmlBuilder; name : string; elem : TFhirDocumentManifest);
    procedure ComposeDocumentReferenceRelatesTo(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceRelatesTo);
    procedure ComposeDocumentReferenceService(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceService);
    procedure ComposeDocumentReferenceServiceParameter(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceServiceParameter);
    procedure ComposeDocumentReferenceContext(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceContext);
    procedure ComposeDocumentReference(xml : TXmlBuilder; name : string; elem : TFhirDocumentReference);
    procedure ComposeEncounterParticipant(xml : TXmlBuilder; name : string; elem : TFhirEncounterParticipant);
    procedure ComposeEncounterHospitalization(xml : TXmlBuilder; name : string; elem : TFhirEncounterHospitalization);
    procedure ComposeEncounterHospitalizationAccomodation(xml : TXmlBuilder; name : string; elem : TFhirEncounterHospitalizationAccomodation);
    procedure ComposeEncounterLocation(xml : TXmlBuilder; name : string; elem : TFhirEncounterLocation);
    procedure ComposeEncounter(xml : TXmlBuilder; name : string; elem : TFhirEncounter);
    procedure ComposeFamilyHistoryRelation(xml : TXmlBuilder; name : string; elem : TFhirFamilyHistoryRelation);
    procedure ComposeFamilyHistoryRelationCondition(xml : TXmlBuilder; name : string; elem : TFhirFamilyHistoryRelationCondition);
    procedure ComposeFamilyHistory(xml : TXmlBuilder; name : string; elem : TFhirFamilyHistory);
    procedure ComposeGroupCharacteristic(xml : TXmlBuilder; name : string; elem : TFhirGroupCharacteristic);
    procedure ComposeGroup(xml : TXmlBuilder; name : string; elem : TFhirGroup);
    procedure ComposeImagingStudySeries(xml : TXmlBuilder; name : string; elem : TFhirImagingStudySeries);
    procedure ComposeImagingStudySeriesInstance(xml : TXmlBuilder; name : string; elem : TFhirImagingStudySeriesInstance);
    procedure ComposeImagingStudy(xml : TXmlBuilder; name : string; elem : TFhirImagingStudy);
    procedure ComposeImmunizationExplanation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationExplanation);
    procedure ComposeImmunizationReaction(xml : TXmlBuilder; name : string; elem : TFhirImmunizationReaction);
    procedure ComposeImmunizationVaccinationProtocol(xml : TXmlBuilder; name : string; elem : TFhirImmunizationVaccinationProtocol);
    procedure ComposeImmunization(xml : TXmlBuilder; name : string; elem : TFhirImmunization);
    procedure ComposeImmunizationRecommendationRecommendation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendation);
    procedure ComposeImmunizationRecommendationRecommendationDateCriterion(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendationDateCriterion);
    procedure ComposeImmunizationRecommendationRecommendationProtocol(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendationProtocol);
    procedure ComposeImmunizationRecommendation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendation);
    procedure ComposeListEntry(xml : TXmlBuilder; name : string; elem : TFhirListEntry);
    procedure ComposeList(xml : TXmlBuilder; name : string; elem : TFhirList);
    procedure ComposeLocationPosition(xml : TXmlBuilder; name : string; elem : TFhirLocationPosition);
    procedure ComposeLocation(xml : TXmlBuilder; name : string; elem : TFhirLocation);
    procedure ComposeMedia(xml : TXmlBuilder; name : string; elem : TFhirMedia);
    procedure ComposeMedicationProduct(xml : TXmlBuilder; name : string; elem : TFhirMedicationProduct);
    procedure ComposeMedicationProductIngredient(xml : TXmlBuilder; name : string; elem : TFhirMedicationProductIngredient);
    procedure ComposeMedicationPackage(xml : TXmlBuilder; name : string; elem : TFhirMedicationPackage);
    procedure ComposeMedicationPackageContent(xml : TXmlBuilder; name : string; elem : TFhirMedicationPackageContent);
    procedure ComposeMedication(xml : TXmlBuilder; name : string; elem : TFhirMedication);
    procedure ComposeMedicationAdministrationDosage(xml : TXmlBuilder; name : string; elem : TFhirMedicationAdministrationDosage);
    procedure ComposeMedicationAdministration(xml : TXmlBuilder; name : string; elem : TFhirMedicationAdministration);
    procedure ComposeMedicationDispenseDispense(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispenseDispense);
    procedure ComposeMedicationDispenseDispenseDosage(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispenseDispenseDosage);
    procedure ComposeMedicationDispenseSubstitution(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispenseSubstitution);
    procedure ComposeMedicationDispense(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispense);
    procedure ComposeMedicationPrescriptionDosageInstruction(xml : TXmlBuilder; name : string; elem : TFhirMedicationPrescriptionDosageInstruction);
    procedure ComposeMedicationPrescriptionDispense(xml : TXmlBuilder; name : string; elem : TFhirMedicationPrescriptionDispense);
    procedure ComposeMedicationPrescriptionSubstitution(xml : TXmlBuilder; name : string; elem : TFhirMedicationPrescriptionSubstitution);
    procedure ComposeMedicationPrescription(xml : TXmlBuilder; name : string; elem : TFhirMedicationPrescription);
    procedure ComposeMedicationStatementDosage(xml : TXmlBuilder; name : string; elem : TFhirMedicationStatementDosage);
    procedure ComposeMedicationStatement(xml : TXmlBuilder; name : string; elem : TFhirMedicationStatement);
    procedure ComposeMessageHeaderResponse(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderResponse);
    procedure ComposeMessageHeaderSource(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderSource);
    procedure ComposeMessageHeaderDestination(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderDestination);
    procedure ComposeMessageHeader(xml : TXmlBuilder; name : string; elem : TFhirMessageHeader);
    procedure ComposeObservationReferenceRange(xml : TXmlBuilder; name : string; elem : TFhirObservationReferenceRange);
    procedure ComposeObservationRelated(xml : TXmlBuilder; name : string; elem : TFhirObservationRelated);
    procedure ComposeObservation(xml : TXmlBuilder; name : string; elem : TFhirObservation);
    procedure ComposeOperationOutcomeIssue(xml : TXmlBuilder; name : string; elem : TFhirOperationOutcomeIssue);
    procedure ComposeOperationOutcome(xml : TXmlBuilder; name : string; elem : TFhirOperationOutcome);
    procedure ComposeOrderWhen(xml : TXmlBuilder; name : string; elem : TFhirOrderWhen);
    procedure ComposeOrder(xml : TXmlBuilder; name : string; elem : TFhirOrder);
    procedure ComposeOrderResponse(xml : TXmlBuilder; name : string; elem : TFhirOrderResponse);
    procedure ComposeOrganizationContact(xml : TXmlBuilder; name : string; elem : TFhirOrganizationContact);
    procedure ComposeOrganization(xml : TXmlBuilder; name : string; elem : TFhirOrganization);
    procedure ComposeOther(xml : TXmlBuilder; name : string; elem : TFhirOther);
    procedure ComposePatientContact(xml : TXmlBuilder; name : string; elem : TFhirPatientContact);
    procedure ComposePatientAnimal(xml : TXmlBuilder; name : string; elem : TFhirPatientAnimal);
    procedure ComposePatientLink(xml : TXmlBuilder; name : string; elem : TFhirPatientLink);
    procedure ComposePatient(xml : TXmlBuilder; name : string; elem : TFhirPatient);
    procedure ComposePractitionerQualification(xml : TXmlBuilder; name : string; elem : TFhirPractitionerQualification);
    procedure ComposePractitioner(xml : TXmlBuilder; name : string; elem : TFhirPractitioner);
    procedure ComposeProcedurePerformer(xml : TXmlBuilder; name : string; elem : TFhirProcedurePerformer);
    procedure ComposeProcedureRelatedItem(xml : TXmlBuilder; name : string; elem : TFhirProcedureRelatedItem);
    procedure ComposeProcedure(xml : TXmlBuilder; name : string; elem : TFhirProcedure);
    procedure ComposeProfileMapping(xml : TXmlBuilder; name : string; elem : TFhirProfileMapping);
    procedure ComposeProfileStructure(xml : TXmlBuilder; name : string; elem : TFhirProfileStructure);
    procedure ComposeProfileStructureElement(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureElement);
    procedure ComposeProfileStructureElementSlicing(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureElementSlicing);
    procedure ComposeProfileStructureElementDefinition(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureElementDefinition);
    procedure ComposeProfileStructureElementDefinitionType(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureElementDefinitionType);
    procedure ComposeProfileStructureElementDefinitionConstraint(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureElementDefinitionConstraint);
    procedure ComposeProfileStructureElementDefinitionBinding(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureElementDefinitionBinding);
    procedure ComposeProfileStructureElementDefinitionMapping(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureElementDefinitionMapping);
    procedure ComposeProfileStructureSearchParam(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureSearchParam);
    procedure ComposeProfileExtensionDefn(xml : TXmlBuilder; name : string; elem : TFhirProfileExtensionDefn);
    procedure ComposeProfileQuery(xml : TXmlBuilder; name : string; elem : TFhirProfileQuery);
    procedure ComposeProfile(xml : TXmlBuilder; name : string; elem : TFhirProfile);
    procedure ComposeProvenanceAgent(xml : TXmlBuilder; name : string; elem : TFhirProvenanceAgent);
    procedure ComposeProvenanceEntity(xml : TXmlBuilder; name : string; elem : TFhirProvenanceEntity);
    procedure ComposeProvenance(xml : TXmlBuilder; name : string; elem : TFhirProvenance);
    procedure ComposeQueryResponse(xml : TXmlBuilder; name : string; elem : TFhirQueryResponse);
    procedure ComposeQuery(xml : TXmlBuilder; name : string; elem : TFhirQuery);
    procedure ComposeQuestionnaireGroup(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireGroup);
    procedure ComposeQuestionnaireGroupQuestion(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireGroupQuestion);
    procedure ComposeQuestionnaire(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaire);
    procedure ComposeRelatedPerson(xml : TXmlBuilder; name : string; elem : TFhirRelatedPerson);
    procedure ComposeSecurityEventEvent(xml : TXmlBuilder; name : string; elem : TFhirSecurityEventEvent);
    procedure ComposeSecurityEventParticipant(xml : TXmlBuilder; name : string; elem : TFhirSecurityEventParticipant);
    procedure ComposeSecurityEventParticipantNetwork(xml : TXmlBuilder; name : string; elem : TFhirSecurityEventParticipantNetwork);
    procedure ComposeSecurityEventSource(xml : TXmlBuilder; name : string; elem : TFhirSecurityEventSource);
    procedure ComposeSecurityEventObject(xml : TXmlBuilder; name : string; elem : TFhirSecurityEventObject);
    procedure ComposeSecurityEventObjectDetail(xml : TXmlBuilder; name : string; elem : TFhirSecurityEventObjectDetail);
    procedure ComposeSecurityEvent(xml : TXmlBuilder; name : string; elem : TFhirSecurityEvent);
    procedure ComposeSpecimenSource(xml : TXmlBuilder; name : string; elem : TFhirSpecimenSource);
    procedure ComposeSpecimenCollection(xml : TXmlBuilder; name : string; elem : TFhirSpecimenCollection);
    procedure ComposeSpecimenTreatment(xml : TXmlBuilder; name : string; elem : TFhirSpecimenTreatment);
    procedure ComposeSpecimenContainer(xml : TXmlBuilder; name : string; elem : TFhirSpecimenContainer);
    procedure ComposeSpecimen(xml : TXmlBuilder; name : string; elem : TFhirSpecimen);
    procedure ComposeSubstanceInstance(xml : TXmlBuilder; name : string; elem : TFhirSubstanceInstance);
    procedure ComposeSubstanceIngredient(xml : TXmlBuilder; name : string; elem : TFhirSubstanceIngredient);
    procedure ComposeSubstance(xml : TXmlBuilder; name : string; elem : TFhirSubstance);
    procedure ComposeSupplyDispense(xml : TXmlBuilder; name : string; elem : TFhirSupplyDispense);
    procedure ComposeSupply(xml : TXmlBuilder; name : string; elem : TFhirSupply);
    procedure ComposeValueSetDefine(xml : TXmlBuilder; name : string; elem : TFhirValueSetDefine);
    procedure ComposeValueSetDefineConcept(xml : TXmlBuilder; name : string; elem : TFhirValueSetDefineConcept);
    procedure ComposeValueSetCompose(xml : TXmlBuilder; name : string; elem : TFhirValueSetCompose);
    procedure ComposeValueSetComposeInclude(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeInclude);
    procedure ComposeValueSetComposeIncludeFilter(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeIncludeFilter);
    procedure ComposeValueSetExpansion(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansion);
    procedure ComposeValueSetExpansionContains(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansionContains);
    procedure ComposeValueSet(xml : TXmlBuilder; name : string; elem : TFhirValueSet);
    procedure ComposeResource(xml : TXmlBuilder; id, ver : String; resource : TFhirResource); override;
  end;

  TFHIRJsonParser = class (TFHIRJsonParserBase)
  protected
    procedure ParseElementProperties(jsn : TJsonObject; element : TFhirElement);
    procedure ParseBackboneElementProperties(jsn : TJsonObject; element : TFhirBackboneElement);

    procedure ParseEnum(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList; Const aNames : Array Of String); overload;
    function ParseEnum(value : string; jsn : TJsonObject; Const aNames : Array Of String) : TFHIREnum; overload;
    procedure ParseInteger(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseInteger(value : string; jsn : TJsonObject) : TFHIRInteger; overload;
    procedure ParseDateTime(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseDateTime(value : string; jsn : TJsonObject) : TFHIRDateTime; overload;
    procedure ParseDate(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseDate(value : string; jsn : TJsonObject) : TFHIRDate; overload;
    procedure ParseDecimal(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseDecimal(value : string; jsn : TJsonObject) : TFHIRDecimal; overload;
    procedure ParseUri(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseUri(value : string; jsn : TJsonObject) : TFHIRUri; overload;
    procedure ParseBase64Binary(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseBase64Binary(value : string; jsn : TJsonObject) : TFHIRBase64Binary; overload;
    procedure ParseString(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseString(value : string; jsn : TJsonObject) : TFHIRString; overload;
    procedure ParseBoolean(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseBoolean(value : string; jsn : TJsonObject) : TFHIRBoolean; overload;
    procedure ParseInstant(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseInstant(value : string; jsn : TJsonObject) : TFHIRInstant; overload;
    procedure ParseCode(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseCode(value : string; jsn : TJsonObject) : TFHIRCode; overload;
    procedure ParseId(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseId(value : string; jsn : TJsonObject) : TFHIRId; overload;
    procedure ParseOid(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseOid(value : string; jsn : TJsonObject) : TFHIROid; overload;
    procedure ParseUuid(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseUuid(value : string; jsn : TJsonObject) : TFHIRUuid; overload;

    procedure ParseResourceProperties(jsn : TJsonObject; resource : TFhirResource);

    function ParseExtension(jsn : TJsonObject) : TFhirExtension; overload;
    procedure ParseExtension(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNarrative(jsn : TJsonObject) : TFhirNarrative; overload;
    procedure ParseNarrative(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePeriod(jsn : TJsonObject) : TFhirPeriod; overload;
    procedure ParsePeriod(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCoding(jsn : TJsonObject) : TFhirCoding; overload;
    procedure ParseCoding(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRange(jsn : TJsonObject) : TFhirRange; overload;
    procedure ParseRange(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuantity(jsn : TJsonObject) : TFhirQuantity; overload;
    procedure ParseQuantity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAttachment(jsn : TJsonObject) : TFhirAttachment; overload;
    procedure ParseAttachment(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRatio(jsn : TJsonObject) : TFhirRatio; overload;
    procedure ParseRatio(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSampledData(jsn : TJsonObject) : TFhirSampledData; overload;
    procedure ParseSampledData(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseResourceReference(jsn : TJsonObject) : TFhirResourceReference; overload;
    procedure ParseResourceReference(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCodeableConcept(jsn : TJsonObject) : TFhirCodeableConcept; overload;
    procedure ParseCodeableConcept(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseIdentifier(jsn : TJsonObject) : TFhirIdentifier; overload;
    procedure ParseIdentifier(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseScheduleRepeat(jsn : TJsonObject) : TFhirScheduleRepeat; overload; {b\}
    procedure ParseScheduleRepeat(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSchedule(jsn : TJsonObject) : TFhirSchedule; overload;
    procedure ParseSchedule(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContact(jsn : TJsonObject) : TFhirContact; overload;
    procedure ParseContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAddress(jsn : TJsonObject) : TFhirAddress; overload;
    procedure ParseAddress(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseHumanName(jsn : TJsonObject) : TFhirHumanName; overload;
    procedure ParseHumanName(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAge(jsn : TJsonObject) : TFhirAge; overload;
    function ParseCount(jsn : TJsonObject) : TFhirCount; overload;
    function ParseMoney(jsn : TJsonObject) : TFhirMoney; overload;
    function ParseDistance(jsn : TJsonObject) : TFhirDistance; overload;
    function ParseDuration(jsn : TJsonObject) : TFhirDuration; overload;

    function ParseAdverseReactionSymptom(jsn : TJsonObject) : TFhirAdverseReactionSymptom; overload; {b\}
    procedure ParseAdverseReactionSymptom(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAdverseReactionExposure(jsn : TJsonObject) : TFhirAdverseReactionExposure; overload; {b\}
    procedure ParseAdverseReactionExposure(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAdverseReaction(jsn : TJsonObject) : TFhirAdverseReaction; overload; {b|}
    procedure ParseAdverseReaction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAlert(jsn : TJsonObject) : TFhirAlert; overload; {b|}
    procedure ParseAlert(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAllergyIntolerance(jsn : TJsonObject) : TFhirAllergyIntolerance; overload; {b|}
    procedure ParseAllergyIntolerance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCarePlanParticipant(jsn : TJsonObject) : TFhirCarePlanParticipant; overload; {b\}
    procedure ParseCarePlanParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCarePlanGoal(jsn : TJsonObject) : TFhirCarePlanGoal; overload; {b\}
    procedure ParseCarePlanGoal(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCarePlanActivity(jsn : TJsonObject) : TFhirCarePlanActivity; overload; {b\}
    procedure ParseCarePlanActivity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCarePlanActivitySimple(jsn : TJsonObject) : TFhirCarePlanActivitySimple; overload; {b\}
    procedure ParseCarePlanActivitySimple(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCarePlan(jsn : TJsonObject) : TFhirCarePlan; overload; {b|}
    procedure ParseCarePlan(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCompositionAttester(jsn : TJsonObject) : TFhirCompositionAttester; overload; {b\}
    procedure ParseCompositionAttester(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCompositionEvent(jsn : TJsonObject) : TFhirCompositionEvent; overload; {b\}
    procedure ParseCompositionEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCompositionSection(jsn : TJsonObject) : TFhirCompositionSection; overload; {b\}
    procedure ParseCompositionSection(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseComposition(jsn : TJsonObject) : TFhirComposition; overload; {b|}
    procedure ParseComposition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMapConcept(jsn : TJsonObject) : TFhirConceptMapConcept; overload; {b\}
    procedure ParseConceptMapConcept(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMapConceptDependsOn(jsn : TJsonObject) : TFhirConceptMapConceptDependsOn; overload; {b\}
    procedure ParseConceptMapConceptDependsOn(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMapConceptMap(jsn : TJsonObject) : TFhirConceptMapConceptMap; overload; {b\}
    procedure ParseConceptMapConceptMap(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMap(jsn : TJsonObject) : TFhirConceptMap; overload; {b|}
    procedure ParseConceptMap(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConditionStage(jsn : TJsonObject) : TFhirConditionStage; overload; {b\}
    procedure ParseConditionStage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConditionEvidence(jsn : TJsonObject) : TFhirConditionEvidence; overload; {b\}
    procedure ParseConditionEvidence(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConditionLocation(jsn : TJsonObject) : TFhirConditionLocation; overload; {b\}
    procedure ParseConditionLocation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConditionRelatedItem(jsn : TJsonObject) : TFhirConditionRelatedItem; overload; {b\}
    procedure ParseConditionRelatedItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCondition(jsn : TJsonObject) : TFhirCondition; overload; {b|}
    procedure ParseCondition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceSoftware(jsn : TJsonObject) : TFhirConformanceSoftware; overload; {b\}
    procedure ParseConformanceSoftware(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceImplementation(jsn : TJsonObject) : TFhirConformanceImplementation; overload; {b\}
    procedure ParseConformanceImplementation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRest(jsn : TJsonObject) : TFhirConformanceRest; overload; {b\}
    procedure ParseConformanceRest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestSecurity(jsn : TJsonObject) : TFhirConformanceRestSecurity; overload; {b\}
    procedure ParseConformanceRestSecurity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestSecurityCertificate(jsn : TJsonObject) : TFhirConformanceRestSecurityCertificate; overload; {b\}
    procedure ParseConformanceRestSecurityCertificate(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestResource(jsn : TJsonObject) : TFhirConformanceRestResource; overload; {b\}
    procedure ParseConformanceRestResource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestResourceOperation(jsn : TJsonObject) : TFhirConformanceRestResourceOperation; overload; {b\}
    procedure ParseConformanceRestResourceOperation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestResourceSearchParam(jsn : TJsonObject) : TFhirConformanceRestResourceSearchParam; overload; {b\}
    procedure ParseConformanceRestResourceSearchParam(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestOperation(jsn : TJsonObject) : TFhirConformanceRestOperation; overload; {b\}
    procedure ParseConformanceRestOperation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestQuery(jsn : TJsonObject) : TFhirConformanceRestQuery; overload; {b\}
    procedure ParseConformanceRestQuery(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceMessaging(jsn : TJsonObject) : TFhirConformanceMessaging; overload; {b\}
    procedure ParseConformanceMessaging(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceMessagingEvent(jsn : TJsonObject) : TFhirConformanceMessagingEvent; overload; {b\}
    procedure ParseConformanceMessagingEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceDocument(jsn : TJsonObject) : TFhirConformanceDocument; overload; {b\}
    procedure ParseConformanceDocument(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformance(jsn : TJsonObject) : TFhirConformance; overload; {b|}
    procedure ParseConformance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDevice(jsn : TJsonObject) : TFhirDevice; overload; {b|}
    procedure ParseDevice(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceObservationReportVirtualDevice(jsn : TJsonObject) : TFhirDeviceObservationReportVirtualDevice; overload; {b\}
    procedure ParseDeviceObservationReportVirtualDevice(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceObservationReportVirtualDeviceChannel(jsn : TJsonObject) : TFhirDeviceObservationReportVirtualDeviceChannel; overload; {b\}
    procedure ParseDeviceObservationReportVirtualDeviceChannel(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceObservationReportVirtualDeviceChannelMetric(jsn : TJsonObject) : TFhirDeviceObservationReportVirtualDeviceChannelMetric; overload; {b\}
    procedure ParseDeviceObservationReportVirtualDeviceChannelMetric(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceObservationReport(jsn : TJsonObject) : TFhirDeviceObservationReport; overload; {b|}
    procedure ParseDeviceObservationReport(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDiagnosticOrderEvent(jsn : TJsonObject) : TFhirDiagnosticOrderEvent; overload; {b\}
    procedure ParseDiagnosticOrderEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDiagnosticOrderItem(jsn : TJsonObject) : TFhirDiagnosticOrderItem; overload; {b\}
    procedure ParseDiagnosticOrderItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDiagnosticOrder(jsn : TJsonObject) : TFhirDiagnosticOrder; overload; {b|}
    procedure ParseDiagnosticOrder(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDiagnosticReportImage(jsn : TJsonObject) : TFhirDiagnosticReportImage; overload; {b\}
    procedure ParseDiagnosticReportImage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDiagnosticReport(jsn : TJsonObject) : TFhirDiagnosticReport; overload; {b|}
    procedure ParseDiagnosticReport(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentManifest(jsn : TJsonObject) : TFhirDocumentManifest; overload; {b|}
    procedure ParseDocumentManifest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReferenceRelatesTo(jsn : TJsonObject) : TFhirDocumentReferenceRelatesTo; overload; {b\}
    procedure ParseDocumentReferenceRelatesTo(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReferenceService(jsn : TJsonObject) : TFhirDocumentReferenceService; overload; {b\}
    procedure ParseDocumentReferenceService(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReferenceServiceParameter(jsn : TJsonObject) : TFhirDocumentReferenceServiceParameter; overload; {b\}
    procedure ParseDocumentReferenceServiceParameter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReferenceContext(jsn : TJsonObject) : TFhirDocumentReferenceContext; overload; {b\}
    procedure ParseDocumentReferenceContext(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReference(jsn : TJsonObject) : TFhirDocumentReference; overload; {b|}
    procedure ParseDocumentReference(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounterParticipant(jsn : TJsonObject) : TFhirEncounterParticipant; overload; {b\}
    procedure ParseEncounterParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounterHospitalization(jsn : TJsonObject) : TFhirEncounterHospitalization; overload; {b\}
    procedure ParseEncounterHospitalization(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounterHospitalizationAccomodation(jsn : TJsonObject) : TFhirEncounterHospitalizationAccomodation; overload; {b\}
    procedure ParseEncounterHospitalizationAccomodation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounterLocation(jsn : TJsonObject) : TFhirEncounterLocation; overload; {b\}
    procedure ParseEncounterLocation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounter(jsn : TJsonObject) : TFhirEncounter; overload; {b|}
    procedure ParseEncounter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseFamilyHistoryRelation(jsn : TJsonObject) : TFhirFamilyHistoryRelation; overload; {b\}
    procedure ParseFamilyHistoryRelation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseFamilyHistoryRelationCondition(jsn : TJsonObject) : TFhirFamilyHistoryRelationCondition; overload; {b\}
    procedure ParseFamilyHistoryRelationCondition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseFamilyHistory(jsn : TJsonObject) : TFhirFamilyHistory; overload; {b|}
    procedure ParseFamilyHistory(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseGroupCharacteristic(jsn : TJsonObject) : TFhirGroupCharacteristic; overload; {b\}
    procedure ParseGroupCharacteristic(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseGroup(jsn : TJsonObject) : TFhirGroup; overload; {b|}
    procedure ParseGroup(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingStudySeries(jsn : TJsonObject) : TFhirImagingStudySeries; overload; {b\}
    procedure ParseImagingStudySeries(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingStudySeriesInstance(jsn : TJsonObject) : TFhirImagingStudySeriesInstance; overload; {b\}
    procedure ParseImagingStudySeriesInstance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingStudy(jsn : TJsonObject) : TFhirImagingStudy; overload; {b|}
    procedure ParseImagingStudy(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationExplanation(jsn : TJsonObject) : TFhirImmunizationExplanation; overload; {b\}
    procedure ParseImmunizationExplanation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationReaction(jsn : TJsonObject) : TFhirImmunizationReaction; overload; {b\}
    procedure ParseImmunizationReaction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationVaccinationProtocol(jsn : TJsonObject) : TFhirImmunizationVaccinationProtocol; overload; {b\}
    procedure ParseImmunizationVaccinationProtocol(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunization(jsn : TJsonObject) : TFhirImmunization; overload; {b|}
    procedure ParseImmunization(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationRecommendationRecommendation(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendation; overload; {b\}
    procedure ParseImmunizationRecommendationRecommendation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationRecommendationRecommendationDateCriterion(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendationDateCriterion; overload; {b\}
    procedure ParseImmunizationRecommendationRecommendationDateCriterion(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationRecommendationRecommendationProtocol(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendationProtocol; overload; {b\}
    procedure ParseImmunizationRecommendationRecommendationProtocol(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationRecommendation(jsn : TJsonObject) : TFhirImmunizationRecommendation; overload; {b|}
    procedure ParseImmunizationRecommendation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseListEntry(jsn : TJsonObject) : TFhirListEntry; overload; {b\}
    procedure ParseListEntry(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseList(jsn : TJsonObject) : TFhirList; overload; {b|}
    procedure ParseList(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseLocationPosition(jsn : TJsonObject) : TFhirLocationPosition; overload; {b\}
    procedure ParseLocationPosition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseLocation(jsn : TJsonObject) : TFhirLocation; overload; {b|}
    procedure ParseLocation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedia(jsn : TJsonObject) : TFhirMedia; overload; {b|}
    procedure ParseMedia(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationProduct(jsn : TJsonObject) : TFhirMedicationProduct; overload; {b\}
    procedure ParseMedicationProduct(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationProductIngredient(jsn : TJsonObject) : TFhirMedicationProductIngredient; overload; {b\}
    procedure ParseMedicationProductIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationPackage(jsn : TJsonObject) : TFhirMedicationPackage; overload; {b\}
    procedure ParseMedicationPackage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationPackageContent(jsn : TJsonObject) : TFhirMedicationPackageContent; overload; {b\}
    procedure ParseMedicationPackageContent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedication(jsn : TJsonObject) : TFhirMedication; overload; {b|}
    procedure ParseMedication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationAdministrationDosage(jsn : TJsonObject) : TFhirMedicationAdministrationDosage; overload; {b\}
    procedure ParseMedicationAdministrationDosage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationAdministration(jsn : TJsonObject) : TFhirMedicationAdministration; overload; {b|}
    procedure ParseMedicationAdministration(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationDispenseDispense(jsn : TJsonObject) : TFhirMedicationDispenseDispense; overload; {b\}
    procedure ParseMedicationDispenseDispense(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationDispenseDispenseDosage(jsn : TJsonObject) : TFhirMedicationDispenseDispenseDosage; overload; {b\}
    procedure ParseMedicationDispenseDispenseDosage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationDispenseSubstitution(jsn : TJsonObject) : TFhirMedicationDispenseSubstitution; overload; {b\}
    procedure ParseMedicationDispenseSubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationDispense(jsn : TJsonObject) : TFhirMedicationDispense; overload; {b|}
    procedure ParseMedicationDispense(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationPrescriptionDosageInstruction(jsn : TJsonObject) : TFhirMedicationPrescriptionDosageInstruction; overload; {b\}
    procedure ParseMedicationPrescriptionDosageInstruction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationPrescriptionDispense(jsn : TJsonObject) : TFhirMedicationPrescriptionDispense; overload; {b\}
    procedure ParseMedicationPrescriptionDispense(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationPrescriptionSubstitution(jsn : TJsonObject) : TFhirMedicationPrescriptionSubstitution; overload; {b\}
    procedure ParseMedicationPrescriptionSubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationPrescription(jsn : TJsonObject) : TFhirMedicationPrescription; overload; {b|}
    procedure ParseMedicationPrescription(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationStatementDosage(jsn : TJsonObject) : TFhirMedicationStatementDosage; overload; {b\}
    procedure ParseMedicationStatementDosage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationStatement(jsn : TJsonObject) : TFhirMedicationStatement; overload; {b|}
    procedure ParseMedicationStatement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMessageHeaderResponse(jsn : TJsonObject) : TFhirMessageHeaderResponse; overload; {b\}
    procedure ParseMessageHeaderResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMessageHeaderSource(jsn : TJsonObject) : TFhirMessageHeaderSource; overload; {b\}
    procedure ParseMessageHeaderSource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMessageHeaderDestination(jsn : TJsonObject) : TFhirMessageHeaderDestination; overload; {b\}
    procedure ParseMessageHeaderDestination(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMessageHeader(jsn : TJsonObject) : TFhirMessageHeader; overload; {b|}
    procedure ParseMessageHeader(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseObservationReferenceRange(jsn : TJsonObject) : TFhirObservationReferenceRange; overload; {b\}
    procedure ParseObservationReferenceRange(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseObservationRelated(jsn : TJsonObject) : TFhirObservationRelated; overload; {b\}
    procedure ParseObservationRelated(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseObservation(jsn : TJsonObject) : TFhirObservation; overload; {b|}
    procedure ParseObservation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationOutcomeIssue(jsn : TJsonObject) : TFhirOperationOutcomeIssue; overload; {b\}
    procedure ParseOperationOutcomeIssue(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationOutcome(jsn : TJsonObject) : TFhirOperationOutcome; overload; {b|}
    procedure ParseOperationOutcome(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOrderWhen(jsn : TJsonObject) : TFhirOrderWhen; overload; {b\}
    procedure ParseOrderWhen(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOrder(jsn : TJsonObject) : TFhirOrder; overload; {b|}
    procedure ParseOrder(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOrderResponse(jsn : TJsonObject) : TFhirOrderResponse; overload; {b|}
    procedure ParseOrderResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOrganizationContact(jsn : TJsonObject) : TFhirOrganizationContact; overload; {b\}
    procedure ParseOrganizationContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOrganization(jsn : TJsonObject) : TFhirOrganization; overload; {b|}
    procedure ParseOrganization(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOther(jsn : TJsonObject) : TFhirOther; overload; {b|}
    procedure ParseOther(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePatientContact(jsn : TJsonObject) : TFhirPatientContact; overload; {b\}
    procedure ParsePatientContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePatientAnimal(jsn : TJsonObject) : TFhirPatientAnimal; overload; {b\}
    procedure ParsePatientAnimal(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePatientLink(jsn : TJsonObject) : TFhirPatientLink; overload; {b\}
    procedure ParsePatientLink(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePatient(jsn : TJsonObject) : TFhirPatient; overload; {b|}
    procedure ParsePatient(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePractitionerQualification(jsn : TJsonObject) : TFhirPractitionerQualification; overload; {b\}
    procedure ParsePractitionerQualification(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePractitioner(jsn : TJsonObject) : TFhirPractitioner; overload; {b|}
    procedure ParsePractitioner(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcedurePerformer(jsn : TJsonObject) : TFhirProcedurePerformer; overload; {b\}
    procedure ParseProcedurePerformer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcedureRelatedItem(jsn : TJsonObject) : TFhirProcedureRelatedItem; overload; {b\}
    procedure ParseProcedureRelatedItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcedure(jsn : TJsonObject) : TFhirProcedure; overload; {b|}
    procedure ParseProcedure(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfileMapping(jsn : TJsonObject) : TFhirProfileMapping; overload; {b\}
    procedure ParseProfileMapping(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfileStructure(jsn : TJsonObject) : TFhirProfileStructure; overload; {b\}
    procedure ParseProfileStructure(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfileStructureElement(jsn : TJsonObject) : TFhirProfileStructureElement; overload; {b\}
    procedure ParseProfileStructureElement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfileStructureElementSlicing(jsn : TJsonObject) : TFhirProfileStructureElementSlicing; overload; {b\}
    procedure ParseProfileStructureElementSlicing(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfileStructureElementDefinition(jsn : TJsonObject) : TFhirProfileStructureElementDefinition; overload; {b\}
    procedure ParseProfileStructureElementDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfileStructureElementDefinitionType(jsn : TJsonObject) : TFhirProfileStructureElementDefinitionType; overload; {b\}
    procedure ParseProfileStructureElementDefinitionType(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfileStructureElementDefinitionConstraint(jsn : TJsonObject) : TFhirProfileStructureElementDefinitionConstraint; overload; {b\}
    procedure ParseProfileStructureElementDefinitionConstraint(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfileStructureElementDefinitionBinding(jsn : TJsonObject) : TFhirProfileStructureElementDefinitionBinding; overload; {b\}
    procedure ParseProfileStructureElementDefinitionBinding(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfileStructureElementDefinitionMapping(jsn : TJsonObject) : TFhirProfileStructureElementDefinitionMapping; overload; {b\}
    procedure ParseProfileStructureElementDefinitionMapping(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfileStructureSearchParam(jsn : TJsonObject) : TFhirProfileStructureSearchParam; overload; {b\}
    procedure ParseProfileStructureSearchParam(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfileExtensionDefn(jsn : TJsonObject) : TFhirProfileExtensionDefn; overload; {b\}
    procedure ParseProfileExtensionDefn(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfileQuery(jsn : TJsonObject) : TFhirProfileQuery; overload; {b\}
    procedure ParseProfileQuery(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProfile(jsn : TJsonObject) : TFhirProfile; overload; {b|}
    procedure ParseProfile(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProvenanceAgent(jsn : TJsonObject) : TFhirProvenanceAgent; overload; {b\}
    procedure ParseProvenanceAgent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProvenanceEntity(jsn : TJsonObject) : TFhirProvenanceEntity; overload; {b\}
    procedure ParseProvenanceEntity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProvenance(jsn : TJsonObject) : TFhirProvenance; overload; {b|}
    procedure ParseProvenance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQueryResponse(jsn : TJsonObject) : TFhirQueryResponse; overload; {b\}
    procedure ParseQueryResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuery(jsn : TJsonObject) : TFhirQuery; overload; {b|}
    procedure ParseQuery(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireGroup(jsn : TJsonObject) : TFhirQuestionnaireGroup; overload; {b\}
    procedure ParseQuestionnaireGroup(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireGroupQuestion(jsn : TJsonObject) : TFhirQuestionnaireGroupQuestion; overload; {b\}
    procedure ParseQuestionnaireGroupQuestion(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaire(jsn : TJsonObject) : TFhirQuestionnaire; overload; {b|}
    procedure ParseQuestionnaire(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRelatedPerson(jsn : TJsonObject) : TFhirRelatedPerson; overload; {b|}
    procedure ParseRelatedPerson(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSecurityEventEvent(jsn : TJsonObject) : TFhirSecurityEventEvent; overload; {b\}
    procedure ParseSecurityEventEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSecurityEventParticipant(jsn : TJsonObject) : TFhirSecurityEventParticipant; overload; {b\}
    procedure ParseSecurityEventParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSecurityEventParticipantNetwork(jsn : TJsonObject) : TFhirSecurityEventParticipantNetwork; overload; {b\}
    procedure ParseSecurityEventParticipantNetwork(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSecurityEventSource(jsn : TJsonObject) : TFhirSecurityEventSource; overload; {b\}
    procedure ParseSecurityEventSource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSecurityEventObject(jsn : TJsonObject) : TFhirSecurityEventObject; overload; {b\}
    procedure ParseSecurityEventObject(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSecurityEventObjectDetail(jsn : TJsonObject) : TFhirSecurityEventObjectDetail; overload; {b\}
    procedure ParseSecurityEventObjectDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSecurityEvent(jsn : TJsonObject) : TFhirSecurityEvent; overload; {b|}
    procedure ParseSecurityEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimenSource(jsn : TJsonObject) : TFhirSpecimenSource; overload; {b\}
    procedure ParseSpecimenSource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimenCollection(jsn : TJsonObject) : TFhirSpecimenCollection; overload; {b\}
    procedure ParseSpecimenCollection(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimenTreatment(jsn : TJsonObject) : TFhirSpecimenTreatment; overload; {b\}
    procedure ParseSpecimenTreatment(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimenContainer(jsn : TJsonObject) : TFhirSpecimenContainer; overload; {b\}
    procedure ParseSpecimenContainer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimen(jsn : TJsonObject) : TFhirSpecimen; overload; {b|}
    procedure ParseSpecimen(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceInstance(jsn : TJsonObject) : TFhirSubstanceInstance; overload; {b\}
    procedure ParseSubstanceInstance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceIngredient(jsn : TJsonObject) : TFhirSubstanceIngredient; overload; {b\}
    procedure ParseSubstanceIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstance(jsn : TJsonObject) : TFhirSubstance; overload; {b|}
    procedure ParseSubstance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSupplyDispense(jsn : TJsonObject) : TFhirSupplyDispense; overload; {b\}
    procedure ParseSupplyDispense(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSupply(jsn : TJsonObject) : TFhirSupply; overload; {b|}
    procedure ParseSupply(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetDefine(jsn : TJsonObject) : TFhirValueSetDefine; overload; {b\}
    procedure ParseValueSetDefine(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetDefineConcept(jsn : TJsonObject) : TFhirValueSetDefineConcept; overload; {b\}
    procedure ParseValueSetDefineConcept(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetCompose(jsn : TJsonObject) : TFhirValueSetCompose; overload; {b\}
    procedure ParseValueSetCompose(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetComposeInclude(jsn : TJsonObject) : TFhirValueSetComposeInclude; overload; {b\}
    procedure ParseValueSetComposeInclude(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetComposeIncludeFilter(jsn : TJsonObject) : TFhirValueSetComposeIncludeFilter; overload; {b\}
    procedure ParseValueSetComposeIncludeFilter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetExpansion(jsn : TJsonObject) : TFhirValueSetExpansion; overload; {b\}
    procedure ParseValueSetExpansion(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetExpansionContains(jsn : TJsonObject) : TFhirValueSetExpansionContains; overload; {b\}
    procedure ParseValueSetExpansionContains(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSet(jsn : TJsonObject) : TFhirValueSet; overload; {b|}
    procedure ParseValueSet(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseResource(jsn : TJsonObject) : TFhirResource; override;
  public
    function ParseFragment(jsn : TJsonObject; type_ : String) : TFhirElement;  overload;
  end;

  TFHIRJsonComposer = class (TFHIRJsonComposerBase)
  protected
    Procedure ComposeElementProperties(json : TJSONWriter; elem : TFhirElement);
    Procedure ComposeBackboneElementProperties(json : TJSONWriter; elem : TFhirBackboneElement);

    Procedure ComposeEnumValue(json : TJSONWriter; name : String; value : TFhirEnum; Const aNames : Array Of String; inArray : boolean);
    Procedure ComposeEnumProps(json : TJSONWriter; name : String; value : TFhirEnum; Const aNames : Array Of String; inArray : boolean);
    Procedure ComposeIntegerValue(json : TJSONWriter; name : String; value : TFhirInteger; inArray : boolean);
    Procedure ComposeIntegerProps(json : TJSONWriter; name : String; value : TFhirInteger; inArray : boolean);
    Procedure ComposeDateTimeValue(json : TJSONWriter; name : String; value : TFhirDateTime; inArray : boolean);
    Procedure ComposeDateTimeProps(json : TJSONWriter; name : String; value : TFhirDateTime; inArray : boolean);
    Procedure ComposeDateValue(json : TJSONWriter; name : String; value : TFhirDate; inArray : boolean);
    Procedure ComposeDateProps(json : TJSONWriter; name : String; value : TFhirDate; inArray : boolean);
    Procedure ComposeDecimalValue(json : TJSONWriter; name : String; value : TFhirDecimal; inArray : boolean);
    Procedure ComposeDecimalProps(json : TJSONWriter; name : String; value : TFhirDecimal; inArray : boolean);
    Procedure ComposeUriValue(json : TJSONWriter; name : String; value : TFhirUri; inArray : boolean);
    Procedure ComposeUriProps(json : TJSONWriter; name : String; value : TFhirUri; inArray : boolean);
    Procedure ComposeBase64BinaryValue(json : TJSONWriter; name : String; value : TFhirBase64Binary; inArray : boolean);
    Procedure ComposeBase64BinaryProps(json : TJSONWriter; name : String; value : TFhirBase64Binary; inArray : boolean);
    Procedure ComposeStringValue(json : TJSONWriter; name : String; value : TFhirString; inArray : boolean);
    Procedure ComposeStringProps(json : TJSONWriter; name : String; value : TFhirString; inArray : boolean);
    Procedure ComposeBooleanValue(json : TJSONWriter; name : String; value : TFhirBoolean; inArray : boolean);
    Procedure ComposeBooleanProps(json : TJSONWriter; name : String; value : TFhirBoolean; inArray : boolean);
    Procedure ComposeInstantValue(json : TJSONWriter; name : String; value : TFhirInstant; inArray : boolean);
    Procedure ComposeInstantProps(json : TJSONWriter; name : String; value : TFhirInstant; inArray : boolean);
    Procedure ComposeCodeValue(json : TJSONWriter; name : String; value : TFhirCode; inArray : boolean);
    Procedure ComposeCodeProps(json : TJSONWriter; name : String; value : TFhirCode; inArray : boolean);
    Procedure ComposeIdValue(json : TJSONWriter; name : String; value : TFhirId; inArray : boolean);
    Procedure ComposeIdProps(json : TJSONWriter; name : String; value : TFhirId; inArray : boolean);
    Procedure ComposeOidValue(json : TJSONWriter; name : String; value : TFhirOid; inArray : boolean);
    Procedure ComposeOidProps(json : TJSONWriter; name : String; value : TFhirOid; inArray : boolean);
    Procedure ComposeUuidValue(json : TJSONWriter; name : String; value : TFhirUuid; inArray : boolean);
    Procedure ComposeUuidProps(json : TJSONWriter; name : String; value : TFhirUuid; inArray : boolean);

    Procedure ComposeResourceProperties(json : TJSONWriter; resource : TFhirResource);

    procedure ComposeExtension(json : TJSONWriter; name : string; elem : TFhirExtension);
    procedure ComposeNarrative(json : TJSONWriter; name : string; elem : TFhirNarrative);
    procedure ComposePeriod(json : TJSONWriter; name : string; elem : TFhirPeriod);
    procedure ComposeCoding(json : TJSONWriter; name : string; elem : TFhirCoding);
    procedure ComposeRange(json : TJSONWriter; name : string; elem : TFhirRange);
    procedure ComposeQuantity(json : TJSONWriter; name : string; elem : TFhirQuantity);
    procedure ComposeAttachment(json : TJSONWriter; name : string; elem : TFhirAttachment);
    procedure ComposeRatio(json : TJSONWriter; name : string; elem : TFhirRatio);
    procedure ComposeSampledData(json : TJSONWriter; name : string; elem : TFhirSampledData);
    procedure ComposeResourceReference(json : TJSONWriter; name : string; elem : TFhirResourceReference);
    procedure ComposeCodeableConcept(json : TJSONWriter; name : string; elem : TFhirCodeableConcept);
    procedure ComposeIdentifier(json : TJSONWriter; name : string; elem : TFhirIdentifier);
    procedure ComposeScheduleRepeat(json : TJSONWriter; name : string; elem : TFhirScheduleRepeat);
    procedure ComposeSchedule(json : TJSONWriter; name : string; elem : TFhirSchedule);
    procedure ComposeContact(json : TJSONWriter; name : string; elem : TFhirContact);
    procedure ComposeAddress(json : TJSONWriter; name : string; elem : TFhirAddress);
    procedure ComposeHumanName(json : TJSONWriter; name : string; elem : TFhirHumanName);
    procedure ComposeAge(json : TJSONWriter; name : string; elem : TFhirAge);
    procedure ComposeCount(json : TJSONWriter; name : string; elem : TFhirCount);
    procedure ComposeMoney(json : TJSONWriter; name : string; elem : TFhirMoney);
    procedure ComposeDistance(json : TJSONWriter; name : string; elem : TFhirDistance);
    procedure ComposeDuration(json : TJSONWriter; name : string; elem : TFhirDuration);

    procedure ComposeAdverseReactionSymptom(json : TJSONWriter; name : string; elem : TFhirAdverseReactionSymptom);
    procedure ComposeAdverseReactionExposure(json : TJSONWriter; name : string; elem : TFhirAdverseReactionExposure);
    procedure ComposeAdverseReaction(json : TJSONWriter; name : string; elem : TFhirAdverseReaction);
    procedure ComposeAlert(json : TJSONWriter; name : string; elem : TFhirAlert);
    procedure ComposeAllergyIntolerance(json : TJSONWriter; name : string; elem : TFhirAllergyIntolerance);
    procedure ComposeCarePlanParticipant(json : TJSONWriter; name : string; elem : TFhirCarePlanParticipant);
    procedure ComposeCarePlanGoal(json : TJSONWriter; name : string; elem : TFhirCarePlanGoal);
    procedure ComposeCarePlanActivity(json : TJSONWriter; name : string; elem : TFhirCarePlanActivity);
    procedure ComposeCarePlanActivitySimple(json : TJSONWriter; name : string; elem : TFhirCarePlanActivitySimple);
    procedure ComposeCarePlan(json : TJSONWriter; name : string; elem : TFhirCarePlan);
    procedure ComposeCompositionAttester(json : TJSONWriter; name : string; elem : TFhirCompositionAttester);
    procedure ComposeCompositionEvent(json : TJSONWriter; name : string; elem : TFhirCompositionEvent);
    procedure ComposeCompositionSection(json : TJSONWriter; name : string; elem : TFhirCompositionSection);
    procedure ComposeComposition(json : TJSONWriter; name : string; elem : TFhirComposition);
    procedure ComposeConceptMapConcept(json : TJSONWriter; name : string; elem : TFhirConceptMapConcept);
    procedure ComposeConceptMapConceptDependsOn(json : TJSONWriter; name : string; elem : TFhirConceptMapConceptDependsOn);
    procedure ComposeConceptMapConceptMap(json : TJSONWriter; name : string; elem : TFhirConceptMapConceptMap);
    procedure ComposeConceptMap(json : TJSONWriter; name : string; elem : TFhirConceptMap);
    procedure ComposeConditionStage(json : TJSONWriter; name : string; elem : TFhirConditionStage);
    procedure ComposeConditionEvidence(json : TJSONWriter; name : string; elem : TFhirConditionEvidence);
    procedure ComposeConditionLocation(json : TJSONWriter; name : string; elem : TFhirConditionLocation);
    procedure ComposeConditionRelatedItem(json : TJSONWriter; name : string; elem : TFhirConditionRelatedItem);
    procedure ComposeCondition(json : TJSONWriter; name : string; elem : TFhirCondition);
    procedure ComposeConformanceSoftware(json : TJSONWriter; name : string; elem : TFhirConformanceSoftware);
    procedure ComposeConformanceImplementation(json : TJSONWriter; name : string; elem : TFhirConformanceImplementation);
    procedure ComposeConformanceRest(json : TJSONWriter; name : string; elem : TFhirConformanceRest);
    procedure ComposeConformanceRestSecurity(json : TJSONWriter; name : string; elem : TFhirConformanceRestSecurity);
    procedure ComposeConformanceRestSecurityCertificate(json : TJSONWriter; name : string; elem : TFhirConformanceRestSecurityCertificate);
    procedure ComposeConformanceRestResource(json : TJSONWriter; name : string; elem : TFhirConformanceRestResource);
    procedure ComposeConformanceRestResourceOperation(json : TJSONWriter; name : string; elem : TFhirConformanceRestResourceOperation);
    procedure ComposeConformanceRestResourceSearchParam(json : TJSONWriter; name : string; elem : TFhirConformanceRestResourceSearchParam);
    procedure ComposeConformanceRestOperation(json : TJSONWriter; name : string; elem : TFhirConformanceRestOperation);
    procedure ComposeConformanceRestQuery(json : TJSONWriter; name : string; elem : TFhirConformanceRestQuery);
    procedure ComposeConformanceMessaging(json : TJSONWriter; name : string; elem : TFhirConformanceMessaging);
    procedure ComposeConformanceMessagingEvent(json : TJSONWriter; name : string; elem : TFhirConformanceMessagingEvent);
    procedure ComposeConformanceDocument(json : TJSONWriter; name : string; elem : TFhirConformanceDocument);
    procedure ComposeConformance(json : TJSONWriter; name : string; elem : TFhirConformance);
    procedure ComposeDevice(json : TJSONWriter; name : string; elem : TFhirDevice);
    procedure ComposeDeviceObservationReportVirtualDevice(json : TJSONWriter; name : string; elem : TFhirDeviceObservationReportVirtualDevice);
    procedure ComposeDeviceObservationReportVirtualDeviceChannel(json : TJSONWriter; name : string; elem : TFhirDeviceObservationReportVirtualDeviceChannel);
    procedure ComposeDeviceObservationReportVirtualDeviceChannelMetric(json : TJSONWriter; name : string; elem : TFhirDeviceObservationReportVirtualDeviceChannelMetric);
    procedure ComposeDeviceObservationReport(json : TJSONWriter; name : string; elem : TFhirDeviceObservationReport);
    procedure ComposeDiagnosticOrderEvent(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrderEvent);
    procedure ComposeDiagnosticOrderItem(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrderItem);
    procedure ComposeDiagnosticOrder(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrder);
    procedure ComposeDiagnosticReportImage(json : TJSONWriter; name : string; elem : TFhirDiagnosticReportImage);
    procedure ComposeDiagnosticReport(json : TJSONWriter; name : string; elem : TFhirDiagnosticReport);
    procedure ComposeDocumentManifest(json : TJSONWriter; name : string; elem : TFhirDocumentManifest);
    procedure ComposeDocumentReferenceRelatesTo(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceRelatesTo);
    procedure ComposeDocumentReferenceService(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceService);
    procedure ComposeDocumentReferenceServiceParameter(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceServiceParameter);
    procedure ComposeDocumentReferenceContext(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceContext);
    procedure ComposeDocumentReference(json : TJSONWriter; name : string; elem : TFhirDocumentReference);
    procedure ComposeEncounterParticipant(json : TJSONWriter; name : string; elem : TFhirEncounterParticipant);
    procedure ComposeEncounterHospitalization(json : TJSONWriter; name : string; elem : TFhirEncounterHospitalization);
    procedure ComposeEncounterHospitalizationAccomodation(json : TJSONWriter; name : string; elem : TFhirEncounterHospitalizationAccomodation);
    procedure ComposeEncounterLocation(json : TJSONWriter; name : string; elem : TFhirEncounterLocation);
    procedure ComposeEncounter(json : TJSONWriter; name : string; elem : TFhirEncounter);
    procedure ComposeFamilyHistoryRelation(json : TJSONWriter; name : string; elem : TFhirFamilyHistoryRelation);
    procedure ComposeFamilyHistoryRelationCondition(json : TJSONWriter; name : string; elem : TFhirFamilyHistoryRelationCondition);
    procedure ComposeFamilyHistory(json : TJSONWriter; name : string; elem : TFhirFamilyHistory);
    procedure ComposeGroupCharacteristic(json : TJSONWriter; name : string; elem : TFhirGroupCharacteristic);
    procedure ComposeGroup(json : TJSONWriter; name : string; elem : TFhirGroup);
    procedure ComposeImagingStudySeries(json : TJSONWriter; name : string; elem : TFhirImagingStudySeries);
    procedure ComposeImagingStudySeriesInstance(json : TJSONWriter; name : string; elem : TFhirImagingStudySeriesInstance);
    procedure ComposeImagingStudy(json : TJSONWriter; name : string; elem : TFhirImagingStudy);
    procedure ComposeImmunizationExplanation(json : TJSONWriter; name : string; elem : TFhirImmunizationExplanation);
    procedure ComposeImmunizationReaction(json : TJSONWriter; name : string; elem : TFhirImmunizationReaction);
    procedure ComposeImmunizationVaccinationProtocol(json : TJSONWriter; name : string; elem : TFhirImmunizationVaccinationProtocol);
    procedure ComposeImmunization(json : TJSONWriter; name : string; elem : TFhirImmunization);
    procedure ComposeImmunizationRecommendationRecommendation(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendation);
    procedure ComposeImmunizationRecommendationRecommendationDateCriterion(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendationDateCriterion);
    procedure ComposeImmunizationRecommendationRecommendationProtocol(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendationProtocol);
    procedure ComposeImmunizationRecommendation(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendation);
    procedure ComposeListEntry(json : TJSONWriter; name : string; elem : TFhirListEntry);
    procedure ComposeList(json : TJSONWriter; name : string; elem : TFhirList);
    procedure ComposeLocationPosition(json : TJSONWriter; name : string; elem : TFhirLocationPosition);
    procedure ComposeLocation(json : TJSONWriter; name : string; elem : TFhirLocation);
    procedure ComposeMedia(json : TJSONWriter; name : string; elem : TFhirMedia);
    procedure ComposeMedicationProduct(json : TJSONWriter; name : string; elem : TFhirMedicationProduct);
    procedure ComposeMedicationProductIngredient(json : TJSONWriter; name : string; elem : TFhirMedicationProductIngredient);
    procedure ComposeMedicationPackage(json : TJSONWriter; name : string; elem : TFhirMedicationPackage);
    procedure ComposeMedicationPackageContent(json : TJSONWriter; name : string; elem : TFhirMedicationPackageContent);
    procedure ComposeMedication(json : TJSONWriter; name : string; elem : TFhirMedication);
    procedure ComposeMedicationAdministrationDosage(json : TJSONWriter; name : string; elem : TFhirMedicationAdministrationDosage);
    procedure ComposeMedicationAdministration(json : TJSONWriter; name : string; elem : TFhirMedicationAdministration);
    procedure ComposeMedicationDispenseDispense(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseDispense);
    procedure ComposeMedicationDispenseDispenseDosage(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseDispenseDosage);
    procedure ComposeMedicationDispenseSubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseSubstitution);
    procedure ComposeMedicationDispense(json : TJSONWriter; name : string; elem : TFhirMedicationDispense);
    procedure ComposeMedicationPrescriptionDosageInstruction(json : TJSONWriter; name : string; elem : TFhirMedicationPrescriptionDosageInstruction);
    procedure ComposeMedicationPrescriptionDispense(json : TJSONWriter; name : string; elem : TFhirMedicationPrescriptionDispense);
    procedure ComposeMedicationPrescriptionSubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationPrescriptionSubstitution);
    procedure ComposeMedicationPrescription(json : TJSONWriter; name : string; elem : TFhirMedicationPrescription);
    procedure ComposeMedicationStatementDosage(json : TJSONWriter; name : string; elem : TFhirMedicationStatementDosage);
    procedure ComposeMedicationStatement(json : TJSONWriter; name : string; elem : TFhirMedicationStatement);
    procedure ComposeMessageHeaderResponse(json : TJSONWriter; name : string; elem : TFhirMessageHeaderResponse);
    procedure ComposeMessageHeaderSource(json : TJSONWriter; name : string; elem : TFhirMessageHeaderSource);
    procedure ComposeMessageHeaderDestination(json : TJSONWriter; name : string; elem : TFhirMessageHeaderDestination);
    procedure ComposeMessageHeader(json : TJSONWriter; name : string; elem : TFhirMessageHeader);
    procedure ComposeObservationReferenceRange(json : TJSONWriter; name : string; elem : TFhirObservationReferenceRange);
    procedure ComposeObservationRelated(json : TJSONWriter; name : string; elem : TFhirObservationRelated);
    procedure ComposeObservation(json : TJSONWriter; name : string; elem : TFhirObservation);
    procedure ComposeOperationOutcomeIssue(json : TJSONWriter; name : string; elem : TFhirOperationOutcomeIssue);
    procedure ComposeOperationOutcome(json : TJSONWriter; name : string; elem : TFhirOperationOutcome);
    procedure ComposeOrderWhen(json : TJSONWriter; name : string; elem : TFhirOrderWhen);
    procedure ComposeOrder(json : TJSONWriter; name : string; elem : TFhirOrder);
    procedure ComposeOrderResponse(json : TJSONWriter; name : string; elem : TFhirOrderResponse);
    procedure ComposeOrganizationContact(json : TJSONWriter; name : string; elem : TFhirOrganizationContact);
    procedure ComposeOrganization(json : TJSONWriter; name : string; elem : TFhirOrganization);
    procedure ComposeOther(json : TJSONWriter; name : string; elem : TFhirOther);
    procedure ComposePatientContact(json : TJSONWriter; name : string; elem : TFhirPatientContact);
    procedure ComposePatientAnimal(json : TJSONWriter; name : string; elem : TFhirPatientAnimal);
    procedure ComposePatientLink(json : TJSONWriter; name : string; elem : TFhirPatientLink);
    procedure ComposePatient(json : TJSONWriter; name : string; elem : TFhirPatient);
    procedure ComposePractitionerQualification(json : TJSONWriter; name : string; elem : TFhirPractitionerQualification);
    procedure ComposePractitioner(json : TJSONWriter; name : string; elem : TFhirPractitioner);
    procedure ComposeProcedurePerformer(json : TJSONWriter; name : string; elem : TFhirProcedurePerformer);
    procedure ComposeProcedureRelatedItem(json : TJSONWriter; name : string; elem : TFhirProcedureRelatedItem);
    procedure ComposeProcedure(json : TJSONWriter; name : string; elem : TFhirProcedure);
    procedure ComposeProfileMapping(json : TJSONWriter; name : string; elem : TFhirProfileMapping);
    procedure ComposeProfileStructure(json : TJSONWriter; name : string; elem : TFhirProfileStructure);
    procedure ComposeProfileStructureElement(json : TJSONWriter; name : string; elem : TFhirProfileStructureElement);
    procedure ComposeProfileStructureElementSlicing(json : TJSONWriter; name : string; elem : TFhirProfileStructureElementSlicing);
    procedure ComposeProfileStructureElementDefinition(json : TJSONWriter; name : string; elem : TFhirProfileStructureElementDefinition);
    procedure ComposeProfileStructureElementDefinitionType(json : TJSONWriter; name : string; elem : TFhirProfileStructureElementDefinitionType);
    procedure ComposeProfileStructureElementDefinitionConstraint(json : TJSONWriter; name : string; elem : TFhirProfileStructureElementDefinitionConstraint);
    procedure ComposeProfileStructureElementDefinitionBinding(json : TJSONWriter; name : string; elem : TFhirProfileStructureElementDefinitionBinding);
    procedure ComposeProfileStructureElementDefinitionMapping(json : TJSONWriter; name : string; elem : TFhirProfileStructureElementDefinitionMapping);
    procedure ComposeProfileStructureSearchParam(json : TJSONWriter; name : string; elem : TFhirProfileStructureSearchParam);
    procedure ComposeProfileExtensionDefn(json : TJSONWriter; name : string; elem : TFhirProfileExtensionDefn);
    procedure ComposeProfileQuery(json : TJSONWriter; name : string; elem : TFhirProfileQuery);
    procedure ComposeProfile(json : TJSONWriter; name : string; elem : TFhirProfile);
    procedure ComposeProvenanceAgent(json : TJSONWriter; name : string; elem : TFhirProvenanceAgent);
    procedure ComposeProvenanceEntity(json : TJSONWriter; name : string; elem : TFhirProvenanceEntity);
    procedure ComposeProvenance(json : TJSONWriter; name : string; elem : TFhirProvenance);
    procedure ComposeQueryResponse(json : TJSONWriter; name : string; elem : TFhirQueryResponse);
    procedure ComposeQuery(json : TJSONWriter; name : string; elem : TFhirQuery);
    procedure ComposeQuestionnaireGroup(json : TJSONWriter; name : string; elem : TFhirQuestionnaireGroup);
    procedure ComposeQuestionnaireGroupQuestion(json : TJSONWriter; name : string; elem : TFhirQuestionnaireGroupQuestion);
    procedure ComposeQuestionnaire(json : TJSONWriter; name : string; elem : TFhirQuestionnaire);
    procedure ComposeRelatedPerson(json : TJSONWriter; name : string; elem : TFhirRelatedPerson);
    procedure ComposeSecurityEventEvent(json : TJSONWriter; name : string; elem : TFhirSecurityEventEvent);
    procedure ComposeSecurityEventParticipant(json : TJSONWriter; name : string; elem : TFhirSecurityEventParticipant);
    procedure ComposeSecurityEventParticipantNetwork(json : TJSONWriter; name : string; elem : TFhirSecurityEventParticipantNetwork);
    procedure ComposeSecurityEventSource(json : TJSONWriter; name : string; elem : TFhirSecurityEventSource);
    procedure ComposeSecurityEventObject(json : TJSONWriter; name : string; elem : TFhirSecurityEventObject);
    procedure ComposeSecurityEventObjectDetail(json : TJSONWriter; name : string; elem : TFhirSecurityEventObjectDetail);
    procedure ComposeSecurityEvent(json : TJSONWriter; name : string; elem : TFhirSecurityEvent);
    procedure ComposeSpecimenSource(json : TJSONWriter; name : string; elem : TFhirSpecimenSource);
    procedure ComposeSpecimenCollection(json : TJSONWriter; name : string; elem : TFhirSpecimenCollection);
    procedure ComposeSpecimenTreatment(json : TJSONWriter; name : string; elem : TFhirSpecimenTreatment);
    procedure ComposeSpecimenContainer(json : TJSONWriter; name : string; elem : TFhirSpecimenContainer);
    procedure ComposeSpecimen(json : TJSONWriter; name : string; elem : TFhirSpecimen);
    procedure ComposeSubstanceInstance(json : TJSONWriter; name : string; elem : TFhirSubstanceInstance);
    procedure ComposeSubstanceIngredient(json : TJSONWriter; name : string; elem : TFhirSubstanceIngredient);
    procedure ComposeSubstance(json : TJSONWriter; name : string; elem : TFhirSubstance);
    procedure ComposeSupplyDispense(json : TJSONWriter; name : string; elem : TFhirSupplyDispense);
    procedure ComposeSupply(json : TJSONWriter; name : string; elem : TFhirSupply);
    procedure ComposeValueSetDefine(json : TJSONWriter; name : string; elem : TFhirValueSetDefine);
    procedure ComposeValueSetDefineConcept(json : TJSONWriter; name : string; elem : TFhirValueSetDefineConcept);
    procedure ComposeValueSetCompose(json : TJSONWriter; name : string; elem : TFhirValueSetCompose);
    procedure ComposeValueSetComposeInclude(json : TJSONWriter; name : string; elem : TFhirValueSetComposeInclude);
    procedure ComposeValueSetComposeIncludeFilter(json : TJSONWriter; name : string; elem : TFhirValueSetComposeIncludeFilter);
    procedure ComposeValueSetExpansion(json : TJSONWriter; name : string; elem : TFhirValueSetExpansion);
    procedure ComposeValueSetExpansionContains(json : TJSONWriter; name : string; elem : TFhirValueSetExpansionContains);
    procedure ComposeValueSet(json : TJSONWriter; name : string; elem : TFhirValueSet);
    procedure ComposeResource(json : TJSONWriter; id, ver : String; resource : TFhirResource); override;
  end;


implementation

{ TFHIRXmlParser }

Procedure TFHIRXmlParser.ParseElementAttributes(value : TFhirElement; path : string; element : IXmlDomElement);
begin
  TakeCommentsStart(value);
  checkOtherAttributes(element, path);
  value.xmlId := GetAttribute(element, 'id');
end;

Function TFHIRXmlParser.ParseBackboneElementChild(element : TFhirBackboneElement; path : string; child : IXmlDomElement) : boolean;
begin
  result := true;
  if (child.baseName = 'modifierExtension') then
    element.ModifierExtensionList.add(ParseExtension(child, path+'/modifierExtension'))
  else
    result := ParseElementChild(element, path, child);
end;

Function TFHIRXmlParser.ParseElementChild(element : TFhirElement; path : string; child : IXmlDomElement) : boolean;
begin
  result := true;
  if (child.baseName = 'extension') then
    element.ExtensionList.add(ParseExtension(child, path+'/extension'))
  else
    result := false;
end;

procedure TFHIRJsonParser.ParseElementProperties(jsn : TJsonObject; element : TFhirElement);
begin
  parseComments(element, jsn);

  if jsn.has('id') then
    element.xmlId:= jsn['id'];
  if jsn.has('extension') then
    iterateArray(jsn.vArr['extension'], element.extensionList, parseExtension)
end;

procedure TFHIRJsonParser.ParseBackboneElementProperties(jsn : TJsonObject; element : TFhirBackboneElement);
begin
  parseElementProperties(jsn, element);

  if jsn.has('modifierExtension') then
    iterateArray(jsn.vArr['modifierExtension'], element.modifierExtensionList, parseExtension)
end;

Procedure TFHIRXmlComposer.ComposeElementAttributes(xml : TXmlBuilder; element : TFhirElement);
begin
  CommentsStart(xml, element);
  Attribute(xml, 'id', element.xmlId);
end;

Procedure TFHIRXmlComposer.ComposeElementChildren(xml : TXmlBuilder; element : TFhirElement);
var
  i : integer;
begin
  if element.hasExtensions then
    for i := 0 to element.extensionList.count - 1 do
       ComposeExtension(xml, 'extension', element.extensionList[i]);
end;

Procedure TFHIRXmlComposer.ComposeBackboneElementChildren(xml : TXmlBuilder; element : TFhirBackboneElement);
var
  i : integer;
begin
  ComposeElementChildren(xml, element);
  if element.hasModifierExtensions then
    for i := 0 to element.modifierExtensionList.count - 1 do
       ComposeExtension(xml, 'modifierExtension', element.modifierExtensionList[i]);
end;

Procedure TFHIRJsonComposer.ComposeElementProperties(json : TJSONWriter; elem : TFhirElement);
var
  i : integer;
begin
  composeComments(json, elem);
  Prop(json, 'id', elem.xmlId);
  if elem.hasExtensions then
  begin
    json.valueArray('extension');
    for i := 0 to elem.extensionList.count - 1 do
       ComposeExtension(json, '', elem.extensionList[i]);
    json.FinishArray;
  end;
end;

Procedure TFHIRJsonComposer.ComposeBackboneElementProperties(json : TJSONWriter; elem : TFhirBackboneElement);
var
  i : integer;
begin
  ComposeElementProperties(json, elem);
  if elem.hasModifierExtensions then
  begin
    json.valueArray('modifierExtension');
    for i := 0 to elem.modifierExtensionList.count - 1 do
       ComposeExtension(json, '', elem.modifierExtensionList[i]);
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseEnum(Const aNames : Array Of String; path : String; element : IXmlDomElement) : TFhirEnum;
var
  child : IXMLDOMElement;
begin
  result := TFhirEnum.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    if StringArrayIndexOf(aNames, result.value) < 0 then
      raise Exception.create('unknown code: '+result.value+' from a set of choices of '+StringArrayToCommaString(aNames)+' for "'+path+'"');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEnum(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList; Const aNames : Array Of String);
begin
  ctxt.add(ParseEnum(value, jsn, aNames));
end;

function TFHIRJsonParser.ParseEnum(value : string; jsn : TJsonObject; Const aNames : Array Of String) : TFHIREnum;
begin
  if StringArrayIndexOf(aNames, value) < 0 then
    raise Exception.create('unknown code: '+value+' from a set of choices of '+StringArrayToCommaString(aNames)+' for "'+jsn.path+'"');
  result := TFHIREnum.create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeEnum(xml : TXmlBuilder; name : String; value : TFhirEnum; Const aNames : Array Of String);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeEnumValue(json : TJSONWriter; name : String; value : TFhirEnum; Const aNames : Array Of String; inArray : boolean);
begin
  if (value = nil) or (value.Value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeEnumProps(json : TJSONWriter; name : String; value : TFhirEnum; Const aNames : Array Of String; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseInteger(element : IXmlDomElement; path : string) : TFhirInteger;
var
  child : IXMLDOMElement;
begin
  result := TFhirInteger.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseInteger(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInteger(value, jsn));
end;

function TFHIRJsonParser.ParseInteger(value : string; jsn : TJsonObject) : TFHIRInteger;
begin
  result := TFhirInteger.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeInteger(xml : TXmlBuilder; name : String; value : TFhirInteger);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeIntegerValue(json : TJSONWriter; name : String; value : TFhirInteger; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeIntegerProps(json : TJSONWriter; name : String; value : TFhirInteger; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseDateTime(element : IXmlDomElement; path : string) : TFhirDateTime;
var
  child : IXMLDOMElement;
begin
  result := TFhirDateTime.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTDateAndTime(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDateTime(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDateTime(value, jsn));
end;

function TFHIRJsonParser.ParseDateTime(value : string; jsn : TJsonObject) : TFHIRDateTime;
begin
  result := TFhirDateTime.Create;
  try
     result.value := toTDateAndTime(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeDateTime(xml : TXmlBuilder; name : String; value : TFhirDateTime);
begin
  if (value = nil) or (value.value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', asString(value.value));
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeDateTimeValue(json : TJSONWriter; name : String; value : TFhirDateTime; inArray : boolean);
begin
  if (value = nil) or (value.value = nil) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, asString(value.value));
end;

Procedure TFHIRJsonComposer.ComposeDateTimeProps(json : TJSONWriter; name : String; value : TFhirDateTime; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseDate(element : IXmlDomElement; path : string) : TFhirDate;
var
  child : IXMLDOMElement;
begin
  result := TFhirDate.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTDateAndTime(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDate(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDate(value, jsn));
end;

function TFHIRJsonParser.ParseDate(value : string; jsn : TJsonObject) : TFHIRDate;
begin
  result := TFhirDate.Create;
  try
     result.value := toTDateAndTime(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeDate(xml : TXmlBuilder; name : String; value : TFhirDate);
begin
  if (value = nil) or (value.value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', asString(value.value));
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeDateValue(json : TJSONWriter; name : String; value : TFhirDate; inArray : boolean);
begin
  if (value = nil) or (value.value = nil) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, asString(value.value));
end;

Procedure TFHIRJsonComposer.ComposeDateProps(json : TJSONWriter; name : String; value : TFhirDate; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseDecimal(element : IXmlDomElement; path : string) : TFhirDecimal;
var
  child : IXMLDOMElement;
begin
  result := TFhirDecimal.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDecimal(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDecimal(value, jsn));
end;

function TFHIRJsonParser.ParseDecimal(value : string; jsn : TJsonObject) : TFHIRDecimal;
begin
  result := TFhirDecimal.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeDecimal(xml : TXmlBuilder; name : String; value : TFhirDecimal);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeDecimalValue(json : TJSONWriter; name : String; value : TFhirDecimal; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeDecimalProps(json : TJSONWriter; name : String; value : TFhirDecimal; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseUri(element : IXmlDomElement; path : string) : TFhirUri;
var
  child : IXMLDOMElement;
begin
  result := TFhirUri.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseUri(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseUri(value, jsn));
end;

function TFHIRJsonParser.ParseUri(value : string; jsn : TJsonObject) : TFHIRUri;
begin
  result := TFhirUri.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeUri(xml : TXmlBuilder; name : String; value : TFhirUri);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeUriValue(json : TJSONWriter; name : String; value : TFhirUri; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeUriProps(json : TJSONWriter; name : String; value : TFhirUri; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseBase64Binary(element : IXmlDomElement; path : string) : TFhirBase64Binary;
var
  child : IXMLDOMElement;
begin
  result := TFhirBase64Binary.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBase64Binary(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBase64Binary(value, jsn));
end;

function TFHIRJsonParser.ParseBase64Binary(value : string; jsn : TJsonObject) : TFHIRBase64Binary;
begin
  result := TFhirBase64Binary.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeBase64Binary(xml : TXmlBuilder; name : String; value : TFhirBase64Binary);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeBase64BinaryValue(json : TJSONWriter; name : String; value : TFhirBase64Binary; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeBase64BinaryProps(json : TJSONWriter; name : String; value : TFhirBase64Binary; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseString(element : IXmlDomElement; path : string) : TFhirString;
var
  child : IXMLDOMElement;
begin
  result := TFhirString.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseString(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseString(value, jsn));
end;

function TFHIRJsonParser.ParseString(value : string; jsn : TJsonObject) : TFHIRString;
begin
  result := TFhirString.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeString(xml : TXmlBuilder; name : String; value : TFhirString);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeStringValue(json : TJSONWriter; name : String; value : TFhirString; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeStringProps(json : TJSONWriter; name : String; value : TFhirString; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseBoolean(element : IXmlDomElement; path : string) : TFhirBoolean;
var
  child : IXMLDOMElement;
begin
  result := TFhirBoolean.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := StringToBoolean(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBoolean(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBoolean(value, jsn));
end;

function TFHIRJsonParser.ParseBoolean(value : string; jsn : TJsonObject) : TFHIRBoolean;
begin
  result := TFhirBoolean.Create;
  try
    result.value := StringToBoolean(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeBoolean(xml : TXmlBuilder; name : String; value : TFhirBoolean);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', LCBooleanToString(value.value));
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeBooleanValue(json : TJSONWriter; name : String; value : TFhirBoolean; inArray : boolean);
begin
  if (value = nil) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeBooleanProps(json : TJSONWriter; name : String; value : TFhirBoolean; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseInstant(element : IXmlDomElement; path : string) : TFhirInstant;
var
  child : IXMLDOMElement;
begin
  result := TFhirInstant.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTDateAndTime(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseInstant(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInstant(value, jsn));
end;

function TFHIRJsonParser.ParseInstant(value : string; jsn : TJsonObject) : TFHIRInstant;
begin
  result := TFhirInstant.Create;
  try
     result.value := toTDateAndTime(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeInstant(xml : TXmlBuilder; name : String; value : TFhirInstant);
begin
  if (value = nil) or (value.value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', asString(value.value));
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeInstantValue(json : TJSONWriter; name : String; value : TFhirInstant; inArray : boolean);
begin
  if (value = nil) or (value.value = nil) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, asString(value.value));
end;

Procedure TFHIRJsonComposer.ComposeInstantProps(json : TJSONWriter; name : String; value : TFhirInstant; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseCode(element : IXmlDomElement; path : string) : TFhirCode;
var
  child : IXMLDOMElement;
begin
  result := TFhirCode.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCode(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCode(value, jsn));
end;

function TFHIRJsonParser.ParseCode(value : string; jsn : TJsonObject) : TFHIRCode;
begin
  result := TFhirCode.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeCode(xml : TXmlBuilder; name : String; value : TFhirCode);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeCodeValue(json : TJSONWriter; name : String; value : TFhirCode; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeCodeProps(json : TJSONWriter; name : String; value : TFhirCode; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseId(element : IXmlDomElement; path : string) : TFhirId;
var
  child : IXMLDOMElement;
begin
  result := TFhirId.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseId(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseId(value, jsn));
end;

function TFHIRJsonParser.ParseId(value : string; jsn : TJsonObject) : TFHIRId;
begin
  result := TFhirId.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeId(xml : TXmlBuilder; name : String; value : TFhirId);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeIdValue(json : TJSONWriter; name : String; value : TFhirId; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeIdProps(json : TJSONWriter; name : String; value : TFhirId; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseOid(element : IXmlDomElement; path : string) : TFhirOid;
var
  child : IXMLDOMElement;
begin
  result := TFhirOid.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseOid(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOid(value, jsn));
end;

function TFHIRJsonParser.ParseOid(value : string; jsn : TJsonObject) : TFHIROid;
begin
  result := TFhirOid.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeOid(xml : TXmlBuilder; name : String; value : TFhirOid);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeOidValue(json : TJSONWriter; name : String; value : TFhirOid; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeOidProps(json : TJSONWriter; name : String; value : TFhirOid; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

function TFHIRXmlParser.ParseUuid(element : IXmlDomElement; path : string) : TFhirUuid;
var
  child : IXMLDOMElement;
begin
  result := TFhirUuid.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseUuid(value : string; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseUuid(value, jsn));
end;

function TFHIRJsonParser.ParseUuid(value : string; jsn : TJsonObject) : TFHIRUuid;
begin
  result := TFhirUuid.Create;
  try
    result.value := value;
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeUuid(xml : TXmlBuilder; name : String; value : TFhirUuid);
begin
  if (value = nil) or (value.value = '') then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
end;

Procedure TFHIRJsonComposer.ComposeUuidValue(json : TJSONWriter; name : String; value : TFhirUuid; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeUuidProps(json : TJSONWriter; name : String; value : TFhirUuid; inArray : boolean);
begin
  if (value = nil) or ((value.xmlId = '') and (not value.hasExtensions) and (not value.hasComments)) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

Procedure TFHIRXmlParser.ParseResourceAttributes(resource : TFhirResource; path : string; element : IXmlDomElement);
begin
  ParseElementAttributes(resource, path, element);
  // lang
end;

Function TFHIRXmlParser.ParseResourceChild(resource : TFhirResource; path : string; child : IXmlDomElement) : boolean;
begin
  result := true;
  if (child.baseName = 'text') then
    resource.text := ParseNarrative(child, path+'/text')
  else if (child.baseName = 'language') then
    resource.language := ParseCode(child, path+'/language')
  else if (child.baseName = 'contained') then
    resource.ContainedList.add(ParseContained(child, path+'/contained'))
  else if not parseBackboneElementChild(resource, path, child) then
    result := false;
end;

procedure TFHIRJsonParser.ParseResourceProperties(jsn : TJsonObject; resource : TFhirResource);
begin
  ParseBackboneElementProperties(jsn, resource);
  if jsn.has('language') or jsn.has('_language') then
    resource.language := parseCode(jsn['language'], jsn.vObj['_language']);
  if jsn.has('text') then
    resource.text := parseNarrative(jsn.vObj['text']);
  if jsn.has('contained') then
    iterateArray(jsn.vArr['contained'], resource.containedList, parseContained);
end;

Procedure TFHIRXmlComposer.ComposeResourceAttributes(xml : TXmlBuilder; resource : TFhirResource);
begin
  ComposeElementAttributes(xml, resource);
end;

Procedure TFHIRXmlComposer.ComposeResourceChildren(xml : TXmlBuilder; resource : TFhirResource);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, resource);
  composeCode(xml, 'language', resource.language);
  if not SummaryOnly then
    composeNarrative(xml, 'text', resource.text);
  if not SummaryOnly then
    for i := 0 to resource.containedList.count - 1 do
      ComposeContained(xml, 'contained', resource.containedList[i]);
end;

Procedure TFHIRJsonComposer.ComposeResourceProperties(json : TJSONWriter; resource : TFhirResource);
var
  i : integer;
begin
  ComposeBackboneElementProperties(json, resource);
  composeCodeValue(json, 'language', resource.language, false);
  composeCodeProps(json, 'language', resource.language, false);
  if not SummaryOnly then
    ComposeNarrative(json, 'text', resource.text);
  if not SummaryOnly and (resource.containedList.count > 0) then
  begin
    json.valueArray('contained');
    for i := 0 to resource.containedList.Count - 1 do
      ComposeContained(json, resource.containedList[i]);
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseExtension(element : IXmlDomElement; path : string) : TFhirExtension;
var
  child : IXMLDOMElement;
begin
  result := TFhirExtension.create;
  try
    parseElementAttributes(result, path, element);
    result.urlST := GetAttribute(element, 'url');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'valueInteger') then
        result.value := ParseInteger(child, path+'.valueInteger') {c}
      else if (child.baseName = 'valueDateTime') then
        result.value := ParseDateTime(child, path+'.valueDateTime') {c}
      else if (child.baseName = 'valueCode') then
        result.value := ParseCode(child, path+'.valueCode') {c}
      else if (child.baseName = 'valueDate') then
        result.value := ParseDate(child, path+'.valueDate') {c}
      else if (child.baseName = 'valueDecimal') then
        result.value := ParseDecimal(child, path+'.valueDecimal') {c}
      else if (child.baseName = 'valueUri') then
        result.value := ParseUri(child, path+'.valueUri') {c}
      else if (child.baseName = 'valueId') then
        result.value := ParseId(child, path+'.valueId') {c}
      else if (child.baseName = 'valueBase64Binary') then
        result.value := ParseBase64Binary(child, path+'.valueBase64Binary') {c}
      else if (child.baseName = 'valueOid') then
        result.value := ParseOid(child, path+'.valueOid') {c}
      else if (child.baseName = 'valueString') then
        result.value := ParseString(child, path+'.valueString') {c}
      else if (child.baseName = 'valueBoolean') then
        result.value := ParseBoolean(child, path+'.valueBoolean') {c}
      else if (child.baseName = 'valueUuid') then
        result.value := ParseUuid(child, path+'.valueUuid') {c}
      else if (child.baseName = 'valueInstant') then
        result.value := ParseInstant(child, path+'.valueInstant') {c}
      else if (child.baseName = 'valuePeriod') then
        result.value := ParsePeriod(child, path+'.valuePeriod') {ePeriod}
      else if (child.baseName = 'valueCoding') then
        result.value := ParseCoding(child, path+'.valueCoding') {eCoding}
      else if (child.baseName = 'valueRange') then
        result.value := ParseRange(child, path+'.valueRange') {eRange}
      else if (child.baseName = 'valueQuantity') then
        result.value := ParseQuantity(child, path+'.valueQuantity') {eQuantity}
      else if (child.baseName = 'valueAttachment') then
        result.value := ParseAttachment(child, path+'.valueAttachment') {eAttachment}
      else if (child.baseName = 'valueRatio') then
        result.value := ParseRatio(child, path+'.valueRatio') {eRatio}
      else if (child.baseName = 'valueSampledData') then
        result.value := ParseSampledData(child, path+'.valueSampledData') {eSampledData}
      else if (child.baseName = 'valueResource') then
        result.value := ParseResourceReference(child, path+'/valueResource') {e0}
      else if (child.baseName = 'valueCodeableConcept') then
        result.value := ParseCodeableConcept(child, path+'.valueCodeableConcept') {eCodeableConcept}
      else if (child.baseName = 'valueIdentifier') then
        result.value := ParseIdentifier(child, path+'.valueIdentifier') {eIdentifier}
      else if (child.baseName = 'valueSchedule') then
        result.value := ParseSchedule(child, path+'/valueSchedule') {f}
      else if (child.baseName = 'valueContact') then
        result.value := ParseContact(child, path+'/valueContact') {f}
      else if (child.baseName = 'valueAddress') then
        result.value := ParseAddress(child, path+'/valueAddress') {f}
      else if (child.baseName = 'valueHumanName') then
        result.value := ParseHumanName(child, path+'/valueHumanName') {f}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeExtension(xml : TXmlBuilder; name : string; elem : TFhirExtension);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  Attribute(xml, 'url', elem.urlST);
  xml.open(name);
  composeElementChildren(xml, elem);
  if (elem.value is TFhirInteger) {1} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (elem.value is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value))
  else if (elem.value is TFhirCode) {1} then
    ComposeCode(xml, 'valueCode', TFhirCode(elem.value))
  else if (elem.value is TFhirDate) {1} then
    ComposeDate(xml, 'valueDate', TFhirDate(elem.value))
  else if (elem.value is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value))
  else if (elem.value is TFhirUri) {1} then
    ComposeUri(xml, 'valueUri', TFhirUri(elem.value))
  else if (elem.value is TFhirId) {1} then
    ComposeId(xml, 'valueId', TFhirId(elem.value))
  else if (elem.value is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(elem.value))
  else if (elem.value is TFhirOid) {1} then
    ComposeOid(xml, 'valueOid', TFhirOid(elem.value))
  else if (elem.value is TFhirString) {1} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (elem.value is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (elem.value is TFhirUuid) {1} then
    ComposeUuid(xml, 'valueUuid', TFhirUuid(elem.value))
  else if (elem.value is TFhirInstant) {1} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(elem.value))
  else if (elem.value is TFhirPeriod) {8} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value))
  else if (elem.value is TFhirCoding) {8} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(elem.value))
  else if (elem.value is TFhirRange) {8} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value))
  else if (elem.value is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (elem.value is TFhirRatio) {8} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(elem.value))
  else if (elem.value is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(elem.value))
  else if (elem.value is TFhirResourceReference) {8} then
    ComposeResourceReference(xml, 'valueResource', TFhirResourceReference(elem.value))
  else if (elem.value is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (elem.value is TFhirSchedule) {9} then
    ComposeSchedule(xml, 'valueSchedule', TFhirSchedule(elem.value))
  else if (elem.value is TFhirContact) {9} then
    ComposeContact(xml, 'valueContact', TFhirContact(elem.value))
  else if (elem.value is TFhirAddress) {9} then
    ComposeAddress(xml, 'valueAddress', TFhirAddress(elem.value))
  else if (elem.value is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'valueHumanName', TFhirHumanName(elem.value));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseExtension(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExtension(jsn));
end;

function TFHIRJsonParser.ParseExtension(jsn : TJsonObject) : TFhirExtension;
begin
  result := TFhirExtension.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.url := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
        result.value := ParseInteger(jsn['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
        result.value := ParseDateTime(jsn['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valueCode') or jsn.has('_valueCode') then
        result.value := ParseCode(jsn['valueCode'], jsn.vObj['_valueCode']);
    if jsn.has('valueDate') or jsn.has('_valueDate') then
        result.value := ParseDate(jsn['valueDate'], jsn.vObj['_valueDate']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
        result.value := ParseDecimal(jsn['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
        result.value := ParseUri(jsn['valueUri'], jsn.vObj['_valueUri']);
    if jsn.has('valueId') or jsn.has('_valueId') then
        result.value := ParseId(jsn['valueId'], jsn.vObj['_valueId']);
    if jsn.has('valueBase64Binary') or jsn.has('_valueBase64Binary') then
        result.value := ParseBase64Binary(jsn['valueBase64Binary'], jsn.vObj['_valueBase64Binary']);
    if jsn.has('valueOid') or jsn.has('_valueOid') then
        result.value := ParseOid(jsn['valueOid'], jsn.vObj['_valueOid']);
    if jsn.has('valueString') or jsn.has('_valueString') then
        result.value := ParseString(jsn['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
        result.value := ParseBoolean(jsn['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueUuid') or jsn.has('_valueUuid') then
        result.value := ParseUuid(jsn['valueUuid'], jsn.vObj['_valueUuid']);
    if jsn.has('valueInstant') or jsn.has('_valueInstant') then
        result.value := ParseInstant(jsn['valueInstant'], jsn.vObj['_valueInstant']);
    if jsn.has('valuePeriod') {a7} then
        result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('valueCoding') {a7} then
        result.value := ParseCoding(jsn.vObj['valueCoding']);
    if jsn.has('valueRange') {a7} then
        result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueQuantity') {a7} then
        result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueAttachment') {a7} then
        result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueRatio') {a7} then
        result.value := ParseRatio(jsn.vObj['valueRatio']);
    if jsn.has('valueSampledData') {a7} then
        result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if jsn.has('valueResource') {a6} then
        result.value := ParseResourceReference(jsn.vObj['valueResource']);
    if jsn.has('valueCodeableConcept') {a7} then
        result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueIdentifier') {a7} then
        result.value := ParseIdentifier(jsn.vObj['valueIdentifier']);
    if jsn.has('valueSchedule') {a9} then
        result.value := ParseSchedule(jsn.vObj['valueSchedule']);
    if jsn.has('valueContact') {a9} then
        result.value := ParseContact(jsn.vObj['valueContact']);
    if jsn.has('valueAddress') {a9} then
        result.value := ParseAddress(jsn.vObj['valueAddress']);
    if jsn.has('valueHumanName') {a9} then
        result.value := ParseHumanName(jsn.vObj['valueHumanName']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeExtension(json : TJSONWriter; name : string; elem : TFhirExtension);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeUriValue(json, 'url', elem.url, false);
  ComposeUriProps(json, 'url', elem.url, false);
  if (elem.value is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false)
  end
  else if (elem.value is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false)
  end
  else if (elem.value is TFhirCode) then
  begin
    ComposeCodeValue(json, 'valueCode', TFhirCode(elem.value), false);
    ComposeCodeProps(json, 'valueCode', TFhirCode(elem.value), false)
  end
  else if (elem.value is TFhirDate) then
  begin
    ComposeDateValue(json, 'valueDate', TFhirDate(elem.value), false);
    ComposeDateProps(json, 'valueDate', TFhirDate(elem.value), false)
  end
  else if (elem.value is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false)
  end
  else if (elem.value is TFhirUri) then
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false)
  end
  else if (elem.value is TFhirId) then
  begin
    ComposeIdValue(json, 'valueId', TFhirId(elem.value), false);
    ComposeIdProps(json, 'valueId', TFhirId(elem.value), false)
  end
  else if (elem.value is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false);
    ComposeBase64BinaryProps(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false)
  end
  else if (elem.value is TFhirOid) then
  begin
    ComposeOidValue(json, 'valueOid', TFhirOid(elem.value), false);
    ComposeOidProps(json, 'valueOid', TFhirOid(elem.value), false)
  end
  else if (elem.value is TFhirString) then
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false)
  end
  else if (elem.value is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false)
  end
  else if (elem.value is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'valueUuid', TFhirUuid(elem.value), false);
    ComposeUuidProps(json, 'valueUuid', TFhirUuid(elem.value), false)
  end
  else if (elem.value is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'valueInstant', TFhirInstant(elem.value), false);
    ComposeInstantProps(json, 'valueInstant', TFhirInstant(elem.value), false)
  end
  else if (elem.value is TFhirPeriod) then
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value))
  else if (elem.value is TFhirCoding) then
    ComposeCoding(json, 'valueCoding', TFhirCoding(elem.value))
  else if (elem.value is TFhirRange) then
    ComposeRange(json, 'valueRange', TFhirRange(elem.value))
  else if (elem.value is TFhirQuantity) then
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirAttachment) then
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value))
  else if (elem.value is TFhirRatio) then
    ComposeRatio(json, 'valueRatio', TFhirRatio(elem.value))
  else if (elem.value is TFhirSampledData) then
    ComposeSampledData(json, 'valueSampledData', TFhirSampledData(elem.value))
  else if (elem.value is TFhirResourceReference) then
    ComposeResourceReference(json, 'valueResource', TFhirResourceReference(elem.value))
  else if (elem.value is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirIdentifier) then
    ComposeIdentifier(json, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (elem.value is TFhirSchedule) then
    ComposeSchedule(json, 'valueSchedule', TFhirSchedule(elem.value))
  else if (elem.value is TFhirContact) then
    ComposeContact(json, 'valueContact', TFhirContact(elem.value))
  else if (elem.value is TFhirAddress) then
    ComposeAddress(json, 'valueAddress', TFhirAddress(elem.value))
  else if (elem.value is TFhirHumanName) then
    ComposeHumanName(json, 'valueHumanName', TFhirHumanName(elem.value));
  json.finishObject;
end;

function TFHIRXmlParser.ParseNarrative(element : IXmlDomElement; path : string) : TFhirNarrative;
var
  child : IXMLDOMElement;
begin
  result := TFhirNarrative.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirNarrativeStatus, path+'/status', child)
      else if (child.baseName = 'div') then
        result.div_ := ParseXHtmlNode(child, path+'/div') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeNarrative(xml : TXmlBuilder; name : string; elem : TFhirNarrative);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirNarrativeStatus);
  ComposeXHtmlNode(xml, 'div', elem.div_);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseNarrative(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNarrative(jsn));
end;

function TFHIRJsonParser.ParseNarrative(jsn : TJsonObject) : TFhirNarrative;
begin
  result := TFhirNarrative.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirNarrativeStatus);
    if jsn.has('div') then
        result.div_ := ParseXHtmlNode(jsn.path+'.div', jsn['div']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeNarrative(json : TJSONWriter; name : string; elem : TFhirNarrative);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirNarrativeStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirNarrativeStatus, false);
  ComposeXHtmlNode(json, 'div', elem.div_); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParsePeriod(element : IXmlDomElement; path : string) : TFhirPeriod;
var
  child : IXMLDOMElement;
begin
  result := TFhirPeriod.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'start') then
        result.start := ParseDateTime(child, path+'/start') {b}
      else if (child.baseName = 'end') then
        result.end_ := ParseDateTime(child, path+'/end') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePeriod(xml : TXmlBuilder; name : string; elem : TFhirPeriod);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeDateTime(xml, 'start', elem.start);
  ComposeDateTime(xml, 'end', elem.end_);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePeriod(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePeriod(jsn));
end;

function TFHIRJsonParser.ParsePeriod(jsn : TJsonObject) : TFhirPeriod;
begin
  result := TFhirPeriod.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('start') or jsn.has('_start') then
        result.start := ParseDateTime(jsn['start'], jsn.vObj['_start']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_ := ParseDateTime(jsn['end'], jsn.vObj['_end']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePeriod(json : TJSONWriter; name : string; elem : TFhirPeriod);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeDateTimeValue(json, 'start', elem.start, false);
  ComposeDateTimeProps(json, 'start', elem.start, false);
  ComposeDateTimeValue(json, 'end', elem.end_, false);
  ComposeDateTimeProps(json, 'end', elem.end_, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseCoding(element : IXmlDomElement; path : string) : TFhirCoding;
var
  child : IXMLDOMElement;
begin
  result := TFhirCoding.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'system') then
        result.system := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'version') then
        result.version := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'display') then
        result.display := ParseString(child, path+'/display') {b}
      else if (child.baseName = 'primary') then
        result.primary := ParseBoolean(child, path+'/primary') {b}
      else if (child.baseName = 'valueSet') then
        result.valueSet := ParseResourceReference{TFhirValueSet}(child, path+'/valueSet') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCoding(xml : TXmlBuilder; name : string; elem : TFhirCoding);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeUri(xml, 'system', elem.system);
  ComposeString(xml, 'version', elem.version);
  ComposeCode(xml, 'code', elem.code);
  ComposeString(xml, 'display', elem.display);
  ComposeBoolean(xml, 'primary', elem.primary);
  ComposeResourceReference{TFhirValueSet}(xml, 'valueSet', elem.valueSet);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCoding(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCoding(jsn));
end;

function TFHIRJsonParser.ParseCoding(jsn : TJsonObject) : TFhirCoding;
begin
  result := TFhirCoding.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system') then
        result.system := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.version := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.code := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.display := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    if jsn.has('primary') or jsn.has('_primary') then
        result.primary := ParseBoolean(jsn['primary'], jsn.vObj['_primary']);{q}
    if jsn.has('valueSet') then
        result.valueSet := ParseResourceReference{TFhirValueSet}(jsn.vObj['valueSet']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCoding(json : TJSONWriter; name : string; elem : TFhirCoding);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeUriValue(json, 'system', elem.system, false);
  ComposeUriProps(json, 'system', elem.system, false);
  ComposeStringValue(json, 'version', elem.version, false);
  ComposeStringProps(json, 'version', elem.version, false);
  ComposeCodeValue(json, 'code', elem.code, false);
  ComposeCodeProps(json, 'code', elem.code, false);
  ComposeStringValue(json, 'display', elem.display, false);
  ComposeStringProps(json, 'display', elem.display, false);
  ComposeBooleanValue(json, 'primary', elem.primary, false);
  ComposeBooleanProps(json, 'primary', elem.primary, false);
  ComposeResourceReference{TFhirValueSet}(json, 'valueSet', elem.valueSet); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseRange(element : IXmlDomElement; path : string) : TFhirRange;
var
  child : IXMLDOMElement;
begin
  result := TFhirRange.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'low') then
        result.low := ParseQuantity(child, path+'/low') {b}
      else if (child.baseName = 'high') then
        result.high := ParseQuantity(child, path+'/high') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeRange(xml : TXmlBuilder; name : string; elem : TFhirRange);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeQuantity(xml, 'low', elem.low);
  ComposeQuantity(xml, 'high', elem.high);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseRange(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRange(jsn));
end;

function TFHIRJsonParser.ParseRange(jsn : TJsonObject) : TFhirRange;
begin
  result := TFhirRange.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('low') then
        result.low := ParseQuantity(jsn.vObj['low']);{q}
    if jsn.has('high') then
        result.high := ParseQuantity(jsn.vObj['high']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeRange(json : TJSONWriter; name : string; elem : TFhirRange);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeQuantity(json, 'low', elem.low); {a}
  ComposeQuantity(json, 'high', elem.high); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseQuantity(element : IXmlDomElement; path : string) : TFhirQuantity;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuantity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'value') then
        result.value := ParseDecimal(child, path+'/value') {b}
      else if (child.baseName = 'comparator') then
        result.comparator := ParseEnum(CODES_TFhirQuantityComparator, path+'/comparator', child)
      else if (child.baseName = 'units') then
        result.units := ParseString(child, path+'/units') {b}
      else if (child.baseName = 'system') then
        result.system := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCode(child, path+'/code') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuantity(xml : TXmlBuilder; name : string; elem : TFhirQuantity);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeDecimal(xml, 'value', elem.value);
  ComposeEnum(xml, 'comparator', elem.Comparator, CODES_TFhirQuantityComparator);
  ComposeString(xml, 'units', elem.units);
  ComposeUri(xml, 'system', elem.system);
  ComposeCode(xml, 'code', elem.code);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuantity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuantity(jsn));
end;

function TFHIRJsonParser.ParseQuantity(jsn : TJsonObject) : TFhirQuantity;
begin
  result := TFhirQuantity.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('value') or jsn.has('_value') then
        result.value := ParseDecimal(jsn['value'], jsn.vObj['_value']);{q}
    if jsn.has('comparator') or jsn.has('_comparator')  then
      result.comparator := parseEnum(jsn['comparator'], jsn.vObj['_comparator'], CODES_TFhirQuantityComparator);
    if jsn.has('units') or jsn.has('_units') then
        result.units := ParseString(jsn['units'], jsn.vObj['_units']);{q}
    if jsn.has('system') or jsn.has('_system') then
        result.system := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.code := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuantity(json : TJSONWriter; name : string; elem : TFhirQuantity);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeDecimalValue(json, 'value', elem.value, false);
  ComposeDecimalProps(json, 'value', elem.value, false);
  ComposeEnumValue(json, 'comparator', elem.Comparator, CODES_TFhirQuantityComparator, false);
  ComposeEnumProps(json, 'comparator', elem.Comparator, CODES_TFhirQuantityComparator, false);
  ComposeStringValue(json, 'units', elem.units, false);
  ComposeStringProps(json, 'units', elem.units, false);
  ComposeUriValue(json, 'system', elem.system, false);
  ComposeUriProps(json, 'system', elem.system, false);
  ComposeCodeValue(json, 'code', elem.code, false);
  ComposeCodeProps(json, 'code', elem.code, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseAttachment(element : IXmlDomElement; path : string) : TFhirAttachment;
var
  child : IXMLDOMElement;
begin
  result := TFhirAttachment.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'contentType') then
        result.contentType := ParseCode(child, path+'/contentType') {b}
      else if (child.baseName = 'language') then
        result.language := ParseCode(child, path+'/language') {b}
      else if (child.baseName = 'data') then
        result.data := ParseBase64Binary(child, path+'/data') {b}
      else if (child.baseName = 'url') then
        result.url := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'size') then
        result.size := ParseInteger(child, path+'/size') {b}
      else if (child.baseName = 'hash') then
        result.hash := ParseBase64Binary(child, path+'/hash') {b}
      else if (child.baseName = 'title') then
        result.title := ParseString(child, path+'/title') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAttachment(xml : TXmlBuilder; name : string; elem : TFhirAttachment);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeCode(xml, 'contentType', elem.contentType);
  ComposeCode(xml, 'language', elem.language);
  ComposeBase64Binary(xml, 'data', elem.data);
  ComposeUri(xml, 'url', elem.url);
  ComposeInteger(xml, 'size', elem.size);
  ComposeBase64Binary(xml, 'hash', elem.hash);
  ComposeString(xml, 'title', elem.title);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAttachment(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAttachment(jsn));
end;

function TFHIRJsonParser.ParseAttachment(jsn : TJsonObject) : TFhirAttachment;
begin
  result := TFhirAttachment.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('contentType') or jsn.has('_contentType') then
        result.contentType := ParseCode(jsn['contentType'], jsn.vObj['_contentType']);{q}
    if jsn.has('language') or jsn.has('_language') then
        result.language := ParseCode(jsn['language'], jsn.vObj['_language']);{q}
    if jsn.has('data') or jsn.has('_data') then
        result.data := ParseBase64Binary(jsn['data'], jsn.vObj['_data']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.url := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('size') or jsn.has('_size') then
        result.size := ParseInteger(jsn['size'], jsn.vObj['_size']);{q}
    if jsn.has('hash') or jsn.has('_hash') then
        result.hash := ParseBase64Binary(jsn['hash'], jsn.vObj['_hash']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.title := ParseString(jsn['title'], jsn.vObj['_title']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAttachment(json : TJSONWriter; name : string; elem : TFhirAttachment);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeCodeValue(json, 'contentType', elem.contentType, false);
  ComposeCodeProps(json, 'contentType', elem.contentType, false);
  ComposeCodeValue(json, 'language', elem.language, false);
  ComposeCodeProps(json, 'language', elem.language, false);
  ComposeBase64BinaryValue(json, 'data', elem.data, false);
  ComposeBase64BinaryProps(json, 'data', elem.data, false);
  ComposeUriValue(json, 'url', elem.url, false);
  ComposeUriProps(json, 'url', elem.url, false);
  ComposeIntegerValue(json, 'size', elem.size, false);
  ComposeIntegerProps(json, 'size', elem.size, false);
  ComposeBase64BinaryValue(json, 'hash', elem.hash, false);
  ComposeBase64BinaryProps(json, 'hash', elem.hash, false);
  ComposeStringValue(json, 'title', elem.title, false);
  ComposeStringProps(json, 'title', elem.title, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseRatio(element : IXmlDomElement; path : string) : TFhirRatio;
var
  child : IXMLDOMElement;
begin
  result := TFhirRatio.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'numerator') then
        result.numerator := ParseQuantity(child, path+'/numerator') {b}
      else if (child.baseName = 'denominator') then
        result.denominator := ParseQuantity(child, path+'/denominator') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeRatio(xml : TXmlBuilder; name : string; elem : TFhirRatio);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeQuantity(xml, 'numerator', elem.numerator);
  ComposeQuantity(xml, 'denominator', elem.denominator);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseRatio(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRatio(jsn));
end;

function TFHIRJsonParser.ParseRatio(jsn : TJsonObject) : TFhirRatio;
begin
  result := TFhirRatio.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('numerator') then
        result.numerator := ParseQuantity(jsn.vObj['numerator']);{q}
    if jsn.has('denominator') then
        result.denominator := ParseQuantity(jsn.vObj['denominator']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeRatio(json : TJSONWriter; name : string; elem : TFhirRatio);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeQuantity(json, 'numerator', elem.numerator); {a}
  ComposeQuantity(json, 'denominator', elem.denominator); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseSampledData(element : IXmlDomElement; path : string) : TFhirSampledData;
var
  child : IXMLDOMElement;
begin
  result := TFhirSampledData.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'origin') then
        result.origin := ParseQuantity(child, path+'/origin') {b}
      else if (child.baseName = 'period') then
        result.period := ParseDecimal(child, path+'/period') {b}
      else if (child.baseName = 'factor') then
        result.factor := ParseDecimal(child, path+'/factor') {b}
      else if (child.baseName = 'lowerLimit') then
        result.lowerLimit := ParseDecimal(child, path+'/lowerLimit') {b}
      else if (child.baseName = 'upperLimit') then
        result.upperLimit := ParseDecimal(child, path+'/upperLimit') {b}
      else if (child.baseName = 'dimensions') then
        result.dimensions := ParseInteger(child, path+'/dimensions') {b}
      else if (child.baseName = 'data') then
        result.data := ParseString(child, path+'/data') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSampledData(xml : TXmlBuilder; name : string; elem : TFhirSampledData);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeQuantity(xml, 'origin', elem.origin);
  ComposeDecimal(xml, 'period', elem.period);
  ComposeDecimal(xml, 'factor', elem.factor);
  ComposeDecimal(xml, 'lowerLimit', elem.lowerLimit);
  ComposeDecimal(xml, 'upperLimit', elem.upperLimit);
  ComposeInteger(xml, 'dimensions', elem.dimensions);
  ComposeString(xml, 'data', elem.data);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSampledData(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSampledData(jsn));
end;

function TFHIRJsonParser.ParseSampledData(jsn : TJsonObject) : TFhirSampledData;
begin
  result := TFhirSampledData.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('origin') then
        result.origin := ParseQuantity(jsn.vObj['origin']);{q}
    if jsn.has('period') or jsn.has('_period') then
        result.period := ParseDecimal(jsn['period'], jsn.vObj['_period']);{q}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factor := ParseDecimal(jsn['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('lowerLimit') or jsn.has('_lowerLimit') then
        result.lowerLimit := ParseDecimal(jsn['lowerLimit'], jsn.vObj['_lowerLimit']);{q}
    if jsn.has('upperLimit') or jsn.has('_upperLimit') then
        result.upperLimit := ParseDecimal(jsn['upperLimit'], jsn.vObj['_upperLimit']);{q}
    if jsn.has('dimensions') or jsn.has('_dimensions') then
        result.dimensions := ParseInteger(jsn['dimensions'], jsn.vObj['_dimensions']);{q}
    if jsn.has('data') or jsn.has('_data') then
        result.data := ParseString(jsn['data'], jsn.vObj['_data']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSampledData(json : TJSONWriter; name : string; elem : TFhirSampledData);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeQuantity(json, 'origin', elem.origin); {a}
  ComposeDecimalValue(json, 'period', elem.period, false);
  ComposeDecimalProps(json, 'period', elem.period, false);
  ComposeDecimalValue(json, 'factor', elem.factor, false);
  ComposeDecimalProps(json, 'factor', elem.factor, false);
  ComposeDecimalValue(json, 'lowerLimit', elem.lowerLimit, false);
  ComposeDecimalProps(json, 'lowerLimit', elem.lowerLimit, false);
  ComposeDecimalValue(json, 'upperLimit', elem.upperLimit, false);
  ComposeDecimalProps(json, 'upperLimit', elem.upperLimit, false);
  ComposeIntegerValue(json, 'dimensions', elem.dimensions, false);
  ComposeIntegerProps(json, 'dimensions', elem.dimensions, false);
  ComposeStringValue(json, 'data', elem.data, false);
  ComposeStringProps(json, 'data', elem.data, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseResourceReference(element : IXmlDomElement; path : string) : TFhirResourceReference;
var
  child : IXMLDOMElement;
begin
  result := TFhirResourceReference.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'reference') then
        result.reference := ParseString(child, path+'/reference') {b}
      else if (child.baseName = 'display') then
        result.display := ParseString(child, path+'/display') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeResourceReference(xml : TXmlBuilder; name : string; elem : TFhirResourceReference);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeString(xml, 'reference', elem.reference);
  ComposeString(xml, 'display', elem.display);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseResourceReference(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseResourceReference(jsn));
end;

function TFHIRJsonParser.ParseResourceReference(jsn : TJsonObject) : TFhirResourceReference;
begin
  result := TFhirResourceReference.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('reference') or jsn.has('_reference') then
        result.reference := ParseString(jsn['reference'], jsn.vObj['_reference']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.display := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeResourceReference(json : TJSONWriter; name : string; elem : TFhirResourceReference);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeStringValue(json, 'reference', elem.reference, false);
  ComposeStringProps(json, 'reference', elem.reference, false);
  ComposeStringValue(json, 'display', elem.display, false);
  ComposeStringProps(json, 'display', elem.display, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseCodeableConcept(element : IXmlDomElement; path : string) : TFhirCodeableConcept;
var
  child : IXMLDOMElement;
begin
  result := TFhirCodeableConcept.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'coding') then
        result.codingList.Add(ParseCoding(child, path+'/coding'))
      else if (child.baseName = 'text') then
        result.text := ParseString(child, path+'/text') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCodeableConcept(xml : TXmlBuilder; name : string; elem : TFhirCodeableConcept);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  for i := 0 to elem.codingList.Count - 1 do
    ComposeCoding(xml, 'coding', elem.codingList[i]);
  ComposeString(xml, 'text', elem.text);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCodeableConcept(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCodeableConcept(jsn));
end;

function TFHIRJsonParser.ParseCodeableConcept(jsn : TJsonObject) : TFhirCodeableConcept;
begin
  result := TFhirCodeableConcept.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('coding') then
      iterateArray(jsn.vArr['coding'], result.codingList, parseCoding);
    if jsn.has('text') or jsn.has('_text') then
        result.text := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCodeableConcept(json : TJSONWriter; name : string; elem : TFhirCodeableConcept);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  if elem.codingList.Count > 0 then
  begin
    json.valueArray('coding');
    for i := 0 to elem.codingList.Count - 1 do
      ComposeCoding(json, '',elem.codingList[i]); {z - Coding}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'text', elem.text, false);
  ComposeStringProps(json, 'text', elem.text, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseIdentifier(element : IXmlDomElement; path : string) : TFhirIdentifier;
var
  child : IXMLDOMElement;
begin
  result := TFhirIdentifier.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'use') then
        result.use := ParseEnum(CODES_TFhirIdentifierUse, path+'/use', child)
      else if (child.baseName = 'label') then
        result.label_ := ParseString(child, path+'/label') {b}
      else if (child.baseName = 'system') then
        result.system := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'value') then
        result.value := ParseString(child, path+'/value') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'assigner') then
        result.assigner := ParseResourceReference{TFhirOrganization}(child, path+'/assigner') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeIdentifier(xml : TXmlBuilder; name : string; elem : TFhirIdentifier);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeEnum(xml, 'use', elem.Use, CODES_TFhirIdentifierUse);
  ComposeString(xml, 'label', elem.label_);
  ComposeUri(xml, 'system', elem.system);
  ComposeString(xml, 'value', elem.value);
  ComposePeriod(xml, 'period', elem.period);
  ComposeResourceReference{TFhirOrganization}(xml, 'assigner', elem.assigner);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseIdentifier(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseIdentifier(jsn));
end;

function TFHIRJsonParser.ParseIdentifier(jsn : TJsonObject) : TFhirIdentifier;
begin
  result := TFhirIdentifier.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('use') or jsn.has('_use')  then
      result.use := parseEnum(jsn['use'], jsn.vObj['_use'], CODES_TFhirIdentifierUse);
    if jsn.has('label') or jsn.has('_label') then
        result.label_ := ParseString(jsn['label'], jsn.vObj['_label']);{q}
    if jsn.has('system') or jsn.has('_system') then
        result.system := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.value := ParseString(jsn['value'], jsn.vObj['_value']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('assigner') then
        result.assigner := ParseResourceReference{TFhirOrganization}(jsn.vObj['assigner']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeIdentifier(json : TJSONWriter; name : string; elem : TFhirIdentifier);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeEnumValue(json, 'use', elem.Use, CODES_TFhirIdentifierUse, false);
  ComposeEnumProps(json, 'use', elem.Use, CODES_TFhirIdentifierUse, false);
  ComposeStringValue(json, 'label', elem.label_, false);
  ComposeStringProps(json, 'label', elem.label_, false);
  ComposeUriValue(json, 'system', elem.system, false);
  ComposeUriProps(json, 'system', elem.system, false);
  ComposeStringValue(json, 'value', elem.value, false);
  ComposeStringProps(json, 'value', elem.value, false);
  ComposePeriod(json, 'period', elem.period); {a}
  ComposeResourceReference{TFhirOrganization}(json, 'assigner', elem.assigner); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseScheduleRepeat(element : IXmlDomElement; path : string) : TFhirScheduleRepeat;
var
  child : IXMLDOMElement;
begin
  result := TFhirScheduleRepeat.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'frequency') then
        result.frequency := ParseInteger(child, path+'/frequency') {b}
      else if (child.baseName = 'when') then
        result.when := ParseEnum(CODES_TFhirEventTiming, path+'/when', child)
      else if (child.baseName = 'duration') then
        result.duration := ParseDecimal(child, path+'/duration') {b}
      else if (child.baseName = 'units') then
        result.units := ParseEnum(CODES_TFhirUnitsOfTime, path+'/units', child)
      else if (child.baseName = 'count') then
        result.count := ParseInteger(child, path+'/count') {b}
      else if (child.baseName = 'end') then
        result.end_ := ParseDateTime(child, path+'/end') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeScheduleRepeat(xml : TXmlBuilder; name : string; elem : TFhirScheduleRepeat);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeInteger(xml, 'frequency', elem.frequency);
  ComposeEnum(xml, 'when', elem.When, CODES_TFhirEventTiming);
  ComposeDecimal(xml, 'duration', elem.duration);
  ComposeEnum(xml, 'units', elem.Units, CODES_TFhirUnitsOfTime);
  ComposeInteger(xml, 'count', elem.count);
  ComposeDateTime(xml, 'end', elem.end_);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseScheduleRepeat(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseScheduleRepeat(jsn));
end;

function TFHIRJsonParser.ParseScheduleRepeat(jsn : TJsonObject) : TFhirScheduleRepeat;
begin
  result := TFhirScheduleRepeat.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('frequency') or jsn.has('_frequency') then
        result.frequency := ParseInteger(jsn['frequency'], jsn.vObj['_frequency']);{q}
    if jsn.has('when') or jsn.has('_when')  then
      result.when := parseEnum(jsn['when'], jsn.vObj['_when'], CODES_TFhirEventTiming);
    if jsn.has('duration') or jsn.has('_duration') then
        result.duration := ParseDecimal(jsn['duration'], jsn.vObj['_duration']);{q}
    if jsn.has('units') or jsn.has('_units')  then
      result.units := parseEnum(jsn['units'], jsn.vObj['_units'], CODES_TFhirUnitsOfTime);
    if jsn.has('count') or jsn.has('_count') then
        result.count := ParseInteger(jsn['count'], jsn.vObj['_count']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_ := ParseDateTime(jsn['end'], jsn.vObj['_end']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeScheduleRepeat(json : TJSONWriter; name : string; elem : TFhirScheduleRepeat);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeIntegerValue(json, 'frequency', elem.frequency, false);
  ComposeIntegerProps(json, 'frequency', elem.frequency, false);
  ComposeEnumValue(json, 'when', elem.When, CODES_TFhirEventTiming, false);
  ComposeEnumProps(json, 'when', elem.When, CODES_TFhirEventTiming, false);
  ComposeDecimalValue(json, 'duration', elem.duration, false);
  ComposeDecimalProps(json, 'duration', elem.duration, false);
  ComposeEnumValue(json, 'units', elem.Units, CODES_TFhirUnitsOfTime, false);
  ComposeEnumProps(json, 'units', elem.Units, CODES_TFhirUnitsOfTime, false);
  ComposeIntegerValue(json, 'count', elem.count, false);
  ComposeIntegerProps(json, 'count', elem.count, false);
  ComposeDateTimeValue(json, 'end', elem.end_, false);
  ComposeDateTimeProps(json, 'end', elem.end_, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseSchedule(element : IXmlDomElement; path : string) : TFhirSchedule;
var
  child : IXMLDOMElement;
begin
  result := TFhirSchedule.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'event') then
        result.eventList.Add(ParsePeriod(child, path+'/event'))
      else if (child.baseName = 'repeat') then
        result.repeat_ := ParseScheduleRepeat(child, path+'/repeat') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSchedule(xml : TXmlBuilder; name : string; elem : TFhirSchedule);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  for i := 0 to elem.eventList.Count - 1 do
    ComposePeriod(xml, 'event', elem.eventList[i]);
  ComposeScheduleRepeat(xml, 'repeat', elem.repeat_);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSchedule(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSchedule(jsn));
end;

function TFHIRJsonParser.ParseSchedule(jsn : TJsonObject) : TFhirSchedule;
begin
  result := TFhirSchedule.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parsePeriod);
    if jsn.has('repeat') then
        result.repeat_ := ParseScheduleRepeat(jsn.vObj['repeat']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSchedule(json : TJSONWriter; name : string; elem : TFhirSchedule);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  if elem.eventList.Count > 0 then
  begin
    json.valueArray('event');
    for i := 0 to elem.eventList.Count - 1 do
      ComposePeriod(json, '',elem.eventList[i]); {z - Period}
    json.FinishArray;
  end;
  ComposeScheduleRepeat(json, 'repeat', elem.repeat_); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseContact(element : IXmlDomElement; path : string) : TFhirContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'system') then
        result.system := ParseEnum(CODES_TFhirContactSystem, path+'/system', child)
      else if (child.baseName = 'value') then
        result.value := ParseString(child, path+'/value') {b}
      else if (child.baseName = 'use') then
        result.use := ParseEnum(CODES_TFhirContactUse, path+'/use', child)
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeContact(xml : TXmlBuilder; name : string; elem : TFhirContact);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeEnum(xml, 'system', elem.System, CODES_TFhirContactSystem);
  ComposeString(xml, 'value', elem.value);
  ComposeEnum(xml, 'use', elem.Use, CODES_TFhirContactUse);
  ComposePeriod(xml, 'period', elem.period);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContact(jsn));
end;

function TFHIRJsonParser.ParseContact(jsn : TJsonObject) : TFhirContact;
begin
  result := TFhirContact.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system')  then
      result.system := parseEnum(jsn['system'], jsn.vObj['_system'], CODES_TFhirContactSystem);
    if jsn.has('value') or jsn.has('_value') then
        result.value := ParseString(jsn['value'], jsn.vObj['_value']);{q}
    if jsn.has('use') or jsn.has('_use')  then
      result.use := parseEnum(jsn['use'], jsn.vObj['_use'], CODES_TFhirContactUse);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeContact(json : TJSONWriter; name : string; elem : TFhirContact);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeEnumValue(json, 'system', elem.System, CODES_TFhirContactSystem, false);
  ComposeEnumProps(json, 'system', elem.System, CODES_TFhirContactSystem, false);
  ComposeStringValue(json, 'value', elem.value, false);
  ComposeStringProps(json, 'value', elem.value, false);
  ComposeEnumValue(json, 'use', elem.Use, CODES_TFhirContactUse, false);
  ComposeEnumProps(json, 'use', elem.Use, CODES_TFhirContactUse, false);
  ComposePeriod(json, 'period', elem.period); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseAddress(element : IXmlDomElement; path : string) : TFhirAddress;
var
  child : IXMLDOMElement;
begin
  result := TFhirAddress.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'use') then
        result.use := ParseEnum(CODES_TFhirAddressUse, path+'/use', child)
      else if (child.baseName = 'text') then
        result.text := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'line') then
        result.lineList.Add(ParseString(child, path+'/line'))
      else if (child.baseName = 'city') then
        result.city := ParseString(child, path+'/city') {b}
      else if (child.baseName = 'state') then
        result.state := ParseString(child, path+'/state') {b}
      else if (child.baseName = 'zip') then
        result.zip := ParseString(child, path+'/zip') {b}
      else if (child.baseName = 'country') then
        result.country := ParseString(child, path+'/country') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAddress(xml : TXmlBuilder; name : string; elem : TFhirAddress);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeEnum(xml, 'use', elem.Use, CODES_TFhirAddressUse);
  ComposeString(xml, 'text', elem.text);
  for i := 0 to elem.lineList.Count - 1 do
    ComposeString(xml, 'line', elem.lineList[i]);
  ComposeString(xml, 'city', elem.city);
  ComposeString(xml, 'state', elem.state);
  ComposeString(xml, 'zip', elem.zip);
  ComposeString(xml, 'country', elem.country);
  ComposePeriod(xml, 'period', elem.period);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAddress(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAddress(jsn));
end;

function TFHIRJsonParser.ParseAddress(jsn : TJsonObject) : TFhirAddress;
begin
  result := TFhirAddress.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('use') or jsn.has('_use')  then
      result.use := parseEnum(jsn['use'], jsn.vObj['_use'], CODES_TFhirAddressUse);
    if jsn.has('text') or jsn.has('_text') then
        result.text := ParseString(jsn['text'], jsn.vObj['_text']);{q}
      if jsn.has('line') or jsn.has('_line') then
      iteratePrimitiveArray(jsn.vArr['line'], jsn.vArr['_line'], result.lineList, parseString);
    if jsn.has('city') or jsn.has('_city') then
        result.city := ParseString(jsn['city'], jsn.vObj['_city']);{q}
    if jsn.has('state') or jsn.has('_state') then
        result.state := ParseString(jsn['state'], jsn.vObj['_state']);{q}
    if jsn.has('zip') or jsn.has('_zip') then
        result.zip := ParseString(jsn['zip'], jsn.vObj['_zip']);{q}
    if jsn.has('country') or jsn.has('_country') then
        result.country := ParseString(jsn['country'], jsn.vObj['_country']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAddress(json : TJSONWriter; name : string; elem : TFhirAddress);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeEnumValue(json, 'use', elem.Use, CODES_TFhirAddressUse, false);
  ComposeEnumProps(json, 'use', elem.Use, CODES_TFhirAddressUse, false);
  ComposeStringValue(json, 'text', elem.text, false);
  ComposeStringProps(json, 'text', elem.text, false);
  if elem.lineList.Count > 0 then
  begin
    json.valueArray('line');
    ext := false;
    for i := 0 to elem.lineList.Count - 1 do
    begin
      ext := ext or ((elem.lineList[i].xmlid <> '') or (elem.lineList[i].hasExtensions));
      ComposeStringValue(json, '',elem.lineList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_line');
      for i := 0 to elem.lineList.Count - 1 do
        ComposeStringProps(json, '',elem.lineList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeStringValue(json, 'city', elem.city, false);
  ComposeStringProps(json, 'city', elem.city, false);
  ComposeStringValue(json, 'state', elem.state, false);
  ComposeStringProps(json, 'state', elem.state, false);
  ComposeStringValue(json, 'zip', elem.zip, false);
  ComposeStringProps(json, 'zip', elem.zip, false);
  ComposeStringValue(json, 'country', elem.country, false);
  ComposeStringProps(json, 'country', elem.country, false);
  ComposePeriod(json, 'period', elem.period); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseHumanName(element : IXmlDomElement; path : string) : TFhirHumanName;
var
  child : IXMLDOMElement;
begin
  result := TFhirHumanName.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'use') then
        result.use := ParseEnum(CODES_TFhirNameUse, path+'/use', child)
      else if (child.baseName = 'text') then
        result.text := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'family') then
        result.familyList.Add(ParseString(child, path+'/family'))
      else if (child.baseName = 'given') then
        result.givenList.Add(ParseString(child, path+'/given'))
      else if (child.baseName = 'prefix') then
        result.prefixList.Add(ParseString(child, path+'/prefix'))
      else if (child.baseName = 'suffix') then
        result.suffixList.Add(ParseString(child, path+'/suffix'))
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeHumanName(xml : TXmlBuilder; name : string; elem : TFhirHumanName);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeElementChildren(xml, elem);
  ComposeEnum(xml, 'use', elem.Use, CODES_TFhirNameUse);
  ComposeString(xml, 'text', elem.text);
  for i := 0 to elem.familyList.Count - 1 do
    ComposeString(xml, 'family', elem.familyList[i]);
  for i := 0 to elem.givenList.Count - 1 do
    ComposeString(xml, 'given', elem.givenList[i]);
  for i := 0 to elem.prefixList.Count - 1 do
    ComposeString(xml, 'prefix', elem.prefixList[i]);
  for i := 0 to elem.suffixList.Count - 1 do
    ComposeString(xml, 'suffix', elem.suffixList[i]);
  ComposePeriod(xml, 'period', elem.period);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseHumanName(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseHumanName(jsn));
end;

function TFHIRJsonParser.ParseHumanName(jsn : TJsonObject) : TFhirHumanName;
begin
  result := TFhirHumanName.create;
  try
    ParseElementProperties(jsn, result);
    if jsn.has('use') or jsn.has('_use')  then
      result.use := parseEnum(jsn['use'], jsn.vObj['_use'], CODES_TFhirNameUse);
    if jsn.has('text') or jsn.has('_text') then
        result.text := ParseString(jsn['text'], jsn.vObj['_text']);{q}
      if jsn.has('family') or jsn.has('_family') then
      iteratePrimitiveArray(jsn.vArr['family'], jsn.vArr['_family'], result.familyList, parseString);
      if jsn.has('given') or jsn.has('_given') then
      iteratePrimitiveArray(jsn.vArr['given'], jsn.vArr['_given'], result.givenList, parseString);
      if jsn.has('prefix') or jsn.has('_prefix') then
      iteratePrimitiveArray(jsn.vArr['prefix'], jsn.vArr['_prefix'], result.prefixList, parseString);
      if jsn.has('suffix') or jsn.has('_suffix') then
      iteratePrimitiveArray(jsn.vArr['suffix'], jsn.vArr['_suffix'], result.suffixList, parseString);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeHumanName(json : TJSONWriter; name : string; elem : TFhirHumanName);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeEnumValue(json, 'use', elem.Use, CODES_TFhirNameUse, false);
  ComposeEnumProps(json, 'use', elem.Use, CODES_TFhirNameUse, false);
  ComposeStringValue(json, 'text', elem.text, false);
  ComposeStringProps(json, 'text', elem.text, false);
  if elem.familyList.Count > 0 then
  begin
    json.valueArray('family');
    ext := false;
    for i := 0 to elem.familyList.Count - 1 do
    begin
      ext := ext or ((elem.familyList[i].xmlid <> '') or (elem.familyList[i].hasExtensions));
      ComposeStringValue(json, '',elem.familyList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_family');
      for i := 0 to elem.familyList.Count - 1 do
        ComposeStringProps(json, '',elem.familyList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.givenList.Count > 0 then
  begin
    json.valueArray('given');
    ext := false;
    for i := 0 to elem.givenList.Count - 1 do
    begin
      ext := ext or ((elem.givenList[i].xmlid <> '') or (elem.givenList[i].hasExtensions));
      ComposeStringValue(json, '',elem.givenList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_given');
      for i := 0 to elem.givenList.Count - 1 do
        ComposeStringProps(json, '',elem.givenList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.prefixList.Count > 0 then
  begin
    json.valueArray('prefix');
    ext := false;
    for i := 0 to elem.prefixList.Count - 1 do
    begin
      ext := ext or ((elem.prefixList[i].xmlid <> '') or (elem.prefixList[i].hasExtensions));
      ComposeStringValue(json, '',elem.prefixList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_prefix');
      for i := 0 to elem.prefixList.Count - 1 do
        ComposeStringProps(json, '',elem.prefixList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.suffixList.Count > 0 then
  begin
    json.valueArray('suffix');
    ext := false;
    for i := 0 to elem.suffixList.Count - 1 do
    begin
      ext := ext or ((elem.suffixList[i].xmlid <> '') or (elem.suffixList[i].hasExtensions));
      ComposeStringValue(json, '',elem.suffixList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_suffix');
      for i := 0 to elem.suffixList.Count - 1 do
        ComposeStringProps(json, '',elem.suffixList[i], true);
      json.FinishArray;
    end;
  end;
  ComposePeriod(json, 'period', elem.period); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseAge(element : IXmlDomElement; path : string) : TFhirAge;
begin
  result := ParseQuantity(element, path);
end;

procedure TFHIRXmlComposer.ComposeAge(xml : TXmlBuilder; name : string; elem : TFhirAge);
begin
  ComposeQuantity(xml, name, elem);
end;

function TFHIRJsonParser.ParseAge(jsn : TJsonObject) : TFhirAge;
begin
  result := ParseQuantity(jsn);
end;

procedure TFHIRJsonComposer.ComposeAge(json : TJSONWriter; name : string; elem : TFhirAge);
begin
  ComposeQuantity(json, name, elem);
end;

function TFHIRXmlParser.ParseCount(element : IXmlDomElement; path : string) : TFhirCount;
begin
  result := ParseQuantity(element, path);
end;

procedure TFHIRXmlComposer.ComposeCount(xml : TXmlBuilder; name : string; elem : TFhirCount);
begin
  ComposeQuantity(xml, name, elem);
end;

function TFHIRJsonParser.ParseCount(jsn : TJsonObject) : TFhirCount;
begin
  result := ParseQuantity(jsn);
end;

procedure TFHIRJsonComposer.ComposeCount(json : TJSONWriter; name : string; elem : TFhirCount);
begin
  ComposeQuantity(json, name, elem);
end;

function TFHIRXmlParser.ParseMoney(element : IXmlDomElement; path : string) : TFhirMoney;
begin
  result := ParseQuantity(element, path);
end;

procedure TFHIRXmlComposer.ComposeMoney(xml : TXmlBuilder; name : string; elem : TFhirMoney);
begin
  ComposeQuantity(xml, name, elem);
end;

function TFHIRJsonParser.ParseMoney(jsn : TJsonObject) : TFhirMoney;
begin
  result := ParseQuantity(jsn);
end;

procedure TFHIRJsonComposer.ComposeMoney(json : TJSONWriter; name : string; elem : TFhirMoney);
begin
  ComposeQuantity(json, name, elem);
end;

function TFHIRXmlParser.ParseDistance(element : IXmlDomElement; path : string) : TFhirDistance;
begin
  result := ParseQuantity(element, path);
end;

procedure TFHIRXmlComposer.ComposeDistance(xml : TXmlBuilder; name : string; elem : TFhirDistance);
begin
  ComposeQuantity(xml, name, elem);
end;

function TFHIRJsonParser.ParseDistance(jsn : TJsonObject) : TFhirDistance;
begin
  result := ParseQuantity(jsn);
end;

procedure TFHIRJsonComposer.ComposeDistance(json : TJSONWriter; name : string; elem : TFhirDistance);
begin
  ComposeQuantity(json, name, elem);
end;

function TFHIRXmlParser.ParseDuration(element : IXmlDomElement; path : string) : TFhirDuration;
begin
  result := ParseQuantity(element, path);
end;

procedure TFHIRXmlComposer.ComposeDuration(xml : TXmlBuilder; name : string; elem : TFhirDuration);
begin
  ComposeQuantity(xml, name, elem);
end;

function TFHIRJsonParser.ParseDuration(jsn : TJsonObject) : TFhirDuration;
begin
  result := ParseQuantity(jsn);
end;

procedure TFHIRJsonComposer.ComposeDuration(json : TJSONWriter; name : string; elem : TFhirDuration);
begin
  ComposeQuantity(json, name, elem);
end;

function TFHIRXmlParser.ParseAdverseReactionSymptom(element : IXmlDomElement; path : string) : TFhirAdverseReactionSymptom;
var
  child : IXMLDOMElement;
begin
  result := TFhirAdverseReactionSymptom.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'severity') then
        result.severity := ParseEnum(CODES_TFhirReactionSeverity, path+'/severity', child)
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAdverseReactionSymptom(xml : TXmlBuilder; name : string; elem : TFhirAdverseReactionSymptom);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);
  ComposeEnum(xml, 'severity', elem.Severity, CODES_TFhirReactionSeverity);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAdverseReactionSymptom(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAdverseReactionSymptom(jsn));
end;

function TFHIRJsonParser.ParseAdverseReactionSymptom(jsn : TJsonObject) : TFhirAdverseReactionSymptom;
begin
  result := TFhirAdverseReactionSymptom.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('severity') or jsn.has('_severity')  then
      result.severity := parseEnum(jsn['severity'], jsn.vObj['_severity'], CODES_TFhirReactionSeverity);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAdverseReactionSymptom(json : TJSONWriter; name : string; elem : TFhirAdverseReactionSymptom);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeEnumValue(json, 'severity', elem.Severity, CODES_TFhirReactionSeverity, false);
  ComposeEnumProps(json, 'severity', elem.Severity, CODES_TFhirReactionSeverity, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseAdverseReactionExposure(element : IXmlDomElement; path : string) : TFhirAdverseReactionExposure;
var
  child : IXMLDOMElement;
begin
  result := TFhirAdverseReactionExposure.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'date') then
        result.date := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseEnum(CODES_TFhirExposureType, path+'/type', child)
      else if (child.baseName = 'causalityExpectation') then
        result.causalityExpectation := ParseEnum(CODES_TFhirCausalityExpectation, path+'/causalityExpectation', child)
      else if (child.baseName = 'substance') then
        result.substance := ParseResourceReference{TFhirSubstance}(child, path+'/substance') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAdverseReactionExposure(xml : TXmlBuilder; name : string; elem : TFhirAdverseReactionExposure);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeDateTime(xml, 'date', elem.date);
  ComposeEnum(xml, 'type', elem.Type_, CODES_TFhirExposureType);
  ComposeEnum(xml, 'causalityExpectation', elem.CausalityExpectation, CODES_TFhirCausalityExpectation);
  ComposeResourceReference{TFhirSubstance}(xml, 'substance', elem.substance);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAdverseReactionExposure(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAdverseReactionExposure(jsn));
end;

function TFHIRJsonParser.ParseAdverseReactionExposure(jsn : TJsonObject) : TFhirAdverseReactionExposure;
begin
  result := TFhirAdverseReactionExposure.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('date') or jsn.has('_date') then
        result.date := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_ := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirExposureType);
    if jsn.has('causalityExpectation') or jsn.has('_causalityExpectation')  then
      result.causalityExpectation := parseEnum(jsn['causalityExpectation'], jsn.vObj['_causalityExpectation'], CODES_TFhirCausalityExpectation);
    if jsn.has('substance') then
        result.substance := ParseResourceReference{TFhirSubstance}(jsn.vObj['substance']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAdverseReactionExposure(json : TJSONWriter; name : string; elem : TFhirAdverseReactionExposure);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeDateTimeValue(json, 'date', elem.date, false);
  ComposeDateTimeProps(json, 'date', elem.date, false);
  ComposeEnumValue(json, 'type', elem.Type_, CODES_TFhirExposureType, false);
  ComposeEnumProps(json, 'type', elem.Type_, CODES_TFhirExposureType, false);
  ComposeEnumValue(json, 'causalityExpectation', elem.CausalityExpectation, CODES_TFhirCausalityExpectation, false);
  ComposeEnumProps(json, 'causalityExpectation', elem.CausalityExpectation, CODES_TFhirCausalityExpectation, false);
  ComposeResourceReference{TFhirSubstance}(json, 'substance', elem.substance); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseAdverseReaction(element : IXmlDomElement; path : string) : TFhirAdverseReaction;
var
  child : IXMLDOMElement;
begin
  result := TFhirAdverseReaction.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'date') then
        result.date := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseResourceReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'didNotOccurFlag') then
        result.didNotOccurFlag := ParseBoolean(child, path+'/didNotOccurFlag') {b}
      else if (child.baseName = 'recorder') then
        result.recorder := ParseResourceReference{Resource}(child, path+'/recorder') {b}
      else if (child.baseName = 'symptom') then
        result.symptomList.Add(ParseAdverseReactionSymptom(child, path+'/symptom'))
      else if (child.baseName = 'exposure') then
        result.exposureList.Add(ParseAdverseReactionExposure(child, path+'/exposure'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAdverseReaction(xml : TXmlBuilder; name : string; elem : TFhirAdverseReaction);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeDateTime(xml, 'date', elem.date);
  ComposeResourceReference{TFhirPatient}(xml, 'subject', elem.subject);
  ComposeBoolean(xml, 'didNotOccurFlag', elem.didNotOccurFlag);
  ComposeResourceReference{Resource}(xml, 'recorder', elem.recorder);
  for i := 0 to elem.symptomList.Count - 1 do
    ComposeAdverseReactionSymptom(xml, 'symptom', elem.symptomList[i]);
  for i := 0 to elem.exposureList.Count - 1 do
    ComposeAdverseReactionExposure(xml, 'exposure', elem.exposureList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAdverseReaction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAdverseReaction(jsn));
end;

function TFHIRJsonParser.ParseAdverseReaction(jsn : TJsonObject) : TFhirAdverseReaction;
begin
  result := TFhirAdverseReaction.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('date') or jsn.has('_date') then
        result.date := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('subject') then
        result.subject := ParseResourceReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('didNotOccurFlag') or jsn.has('_didNotOccurFlag') then
        result.didNotOccurFlag := ParseBoolean(jsn['didNotOccurFlag'], jsn.vObj['_didNotOccurFlag']);{q}
    if jsn.has('recorder') then
        result.recorder := ParseResourceReference{Resource}(jsn.vObj['recorder']);{q}
    if jsn.has('symptom') then
      iterateArray(jsn.vArr['symptom'], result.symptomList, parseAdverseReactionSymptom);
    if jsn.has('exposure') then
      iterateArray(jsn.vArr['exposure'], result.exposureList, parseAdverseReactionExposure);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAdverseReaction(json : TJSONWriter; name : string; elem : TFhirAdverseReaction);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeDateTimeValue(json, 'date', elem.date, false);
  ComposeDateTimeProps(json, 'date', elem.date, false);
  ComposeResourceReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  ComposeBooleanValue(json, 'didNotOccurFlag', elem.didNotOccurFlag, false);
  ComposeBooleanProps(json, 'didNotOccurFlag', elem.didNotOccurFlag, false);
  ComposeResourceReference{Resource}(json, 'recorder', elem.recorder); {a}
  if elem.symptomList.Count > 0 then
  begin
    json.valueArray('symptom');
    for i := 0 to elem.symptomList.Count - 1 do
      ComposeAdverseReactionSymptom(json, '',elem.symptomList[i]); {z - }
    json.FinishArray;
  end;
  if elem.exposureList.Count > 0 then
  begin
    json.valueArray('exposure');
    for i := 0 to elem.exposureList.Count - 1 do
      ComposeAdverseReactionExposure(json, '',elem.exposureList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseAlert(element : IXmlDomElement; path : string) : TFhirAlert;
var
  child : IXMLDOMElement;
begin
  result := TFhirAlert.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'category') then
        result.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirAlertStatus, path+'/status', child)
      else if (child.baseName = 'subject') then
        result.subject := ParseResourceReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'author') then
        result.author := ParseResourceReference{Resource}(child, path+'/author') {b}
      else if (child.baseName = 'note') then
        result.note := ParseString(child, path+'/note') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAlert(xml : TXmlBuilder; name : string; elem : TFhirAlert);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'category', elem.category);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirAlertStatus);
  ComposeResourceReference{TFhirPatient}(xml, 'subject', elem.subject);
  ComposeResourceReference{Resource}(xml, 'author', elem.author);
  ComposeString(xml, 'note', elem.note);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAlert(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAlert(jsn));
end;

function TFHIRJsonParser.ParseAlert(jsn : TJsonObject) : TFhirAlert;
begin
  result := TFhirAlert.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirAlertStatus);
    if jsn.has('subject') then
        result.subject := ParseResourceReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('author') then
        result.author := ParseResourceReference{Resource}(jsn.vObj['author']);{q}
    if jsn.has('note') or jsn.has('_note') then
        result.note := ParseString(jsn['note'], jsn.vObj['_note']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAlert(json : TJSONWriter; name : string; elem : TFhirAlert);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirAlertStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirAlertStatus, false);
  ComposeResourceReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  ComposeResourceReference{Resource}(json, 'author', elem.author); {a}
  ComposeStringValue(json, 'note', elem.note, false);
  ComposeStringProps(json, 'note', elem.note, false);
end;

function TFHIRXmlParser.ParseAllergyIntolerance(element : IXmlDomElement; path : string) : TFhirAllergyIntolerance;
var
  child : IXMLDOMElement;
begin
  result := TFhirAllergyIntolerance.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'criticality') then
        result.criticality := ParseEnum(CODES_TFhirCriticality, path+'/criticality', child)
      else if (child.baseName = 'sensitivityType') then
        result.sensitivityType := ParseEnum(CODES_TFhirSensitivitytype, path+'/sensitivityType', child)
      else if (child.baseName = 'recordedDate') then
        result.recordedDate := ParseDateTime(child, path+'/recordedDate') {b}
      else if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirSensitivitystatus, path+'/status', child)
      else if (child.baseName = 'subject') then
        result.subject := ParseResourceReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'recorder') then
        result.recorder := ParseResourceReference{Resource}(child, path+'/recorder') {b}
      else if (child.baseName = 'substance') then
        result.substance := ParseResourceReference{TFhirSubstance}(child, path+'/substance') {b}
      else if (child.baseName = 'reaction') then
        result.reactionList.Add(ParseResourceReference{TFhirAdverseReaction}(child, path+'/reaction'))
      else if (child.baseName = 'sensitivityTest') then
        result.sensitivityTestList.Add(ParseResourceReference{TFhirObservation}(child, path+'/sensitivityTest'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeAllergyIntolerance(xml : TXmlBuilder; name : string; elem : TFhirAllergyIntolerance);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'criticality', elem.Criticality, CODES_TFhirCriticality);
  ComposeEnum(xml, 'sensitivityType', elem.SensitivityType, CODES_TFhirSensitivitytype);
  ComposeDateTime(xml, 'recordedDate', elem.recordedDate);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirSensitivitystatus);
  ComposeResourceReference{TFhirPatient}(xml, 'subject', elem.subject);
  ComposeResourceReference{Resource}(xml, 'recorder', elem.recorder);
  ComposeResourceReference{TFhirSubstance}(xml, 'substance', elem.substance);
  for i := 0 to elem.reactionList.Count - 1 do
    ComposeResourceReference{TFhirAdverseReaction}(xml, 'reaction', elem.reactionList[i]);
  for i := 0 to elem.sensitivityTestList.Count - 1 do
    ComposeResourceReference{TFhirObservation}(xml, 'sensitivityTest', elem.sensitivityTestList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseAllergyIntolerance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAllergyIntolerance(jsn));
end;

function TFHIRJsonParser.ParseAllergyIntolerance(jsn : TJsonObject) : TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('criticality') or jsn.has('_criticality')  then
      result.criticality := parseEnum(jsn['criticality'], jsn.vObj['_criticality'], CODES_TFhirCriticality);
    if jsn.has('sensitivityType') or jsn.has('_sensitivityType')  then
      result.sensitivityType := parseEnum(jsn['sensitivityType'], jsn.vObj['_sensitivityType'], CODES_TFhirSensitivitytype);
    if jsn.has('recordedDate') or jsn.has('_recordedDate') then
        result.recordedDate := ParseDateTime(jsn['recordedDate'], jsn.vObj['_recordedDate']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirSensitivitystatus);
    if jsn.has('subject') then
        result.subject := ParseResourceReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('recorder') then
        result.recorder := ParseResourceReference{Resource}(jsn.vObj['recorder']);{q}
    if jsn.has('substance') then
        result.substance := ParseResourceReference{TFhirSubstance}(jsn.vObj['substance']);{q}
    if jsn.has('reaction') then
      iterateArray(jsn.vArr['reaction'], result.reactionList, parseResourceReference{TFhirAdverseReaction});
    if jsn.has('sensitivityTest') then
      iterateArray(jsn.vArr['sensitivityTest'], result.sensitivityTestList, parseResourceReference{TFhirObservation});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeAllergyIntolerance(json : TJSONWriter; name : string; elem : TFhirAllergyIntolerance);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'criticality', elem.Criticality, CODES_TFhirCriticality, false);
  ComposeEnumProps(json, 'criticality', elem.Criticality, CODES_TFhirCriticality, false);
  ComposeEnumValue(json, 'sensitivityType', elem.SensitivityType, CODES_TFhirSensitivitytype, false);
  ComposeEnumProps(json, 'sensitivityType', elem.SensitivityType, CODES_TFhirSensitivitytype, false);
  ComposeDateTimeValue(json, 'recordedDate', elem.recordedDate, false);
  ComposeDateTimeProps(json, 'recordedDate', elem.recordedDate, false);
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirSensitivitystatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirSensitivitystatus, false);
  ComposeResourceReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  ComposeResourceReference{Resource}(json, 'recorder', elem.recorder); {a}
  ComposeResourceReference{TFhirSubstance}(json, 'substance', elem.substance); {a}
  if elem.reactionList.Count > 0 then
  begin
    json.valueArray('reaction');
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeResourceReference{TFhirAdverseReaction}(json, '',elem.reactionList[i]); {z - Resource(AdverseReaction)}
    json.FinishArray;
  end;
  if elem.sensitivityTestList.Count > 0 then
  begin
    json.valueArray('sensitivityTest');
    for i := 0 to elem.sensitivityTestList.Count - 1 do
      ComposeResourceReference{TFhirObservation}(json, '',elem.sensitivityTestList[i]); {z - Resource(Observation)}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseCarePlanParticipant(element : IXmlDomElement; path : string) : TFhirCarePlanParticipant;
var
  child : IXMLDOMElement;
begin
  result := TFhirCarePlanParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'role') then
        result.role := ParseCodeableConcept(child, path+'/role') {b}
      else if (child.baseName = 'member') then
        result.member := ParseResourceReference{Resource}(child, path+'/member') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCarePlanParticipant(xml : TXmlBuilder; name : string; elem : TFhirCarePlanParticipant);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'role', elem.role);
  ComposeResourceReference{Resource}(xml, 'member', elem.member);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCarePlanParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlanParticipant(jsn));
end;

function TFHIRJsonParser.ParseCarePlanParticipant(jsn : TJsonObject) : TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') then
        result.role := ParseCodeableConcept(jsn.vObj['role']);{q}
    if jsn.has('member') then
        result.member := ParseResourceReference{Resource}(jsn.vObj['member']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCarePlanParticipant(json : TJSONWriter; name : string; elem : TFhirCarePlanParticipant);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'role', elem.role); {a}
  ComposeResourceReference{Resource}(json, 'member', elem.member); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseCarePlanGoal(element : IXmlDomElement; path : string) : TFhirCarePlanGoal;
var
  child : IXMLDOMElement;
begin
  result := TFhirCarePlanGoal.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'description') then
        result.description := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirCarePlanGoalStatus, path+'/status', child)
      else if (child.baseName = 'notes') then
        result.notes := ParseString(child, path+'/notes') {b}
      else if (child.baseName = 'concern') then
        result.concernList.Add(ParseResourceReference{TFhirCondition}(child, path+'/concern'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCarePlanGoal(xml : TXmlBuilder; name : string; elem : TFhirCarePlanGoal);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'description', elem.description);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirCarePlanGoalStatus);
  ComposeString(xml, 'notes', elem.notes);
  for i := 0 to elem.concernList.Count - 1 do
    ComposeResourceReference{TFhirCondition}(xml, 'concern', elem.concernList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCarePlanGoal(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlanGoal(jsn));
end;

function TFHIRJsonParser.ParseCarePlanGoal(jsn : TJsonObject) : TFhirCarePlanGoal;
begin
  result := TFhirCarePlanGoal.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.description := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirCarePlanGoalStatus);
    if jsn.has('notes') or jsn.has('_notes') then
        result.notes := ParseString(jsn['notes'], jsn.vObj['_notes']);{q}
    if jsn.has('concern') then
      iterateArray(jsn.vArr['concern'], result.concernList, parseResourceReference{TFhirCondition});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCarePlanGoal(json : TJSONWriter; name : string; elem : TFhirCarePlanGoal);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'description', elem.description, false);
  ComposeStringProps(json, 'description', elem.description, false);
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirCarePlanGoalStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirCarePlanGoalStatus, false);
  ComposeStringValue(json, 'notes', elem.notes, false);
  ComposeStringProps(json, 'notes', elem.notes, false);
  if elem.concernList.Count > 0 then
  begin
    json.valueArray('concern');
    for i := 0 to elem.concernList.Count - 1 do
      ComposeResourceReference{TFhirCondition}(json, '',elem.concernList[i]); {z - Resource(Condition)}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseCarePlanActivity(element : IXmlDomElement; path : string) : TFhirCarePlanActivity;
var
  child : IXMLDOMElement;
begin
  result := TFhirCarePlanActivity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'goal') then
        result.goalList.Add(ParseString(child, path+'/goal'))
      else if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirCarePlanActivityStatus, path+'/status', child)
      else if (child.baseName = 'prohibited') then
        result.prohibited := ParseBoolean(child, path+'/prohibited') {b}
      else if (child.baseName = 'actionResulting') then
        result.actionResultingList.Add(ParseResourceReference{Resource}(child, path+'/actionResulting'))
      else if (child.baseName = 'notes') then
        result.notes := ParseString(child, path+'/notes') {b}
      else if (child.baseName = 'detail') then
        result.detail := ParseResourceReference{Resource}(child, path+'/detail') {b}
      else if (child.baseName = 'simple') then
        result.simple := ParseCarePlanActivitySimple(child, path+'/simple') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCarePlanActivity(xml : TXmlBuilder; name : string; elem : TFhirCarePlanActivity);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.goalList.Count - 1 do
    ComposeString(xml, 'goal', elem.goalList[i]);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirCarePlanActivityStatus);
  ComposeBoolean(xml, 'prohibited', elem.prohibited);
  for i := 0 to elem.actionResultingList.Count - 1 do
    ComposeResourceReference{Resource}(xml, 'actionResulting', elem.actionResultingList[i]);
  ComposeString(xml, 'notes', elem.notes);
  ComposeResourceReference{Resource}(xml, 'detail', elem.detail);
  ComposeCarePlanActivitySimple(xml, 'simple', elem.simple);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCarePlanActivity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlanActivity(jsn));
end;

function TFHIRJsonParser.ParseCarePlanActivity(jsn : TJsonObject) : TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity.create;
  try
    ParseBackboneElementProperties(jsn, result);
      if jsn.has('goal') or jsn.has('_goal') then
      iteratePrimitiveArray(jsn.vArr['goal'], jsn.vArr['_goal'], result.goalList, parseString);
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirCarePlanActivityStatus);
    if jsn.has('prohibited') or jsn.has('_prohibited') then
        result.prohibited := ParseBoolean(jsn['prohibited'], jsn.vObj['_prohibited']);{q}
    if jsn.has('actionResulting') then
      iterateArray(jsn.vArr['actionResulting'], result.actionResultingList, parseResourceReference{Resource});
    if jsn.has('notes') or jsn.has('_notes') then
        result.notes := ParseString(jsn['notes'], jsn.vObj['_notes']);{q}
    if jsn.has('detail') then
        result.detail := ParseResourceReference{Resource}(jsn.vObj['detail']);{q}
    if jsn.has('simple') then
        result.simple := ParseCarePlanActivitySimple(jsn.vObj['simple']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCarePlanActivity(json : TJSONWriter; name : string; elem : TFhirCarePlanActivity);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.goalList.Count > 0 then
  begin
    json.valueArray('goal');
    ext := false;
    for i := 0 to elem.goalList.Count - 1 do
    begin
      ext := ext or ((elem.goalList[i].xmlid <> '') or (elem.goalList[i].hasExtensions));
      ComposeStringValue(json, '',elem.goalList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_goal');
      for i := 0 to elem.goalList.Count - 1 do
        ComposeStringProps(json, '',elem.goalList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirCarePlanActivityStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirCarePlanActivityStatus, false);
  ComposeBooleanValue(json, 'prohibited', elem.prohibited, false);
  ComposeBooleanProps(json, 'prohibited', elem.prohibited, false);
  if elem.actionResultingList.Count > 0 then
  begin
    json.valueArray('actionResulting');
    for i := 0 to elem.actionResultingList.Count - 1 do
      ComposeResourceReference{Resource}(json, '',elem.actionResultingList[i]); {z - Resource(Any)}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'notes', elem.notes, false);
  ComposeStringProps(json, 'notes', elem.notes, false);
  ComposeResourceReference{Resource}(json, 'detail', elem.detail); {a}
  ComposeCarePlanActivitySimple(json, 'simple', elem.simple); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseCarePlanActivitySimple(element : IXmlDomElement; path : string) : TFhirCarePlanActivitySimple;
var
  child : IXMLDOMElement;
begin
  result := TFhirCarePlanActivitySimple.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'category') then
        result.category := ParseEnum(CODES_TFhirCarePlanActivityCategory, path+'/category', child)
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'timingSchedule') then
        result.timing := ParseSchedule(child, path+'/timingSchedule')
      else if (child.baseName = 'timingPeriod') then
        result.timing := ParsePeriod(child, path+'/timingPeriod')
      else if (child.baseName = 'timingString') then
        result.timing := ParseString(child, path+'/timingString')
      else if (child.baseName = 'location') then
        result.location := ParseResourceReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'performer') then
        result.performerList.Add(ParseResourceReference{Resource}(child, path+'/performer'))
      else if (child.baseName = 'product') then
        result.product := ParseResourceReference{Resource}(child, path+'/product') {b}
      else if (child.baseName = 'dailyAmount') then
        result.dailyAmount := ParseQuantity(child, path+'/dailyAmount') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'details') then
        result.details := ParseString(child, path+'/details') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCarePlanActivitySimple(xml : TXmlBuilder; name : string; elem : TFhirCarePlanActivitySimple);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'category', elem.Category, CODES_TFhirCarePlanActivityCategory);
  ComposeCodeableConcept(xml, 'code', elem.code);
  if (elem.timing is TFhirSchedule) {6} then
    ComposeSchedule(xml, 'timingSchedule', TFhirSchedule(elem.timing))
  else if (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(xml, 'timingPeriod', TFhirPeriod(elem.timing))
  else if (elem.timing is TFhirString) {6} then
    ComposeString(xml, 'timingString', TFhirString(elem.timing));
  ComposeResourceReference{TFhirLocation}(xml, 'location', elem.location);
  for i := 0 to elem.performerList.Count - 1 do
    ComposeResourceReference{Resource}(xml, 'performer', elem.performerList[i]);
  ComposeResourceReference{Resource}(xml, 'product', elem.product);
  ComposeQuantity(xml, 'dailyAmount', elem.dailyAmount);
  ComposeQuantity(xml, 'quantity', elem.quantity);
  ComposeString(xml, 'details', elem.details);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCarePlanActivitySimple(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlanActivitySimple(jsn));
end;

function TFHIRJsonParser.ParseCarePlanActivitySimple(jsn : TJsonObject) : TFhirCarePlanActivitySimple;
begin
  result := TFhirCarePlanActivitySimple.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('category') or jsn.has('_category')  then
      result.category := parseEnum(jsn['category'], jsn.vObj['_category'], CODES_TFhirCarePlanActivityCategory);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('timingSchedule') {a4} then
      result.timing := ParseSchedule(jsn.vObj['timingSchedule']);
    if jsn.has('timingPeriod') {a4} then
      result.timing := ParsePeriod(jsn.vObj['timingPeriod']);
    if jsn.has('timingString') or jsn.has('_timingString') then
      result.timing := parseString(jsn['timingString'], jsn.vObj['_timingString']);
    if jsn.has('location') then
        result.location := ParseResourceReference{TFhirLocation}(jsn.vObj['location']);{q}
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseResourceReference{Resource});
    if jsn.has('product') then
        result.product := ParseResourceReference{Resource}(jsn.vObj['product']);{q}
    if jsn.has('dailyAmount') then
        result.dailyAmount := ParseQuantity(jsn.vObj['dailyAmount']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('details') or jsn.has('_details') then
        result.details := ParseString(jsn['details'], jsn.vObj['_details']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCarePlanActivitySimple(json : TJSONWriter; name : string; elem : TFhirCarePlanActivitySimple);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'category', elem.Category, CODES_TFhirCarePlanActivityCategory, false);
  ComposeEnumProps(json, 'category', elem.Category, CODES_TFhirCarePlanActivityCategory, false);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (elem.timing is TFhirSchedule) then 
    ComposeSchedule(json, 'timingSchedule', TFhirSchedule(elem.timing)) 
  else if (elem.timing is TFhirPeriod) then 
    ComposePeriod(json, 'timingPeriod', TFhirPeriod(elem.timing)) 
  else if (elem.timing is TFhirString) then 
  begin
    ComposeStringValue(json, 'timingString', TFhirString(elem.timing), false);
    ComposeStringProps(json, 'timingString', TFhirString(elem.timing), false);
  end;
  ComposeResourceReference{TFhirLocation}(json, 'location', elem.location); {a}
  if elem.performerList.Count > 0 then
  begin
    json.valueArray('performer');
    for i := 0 to elem.performerList.Count - 1 do
      ComposeResourceReference{Resource}(json, '',elem.performerList[i]); {z - Resource(Practitioner|Organization|RelatedPerson|Patient)}
    json.FinishArray;
  end;
  ComposeResourceReference{Resource}(json, 'product', elem.product); {a}
  ComposeQuantity(json, 'dailyAmount', elem.dailyAmount); {a}
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeStringValue(json, 'details', elem.details, false);
  ComposeStringProps(json, 'details', elem.details, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseCarePlan(element : IXmlDomElement; path : string) : TFhirCarePlan;
var
  child : IXMLDOMElement;
begin
  result := TFhirCarePlan.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'patient') then
        result.patient := ParseResourceReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirCarePlanStatus, path+'/status', child)
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'modified') then
        result.modified := ParseDateTime(child, path+'/modified') {b}
      else if (child.baseName = 'concern') then
        result.concernList.Add(ParseResourceReference{TFhirCondition}(child, path+'/concern'))
      else if (child.baseName = 'participant') then
        result.participantList.Add(ParseCarePlanParticipant(child, path+'/participant'))
      else if (child.baseName = 'goal') then
        result.goalList.Add(ParseCarePlanGoal(child, path+'/goal'))
      else if (child.baseName = 'activity') then
        result.activityList.Add(ParseCarePlanActivity(child, path+'/activity'))
      else if (child.baseName = 'notes') then
        result.notes := ParseString(child, path+'/notes') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCarePlan(xml : TXmlBuilder; name : string; elem : TFhirCarePlan);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeResourceReference{TFhirPatient}(xml, 'patient', elem.patient);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirCarePlanStatus);
  ComposePeriod(xml, 'period', elem.period);
  ComposeDateTime(xml, 'modified', elem.modified);
  for i := 0 to elem.concernList.Count - 1 do
    ComposeResourceReference{TFhirCondition}(xml, 'concern', elem.concernList[i]);
  for i := 0 to elem.participantList.Count - 1 do
    ComposeCarePlanParticipant(xml, 'participant', elem.participantList[i]);
  for i := 0 to elem.goalList.Count - 1 do
    ComposeCarePlanGoal(xml, 'goal', elem.goalList[i]);
  for i := 0 to elem.activityList.Count - 1 do
    ComposeCarePlanActivity(xml, 'activity', elem.activityList[i]);
  ComposeString(xml, 'notes', elem.notes);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCarePlan(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlan(jsn));
end;

function TFHIRJsonParser.ParseCarePlan(jsn : TJsonObject) : TFhirCarePlan;
begin
  result := TFhirCarePlan.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('patient') then
        result.patient := ParseResourceReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirCarePlanStatus);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('modified') or jsn.has('_modified') then
        result.modified := ParseDateTime(jsn['modified'], jsn.vObj['_modified']);{q}
    if jsn.has('concern') then
      iterateArray(jsn.vArr['concern'], result.concernList, parseResourceReference{TFhirCondition});
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseCarePlanParticipant);
    if jsn.has('goal') then
      iterateArray(jsn.vArr['goal'], result.goalList, parseCarePlanGoal);
    if jsn.has('activity') then
      iterateArray(jsn.vArr['activity'], result.activityList, parseCarePlanActivity);
    if jsn.has('notes') or jsn.has('_notes') then
        result.notes := ParseString(jsn['notes'], jsn.vObj['_notes']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCarePlan(json : TJSONWriter; name : string; elem : TFhirCarePlan);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeResourceReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirCarePlanStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirCarePlanStatus, false);
  ComposePeriod(json, 'period', elem.period); {a}
  ComposeDateTimeValue(json, 'modified', elem.modified, false);
  ComposeDateTimeProps(json, 'modified', elem.modified, false);
  if elem.concernList.Count > 0 then
  begin
    json.valueArray('concern');
    for i := 0 to elem.concernList.Count - 1 do
      ComposeResourceReference{TFhirCondition}(json, '',elem.concernList[i]); {z - Resource(Condition)}
    json.FinishArray;
  end;
  if elem.participantList.Count > 0 then
  begin
    json.valueArray('participant');
    for i := 0 to elem.participantList.Count - 1 do
      ComposeCarePlanParticipant(json, '',elem.participantList[i]); {z - }
    json.FinishArray;
  end;
  if elem.goalList.Count > 0 then
  begin
    json.valueArray('goal');
    for i := 0 to elem.goalList.Count - 1 do
      ComposeCarePlanGoal(json, '',elem.goalList[i]); {z - }
    json.FinishArray;
  end;
  if elem.activityList.Count > 0 then
  begin
    json.valueArray('activity');
    for i := 0 to elem.activityList.Count - 1 do
      ComposeCarePlanActivity(json, '',elem.activityList[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'notes', elem.notes, false);
  ComposeStringProps(json, 'notes', elem.notes, false);
end;

function TFHIRXmlParser.ParseCompositionAttester(element : IXmlDomElement; path : string) : TFhirCompositionAttester;
var
  child : IXMLDOMElement;
begin
  result := TFhirCompositionAttester.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'mode') then
        result.mode.Add(ParseEnum(CODES_TFhirCompositionAttestationMode, path+'/mode', child))
      else if (child.baseName = 'time') then
        result.time := ParseDateTime(child, path+'/time') {b}
      else if (child.baseName = 'party') then
        result.party := ParseResourceReference{Resource}(child, path+'/party') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCompositionAttester(xml : TXmlBuilder; name : string; elem : TFhirCompositionAttester);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.mode.Count - 1 do
    ComposeEnum(xml, 'mode', elem.mode[i], CODES_TFhirCompositionAttestationMode);
  ComposeDateTime(xml, 'time', elem.time);
  ComposeResourceReference{Resource}(xml, 'party', elem.party);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCompositionAttester(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCompositionAttester(jsn));
end;

function TFHIRJsonParser.ParseCompositionAttester(jsn : TJsonObject) : TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('mode') or jsn.has('_mode') then
      iterateEnumArray(jsn.vArr['mode'], jsn.vArr['_mode'], result.mode, parseEnum, CODES_TFhirCompositionAttestationMode);
    if jsn.has('time') or jsn.has('_time') then
        result.time := ParseDateTime(jsn['time'], jsn.vObj['_time']);{q}
    if jsn.has('party') then
        result.party := ParseResourceReference{Resource}(jsn.vObj['party']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCompositionAttester(json : TJSONWriter; name : string; elem : TFhirCompositionAttester);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.mode.Count > 0 then
  begin
    json.valueArray('mode');
    ext := false;
    for i := 0 to elem.mode.Count - 1 do
    begin
      ext := ext or ((elem.mode[i].xmlid <> '') or (elem.mode[i].hasExtensions));
      ComposeEnumValue(json, '', elem.mode[i], CODES_TFhirCompositionAttestationMode, true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_mode');
      for i := 0 to elem.mode.Count - 1 do
        ComposeEnumProps(json, '', elem.mode[i], CODES_TFhirCompositionAttestationMode, true);
      json.FinishArray;
    end;
  end;
  ComposeDateTimeValue(json, 'time', elem.time, false);
  ComposeDateTimeProps(json, 'time', elem.time, false);
  ComposeResourceReference{Resource}(json, 'party', elem.party); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseCompositionEvent(element : IXmlDomElement; path : string) : TFhirCompositionEvent;
var
  child : IXMLDOMElement;
begin
  result := TFhirCompositionEvent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.codeList.Add(ParseCodeableConcept(child, path+'/code'))
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'detail') then
        result.detailList.Add(ParseResourceReference{Resource}(child, path+'/detail'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCompositionEvent(xml : TXmlBuilder; name : string; elem : TFhirCompositionEvent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.codeList.Count - 1 do
    ComposeCodeableConcept(xml, 'code', elem.codeList[i]);
  ComposePeriod(xml, 'period', elem.period);
  for i := 0 to elem.detailList.Count - 1 do
    ComposeResourceReference{Resource}(xml, 'detail', elem.detailList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCompositionEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCompositionEvent(jsn));
end;

function TFHIRJsonParser.ParseCompositionEvent(jsn : TJsonObject) : TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCodeableConcept);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseResourceReference{Resource});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCompositionEvent(json : TJSONWriter; name : string; elem : TFhirCompositionEvent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.codeList.Count > 0 then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.codeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposePeriod(json, 'period', elem.period); {a}
  if elem.detailList.Count > 0 then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeResourceReference{Resource}(json, '',elem.detailList[i]); {z - Resource(Any)}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseCompositionSection(element : IXmlDomElement; path : string) : TFhirCompositionSection;
var
  child : IXMLDOMElement;
begin
  result := TFhirCompositionSection.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'title') then
        result.title := ParseString(child, path+'/title') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseResourceReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'content') then
        result.content := ParseResourceReference{Resource}(child, path+'/content') {b}
      else if (child.baseName = 'section') then
        result.sectionList.Add(ParseCompositionSection(child, path+'/section'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCompositionSection(xml : TXmlBuilder; name : string; elem : TFhirCompositionSection);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'title', elem.title);
  ComposeCodeableConcept(xml, 'code', elem.code);
  ComposeResourceReference{Resource}(xml, 'subject', elem.subject);
  ComposeResourceReference{Resource}(xml, 'content', elem.content);
  for i := 0 to elem.sectionList.Count - 1 do
    ComposeCompositionSection(xml, 'section', elem.sectionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCompositionSection(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCompositionSection(jsn));
end;

function TFHIRJsonParser.ParseCompositionSection(jsn : TJsonObject) : TFhirCompositionSection;
begin
  result := TFhirCompositionSection.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('title') or jsn.has('_title') then
        result.title := ParseString(jsn['title'], jsn.vObj['_title']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('subject') then
        result.subject := ParseResourceReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('content') then
        result.content := ParseResourceReference{Resource}(jsn.vObj['content']);{q}
    if jsn.has('section') then
      iterateArray(jsn.vArr['section'], result.sectionList, parseCompositionSection);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCompositionSection(json : TJSONWriter; name : string; elem : TFhirCompositionSection);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'title', elem.title, false);
  ComposeStringProps(json, 'title', elem.title, false);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeResourceReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeResourceReference{Resource}(json, 'content', elem.content); {a}
  if elem.sectionList.Count > 0 then
  begin
    json.valueArray('section');
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(json, '',elem.sectionList[i]); {z - @Composition.section}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseComposition(element : IXmlDomElement; path : string) : TFhirComposition;
var
  child : IXMLDOMElement;
begin
  result := TFhirComposition.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'date') then
        result.date := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'class') then
        result.class_ := ParseCodeableConcept(child, path+'/class') {b}
      else if (child.baseName = 'title') then
        result.title := ParseString(child, path+'/title') {b}
      else if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirCompositionStatus, path+'/status', child)
      else if (child.baseName = 'confidentiality') then
        result.confidentiality := ParseCoding(child, path+'/confidentiality') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseResourceReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'author') then
        result.authorList.Add(ParseResourceReference{Resource}(child, path+'/author'))
      else if (child.baseName = 'attester') then
        result.attesterList.Add(ParseCompositionAttester(child, path+'/attester'))
      else if (child.baseName = 'custodian') then
        result.custodian := ParseResourceReference{TFhirOrganization}(child, path+'/custodian') {b}
      else if (child.baseName = 'event') then
        result.event := ParseCompositionEvent(child, path+'/event') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseResourceReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'section') then
        result.sectionList.Add(ParseCompositionSection(child, path+'/section'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeComposition(xml : TXmlBuilder; name : string; elem : TFhirComposition);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);
  ComposeDateTime(xml, 'date', elem.date);
  ComposeCodeableConcept(xml, 'type', elem.type_);
  ComposeCodeableConcept(xml, 'class', elem.class_);
  ComposeString(xml, 'title', elem.title);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirCompositionStatus);
  ComposeCoding(xml, 'confidentiality', elem.confidentiality);
  ComposeResourceReference{Resource}(xml, 'subject', elem.subject);
  for i := 0 to elem.authorList.Count - 1 do
    ComposeResourceReference{Resource}(xml, 'author', elem.authorList[i]);
  for i := 0 to elem.attesterList.Count - 1 do
    ComposeCompositionAttester(xml, 'attester', elem.attesterList[i]);
  ComposeResourceReference{TFhirOrganization}(xml, 'custodian', elem.custodian);
  ComposeCompositionEvent(xml, 'event', elem.event);
  ComposeResourceReference{TFhirEncounter}(xml, 'encounter', elem.encounter);
  if not SummaryOnly then
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(xml, 'section', elem.sectionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseComposition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseComposition(jsn));
end;

function TFHIRJsonParser.ParseComposition(jsn : TJsonObject) : TFhirComposition;
begin
  result := TFhirComposition.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.date := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('class') then
        result.class_ := ParseCodeableConcept(jsn.vObj['class']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.title := ParseString(jsn['title'], jsn.vObj['_title']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirCompositionStatus);
    if jsn.has('confidentiality') then
        result.confidentiality := ParseCoding(jsn.vObj['confidentiality']);{q}
    if jsn.has('subject') then
        result.subject := ParseResourceReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseResourceReference{Resource});
    if jsn.has('attester') then
      iterateArray(jsn.vArr['attester'], result.attesterList, parseCompositionAttester);
    if jsn.has('custodian') then
        result.custodian := ParseResourceReference{TFhirOrganization}(jsn.vObj['custodian']);{q}
    if jsn.has('event') then
        result.event := ParseCompositionEvent(jsn.vObj['event']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseResourceReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('section') then
      iterateArray(jsn.vArr['section'], result.sectionList, parseCompositionSection);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeComposition(json : TJSONWriter; name : string; elem : TFhirComposition);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeDateTimeValue(json, 'date', elem.date, false);
  ComposeDateTimeProps(json, 'date', elem.date, false);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeCodeableConcept(json, 'class', elem.class_); {a}
  ComposeStringValue(json, 'title', elem.title, false);
  ComposeStringProps(json, 'title', elem.title, false);
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirCompositionStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirCompositionStatus, false);
  ComposeCoding(json, 'confidentiality', elem.confidentiality); {a}
  ComposeResourceReference{Resource}(json, 'subject', elem.subject); {a}
  if elem.authorList.Count > 0 then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeResourceReference{Resource}(json, '',elem.authorList[i]); {z - Resource(Practitioner|Device|Patient|RelatedPerson)}
    json.FinishArray;
  end;
  if elem.attesterList.Count > 0 then
  begin
    json.valueArray('attester');
    for i := 0 to elem.attesterList.Count - 1 do
      ComposeCompositionAttester(json, '',elem.attesterList[i]); {z - }
    json.FinishArray;
  end;
  ComposeResourceReference{TFhirOrganization}(json, 'custodian', elem.custodian); {a}
  ComposeCompositionEvent(json, 'event', elem.event); {a}
  ComposeResourceReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if not SummaryOnly and (elem.sectionList.Count > 0) then
  begin
    json.valueArray('section');
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(json, '',elem.sectionList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseConceptMapConcept(element : IXmlDomElement; path : string) : TFhirConceptMapConcept;
var
  child : IXMLDOMElement;
begin
  result := TFhirConceptMapConcept.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'system') then
        result.system := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'dependsOn') then
        result.dependsOnList.Add(ParseConceptMapConceptDependsOn(child, path+'/dependsOn'))
      else if (child.baseName = 'map') then
        result.mapList.Add(ParseConceptMapConceptMap(child, path+'/map'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConceptMapConcept(xml : TXmlBuilder; name : string; elem : TFhirConceptMapConcept);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'system', elem.system);
  ComposeCode(xml, 'code', elem.code);
  for i := 0 to elem.dependsOnList.Count - 1 do
    ComposeConceptMapConceptDependsOn(xml, 'dependsOn', elem.dependsOnList[i]);
  for i := 0 to elem.mapList.Count - 1 do
    ComposeConceptMapConceptMap(xml, 'map', elem.mapList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConceptMapConcept(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMapConcept(jsn));
end;

function TFHIRJsonParser.ParseConceptMapConcept(jsn : TJsonObject) : TFhirConceptMapConcept;
begin
  result := TFhirConceptMapConcept.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system') then
        result.system := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.code := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('dependsOn') then
      iterateArray(jsn.vArr['dependsOn'], result.dependsOnList, parseConceptMapConceptDependsOn);
    if jsn.has('map') then
      iterateArray(jsn.vArr['map'], result.mapList, parseConceptMapConceptMap);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConceptMapConcept(json : TJSONWriter; name : string; elem : TFhirConceptMapConcept);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'system', elem.system, false);
  ComposeUriProps(json, 'system', elem.system, false);
  ComposeCodeValue(json, 'code', elem.code, false);
  ComposeCodeProps(json, 'code', elem.code, false);
  if elem.dependsOnList.Count > 0 then
  begin
    json.valueArray('dependsOn');
    for i := 0 to elem.dependsOnList.Count - 1 do
      ComposeConceptMapConceptDependsOn(json, '',elem.dependsOnList[i]); {z - }
    json.FinishArray;
  end;
  if elem.mapList.Count > 0 then
  begin
    json.valueArray('map');
    for i := 0 to elem.mapList.Count - 1 do
      ComposeConceptMapConceptMap(json, '',elem.mapList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseConceptMapConceptDependsOn(element : IXmlDomElement; path : string) : TFhirConceptMapConceptDependsOn;
var
  child : IXMLDOMElement;
begin
  result := TFhirConceptMapConceptDependsOn.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'concept') then
        result.concept := ParseUri(child, path+'/concept') {b}
      else if (child.baseName = 'system') then
        result.system := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCode(child, path+'/code') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConceptMapConceptDependsOn(xml : TXmlBuilder; name : string; elem : TFhirConceptMapConceptDependsOn);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'concept', elem.concept);
  ComposeUri(xml, 'system', elem.system);
  ComposeCode(xml, 'code', elem.code);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConceptMapConceptDependsOn(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMapConceptDependsOn(jsn));
end;

function TFHIRJsonParser.ParseConceptMapConceptDependsOn(jsn : TJsonObject) : TFhirConceptMapConceptDependsOn;
begin
  result := TFhirConceptMapConceptDependsOn.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('concept') or jsn.has('_concept') then
        result.concept := ParseUri(jsn['concept'], jsn.vObj['_concept']);{q}
    if jsn.has('system') or jsn.has('_system') then
        result.system := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.code := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConceptMapConceptDependsOn(json : TJSONWriter; name : string; elem : TFhirConceptMapConceptDependsOn);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'concept', elem.concept, false);
  ComposeUriProps(json, 'concept', elem.concept, false);
  ComposeUriValue(json, 'system', elem.system, false);
  ComposeUriProps(json, 'system', elem.system, false);
  ComposeCodeValue(json, 'code', elem.code, false);
  ComposeCodeProps(json, 'code', elem.code, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseConceptMapConceptMap(element : IXmlDomElement; path : string) : TFhirConceptMapConceptMap;
var
  child : IXMLDOMElement;
begin
  result := TFhirConceptMapConceptMap.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'system') then
        result.system := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'equivalence') then
        result.equivalence := ParseEnum(CODES_TFhirConceptEquivalence, path+'/equivalence', child)
      else if (child.baseName = 'comments') then
        result.comments := ParseString(child, path+'/comments') {b}
      else if (child.baseName = 'product') then
        result.productList.Add(ParseConceptMapConceptDependsOn(child, path+'/product'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConceptMapConceptMap(xml : TXmlBuilder; name : string; elem : TFhirConceptMapConceptMap);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'system', elem.system);
  ComposeCode(xml, 'code', elem.code);
  ComposeEnum(xml, 'equivalence', elem.Equivalence, CODES_TFhirConceptEquivalence);
  ComposeString(xml, 'comments', elem.comments);
  for i := 0 to elem.productList.Count - 1 do
    ComposeConceptMapConceptDependsOn(xml, 'product', elem.productList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConceptMapConceptMap(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMapConceptMap(jsn));
end;

function TFHIRJsonParser.ParseConceptMapConceptMap(jsn : TJsonObject) : TFhirConceptMapConceptMap;
begin
  result := TFhirConceptMapConceptMap.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system') then
        result.system := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.code := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('equivalence') or jsn.has('_equivalence')  then
      result.equivalence := parseEnum(jsn['equivalence'], jsn.vObj['_equivalence'], CODES_TFhirConceptEquivalence);
    if jsn.has('comments') or jsn.has('_comments') then
        result.comments := ParseString(jsn['comments'], jsn.vObj['_comments']);{q}
    if jsn.has('product') then
      iterateArray(jsn.vArr['product'], result.productList, parseConceptMapConceptDependsOn);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConceptMapConceptMap(json : TJSONWriter; name : string; elem : TFhirConceptMapConceptMap);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'system', elem.system, false);
  ComposeUriProps(json, 'system', elem.system, false);
  ComposeCodeValue(json, 'code', elem.code, false);
  ComposeCodeProps(json, 'code', elem.code, false);
  ComposeEnumValue(json, 'equivalence', elem.Equivalence, CODES_TFhirConceptEquivalence, false);
  ComposeEnumProps(json, 'equivalence', elem.Equivalence, CODES_TFhirConceptEquivalence, false);
  ComposeStringValue(json, 'comments', elem.comments, false);
  ComposeStringProps(json, 'comments', elem.comments, false);
  if elem.productList.Count > 0 then
  begin
    json.valueArray('product');
    for i := 0 to elem.productList.Count - 1 do
      ComposeConceptMapConceptDependsOn(json, '',elem.productList[i]); {z - @ConceptMap.concept.dependsOn}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseConceptMap(element : IXmlDomElement; path : string) : TFhirConceptMap;
var
  child : IXMLDOMElement;
begin
  result := TFhirConceptMap.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseString(child, path+'/identifier') {b}
      else if (child.baseName = 'version') then
        result.version := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'name') then
        result.name := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'publisher') then
        result.publisher := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContact(child, path+'/telecom'))
      else if (child.baseName = 'description') then
        result.description := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'copyright') then
        result.copyright := ParseString(child, path+'/copyright') {b}
      else if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirValuesetStatus, path+'/status', child)
      else if (child.baseName = 'experimental') then
        result.experimental := ParseBoolean(child, path+'/experimental') {b}
      else if (child.baseName = 'date') then
        result.date := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'source') then
        result.source := ParseResourceReference{TFhirValueSet}(child, path+'/source') {b}
      else if (child.baseName = 'target') then
        result.target := ParseResourceReference{TFhirValueSet}(child, path+'/target') {b}
      else if (child.baseName = 'concept') then
        result.conceptList.Add(ParseConceptMapConcept(child, path+'/concept'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConceptMap(xml : TXmlBuilder; name : string; elem : TFhirConceptMap);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeString(xml, 'identifier', elem.identifier);
  ComposeString(xml, 'version', elem.version);
  ComposeString(xml, 'name', elem.name);
  ComposeString(xml, 'publisher', elem.publisher);
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContact(xml, 'telecom', elem.telecomList[i]);
  ComposeString(xml, 'description', elem.description);
  if not SummaryOnly then
    ComposeString(xml, 'copyright', elem.copyright);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirValuesetStatus);
  ComposeBoolean(xml, 'experimental', elem.experimental);
  ComposeDateTime(xml, 'date', elem.date);
  ComposeResourceReference{TFhirValueSet}(xml, 'source', elem.source);
  ComposeResourceReference{TFhirValueSet}(xml, 'target', elem.target);
  if not SummaryOnly then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeConceptMapConcept(xml, 'concept', elem.conceptList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConceptMap(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMap(jsn));
end;

function TFHIRJsonParser.ParseConceptMap(jsn : TJsonObject) : TFhirConceptMap;
begin
  result := TFhirConceptMap.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifier := ParseString(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.version := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.name := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisher := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContact);
    if jsn.has('description') or jsn.has('_description') then
        result.description := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyright := ParseString(jsn['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirValuesetStatus);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimental := ParseBoolean(jsn['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.date := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('source') then
        result.source := ParseResourceReference{TFhirValueSet}(jsn.vObj['source']);{q}
    if jsn.has('target') then
        result.target := ParseResourceReference{TFhirValueSet}(jsn.vObj['target']);{q}
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseConceptMapConcept);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConceptMap(json : TJSONWriter; name : string; elem : TFhirConceptMap);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeStringValue(json, 'identifier', elem.identifier, false);
  ComposeStringProps(json, 'identifier', elem.identifier, false);
  ComposeStringValue(json, 'version', elem.version, false);
  ComposeStringProps(json, 'version', elem.version, false);
  ComposeStringValue(json, 'name', elem.name, false);
  ComposeStringProps(json, 'name', elem.name, false);
  ComposeStringValue(json, 'publisher', elem.publisher, false);
  ComposeStringProps(json, 'publisher', elem.publisher, false);
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContact(json, '',elem.telecomList[i]); {z - Contact}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.description, false);
  ComposeStringProps(json, 'description', elem.description, false);
  if not SummaryOnly then
    ComposeStringValue(json, 'copyright', elem.copyright, false);
  if not SummaryOnly then
    ComposeStringProps(json, 'copyright', elem.copyright, false);
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirValuesetStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirValuesetStatus, false);
  ComposeBooleanValue(json, 'experimental', elem.experimental, false);
  ComposeBooleanProps(json, 'experimental', elem.experimental, false);
  ComposeDateTimeValue(json, 'date', elem.date, false);
  ComposeDateTimeProps(json, 'date', elem.date, false);
  ComposeResourceReference{TFhirValueSet}(json, 'source', elem.source); {a}
  ComposeResourceReference{TFhirValueSet}(json, 'target', elem.target); {a}
  if not SummaryOnly and (elem.conceptList.Count > 0) then
  begin
    json.valueArray('concept');
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeConceptMapConcept(json, '',elem.conceptList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseConditionStage(element : IXmlDomElement; path : string) : TFhirConditionStage;
var
  child : IXMLDOMElement;
begin
  result := TFhirConditionStage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'summary') then
        result.summary := ParseCodeableConcept(child, path+'/summary') {b}
      else if (child.baseName = 'assessment') then
        result.assessmentList.Add(ParseResourceReference{Resource}(child, path+'/assessment'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConditionStage(xml : TXmlBuilder; name : string; elem : TFhirConditionStage);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'summary', elem.summary);
  for i := 0 to elem.assessmentList.Count - 1 do
    ComposeResourceReference{Resource}(xml, 'assessment', elem.assessmentList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConditionStage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConditionStage(jsn));
end;

function TFHIRJsonParser.ParseConditionStage(jsn : TJsonObject) : TFhirConditionStage;
begin
  result := TFhirConditionStage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('summary') then
        result.summary := ParseCodeableConcept(jsn.vObj['summary']);{q}
    if jsn.has('assessment') then
      iterateArray(jsn.vArr['assessment'], result.assessmentList, parseResourceReference{Resource});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConditionStage(json : TJSONWriter; name : string; elem : TFhirConditionStage);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'summary', elem.summary); {a}
  if elem.assessmentList.Count > 0 then
  begin
    json.valueArray('assessment');
    for i := 0 to elem.assessmentList.Count - 1 do
      ComposeResourceReference{Resource}(json, '',elem.assessmentList[i]); {z - Resource(Any)}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseConditionEvidence(element : IXmlDomElement; path : string) : TFhirConditionEvidence;
var
  child : IXMLDOMElement;
begin
  result := TFhirConditionEvidence.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'detail') then
        result.detailList.Add(ParseResourceReference{Resource}(child, path+'/detail'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConditionEvidence(xml : TXmlBuilder; name : string; elem : TFhirConditionEvidence);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);
  for i := 0 to elem.detailList.Count - 1 do
    ComposeResourceReference{Resource}(xml, 'detail', elem.detailList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConditionEvidence(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConditionEvidence(jsn));
end;

function TFHIRJsonParser.ParseConditionEvidence(jsn : TJsonObject) : TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseResourceReference{Resource});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConditionEvidence(json : TJSONWriter; name : string; elem : TFhirConditionEvidence);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if elem.detailList.Count > 0 then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeResourceReference{Resource}(json, '',elem.detailList[i]); {z - Resource(Any)}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseConditionLocation(element : IXmlDomElement; path : string) : TFhirConditionLocation;
var
  child : IXMLDOMElement;
begin
  result := TFhirConditionLocation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'detail') then
        result.detail := ParseString(child, path+'/detail') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConditionLocation(xml : TXmlBuilder; name : string; elem : TFhirConditionLocation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);
  ComposeString(xml, 'detail', elem.detail);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConditionLocation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConditionLocation(jsn));
end;

function TFHIRJsonParser.ParseConditionLocation(jsn : TJsonObject) : TFhirConditionLocation;
begin
  result := TFhirConditionLocation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('detail') or jsn.has('_detail') then
        result.detail := ParseString(jsn['detail'], jsn.vObj['_detail']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConditionLocation(json : TJSONWriter; name : string; elem : TFhirConditionLocation);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeStringValue(json, 'detail', elem.detail, false);
  ComposeStringProps(json, 'detail', elem.detail, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseConditionRelatedItem(element : IXmlDomElement; path : string) : TFhirConditionRelatedItem;
var
  child : IXMLDOMElement;
begin
  result := TFhirConditionRelatedItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseEnum(CODES_TFhirConditionRelationshipType, path+'/type', child)
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'target') then
        result.target := ParseResourceReference{Resource}(child, path+'/target') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConditionRelatedItem(xml : TXmlBuilder; name : string; elem : TFhirConditionRelatedItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_, CODES_TFhirConditionRelationshipType);
  ComposeCodeableConcept(xml, 'code', elem.code);
  ComposeResourceReference{Resource}(xml, 'target', elem.target);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConditionRelatedItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConditionRelatedItem(jsn));
end;

function TFHIRJsonParser.ParseConditionRelatedItem(jsn : TJsonObject) : TFhirConditionRelatedItem;
begin
  result := TFhirConditionRelatedItem.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_ := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirConditionRelationshipType);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('target') then
        result.target := ParseResourceReference{Resource}(jsn.vObj['target']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConditionRelatedItem(json : TJSONWriter; name : string; elem : TFhirConditionRelatedItem);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_, CODES_TFhirConditionRelationshipType, false);
  ComposeEnumProps(json, 'type', elem.Type_, CODES_TFhirConditionRelationshipType, false);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeResourceReference{Resource}(json, 'target', elem.target); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseCondition(element : IXmlDomElement; path : string) : TFhirCondition;
var
  child : IXMLDOMElement;
begin
  result := TFhirCondition.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'subject') then
        result.subject := ParseResourceReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseResourceReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'asserter') then
        result.asserter := ParseResourceReference{Resource}(child, path+'/asserter') {b}
      else if (child.baseName = 'dateAsserted') then
        result.dateAsserted := ParseDate(child, path+'/dateAsserted') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'category') then
        result.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirConditionStatus, path+'/status', child)
      else if (child.baseName = 'certainty') then
        result.certainty := ParseCodeableConcept(child, path+'/certainty') {b}
      else if (child.baseName = 'severity') then
        result.severity := ParseCodeableConcept(child, path+'/severity') {b}
      else if (child.baseName = 'onsetDate') then
        result.onset := ParseDate(child, path+'/onsetDate')
      else if (child.baseName = 'onsetAge') then
        result.onset := ParseAge(child, path+'/onsetAge')
      else if (child.baseName = 'abatementDate') then
        result.abatement := ParseDate(child, path+'/abatementDate')
      else if (child.baseName = 'abatementAge') then
        result.abatement := ParseAge(child, path+'/abatementAge')
      else if (child.baseName = 'abatementBoolean') then
        result.abatement := ParseBoolean(child, path+'/abatementBoolean')
      else if (child.baseName = 'stage') then
        result.stage := ParseConditionStage(child, path+'/stage') {b}
      else if (child.baseName = 'evidence') then
        result.evidenceList.Add(ParseConditionEvidence(child, path+'/evidence'))
      else if (child.baseName = 'location') then
        result.locationList.Add(ParseConditionLocation(child, path+'/location'))
      else if (child.baseName = 'relatedItem') then
        result.relatedItemList.Add(ParseConditionRelatedItem(child, path+'/relatedItem'))
      else if (child.baseName = 'notes') then
        result.notes := ParseString(child, path+'/notes') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeCondition(xml : TXmlBuilder; name : string; elem : TFhirCondition);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeResourceReference{TFhirPatient}(xml, 'subject', elem.subject);
  ComposeResourceReference{TFhirEncounter}(xml, 'encounter', elem.encounter);
  ComposeResourceReference{Resource}(xml, 'asserter', elem.asserter);
  ComposeDate(xml, 'dateAsserted', elem.dateAsserted);
  ComposeCodeableConcept(xml, 'code', elem.code);
  ComposeCodeableConcept(xml, 'category', elem.category);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirConditionStatus);
  ComposeCodeableConcept(xml, 'certainty', elem.certainty);
  ComposeCodeableConcept(xml, 'severity', elem.severity);
  if (elem.onset is TFhirDate) {6} then
    ComposeDate(xml, 'onsetDate', TFhirDate(elem.onset))
  else if (elem.onset is TFhirQuantity) {6} then
    ComposeAge(xml, 'onsetAge', TFhirQuantity(elem.onset));
  if (elem.abatement is TFhirDate) {6} then
    ComposeDate(xml, 'abatementDate', TFhirDate(elem.abatement))
  else if (elem.abatement is TFhirQuantity) {6} then
    ComposeAge(xml, 'abatementAge', TFhirQuantity(elem.abatement))
  else if (elem.abatement is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'abatementBoolean', TFhirBoolean(elem.abatement));
  ComposeConditionStage(xml, 'stage', elem.stage);
  for i := 0 to elem.evidenceList.Count - 1 do
    ComposeConditionEvidence(xml, 'evidence', elem.evidenceList[i]);
  for i := 0 to elem.locationList.Count - 1 do
    ComposeConditionLocation(xml, 'location', elem.locationList[i]);
  for i := 0 to elem.relatedItemList.Count - 1 do
    ComposeConditionRelatedItem(xml, 'relatedItem', elem.relatedItemList[i]);
  ComposeString(xml, 'notes', elem.notes);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseCondition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCondition(jsn));
end;

function TFHIRJsonParser.ParseCondition(jsn : TJsonObject) : TFhirCondition;
begin
  result := TFhirCondition.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseResourceReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseResourceReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('asserter') then
        result.asserter := ParseResourceReference{Resource}(jsn.vObj['asserter']);{q}
    if jsn.has('dateAsserted') or jsn.has('_dateAsserted') then
        result.dateAsserted := ParseDate(jsn['dateAsserted'], jsn.vObj['_dateAsserted']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirConditionStatus);
    if jsn.has('certainty') then
        result.certainty := ParseCodeableConcept(jsn.vObj['certainty']);{q}
    if jsn.has('severity') then
        result.severity := ParseCodeableConcept(jsn.vObj['severity']);{q}
    if jsn.has('onsetDate') or jsn.has('_onsetDate') then
      result.onset := parseDate(jsn['onsetDate'], jsn.vObj['_onsetDate']);
    if jsn.has('onsetAge') {a4} then
      result.onset := ParseAge(jsn.vObj['onsetAge']);
    if jsn.has('abatementDate') or jsn.has('_abatementDate') then
      result.abatement := parseDate(jsn['abatementDate'], jsn.vObj['_abatementDate']);
    if jsn.has('abatementAge') {a4} then
      result.abatement := ParseAge(jsn.vObj['abatementAge']);
    if jsn.has('abatementBoolean') or jsn.has('_abatementBoolean') then
      result.abatement := parseBoolean(jsn['abatementBoolean'], jsn.vObj['_abatementBoolean']);
    if jsn.has('stage') then
        result.stage := ParseConditionStage(jsn.vObj['stage']);{q}
    if jsn.has('evidence') then
      iterateArray(jsn.vArr['evidence'], result.evidenceList, parseConditionEvidence);
    if jsn.has('location') then
      iterateArray(jsn.vArr['location'], result.locationList, parseConditionLocation);
    if jsn.has('relatedItem') then
      iterateArray(jsn.vArr['relatedItem'], result.relatedItemList, parseConditionRelatedItem);
    if jsn.has('notes') or jsn.has('_notes') then
        result.notes := ParseString(jsn['notes'], jsn.vObj['_notes']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeCondition(json : TJSONWriter; name : string; elem : TFhirCondition);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeResourceReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  ComposeResourceReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  ComposeResourceReference{Resource}(json, 'asserter', elem.asserter); {a}
  ComposeDateValue(json, 'dateAsserted', elem.dateAsserted, false);
  ComposeDateProps(json, 'dateAsserted', elem.dateAsserted, false);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirConditionStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirConditionStatus, false);
  ComposeCodeableConcept(json, 'certainty', elem.certainty); {a}
  ComposeCodeableConcept(json, 'severity', elem.severity); {a}
  if (elem.onset is TFhirDate) then 
  begin
    ComposeDateValue(json, 'onsetDate', TFhirDate(elem.onset), false);
    ComposeDateProps(json, 'onsetDate', TFhirDate(elem.onset), false);
  end
  else if (elem.onset is TFhirQuantity) then 
    ComposeAge(json, 'onsetAge', TFhirQuantity(elem.onset)) ;
  if (elem.abatement is TFhirDate) then 
  begin
    ComposeDateValue(json, 'abatementDate', TFhirDate(elem.abatement), false);
    ComposeDateProps(json, 'abatementDate', TFhirDate(elem.abatement), false);
  end
  else if (elem.abatement is TFhirQuantity) then 
    ComposeAge(json, 'abatementAge', TFhirQuantity(elem.abatement)) 
  else if (elem.abatement is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'abatementBoolean', TFhirBoolean(elem.abatement), false);
    ComposeBooleanProps(json, 'abatementBoolean', TFhirBoolean(elem.abatement), false);
  end;
  ComposeConditionStage(json, 'stage', elem.stage); {a}
  if elem.evidenceList.Count > 0 then
  begin
    json.valueArray('evidence');
    for i := 0 to elem.evidenceList.Count - 1 do
      ComposeConditionEvidence(json, '',elem.evidenceList[i]); {z - }
    json.FinishArray;
  end;
  if elem.locationList.Count > 0 then
  begin
    json.valueArray('location');
    for i := 0 to elem.locationList.Count - 1 do
      ComposeConditionLocation(json, '',elem.locationList[i]); {z - }
    json.FinishArray;
  end;
  if elem.relatedItemList.Count > 0 then
  begin
    json.valueArray('relatedItem');
    for i := 0 to elem.relatedItemList.Count - 1 do
      ComposeConditionRelatedItem(json, '',elem.relatedItemList[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'notes', elem.notes, false);
  ComposeStringProps(json, 'notes', elem.notes, false);
end;

function TFHIRXmlParser.ParseConformanceSoftware(element : IXmlDomElement; path : string) : TFhirConformanceSoftware;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceSoftware.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.name := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'version') then
        result.version := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'releaseDate') then
        result.releaseDate := ParseDateTime(child, path+'/releaseDate') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceSoftware(xml : TXmlBuilder; name : string; elem : TFhirConformanceSoftware);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.name);
  ComposeString(xml, 'version', elem.version);
  ComposeDateTime(xml, 'releaseDate', elem.releaseDate);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceSoftware(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceSoftware(jsn));
end;

function TFHIRJsonParser.ParseConformanceSoftware(jsn : TJsonObject) : TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.name := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.version := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('releaseDate') or jsn.has('_releaseDate') then
        result.releaseDate := ParseDateTime(jsn['releaseDate'], jsn.vObj['_releaseDate']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceSoftware(json : TJSONWriter; name : string; elem : TFhirConformanceSoftware);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.name, false);
  ComposeStringProps(json, 'name', elem.name, false);
  ComposeStringValue(json, 'version', elem.version, false);
  ComposeStringProps(json, 'version', elem.version, false);
  ComposeDateTimeValue(json, 'releaseDate', elem.releaseDate, false);
  ComposeDateTimeProps(json, 'releaseDate', elem.releaseDate, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceImplementation(element : IXmlDomElement; path : string) : TFhirConformanceImplementation;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceImplementation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'description') then
        result.description := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'url') then
        result.url := ParseUri(child, path+'/url') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceImplementation(xml : TXmlBuilder; name : string; elem : TFhirConformanceImplementation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'description', elem.description);
  ComposeUri(xml, 'url', elem.url);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceImplementation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceImplementation(jsn));
end;

function TFHIRJsonParser.ParseConformanceImplementation(jsn : TJsonObject) : TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.description := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.url := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceImplementation(json : TJSONWriter; name : string; elem : TFhirConformanceImplementation);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'description', elem.description, false);
  ComposeStringProps(json, 'description', elem.description, false);
  ComposeUriValue(json, 'url', elem.url, false);
  ComposeUriProps(json, 'url', elem.url, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceRest(element : IXmlDomElement; path : string) : TFhirConformanceRest;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRest.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'mode') then
        result.mode := ParseEnum(CODES_TFhirRestfulConformanceMode, path+'/mode', child)
      else if (child.baseName = 'documentation') then
        result.documentation := ParseString(child, path+'/documentation') {b}
      else if (child.baseName = 'security') then
        result.security := ParseConformanceRestSecurity(child, path+'/security') {b}
      else if (child.baseName = 'resource') then
        result.resourceList.Add(ParseConformanceRestResource(child, path+'/resource'))
      else if (child.baseName = 'operation') then
        result.operationList.Add(ParseConformanceRestOperation(child, path+'/operation'))
      else if (child.baseName = 'query') then
        result.queryList.Add(ParseConformanceRestQuery(child, path+'/query'))
      else if (child.baseName = 'documentMailbox') then
        result.documentMailboxList.Add(ParseUri(child, path+'/documentMailbox'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRest(xml : TXmlBuilder; name : string; elem : TFhirConformanceRest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'mode', elem.Mode, CODES_TFhirRestfulConformanceMode);
  ComposeString(xml, 'documentation', elem.documentation);
  ComposeConformanceRestSecurity(xml, 'security', elem.security);
  for i := 0 to elem.resourceList.Count - 1 do
    ComposeConformanceRestResource(xml, 'resource', elem.resourceList[i]);
  for i := 0 to elem.operationList.Count - 1 do
    ComposeConformanceRestOperation(xml, 'operation', elem.operationList[i]);
  for i := 0 to elem.queryList.Count - 1 do
    ComposeConformanceRestQuery(xml, 'query', elem.queryList[i]);
  for i := 0 to elem.documentMailboxList.Count - 1 do
    ComposeUri(xml, 'documentMailbox', elem.documentMailboxList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRest(jsn));
end;

function TFHIRJsonParser.ParseConformanceRest(jsn : TJsonObject) : TFhirConformanceRest;
begin
  result := TFhirConformanceRest.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('mode') or jsn.has('_mode')  then
      result.mode := parseEnum(jsn['mode'], jsn.vObj['_mode'], CODES_TFhirRestfulConformanceMode);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentation := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('security') then
        result.security := ParseConformanceRestSecurity(jsn.vObj['security']);{q}
    if jsn.has('resource') then
      iterateArray(jsn.vArr['resource'], result.resourceList, parseConformanceRestResource);
    if jsn.has('operation') then
      iterateArray(jsn.vArr['operation'], result.operationList, parseConformanceRestOperation);
    if jsn.has('query') then
      iterateArray(jsn.vArr['query'], result.queryList, parseConformanceRestQuery);
      if jsn.has('documentMailbox') or jsn.has('_documentMailbox') then
      iteratePrimitiveArray(jsn.vArr['documentMailbox'], jsn.vArr['_documentMailbox'], result.documentMailboxList, parseUri);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRest(json : TJSONWriter; name : string; elem : TFhirConformanceRest);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'mode', elem.Mode, CODES_TFhirRestfulConformanceMode, false);
  ComposeEnumProps(json, 'mode', elem.Mode, CODES_TFhirRestfulConformanceMode, false);
  ComposeStringValue(json, 'documentation', elem.documentation, false);
  ComposeStringProps(json, 'documentation', elem.documentation, false);
  ComposeConformanceRestSecurity(json, 'security', elem.security); {a}
  if elem.resourceList.Count > 0 then
  begin
    json.valueArray('resource');
    for i := 0 to elem.resourceList.Count - 1 do
      ComposeConformanceRestResource(json, '',elem.resourceList[i]); {z - }
    json.FinishArray;
  end;
  if elem.operationList.Count > 0 then
  begin
    json.valueArray('operation');
    for i := 0 to elem.operationList.Count - 1 do
      ComposeConformanceRestOperation(json, '',elem.operationList[i]); {z - }
    json.FinishArray;
  end;
  if elem.queryList.Count > 0 then
  begin
    json.valueArray('query');
    for i := 0 to elem.queryList.Count - 1 do
      ComposeConformanceRestQuery(json, '',elem.queryList[i]); {z - }
    json.FinishArray;
  end;
  if elem.documentMailboxList.Count > 0 then
  begin
    json.valueArray('documentMailbox');
    ext := false;
    for i := 0 to elem.documentMailboxList.Count - 1 do
    begin
      ext := ext or ((elem.documentMailboxList[i].xmlid <> '') or (elem.documentMailboxList[i].hasExtensions));
      ComposeUriValue(json, '',elem.documentMailboxList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_documentMailbox');
      for i := 0 to elem.documentMailboxList.Count - 1 do
        ComposeUriProps(json, '',elem.documentMailboxList[i], true);
      json.FinishArray;
    end;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceRestSecurity(element : IXmlDomElement; path : string) : TFhirConformanceRestSecurity;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestSecurity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'cors') then
        result.cors := ParseBoolean(child, path+'/cors') {b}
      else if (child.baseName = 'service') then
        result.serviceList.Add(ParseCodeableConcept(child, path+'/service'))
      else if (child.baseName = 'description') then
        result.description := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'certificate') then
        result.certificateList.Add(ParseConformanceRestSecurityCertificate(child, path+'/certificate'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestSecurity(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestSecurity);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeBoolean(xml, 'cors', elem.cors);
  for i := 0 to elem.serviceList.Count - 1 do
    ComposeCodeableConcept(xml, 'service', elem.serviceList[i]);
  ComposeString(xml, 'description', elem.description);
  for i := 0 to elem.certificateList.Count - 1 do
    ComposeConformanceRestSecurityCertificate(xml, 'certificate', elem.certificateList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestSecurity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestSecurity(jsn));
end;

function TFHIRJsonParser.ParseConformanceRestSecurity(jsn : TJsonObject) : TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('cors') or jsn.has('_cors') then
        result.cors := ParseBoolean(jsn['cors'], jsn.vObj['_cors']);{q}
    if jsn.has('service') then
      iterateArray(jsn.vArr['service'], result.serviceList, parseCodeableConcept);
    if jsn.has('description') or jsn.has('_description') then
        result.description := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('certificate') then
      iterateArray(jsn.vArr['certificate'], result.certificateList, parseConformanceRestSecurityCertificate);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestSecurity(json : TJSONWriter; name : string; elem : TFhirConformanceRestSecurity);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeBooleanValue(json, 'cors', elem.cors, false);
  ComposeBooleanProps(json, 'cors', elem.cors, false);
  if elem.serviceList.Count > 0 then
  begin
    json.valueArray('service');
    for i := 0 to elem.serviceList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.serviceList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.description, false);
  ComposeStringProps(json, 'description', elem.description, false);
  if elem.certificateList.Count > 0 then
  begin
    json.valueArray('certificate');
    for i := 0 to elem.certificateList.Count - 1 do
      ComposeConformanceRestSecurityCertificate(json, '',elem.certificateList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceRestSecurityCertificate(element : IXmlDomElement; path : string) : TFhirConformanceRestSecurityCertificate;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestSecurityCertificate.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCode(child, path+'/type') {b}
      else if (child.baseName = 'blob') then
        result.blob := ParseBase64Binary(child, path+'/blob') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestSecurityCertificate(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestSecurityCertificate);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'type', elem.type_);
  ComposeBase64Binary(xml, 'blob', elem.blob);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestSecurityCertificate(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestSecurityCertificate(jsn));
end;

function TFHIRJsonParser.ParseConformanceRestSecurityCertificate(jsn : TJsonObject) : TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type') then
        result.type_ := ParseCode(jsn['type'], jsn.vObj['_type']);{q}
    if jsn.has('blob') or jsn.has('_blob') then
        result.blob := ParseBase64Binary(jsn['blob'], jsn.vObj['_blob']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestSecurityCertificate(json : TJSONWriter; name : string; elem : TFhirConformanceRestSecurityCertificate);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'type', elem.type_, false);
  ComposeCodeProps(json, 'type', elem.type_, false);
  ComposeBase64BinaryValue(json, 'blob', elem.blob, false);
  ComposeBase64BinaryProps(json, 'blob', elem.blob, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceRestResource(element : IXmlDomElement; path : string) : TFhirConformanceRestResource;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestResource.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCode(child, path+'/type') {b}
      else if (child.baseName = 'profile') then
        result.profile := ParseResourceReference{TFhirProfile}(child, path+'/profile') {b}
      else if (child.baseName = 'operation') then
        result.operationList.Add(ParseConformanceRestResourceOperation(child, path+'/operation'))
      else if (child.baseName = 'readHistory') then
        result.readHistory := ParseBoolean(child, path+'/readHistory') {b}
      else if (child.baseName = 'updateCreate') then
        result.updateCreate := ParseBoolean(child, path+'/updateCreate') {b}
      else if (child.baseName = 'searchInclude') then
        result.searchIncludeList.Add(ParseString(child, path+'/searchInclude'))
      else if (child.baseName = 'searchParam') then
        result.searchParamList.Add(ParseConformanceRestResourceSearchParam(child, path+'/searchParam'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestResource(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResource);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'type', elem.type_);
  ComposeResourceReference{TFhirProfile}(xml, 'profile', elem.profile);
  for i := 0 to elem.operationList.Count - 1 do
    ComposeConformanceRestResourceOperation(xml, 'operation', elem.operationList[i]);
  ComposeBoolean(xml, 'readHistory', elem.readHistory);
  ComposeBoolean(xml, 'updateCreate', elem.updateCreate);
  for i := 0 to elem.searchIncludeList.Count - 1 do
    ComposeString(xml, 'searchInclude', elem.searchIncludeList[i]);
  for i := 0 to elem.searchParamList.Count - 1 do
    ComposeConformanceRestResourceSearchParam(xml, 'searchParam', elem.searchParamList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestResource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestResource(jsn));
end;

function TFHIRJsonParser.ParseConformanceRestResource(jsn : TJsonObject) : TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type') then
        result.type_ := ParseCode(jsn['type'], jsn.vObj['_type']);{q}
    if jsn.has('profile') then
        result.profile := ParseResourceReference{TFhirProfile}(jsn.vObj['profile']);{q}
    if jsn.has('operation') then
      iterateArray(jsn.vArr['operation'], result.operationList, parseConformanceRestResourceOperation);
    if jsn.has('readHistory') or jsn.has('_readHistory') then
        result.readHistory := ParseBoolean(jsn['readHistory'], jsn.vObj['_readHistory']);{q}
    if jsn.has('updateCreate') or jsn.has('_updateCreate') then
        result.updateCreate := ParseBoolean(jsn['updateCreate'], jsn.vObj['_updateCreate']);{q}
      if jsn.has('searchInclude') or jsn.has('_searchInclude') then
      iteratePrimitiveArray(jsn.vArr['searchInclude'], jsn.vArr['_searchInclude'], result.searchIncludeList, parseString);
    if jsn.has('searchParam') then
      iterateArray(jsn.vArr['searchParam'], result.searchParamList, parseConformanceRestResourceSearchParam);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestResource(json : TJSONWriter; name : string; elem : TFhirConformanceRestResource);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'type', elem.type_, false);
  ComposeCodeProps(json, 'type', elem.type_, false);
  ComposeResourceReference{TFhirProfile}(json, 'profile', elem.profile); {a}
  if elem.operationList.Count > 0 then
  begin
    json.valueArray('operation');
    for i := 0 to elem.operationList.Count - 1 do
      ComposeConformanceRestResourceOperation(json, '',elem.operationList[i]); {z - }
    json.FinishArray;
  end;
  ComposeBooleanValue(json, 'readHistory', elem.readHistory, false);
  ComposeBooleanProps(json, 'readHistory', elem.readHistory, false);
  ComposeBooleanValue(json, 'updateCreate', elem.updateCreate, false);
  ComposeBooleanProps(json, 'updateCreate', elem.updateCreate, false);
  if elem.searchIncludeList.Count > 0 then
  begin
    json.valueArray('searchInclude');
    ext := false;
    for i := 0 to elem.searchIncludeList.Count - 1 do
    begin
      ext := ext or ((elem.searchIncludeList[i].xmlid <> '') or (elem.searchIncludeList[i].hasExtensions));
      ComposeStringValue(json, '',elem.searchIncludeList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_searchInclude');
      for i := 0 to elem.searchIncludeList.Count - 1 do
        ComposeStringProps(json, '',elem.searchIncludeList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.searchParamList.Count > 0 then
  begin
    json.valueArray('searchParam');
    for i := 0 to elem.searchParamList.Count - 1 do
      ComposeConformanceRestResourceSearchParam(json, '',elem.searchParamList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceRestResourceOperation(element : IXmlDomElement; path : string) : TFhirConformanceRestResourceOperation;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestResourceOperation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseEnum(CODES_TFhirTypeRestfulOperation, path+'/code', child)
      else if (child.baseName = 'documentation') then
        result.documentation := ParseString(child, path+'/documentation') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestResourceOperation(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResourceOperation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'code', elem.Code, CODES_TFhirTypeRestfulOperation);
  ComposeString(xml, 'documentation', elem.documentation);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestResourceOperation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestResourceOperation(jsn));
end;

function TFHIRJsonParser.ParseConformanceRestResourceOperation(jsn : TJsonObject) : TFhirConformanceRestResourceOperation;
begin
  result := TFhirConformanceRestResourceOperation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code')  then
      result.code := parseEnum(jsn['code'], jsn.vObj['_code'], CODES_TFhirTypeRestfulOperation);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentation := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestResourceOperation(json : TJSONWriter; name : string; elem : TFhirConformanceRestResourceOperation);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'code', elem.Code, CODES_TFhirTypeRestfulOperation, false);
  ComposeEnumProps(json, 'code', elem.Code, CODES_TFhirTypeRestfulOperation, false);
  ComposeStringValue(json, 'documentation', elem.documentation, false);
  ComposeStringProps(json, 'documentation', elem.documentation, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceRestResourceSearchParam(element : IXmlDomElement; path : string) : TFhirConformanceRestResourceSearchParam;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestResourceSearchParam.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.name := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'definition') then
        result.definition := ParseUri(child, path+'/definition') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseEnum(CODES_TFhirSearchParamType, path+'/type', child)
      else if (child.baseName = 'documentation') then
        result.documentation := ParseString(child, path+'/documentation') {b}
      else if (child.baseName = 'target') then
        result.targetList.Add(ParseCode(child, path+'/target'))
      else if (child.baseName = 'chain') then
        result.chainList.Add(ParseString(child, path+'/chain'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestResourceSearchParam(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResourceSearchParam);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.name);
  ComposeUri(xml, 'definition', elem.definition);
  ComposeEnum(xml, 'type', elem.Type_, CODES_TFhirSearchParamType);
  ComposeString(xml, 'documentation', elem.documentation);
  for i := 0 to elem.targetList.Count - 1 do
    ComposeCode(xml, 'target', elem.targetList[i]);
  for i := 0 to elem.chainList.Count - 1 do
    ComposeString(xml, 'chain', elem.chainList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestResourceSearchParam(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestResourceSearchParam(jsn));
end;

function TFHIRJsonParser.ParseConformanceRestResourceSearchParam(jsn : TJsonObject) : TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.name := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('definition') or jsn.has('_definition') then
        result.definition := ParseUri(jsn['definition'], jsn.vObj['_definition']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_ := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirSearchParamType);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentation := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
      if jsn.has('target') or jsn.has('_target') then
      iteratePrimitiveArray(jsn.vArr['target'], jsn.vArr['_target'], result.targetList, parseCode);
      if jsn.has('chain') or jsn.has('_chain') then
      iteratePrimitiveArray(jsn.vArr['chain'], jsn.vArr['_chain'], result.chainList, parseString);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestResourceSearchParam(json : TJSONWriter; name : string; elem : TFhirConformanceRestResourceSearchParam);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.name, false);
  ComposeStringProps(json, 'name', elem.name, false);
  ComposeUriValue(json, 'definition', elem.definition, false);
  ComposeUriProps(json, 'definition', elem.definition, false);
  ComposeEnumValue(json, 'type', elem.Type_, CODES_TFhirSearchParamType, false);
  ComposeEnumProps(json, 'type', elem.Type_, CODES_TFhirSearchParamType, false);
  ComposeStringValue(json, 'documentation', elem.documentation, false);
  ComposeStringProps(json, 'documentation', elem.documentation, false);
  if elem.targetList.Count > 0 then
  begin
    json.valueArray('target');
    ext := false;
    for i := 0 to elem.targetList.Count - 1 do
    begin
      ext := ext or ((elem.targetList[i].xmlid <> '') or (elem.targetList[i].hasExtensions));
      ComposeCodeValue(json, '',elem.targetList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_target');
      for i := 0 to elem.targetList.Count - 1 do
        ComposeCodeProps(json, '',elem.targetList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.chainList.Count > 0 then
  begin
    json.valueArray('chain');
    ext := false;
    for i := 0 to elem.chainList.Count - 1 do
    begin
      ext := ext or ((elem.chainList[i].xmlid <> '') or (elem.chainList[i].hasExtensions));
      ComposeStringValue(json, '',elem.chainList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_chain');
      for i := 0 to elem.chainList.Count - 1 do
        ComposeStringProps(json, '',elem.chainList[i], true);
      json.FinishArray;
    end;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceRestOperation(element : IXmlDomElement; path : string) : TFhirConformanceRestOperation;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestOperation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseEnum(CODES_TFhirSystemRestfulOperation, path+'/code', child)
      else if (child.baseName = 'documentation') then
        result.documentation := ParseString(child, path+'/documentation') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestOperation(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestOperation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'code', elem.Code, CODES_TFhirSystemRestfulOperation);
  ComposeString(xml, 'documentation', elem.documentation);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestOperation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestOperation(jsn));
end;

function TFHIRJsonParser.ParseConformanceRestOperation(jsn : TJsonObject) : TFhirConformanceRestOperation;
begin
  result := TFhirConformanceRestOperation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code')  then
      result.code := parseEnum(jsn['code'], jsn.vObj['_code'], CODES_TFhirSystemRestfulOperation);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentation := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestOperation(json : TJSONWriter; name : string; elem : TFhirConformanceRestOperation);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'code', elem.Code, CODES_TFhirSystemRestfulOperation, false);
  ComposeEnumProps(json, 'code', elem.Code, CODES_TFhirSystemRestfulOperation, false);
  ComposeStringValue(json, 'documentation', elem.documentation, false);
  ComposeStringProps(json, 'documentation', elem.documentation, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceRestQuery(element : IXmlDomElement; path : string) : TFhirConformanceRestQuery;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceRestQuery.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.name := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'definition') then
        result.definition := ParseUri(child, path+'/definition') {b}
      else if (child.baseName = 'documentation') then
        result.documentation := ParseString(child, path+'/documentation') {b}
      else if (child.baseName = 'parameter') then
        result.parameterList.Add(ParseConformanceRestResourceSearchParam(child, path+'/parameter'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestQuery(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestQuery);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.name);
  ComposeUri(xml, 'definition', elem.definition);
  ComposeString(xml, 'documentation', elem.documentation);
  for i := 0 to elem.parameterList.Count - 1 do
    ComposeConformanceRestResourceSearchParam(xml, 'parameter', elem.parameterList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceRestQuery(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestQuery(jsn));
end;

function TFHIRJsonParser.ParseConformanceRestQuery(jsn : TJsonObject) : TFhirConformanceRestQuery;
begin
  result := TFhirConformanceRestQuery.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.name := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('definition') or jsn.has('_definition') then
        result.definition := ParseUri(jsn['definition'], jsn.vObj['_definition']);{q}
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentation := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseConformanceRestResourceSearchParam);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceRestQuery(json : TJSONWriter; name : string; elem : TFhirConformanceRestQuery);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.name, false);
  ComposeStringProps(json, 'name', elem.name, false);
  ComposeUriValue(json, 'definition', elem.definition, false);
  ComposeUriProps(json, 'definition', elem.definition, false);
  ComposeStringValue(json, 'documentation', elem.documentation, false);
  ComposeStringProps(json, 'documentation', elem.documentation, false);
  if elem.parameterList.Count > 0 then
  begin
    json.valueArray('parameter');
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeConformanceRestResourceSearchParam(json, '',elem.parameterList[i]); {z - @Conformance.rest.resource.searchParam}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceMessaging(element : IXmlDomElement; path : string) : TFhirConformanceMessaging;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceMessaging.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'endpoint') then
        result.endpoint := ParseUri(child, path+'/endpoint') {b}
      else if (child.baseName = 'reliableCache') then
        result.reliableCache := ParseInteger(child, path+'/reliableCache') {b}
      else if (child.baseName = 'documentation') then
        result.documentation := ParseString(child, path+'/documentation') {b}
      else if (child.baseName = 'event') then
        result.eventList.Add(ParseConformanceMessagingEvent(child, path+'/event'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceMessaging(xml : TXmlBuilder; name : string; elem : TFhirConformanceMessaging);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'endpoint', elem.endpoint);
  ComposeInteger(xml, 'reliableCache', elem.reliableCache);
  ComposeString(xml, 'documentation', elem.documentation);
  for i := 0 to elem.eventList.Count - 1 do
    ComposeConformanceMessagingEvent(xml, 'event', elem.eventList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceMessaging(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceMessaging(jsn));
end;

function TFHIRJsonParser.ParseConformanceMessaging(jsn : TJsonObject) : TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('endpoint') or jsn.has('_endpoint') then
        result.endpoint := ParseUri(jsn['endpoint'], jsn.vObj['_endpoint']);{q}
    if jsn.has('reliableCache') or jsn.has('_reliableCache') then
        result.reliableCache := ParseInteger(jsn['reliableCache'], jsn.vObj['_reliableCache']);{q}
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentation := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseConformanceMessagingEvent);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceMessaging(json : TJSONWriter; name : string; elem : TFhirConformanceMessaging);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'endpoint', elem.endpoint, false);
  ComposeUriProps(json, 'endpoint', elem.endpoint, false);
  ComposeIntegerValue(json, 'reliableCache', elem.reliableCache, false);
  ComposeIntegerProps(json, 'reliableCache', elem.reliableCache, false);
  ComposeStringValue(json, 'documentation', elem.documentation, false);
  ComposeStringProps(json, 'documentation', elem.documentation, false);
  if elem.eventList.Count > 0 then
  begin
    json.valueArray('event');
    for i := 0 to elem.eventList.Count - 1 do
      ComposeConformanceMessagingEvent(json, '',elem.eventList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceMessagingEvent(element : IXmlDomElement; path : string) : TFhirConformanceMessagingEvent;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceMessagingEvent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCoding(child, path+'/code') {b}
      else if (child.baseName = 'category') then
        result.category := ParseEnum(CODES_TFhirMessageSignificanceCategory, path+'/category', child)
      else if (child.baseName = 'mode') then
        result.mode := ParseEnum(CODES_TFhirMessageConformanceEventMode, path+'/mode', child)
      else if (child.baseName = 'protocol') then
        result.protocolList.Add(ParseCoding(child, path+'/protocol'))
      else if (child.baseName = 'focus') then
        result.focus := ParseCode(child, path+'/focus') {b}
      else if (child.baseName = 'request') then
        result.request := ParseResourceReference{TFhirProfile}(child, path+'/request') {b}
      else if (child.baseName = 'response') then
        result.response := ParseResourceReference{TFhirProfile}(child, path+'/response') {b}
      else if (child.baseName = 'documentation') then
        result.documentation := ParseString(child, path+'/documentation') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceMessagingEvent(xml : TXmlBuilder; name : string; elem : TFhirConformanceMessagingEvent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'code', elem.code);
  ComposeEnum(xml, 'category', elem.Category, CODES_TFhirMessageSignificanceCategory);
  ComposeEnum(xml, 'mode', elem.Mode, CODES_TFhirMessageConformanceEventMode);
  for i := 0 to elem.protocolList.Count - 1 do
    ComposeCoding(xml, 'protocol', elem.protocolList[i]);
  ComposeCode(xml, 'focus', elem.focus);
  ComposeResourceReference{TFhirProfile}(xml, 'request', elem.request);
  ComposeResourceReference{TFhirProfile}(xml, 'response', elem.response);
  ComposeString(xml, 'documentation', elem.documentation);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceMessagingEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceMessagingEvent(jsn));
end;

function TFHIRJsonParser.ParseConformanceMessagingEvent(jsn : TJsonObject) : TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCoding(jsn.vObj['code']);{q}
    if jsn.has('category') or jsn.has('_category')  then
      result.category := parseEnum(jsn['category'], jsn.vObj['_category'], CODES_TFhirMessageSignificanceCategory);
    if jsn.has('mode') or jsn.has('_mode')  then
      result.mode := parseEnum(jsn['mode'], jsn.vObj['_mode'], CODES_TFhirMessageConformanceEventMode);
    if jsn.has('protocol') then
      iterateArray(jsn.vArr['protocol'], result.protocolList, parseCoding);
    if jsn.has('focus') or jsn.has('_focus') then
        result.focus := ParseCode(jsn['focus'], jsn.vObj['_focus']);{q}
    if jsn.has('request') then
        result.request := ParseResourceReference{TFhirProfile}(jsn.vObj['request']);{q}
    if jsn.has('response') then
        result.response := ParseResourceReference{TFhirProfile}(jsn.vObj['response']);{q}
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentation := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceMessagingEvent(json : TJSONWriter; name : string; elem : TFhirConformanceMessagingEvent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'code', elem.code); {a}
  ComposeEnumValue(json, 'category', elem.Category, CODES_TFhirMessageSignificanceCategory, false);
  ComposeEnumProps(json, 'category', elem.Category, CODES_TFhirMessageSignificanceCategory, false);
  ComposeEnumValue(json, 'mode', elem.Mode, CODES_TFhirMessageConformanceEventMode, false);
  ComposeEnumProps(json, 'mode', elem.Mode, CODES_TFhirMessageConformanceEventMode, false);
  if elem.protocolList.Count > 0 then
  begin
    json.valueArray('protocol');
    for i := 0 to elem.protocolList.Count - 1 do
      ComposeCoding(json, '',elem.protocolList[i]); {z - Coding}
    json.FinishArray;
  end;
  ComposeCodeValue(json, 'focus', elem.focus, false);
  ComposeCodeProps(json, 'focus', elem.focus, false);
  ComposeResourceReference{TFhirProfile}(json, 'request', elem.request); {a}
  ComposeResourceReference{TFhirProfile}(json, 'response', elem.response); {a}
  ComposeStringValue(json, 'documentation', elem.documentation, false);
  ComposeStringProps(json, 'documentation', elem.documentation, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformanceDocument(element : IXmlDomElement; path : string) : TFhirConformanceDocument;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformanceDocument.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'mode') then
        result.mode := ParseEnum(CODES_TFhirDocumentMode, path+'/mode', child)
      else if (child.baseName = 'documentation') then
        result.documentation := ParseString(child, path+'/documentation') {b}
      else if (child.baseName = 'profile') then
        result.profile := ParseResourceReference{TFhirProfile}(child, path+'/profile') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformanceDocument(xml : TXmlBuilder; name : string; elem : TFhirConformanceDocument);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'mode', elem.Mode, CODES_TFhirDocumentMode);
  ComposeString(xml, 'documentation', elem.documentation);
  ComposeResourceReference{TFhirProfile}(xml, 'profile', elem.profile);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformanceDocument(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceDocument(jsn));
end;

function TFHIRJsonParser.ParseConformanceDocument(jsn : TJsonObject) : TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('mode') or jsn.has('_mode')  then
      result.mode := parseEnum(jsn['mode'], jsn.vObj['_mode'], CODES_TFhirDocumentMode);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentation := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('profile') then
        result.profile := ParseResourceReference{TFhirProfile}(jsn.vObj['profile']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformanceDocument(json : TJSONWriter; name : string; elem : TFhirConformanceDocument);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'mode', elem.Mode, CODES_TFhirDocumentMode, false);
  ComposeEnumProps(json, 'mode', elem.Mode, CODES_TFhirDocumentMode, false);
  ComposeStringValue(json, 'documentation', elem.documentation, false);
  ComposeStringProps(json, 'documentation', elem.documentation, false);
  ComposeResourceReference{TFhirProfile}(json, 'profile', elem.profile); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseConformance(element : IXmlDomElement; path : string) : TFhirConformance;
var
  child : IXMLDOMElement;
begin
  result := TFhirConformance.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseString(child, path+'/identifier') {b}
      else if (child.baseName = 'version') then
        result.version := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'name') then
        result.name := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'publisher') then
        result.publisher := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContact(child, path+'/telecom'))
      else if (child.baseName = 'description') then
        result.description := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirConformanceStatementStatus, path+'/status', child)
      else if (child.baseName = 'experimental') then
        result.experimental := ParseBoolean(child, path+'/experimental') {b}
      else if (child.baseName = 'date') then
        result.date := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'software') then
        result.software := ParseConformanceSoftware(child, path+'/software') {b}
      else if (child.baseName = 'implementation') then
        result.implementation_ := ParseConformanceImplementation(child, path+'/implementation') {b}
      else if (child.baseName = 'fhirVersion') then
        result.fhirVersion := ParseId(child, path+'/fhirVersion') {b}
      else if (child.baseName = 'acceptUnknown') then
        result.acceptUnknown := ParseBoolean(child, path+'/acceptUnknown') {b}
      else if (child.baseName = 'format') then
        result.formatList.Add(ParseCode(child, path+'/format'))
      else if (child.baseName = 'profile') then
        result.profileList.Add(ParseResourceReference{TFhirProfile}(child, path+'/profile'))
      else if (child.baseName = 'rest') then
        result.restList.Add(ParseConformanceRest(child, path+'/rest'))
      else if (child.baseName = 'messaging') then
        result.messagingList.Add(ParseConformanceMessaging(child, path+'/messaging'))
      else if (child.baseName = 'document') then
        result.documentList.Add(ParseConformanceDocument(child, path+'/document'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeConformance(xml : TXmlBuilder; name : string; elem : TFhirConformance);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeString(xml, 'identifier', elem.identifier);
  ComposeString(xml, 'version', elem.version);
  ComposeString(xml, 'name', elem.name);
  ComposeString(xml, 'publisher', elem.publisher);
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContact(xml, 'telecom', elem.telecomList[i]);
  ComposeString(xml, 'description', elem.description);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirConformanceStatementStatus);
  ComposeBoolean(xml, 'experimental', elem.experimental);
  ComposeDateTime(xml, 'date', elem.date);
  ComposeConformanceSoftware(xml, 'software', elem.software);
  ComposeConformanceImplementation(xml, 'implementation', elem.implementation_);
  ComposeId(xml, 'fhirVersion', elem.fhirVersion);
  ComposeBoolean(xml, 'acceptUnknown', elem.acceptUnknown);
  if not SummaryOnly then
    for i := 0 to elem.formatList.Count - 1 do
      ComposeCode(xml, 'format', elem.formatList[i]);
  if not SummaryOnly then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeResourceReference{TFhirProfile}(xml, 'profile', elem.profileList[i]);
  if not SummaryOnly then
    for i := 0 to elem.restList.Count - 1 do
      ComposeConformanceRest(xml, 'rest', elem.restList[i]);
  if not SummaryOnly then
    for i := 0 to elem.messagingList.Count - 1 do
      ComposeConformanceMessaging(xml, 'messaging', elem.messagingList[i]);
  if not SummaryOnly then
    for i := 0 to elem.documentList.Count - 1 do
      ComposeConformanceDocument(xml, 'document', elem.documentList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseConformance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformance(jsn));
end;

function TFHIRJsonParser.ParseConformance(jsn : TJsonObject) : TFhirConformance;
begin
  result := TFhirConformance.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifier := ParseString(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.version := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.name := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisher := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContact);
    if jsn.has('description') or jsn.has('_description') then
        result.description := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirConformanceStatementStatus);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimental := ParseBoolean(jsn['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.date := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('software') then
        result.software := ParseConformanceSoftware(jsn.vObj['software']);{q}
    if jsn.has('implementation') then
        result.implementation_ := ParseConformanceImplementation(jsn.vObj['implementation']);{q}
    if jsn.has('fhirVersion') or jsn.has('_fhirVersion') then
        result.fhirVersion := ParseId(jsn['fhirVersion'], jsn.vObj['_fhirVersion']);{q}
    if jsn.has('acceptUnknown') or jsn.has('_acceptUnknown') then
        result.acceptUnknown := ParseBoolean(jsn['acceptUnknown'], jsn.vObj['_acceptUnknown']);{q}
      if jsn.has('format') or jsn.has('_format') then
      iteratePrimitiveArray(jsn.vArr['format'], jsn.vArr['_format'], result.formatList, parseCode);
    if jsn.has('profile') then
      iterateArray(jsn.vArr['profile'], result.profileList, parseResourceReference{TFhirProfile});
    if jsn.has('rest') then
      iterateArray(jsn.vArr['rest'], result.restList, parseConformanceRest);
    if jsn.has('messaging') then
      iterateArray(jsn.vArr['messaging'], result.messagingList, parseConformanceMessaging);
    if jsn.has('document') then
      iterateArray(jsn.vArr['document'], result.documentList, parseConformanceDocument);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeConformance(json : TJSONWriter; name : string; elem : TFhirConformance);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeStringValue(json, 'identifier', elem.identifier, false);
  ComposeStringProps(json, 'identifier', elem.identifier, false);
  ComposeStringValue(json, 'version', elem.version, false);
  ComposeStringProps(json, 'version', elem.version, false);
  ComposeStringValue(json, 'name', elem.name, false);
  ComposeStringProps(json, 'name', elem.name, false);
  ComposeStringValue(json, 'publisher', elem.publisher, false);
  ComposeStringProps(json, 'publisher', elem.publisher, false);
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContact(json, '',elem.telecomList[i]); {z - Contact}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.description, false);
  ComposeStringProps(json, 'description', elem.description, false);
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirConformanceStatementStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirConformanceStatementStatus, false);
  ComposeBooleanValue(json, 'experimental', elem.experimental, false);
  ComposeBooleanProps(json, 'experimental', elem.experimental, false);
  ComposeDateTimeValue(json, 'date', elem.date, false);
  ComposeDateTimeProps(json, 'date', elem.date, false);
  ComposeConformanceSoftware(json, 'software', elem.software); {a}
  ComposeConformanceImplementation(json, 'implementation', elem.implementation_); {a}
  ComposeIdValue(json, 'fhirVersion', elem.fhirVersion, false);
  ComposeIdProps(json, 'fhirVersion', elem.fhirVersion, false);
  ComposeBooleanValue(json, 'acceptUnknown', elem.acceptUnknown, false);
  ComposeBooleanProps(json, 'acceptUnknown', elem.acceptUnknown, false);
  if not SummaryOnly and (elem.formatList.Count > 0) then
  begin
    json.valueArray('format');
    ext := false;
    for i := 0 to elem.formatList.Count - 1 do
    begin
      ext := ext or ((elem.formatList[i].xmlid <> '') or (elem.formatList[i].hasExtensions));
      ComposeCodeValue(json, '',elem.formatList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_format');
      for i := 0 to elem.formatList.Count - 1 do
        ComposeCodeProps(json, '',elem.formatList[i], true);
      json.FinishArray;
    end;
  end;
  if not SummaryOnly and (elem.profileList.Count > 0) then
  begin
    json.valueArray('profile');
    for i := 0 to elem.profileList.Count - 1 do
      ComposeResourceReference{TFhirProfile}(json, '',elem.profileList[i]); {z - Resource(Profile)}
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.restList.Count > 0) then
  begin
    json.valueArray('rest');
    for i := 0 to elem.restList.Count - 1 do
      ComposeConformanceRest(json, '',elem.restList[i]); {z - }
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.messagingList.Count > 0) then
  begin
    json.valueArray('messaging');
    for i := 0 to elem.messagingList.Count - 1 do
      ComposeConformanceMessaging(json, '',elem.messagingList[i]); {z - }
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.documentList.Count > 0) then
  begin
    json.valueArray('document');
    for i := 0 to elem.documentList.Count - 1 do
      ComposeConformanceDocument(json, '',elem.documentList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseDevice(element : IXmlDomElement; path : string) : TFhirDevice;
var
  child : IXMLDOMElement;
begin
  result := TFhirDevice.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'manufacturer') then
        result.manufacturer := ParseString(child, path+'/manufacturer') {b}
      else if (child.baseName = 'model') then
        result.model := ParseString(child, path+'/model') {b}
      else if (child.baseName = 'version') then
        result.version := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'expiry') then
        result.expiry := ParseDate(child, path+'/expiry') {b}
      else if (child.baseName = 'udi') then
        result.udi := ParseString(child, path+'/udi') {b}
      else if (child.baseName = 'lotNumber') then
        result.lotNumber := ParseString(child, path+'/lotNumber') {b}
      else if (child.baseName = 'owner') then
        result.owner := ParseResourceReference{TFhirOrganization}(child, path+'/owner') {b}
      else if (child.baseName = 'location') then
        result.location := ParseResourceReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'patient') then
        result.patient := ParseResourceReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseContact(child, path+'/contact'))
      else if (child.baseName = 'url') then
        result.url := ParseUri(child, path+'/url') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDevice(xml : TXmlBuilder; name : string; elem : TFhirDevice);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'type', elem.type_);
  ComposeString(xml, 'manufacturer', elem.manufacturer);
  ComposeString(xml, 'model', elem.model);
  ComposeString(xml, 'version', elem.version);
  ComposeDate(xml, 'expiry', elem.expiry);
  ComposeString(xml, 'udi', elem.udi);
  ComposeString(xml, 'lotNumber', elem.lotNumber);
  ComposeResourceReference{TFhirOrganization}(xml, 'owner', elem.owner);
  ComposeResourceReference{TFhirLocation}(xml, 'location', elem.location);
  ComposeResourceReference{TFhirPatient}(xml, 'patient', elem.patient);
  for i := 0 to elem.contactList.Count - 1 do
    ComposeContact(xml, 'contact', elem.contactList[i]);
  ComposeUri(xml, 'url', elem.url);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDevice(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDevice(jsn));
end;

function TFHIRJsonParser.ParseDevice(jsn : TJsonObject) : TFhirDevice;
begin
  result := TFhirDevice.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('manufacturer') or jsn.has('_manufacturer') then
        result.manufacturer := ParseString(jsn['manufacturer'], jsn.vObj['_manufacturer']);{q}
    if jsn.has('model') or jsn.has('_model') then
        result.model := ParseString(jsn['model'], jsn.vObj['_model']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.version := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('expiry') or jsn.has('_expiry') then
        result.expiry := ParseDate(jsn['expiry'], jsn.vObj['_expiry']);{q}
    if jsn.has('udi') or jsn.has('_udi') then
        result.udi := ParseString(jsn['udi'], jsn.vObj['_udi']);{q}
    if jsn.has('lotNumber') or jsn.has('_lotNumber') then
        result.lotNumber := ParseString(jsn['lotNumber'], jsn.vObj['_lotNumber']);{q}
    if jsn.has('owner') then
        result.owner := ParseResourceReference{TFhirOrganization}(jsn.vObj['owner']);{q}
    if jsn.has('location') then
        result.location := ParseResourceReference{TFhirLocation}(jsn.vObj['location']);{q}
    if jsn.has('patient') then
        result.patient := ParseResourceReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContact);
    if jsn.has('url') or jsn.has('_url') then
        result.url := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDevice(json : TJSONWriter; name : string; elem : TFhirDevice);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeStringValue(json, 'manufacturer', elem.manufacturer, false);
  ComposeStringProps(json, 'manufacturer', elem.manufacturer, false);
  ComposeStringValue(json, 'model', elem.model, false);
  ComposeStringProps(json, 'model', elem.model, false);
  ComposeStringValue(json, 'version', elem.version, false);
  ComposeStringProps(json, 'version', elem.version, false);
  ComposeDateValue(json, 'expiry', elem.expiry, false);
  ComposeDateProps(json, 'expiry', elem.expiry, false);
  ComposeStringValue(json, 'udi', elem.udi, false);
  ComposeStringProps(json, 'udi', elem.udi, false);
  ComposeStringValue(json, 'lotNumber', elem.lotNumber, false);
  ComposeStringProps(json, 'lotNumber', elem.lotNumber, false);
  ComposeResourceReference{TFhirOrganization}(json, 'owner', elem.owner); {a}
  ComposeResourceReference{TFhirLocation}(json, 'location', elem.location); {a}
  ComposeResourceReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if elem.contactList.Count > 0 then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContact(json, '',elem.contactList[i]); {z - Contact}
    json.FinishArray;
  end;
  ComposeUriValue(json, 'url', elem.url, false);
  ComposeUriProps(json, 'url', elem.url, false);
end;

function TFHIRXmlParser.ParseDeviceObservationReportVirtualDevice(element : IXmlDomElement; path : string) : TFhirDeviceObservationReportVirtualDevice;
var
  child : IXMLDOMElement;
begin
  result := TFhirDeviceObservationReportVirtualDevice.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'channel') then
        result.channelList.Add(ParseDeviceObservationReportVirtualDeviceChannel(child, path+'/channel'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDeviceObservationReportVirtualDevice(xml : TXmlBuilder; name : string; elem : TFhirDeviceObservationReportVirtualDevice);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);
  for i := 0 to elem.channelList.Count - 1 do
    ComposeDeviceObservationReportVirtualDeviceChannel(xml, 'channel', elem.channelList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDeviceObservationReportVirtualDevice(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceObservationReportVirtualDevice(jsn));
end;

function TFHIRJsonParser.ParseDeviceObservationReportVirtualDevice(jsn : TJsonObject) : TFhirDeviceObservationReportVirtualDevice;
begin
  result := TFhirDeviceObservationReportVirtualDevice.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('channel') then
      iterateArray(jsn.vArr['channel'], result.channelList, parseDeviceObservationReportVirtualDeviceChannel);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDeviceObservationReportVirtualDevice(json : TJSONWriter; name : string; elem : TFhirDeviceObservationReportVirtualDevice);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if elem.channelList.Count > 0 then
  begin
    json.valueArray('channel');
    for i := 0 to elem.channelList.Count - 1 do
      ComposeDeviceObservationReportVirtualDeviceChannel(json, '',elem.channelList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseDeviceObservationReportVirtualDeviceChannel(element : IXmlDomElement; path : string) : TFhirDeviceObservationReportVirtualDeviceChannel;
var
  child : IXMLDOMElement;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannel.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'metric') then
        result.metricList.Add(ParseDeviceObservationReportVirtualDeviceChannelMetric(child, path+'/metric'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDeviceObservationReportVirtualDeviceChannel(xml : TXmlBuilder; name : string; elem : TFhirDeviceObservationReportVirtualDeviceChannel);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);
  for i := 0 to elem.metricList.Count - 1 do
    ComposeDeviceObservationReportVirtualDeviceChannelMetric(xml, 'metric', elem.metricList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDeviceObservationReportVirtualDeviceChannel(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceObservationReportVirtualDeviceChannel(jsn));
end;

function TFHIRJsonParser.ParseDeviceObservationReportVirtualDeviceChannel(jsn : TJsonObject) : TFhirDeviceObservationReportVirtualDeviceChannel;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannel.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('metric') then
      iterateArray(jsn.vArr['metric'], result.metricList, parseDeviceObservationReportVirtualDeviceChannelMetric);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDeviceObservationReportVirtualDeviceChannel(json : TJSONWriter; name : string; elem : TFhirDeviceObservationReportVirtualDeviceChannel);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if elem.metricList.Count > 0 then
  begin
    json.valueArray('metric');
    for i := 0 to elem.metricList.Count - 1 do
      ComposeDeviceObservationReportVirtualDeviceChannelMetric(json, '',elem.metricList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseDeviceObservationReportVirtualDeviceChannelMetric(element : IXmlDomElement; path : string) : TFhirDeviceObservationReportVirtualDeviceChannelMetric;
var
  child : IXMLDOMElement;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelMetric.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'observation') then
        result.observation := ParseResourceReference{TFhirObservation}(child, path+'/observation') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDeviceObservationReportVirtualDeviceChannelMetric(xml : TXmlBuilder; name : string; elem : TFhirDeviceObservationReportVirtualDeviceChannelMetric);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeResourceReference{TFhirObservation}(xml, 'observation', elem.observation);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDeviceObservationReportVirtualDeviceChannelMetric(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceObservationReportVirtualDeviceChannelMetric(jsn));
end;

function TFHIRJsonParser.ParseDeviceObservationReportVirtualDeviceChannelMetric(jsn : TJsonObject) : TFhirDeviceObservationReportVirtualDeviceChannelMetric;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelMetric.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('observation') then
        result.observation := ParseResourceReference{TFhirObservation}(jsn.vObj['observation']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDeviceObservationReportVirtualDeviceChannelMetric(json : TJSONWriter; name : string; elem : TFhirDeviceObservationReportVirtualDeviceChannelMetric);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeResourceReference{TFhirObservation}(json, 'observation', elem.observation); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseDeviceObservationReport(element : IXmlDomElement; path : string) : TFhirDeviceObservationReport;
var
  child : IXMLDOMElement;
begin
  result := TFhirDeviceObservationReport.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'instant') then
        result.instant := ParseInstant(child, path+'/instant') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'source') then
        result.source := ParseResourceReference{TFhirDevice}(child, path+'/source') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseResourceReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'virtualDevice') then
        result.virtualDeviceList.Add(ParseDeviceObservationReportVirtualDevice(child, path+'/virtualDevice'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDeviceObservationReport(xml : TXmlBuilder; name : string; elem : TFhirDeviceObservationReport);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeInstant(xml, 'instant', elem.instant);
  ComposeIdentifier(xml, 'identifier', elem.identifier);
  ComposeResourceReference{TFhirDevice}(xml, 'source', elem.source);
  ComposeResourceReference{Resource}(xml, 'subject', elem.subject);
  for i := 0 to elem.virtualDeviceList.Count - 1 do
    ComposeDeviceObservationReportVirtualDevice(xml, 'virtualDevice', elem.virtualDeviceList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDeviceObservationReport(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceObservationReport(jsn));
end;

function TFHIRJsonParser.ParseDeviceObservationReport(jsn : TJsonObject) : TFhirDeviceObservationReport;
begin
  result := TFhirDeviceObservationReport.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('instant') or jsn.has('_instant') then
        result.instant := ParseInstant(jsn['instant'], jsn.vObj['_instant']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('source') then
        result.source := ParseResourceReference{TFhirDevice}(jsn.vObj['source']);{q}
    if jsn.has('subject') then
        result.subject := ParseResourceReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('virtualDevice') then
      iterateArray(jsn.vArr['virtualDevice'], result.virtualDeviceList, parseDeviceObservationReportVirtualDevice);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDeviceObservationReport(json : TJSONWriter; name : string; elem : TFhirDeviceObservationReport);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeInstantValue(json, 'instant', elem.instant, false);
  ComposeInstantProps(json, 'instant', elem.instant, false);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeResourceReference{TFhirDevice}(json, 'source', elem.source); {a}
  ComposeResourceReference{Resource}(json, 'subject', elem.subject); {a}
  if elem.virtualDeviceList.Count > 0 then
  begin
    json.valueArray('virtualDevice');
    for i := 0 to elem.virtualDeviceList.Count - 1 do
      ComposeDeviceObservationReportVirtualDevice(json, '',elem.virtualDeviceList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseDiagnosticOrderEvent(element : IXmlDomElement; path : string) : TFhirDiagnosticOrderEvent;
var
  child : IXMLDOMElement;
begin
  result := TFhirDiagnosticOrderEvent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirDiagnosticOrderStatus, path+'/status', child)
      else if (child.baseName = 'description') then
        result.description := ParseCodeableConcept(child, path+'/description') {b}
      else if (child.baseName = 'dateTime') then
        result.dateTime := ParseDateTime(child, path+'/dateTime') {b}
      else if (child.baseName = 'actor') then
        result.actor := ParseResourceReference{Resource}(child, path+'/actor') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticOrderEvent(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrderEvent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirDiagnosticOrderStatus);
  ComposeCodeableConcept(xml, 'description', elem.description);
  ComposeDateTime(xml, 'dateTime', elem.dateTime);
  ComposeResourceReference{Resource}(xml, 'actor', elem.actor);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDiagnosticOrderEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticOrderEvent(jsn));
end;

function TFHIRJsonParser.ParseDiagnosticOrderEvent(jsn : TJsonObject) : TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirDiagnosticOrderStatus);
    if jsn.has('description') then
        result.description := ParseCodeableConcept(jsn.vObj['description']);{q}
    if jsn.has('dateTime') or jsn.has('_dateTime') then
        result.dateTime := ParseDateTime(jsn['dateTime'], jsn.vObj['_dateTime']);{q}
    if jsn.has('actor') then
        result.actor := ParseResourceReference{Resource}(jsn.vObj['actor']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDiagnosticOrderEvent(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrderEvent);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirDiagnosticOrderStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirDiagnosticOrderStatus, false);
  ComposeCodeableConcept(json, 'description', elem.description); {a}
  ComposeDateTimeValue(json, 'dateTime', elem.dateTime, false);
  ComposeDateTimeProps(json, 'dateTime', elem.dateTime, false);
  ComposeResourceReference{Resource}(json, 'actor', elem.actor); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseDiagnosticOrderItem(element : IXmlDomElement; path : string) : TFhirDiagnosticOrderItem;
var
  child : IXMLDOMElement;
begin
  result := TFhirDiagnosticOrderItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'specimen') then
        result.specimenList.Add(ParseResourceReference{TFhirSpecimen}(child, path+'/specimen'))
      else if (child.baseName = 'bodySite') then
        result.bodySite := ParseCodeableConcept(child, path+'/bodySite') {b}
      else if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirDiagnosticOrderStatus, path+'/status', child)
      else if (child.baseName = 'event') then
        result.eventList.Add(ParseDiagnosticOrderEvent(child, path+'/event'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticOrderItem(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrderItem);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);
  for i := 0 to elem.specimenList.Count - 1 do
    ComposeResourceReference{TFhirSpecimen}(xml, 'specimen', elem.specimenList[i]);
  ComposeCodeableConcept(xml, 'bodySite', elem.bodySite);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirDiagnosticOrderStatus);
  for i := 0 to elem.eventList.Count - 1 do
    ComposeDiagnosticOrderEvent(xml, 'event', elem.eventList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDiagnosticOrderItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticOrderItem(jsn));
end;

function TFHIRJsonParser.ParseDiagnosticOrderItem(jsn : TJsonObject) : TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('specimen') then
      iterateArray(jsn.vArr['specimen'], result.specimenList, parseResourceReference{TFhirSpecimen});
    if jsn.has('bodySite') then
        result.bodySite := ParseCodeableConcept(jsn.vObj['bodySite']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirDiagnosticOrderStatus);
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseDiagnosticOrderEvent);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDiagnosticOrderItem(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrderItem);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if elem.specimenList.Count > 0 then
  begin
    json.valueArray('specimen');
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeResourceReference{TFhirSpecimen}(json, '',elem.specimenList[i]); {z - Resource(Specimen)}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'bodySite', elem.bodySite); {a}
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirDiagnosticOrderStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirDiagnosticOrderStatus, false);
  if elem.eventList.Count > 0 then
  begin
    json.valueArray('event');
    for i := 0 to elem.eventList.Count - 1 do
      ComposeDiagnosticOrderEvent(json, '',elem.eventList[i]); {z - @DiagnosticOrder.event}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseDiagnosticOrder(element : IXmlDomElement; path : string) : TFhirDiagnosticOrder;
var
  child : IXMLDOMElement;
begin
  result := TFhirDiagnosticOrder.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'subject') then
        result.subject := ParseResourceReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'orderer') then
        result.orderer := ParseResourceReference{TFhirPractitioner}(child, path+'/orderer') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'encounter') then
        result.encounter := ParseResourceReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'clinicalNotes') then
        result.clinicalNotes := ParseString(child, path+'/clinicalNotes') {b}
      else if (child.baseName = 'specimen') then
        result.specimenList.Add(ParseResourceReference{TFhirSpecimen}(child, path+'/specimen'))
      else if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirDiagnosticOrderStatus, path+'/status', child)
      else if (child.baseName = 'priority') then
        result.priority := ParseEnum(CODES_TFhirDiagnosticOrderPriority, path+'/priority', child)
      else if (child.baseName = 'event') then
        result.eventList.Add(ParseDiagnosticOrderEvent(child, path+'/event'))
      else if (child.baseName = 'item') then
        result.itemList.Add(ParseDiagnosticOrderItem(child, path+'/item'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticOrder(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrder);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeResourceReference{Resource}(xml, 'subject', elem.subject);
  ComposeResourceReference{TFhirPractitioner}(xml, 'orderer', elem.orderer);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeResourceReference{TFhirEncounter}(xml, 'encounter', elem.encounter);
  ComposeString(xml, 'clinicalNotes', elem.clinicalNotes);
  for i := 0 to elem.specimenList.Count - 1 do
    ComposeResourceReference{TFhirSpecimen}(xml, 'specimen', elem.specimenList[i]);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirDiagnosticOrderStatus);
  ComposeEnum(xml, 'priority', elem.Priority, CODES_TFhirDiagnosticOrderPriority);
  for i := 0 to elem.eventList.Count - 1 do
    ComposeDiagnosticOrderEvent(xml, 'event', elem.eventList[i]);
  for i := 0 to elem.itemList.Count - 1 do
    ComposeDiagnosticOrderItem(xml, 'item', elem.itemList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDiagnosticOrder(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticOrder(jsn));
end;

function TFHIRJsonParser.ParseDiagnosticOrder(jsn : TJsonObject) : TFhirDiagnosticOrder;
begin
  result := TFhirDiagnosticOrder.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('subject') then
        result.subject := ParseResourceReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('orderer') then
        result.orderer := ParseResourceReference{TFhirPractitioner}(jsn.vObj['orderer']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('encounter') then
        result.encounter := ParseResourceReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('clinicalNotes') or jsn.has('_clinicalNotes') then
        result.clinicalNotes := ParseString(jsn['clinicalNotes'], jsn.vObj['_clinicalNotes']);{q}
    if jsn.has('specimen') then
      iterateArray(jsn.vArr['specimen'], result.specimenList, parseResourceReference{TFhirSpecimen});
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirDiagnosticOrderStatus);
    if jsn.has('priority') or jsn.has('_priority')  then
      result.priority := parseEnum(jsn['priority'], jsn.vObj['_priority'], CODES_TFhirDiagnosticOrderPriority);
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseDiagnosticOrderEvent);
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseDiagnosticOrderItem);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDiagnosticOrder(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrder);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeResourceReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeResourceReference{TFhirPractitioner}(json, 'orderer', elem.orderer); {a}
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeResourceReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  ComposeStringValue(json, 'clinicalNotes', elem.clinicalNotes, false);
  ComposeStringProps(json, 'clinicalNotes', elem.clinicalNotes, false);
  if elem.specimenList.Count > 0 then
  begin
    json.valueArray('specimen');
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeResourceReference{TFhirSpecimen}(json, '',elem.specimenList[i]); {z - Resource(Specimen)}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirDiagnosticOrderStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirDiagnosticOrderStatus, false);
  ComposeEnumValue(json, 'priority', elem.Priority, CODES_TFhirDiagnosticOrderPriority, false);
  ComposeEnumProps(json, 'priority', elem.Priority, CODES_TFhirDiagnosticOrderPriority, false);
  if elem.eventList.Count > 0 then
  begin
    json.valueArray('event');
    for i := 0 to elem.eventList.Count - 1 do
      ComposeDiagnosticOrderEvent(json, '',elem.eventList[i]); {z - }
    json.FinishArray;
  end;
  if elem.itemList.Count > 0 then
  begin
    json.valueArray('item');
    for i := 0 to elem.itemList.Count - 1 do
      ComposeDiagnosticOrderItem(json, '',elem.itemList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseDiagnosticReportImage(element : IXmlDomElement; path : string) : TFhirDiagnosticReportImage;
var
  child : IXMLDOMElement;
begin
  result := TFhirDiagnosticReportImage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'comment') then
        result.comment := ParseString(child, path+'/comment') {b}
      else if (child.baseName = 'link') then
        result.link_ := ParseResourceReference{TFhirMedia}(child, path+'/link') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticReportImage(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticReportImage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'comment', elem.comment);
  ComposeResourceReference{TFhirMedia}(xml, 'link', elem.link_);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDiagnosticReportImage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticReportImage(jsn));
end;

function TFHIRJsonParser.ParseDiagnosticReportImage(jsn : TJsonObject) : TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('comment') or jsn.has('_comment') then
        result.comment := ParseString(jsn['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('link') then
        result.link_ := ParseResourceReference{TFhirMedia}(jsn.vObj['link']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDiagnosticReportImage(json : TJSONWriter; name : string; elem : TFhirDiagnosticReportImage);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'comment', elem.comment, false);
  ComposeStringProps(json, 'comment', elem.comment, false);
  ComposeResourceReference{TFhirMedia}(json, 'link', elem.link_); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseDiagnosticReport(element : IXmlDomElement; path : string) : TFhirDiagnosticReport;
var
  child : IXMLDOMElement;
begin
  result := TFhirDiagnosticReport.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.name := ParseCodeableConcept(child, path+'/name') {b}
      else if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirDiagnosticReportStatus, path+'/status', child)
      else if (child.baseName = 'issued') then
        result.issued := ParseDateTime(child, path+'/issued') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseResourceReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'performer') then
        result.performer := ParseResourceReference{Resource}(child, path+'/performer') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'requestDetail') then
        result.requestDetailList.Add(ParseResourceReference{TFhirDiagnosticOrder}(child, path+'/requestDetail'))
      else if (child.baseName = 'serviceCategory') then
        result.serviceCategory := ParseCodeableConcept(child, path+'/serviceCategory') {b}
      else if (child.baseName = 'diagnosticDateTime') then
        result.diagnostic := ParseDateTime(child, path+'/diagnosticDateTime')
      else if (child.baseName = 'diagnosticPeriod') then
        result.diagnostic := ParsePeriod(child, path+'/diagnosticPeriod')
      else if (child.baseName = 'specimen') then
        result.specimenList.Add(ParseResourceReference{TFhirSpecimen}(child, path+'/specimen'))
      else if (child.baseName = 'result') then
        result.resultList.Add(ParseResourceReference{TFhirObservation}(child, path+'/result'))
      else if (child.baseName = 'imagingStudy') then
        result.imagingStudyList.Add(ParseResourceReference{TFhirImagingStudy}(child, path+'/imagingStudy'))
      else if (child.baseName = 'image') then
        result.imageList.Add(ParseDiagnosticReportImage(child, path+'/image'))
      else if (child.baseName = 'conclusion') then
        result.conclusion := ParseString(child, path+'/conclusion') {b}
      else if (child.baseName = 'codedDiagnosis') then
        result.codedDiagnosisList.Add(ParseCodeableConcept(child, path+'/codedDiagnosis'))
      else if (child.baseName = 'presentedForm') then
        result.presentedFormList.Add(ParseAttachment(child, path+'/presentedForm'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticReport(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticReport);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  if not SummaryOnly then
    ComposeCodeableConcept(xml, 'name', elem.name);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirDiagnosticReportStatus);
  ComposeDateTime(xml, 'issued', elem.issued);
  ComposeResourceReference{Resource}(xml, 'subject', elem.subject);
  ComposeResourceReference{Resource}(xml, 'performer', elem.performer);
  ComposeIdentifier(xml, 'identifier', elem.identifier);
  if not SummaryOnly then
    for i := 0 to elem.requestDetailList.Count - 1 do
      ComposeResourceReference{TFhirDiagnosticOrder}(xml, 'requestDetail', elem.requestDetailList[i]);
  ComposeCodeableConcept(xml, 'serviceCategory', elem.serviceCategory);
  if (elem.diagnostic is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'diagnosticDateTime', TFhirDateTime(elem.diagnostic))
  else if (elem.diagnostic is TFhirPeriod) {6} then
    ComposePeriod(xml, 'diagnosticPeriod', TFhirPeriod(elem.diagnostic));
  if not SummaryOnly then
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeResourceReference{TFhirSpecimen}(xml, 'specimen', elem.specimenList[i]);
  if not SummaryOnly then
    for i := 0 to elem.resultList.Count - 1 do
      ComposeResourceReference{TFhirObservation}(xml, 'result', elem.resultList[i]);
  if not SummaryOnly then
    for i := 0 to elem.imagingStudyList.Count - 1 do
      ComposeResourceReference{TFhirImagingStudy}(xml, 'imagingStudy', elem.imagingStudyList[i]);
  for i := 0 to elem.imageList.Count - 1 do
    ComposeDiagnosticReportImage(xml, 'image', elem.imageList[i]);
  if not SummaryOnly then
    ComposeString(xml, 'conclusion', elem.conclusion);
  if not SummaryOnly then
    for i := 0 to elem.codedDiagnosisList.Count - 1 do
      ComposeCodeableConcept(xml, 'codedDiagnosis', elem.codedDiagnosisList[i]);
  if not SummaryOnly then
    for i := 0 to elem.presentedFormList.Count - 1 do
      ComposeAttachment(xml, 'presentedForm', elem.presentedFormList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDiagnosticReport(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticReport(jsn));
end;

function TFHIRJsonParser.ParseDiagnosticReport(jsn : TJsonObject) : TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('name') then
        result.name := ParseCodeableConcept(jsn.vObj['name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirDiagnosticReportStatus);
    if jsn.has('issued') or jsn.has('_issued') then
        result.issued := ParseDateTime(jsn['issued'], jsn.vObj['_issued']);{q}
    if jsn.has('subject') then
        result.subject := ParseResourceReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('performer') then
        result.performer := ParseResourceReference{Resource}(jsn.vObj['performer']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('requestDetail') then
      iterateArray(jsn.vArr['requestDetail'], result.requestDetailList, parseResourceReference{TFhirDiagnosticOrder});
    if jsn.has('serviceCategory') then
        result.serviceCategory := ParseCodeableConcept(jsn.vObj['serviceCategory']);{q}
    if jsn.has('diagnosticDateTime') or jsn.has('_diagnosticDateTime') then
      result.diagnostic := parseDateTime(jsn['diagnosticDateTime'], jsn.vObj['_diagnosticDateTime']);
    if jsn.has('diagnosticPeriod') {a4} then
      result.diagnostic := ParsePeriod(jsn.vObj['diagnosticPeriod']);
    if jsn.has('specimen') then
      iterateArray(jsn.vArr['specimen'], result.specimenList, parseResourceReference{TFhirSpecimen});
    if jsn.has('result') then
      iterateArray(jsn.vArr['result'], result.resultList, parseResourceReference{TFhirObservation});
    if jsn.has('imagingStudy') then
      iterateArray(jsn.vArr['imagingStudy'], result.imagingStudyList, parseResourceReference{TFhirImagingStudy});
    if jsn.has('image') then
      iterateArray(jsn.vArr['image'], result.imageList, parseDiagnosticReportImage);
    if jsn.has('conclusion') or jsn.has('_conclusion') then
        result.conclusion := ParseString(jsn['conclusion'], jsn.vObj['_conclusion']);{q}
    if jsn.has('codedDiagnosis') then
      iterateArray(jsn.vArr['codedDiagnosis'], result.codedDiagnosisList, parseCodeableConcept);
    if jsn.has('presentedForm') then
      iterateArray(jsn.vArr['presentedForm'], result.presentedFormList, parseAttachment);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDiagnosticReport(json : TJSONWriter; name : string; elem : TFhirDiagnosticReport);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if not SummaryOnly then
    ComposeCodeableConcept(json, 'name', elem.name); {a}
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirDiagnosticReportStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirDiagnosticReportStatus, false);
  ComposeDateTimeValue(json, 'issued', elem.issued, false);
  ComposeDateTimeProps(json, 'issued', elem.issued, false);
  ComposeResourceReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeResourceReference{Resource}(json, 'performer', elem.performer); {a}
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if not SummaryOnly and (elem.requestDetailList.Count > 0) then
  begin
    json.valueArray('requestDetail');
    for i := 0 to elem.requestDetailList.Count - 1 do
      ComposeResourceReference{TFhirDiagnosticOrder}(json, '',elem.requestDetailList[i]); {z - Resource(DiagnosticOrder)}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'serviceCategory', elem.serviceCategory); {a}
  if (elem.diagnostic is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'diagnosticDateTime', TFhirDateTime(elem.diagnostic), false);
    ComposeDateTimeProps(json, 'diagnosticDateTime', TFhirDateTime(elem.diagnostic), false);
  end
  else if (elem.diagnostic is TFhirPeriod) then 
    ComposePeriod(json, 'diagnosticPeriod', TFhirPeriod(elem.diagnostic)) ;
  if not SummaryOnly and (elem.specimenList.Count > 0) then
  begin
    json.valueArray('specimen');
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeResourceReference{TFhirSpecimen}(json, '',elem.specimenList[i]); {z - Resource(Specimen)}
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.resultList.Count > 0) then
  begin
    json.valueArray('result');
    for i := 0 to elem.resultList.Count - 1 do
      ComposeResourceReference{TFhirObservation}(json, '',elem.resultList[i]); {z - Resource(Observation)}
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.imagingStudyList.Count > 0) then
  begin
    json.valueArray('imagingStudy');
    for i := 0 to elem.imagingStudyList.Count - 1 do
      ComposeResourceReference{TFhirImagingStudy}(json, '',elem.imagingStudyList[i]); {z - Resource(ImagingStudy)}
    json.FinishArray;
  end;
  if elem.imageList.Count > 0 then
  begin
    json.valueArray('image');
    for i := 0 to elem.imageList.Count - 1 do
      ComposeDiagnosticReportImage(json, '',elem.imageList[i]); {z - }
    json.FinishArray;
  end;
  if not SummaryOnly then
    ComposeStringValue(json, 'conclusion', elem.conclusion, false);
  if not SummaryOnly then
    ComposeStringProps(json, 'conclusion', elem.conclusion, false);
  if not SummaryOnly and (elem.codedDiagnosisList.Count > 0) then
  begin
    json.valueArray('codedDiagnosis');
    for i := 0 to elem.codedDiagnosisList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.codedDiagnosisList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.presentedFormList.Count > 0) then
  begin
    json.valueArray('presentedForm');
    for i := 0 to elem.presentedFormList.Count - 1 do
      ComposeAttachment(json, '',elem.presentedFormList[i]); {z - Attachment}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseDocumentManifest(element : IXmlDomElement; path : string) : TFhirDocumentManifest;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentManifest.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'masterIdentifier') then
        result.masterIdentifier := ParseIdentifier(child, path+'/masterIdentifier') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'subject') then
        result.subjectList.Add(ParseResourceReference{Resource}(child, path+'/subject'))
      else if (child.baseName = 'recipient') then
        result.recipientList.Add(ParseResourceReference{Resource}(child, path+'/recipient'))
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'author') then
        result.authorList.Add(ParseResourceReference{Resource}(child, path+'/author'))
      else if (child.baseName = 'created') then
        result.created := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'source') then
        result.source := ParseUri(child, path+'/source') {b}
      else if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirDocumentReferenceStatus, path+'/status', child)
      else if (child.baseName = 'supercedes') then
        result.supercedes := ParseResourceReference{TFhirDocumentManifest}(child, path+'/supercedes') {b}
      else if (child.baseName = 'description') then
        result.description := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'confidentiality') then
        result.confidentiality := ParseCodeableConcept(child, path+'/confidentiality') {b}
      else if (child.baseName = 'content') then
        result.contentList.Add(ParseResourceReference{Resource}(child, path+'/content'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentManifest(xml : TXmlBuilder; name : string; elem : TFhirDocumentManifest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeIdentifier(xml, 'masterIdentifier', elem.masterIdentifier);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  for i := 0 to elem.subjectList.Count - 1 do
    ComposeResourceReference{Resource}(xml, 'subject', elem.subjectList[i]);
  for i := 0 to elem.recipientList.Count - 1 do
    ComposeResourceReference{Resource}(xml, 'recipient', elem.recipientList[i]);
  ComposeCodeableConcept(xml, 'type', elem.type_);
  for i := 0 to elem.authorList.Count - 1 do
    ComposeResourceReference{Resource}(xml, 'author', elem.authorList[i]);
  ComposeDateTime(xml, 'created', elem.created);
  ComposeUri(xml, 'source', elem.source);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirDocumentReferenceStatus);
  ComposeResourceReference{TFhirDocumentManifest}(xml, 'supercedes', elem.supercedes);
  ComposeString(xml, 'description', elem.description);
  ComposeCodeableConcept(xml, 'confidentiality', elem.confidentiality);
  for i := 0 to elem.contentList.Count - 1 do
    ComposeResourceReference{Resource}(xml, 'content', elem.contentList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentManifest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentManifest(jsn));
end;

function TFHIRJsonParser.ParseDocumentManifest(jsn : TJsonObject) : TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('masterIdentifier') then
        result.masterIdentifier := ParseIdentifier(jsn.vObj['masterIdentifier']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
      iterateArray(jsn.vArr['subject'], result.subjectList, parseResourceReference{Resource});
    if jsn.has('recipient') then
      iterateArray(jsn.vArr['recipient'], result.recipientList, parseResourceReference{Resource});
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseResourceReference{Resource});
    if jsn.has('created') or jsn.has('_created') then
        result.created := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('source') or jsn.has('_source') then
        result.source := ParseUri(jsn['source'], jsn.vObj['_source']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirDocumentReferenceStatus);
    if jsn.has('supercedes') then
        result.supercedes := ParseResourceReference{TFhirDocumentManifest}(jsn.vObj['supercedes']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.description := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('confidentiality') then
        result.confidentiality := ParseCodeableConcept(jsn.vObj['confidentiality']);{q}
    if jsn.has('content') then
      iterateArray(jsn.vArr['content'], result.contentList, parseResourceReference{Resource});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentManifest(json : TJSONWriter; name : string; elem : TFhirDocumentManifest);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeIdentifier(json, 'masterIdentifier', elem.masterIdentifier); {a}
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if elem.subjectList.Count > 0 then
  begin
    json.valueArray('subject');
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeResourceReference{Resource}(json, '',elem.subjectList[i]); {z - Resource(Patient|Practitioner|Group|Device)}
    json.FinishArray;
  end;
  if elem.recipientList.Count > 0 then
  begin
    json.valueArray('recipient');
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeResourceReference{Resource}(json, '',elem.recipientList[i]); {z - Resource(Patient|Practitioner|Organization)}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if elem.authorList.Count > 0 then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeResourceReference{Resource}(json, '',elem.authorList[i]); {z - Resource(Practitioner|Device|Patient|RelatedPerson)}
    json.FinishArray;
  end;
  ComposeDateTimeValue(json, 'created', elem.created, false);
  ComposeDateTimeProps(json, 'created', elem.created, false);
  ComposeUriValue(json, 'source', elem.source, false);
  ComposeUriProps(json, 'source', elem.source, false);
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirDocumentReferenceStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirDocumentReferenceStatus, false);
  ComposeResourceReference{TFhirDocumentManifest}(json, 'supercedes', elem.supercedes); {a}
  ComposeStringValue(json, 'description', elem.description, false);
  ComposeStringProps(json, 'description', elem.description, false);
  ComposeCodeableConcept(json, 'confidentiality', elem.confidentiality); {a}
  if elem.contentList.Count > 0 then
  begin
    json.valueArray('content');
    for i := 0 to elem.contentList.Count - 1 do
      ComposeResourceReference{Resource}(json, '',elem.contentList[i]); {z - Resource(DocumentReference|Binary|Media)}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseDocumentReferenceRelatesTo(element : IXmlDomElement; path : string) : TFhirDocumentReferenceRelatesTo;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseEnum(CODES_TFhirDocumentRelationshipType, path+'/code', child)
      else if (child.baseName = 'target') then
        result.target := ParseResourceReference{TFhirDocumentReference}(child, path+'/target') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceRelatesTo(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceRelatesTo);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'code', elem.Code, CODES_TFhirDocumentRelationshipType);
  ComposeResourceReference{TFhirDocumentReference}(xml, 'target', elem.target);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentReferenceRelatesTo(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReferenceRelatesTo(jsn));
end;

function TFHIRJsonParser.ParseDocumentReferenceRelatesTo(jsn : TJsonObject) : TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code')  then
      result.code := parseEnum(jsn['code'], jsn.vObj['_code'], CODES_TFhirDocumentRelationshipType);
    if jsn.has('target') then
        result.target := ParseResourceReference{TFhirDocumentReference}(jsn.vObj['target']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentReferenceRelatesTo(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceRelatesTo);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'code', elem.Code, CODES_TFhirDocumentRelationshipType, false);
  ComposeEnumProps(json, 'code', elem.Code, CODES_TFhirDocumentRelationshipType, false);
  ComposeResourceReference{TFhirDocumentReference}(json, 'target', elem.target); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseDocumentReferenceService(element : IXmlDomElement; path : string) : TFhirDocumentReferenceService;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentReferenceService.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'address') then
        result.address := ParseString(child, path+'/address') {b}
      else if (child.baseName = 'parameter') then
        result.parameterList.Add(ParseDocumentReferenceServiceParameter(child, path+'/parameter'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceService(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceService);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);
  ComposeString(xml, 'address', elem.address);
  for i := 0 to elem.parameterList.Count - 1 do
    ComposeDocumentReferenceServiceParameter(xml, 'parameter', elem.parameterList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentReferenceService(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReferenceService(jsn));
end;

function TFHIRJsonParser.ParseDocumentReferenceService(jsn : TJsonObject) : TFhirDocumentReferenceService;
begin
  result := TFhirDocumentReferenceService.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('address') or jsn.has('_address') then
        result.address := ParseString(jsn['address'], jsn.vObj['_address']);{q}
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseDocumentReferenceServiceParameter);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentReferenceService(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceService);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeStringValue(json, 'address', elem.address, false);
  ComposeStringProps(json, 'address', elem.address, false);
  if elem.parameterList.Count > 0 then
  begin
    json.valueArray('parameter');
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeDocumentReferenceServiceParameter(json, '',elem.parameterList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseDocumentReferenceServiceParameter(element : IXmlDomElement; path : string) : TFhirDocumentReferenceServiceParameter;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentReferenceServiceParameter.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.name := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'value') then
        result.value := ParseString(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceServiceParameter(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceServiceParameter);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.name);
  ComposeString(xml, 'value', elem.value);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentReferenceServiceParameter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReferenceServiceParameter(jsn));
end;

function TFHIRJsonParser.ParseDocumentReferenceServiceParameter(jsn : TJsonObject) : TFhirDocumentReferenceServiceParameter;
begin
  result := TFhirDocumentReferenceServiceParameter.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.name := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.value := ParseString(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentReferenceServiceParameter(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceServiceParameter);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.name, false);
  ComposeStringProps(json, 'name', elem.name, false);
  ComposeStringValue(json, 'value', elem.value, false);
  ComposeStringProps(json, 'value', elem.value, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseDocumentReferenceContext(element : IXmlDomElement; path : string) : TFhirDocumentReferenceContext;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentReferenceContext.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'event') then
        result.eventList.Add(ParseCodeableConcept(child, path+'/event'))
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'facilityType') then
        result.facilityType := ParseCodeableConcept(child, path+'/facilityType') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceContext(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceContext);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.eventList.Count - 1 do
    ComposeCodeableConcept(xml, 'event', elem.eventList[i]);
  ComposePeriod(xml, 'period', elem.period);
  ComposeCodeableConcept(xml, 'facilityType', elem.facilityType);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentReferenceContext(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReferenceContext(jsn));
end;

function TFHIRJsonParser.ParseDocumentReferenceContext(jsn : TJsonObject) : TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseCodeableConcept);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('facilityType') then
        result.facilityType := ParseCodeableConcept(jsn.vObj['facilityType']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentReferenceContext(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceContext);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.eventList.Count > 0 then
  begin
    json.valueArray('event');
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.eventList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposePeriod(json, 'period', elem.period); {a}
  ComposeCodeableConcept(json, 'facilityType', elem.facilityType); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseDocumentReference(element : IXmlDomElement; path : string) : TFhirDocumentReference;
var
  child : IXMLDOMElement;
begin
  result := TFhirDocumentReference.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'masterIdentifier') then
        result.masterIdentifier := ParseIdentifier(child, path+'/masterIdentifier') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'subject') then
        result.subject := ParseResourceReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'class') then
        result.class_ := ParseCodeableConcept(child, path+'/class') {b}
      else if (child.baseName = 'author') then
        result.authorList.Add(ParseResourceReference{Resource}(child, path+'/author'))
      else if (child.baseName = 'custodian') then
        result.custodian := ParseResourceReference{TFhirOrganization}(child, path+'/custodian') {b}
      else if (child.baseName = 'policyManager') then
        result.policyManager := ParseUri(child, path+'/policyManager') {b}
      else if (child.baseName = 'authenticator') then
        result.authenticator := ParseResourceReference{Resource}(child, path+'/authenticator') {b}
      else if (child.baseName = 'created') then
        result.created := ParseDateTime(child, path+'/created') {b}
      else if (child.baseName = 'indexed') then
        result.indexed := ParseInstant(child, path+'/indexed') {b}
      else if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirDocumentReferenceStatus, path+'/status', child)
      else if (child.baseName = 'docStatus') then
        result.docStatus := ParseCodeableConcept(child, path+'/docStatus') {b}
      else if (child.baseName = 'relatesTo') then
        result.relatesToList.Add(ParseDocumentReferenceRelatesTo(child, path+'/relatesTo'))
      else if (child.baseName = 'description') then
        result.description := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'confidentiality') then
        result.confidentialityList.Add(ParseCodeableConcept(child, path+'/confidentiality'))
      else if (child.baseName = 'primaryLanguage') then
        result.primaryLanguage := ParseCode(child, path+'/primaryLanguage') {b}
      else if (child.baseName = 'mimeType') then
        result.mimeType := ParseCode(child, path+'/mimeType') {b}
      else if (child.baseName = 'format') then
        result.formatList.Add(ParseUri(child, path+'/format'))
      else if (child.baseName = 'size') then
        result.size := ParseInteger(child, path+'/size') {b}
      else if (child.baseName = 'hash') then
        result.hash := ParseString(child, path+'/hash') {b}
      else if (child.baseName = 'location') then
        result.location := ParseUri(child, path+'/location') {b}
      else if (child.baseName = 'service') then
        result.service := ParseDocumentReferenceService(child, path+'/service') {b}
      else if (child.baseName = 'context') then
        result.context := ParseDocumentReferenceContext(child, path+'/context') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeDocumentReference(xml : TXmlBuilder; name : string; elem : TFhirDocumentReference);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeIdentifier(xml, 'masterIdentifier', elem.masterIdentifier);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeResourceReference{Resource}(xml, 'subject', elem.subject);
  ComposeCodeableConcept(xml, 'type', elem.type_);
  ComposeCodeableConcept(xml, 'class', elem.class_);
  for i := 0 to elem.authorList.Count - 1 do
    ComposeResourceReference{Resource}(xml, 'author', elem.authorList[i]);
  ComposeResourceReference{TFhirOrganization}(xml, 'custodian', elem.custodian);
  ComposeUri(xml, 'policyManager', elem.policyManager);
  ComposeResourceReference{Resource}(xml, 'authenticator', elem.authenticator);
  ComposeDateTime(xml, 'created', elem.created);
  ComposeInstant(xml, 'indexed', elem.indexed);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirDocumentReferenceStatus);
  ComposeCodeableConcept(xml, 'docStatus', elem.docStatus);
  for i := 0 to elem.relatesToList.Count - 1 do
    ComposeDocumentReferenceRelatesTo(xml, 'relatesTo', elem.relatesToList[i]);
  ComposeString(xml, 'description', elem.description);
  for i := 0 to elem.confidentialityList.Count - 1 do
    ComposeCodeableConcept(xml, 'confidentiality', elem.confidentialityList[i]);
  ComposeCode(xml, 'primaryLanguage', elem.primaryLanguage);
  ComposeCode(xml, 'mimeType', elem.mimeType);
  for i := 0 to elem.formatList.Count - 1 do
    ComposeUri(xml, 'format', elem.formatList[i]);
  ComposeInteger(xml, 'size', elem.size);
  ComposeString(xml, 'hash', elem.hash);
  ComposeUri(xml, 'location', elem.location);
  ComposeDocumentReferenceService(xml, 'service', elem.service);
  ComposeDocumentReferenceContext(xml, 'context', elem.context);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseDocumentReference(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReference(jsn));
end;

function TFHIRJsonParser.ParseDocumentReference(jsn : TJsonObject) : TFhirDocumentReference;
begin
  result := TFhirDocumentReference.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('masterIdentifier') then
        result.masterIdentifier := ParseIdentifier(jsn.vObj['masterIdentifier']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseResourceReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('class') then
        result.class_ := ParseCodeableConcept(jsn.vObj['class']);{q}
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseResourceReference{Resource});
    if jsn.has('custodian') then
        result.custodian := ParseResourceReference{TFhirOrganization}(jsn.vObj['custodian']);{q}
    if jsn.has('policyManager') or jsn.has('_policyManager') then
        result.policyManager := ParseUri(jsn['policyManager'], jsn.vObj['_policyManager']);{q}
    if jsn.has('authenticator') then
        result.authenticator := ParseResourceReference{Resource}(jsn.vObj['authenticator']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.created := ParseDateTime(jsn['created'], jsn.vObj['_created']);{q}
    if jsn.has('indexed') or jsn.has('_indexed') then
        result.indexed := ParseInstant(jsn['indexed'], jsn.vObj['_indexed']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirDocumentReferenceStatus);
    if jsn.has('docStatus') then
        result.docStatus := ParseCodeableConcept(jsn.vObj['docStatus']);{q}
    if jsn.has('relatesTo') then
      iterateArray(jsn.vArr['relatesTo'], result.relatesToList, parseDocumentReferenceRelatesTo);
    if jsn.has('description') or jsn.has('_description') then
        result.description := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('confidentiality') then
      iterateArray(jsn.vArr['confidentiality'], result.confidentialityList, parseCodeableConcept);
    if jsn.has('primaryLanguage') or jsn.has('_primaryLanguage') then
        result.primaryLanguage := ParseCode(jsn['primaryLanguage'], jsn.vObj['_primaryLanguage']);{q}
    if jsn.has('mimeType') or jsn.has('_mimeType') then
        result.mimeType := ParseCode(jsn['mimeType'], jsn.vObj['_mimeType']);{q}
      if jsn.has('format') or jsn.has('_format') then
      iteratePrimitiveArray(jsn.vArr['format'], jsn.vArr['_format'], result.formatList, parseUri);
    if jsn.has('size') or jsn.has('_size') then
        result.size := ParseInteger(jsn['size'], jsn.vObj['_size']);{q}
    if jsn.has('hash') or jsn.has('_hash') then
        result.hash := ParseString(jsn['hash'], jsn.vObj['_hash']);{q}
    if jsn.has('location') or jsn.has('_location') then
        result.location := ParseUri(jsn['location'], jsn.vObj['_location']);{q}
    if jsn.has('service') then
        result.service := ParseDocumentReferenceService(jsn.vObj['service']);{q}
    if jsn.has('context') then
        result.context := ParseDocumentReferenceContext(jsn.vObj['context']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeDocumentReference(json : TJSONWriter; name : string; elem : TFhirDocumentReference);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeIdentifier(json, 'masterIdentifier', elem.masterIdentifier); {a}
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeResourceReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeCodeableConcept(json, 'class', elem.class_); {a}
  if elem.authorList.Count > 0 then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeResourceReference{Resource}(json, '',elem.authorList[i]); {z - Resource(Practitioner|Device|Patient|RelatedPerson)}
    json.FinishArray;
  end;
  ComposeResourceReference{TFhirOrganization}(json, 'custodian', elem.custodian); {a}
  ComposeUriValue(json, 'policyManager', elem.policyManager, false);
  ComposeUriProps(json, 'policyManager', elem.policyManager, false);
  ComposeResourceReference{Resource}(json, 'authenticator', elem.authenticator); {a}
  ComposeDateTimeValue(json, 'created', elem.created, false);
  ComposeDateTimeProps(json, 'created', elem.created, false);
  ComposeInstantValue(json, 'indexed', elem.indexed, false);
  ComposeInstantProps(json, 'indexed', elem.indexed, false);
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirDocumentReferenceStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirDocumentReferenceStatus, false);
  ComposeCodeableConcept(json, 'docStatus', elem.docStatus); {a}
  if elem.relatesToList.Count > 0 then
  begin
    json.valueArray('relatesTo');
    for i := 0 to elem.relatesToList.Count - 1 do
      ComposeDocumentReferenceRelatesTo(json, '',elem.relatesToList[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.description, false);
  ComposeStringProps(json, 'description', elem.description, false);
  if elem.confidentialityList.Count > 0 then
  begin
    json.valueArray('confidentiality');
    for i := 0 to elem.confidentialityList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.confidentialityList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeCodeValue(json, 'primaryLanguage', elem.primaryLanguage, false);
  ComposeCodeProps(json, 'primaryLanguage', elem.primaryLanguage, false);
  ComposeCodeValue(json, 'mimeType', elem.mimeType, false);
  ComposeCodeProps(json, 'mimeType', elem.mimeType, false);
  if elem.formatList.Count > 0 then
  begin
    json.valueArray('format');
    ext := false;
    for i := 0 to elem.formatList.Count - 1 do
    begin
      ext := ext or ((elem.formatList[i].xmlid <> '') or (elem.formatList[i].hasExtensions));
      ComposeUriValue(json, '',elem.formatList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_format');
      for i := 0 to elem.formatList.Count - 1 do
        ComposeUriProps(json, '',elem.formatList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeIntegerValue(json, 'size', elem.size, false);
  ComposeIntegerProps(json, 'size', elem.size, false);
  ComposeStringValue(json, 'hash', elem.hash, false);
  ComposeStringProps(json, 'hash', elem.hash, false);
  ComposeUriValue(json, 'location', elem.location, false);
  ComposeUriProps(json, 'location', elem.location, false);
  ComposeDocumentReferenceService(json, 'service', elem.service); {a}
  ComposeDocumentReferenceContext(json, 'context', elem.context); {a}
end;

function TFHIRXmlParser.ParseEncounterParticipant(element : IXmlDomElement; path : string) : TFhirEncounterParticipant;
var
  child : IXMLDOMElement;
begin
  result := TFhirEncounterParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_List.Add(ParseCodeableConcept(child, path+'/type'))
      else if (child.baseName = 'individual') then
        result.individual := ParseResourceReference{Resource}(child, path+'/individual') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEncounterParticipant(xml : TXmlBuilder; name : string; elem : TFhirEncounterParticipant);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.type_List.Count - 1 do
    ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  ComposeResourceReference{Resource}(xml, 'individual', elem.individual);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEncounterParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterParticipant(jsn));
end;

function TFHIRJsonParser.ParseEncounterParticipant(jsn : TJsonObject) : TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('individual') then
        result.individual := ParseResourceReference{Resource}(jsn.vObj['individual']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEncounterParticipant(json : TJSONWriter; name : string; elem : TFhirEncounterParticipant);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.type_List.Count > 0 then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '',elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeResourceReference{Resource}(json, 'individual', elem.individual); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseEncounterHospitalization(element : IXmlDomElement; path : string) : TFhirEncounterHospitalization;
var
  child : IXMLDOMElement;
begin
  result := TFhirEncounterHospitalization.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'preAdmissionIdentifier') then
        result.preAdmissionIdentifier := ParseIdentifier(child, path+'/preAdmissionIdentifier') {b}
      else if (child.baseName = 'origin') then
        result.origin := ParseResourceReference{TFhirLocation}(child, path+'/origin') {b}
      else if (child.baseName = 'admitSource') then
        result.admitSource := ParseCodeableConcept(child, path+'/admitSource') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'accomodation') then
        result.accomodationList.Add(ParseEncounterHospitalizationAccomodation(child, path+'/accomodation'))
      else if (child.baseName = 'diet') then
        result.diet := ParseCodeableConcept(child, path+'/diet') {b}
      else if (child.baseName = 'specialCourtesy') then
        result.specialCourtesyList.Add(ParseCodeableConcept(child, path+'/specialCourtesy'))
      else if (child.baseName = 'specialArrangement') then
        result.specialArrangementList.Add(ParseCodeableConcept(child, path+'/specialArrangement'))
      else if (child.baseName = 'destination') then
        result.destination := ParseResourceReference{TFhirLocation}(child, path+'/destination') {b}
      else if (child.baseName = 'dischargeDisposition') then
        result.dischargeDisposition := ParseCodeableConcept(child, path+'/dischargeDisposition') {b}
      else if (child.baseName = 'dischargeDiagnosis') then
        result.dischargeDiagnosis := ParseResourceReference{Resource}(child, path+'/dischargeDiagnosis') {b}
      else if (child.baseName = 'reAdmission') then
        result.reAdmission := ParseBoolean(child, path+'/reAdmission') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEncounterHospitalization(xml : TXmlBuilder; name : string; elem : TFhirEncounterHospitalization);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeIdentifier(xml, 'preAdmissionIdentifier', elem.preAdmissionIdentifier);
  ComposeResourceReference{TFhirLocation}(xml, 'origin', elem.origin);
  ComposeCodeableConcept(xml, 'admitSource', elem.admitSource);
  ComposePeriod(xml, 'period', elem.period);
  for i := 0 to elem.accomodationList.Count - 1 do
    ComposeEncounterHospitalizationAccomodation(xml, 'accomodation', elem.accomodationList[i]);
  ComposeCodeableConcept(xml, 'diet', elem.diet);
  for i := 0 to elem.specialCourtesyList.Count - 1 do
    ComposeCodeableConcept(xml, 'specialCourtesy', elem.specialCourtesyList[i]);
  for i := 0 to elem.specialArrangementList.Count - 1 do
    ComposeCodeableConcept(xml, 'specialArrangement', elem.specialArrangementList[i]);
  ComposeResourceReference{TFhirLocation}(xml, 'destination', elem.destination);
  ComposeCodeableConcept(xml, 'dischargeDisposition', elem.dischargeDisposition);
  ComposeResourceReference{Resource}(xml, 'dischargeDiagnosis', elem.dischargeDiagnosis);
  ComposeBoolean(xml, 'reAdmission', elem.reAdmission);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEncounterHospitalization(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterHospitalization(jsn));
end;

function TFHIRJsonParser.ParseEncounterHospitalization(jsn : TJsonObject) : TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('preAdmissionIdentifier') then
        result.preAdmissionIdentifier := ParseIdentifier(jsn.vObj['preAdmissionIdentifier']);{q}
    if jsn.has('origin') then
        result.origin := ParseResourceReference{TFhirLocation}(jsn.vObj['origin']);{q}
    if jsn.has('admitSource') then
        result.admitSource := ParseCodeableConcept(jsn.vObj['admitSource']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('accomodation') then
      iterateArray(jsn.vArr['accomodation'], result.accomodationList, parseEncounterHospitalizationAccomodation);
    if jsn.has('diet') then
        result.diet := ParseCodeableConcept(jsn.vObj['diet']);{q}
    if jsn.has('specialCourtesy') then
      iterateArray(jsn.vArr['specialCourtesy'], result.specialCourtesyList, parseCodeableConcept);
    if jsn.has('specialArrangement') then
      iterateArray(jsn.vArr['specialArrangement'], result.specialArrangementList, parseCodeableConcept);
    if jsn.has('destination') then
        result.destination := ParseResourceReference{TFhirLocation}(jsn.vObj['destination']);{q}
    if jsn.has('dischargeDisposition') then
        result.dischargeDisposition := ParseCodeableConcept(jsn.vObj['dischargeDisposition']);{q}
    if jsn.has('dischargeDiagnosis') then
        result.dischargeDiagnosis := ParseResourceReference{Resource}(jsn.vObj['dischargeDiagnosis']);{q}
    if jsn.has('reAdmission') or jsn.has('_reAdmission') then
        result.reAdmission := ParseBoolean(jsn['reAdmission'], jsn.vObj['_reAdmission']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEncounterHospitalization(json : TJSONWriter; name : string; elem : TFhirEncounterHospitalization);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdentifier(json, 'preAdmissionIdentifier', elem.preAdmissionIdentifier); {a}
  ComposeResourceReference{TFhirLocation}(json, 'origin', elem.origin); {a}
  ComposeCodeableConcept(json, 'admitSource', elem.admitSource); {a}
  ComposePeriod(json, 'period', elem.period); {a}
  if elem.accomodationList.Count > 0 then
  begin
    json.valueArray('accomodation');
    for i := 0 to elem.accomodationList.Count - 1 do
      ComposeEncounterHospitalizationAccomodation(json, '',elem.accomodationList[i]); {z - }
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'diet', elem.diet); {a}
  if elem.specialCourtesyList.Count > 0 then
  begin
    json.valueArray('specialCourtesy');
    for i := 0 to elem.specialCourtesyList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.specialCourtesyList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.specialArrangementList.Count > 0 then
  begin
    json.valueArray('specialArrangement');
    for i := 0 to elem.specialArrangementList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.specialArrangementList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeResourceReference{TFhirLocation}(json, 'destination', elem.destination); {a}
  ComposeCodeableConcept(json, 'dischargeDisposition', elem.dischargeDisposition); {a}
  ComposeResourceReference{Resource}(json, 'dischargeDiagnosis', elem.dischargeDiagnosis); {a}
  ComposeBooleanValue(json, 'reAdmission', elem.reAdmission, false);
  ComposeBooleanProps(json, 'reAdmission', elem.reAdmission, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseEncounterHospitalizationAccomodation(element : IXmlDomElement; path : string) : TFhirEncounterHospitalizationAccomodation;
var
  child : IXMLDOMElement;
begin
  result := TFhirEncounterHospitalizationAccomodation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'bed') then
        result.bed := ParseResourceReference{TFhirLocation}(child, path+'/bed') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEncounterHospitalizationAccomodation(xml : TXmlBuilder; name : string; elem : TFhirEncounterHospitalizationAccomodation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeResourceReference{TFhirLocation}(xml, 'bed', elem.bed);
  ComposePeriod(xml, 'period', elem.period);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEncounterHospitalizationAccomodation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterHospitalizationAccomodation(jsn));
end;

function TFHIRJsonParser.ParseEncounterHospitalizationAccomodation(jsn : TJsonObject) : TFhirEncounterHospitalizationAccomodation;
begin
  result := TFhirEncounterHospitalizationAccomodation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('bed') then
        result.bed := ParseResourceReference{TFhirLocation}(jsn.vObj['bed']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEncounterHospitalizationAccomodation(json : TJSONWriter; name : string; elem : TFhirEncounterHospitalizationAccomodation);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeResourceReference{TFhirLocation}(json, 'bed', elem.bed); {a}
  ComposePeriod(json, 'period', elem.period); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseEncounterLocation(element : IXmlDomElement; path : string) : TFhirEncounterLocation;
var
  child : IXMLDOMElement;
begin
  result := TFhirEncounterLocation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'location') then
        result.location := ParseResourceReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEncounterLocation(xml : TXmlBuilder; name : string; elem : TFhirEncounterLocation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeResourceReference{TFhirLocation}(xml, 'location', elem.location);
  ComposePeriod(xml, 'period', elem.period);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEncounterLocation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterLocation(jsn));
end;

function TFHIRJsonParser.ParseEncounterLocation(jsn : TJsonObject) : TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('location') then
        result.location := ParseResourceReference{TFhirLocation}(jsn.vObj['location']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEncounterLocation(json : TJSONWriter; name : string; elem : TFhirEncounterLocation);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeResourceReference{TFhirLocation}(json, 'location', elem.location); {a}
  ComposePeriod(json, 'period', elem.period); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseEncounter(element : IXmlDomElement; path : string) : TFhirEncounter;
var
  child : IXMLDOMElement;
begin
  result := TFhirEncounter.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirEncounterState, path+'/status', child)
      else if (child.baseName = 'class') then
        result.class_ := ParseEnum(CODES_TFhirEncounterClass, path+'/class', child)
      else if (child.baseName = 'type') then
        result.type_List.Add(ParseCodeableConcept(child, path+'/type'))
      else if (child.baseName = 'subject') then
        result.subject := ParseResourceReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'participant') then
        result.participantList.Add(ParseEncounterParticipant(child, path+'/participant'))
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'length') then
        result.length := ParseQuantity(child, path+'/length') {b}
      else if (child.baseName = 'reason') then
        result.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if (child.baseName = 'indication') then
        result.indication := ParseResourceReference{Resource}(child, path+'/indication') {b}
      else if (child.baseName = 'priority') then
        result.priority := ParseCodeableConcept(child, path+'/priority') {b}
      else if (child.baseName = 'hospitalization') then
        result.hospitalization := ParseEncounterHospitalization(child, path+'/hospitalization') {b}
      else if (child.baseName = 'location') then
        result.locationList.Add(ParseEncounterLocation(child, path+'/location'))
      else if (child.baseName = 'serviceProvider') then
        result.serviceProvider := ParseResourceReference{TFhirOrganization}(child, path+'/serviceProvider') {b}
      else if (child.baseName = 'partOf') then
        result.partOf := ParseResourceReference{TFhirEncounter}(child, path+'/partOf') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeEncounter(xml : TXmlBuilder; name : string; elem : TFhirEncounter);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirEncounterState);
  ComposeEnum(xml, 'class', elem.Class_, CODES_TFhirEncounterClass);
  for i := 0 to elem.type_List.Count - 1 do
    ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  ComposeResourceReference{TFhirPatient}(xml, 'subject', elem.subject);
  for i := 0 to elem.participantList.Count - 1 do
    ComposeEncounterParticipant(xml, 'participant', elem.participantList[i]);
  if not SummaryOnly then
    ComposePeriod(xml, 'period', elem.period);
  if not SummaryOnly then
    ComposeQuantity(xml, 'length', elem.length);
  ComposeCodeableConcept(xml, 'reason', elem.reason);
  if not SummaryOnly then
    ComposeResourceReference{Resource}(xml, 'indication', elem.indication);
  if not SummaryOnly then
    ComposeCodeableConcept(xml, 'priority', elem.priority);
  if not SummaryOnly then
    ComposeEncounterHospitalization(xml, 'hospitalization', elem.hospitalization);
  if not SummaryOnly then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeEncounterLocation(xml, 'location', elem.locationList[i]);
  if not SummaryOnly then
    ComposeResourceReference{TFhirOrganization}(xml, 'serviceProvider', elem.serviceProvider);
  if not SummaryOnly then
    ComposeResourceReference{TFhirEncounter}(xml, 'partOf', elem.partOf);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseEncounter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounter(jsn));
end;

function TFHIRJsonParser.ParseEncounter(jsn : TJsonObject) : TFhirEncounter;
begin
  result := TFhirEncounter.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirEncounterState);
    if jsn.has('class') or jsn.has('_class')  then
      result.class_ := parseEnum(jsn['class'], jsn.vObj['_class'], CODES_TFhirEncounterClass);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('subject') then
        result.subject := ParseResourceReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseEncounterParticipant);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('length') then
        result.length := ParseQuantity(jsn.vObj['length']);{q}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q}
    if jsn.has('indication') then
        result.indication := ParseResourceReference{Resource}(jsn.vObj['indication']);{q}
    if jsn.has('priority') then
        result.priority := ParseCodeableConcept(jsn.vObj['priority']);{q}
    if jsn.has('hospitalization') then
        result.hospitalization := ParseEncounterHospitalization(jsn.vObj['hospitalization']);{q}
    if jsn.has('location') then
      iterateArray(jsn.vArr['location'], result.locationList, parseEncounterLocation);
    if jsn.has('serviceProvider') then
        result.serviceProvider := ParseResourceReference{TFhirOrganization}(jsn.vObj['serviceProvider']);{q}
    if jsn.has('partOf') then
        result.partOf := ParseResourceReference{TFhirEncounter}(jsn.vObj['partOf']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeEncounter(json : TJSONWriter; name : string; elem : TFhirEncounter);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirEncounterState, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirEncounterState, false);
  ComposeEnumValue(json, 'class', elem.Class_, CODES_TFhirEncounterClass, false);
  ComposeEnumProps(json, 'class', elem.Class_, CODES_TFhirEncounterClass, false);
  if elem.type_List.Count > 0 then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '',elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeResourceReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if elem.participantList.Count > 0 then
  begin
    json.valueArray('participant');
    for i := 0 to elem.participantList.Count - 1 do
      ComposeEncounterParticipant(json, '',elem.participantList[i]); {z - }
    json.FinishArray;
  end;
  if not SummaryOnly then
    ComposePeriod(json, 'period', elem.period); {a}
  if not SummaryOnly then
    ComposeQuantity(json, 'length', elem.length); {a}
  ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  if not SummaryOnly then
    ComposeResourceReference{Resource}(json, 'indication', elem.indication); {a}
  if not SummaryOnly then
    ComposeCodeableConcept(json, 'priority', elem.priority); {a}
  if not SummaryOnly then
    ComposeEncounterHospitalization(json, 'hospitalization', elem.hospitalization); {a}
  if not SummaryOnly and (elem.locationList.Count > 0) then
  begin
    json.valueArray('location');
    for i := 0 to elem.locationList.Count - 1 do
      ComposeEncounterLocation(json, '',elem.locationList[i]); {z - }
    json.FinishArray;
  end;
  if not SummaryOnly then
    ComposeResourceReference{TFhirOrganization}(json, 'serviceProvider', elem.serviceProvider); {a}
  if not SummaryOnly then
    ComposeResourceReference{TFhirEncounter}(json, 'partOf', elem.partOf); {a}
end;

function TFHIRXmlParser.ParseFamilyHistoryRelation(element : IXmlDomElement; path : string) : TFhirFamilyHistoryRelation;
var
  child : IXMLDOMElement;
begin
  result := TFhirFamilyHistoryRelation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.name := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'relationship') then
        result.relationship := ParseCodeableConcept(child, path+'/relationship') {b}
      else if (child.baseName = 'bornPeriod') then
        result.born := ParsePeriod(child, path+'/bornPeriod')
      else if (child.baseName = 'bornDate') then
        result.born := ParseDate(child, path+'/bornDate')
      else if (child.baseName = 'bornString') then
        result.born := ParseString(child, path+'/bornString')
      else if (child.baseName = 'deceasedBoolean') then
        result.deceased := ParseBoolean(child, path+'/deceasedBoolean')
      else if (child.baseName = 'deceasedAge') then
        result.deceased := ParseAge(child, path+'/deceasedAge')
      else if (child.baseName = 'deceasedRange') then
        result.deceased := ParseRange(child, path+'/deceasedRange')
      else if (child.baseName = 'deceasedDate') then
        result.deceased := ParseDate(child, path+'/deceasedDate')
      else if (child.baseName = 'deceasedString') then
        result.deceased := ParseString(child, path+'/deceasedString')
      else if (child.baseName = 'note') then
        result.note := ParseString(child, path+'/note') {b}
      else if (child.baseName = 'condition') then
        result.conditionList.Add(ParseFamilyHistoryRelationCondition(child, path+'/condition'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeFamilyHistoryRelation(xml : TXmlBuilder; name : string; elem : TFhirFamilyHistoryRelation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.name);
  ComposeCodeableConcept(xml, 'relationship', elem.relationship);
  if (elem.born is TFhirPeriod) {6} then
    ComposePeriod(xml, 'bornPeriod', TFhirPeriod(elem.born))
  else if (elem.born is TFhirDate) {6} then
    ComposeDate(xml, 'bornDate', TFhirDate(elem.born))
  else if (elem.born is TFhirString) {6} then
    ComposeString(xml, 'bornString', TFhirString(elem.born));
  if (elem.deceased is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'deceasedBoolean', TFhirBoolean(elem.deceased))
  else if (elem.deceased is TFhirQuantity) {6} then
    ComposeAge(xml, 'deceasedAge', TFhirQuantity(elem.deceased))
  else if (elem.deceased is TFhirRange) {6} then
    ComposeRange(xml, 'deceasedRange', TFhirRange(elem.deceased))
  else if (elem.deceased is TFhirDate) {6} then
    ComposeDate(xml, 'deceasedDate', TFhirDate(elem.deceased))
  else if (elem.deceased is TFhirString) {6} then
    ComposeString(xml, 'deceasedString', TFhirString(elem.deceased));
  ComposeString(xml, 'note', elem.note);
  for i := 0 to elem.conditionList.Count - 1 do
    ComposeFamilyHistoryRelationCondition(xml, 'condition', elem.conditionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseFamilyHistoryRelation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseFamilyHistoryRelation(jsn));
end;

function TFHIRJsonParser.ParseFamilyHistoryRelation(jsn : TJsonObject) : TFhirFamilyHistoryRelation;
begin
  result := TFhirFamilyHistoryRelation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.name := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('relationship') then
        result.relationship := ParseCodeableConcept(jsn.vObj['relationship']);{q}
    if jsn.has('bornPeriod') {a4} then
      result.born := ParsePeriod(jsn.vObj['bornPeriod']);
    if jsn.has('bornDate') or jsn.has('_bornDate') then
      result.born := parseDate(jsn['bornDate'], jsn.vObj['_bornDate']);
    if jsn.has('bornString') or jsn.has('_bornString') then
      result.born := parseString(jsn['bornString'], jsn.vObj['_bornString']);
    if jsn.has('deceasedBoolean') or jsn.has('_deceasedBoolean') then
      result.deceased := parseBoolean(jsn['deceasedBoolean'], jsn.vObj['_deceasedBoolean']);
    if jsn.has('deceasedAge') {a4} then
      result.deceased := ParseAge(jsn.vObj['deceasedAge']);
    if jsn.has('deceasedRange') {a4} then
      result.deceased := ParseRange(jsn.vObj['deceasedRange']);
    if jsn.has('deceasedDate') or jsn.has('_deceasedDate') then
      result.deceased := parseDate(jsn['deceasedDate'], jsn.vObj['_deceasedDate']);
    if jsn.has('deceasedString') or jsn.has('_deceasedString') then
      result.deceased := parseString(jsn['deceasedString'], jsn.vObj['_deceasedString']);
    if jsn.has('note') or jsn.has('_note') then
        result.note := ParseString(jsn['note'], jsn.vObj['_note']);{q}
    if jsn.has('condition') then
      iterateArray(jsn.vArr['condition'], result.conditionList, parseFamilyHistoryRelationCondition);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeFamilyHistoryRelation(json : TJSONWriter; name : string; elem : TFhirFamilyHistoryRelation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.name, false);
  ComposeStringProps(json, 'name', elem.name, false);
  ComposeCodeableConcept(json, 'relationship', elem.relationship); {a}
  if (elem.born is TFhirPeriod) then 
    ComposePeriod(json, 'bornPeriod', TFhirPeriod(elem.born)) 
  else if (elem.born is TFhirDate) then 
  begin
    ComposeDateValue(json, 'bornDate', TFhirDate(elem.born), false);
    ComposeDateProps(json, 'bornDate', TFhirDate(elem.born), false);
  end
  else if (elem.born is TFhirString) then 
  begin
    ComposeStringValue(json, 'bornString', TFhirString(elem.born), false);
    ComposeStringProps(json, 'bornString', TFhirString(elem.born), false);
  end;
  if (elem.deceased is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'deceasedBoolean', TFhirBoolean(elem.deceased), false);
    ComposeBooleanProps(json, 'deceasedBoolean', TFhirBoolean(elem.deceased), false);
  end
  else if (elem.deceased is TFhirQuantity) then 
    ComposeAge(json, 'deceasedAge', TFhirQuantity(elem.deceased)) 
  else if (elem.deceased is TFhirRange) then 
    ComposeRange(json, 'deceasedRange', TFhirRange(elem.deceased)) 
  else if (elem.deceased is TFhirDate) then 
  begin
    ComposeDateValue(json, 'deceasedDate', TFhirDate(elem.deceased), false);
    ComposeDateProps(json, 'deceasedDate', TFhirDate(elem.deceased), false);
  end
  else if (elem.deceased is TFhirString) then 
  begin
    ComposeStringValue(json, 'deceasedString', TFhirString(elem.deceased), false);
    ComposeStringProps(json, 'deceasedString', TFhirString(elem.deceased), false);
  end;
  ComposeStringValue(json, 'note', elem.note, false);
  ComposeStringProps(json, 'note', elem.note, false);
  if elem.conditionList.Count > 0 then
  begin
    json.valueArray('condition');
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeFamilyHistoryRelationCondition(json, '',elem.conditionList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseFamilyHistoryRelationCondition(element : IXmlDomElement; path : string) : TFhirFamilyHistoryRelationCondition;
var
  child : IXMLDOMElement;
begin
  result := TFhirFamilyHistoryRelationCondition.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'outcome') then
        result.outcome := ParseCodeableConcept(child, path+'/outcome') {b}
      else if (child.baseName = 'onsetAge') then
        result.onset := ParseAge(child, path+'/onsetAge')
      else if (child.baseName = 'onsetRange') then
        result.onset := ParseRange(child, path+'/onsetRange')
      else if (child.baseName = 'onsetString') then
        result.onset := ParseString(child, path+'/onsetString')
      else if (child.baseName = 'note') then
        result.note := ParseString(child, path+'/note') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeFamilyHistoryRelationCondition(xml : TXmlBuilder; name : string; elem : TFhirFamilyHistoryRelationCondition);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);
  ComposeCodeableConcept(xml, 'outcome', elem.outcome);
  if (elem.onset is TFhirQuantity) {6} then
    ComposeAge(xml, 'onsetAge', TFhirQuantity(elem.onset))
  else if (elem.onset is TFhirRange) {6} then
    ComposeRange(xml, 'onsetRange', TFhirRange(elem.onset))
  else if (elem.onset is TFhirString) {6} then
    ComposeString(xml, 'onsetString', TFhirString(elem.onset));
  ComposeString(xml, 'note', elem.note);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseFamilyHistoryRelationCondition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseFamilyHistoryRelationCondition(jsn));
end;

function TFHIRJsonParser.ParseFamilyHistoryRelationCondition(jsn : TJsonObject) : TFhirFamilyHistoryRelationCondition;
begin
  result := TFhirFamilyHistoryRelationCondition.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('outcome') then
        result.outcome := ParseCodeableConcept(jsn.vObj['outcome']);{q}
    if jsn.has('onsetAge') {a4} then
      result.onset := ParseAge(jsn.vObj['onsetAge']);
    if jsn.has('onsetRange') {a4} then
      result.onset := ParseRange(jsn.vObj['onsetRange']);
    if jsn.has('onsetString') or jsn.has('_onsetString') then
      result.onset := parseString(jsn['onsetString'], jsn.vObj['_onsetString']);
    if jsn.has('note') or jsn.has('_note') then
        result.note := ParseString(jsn['note'], jsn.vObj['_note']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeFamilyHistoryRelationCondition(json : TJSONWriter; name : string; elem : TFhirFamilyHistoryRelationCondition);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeCodeableConcept(json, 'outcome', elem.outcome); {a}
  if (elem.onset is TFhirQuantity) then 
    ComposeAge(json, 'onsetAge', TFhirQuantity(elem.onset)) 
  else if (elem.onset is TFhirRange) then 
    ComposeRange(json, 'onsetRange', TFhirRange(elem.onset)) 
  else if (elem.onset is TFhirString) then 
  begin
    ComposeStringValue(json, 'onsetString', TFhirString(elem.onset), false);
    ComposeStringProps(json, 'onsetString', TFhirString(elem.onset), false);
  end;
  ComposeStringValue(json, 'note', elem.note, false);
  ComposeStringProps(json, 'note', elem.note, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseFamilyHistory(element : IXmlDomElement; path : string) : TFhirFamilyHistory;
var
  child : IXMLDOMElement;
begin
  result := TFhirFamilyHistory.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'subject') then
        result.subject := ParseResourceReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'note') then
        result.note := ParseString(child, path+'/note') {b}
      else if (child.baseName = 'relation') then
        result.relationList.Add(ParseFamilyHistoryRelation(child, path+'/relation'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeFamilyHistory(xml : TXmlBuilder; name : string; elem : TFhirFamilyHistory);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeResourceReference{TFhirPatient}(xml, 'subject', elem.subject);
  if not SummaryOnly then
    ComposeString(xml, 'note', elem.note);
  if not SummaryOnly then
    for i := 0 to elem.relationList.Count - 1 do
      ComposeFamilyHistoryRelation(xml, 'relation', elem.relationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseFamilyHistory(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseFamilyHistory(jsn));
end;

function TFHIRJsonParser.ParseFamilyHistory(jsn : TJsonObject) : TFhirFamilyHistory;
begin
  result := TFhirFamilyHistory.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseResourceReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('note') or jsn.has('_note') then
        result.note := ParseString(jsn['note'], jsn.vObj['_note']);{q}
    if jsn.has('relation') then
      iterateArray(jsn.vArr['relation'], result.relationList, parseFamilyHistoryRelation);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeFamilyHistory(json : TJSONWriter; name : string; elem : TFhirFamilyHistory);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeResourceReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if not SummaryOnly then
    ComposeStringValue(json, 'note', elem.note, false);
  if not SummaryOnly then
    ComposeStringProps(json, 'note', elem.note, false);
  if not SummaryOnly and (elem.relationList.Count > 0) then
  begin
    json.valueArray('relation');
    for i := 0 to elem.relationList.Count - 1 do
      ComposeFamilyHistoryRelation(json, '',elem.relationList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseGroupCharacteristic(element : IXmlDomElement; path : string) : TFhirGroupCharacteristic;
var
  child : IXMLDOMElement;
begin
  result := TFhirGroupCharacteristic.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'valueCodeableConcept') then
        result.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.baseName = 'valueBoolean') then
        result.value := ParseBoolean(child, path+'/valueBoolean')
      else if (child.baseName = 'valueQuantity') then
        result.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.baseName = 'valueRange') then
        result.value := ParseRange(child, path+'/valueRange')
      else if (child.baseName = 'exclude') then
        result.exclude := ParseBoolean(child, path+'/exclude') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeGroupCharacteristic(xml : TXmlBuilder; name : string; elem : TFhirGroupCharacteristic);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);
  if (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value));
  ComposeBoolean(xml, 'exclude', elem.exclude);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseGroupCharacteristic(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGroupCharacteristic(jsn));
end;

function TFHIRJsonParser.ParseGroupCharacteristic(jsn : TJsonObject) : TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('valueCodeableConcept') {a4} then
      result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueRange') {a4} then
      result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('exclude') or jsn.has('_exclude') then
        result.exclude := ParseBoolean(jsn['exclude'], jsn.vObj['_exclude']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeGroupCharacteristic(json : TJSONWriter; name : string; elem : TFhirGroupCharacteristic);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (elem.value is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value)) 
  else if (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (elem.value is TFhirRange) then 
    ComposeRange(json, 'valueRange', TFhirRange(elem.value)) ;
  ComposeBooleanValue(json, 'exclude', elem.exclude, false);
  ComposeBooleanProps(json, 'exclude', elem.exclude, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseGroup(element : IXmlDomElement; path : string) : TFhirGroup;
var
  child : IXMLDOMElement;
begin
  result := TFhirGroup.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseEnum(CODES_TFhirGroupType, path+'/type', child)
      else if (child.baseName = 'actual') then
        result.actual := ParseBoolean(child, path+'/actual') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'name') then
        result.name := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseInteger(child, path+'/quantity') {b}
      else if (child.baseName = 'characteristic') then
        result.characteristicList.Add(ParseGroupCharacteristic(child, path+'/characteristic'))
      else if (child.baseName = 'member') then
        result.memberList.Add(ParseResourceReference{Resource}(child, path+'/member'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeGroup(xml : TXmlBuilder; name : string; elem : TFhirGroup);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);
  ComposeEnum(xml, 'type', elem.Type_, CODES_TFhirGroupType);
  ComposeBoolean(xml, 'actual', elem.actual);
  ComposeCodeableConcept(xml, 'code', elem.code);
  ComposeString(xml, 'name', elem.name);
  ComposeInteger(xml, 'quantity', elem.quantity);
  if not SummaryOnly then
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeGroupCharacteristic(xml, 'characteristic', elem.characteristicList[i]);
  if not SummaryOnly then
    for i := 0 to elem.memberList.Count - 1 do
      ComposeResourceReference{Resource}(xml, 'member', elem.memberList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseGroup(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGroup(jsn));
end;

function TFHIRJsonParser.ParseGroup(jsn : TJsonObject) : TFhirGroup;
begin
  result := TFhirGroup.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_ := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirGroupType);
    if jsn.has('actual') or jsn.has('_actual') then
        result.actual := ParseBoolean(jsn['actual'], jsn.vObj['_actual']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.name := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('quantity') or jsn.has('_quantity') then
        result.quantity := ParseInteger(jsn['quantity'], jsn.vObj['_quantity']);{q}
    if jsn.has('characteristic') then
      iterateArray(jsn.vArr['characteristic'], result.characteristicList, parseGroupCharacteristic);
    if jsn.has('member') then
      iterateArray(jsn.vArr['member'], result.memberList, parseResourceReference{Resource});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeGroup(json : TJSONWriter; name : string; elem : TFhirGroup);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeEnumValue(json, 'type', elem.Type_, CODES_TFhirGroupType, false);
  ComposeEnumProps(json, 'type', elem.Type_, CODES_TFhirGroupType, false);
  ComposeBooleanValue(json, 'actual', elem.actual, false);
  ComposeBooleanProps(json, 'actual', elem.actual, false);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeStringValue(json, 'name', elem.name, false);
  ComposeStringProps(json, 'name', elem.name, false);
  ComposeIntegerValue(json, 'quantity', elem.quantity, false);
  ComposeIntegerProps(json, 'quantity', elem.quantity, false);
  if not SummaryOnly and (elem.characteristicList.Count > 0) then
  begin
    json.valueArray('characteristic');
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeGroupCharacteristic(json, '',elem.characteristicList[i]); {z - }
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.memberList.Count > 0) then
  begin
    json.valueArray('member');
    for i := 0 to elem.memberList.Count - 1 do
      ComposeResourceReference{Resource}(json, '',elem.memberList[i]); {z - Resource(Patient|Practitioner|Device|Medication|Substance)}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseImagingStudySeries(element : IXmlDomElement; path : string) : TFhirImagingStudySeries;
var
  child : IXMLDOMElement;
begin
  result := TFhirImagingStudySeries.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'number') then
        result.number := ParseInteger(child, path+'/number') {b}
      else if (child.baseName = 'modality') then
        result.modality := ParseEnum(CODES_TFhirModality, path+'/modality', child)
      else if (child.baseName = 'uid') then
        result.uid := ParseOid(child, path+'/uid') {b}
      else if (child.baseName = 'description') then
        result.description := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'numberOfInstances') then
        result.numberOfInstances := ParseInteger(child, path+'/numberOfInstances') {b}
      else if (child.baseName = 'availability') then
        result.availability := ParseEnum(CODES_TFhirInstanceAvailability, path+'/availability', child)
      else if (child.baseName = 'url') then
        result.url := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'bodySite') then
        result.bodySite := ParseCoding(child, path+'/bodySite') {b}
      else if (child.baseName = 'dateTime') then
        result.dateTime := ParseDateTime(child, path+'/dateTime') {b}
      else if (child.baseName = 'instance') then
        result.instanceList.Add(ParseImagingStudySeriesInstance(child, path+'/instance'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImagingStudySeries(xml : TXmlBuilder; name : string; elem : TFhirImagingStudySeries);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeInteger(xml, 'number', elem.number);
  ComposeEnum(xml, 'modality', elem.Modality, CODES_TFhirModality);
  ComposeOid(xml, 'uid', elem.uid);
  ComposeString(xml, 'description', elem.description);
  ComposeInteger(xml, 'numberOfInstances', elem.numberOfInstances);
  ComposeEnum(xml, 'availability', elem.Availability, CODES_TFhirInstanceAvailability);
  ComposeUri(xml, 'url', elem.url);
  ComposeCoding(xml, 'bodySite', elem.bodySite);
  ComposeDateTime(xml, 'dateTime', elem.dateTime);
  for i := 0 to elem.instanceList.Count - 1 do
    ComposeImagingStudySeriesInstance(xml, 'instance', elem.instanceList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImagingStudySeries(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingStudySeries(jsn));
end;

function TFHIRJsonParser.ParseImagingStudySeries(jsn : TJsonObject) : TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('number') or jsn.has('_number') then
        result.number := ParseInteger(jsn['number'], jsn.vObj['_number']);{q}
    if jsn.has('modality') or jsn.has('_modality')  then
      result.modality := parseEnum(jsn['modality'], jsn.vObj['_modality'], CODES_TFhirModality);
    if jsn.has('uid') or jsn.has('_uid') then
        result.uid := ParseOid(jsn['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.description := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('numberOfInstances') or jsn.has('_numberOfInstances') then
        result.numberOfInstances := ParseInteger(jsn['numberOfInstances'], jsn.vObj['_numberOfInstances']);{q}
    if jsn.has('availability') or jsn.has('_availability')  then
      result.availability := parseEnum(jsn['availability'], jsn.vObj['_availability'], CODES_TFhirInstanceAvailability);
    if jsn.has('url') or jsn.has('_url') then
        result.url := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('bodySite') then
        result.bodySite := ParseCoding(jsn.vObj['bodySite']);{q}
    if jsn.has('dateTime') or jsn.has('_dateTime') then
        result.dateTime := ParseDateTime(jsn['dateTime'], jsn.vObj['_dateTime']);{q}
    if jsn.has('instance') then
      iterateArray(jsn.vArr['instance'], result.instanceList, parseImagingStudySeriesInstance);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImagingStudySeries(json : TJSONWriter; name : string; elem : TFhirImagingStudySeries);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIntegerValue(json, 'number', elem.number, false);
  ComposeIntegerProps(json, 'number', elem.number, false);
  ComposeEnumValue(json, 'modality', elem.Modality, CODES_TFhirModality, false);
  ComposeEnumProps(json, 'modality', elem.Modality, CODES_TFhirModality, false);
  ComposeOidValue(json, 'uid', elem.uid, false);
  ComposeOidProps(json, 'uid', elem.uid, false);
  ComposeStringValue(json, 'description', elem.description, false);
  ComposeStringProps(json, 'description', elem.description, false);
  ComposeIntegerValue(json, 'numberOfInstances', elem.numberOfInstances, false);
  ComposeIntegerProps(json, 'numberOfInstances', elem.numberOfInstances, false);
  ComposeEnumValue(json, 'availability', elem.Availability, CODES_TFhirInstanceAvailability, false);
  ComposeEnumProps(json, 'availability', elem.Availability, CODES_TFhirInstanceAvailability, false);
  ComposeUriValue(json, 'url', elem.url, false);
  ComposeUriProps(json, 'url', elem.url, false);
  ComposeCoding(json, 'bodySite', elem.bodySite); {a}
  ComposeDateTimeValue(json, 'dateTime', elem.dateTime, false);
  ComposeDateTimeProps(json, 'dateTime', elem.dateTime, false);
  if elem.instanceList.Count > 0 then
  begin
    json.valueArray('instance');
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeImagingStudySeriesInstance(json, '',elem.instanceList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseImagingStudySeriesInstance(element : IXmlDomElement; path : string) : TFhirImagingStudySeriesInstance;
var
  child : IXMLDOMElement;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'number') then
        result.number := ParseInteger(child, path+'/number') {b}
      else if (child.baseName = 'uid') then
        result.uid := ParseOid(child, path+'/uid') {b}
      else if (child.baseName = 'sopclass') then
        result.sopclass := ParseOid(child, path+'/sopclass') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseString(child, path+'/type') {b}
      else if (child.baseName = 'title') then
        result.title := ParseString(child, path+'/title') {b}
      else if (child.baseName = 'url') then
        result.url := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'attachment') then
        result.attachment := ParseResourceReference{Resource}(child, path+'/attachment') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImagingStudySeriesInstance(xml : TXmlBuilder; name : string; elem : TFhirImagingStudySeriesInstance);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeInteger(xml, 'number', elem.number);
  ComposeOid(xml, 'uid', elem.uid);
  ComposeOid(xml, 'sopclass', elem.sopclass);
  ComposeString(xml, 'type', elem.type_);
  ComposeString(xml, 'title', elem.title);
  ComposeUri(xml, 'url', elem.url);
  ComposeResourceReference{Resource}(xml, 'attachment', elem.attachment);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImagingStudySeriesInstance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingStudySeriesInstance(jsn));
end;

function TFHIRJsonParser.ParseImagingStudySeriesInstance(jsn : TJsonObject) : TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('number') or jsn.has('_number') then
        result.number := ParseInteger(jsn['number'], jsn.vObj['_number']);{q}
    if jsn.has('uid') or jsn.has('_uid') then
        result.uid := ParseOid(jsn['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('sopclass') or jsn.has('_sopclass') then
        result.sopclass := ParseOid(jsn['sopclass'], jsn.vObj['_sopclass']);{q}
    if jsn.has('type') or jsn.has('_type') then
        result.type_ := ParseString(jsn['type'], jsn.vObj['_type']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.title := ParseString(jsn['title'], jsn.vObj['_title']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.url := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('attachment') then
        result.attachment := ParseResourceReference{Resource}(jsn.vObj['attachment']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImagingStudySeriesInstance(json : TJSONWriter; name : string; elem : TFhirImagingStudySeriesInstance);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIntegerValue(json, 'number', elem.number, false);
  ComposeIntegerProps(json, 'number', elem.number, false);
  ComposeOidValue(json, 'uid', elem.uid, false);
  ComposeOidProps(json, 'uid', elem.uid, false);
  ComposeOidValue(json, 'sopclass', elem.sopclass, false);
  ComposeOidProps(json, 'sopclass', elem.sopclass, false);
  ComposeStringValue(json, 'type', elem.type_, false);
  ComposeStringProps(json, 'type', elem.type_, false);
  ComposeStringValue(json, 'title', elem.title, false);
  ComposeStringProps(json, 'title', elem.title, false);
  ComposeUriValue(json, 'url', elem.url, false);
  ComposeUriProps(json, 'url', elem.url, false);
  ComposeResourceReference{Resource}(json, 'attachment', elem.attachment); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseImagingStudy(element : IXmlDomElement; path : string) : TFhirImagingStudy;
var
  child : IXMLDOMElement;
begin
  result := TFhirImagingStudy.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'dateTime') then
        result.dateTime := ParseDateTime(child, path+'/dateTime') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseResourceReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'uid') then
        result.uid := ParseOid(child, path+'/uid') {b}
      else if (child.baseName = 'accessionNo') then
        result.accessionNo := ParseIdentifier(child, path+'/accessionNo') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'order') then
        result.orderList.Add(ParseResourceReference{TFhirDiagnosticOrder}(child, path+'/order'))
      else if (child.baseName = 'modality') then
        result.modality.Add(ParseEnum(CODES_TFhirImagingModality, path+'/modality', child))
      else if (child.baseName = 'referrer') then
        result.referrer := ParseResourceReference{TFhirPractitioner}(child, path+'/referrer') {b}
      else if (child.baseName = 'availability') then
        result.availability := ParseEnum(CODES_TFhirInstanceAvailability, path+'/availability', child)
      else if (child.baseName = 'url') then
        result.url := ParseUri(child, path+'/url') {b}
      else if (child.baseName = 'numberOfSeries') then
        result.numberOfSeries := ParseInteger(child, path+'/numberOfSeries') {b}
      else if (child.baseName = 'numberOfInstances') then
        result.numberOfInstances := ParseInteger(child, path+'/numberOfInstances') {b}
      else if (child.baseName = 'clinicalInformation') then
        result.clinicalInformation := ParseString(child, path+'/clinicalInformation') {b}
      else if (child.baseName = 'procedure') then
        result.procedure_List.Add(ParseCoding(child, path+'/procedure'))
      else if (child.baseName = 'interpreter') then
        result.interpreter := ParseResourceReference{TFhirPractitioner}(child, path+'/interpreter') {b}
      else if (child.baseName = 'description') then
        result.description := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'series') then
        result.seriesList.Add(ParseImagingStudySeries(child, path+'/series'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImagingStudy(xml : TXmlBuilder; name : string; elem : TFhirImagingStudy);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeDateTime(xml, 'dateTime', elem.dateTime);
  ComposeResourceReference{TFhirPatient}(xml, 'subject', elem.subject);
  ComposeOid(xml, 'uid', elem.uid);
  ComposeIdentifier(xml, 'accessionNo', elem.accessionNo);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  for i := 0 to elem.orderList.Count - 1 do
    ComposeResourceReference{TFhirDiagnosticOrder}(xml, 'order', elem.orderList[i]);
  for i := 0 to elem.modality.Count - 1 do
    ComposeEnum(xml, 'modality', elem.modality[i], CODES_TFhirImagingModality);
  ComposeResourceReference{TFhirPractitioner}(xml, 'referrer', elem.referrer);
  ComposeEnum(xml, 'availability', elem.Availability, CODES_TFhirInstanceAvailability);
  ComposeUri(xml, 'url', elem.url);
  ComposeInteger(xml, 'numberOfSeries', elem.numberOfSeries);
  ComposeInteger(xml, 'numberOfInstances', elem.numberOfInstances);
  ComposeString(xml, 'clinicalInformation', elem.clinicalInformation);
  for i := 0 to elem.procedure_List.Count - 1 do
    ComposeCoding(xml, 'procedure', elem.procedure_List[i]);
  ComposeResourceReference{TFhirPractitioner}(xml, 'interpreter', elem.interpreter);
  ComposeString(xml, 'description', elem.description);
  for i := 0 to elem.seriesList.Count - 1 do
    ComposeImagingStudySeries(xml, 'series', elem.seriesList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImagingStudy(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingStudy(jsn));
end;

function TFHIRJsonParser.ParseImagingStudy(jsn : TJsonObject) : TFhirImagingStudy;
begin
  result := TFhirImagingStudy.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('dateTime') or jsn.has('_dateTime') then
        result.dateTime := ParseDateTime(jsn['dateTime'], jsn.vObj['_dateTime']);{q}
    if jsn.has('subject') then
        result.subject := ParseResourceReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('uid') or jsn.has('_uid') then
        result.uid := ParseOid(jsn['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('accessionNo') then
        result.accessionNo := ParseIdentifier(jsn.vObj['accessionNo']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('order') then
      iterateArray(jsn.vArr['order'], result.orderList, parseResourceReference{TFhirDiagnosticOrder});
    if jsn.has('modality') or jsn.has('_modality') then
      iterateEnumArray(jsn.vArr['modality'], jsn.vArr['_modality'], result.modality, parseEnum, CODES_TFhirImagingModality);
    if jsn.has('referrer') then
        result.referrer := ParseResourceReference{TFhirPractitioner}(jsn.vObj['referrer']);{q}
    if jsn.has('availability') or jsn.has('_availability')  then
      result.availability := parseEnum(jsn['availability'], jsn.vObj['_availability'], CODES_TFhirInstanceAvailability);
    if jsn.has('url') or jsn.has('_url') then
        result.url := ParseUri(jsn['url'], jsn.vObj['_url']);{q}
    if jsn.has('numberOfSeries') or jsn.has('_numberOfSeries') then
        result.numberOfSeries := ParseInteger(jsn['numberOfSeries'], jsn.vObj['_numberOfSeries']);{q}
    if jsn.has('numberOfInstances') or jsn.has('_numberOfInstances') then
        result.numberOfInstances := ParseInteger(jsn['numberOfInstances'], jsn.vObj['_numberOfInstances']);{q}
    if jsn.has('clinicalInformation') or jsn.has('_clinicalInformation') then
        result.clinicalInformation := ParseString(jsn['clinicalInformation'], jsn.vObj['_clinicalInformation']);{q}
    if jsn.has('procedure') then
      iterateArray(jsn.vArr['procedure'], result.procedure_List, parseCoding);
    if jsn.has('interpreter') then
        result.interpreter := ParseResourceReference{TFhirPractitioner}(jsn.vObj['interpreter']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.description := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('series') then
      iterateArray(jsn.vArr['series'], result.seriesList, parseImagingStudySeries);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImagingStudy(json : TJSONWriter; name : string; elem : TFhirImagingStudy);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeDateTimeValue(json, 'dateTime', elem.dateTime, false);
  ComposeDateTimeProps(json, 'dateTime', elem.dateTime, false);
  ComposeResourceReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  ComposeOidValue(json, 'uid', elem.uid, false);
  ComposeOidProps(json, 'uid', elem.uid, false);
  ComposeIdentifier(json, 'accessionNo', elem.accessionNo); {a}
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if elem.orderList.Count > 0 then
  begin
    json.valueArray('order');
    for i := 0 to elem.orderList.Count - 1 do
      ComposeResourceReference{TFhirDiagnosticOrder}(json, '',elem.orderList[i]); {z - Resource(DiagnosticOrder)}
    json.FinishArray;
  end;
  if elem.modality.Count > 0 then
  begin
    json.valueArray('modality');
    ext := false;
    for i := 0 to elem.modality.Count - 1 do
    begin
      ext := ext or ((elem.modality[i].xmlid <> '') or (elem.modality[i].hasExtensions));
      ComposeEnumValue(json, '', elem.modality[i], CODES_TFhirImagingModality, true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_modality');
      for i := 0 to elem.modality.Count - 1 do
        ComposeEnumProps(json, '', elem.modality[i], CODES_TFhirImagingModality, true);
      json.FinishArray;
    end;
  end;
  ComposeResourceReference{TFhirPractitioner}(json, 'referrer', elem.referrer); {a}
  ComposeEnumValue(json, 'availability', elem.Availability, CODES_TFhirInstanceAvailability, false);
  ComposeEnumProps(json, 'availability', elem.Availability, CODES_TFhirInstanceAvailability, false);
  ComposeUriValue(json, 'url', elem.url, false);
  ComposeUriProps(json, 'url', elem.url, false);
  ComposeIntegerValue(json, 'numberOfSeries', elem.numberOfSeries, false);
  ComposeIntegerProps(json, 'numberOfSeries', elem.numberOfSeries, false);
  ComposeIntegerValue(json, 'numberOfInstances', elem.numberOfInstances, false);
  ComposeIntegerProps(json, 'numberOfInstances', elem.numberOfInstances, false);
  ComposeStringValue(json, 'clinicalInformation', elem.clinicalInformation, false);
  ComposeStringProps(json, 'clinicalInformation', elem.clinicalInformation, false);
  if elem.procedure_List.Count > 0 then
  begin
    json.valueArray('procedure');
    for i := 0 to elem.procedure_List.Count - 1 do
      ComposeCoding(json, '',elem.procedure_List[i]); {z - Coding}
    json.FinishArray;
  end;
  ComposeResourceReference{TFhirPractitioner}(json, 'interpreter', elem.interpreter); {a}
  ComposeStringValue(json, 'description', elem.description, false);
  ComposeStringProps(json, 'description', elem.description, false);
  if elem.seriesList.Count > 0 then
  begin
    json.valueArray('series');
    for i := 0 to elem.seriesList.Count - 1 do
      ComposeImagingStudySeries(json, '',elem.seriesList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseImmunizationExplanation(element : IXmlDomElement; path : string) : TFhirImmunizationExplanation;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationExplanation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'reason') then
        result.reasonList.Add(ParseCodeableConcept(child, path+'/reason'))
      else if (child.baseName = 'refusalReason') then
        result.refusalReasonList.Add(ParseCodeableConcept(child, path+'/refusalReason'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationExplanation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationExplanation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.reasonList.Count - 1 do
    ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  for i := 0 to elem.refusalReasonList.Count - 1 do
    ComposeCodeableConcept(xml, 'refusalReason', elem.refusalReasonList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationExplanation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationExplanation(jsn));
end;

function TFHIRJsonParser.ParseImmunizationExplanation(jsn : TJsonObject) : TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('refusalReason') then
      iterateArray(jsn.vArr['refusalReason'], result.refusalReasonList, parseCodeableConcept);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationExplanation(json : TJSONWriter; name : string; elem : TFhirImmunizationExplanation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.reasonList.Count > 0 then
  begin
    json.valueArray('reason');
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.reasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.refusalReasonList.Count > 0 then
  begin
    json.valueArray('refusalReason');
    for i := 0 to elem.refusalReasonList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.refusalReasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseImmunizationReaction(element : IXmlDomElement; path : string) : TFhirImmunizationReaction;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationReaction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'date') then
        result.date := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'detail') then
        result.detail := ParseResourceReference{Resource}(child, path+'/detail') {b}
      else if (child.baseName = 'reported') then
        result.reported := ParseBoolean(child, path+'/reported') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationReaction(xml : TXmlBuilder; name : string; elem : TFhirImmunizationReaction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeDateTime(xml, 'date', elem.date);
  ComposeResourceReference{Resource}(xml, 'detail', elem.detail);
  ComposeBoolean(xml, 'reported', elem.reported);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationReaction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationReaction(jsn));
end;

function TFHIRJsonParser.ParseImmunizationReaction(jsn : TJsonObject) : TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('date') or jsn.has('_date') then
        result.date := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('detail') then
        result.detail := ParseResourceReference{Resource}(jsn.vObj['detail']);{q}
    if jsn.has('reported') or jsn.has('_reported') then
        result.reported := ParseBoolean(jsn['reported'], jsn.vObj['_reported']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationReaction(json : TJSONWriter; name : string; elem : TFhirImmunizationReaction);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeDateTimeValue(json, 'date', elem.date, false);
  ComposeDateTimeProps(json, 'date', elem.date, false);
  ComposeResourceReference{Resource}(json, 'detail', elem.detail); {a}
  ComposeBooleanValue(json, 'reported', elem.reported, false);
  ComposeBooleanProps(json, 'reported', elem.reported, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseImmunizationVaccinationProtocol(element : IXmlDomElement; path : string) : TFhirImmunizationVaccinationProtocol;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationVaccinationProtocol.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'doseSequence') then
        result.doseSequence := ParseInteger(child, path+'/doseSequence') {b}
      else if (child.baseName = 'description') then
        result.description := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'authority') then
        result.authority := ParseResourceReference{TFhirOrganization}(child, path+'/authority') {b}
      else if (child.baseName = 'series') then
        result.series := ParseString(child, path+'/series') {b}
      else if (child.baseName = 'seriesDoses') then
        result.seriesDoses := ParseInteger(child, path+'/seriesDoses') {b}
      else if (child.baseName = 'doseTarget') then
        result.doseTarget := ParseCodeableConcept(child, path+'/doseTarget') {b}
      else if (child.baseName = 'doseStatus') then
        result.doseStatus := ParseCodeableConcept(child, path+'/doseStatus') {b}
      else if (child.baseName = 'doseStatusReason') then
        result.doseStatusReason := ParseCodeableConcept(child, path+'/doseStatusReason') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationVaccinationProtocol(xml : TXmlBuilder; name : string; elem : TFhirImmunizationVaccinationProtocol);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeInteger(xml, 'doseSequence', elem.doseSequence);
  ComposeString(xml, 'description', elem.description);
  ComposeResourceReference{TFhirOrganization}(xml, 'authority', elem.authority);
  ComposeString(xml, 'series', elem.series);
  ComposeInteger(xml, 'seriesDoses', elem.seriesDoses);
  ComposeCodeableConcept(xml, 'doseTarget', elem.doseTarget);
  ComposeCodeableConcept(xml, 'doseStatus', elem.doseStatus);
  ComposeCodeableConcept(xml, 'doseStatusReason', elem.doseStatusReason);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationVaccinationProtocol(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationVaccinationProtocol(jsn));
end;

function TFHIRJsonParser.ParseImmunizationVaccinationProtocol(jsn : TJsonObject) : TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('doseSequence') or jsn.has('_doseSequence') then
        result.doseSequence := ParseInteger(jsn['doseSequence'], jsn.vObj['_doseSequence']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.description := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('authority') then
        result.authority := ParseResourceReference{TFhirOrganization}(jsn.vObj['authority']);{q}
    if jsn.has('series') or jsn.has('_series') then
        result.series := ParseString(jsn['series'], jsn.vObj['_series']);{q}
    if jsn.has('seriesDoses') or jsn.has('_seriesDoses') then
        result.seriesDoses := ParseInteger(jsn['seriesDoses'], jsn.vObj['_seriesDoses']);{q}
    if jsn.has('doseTarget') then
        result.doseTarget := ParseCodeableConcept(jsn.vObj['doseTarget']);{q}
    if jsn.has('doseStatus') then
        result.doseStatus := ParseCodeableConcept(jsn.vObj['doseStatus']);{q}
    if jsn.has('doseStatusReason') then
        result.doseStatusReason := ParseCodeableConcept(jsn.vObj['doseStatusReason']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationVaccinationProtocol(json : TJSONWriter; name : string; elem : TFhirImmunizationVaccinationProtocol);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIntegerValue(json, 'doseSequence', elem.doseSequence, false);
  ComposeIntegerProps(json, 'doseSequence', elem.doseSequence, false);
  ComposeStringValue(json, 'description', elem.description, false);
  ComposeStringProps(json, 'description', elem.description, false);
  ComposeResourceReference{TFhirOrganization}(json, 'authority', elem.authority); {a}
  ComposeStringValue(json, 'series', elem.series, false);
  ComposeStringProps(json, 'series', elem.series, false);
  ComposeIntegerValue(json, 'seriesDoses', elem.seriesDoses, false);
  ComposeIntegerProps(json, 'seriesDoses', elem.seriesDoses, false);
  ComposeCodeableConcept(json, 'doseTarget', elem.doseTarget); {a}
  ComposeCodeableConcept(json, 'doseStatus', elem.doseStatus); {a}
  ComposeCodeableConcept(json, 'doseStatusReason', elem.doseStatusReason); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseImmunization(element : IXmlDomElement; path : string) : TFhirImmunization;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunization.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'date') then
        result.date := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'vaccineType') then
        result.vaccineType := ParseCodeableConcept(child, path+'/vaccineType') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseResourceReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'refusedIndicator') then
        result.refusedIndicator := ParseBoolean(child, path+'/refusedIndicator') {b}
      else if (child.baseName = 'reported') then
        result.reported := ParseBoolean(child, path+'/reported') {b}
      else if (child.baseName = 'performer') then
        result.performer := ParseResourceReference{TFhirPractitioner}(child, path+'/performer') {b}
      else if (child.baseName = 'requester') then
        result.requester := ParseResourceReference{TFhirPractitioner}(child, path+'/requester') {b}
      else if (child.baseName = 'manufacturer') then
        result.manufacturer := ParseResourceReference{TFhirOrganization}(child, path+'/manufacturer') {b}
      else if (child.baseName = 'location') then
        result.location := ParseResourceReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'lotNumber') then
        result.lotNumber := ParseString(child, path+'/lotNumber') {b}
      else if (child.baseName = 'expirationDate') then
        result.expirationDate := ParseDate(child, path+'/expirationDate') {b}
      else if (child.baseName = 'site') then
        result.site := ParseCodeableConcept(child, path+'/site') {b}
      else if (child.baseName = 'route') then
        result.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.baseName = 'doseQuantity') then
        result.doseQuantity := ParseQuantity(child, path+'/doseQuantity') {b}
      else if (child.baseName = 'explanation') then
        result.explanation := ParseImmunizationExplanation(child, path+'/explanation') {b}
      else if (child.baseName = 'reaction') then
        result.reactionList.Add(ParseImmunizationReaction(child, path+'/reaction'))
      else if (child.baseName = 'vaccinationProtocol') then
        result.vaccinationProtocolList.Add(ParseImmunizationVaccinationProtocol(child, path+'/vaccinationProtocol'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunization(xml : TXmlBuilder; name : string; elem : TFhirImmunization);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeDateTime(xml, 'date', elem.date);
  ComposeCodeableConcept(xml, 'vaccineType', elem.vaccineType);
  ComposeResourceReference{TFhirPatient}(xml, 'subject', elem.subject);
  ComposeBoolean(xml, 'refusedIndicator', elem.refusedIndicator);
  ComposeBoolean(xml, 'reported', elem.reported);
  ComposeResourceReference{TFhirPractitioner}(xml, 'performer', elem.performer);
  ComposeResourceReference{TFhirPractitioner}(xml, 'requester', elem.requester);
  ComposeResourceReference{TFhirOrganization}(xml, 'manufacturer', elem.manufacturer);
  ComposeResourceReference{TFhirLocation}(xml, 'location', elem.location);
  ComposeString(xml, 'lotNumber', elem.lotNumber);
  ComposeDate(xml, 'expirationDate', elem.expirationDate);
  ComposeCodeableConcept(xml, 'site', elem.site);
  ComposeCodeableConcept(xml, 'route', elem.route);
  ComposeQuantity(xml, 'doseQuantity', elem.doseQuantity);
  ComposeImmunizationExplanation(xml, 'explanation', elem.explanation);
  for i := 0 to elem.reactionList.Count - 1 do
    ComposeImmunizationReaction(xml, 'reaction', elem.reactionList[i]);
  for i := 0 to elem.vaccinationProtocolList.Count - 1 do
    ComposeImmunizationVaccinationProtocol(xml, 'vaccinationProtocol', elem.vaccinationProtocolList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunization(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunization(jsn));
end;

function TFHIRJsonParser.ParseImmunization(jsn : TJsonObject) : TFhirImmunization;
begin
  result := TFhirImmunization.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('date') or jsn.has('_date') then
        result.date := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('vaccineType') then
        result.vaccineType := ParseCodeableConcept(jsn.vObj['vaccineType']);{q}
    if jsn.has('subject') then
        result.subject := ParseResourceReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('refusedIndicator') or jsn.has('_refusedIndicator') then
        result.refusedIndicator := ParseBoolean(jsn['refusedIndicator'], jsn.vObj['_refusedIndicator']);{q}
    if jsn.has('reported') or jsn.has('_reported') then
        result.reported := ParseBoolean(jsn['reported'], jsn.vObj['_reported']);{q}
    if jsn.has('performer') then
        result.performer := ParseResourceReference{TFhirPractitioner}(jsn.vObj['performer']);{q}
    if jsn.has('requester') then
        result.requester := ParseResourceReference{TFhirPractitioner}(jsn.vObj['requester']);{q}
    if jsn.has('manufacturer') then
        result.manufacturer := ParseResourceReference{TFhirOrganization}(jsn.vObj['manufacturer']);{q}
    if jsn.has('location') then
        result.location := ParseResourceReference{TFhirLocation}(jsn.vObj['location']);{q}
    if jsn.has('lotNumber') or jsn.has('_lotNumber') then
        result.lotNumber := ParseString(jsn['lotNumber'], jsn.vObj['_lotNumber']);{q}
    if jsn.has('expirationDate') or jsn.has('_expirationDate') then
        result.expirationDate := ParseDate(jsn['expirationDate'], jsn.vObj['_expirationDate']);{q}
    if jsn.has('site') then
        result.site := ParseCodeableConcept(jsn.vObj['site']);{q}
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q}
    if jsn.has('doseQuantity') then
        result.doseQuantity := ParseQuantity(jsn.vObj['doseQuantity']);{q}
    if jsn.has('explanation') then
        result.explanation := ParseImmunizationExplanation(jsn.vObj['explanation']);{q}
    if jsn.has('reaction') then
      iterateArray(jsn.vArr['reaction'], result.reactionList, parseImmunizationReaction);
    if jsn.has('vaccinationProtocol') then
      iterateArray(jsn.vArr['vaccinationProtocol'], result.vaccinationProtocolList, parseImmunizationVaccinationProtocol);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunization(json : TJSONWriter; name : string; elem : TFhirImmunization);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeDateTimeValue(json, 'date', elem.date, false);
  ComposeDateTimeProps(json, 'date', elem.date, false);
  ComposeCodeableConcept(json, 'vaccineType', elem.vaccineType); {a}
  ComposeResourceReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  ComposeBooleanValue(json, 'refusedIndicator', elem.refusedIndicator, false);
  ComposeBooleanProps(json, 'refusedIndicator', elem.refusedIndicator, false);
  ComposeBooleanValue(json, 'reported', elem.reported, false);
  ComposeBooleanProps(json, 'reported', elem.reported, false);
  ComposeResourceReference{TFhirPractitioner}(json, 'performer', elem.performer); {a}
  ComposeResourceReference{TFhirPractitioner}(json, 'requester', elem.requester); {a}
  ComposeResourceReference{TFhirOrganization}(json, 'manufacturer', elem.manufacturer); {a}
  ComposeResourceReference{TFhirLocation}(json, 'location', elem.location); {a}
  ComposeStringValue(json, 'lotNumber', elem.lotNumber, false);
  ComposeStringProps(json, 'lotNumber', elem.lotNumber, false);
  ComposeDateValue(json, 'expirationDate', elem.expirationDate, false);
  ComposeDateProps(json, 'expirationDate', elem.expirationDate, false);
  ComposeCodeableConcept(json, 'site', elem.site); {a}
  ComposeCodeableConcept(json, 'route', elem.route); {a}
  ComposeQuantity(json, 'doseQuantity', elem.doseQuantity); {a}
  ComposeImmunizationExplanation(json, 'explanation', elem.explanation); {a}
  if elem.reactionList.Count > 0 then
  begin
    json.valueArray('reaction');
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeImmunizationReaction(json, '',elem.reactionList[i]); {z - }
    json.FinishArray;
  end;
  if elem.vaccinationProtocolList.Count > 0 then
  begin
    json.valueArray('vaccinationProtocol');
    for i := 0 to elem.vaccinationProtocolList.Count - 1 do
      ComposeImmunizationVaccinationProtocol(json, '',elem.vaccinationProtocolList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseImmunizationRecommendationRecommendation(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendationRecommendation;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'date') then
        result.date := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'vaccineType') then
        result.vaccineType := ParseCodeableConcept(child, path+'/vaccineType') {b}
      else if (child.baseName = 'doseNumber') then
        result.doseNumber := ParseInteger(child, path+'/doseNumber') {b}
      else if (child.baseName = 'forecastStatus') then
        result.forecastStatus := ParseCodeableConcept(child, path+'/forecastStatus') {b}
      else if (child.baseName = 'dateCriterion') then
        result.dateCriterionList.Add(ParseImmunizationRecommendationRecommendationDateCriterion(child, path+'/dateCriterion'))
      else if (child.baseName = 'protocol') then
        result.protocol := ParseImmunizationRecommendationRecommendationProtocol(child, path+'/protocol') {b}
      else if (child.baseName = 'supportingImmunization') then
        result.supportingImmunizationList.Add(ParseResourceReference{TFhirImmunization}(child, path+'/supportingImmunization'))
      else if (child.baseName = 'supportingPatientInformation') then
        result.supportingPatientInformationList.Add(ParseResourceReference{Resource}(child, path+'/supportingPatientInformation'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeDateTime(xml, 'date', elem.date);
  ComposeCodeableConcept(xml, 'vaccineType', elem.vaccineType);
  ComposeInteger(xml, 'doseNumber', elem.doseNumber);
  ComposeCodeableConcept(xml, 'forecastStatus', elem.forecastStatus);
  for i := 0 to elem.dateCriterionList.Count - 1 do
    ComposeImmunizationRecommendationRecommendationDateCriterion(xml, 'dateCriterion', elem.dateCriterionList[i]);
  ComposeImmunizationRecommendationRecommendationProtocol(xml, 'protocol', elem.protocol);
  for i := 0 to elem.supportingImmunizationList.Count - 1 do
    ComposeResourceReference{TFhirImmunization}(xml, 'supportingImmunization', elem.supportingImmunizationList[i]);
  for i := 0 to elem.supportingPatientInformationList.Count - 1 do
    ComposeResourceReference{Resource}(xml, 'supportingPatientInformation', elem.supportingPatientInformationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendationRecommendation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationRecommendationRecommendation(jsn));
end;

function TFHIRJsonParser.ParseImmunizationRecommendationRecommendation(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('date') or jsn.has('_date') then
        result.date := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('vaccineType') then
        result.vaccineType := ParseCodeableConcept(jsn.vObj['vaccineType']);{q}
    if jsn.has('doseNumber') or jsn.has('_doseNumber') then
        result.doseNumber := ParseInteger(jsn['doseNumber'], jsn.vObj['_doseNumber']);{q}
    if jsn.has('forecastStatus') then
        result.forecastStatus := ParseCodeableConcept(jsn.vObj['forecastStatus']);{q}
    if jsn.has('dateCriterion') then
      iterateArray(jsn.vArr['dateCriterion'], result.dateCriterionList, parseImmunizationRecommendationRecommendationDateCriterion);
    if jsn.has('protocol') then
        result.protocol := ParseImmunizationRecommendationRecommendationProtocol(jsn.vObj['protocol']);{q}
    if jsn.has('supportingImmunization') then
      iterateArray(jsn.vArr['supportingImmunization'], result.supportingImmunizationList, parseResourceReference{TFhirImmunization});
    if jsn.has('supportingPatientInformation') then
      iterateArray(jsn.vArr['supportingPatientInformation'], result.supportingPatientInformationList, parseResourceReference{Resource});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationRecommendationRecommendation(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeDateTimeValue(json, 'date', elem.date, false);
  ComposeDateTimeProps(json, 'date', elem.date, false);
  ComposeCodeableConcept(json, 'vaccineType', elem.vaccineType); {a}
  ComposeIntegerValue(json, 'doseNumber', elem.doseNumber, false);
  ComposeIntegerProps(json, 'doseNumber', elem.doseNumber, false);
  ComposeCodeableConcept(json, 'forecastStatus', elem.forecastStatus); {a}
  if elem.dateCriterionList.Count > 0 then
  begin
    json.valueArray('dateCriterion');
    for i := 0 to elem.dateCriterionList.Count - 1 do
      ComposeImmunizationRecommendationRecommendationDateCriterion(json, '',elem.dateCriterionList[i]); {z - }
    json.FinishArray;
  end;
  ComposeImmunizationRecommendationRecommendationProtocol(json, 'protocol', elem.protocol); {a}
  if elem.supportingImmunizationList.Count > 0 then
  begin
    json.valueArray('supportingImmunization');
    for i := 0 to elem.supportingImmunizationList.Count - 1 do
      ComposeResourceReference{TFhirImmunization}(json, '',elem.supportingImmunizationList[i]); {z - Resource(Immunization)}
    json.FinishArray;
  end;
  if elem.supportingPatientInformationList.Count > 0 then
  begin
    json.valueArray('supportingPatientInformation');
    for i := 0 to elem.supportingPatientInformationList.Count - 1 do
      ComposeResourceReference{Resource}(json, '',elem.supportingPatientInformationList[i]); {z - Resource(Observation|AdverseReaction|AllergyIntolerance)}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseImmunizationRecommendationRecommendationDateCriterion(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendationRecommendationDateCriterion;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'value') then
        result.value := ParseDateTime(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendationDateCriterion(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);
  ComposeDateTime(xml, 'value', elem.value);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendationRecommendationDateCriterion(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationRecommendationRecommendationDateCriterion(jsn));
end;

function TFHIRJsonParser.ParseImmunizationRecommendationRecommendationDateCriterion(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.value := ParseDateTime(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationRecommendationRecommendationDateCriterion(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeDateTimeValue(json, 'value', elem.value, false);
  ComposeDateTimeProps(json, 'value', elem.value, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseImmunizationRecommendationRecommendationProtocol(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendationRecommendationProtocol;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'doseSequence') then
        result.doseSequence := ParseInteger(child, path+'/doseSequence') {b}
      else if (child.baseName = 'description') then
        result.description := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'authority') then
        result.authority := ParseResourceReference{TFhirOrganization}(child, path+'/authority') {b}
      else if (child.baseName = 'series') then
        result.series := ParseString(child, path+'/series') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendationProtocol(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendationProtocol);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeInteger(xml, 'doseSequence', elem.doseSequence);
  ComposeString(xml, 'description', elem.description);
  ComposeResourceReference{TFhirOrganization}(xml, 'authority', elem.authority);
  ComposeString(xml, 'series', elem.series);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendationRecommendationProtocol(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationRecommendationRecommendationProtocol(jsn));
end;

function TFHIRJsonParser.ParseImmunizationRecommendationRecommendationProtocol(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('doseSequence') or jsn.has('_doseSequence') then
        result.doseSequence := ParseInteger(jsn['doseSequence'], jsn.vObj['_doseSequence']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.description := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('authority') then
        result.authority := ParseResourceReference{TFhirOrganization}(jsn.vObj['authority']);{q}
    if jsn.has('series') or jsn.has('_series') then
        result.series := ParseString(jsn['series'], jsn.vObj['_series']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationRecommendationRecommendationProtocol(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendationProtocol);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIntegerValue(json, 'doseSequence', elem.doseSequence, false);
  ComposeIntegerProps(json, 'doseSequence', elem.doseSequence, false);
  ComposeStringValue(json, 'description', elem.description, false);
  ComposeStringProps(json, 'description', elem.description, false);
  ComposeResourceReference{TFhirOrganization}(json, 'authority', elem.authority); {a}
  ComposeStringValue(json, 'series', elem.series, false);
  ComposeStringProps(json, 'series', elem.series, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseImmunizationRecommendation(element : IXmlDomElement; path : string) : TFhirImmunizationRecommendation;
var
  child : IXMLDOMElement;
begin
  result := TFhirImmunizationRecommendation.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'subject') then
        result.subject := ParseResourceReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'recommendation') then
        result.recommendationList.Add(ParseImmunizationRecommendationRecommendation(child, path+'/recommendation'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeResourceReference{TFhirPatient}(xml, 'subject', elem.subject);
  for i := 0 to elem.recommendationList.Count - 1 do
    ComposeImmunizationRecommendationRecommendation(xml, 'recommendation', elem.recommendationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationRecommendation(jsn));
end;

function TFHIRJsonParser.ParseImmunizationRecommendation(jsn : TJsonObject) : TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseResourceReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('recommendation') then
      iterateArray(jsn.vArr['recommendation'], result.recommendationList, parseImmunizationRecommendationRecommendation);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeImmunizationRecommendation(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeResourceReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if elem.recommendationList.Count > 0 then
  begin
    json.valueArray('recommendation');
    for i := 0 to elem.recommendationList.Count - 1 do
      ComposeImmunizationRecommendationRecommendation(json, '',elem.recommendationList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseListEntry(element : IXmlDomElement; path : string) : TFhirListEntry;
var
  child : IXMLDOMElement;
begin
  result := TFhirListEntry.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'flag') then
        result.flagList.Add(ParseCodeableConcept(child, path+'/flag'))
      else if (child.baseName = 'deleted') then
        result.deleted := ParseBoolean(child, path+'/deleted') {b}
      else if (child.baseName = 'date') then
        result.date := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'item') then
        result.item := ParseResourceReference{Resource}(child, path+'/item') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeListEntry(xml : TXmlBuilder; name : string; elem : TFhirListEntry);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.flagList.Count - 1 do
    ComposeCodeableConcept(xml, 'flag', elem.flagList[i]);
  ComposeBoolean(xml, 'deleted', elem.deleted);
  ComposeDateTime(xml, 'date', elem.date);
  ComposeResourceReference{Resource}(xml, 'item', elem.item);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseListEntry(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseListEntry(jsn));
end;

function TFHIRJsonParser.ParseListEntry(jsn : TJsonObject) : TFhirListEntry;
begin
  result := TFhirListEntry.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('flag') then
      iterateArray(jsn.vArr['flag'], result.flagList, parseCodeableConcept);
    if jsn.has('deleted') or jsn.has('_deleted') then
        result.deleted := ParseBoolean(jsn['deleted'], jsn.vObj['_deleted']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.date := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('item') then
        result.item := ParseResourceReference{Resource}(jsn.vObj['item']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeListEntry(json : TJSONWriter; name : string; elem : TFhirListEntry);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.flagList.Count > 0 then
  begin
    json.valueArray('flag');
    for i := 0 to elem.flagList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.flagList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeBooleanValue(json, 'deleted', elem.deleted, false);
  ComposeBooleanProps(json, 'deleted', elem.deleted, false);
  ComposeDateTimeValue(json, 'date', elem.date, false);
  ComposeDateTimeProps(json, 'date', elem.date, false);
  ComposeResourceReference{Resource}(json, 'item', elem.item); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseList(element : IXmlDomElement; path : string) : TFhirList;
var
  child : IXMLDOMElement;
begin
  result := TFhirList.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseResourceReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'source') then
        result.source := ParseResourceReference{Resource}(child, path+'/source') {b}
      else if (child.baseName = 'date') then
        result.date := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'ordered') then
        result.ordered := ParseBoolean(child, path+'/ordered') {b}
      else if (child.baseName = 'mode') then
        result.mode := ParseEnum(CODES_TFhirListMode, path+'/mode', child)
      else if (child.baseName = 'entry') then
        result.entryList.Add(ParseListEntry(child, path+'/entry'))
      else if (child.baseName = 'emptyReason') then
        result.emptyReason := ParseCodeableConcept(child, path+'/emptyReason') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeList(xml : TXmlBuilder; name : string; elem : TFhirList);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'code', elem.code);
  ComposeResourceReference{Resource}(xml, 'subject', elem.subject);
  ComposeResourceReference{Resource}(xml, 'source', elem.source);
  ComposeDateTime(xml, 'date', elem.date);
  ComposeBoolean(xml, 'ordered', elem.ordered);
  ComposeEnum(xml, 'mode', elem.Mode, CODES_TFhirListMode);
  for i := 0 to elem.entryList.Count - 1 do
    ComposeListEntry(xml, 'entry', elem.entryList[i]);
  ComposeCodeableConcept(xml, 'emptyReason', elem.emptyReason);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseList(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseList(jsn));
end;

function TFHIRJsonParser.ParseList(jsn : TJsonObject) : TFhirList;
begin
  result := TFhirList.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('subject') then
        result.subject := ParseResourceReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('source') then
        result.source := ParseResourceReference{Resource}(jsn.vObj['source']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.date := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('ordered') or jsn.has('_ordered') then
        result.ordered := ParseBoolean(jsn['ordered'], jsn.vObj['_ordered']);{q}
    if jsn.has('mode') or jsn.has('_mode')  then
      result.mode := parseEnum(jsn['mode'], jsn.vObj['_mode'], CODES_TFhirListMode);
    if jsn.has('entry') then
      iterateArray(jsn.vArr['entry'], result.entryList, parseListEntry);
    if jsn.has('emptyReason') then
        result.emptyReason := ParseCodeableConcept(jsn.vObj['emptyReason']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeList(json : TJSONWriter; name : string; elem : TFhirList);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeResourceReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeResourceReference{Resource}(json, 'source', elem.source); {a}
  ComposeDateTimeValue(json, 'date', elem.date, false);
  ComposeDateTimeProps(json, 'date', elem.date, false);
  ComposeBooleanValue(json, 'ordered', elem.ordered, false);
  ComposeBooleanProps(json, 'ordered', elem.ordered, false);
  ComposeEnumValue(json, 'mode', elem.Mode, CODES_TFhirListMode, false);
  ComposeEnumProps(json, 'mode', elem.Mode, CODES_TFhirListMode, false);
  if elem.entryList.Count > 0 then
  begin
    json.valueArray('entry');
    for i := 0 to elem.entryList.Count - 1 do
      ComposeListEntry(json, '',elem.entryList[i]); {z - }
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'emptyReason', elem.emptyReason); {a}
end;

function TFHIRXmlParser.ParseLocationPosition(element : IXmlDomElement; path : string) : TFhirLocationPosition;
var
  child : IXMLDOMElement;
begin
  result := TFhirLocationPosition.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'longitude') then
        result.longitude := ParseDecimal(child, path+'/longitude') {b}
      else if (child.baseName = 'latitude') then
        result.latitude := ParseDecimal(child, path+'/latitude') {b}
      else if (child.baseName = 'altitude') then
        result.altitude := ParseDecimal(child, path+'/altitude') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeLocationPosition(xml : TXmlBuilder; name : string; elem : TFhirLocationPosition);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeDecimal(xml, 'longitude', elem.longitude);
  ComposeDecimal(xml, 'latitude', elem.latitude);
  ComposeDecimal(xml, 'altitude', elem.altitude);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseLocationPosition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseLocationPosition(jsn));
end;

function TFHIRJsonParser.ParseLocationPosition(jsn : TJsonObject) : TFhirLocationPosition;
begin
  result := TFhirLocationPosition.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('longitude') or jsn.has('_longitude') then
        result.longitude := ParseDecimal(jsn['longitude'], jsn.vObj['_longitude']);{q}
    if jsn.has('latitude') or jsn.has('_latitude') then
        result.latitude := ParseDecimal(jsn['latitude'], jsn.vObj['_latitude']);{q}
    if jsn.has('altitude') or jsn.has('_altitude') then
        result.altitude := ParseDecimal(jsn['altitude'], jsn.vObj['_altitude']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeLocationPosition(json : TJSONWriter; name : string; elem : TFhirLocationPosition);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeDecimalValue(json, 'longitude', elem.longitude, false);
  ComposeDecimalProps(json, 'longitude', elem.longitude, false);
  ComposeDecimalValue(json, 'latitude', elem.latitude, false);
  ComposeDecimalProps(json, 'latitude', elem.latitude, false);
  ComposeDecimalValue(json, 'altitude', elem.altitude, false);
  ComposeDecimalProps(json, 'altitude', elem.altitude, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseLocation(element : IXmlDomElement; path : string) : TFhirLocation;
var
  child : IXMLDOMElement;
begin
  result := TFhirLocation.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'name') then
        result.name := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'description') then
        result.description := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContact(child, path+'/telecom'))
      else if (child.baseName = 'address') then
        result.address := ParseAddress(child, path+'/address') {b}
      else if (child.baseName = 'physicalType') then
        result.physicalType := ParseCodeableConcept(child, path+'/physicalType') {b}
      else if (child.baseName = 'position') then
        result.position := ParseLocationPosition(child, path+'/position') {b}
      else if (child.baseName = 'managingOrganization') then
        result.managingOrganization := ParseResourceReference{TFhirOrganization}(child, path+'/managingOrganization') {b}
      else if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirLocationStatus, path+'/status', child)
      else if (child.baseName = 'partOf') then
        result.partOf := ParseResourceReference{TFhirLocation}(child, path+'/partOf') {b}
      else if (child.baseName = 'mode') then
        result.mode := ParseEnum(CODES_TFhirLocationMode, path+'/mode', child)
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeLocation(xml : TXmlBuilder; name : string; elem : TFhirLocation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);
  ComposeString(xml, 'name', elem.name);
  ComposeString(xml, 'description', elem.description);
  ComposeCodeableConcept(xml, 'type', elem.type_);
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContact(xml, 'telecom', elem.telecomList[i]);
  ComposeAddress(xml, 'address', elem.address);
  ComposeCodeableConcept(xml, 'physicalType', elem.physicalType);
  ComposeLocationPosition(xml, 'position', elem.position);
  ComposeResourceReference{TFhirOrganization}(xml, 'managingOrganization', elem.managingOrganization);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirLocationStatus);
  ComposeResourceReference{TFhirLocation}(xml, 'partOf', elem.partOf);
  ComposeEnum(xml, 'mode', elem.Mode, CODES_TFhirLocationMode);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseLocation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseLocation(jsn));
end;

function TFHIRJsonParser.ParseLocation(jsn : TJsonObject) : TFhirLocation;
begin
  result := TFhirLocation.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.name := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.description := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContact);
    if jsn.has('address') then
        result.address := ParseAddress(jsn.vObj['address']);{q}
    if jsn.has('physicalType') then
        result.physicalType := ParseCodeableConcept(jsn.vObj['physicalType']);{q}
    if jsn.has('position') then
        result.position := ParseLocationPosition(jsn.vObj['position']);{q}
    if jsn.has('managingOrganization') then
        result.managingOrganization := ParseResourceReference{TFhirOrganization}(jsn.vObj['managingOrganization']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirLocationStatus);
    if jsn.has('partOf') then
        result.partOf := ParseResourceReference{TFhirLocation}(jsn.vObj['partOf']);{q}
    if jsn.has('mode') or jsn.has('_mode')  then
      result.mode := parseEnum(jsn['mode'], jsn.vObj['_mode'], CODES_TFhirLocationMode);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeLocation(json : TJSONWriter; name : string; elem : TFhirLocation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeStringValue(json, 'name', elem.name, false);
  ComposeStringProps(json, 'name', elem.name, false);
  ComposeStringValue(json, 'description', elem.description, false);
  ComposeStringProps(json, 'description', elem.description, false);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContact(json, '',elem.telecomList[i]); {z - Contact}
    json.FinishArray;
  end;
  ComposeAddress(json, 'address', elem.address); {a}
  ComposeCodeableConcept(json, 'physicalType', elem.physicalType); {a}
  ComposeLocationPosition(json, 'position', elem.position); {a}
  ComposeResourceReference{TFhirOrganization}(json, 'managingOrganization', elem.managingOrganization); {a}
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirLocationStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirLocationStatus, false);
  ComposeResourceReference{TFhirLocation}(json, 'partOf', elem.partOf); {a}
  ComposeEnumValue(json, 'mode', elem.Mode, CODES_TFhirLocationMode, false);
  ComposeEnumProps(json, 'mode', elem.Mode, CODES_TFhirLocationMode, false);
end;

function TFHIRXmlParser.ParseMedia(element : IXmlDomElement; path : string) : TFhirMedia;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedia.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseEnum(CODES_TFhirMediaType, path+'/type', child)
      else if (child.baseName = 'subtype') then
        result.subtype := ParseCodeableConcept(child, path+'/subtype') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'dateTime') then
        result.dateTime := ParseDateTime(child, path+'/dateTime') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseResourceReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'operator') then
        result.operator := ParseResourceReference{TFhirPractitioner}(child, path+'/operator') {b}
      else if (child.baseName = 'view') then
        result.view := ParseCodeableConcept(child, path+'/view') {b}
      else if (child.baseName = 'deviceName') then
        result.deviceName := ParseString(child, path+'/deviceName') {b}
      else if (child.baseName = 'height') then
        result.height := ParseInteger(child, path+'/height') {b}
      else if (child.baseName = 'width') then
        result.width := ParseInteger(child, path+'/width') {b}
      else if (child.baseName = 'frames') then
        result.frames := ParseInteger(child, path+'/frames') {b}
      else if (child.baseName = 'length') then
        result.length := ParseInteger(child, path+'/length') {b}
      else if (child.baseName = 'content') then
        result.content := ParseAttachment(child, path+'/content') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedia(xml : TXmlBuilder; name : string; elem : TFhirMedia);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_, CODES_TFhirMediaType);
  ComposeCodeableConcept(xml, 'subtype', elem.subtype);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeDateTime(xml, 'dateTime', elem.dateTime);
  ComposeResourceReference{Resource}(xml, 'subject', elem.subject);
  ComposeResourceReference{TFhirPractitioner}(xml, 'operator', elem.operator);
  ComposeCodeableConcept(xml, 'view', elem.view);
  ComposeString(xml, 'deviceName', elem.deviceName);
  ComposeInteger(xml, 'height', elem.height);
  ComposeInteger(xml, 'width', elem.width);
  ComposeInteger(xml, 'frames', elem.frames);
  ComposeInteger(xml, 'length', elem.length);
  if not SummaryOnly then
    ComposeAttachment(xml, 'content', elem.content);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedia(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedia(jsn));
end;

function TFHIRJsonParser.ParseMedia(jsn : TJsonObject) : TFhirMedia;
begin
  result := TFhirMedia.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_ := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirMediaType);
    if jsn.has('subtype') then
        result.subtype := ParseCodeableConcept(jsn.vObj['subtype']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('dateTime') or jsn.has('_dateTime') then
        result.dateTime := ParseDateTime(jsn['dateTime'], jsn.vObj['_dateTime']);{q}
    if jsn.has('subject') then
        result.subject := ParseResourceReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('operator') then
        result.operator := ParseResourceReference{TFhirPractitioner}(jsn.vObj['operator']);{q}
    if jsn.has('view') then
        result.view := ParseCodeableConcept(jsn.vObj['view']);{q}
    if jsn.has('deviceName') or jsn.has('_deviceName') then
        result.deviceName := ParseString(jsn['deviceName'], jsn.vObj['_deviceName']);{q}
    if jsn.has('height') or jsn.has('_height') then
        result.height := ParseInteger(jsn['height'], jsn.vObj['_height']);{q}
    if jsn.has('width') or jsn.has('_width') then
        result.width := ParseInteger(jsn['width'], jsn.vObj['_width']);{q}
    if jsn.has('frames') or jsn.has('_frames') then
        result.frames := ParseInteger(jsn['frames'], jsn.vObj['_frames']);{q}
    if jsn.has('length') or jsn.has('_length') then
        result.length := ParseInteger(jsn['length'], jsn.vObj['_length']);{q}
    if jsn.has('content') then
        result.content := ParseAttachment(jsn.vObj['content']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedia(json : TJSONWriter; name : string; elem : TFhirMedia);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_, CODES_TFhirMediaType, false);
  ComposeEnumProps(json, 'type', elem.Type_, CODES_TFhirMediaType, false);
  ComposeCodeableConcept(json, 'subtype', elem.subtype); {a}
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeDateTimeValue(json, 'dateTime', elem.dateTime, false);
  ComposeDateTimeProps(json, 'dateTime', elem.dateTime, false);
  ComposeResourceReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeResourceReference{TFhirPractitioner}(json, 'operator', elem.operator); {a}
  ComposeCodeableConcept(json, 'view', elem.view); {a}
  ComposeStringValue(json, 'deviceName', elem.deviceName, false);
  ComposeStringProps(json, 'deviceName', elem.deviceName, false);
  ComposeIntegerValue(json, 'height', elem.height, false);
  ComposeIntegerProps(json, 'height', elem.height, false);
  ComposeIntegerValue(json, 'width', elem.width, false);
  ComposeIntegerProps(json, 'width', elem.width, false);
  ComposeIntegerValue(json, 'frames', elem.frames, false);
  ComposeIntegerProps(json, 'frames', elem.frames, false);
  ComposeIntegerValue(json, 'length', elem.length, false);
  ComposeIntegerProps(json, 'length', elem.length, false);
  if not SummaryOnly then
    ComposeAttachment(json, 'content', elem.content); {a}
end;

function TFHIRXmlParser.ParseMedicationProduct(element : IXmlDomElement; path : string) : TFhirMedicationProduct;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationProduct.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'form') then
        result.form := ParseCodeableConcept(child, path+'/form') {b}
      else if (child.baseName = 'ingredient') then
        result.ingredientList.Add(ParseMedicationProductIngredient(child, path+'/ingredient'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationProduct(xml : TXmlBuilder; name : string; elem : TFhirMedicationProduct);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'form', elem.form);
  for i := 0 to elem.ingredientList.Count - 1 do
    ComposeMedicationProductIngredient(xml, 'ingredient', elem.ingredientList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationProduct(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationProduct(jsn));
end;

function TFHIRJsonParser.ParseMedicationProduct(jsn : TJsonObject) : TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('form') then
        result.form := ParseCodeableConcept(jsn.vObj['form']);{q}
    if jsn.has('ingredient') then
      iterateArray(jsn.vArr['ingredient'], result.ingredientList, parseMedicationProductIngredient);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationProduct(json : TJSONWriter; name : string; elem : TFhirMedicationProduct);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'form', elem.form); {a}
  if elem.ingredientList.Count > 0 then
  begin
    json.valueArray('ingredient');
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeMedicationProductIngredient(json, '',elem.ingredientList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationProductIngredient(element : IXmlDomElement; path : string) : TFhirMedicationProductIngredient;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationProductIngredient.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'item') then
        result.item := ParseResourceReference{Resource}(child, path+'/item') {b}
      else if (child.baseName = 'amount') then
        result.amount := ParseRatio(child, path+'/amount') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationProductIngredient(xml : TXmlBuilder; name : string; elem : TFhirMedicationProductIngredient);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeResourceReference{Resource}(xml, 'item', elem.item);
  ComposeRatio(xml, 'amount', elem.amount);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationProductIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationProductIngredient(jsn));
end;

function TFHIRJsonParser.ParseMedicationProductIngredient(jsn : TJsonObject) : TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('item') then
        result.item := ParseResourceReference{Resource}(jsn.vObj['item']);{q}
    if jsn.has('amount') then
        result.amount := ParseRatio(jsn.vObj['amount']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationProductIngredient(json : TJSONWriter; name : string; elem : TFhirMedicationProductIngredient);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeResourceReference{Resource}(json, 'item', elem.item); {a}
  ComposeRatio(json, 'amount', elem.amount); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationPackage(element : IXmlDomElement; path : string) : TFhirMedicationPackage;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationPackage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'container') then
        result.container := ParseCodeableConcept(child, path+'/container') {b}
      else if (child.baseName = 'content') then
        result.contentList.Add(ParseMedicationPackageContent(child, path+'/content'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationPackage(xml : TXmlBuilder; name : string; elem : TFhirMedicationPackage);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'container', elem.container);
  for i := 0 to elem.contentList.Count - 1 do
    ComposeMedicationPackageContent(xml, 'content', elem.contentList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationPackage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationPackage(jsn));
end;

function TFHIRJsonParser.ParseMedicationPackage(jsn : TJsonObject) : TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('container') then
        result.container := ParseCodeableConcept(jsn.vObj['container']);{q}
    if jsn.has('content') then
      iterateArray(jsn.vArr['content'], result.contentList, parseMedicationPackageContent);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationPackage(json : TJSONWriter; name : string; elem : TFhirMedicationPackage);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'container', elem.container); {a}
  if elem.contentList.Count > 0 then
  begin
    json.valueArray('content');
    for i := 0 to elem.contentList.Count - 1 do
      ComposeMedicationPackageContent(json, '',elem.contentList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationPackageContent(element : IXmlDomElement; path : string) : TFhirMedicationPackageContent;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationPackageContent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'item') then
        result.item := ParseResourceReference{TFhirMedication}(child, path+'/item') {b}
      else if (child.baseName = 'amount') then
        result.amount := ParseQuantity(child, path+'/amount') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationPackageContent(xml : TXmlBuilder; name : string; elem : TFhirMedicationPackageContent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeResourceReference{TFhirMedication}(xml, 'item', elem.item);
  ComposeQuantity(xml, 'amount', elem.amount);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationPackageContent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationPackageContent(jsn));
end;

function TFHIRJsonParser.ParseMedicationPackageContent(jsn : TJsonObject) : TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('item') then
        result.item := ParseResourceReference{TFhirMedication}(jsn.vObj['item']);{q}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationPackageContent(json : TJSONWriter; name : string; elem : TFhirMedicationPackageContent);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeResourceReference{TFhirMedication}(json, 'item', elem.item); {a}
  ComposeQuantity(json, 'amount', elem.amount); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseMedication(element : IXmlDomElement; path : string) : TFhirMedication;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedication.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.name := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'isBrand') then
        result.isBrand := ParseBoolean(child, path+'/isBrand') {b}
      else if (child.baseName = 'manufacturer') then
        result.manufacturer := ParseResourceReference{TFhirOrganization}(child, path+'/manufacturer') {b}
      else if (child.baseName = 'kind') then
        result.kind := ParseEnum(CODES_TFhirMedicationKind, path+'/kind', child)
      else if (child.baseName = 'product') then
        result.product := ParseMedicationProduct(child, path+'/product') {b}
      else if (child.baseName = 'package') then
        result.package := ParseMedicationPackage(child, path+'/package') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedication(xml : TXmlBuilder; name : string; elem : TFhirMedication);
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeString(xml, 'name', elem.name);
  ComposeCodeableConcept(xml, 'code', elem.code);
  ComposeBoolean(xml, 'isBrand', elem.isBrand);
  ComposeResourceReference{TFhirOrganization}(xml, 'manufacturer', elem.manufacturer);
  ComposeEnum(xml, 'kind', elem.Kind, CODES_TFhirMedicationKind);
  if not SummaryOnly then
    ComposeMedicationProduct(xml, 'product', elem.product);
  if not SummaryOnly then
    ComposeMedicationPackage(xml, 'package', elem.package);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedication(jsn));
end;

function TFHIRJsonParser.ParseMedication(jsn : TJsonObject) : TFhirMedication;
begin
  result := TFhirMedication.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.name := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('isBrand') or jsn.has('_isBrand') then
        result.isBrand := ParseBoolean(jsn['isBrand'], jsn.vObj['_isBrand']);{q}
    if jsn.has('manufacturer') then
        result.manufacturer := ParseResourceReference{TFhirOrganization}(jsn.vObj['manufacturer']);{q}
    if jsn.has('kind') or jsn.has('_kind')  then
      result.kind := parseEnum(jsn['kind'], jsn.vObj['_kind'], CODES_TFhirMedicationKind);
    if jsn.has('product') then
        result.product := ParseMedicationProduct(jsn.vObj['product']);{q}
    if jsn.has('package') then
        result.package := ParseMedicationPackage(jsn.vObj['package']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedication(json : TJSONWriter; name : string; elem : TFhirMedication);
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeStringValue(json, 'name', elem.name, false);
  ComposeStringProps(json, 'name', elem.name, false);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeBooleanValue(json, 'isBrand', elem.isBrand, false);
  ComposeBooleanProps(json, 'isBrand', elem.isBrand, false);
  ComposeResourceReference{TFhirOrganization}(json, 'manufacturer', elem.manufacturer); {a}
  ComposeEnumValue(json, 'kind', elem.Kind, CODES_TFhirMedicationKind, false);
  ComposeEnumProps(json, 'kind', elem.Kind, CODES_TFhirMedicationKind, false);
  if not SummaryOnly then
    ComposeMedicationProduct(json, 'product', elem.product); {a}
  if not SummaryOnly then
    ComposeMedicationPackage(json, 'package', elem.package); {a}
end;

function TFHIRXmlParser.ParseMedicationAdministrationDosage(element : IXmlDomElement; path : string) : TFhirMedicationAdministrationDosage;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'timingDateTime') then
        result.timing := ParseDateTime(child, path+'/timingDateTime')
      else if (child.baseName = 'timingPeriod') then
        result.timing := ParsePeriod(child, path+'/timingPeriod')
      else if (child.baseName = 'asNeededBoolean') then
        result.asNeeded := ParseBoolean(child, path+'/asNeededBoolean')
      else if (child.baseName = 'asNeededCodeableConcept') then
        result.asNeeded := ParseCodeableConcept(child, path+'/asNeededCodeableConcept')
      else if (child.baseName = 'site') then
        result.site := ParseCodeableConcept(child, path+'/site') {b}
      else if (child.baseName = 'route') then
        result.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'rate') then
        result.rate := ParseRatio(child, path+'/rate') {b}
      else if (child.baseName = 'maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(child, path+'/maxDosePerPeriod') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationAdministrationDosage(xml : TXmlBuilder; name : string; elem : TFhirMedicationAdministrationDosage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  if (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'timingDateTime', TFhirDateTime(elem.timing))
  else if (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(xml, 'timingPeriod', TFhirPeriod(elem.timing));
  if (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'asNeededBoolean', TFhirBoolean(elem.asNeeded))
  else if (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded));
  ComposeCodeableConcept(xml, 'site', elem.site);
  ComposeCodeableConcept(xml, 'route', elem.route);
  ComposeCodeableConcept(xml, 'method', elem.method);
  ComposeQuantity(xml, 'quantity', elem.quantity);
  ComposeRatio(xml, 'rate', elem.rate);
  ComposeRatio(xml, 'maxDosePerPeriod', elem.maxDosePerPeriod);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationAdministrationDosage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationAdministrationDosage(jsn));
end;

function TFHIRJsonParser.ParseMedicationAdministrationDosage(jsn : TJsonObject) : TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('timingDateTime') or jsn.has('_timingDateTime') then
      result.timing := parseDateTime(jsn['timingDateTime'], jsn.vObj['_timingDateTime']);
    if jsn.has('timingPeriod') {a4} then
      result.timing := ParsePeriod(jsn.vObj['timingPeriod']);
    if jsn.has('asNeededBoolean') or jsn.has('_asNeededBoolean') then
      result.asNeeded := parseBoolean(jsn['asNeededBoolean'], jsn.vObj['_asNeededBoolean']);
    if jsn.has('asNeededCodeableConcept') {a4} then
      result.asNeeded := ParseCodeableConcept(jsn.vObj['asNeededCodeableConcept']);
    if jsn.has('site') then
        result.site := ParseCodeableConcept(jsn.vObj['site']);{q}
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('rate') then
        result.rate := ParseRatio(jsn.vObj['rate']);{q}
    if jsn.has('maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(jsn.vObj['maxDosePerPeriod']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationAdministrationDosage(json : TJSONWriter; name : string; elem : TFhirMedicationAdministrationDosage);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.timing is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
    ComposeDateTimeProps(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
  end
  else if (elem.timing is TFhirPeriod) then 
    ComposePeriod(json, 'timingPeriod', TFhirPeriod(elem.timing)) ;
  if (elem.asNeeded is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
    ComposeBooleanProps(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
  end
  else if (elem.asNeeded is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded)) ;
  ComposeCodeableConcept(json, 'site', elem.site); {a}
  ComposeCodeableConcept(json, 'route', elem.route); {a}
  ComposeCodeableConcept(json, 'method', elem.method); {a}
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeRatio(json, 'rate', elem.rate); {a}
  ComposeRatio(json, 'maxDosePerPeriod', elem.maxDosePerPeriod); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationAdministration(element : IXmlDomElement; path : string) : TFhirMedicationAdministration;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationAdministration.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirMedicationAdminStatus, path+'/status', child)
      else if (child.baseName = 'patient') then
        result.patient := ParseResourceReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'practitioner') then
        result.practitioner := ParseResourceReference{TFhirPractitioner}(child, path+'/practitioner') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseResourceReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'prescription') then
        result.prescription := ParseResourceReference{TFhirMedicationPrescription}(child, path+'/prescription') {b}
      else if (child.baseName = 'wasNotGiven') then
        result.wasNotGiven := ParseBoolean(child, path+'/wasNotGiven') {b}
      else if (child.baseName = 'reasonNotGiven') then
        result.reasonNotGivenList.Add(ParseCodeableConcept(child, path+'/reasonNotGiven'))
      else if (child.baseName = 'whenGiven') then
        result.whenGiven := ParsePeriod(child, path+'/whenGiven') {b}
      else if (child.baseName = 'medication') then
        result.medication := ParseResourceReference{TFhirMedication}(child, path+'/medication') {b}
      else if (child.baseName = 'device') then
        result.deviceList.Add(ParseResourceReference{TFhirDevice}(child, path+'/device'))
      else if (child.baseName = 'dosage') then
        result.dosageList.Add(ParseMedicationAdministrationDosage(child, path+'/dosage'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationAdministration(xml : TXmlBuilder; name : string; elem : TFhirMedicationAdministration);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirMedicationAdminStatus);
  ComposeResourceReference{TFhirPatient}(xml, 'patient', elem.patient);
  ComposeResourceReference{TFhirPractitioner}(xml, 'practitioner', elem.practitioner);
  ComposeResourceReference{TFhirEncounter}(xml, 'encounter', elem.encounter);
  ComposeResourceReference{TFhirMedicationPrescription}(xml, 'prescription', elem.prescription);
  ComposeBoolean(xml, 'wasNotGiven', elem.wasNotGiven);
  for i := 0 to elem.reasonNotGivenList.Count - 1 do
    ComposeCodeableConcept(xml, 'reasonNotGiven', elem.reasonNotGivenList[i]);
  ComposePeriod(xml, 'whenGiven', elem.whenGiven);
  ComposeResourceReference{TFhirMedication}(xml, 'medication', elem.medication);
  for i := 0 to elem.deviceList.Count - 1 do
    ComposeResourceReference{TFhirDevice}(xml, 'device', elem.deviceList[i]);
  for i := 0 to elem.dosageList.Count - 1 do
    ComposeMedicationAdministrationDosage(xml, 'dosage', elem.dosageList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationAdministration(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationAdministration(jsn));
end;

function TFHIRJsonParser.ParseMedicationAdministration(jsn : TJsonObject) : TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirMedicationAdminStatus);
    if jsn.has('patient') then
        result.patient := ParseResourceReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('practitioner') then
        result.practitioner := ParseResourceReference{TFhirPractitioner}(jsn.vObj['practitioner']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseResourceReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('prescription') then
        result.prescription := ParseResourceReference{TFhirMedicationPrescription}(jsn.vObj['prescription']);{q}
    if jsn.has('wasNotGiven') or jsn.has('_wasNotGiven') then
        result.wasNotGiven := ParseBoolean(jsn['wasNotGiven'], jsn.vObj['_wasNotGiven']);{q}
    if jsn.has('reasonNotGiven') then
      iterateArray(jsn.vArr['reasonNotGiven'], result.reasonNotGivenList, parseCodeableConcept);
    if jsn.has('whenGiven') then
        result.whenGiven := ParsePeriod(jsn.vObj['whenGiven']);{q}
    if jsn.has('medication') then
        result.medication := ParseResourceReference{TFhirMedication}(jsn.vObj['medication']);{q}
    if jsn.has('device') then
      iterateArray(jsn.vArr['device'], result.deviceList, parseResourceReference{TFhirDevice});
    if jsn.has('dosage') then
      iterateArray(jsn.vArr['dosage'], result.dosageList, parseMedicationAdministrationDosage);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationAdministration(json : TJSONWriter; name : string; elem : TFhirMedicationAdministration);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirMedicationAdminStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirMedicationAdminStatus, false);
  ComposeResourceReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeResourceReference{TFhirPractitioner}(json, 'practitioner', elem.practitioner); {a}
  ComposeResourceReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  ComposeResourceReference{TFhirMedicationPrescription}(json, 'prescription', elem.prescription); {a}
  ComposeBooleanValue(json, 'wasNotGiven', elem.wasNotGiven, false);
  ComposeBooleanProps(json, 'wasNotGiven', elem.wasNotGiven, false);
  if elem.reasonNotGivenList.Count > 0 then
  begin
    json.valueArray('reasonNotGiven');
    for i := 0 to elem.reasonNotGivenList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.reasonNotGivenList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposePeriod(json, 'whenGiven', elem.whenGiven); {a}
  ComposeResourceReference{TFhirMedication}(json, 'medication', elem.medication); {a}
  if elem.deviceList.Count > 0 then
  begin
    json.valueArray('device');
    for i := 0 to elem.deviceList.Count - 1 do
      ComposeResourceReference{TFhirDevice}(json, '',elem.deviceList[i]); {z - Resource(Device)}
    json.FinishArray;
  end;
  if elem.dosageList.Count > 0 then
  begin
    json.valueArray('dosage');
    for i := 0 to elem.dosageList.Count - 1 do
      ComposeMedicationAdministrationDosage(json, '',elem.dosageList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseMedicationDispenseDispense(element : IXmlDomElement; path : string) : TFhirMedicationDispenseDispense;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationDispenseDispense.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirMedicationDispenseStatus, path+'/status', child)
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'medication') then
        result.medication := ParseResourceReference{TFhirMedication}(child, path+'/medication') {b}
      else if (child.baseName = 'whenPrepared') then
        result.whenPrepared := ParseDateTime(child, path+'/whenPrepared') {b}
      else if (child.baseName = 'whenHandedOver') then
        result.whenHandedOver := ParseDateTime(child, path+'/whenHandedOver') {b}
      else if (child.baseName = 'destination') then
        result.destination := ParseResourceReference{TFhirLocation}(child, path+'/destination') {b}
      else if (child.baseName = 'receiver') then
        result.receiverList.Add(ParseResourceReference{Resource}(child, path+'/receiver'))
      else if (child.baseName = 'dosage') then
        result.dosageList.Add(ParseMedicationDispenseDispenseDosage(child, path+'/dosage'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispenseDispense(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispenseDispense);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirMedicationDispenseStatus);
  ComposeCodeableConcept(xml, 'type', elem.type_);
  ComposeQuantity(xml, 'quantity', elem.quantity);
  ComposeResourceReference{TFhirMedication}(xml, 'medication', elem.medication);
  ComposeDateTime(xml, 'whenPrepared', elem.whenPrepared);
  ComposeDateTime(xml, 'whenHandedOver', elem.whenHandedOver);
  ComposeResourceReference{TFhirLocation}(xml, 'destination', elem.destination);
  for i := 0 to elem.receiverList.Count - 1 do
    ComposeResourceReference{Resource}(xml, 'receiver', elem.receiverList[i]);
  for i := 0 to elem.dosageList.Count - 1 do
    ComposeMedicationDispenseDispenseDosage(xml, 'dosage', elem.dosageList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationDispenseDispense(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationDispenseDispense(jsn));
end;

function TFHIRJsonParser.ParseMedicationDispenseDispense(jsn : TJsonObject) : TFhirMedicationDispenseDispense;
begin
  result := TFhirMedicationDispenseDispense.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirMedicationDispenseStatus);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('medication') then
        result.medication := ParseResourceReference{TFhirMedication}(jsn.vObj['medication']);{q}
    if jsn.has('whenPrepared') or jsn.has('_whenPrepared') then
        result.whenPrepared := ParseDateTime(jsn['whenPrepared'], jsn.vObj['_whenPrepared']);{q}
    if jsn.has('whenHandedOver') or jsn.has('_whenHandedOver') then
        result.whenHandedOver := ParseDateTime(jsn['whenHandedOver'], jsn.vObj['_whenHandedOver']);{q}
    if jsn.has('destination') then
        result.destination := ParseResourceReference{TFhirLocation}(jsn.vObj['destination']);{q}
    if jsn.has('receiver') then
      iterateArray(jsn.vArr['receiver'], result.receiverList, parseResourceReference{Resource});
    if jsn.has('dosage') then
      iterateArray(jsn.vArr['dosage'], result.dosageList, parseMedicationDispenseDispenseDosage);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationDispenseDispense(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseDispense);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirMedicationDispenseStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirMedicationDispenseStatus, false);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeResourceReference{TFhirMedication}(json, 'medication', elem.medication); {a}
  ComposeDateTimeValue(json, 'whenPrepared', elem.whenPrepared, false);
  ComposeDateTimeProps(json, 'whenPrepared', elem.whenPrepared, false);
  ComposeDateTimeValue(json, 'whenHandedOver', elem.whenHandedOver, false);
  ComposeDateTimeProps(json, 'whenHandedOver', elem.whenHandedOver, false);
  ComposeResourceReference{TFhirLocation}(json, 'destination', elem.destination); {a}
  if elem.receiverList.Count > 0 then
  begin
    json.valueArray('receiver');
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeResourceReference{Resource}(json, '',elem.receiverList[i]); {z - Resource(Patient|Practitioner)}
    json.FinishArray;
  end;
  if elem.dosageList.Count > 0 then
  begin
    json.valueArray('dosage');
    for i := 0 to elem.dosageList.Count - 1 do
      ComposeMedicationDispenseDispenseDosage(json, '',elem.dosageList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationDispenseDispenseDosage(element : IXmlDomElement; path : string) : TFhirMedicationDispenseDispenseDosage;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationDispenseDispenseDosage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'additionalInstructions') then
        result.additionalInstructions := ParseCodeableConcept(child, path+'/additionalInstructions') {b}
      else if (child.baseName = 'timingDateTime') then
        result.timing := ParseDateTime(child, path+'/timingDateTime')
      else if (child.baseName = 'timingPeriod') then
        result.timing := ParsePeriod(child, path+'/timingPeriod')
      else if (child.baseName = 'timingSchedule') then
        result.timing := ParseSchedule(child, path+'/timingSchedule')
      else if (child.baseName = 'asNeededBoolean') then
        result.asNeeded := ParseBoolean(child, path+'/asNeededBoolean')
      else if (child.baseName = 'asNeededCodeableConcept') then
        result.asNeeded := ParseCodeableConcept(child, path+'/asNeededCodeableConcept')
      else if (child.baseName = 'site') then
        result.site := ParseCodeableConcept(child, path+'/site') {b}
      else if (child.baseName = 'route') then
        result.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'rate') then
        result.rate := ParseRatio(child, path+'/rate') {b}
      else if (child.baseName = 'maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(child, path+'/maxDosePerPeriod') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispenseDispenseDosage(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispenseDispenseDosage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'additionalInstructions', elem.additionalInstructions);
  if (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'timingDateTime', TFhirDateTime(elem.timing))
  else if (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(xml, 'timingPeriod', TFhirPeriod(elem.timing))
  else if (elem.timing is TFhirSchedule) {6} then
    ComposeSchedule(xml, 'timingSchedule', TFhirSchedule(elem.timing));
  if (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'asNeededBoolean', TFhirBoolean(elem.asNeeded))
  else if (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded));
  ComposeCodeableConcept(xml, 'site', elem.site);
  ComposeCodeableConcept(xml, 'route', elem.route);
  ComposeCodeableConcept(xml, 'method', elem.method);
  ComposeQuantity(xml, 'quantity', elem.quantity);
  ComposeRatio(xml, 'rate', elem.rate);
  ComposeRatio(xml, 'maxDosePerPeriod', elem.maxDosePerPeriod);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationDispenseDispenseDosage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationDispenseDispenseDosage(jsn));
end;

function TFHIRJsonParser.ParseMedicationDispenseDispenseDosage(jsn : TJsonObject) : TFhirMedicationDispenseDispenseDosage;
begin
  result := TFhirMedicationDispenseDispenseDosage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('additionalInstructions') then
        result.additionalInstructions := ParseCodeableConcept(jsn.vObj['additionalInstructions']);{q}
    if jsn.has('timingDateTime') or jsn.has('_timingDateTime') then
      result.timing := parseDateTime(jsn['timingDateTime'], jsn.vObj['_timingDateTime']);
    if jsn.has('timingPeriod') {a4} then
      result.timing := ParsePeriod(jsn.vObj['timingPeriod']);
    if jsn.has('timingSchedule') {a4} then
      result.timing := ParseSchedule(jsn.vObj['timingSchedule']);
    if jsn.has('asNeededBoolean') or jsn.has('_asNeededBoolean') then
      result.asNeeded := parseBoolean(jsn['asNeededBoolean'], jsn.vObj['_asNeededBoolean']);
    if jsn.has('asNeededCodeableConcept') {a4} then
      result.asNeeded := ParseCodeableConcept(jsn.vObj['asNeededCodeableConcept']);
    if jsn.has('site') then
        result.site := ParseCodeableConcept(jsn.vObj['site']);{q}
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('rate') then
        result.rate := ParseRatio(jsn.vObj['rate']);{q}
    if jsn.has('maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(jsn.vObj['maxDosePerPeriod']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationDispenseDispenseDosage(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseDispenseDosage);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'additionalInstructions', elem.additionalInstructions); {a}
  if (elem.timing is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
    ComposeDateTimeProps(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
  end
  else if (elem.timing is TFhirPeriod) then 
    ComposePeriod(json, 'timingPeriod', TFhirPeriod(elem.timing)) 
  else if (elem.timing is TFhirSchedule) then 
    ComposeSchedule(json, 'timingSchedule', TFhirSchedule(elem.timing)) ;
  if (elem.asNeeded is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
    ComposeBooleanProps(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
  end
  else if (elem.asNeeded is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded)) ;
  ComposeCodeableConcept(json, 'site', elem.site); {a}
  ComposeCodeableConcept(json, 'route', elem.route); {a}
  ComposeCodeableConcept(json, 'method', elem.method); {a}
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeRatio(json, 'rate', elem.rate); {a}
  ComposeRatio(json, 'maxDosePerPeriod', elem.maxDosePerPeriod); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationDispenseSubstitution(element : IXmlDomElement; path : string) : TFhirMedicationDispenseSubstitution;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'reason') then
        result.reasonList.Add(ParseCodeableConcept(child, path+'/reason'))
      else if (child.baseName = 'responsibleParty') then
        result.responsiblePartyList.Add(ParseResourceReference{TFhirPractitioner}(child, path+'/responsibleParty'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispenseSubstitution(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispenseSubstitution);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);
  for i := 0 to elem.reasonList.Count - 1 do
    ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  for i := 0 to elem.responsiblePartyList.Count - 1 do
    ComposeResourceReference{TFhirPractitioner}(xml, 'responsibleParty', elem.responsiblePartyList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationDispenseSubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationDispenseSubstitution(jsn));
end;

function TFHIRJsonParser.ParseMedicationDispenseSubstitution(jsn : TJsonObject) : TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('responsibleParty') then
      iterateArray(jsn.vArr['responsibleParty'], result.responsiblePartyList, parseResourceReference{TFhirPractitioner});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationDispenseSubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseSubstitution);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if elem.reasonList.Count > 0 then
  begin
    json.valueArray('reason');
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.reasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.responsiblePartyList.Count > 0 then
  begin
    json.valueArray('responsibleParty');
    for i := 0 to elem.responsiblePartyList.Count - 1 do
      ComposeResourceReference{TFhirPractitioner}(json, '',elem.responsiblePartyList[i]); {z - Resource(Practitioner)}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationDispense(element : IXmlDomElement; path : string) : TFhirMedicationDispense;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationDispense.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirMedicationDispenseStatus, path+'/status', child)
      else if (child.baseName = 'patient') then
        result.patient := ParseResourceReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'dispenser') then
        result.dispenser := ParseResourceReference{TFhirPractitioner}(child, path+'/dispenser') {b}
      else if (child.baseName = 'authorizingPrescription') then
        result.authorizingPrescriptionList.Add(ParseResourceReference{TFhirMedicationPrescription}(child, path+'/authorizingPrescription'))
      else if (child.baseName = 'dispense') then
        result.dispenseList.Add(ParseMedicationDispenseDispense(child, path+'/dispense'))
      else if (child.baseName = 'substitution') then
        result.substitution := ParseMedicationDispenseSubstitution(child, path+'/substitution') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispense(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispense);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirMedicationDispenseStatus);
  ComposeResourceReference{TFhirPatient}(xml, 'patient', elem.patient);
  ComposeResourceReference{TFhirPractitioner}(xml, 'dispenser', elem.dispenser);
  for i := 0 to elem.authorizingPrescriptionList.Count - 1 do
    ComposeResourceReference{TFhirMedicationPrescription}(xml, 'authorizingPrescription', elem.authorizingPrescriptionList[i]);
  for i := 0 to elem.dispenseList.Count - 1 do
    ComposeMedicationDispenseDispense(xml, 'dispense', elem.dispenseList[i]);
  ComposeMedicationDispenseSubstitution(xml, 'substitution', elem.substitution);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationDispense(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationDispense(jsn));
end;

function TFHIRJsonParser.ParseMedicationDispense(jsn : TJsonObject) : TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirMedicationDispenseStatus);
    if jsn.has('patient') then
        result.patient := ParseResourceReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('dispenser') then
        result.dispenser := ParseResourceReference{TFhirPractitioner}(jsn.vObj['dispenser']);{q}
    if jsn.has('authorizingPrescription') then
      iterateArray(jsn.vArr['authorizingPrescription'], result.authorizingPrescriptionList, parseResourceReference{TFhirMedicationPrescription});
    if jsn.has('dispense') then
      iterateArray(jsn.vArr['dispense'], result.dispenseList, parseMedicationDispenseDispense);
    if jsn.has('substitution') then
        result.substitution := ParseMedicationDispenseSubstitution(jsn.vObj['substitution']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationDispense(json : TJSONWriter; name : string; elem : TFhirMedicationDispense);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirMedicationDispenseStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirMedicationDispenseStatus, false);
  ComposeResourceReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeResourceReference{TFhirPractitioner}(json, 'dispenser', elem.dispenser); {a}
  if elem.authorizingPrescriptionList.Count > 0 then
  begin
    json.valueArray('authorizingPrescription');
    for i := 0 to elem.authorizingPrescriptionList.Count - 1 do
      ComposeResourceReference{TFhirMedicationPrescription}(json, '',elem.authorizingPrescriptionList[i]); {z - Resource(MedicationPrescription)}
    json.FinishArray;
  end;
  if elem.dispenseList.Count > 0 then
  begin
    json.valueArray('dispense');
    for i := 0 to elem.dispenseList.Count - 1 do
      ComposeMedicationDispenseDispense(json, '',elem.dispenseList[i]); {z - }
    json.FinishArray;
  end;
  ComposeMedicationDispenseSubstitution(json, 'substitution', elem.substitution); {a}
end;

function TFHIRXmlParser.ParseMedicationPrescriptionDosageInstruction(element : IXmlDomElement; path : string) : TFhirMedicationPrescriptionDosageInstruction;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationPrescriptionDosageInstruction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'text') then
        result.text := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'additionalInstructions') then
        result.additionalInstructions := ParseCodeableConcept(child, path+'/additionalInstructions') {b}
      else if (child.baseName = 'timingDateTime') then
        result.timing := ParseDateTime(child, path+'/timingDateTime')
      else if (child.baseName = 'timingPeriod') then
        result.timing := ParsePeriod(child, path+'/timingPeriod')
      else if (child.baseName = 'timingSchedule') then
        result.timing := ParseSchedule(child, path+'/timingSchedule')
      else if (child.baseName = 'asNeededBoolean') then
        result.asNeeded := ParseBoolean(child, path+'/asNeededBoolean')
      else if (child.baseName = 'asNeededCodeableConcept') then
        result.asNeeded := ParseCodeableConcept(child, path+'/asNeededCodeableConcept')
      else if (child.baseName = 'site') then
        result.site := ParseCodeableConcept(child, path+'/site') {b}
      else if (child.baseName = 'route') then
        result.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'doseQuantity') then
        result.doseQuantity := ParseQuantity(child, path+'/doseQuantity') {b}
      else if (child.baseName = 'rate') then
        result.rate := ParseRatio(child, path+'/rate') {b}
      else if (child.baseName = 'maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(child, path+'/maxDosePerPeriod') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationPrescriptionDosageInstruction(xml : TXmlBuilder; name : string; elem : TFhirMedicationPrescriptionDosageInstruction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'text', elem.text);
  ComposeCodeableConcept(xml, 'additionalInstructions', elem.additionalInstructions);
  if (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'timingDateTime', TFhirDateTime(elem.timing))
  else if (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(xml, 'timingPeriod', TFhirPeriod(elem.timing))
  else if (elem.timing is TFhirSchedule) {6} then
    ComposeSchedule(xml, 'timingSchedule', TFhirSchedule(elem.timing));
  if (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'asNeededBoolean', TFhirBoolean(elem.asNeeded))
  else if (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded));
  ComposeCodeableConcept(xml, 'site', elem.site);
  ComposeCodeableConcept(xml, 'route', elem.route);
  ComposeCodeableConcept(xml, 'method', elem.method);
  ComposeQuantity(xml, 'doseQuantity', elem.doseQuantity);
  ComposeRatio(xml, 'rate', elem.rate);
  ComposeRatio(xml, 'maxDosePerPeriod', elem.maxDosePerPeriod);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationPrescriptionDosageInstruction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationPrescriptionDosageInstruction(jsn));
end;

function TFHIRJsonParser.ParseMedicationPrescriptionDosageInstruction(jsn : TJsonObject) : TFhirMedicationPrescriptionDosageInstruction;
begin
  result := TFhirMedicationPrescriptionDosageInstruction.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('text') or jsn.has('_text') then
        result.text := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    if jsn.has('additionalInstructions') then
        result.additionalInstructions := ParseCodeableConcept(jsn.vObj['additionalInstructions']);{q}
    if jsn.has('timingDateTime') or jsn.has('_timingDateTime') then
      result.timing := parseDateTime(jsn['timingDateTime'], jsn.vObj['_timingDateTime']);
    if jsn.has('timingPeriod') {a4} then
      result.timing := ParsePeriod(jsn.vObj['timingPeriod']);
    if jsn.has('timingSchedule') {a4} then
      result.timing := ParseSchedule(jsn.vObj['timingSchedule']);
    if jsn.has('asNeededBoolean') or jsn.has('_asNeededBoolean') then
      result.asNeeded := parseBoolean(jsn['asNeededBoolean'], jsn.vObj['_asNeededBoolean']);
    if jsn.has('asNeededCodeableConcept') {a4} then
      result.asNeeded := ParseCodeableConcept(jsn.vObj['asNeededCodeableConcept']);
    if jsn.has('site') then
        result.site := ParseCodeableConcept(jsn.vObj['site']);{q}
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('doseQuantity') then
        result.doseQuantity := ParseQuantity(jsn.vObj['doseQuantity']);{q}
    if jsn.has('rate') then
        result.rate := ParseRatio(jsn.vObj['rate']);{q}
    if jsn.has('maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(jsn.vObj['maxDosePerPeriod']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationPrescriptionDosageInstruction(json : TJSONWriter; name : string; elem : TFhirMedicationPrescriptionDosageInstruction);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'text', elem.text, false);
  ComposeStringProps(json, 'text', elem.text, false);
  ComposeCodeableConcept(json, 'additionalInstructions', elem.additionalInstructions); {a}
  if (elem.timing is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
    ComposeDateTimeProps(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
  end
  else if (elem.timing is TFhirPeriod) then 
    ComposePeriod(json, 'timingPeriod', TFhirPeriod(elem.timing)) 
  else if (elem.timing is TFhirSchedule) then 
    ComposeSchedule(json, 'timingSchedule', TFhirSchedule(elem.timing)) ;
  if (elem.asNeeded is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
    ComposeBooleanProps(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
  end
  else if (elem.asNeeded is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded)) ;
  ComposeCodeableConcept(json, 'site', elem.site); {a}
  ComposeCodeableConcept(json, 'route', elem.route); {a}
  ComposeCodeableConcept(json, 'method', elem.method); {a}
  ComposeQuantity(json, 'doseQuantity', elem.doseQuantity); {a}
  ComposeRatio(json, 'rate', elem.rate); {a}
  ComposeRatio(json, 'maxDosePerPeriod', elem.maxDosePerPeriod); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationPrescriptionDispense(element : IXmlDomElement; path : string) : TFhirMedicationPrescriptionDispense;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationPrescriptionDispense.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'medication') then
        result.medication := ParseResourceReference{TFhirMedication}(child, path+'/medication') {b}
      else if (child.baseName = 'validityPeriod') then
        result.validityPeriod := ParsePeriod(child, path+'/validityPeriod') {b}
      else if (child.baseName = 'numberOfRepeatsAllowed') then
        result.numberOfRepeatsAllowed := ParseInteger(child, path+'/numberOfRepeatsAllowed') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'expectedSupplyDuration') then
        result.expectedSupplyDuration := ParseQuantity(child, path+'/expectedSupplyDuration') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationPrescriptionDispense(xml : TXmlBuilder; name : string; elem : TFhirMedicationPrescriptionDispense);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeResourceReference{TFhirMedication}(xml, 'medication', elem.medication);
  ComposePeriod(xml, 'validityPeriod', elem.validityPeriod);
  ComposeInteger(xml, 'numberOfRepeatsAllowed', elem.numberOfRepeatsAllowed);
  ComposeQuantity(xml, 'quantity', elem.quantity);
  ComposeQuantity(xml, 'expectedSupplyDuration', elem.expectedSupplyDuration);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationPrescriptionDispense(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationPrescriptionDispense(jsn));
end;

function TFHIRJsonParser.ParseMedicationPrescriptionDispense(jsn : TJsonObject) : TFhirMedicationPrescriptionDispense;
begin
  result := TFhirMedicationPrescriptionDispense.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('medication') then
        result.medication := ParseResourceReference{TFhirMedication}(jsn.vObj['medication']);{q}
    if jsn.has('validityPeriod') then
        result.validityPeriod := ParsePeriod(jsn.vObj['validityPeriod']);{q}
    if jsn.has('numberOfRepeatsAllowed') or jsn.has('_numberOfRepeatsAllowed') then
        result.numberOfRepeatsAllowed := ParseInteger(jsn['numberOfRepeatsAllowed'], jsn.vObj['_numberOfRepeatsAllowed']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('expectedSupplyDuration') then
        result.expectedSupplyDuration := ParseQuantity(jsn.vObj['expectedSupplyDuration']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationPrescriptionDispense(json : TJSONWriter; name : string; elem : TFhirMedicationPrescriptionDispense);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeResourceReference{TFhirMedication}(json, 'medication', elem.medication); {a}
  ComposePeriod(json, 'validityPeriod', elem.validityPeriod); {a}
  ComposeIntegerValue(json, 'numberOfRepeatsAllowed', elem.numberOfRepeatsAllowed, false);
  ComposeIntegerProps(json, 'numberOfRepeatsAllowed', elem.numberOfRepeatsAllowed, false);
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeQuantity(json, 'expectedSupplyDuration', elem.expectedSupplyDuration); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationPrescriptionSubstitution(element : IXmlDomElement; path : string) : TFhirMedicationPrescriptionSubstitution;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationPrescriptionSubstitution.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'reason') then
        result.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationPrescriptionSubstitution(xml : TXmlBuilder; name : string; elem : TFhirMedicationPrescriptionSubstitution);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);
  ComposeCodeableConcept(xml, 'reason', elem.reason);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationPrescriptionSubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationPrescriptionSubstitution(jsn));
end;

function TFHIRJsonParser.ParseMedicationPrescriptionSubstitution(jsn : TJsonObject) : TFhirMedicationPrescriptionSubstitution;
begin
  result := TFhirMedicationPrescriptionSubstitution.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationPrescriptionSubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationPrescriptionSubstitution);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationPrescription(element : IXmlDomElement; path : string) : TFhirMedicationPrescription;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationPrescription.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'dateWritten') then
        result.dateWritten := ParseDateTime(child, path+'/dateWritten') {b}
      else if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirMedicationPrescriptionStatus, path+'/status', child)
      else if (child.baseName = 'patient') then
        result.patient := ParseResourceReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'prescriber') then
        result.prescriber := ParseResourceReference{TFhirPractitioner}(child, path+'/prescriber') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseResourceReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'reasonCodeableConcept') then
        result.reason := ParseCodeableConcept(child, path+'/reasonCodeableConcept')
      else if (child.baseName = 'reasonResource') then
        result.reason := ParseResourceReference(child, path+'/reasonResource') {a}
      else if (child.baseName = 'medication') then
        result.medication := ParseResourceReference{TFhirMedication}(child, path+'/medication') {b}
      else if (child.baseName = 'dosageInstruction') then
        result.dosageInstructionList.Add(ParseMedicationPrescriptionDosageInstruction(child, path+'/dosageInstruction'))
      else if (child.baseName = 'dispense') then
        result.dispense := ParseMedicationPrescriptionDispense(child, path+'/dispense') {b}
      else if (child.baseName = 'substitution') then
        result.substitution := ParseMedicationPrescriptionSubstitution(child, path+'/substitution') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationPrescription(xml : TXmlBuilder; name : string; elem : TFhirMedicationPrescription);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeDateTime(xml, 'dateWritten', elem.dateWritten);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirMedicationPrescriptionStatus);
  ComposeResourceReference{TFhirPatient}(xml, 'patient', elem.patient);
  ComposeResourceReference{TFhirPractitioner}(xml, 'prescriber', elem.prescriber);
  ComposeResourceReference{TFhirEncounter}(xml, 'encounter', elem.encounter);
  if (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason))
  else if (elem.reason is TFhirResourceReference) {2} then
    ComposeResourceReference(xml, 'reasonResource', TFhirResourceReference(elem.reason));
  ComposeResourceReference{TFhirMedication}(xml, 'medication', elem.medication);
  for i := 0 to elem.dosageInstructionList.Count - 1 do
    ComposeMedicationPrescriptionDosageInstruction(xml, 'dosageInstruction', elem.dosageInstructionList[i]);
  ComposeMedicationPrescriptionDispense(xml, 'dispense', elem.dispense);
  ComposeMedicationPrescriptionSubstitution(xml, 'substitution', elem.substitution);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationPrescription(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationPrescription(jsn));
end;

function TFHIRJsonParser.ParseMedicationPrescription(jsn : TJsonObject) : TFhirMedicationPrescription;
begin
  result := TFhirMedicationPrescription.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('dateWritten') or jsn.has('_dateWritten') then
        result.dateWritten := ParseDateTime(jsn['dateWritten'], jsn.vObj['_dateWritten']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirMedicationPrescriptionStatus);
    if jsn.has('patient') then
        result.patient := ParseResourceReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('prescriber') then
        result.prescriber := ParseResourceReference{TFhirPractitioner}(jsn.vObj['prescriber']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseResourceReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('reasonCodeableConcept') {a4} then
      result.reason := ParseCodeableConcept(jsn.vObj['reasonCodeableConcept']);
    if jsn.has('reasonResource') {a3} then
      result.reason := ParseResourceReference(jsn.vObj['reasonResource']);
    if jsn.has('medication') then
        result.medication := ParseResourceReference{TFhirMedication}(jsn.vObj['medication']);{q}
    if jsn.has('dosageInstruction') then
      iterateArray(jsn.vArr['dosageInstruction'], result.dosageInstructionList, parseMedicationPrescriptionDosageInstruction);
    if jsn.has('dispense') then
        result.dispense := ParseMedicationPrescriptionDispense(jsn.vObj['dispense']);{q}
    if jsn.has('substitution') then
        result.substitution := ParseMedicationPrescriptionSubstitution(jsn.vObj['substitution']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationPrescription(json : TJSONWriter; name : string; elem : TFhirMedicationPrescription);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeDateTimeValue(json, 'dateWritten', elem.dateWritten, false);
  ComposeDateTimeProps(json, 'dateWritten', elem.dateWritten, false);
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirMedicationPrescriptionStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirMedicationPrescriptionStatus, false);
  ComposeResourceReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeResourceReference{TFhirPractitioner}(json, 'prescriber', elem.prescriber); {a}
  ComposeResourceReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (elem.reason is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason)) 
  else if (elem.reason is TFhirResourceReference) then
    ComposeResourceReference(json, 'reasonResource', TFhirResourceReference(elem.reason));
  ComposeResourceReference{TFhirMedication}(json, 'medication', elem.medication); {a}
  if elem.dosageInstructionList.Count > 0 then
  begin
    json.valueArray('dosageInstruction');
    for i := 0 to elem.dosageInstructionList.Count - 1 do
      ComposeMedicationPrescriptionDosageInstruction(json, '',elem.dosageInstructionList[i]); {z - }
    json.FinishArray;
  end;
  ComposeMedicationPrescriptionDispense(json, 'dispense', elem.dispense); {a}
  ComposeMedicationPrescriptionSubstitution(json, 'substitution', elem.substitution); {a}
end;

function TFHIRXmlParser.ParseMedicationStatementDosage(element : IXmlDomElement; path : string) : TFhirMedicationStatementDosage;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationStatementDosage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'timing') then
        result.timing := ParseSchedule(child, path+'/timing') {b}
      else if (child.baseName = 'asNeededBoolean') then
        result.asNeeded := ParseBoolean(child, path+'/asNeededBoolean')
      else if (child.baseName = 'asNeededCodeableConcept') then
        result.asNeeded := ParseCodeableConcept(child, path+'/asNeededCodeableConcept')
      else if (child.baseName = 'site') then
        result.site := ParseCodeableConcept(child, path+'/site') {b}
      else if (child.baseName = 'route') then
        result.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'rate') then
        result.rate := ParseRatio(child, path+'/rate') {b}
      else if (child.baseName = 'maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(child, path+'/maxDosePerPeriod') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationStatementDosage(xml : TXmlBuilder; name : string; elem : TFhirMedicationStatementDosage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeSchedule(xml, 'timing', elem.timing);
  if (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'asNeededBoolean', TFhirBoolean(elem.asNeeded))
  else if (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded));
  ComposeCodeableConcept(xml, 'site', elem.site);
  ComposeCodeableConcept(xml, 'route', elem.route);
  ComposeCodeableConcept(xml, 'method', elem.method);
  ComposeQuantity(xml, 'quantity', elem.quantity);
  ComposeRatio(xml, 'rate', elem.rate);
  ComposeRatio(xml, 'maxDosePerPeriod', elem.maxDosePerPeriod);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationStatementDosage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationStatementDosage(jsn));
end;

function TFHIRJsonParser.ParseMedicationStatementDosage(jsn : TJsonObject) : TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('timing') then
        result.timing := ParseSchedule(jsn.vObj['timing']);{q}
    if jsn.has('asNeededBoolean') or jsn.has('_asNeededBoolean') then
      result.asNeeded := parseBoolean(jsn['asNeededBoolean'], jsn.vObj['_asNeededBoolean']);
    if jsn.has('asNeededCodeableConcept') {a4} then
      result.asNeeded := ParseCodeableConcept(jsn.vObj['asNeededCodeableConcept']);
    if jsn.has('site') then
        result.site := ParseCodeableConcept(jsn.vObj['site']);{q}
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('rate') then
        result.rate := ParseRatio(jsn.vObj['rate']);{q}
    if jsn.has('maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(jsn.vObj['maxDosePerPeriod']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationStatementDosage(json : TJSONWriter; name : string; elem : TFhirMedicationStatementDosage);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeSchedule(json, 'timing', elem.timing); {a}
  if (elem.asNeeded is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
    ComposeBooleanProps(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
  end
  else if (elem.asNeeded is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded)) ;
  ComposeCodeableConcept(json, 'site', elem.site); {a}
  ComposeCodeableConcept(json, 'route', elem.route); {a}
  ComposeCodeableConcept(json, 'method', elem.method); {a}
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeRatio(json, 'rate', elem.rate); {a}
  ComposeRatio(json, 'maxDosePerPeriod', elem.maxDosePerPeriod); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseMedicationStatement(element : IXmlDomElement; path : string) : TFhirMedicationStatement;
var
  child : IXMLDOMElement;
begin
  result := TFhirMedicationStatement.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'patient') then
        result.patient := ParseResourceReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'wasNotGiven') then
        result.wasNotGiven := ParseBoolean(child, path+'/wasNotGiven') {b}
      else if (child.baseName = 'reasonNotGiven') then
        result.reasonNotGivenList.Add(ParseCodeableConcept(child, path+'/reasonNotGiven'))
      else if (child.baseName = 'whenGiven') then
        result.whenGiven := ParsePeriod(child, path+'/whenGiven') {b}
      else if (child.baseName = 'medication') then
        result.medication := ParseResourceReference{TFhirMedication}(child, path+'/medication') {b}
      else if (child.baseName = 'device') then
        result.deviceList.Add(ParseResourceReference{TFhirDevice}(child, path+'/device'))
      else if (child.baseName = 'dosage') then
        result.dosageList.Add(ParseMedicationStatementDosage(child, path+'/dosage'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMedicationStatement(xml : TXmlBuilder; name : string; elem : TFhirMedicationStatement);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeResourceReference{TFhirPatient}(xml, 'patient', elem.patient);
  ComposeBoolean(xml, 'wasNotGiven', elem.wasNotGiven);
  for i := 0 to elem.reasonNotGivenList.Count - 1 do
    ComposeCodeableConcept(xml, 'reasonNotGiven', elem.reasonNotGivenList[i]);
  ComposePeriod(xml, 'whenGiven', elem.whenGiven);
  ComposeResourceReference{TFhirMedication}(xml, 'medication', elem.medication);
  for i := 0 to elem.deviceList.Count - 1 do
    ComposeResourceReference{TFhirDevice}(xml, 'device', elem.deviceList[i]);
  for i := 0 to elem.dosageList.Count - 1 do
    ComposeMedicationStatementDosage(xml, 'dosage', elem.dosageList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMedicationStatement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationStatement(jsn));
end;

function TFHIRJsonParser.ParseMedicationStatement(jsn : TJsonObject) : TFhirMedicationStatement;
begin
  result := TFhirMedicationStatement.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('patient') then
        result.patient := ParseResourceReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('wasNotGiven') or jsn.has('_wasNotGiven') then
        result.wasNotGiven := ParseBoolean(jsn['wasNotGiven'], jsn.vObj['_wasNotGiven']);{q}
    if jsn.has('reasonNotGiven') then
      iterateArray(jsn.vArr['reasonNotGiven'], result.reasonNotGivenList, parseCodeableConcept);
    if jsn.has('whenGiven') then
        result.whenGiven := ParsePeriod(jsn.vObj['whenGiven']);{q}
    if jsn.has('medication') then
        result.medication := ParseResourceReference{TFhirMedication}(jsn.vObj['medication']);{q}
    if jsn.has('device') then
      iterateArray(jsn.vArr['device'], result.deviceList, parseResourceReference{TFhirDevice});
    if jsn.has('dosage') then
      iterateArray(jsn.vArr['dosage'], result.dosageList, parseMedicationStatementDosage);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMedicationStatement(json : TJSONWriter; name : string; elem : TFhirMedicationStatement);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeResourceReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeBooleanValue(json, 'wasNotGiven', elem.wasNotGiven, false);
  ComposeBooleanProps(json, 'wasNotGiven', elem.wasNotGiven, false);
  if elem.reasonNotGivenList.Count > 0 then
  begin
    json.valueArray('reasonNotGiven');
    for i := 0 to elem.reasonNotGivenList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.reasonNotGivenList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposePeriod(json, 'whenGiven', elem.whenGiven); {a}
  ComposeResourceReference{TFhirMedication}(json, 'medication', elem.medication); {a}
  if elem.deviceList.Count > 0 then
  begin
    json.valueArray('device');
    for i := 0 to elem.deviceList.Count - 1 do
      ComposeResourceReference{TFhirDevice}(json, '',elem.deviceList[i]); {z - Resource(Device)}
    json.FinishArray;
  end;
  if elem.dosageList.Count > 0 then
  begin
    json.valueArray('dosage');
    for i := 0 to elem.dosageList.Count - 1 do
      ComposeMedicationStatementDosage(json, '',elem.dosageList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseMessageHeaderResponse(element : IXmlDomElement; path : string) : TFhirMessageHeaderResponse;
var
  child : IXMLDOMElement;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseId(child, path+'/identifier') {b}
      else if (child.baseName = 'code') then
        result.code := ParseEnum(CODES_TFhirResponseCode, path+'/code', child)
      else if (child.baseName = 'details') then
        result.details := ParseResourceReference{TFhirOperationOutcome}(child, path+'/details') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderResponse(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderResponse);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'identifier', elem.identifier);
  ComposeEnum(xml, 'code', elem.Code, CODES_TFhirResponseCode);
  ComposeResourceReference{TFhirOperationOutcome}(xml, 'details', elem.details);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMessageHeaderResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageHeaderResponse(jsn));
end;

function TFHIRJsonParser.ParseMessageHeaderResponse(jsn : TJsonObject) : TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifier := ParseId(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('code') or jsn.has('_code')  then
      result.code := parseEnum(jsn['code'], jsn.vObj['_code'], CODES_TFhirResponseCode);
    if jsn.has('details') then
        result.details := ParseResourceReference{TFhirOperationOutcome}(jsn.vObj['details']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMessageHeaderResponse(json : TJSONWriter; name : string; elem : TFhirMessageHeaderResponse);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'identifier', elem.identifier, false);
  ComposeIdProps(json, 'identifier', elem.identifier, false);
  ComposeEnumValue(json, 'code', elem.Code, CODES_TFhirResponseCode, false);
  ComposeEnumProps(json, 'code', elem.Code, CODES_TFhirResponseCode, false);
  ComposeResourceReference{TFhirOperationOutcome}(json, 'details', elem.details); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseMessageHeaderSource(element : IXmlDomElement; path : string) : TFhirMessageHeaderSource;
var
  child : IXMLDOMElement;
begin
  result := TFhirMessageHeaderSource.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.name := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'software') then
        result.software := ParseString(child, path+'/software') {b}
      else if (child.baseName = 'version') then
        result.version := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'contact') then
        result.contact := ParseContact(child, path+'/contact') {b}
      else if (child.baseName = 'endpoint') then
        result.endpoint := ParseUri(child, path+'/endpoint') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderSource(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderSource);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.name);
  ComposeString(xml, 'software', elem.software);
  ComposeString(xml, 'version', elem.version);
  ComposeContact(xml, 'contact', elem.contact);
  ComposeUri(xml, 'endpoint', elem.endpoint);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMessageHeaderSource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageHeaderSource(jsn));
end;

function TFHIRJsonParser.ParseMessageHeaderSource(jsn : TJsonObject) : TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.name := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('software') or jsn.has('_software') then
        result.software := ParseString(jsn['software'], jsn.vObj['_software']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.version := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('contact') then
        result.contact := ParseContact(jsn.vObj['contact']);{q}
    if jsn.has('endpoint') or jsn.has('_endpoint') then
        result.endpoint := ParseUri(jsn['endpoint'], jsn.vObj['_endpoint']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMessageHeaderSource(json : TJSONWriter; name : string; elem : TFhirMessageHeaderSource);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.name, false);
  ComposeStringProps(json, 'name', elem.name, false);
  ComposeStringValue(json, 'software', elem.software, false);
  ComposeStringProps(json, 'software', elem.software, false);
  ComposeStringValue(json, 'version', elem.version, false);
  ComposeStringProps(json, 'version', elem.version, false);
  ComposeContact(json, 'contact', elem.contact); {a}
  ComposeUriValue(json, 'endpoint', elem.endpoint, false);
  ComposeUriProps(json, 'endpoint', elem.endpoint, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseMessageHeaderDestination(element : IXmlDomElement; path : string) : TFhirMessageHeaderDestination;
var
  child : IXMLDOMElement;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.name := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'target') then
        result.target := ParseResourceReference{TFhirDevice}(child, path+'/target') {b}
      else if (child.baseName = 'endpoint') then
        result.endpoint := ParseUri(child, path+'/endpoint') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderDestination(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderDestination);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.name);
  ComposeResourceReference{TFhirDevice}(xml, 'target', elem.target);
  ComposeUri(xml, 'endpoint', elem.endpoint);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMessageHeaderDestination(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageHeaderDestination(jsn));
end;

function TFHIRJsonParser.ParseMessageHeaderDestination(jsn : TJsonObject) : TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.name := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('target') then
        result.target := ParseResourceReference{TFhirDevice}(jsn.vObj['target']);{q}
    if jsn.has('endpoint') or jsn.has('_endpoint') then
        result.endpoint := ParseUri(jsn['endpoint'], jsn.vObj['_endpoint']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMessageHeaderDestination(json : TJSONWriter; name : string; elem : TFhirMessageHeaderDestination);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.name, false);
  ComposeStringProps(json, 'name', elem.name, false);
  ComposeResourceReference{TFhirDevice}(json, 'target', elem.target); {a}
  ComposeUriValue(json, 'endpoint', elem.endpoint, false);
  ComposeUriProps(json, 'endpoint', elem.endpoint, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseMessageHeader(element : IXmlDomElement; path : string) : TFhirMessageHeader;
var
  child : IXMLDOMElement;
begin
  result := TFhirMessageHeader.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseId(child, path+'/identifier') {b}
      else if (child.baseName = 'timestamp') then
        result.timestamp := ParseInstant(child, path+'/timestamp') {b}
      else if (child.baseName = 'event') then
        result.event := ParseCoding(child, path+'/event') {b}
      else if (child.baseName = 'response') then
        result.response := ParseMessageHeaderResponse(child, path+'/response') {b}
      else if (child.baseName = 'source') then
        result.source := ParseMessageHeaderSource(child, path+'/source') {b}
      else if (child.baseName = 'destination') then
        result.destinationList.Add(ParseMessageHeaderDestination(child, path+'/destination'))
      else if (child.baseName = 'enterer') then
        result.enterer := ParseResourceReference{TFhirPractitioner}(child, path+'/enterer') {b}
      else if (child.baseName = 'author') then
        result.author := ParseResourceReference{TFhirPractitioner}(child, path+'/author') {b}
      else if (child.baseName = 'receiver') then
        result.receiver := ParseResourceReference{Resource}(child, path+'/receiver') {b}
      else if (child.baseName = 'responsible') then
        result.responsible := ParseResourceReference{Resource}(child, path+'/responsible') {b}
      else if (child.baseName = 'reason') then
        result.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if (child.baseName = 'data') then
        result.dataList.Add(ParseResourceReference{Resource}(child, path+'/data'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeMessageHeader(xml : TXmlBuilder; name : string; elem : TFhirMessageHeader);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeId(xml, 'identifier', elem.identifier);
  ComposeInstant(xml, 'timestamp', elem.timestamp);
  ComposeCoding(xml, 'event', elem.event);
  ComposeMessageHeaderResponse(xml, 'response', elem.response);
  ComposeMessageHeaderSource(xml, 'source', elem.source);
  for i := 0 to elem.destinationList.Count - 1 do
    ComposeMessageHeaderDestination(xml, 'destination', elem.destinationList[i]);
  ComposeResourceReference{TFhirPractitioner}(xml, 'enterer', elem.enterer);
  ComposeResourceReference{TFhirPractitioner}(xml, 'author', elem.author);
  ComposeResourceReference{Resource}(xml, 'receiver', elem.receiver);
  ComposeResourceReference{Resource}(xml, 'responsible', elem.responsible);
  ComposeCodeableConcept(xml, 'reason', elem.reason);
  for i := 0 to elem.dataList.Count - 1 do
    ComposeResourceReference{Resource}(xml, 'data', elem.dataList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseMessageHeader(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageHeader(jsn));
end;

function TFHIRJsonParser.ParseMessageHeader(jsn : TJsonObject) : TFhirMessageHeader;
begin
  result := TFhirMessageHeader.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifier := ParseId(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('timestamp') or jsn.has('_timestamp') then
        result.timestamp := ParseInstant(jsn['timestamp'], jsn.vObj['_timestamp']);{q}
    if jsn.has('event') then
        result.event := ParseCoding(jsn.vObj['event']);{q}
    if jsn.has('response') then
        result.response := ParseMessageHeaderResponse(jsn.vObj['response']);{q}
    if jsn.has('source') then
        result.source := ParseMessageHeaderSource(jsn.vObj['source']);{q}
    if jsn.has('destination') then
      iterateArray(jsn.vArr['destination'], result.destinationList, parseMessageHeaderDestination);
    if jsn.has('enterer') then
        result.enterer := ParseResourceReference{TFhirPractitioner}(jsn.vObj['enterer']);{q}
    if jsn.has('author') then
        result.author := ParseResourceReference{TFhirPractitioner}(jsn.vObj['author']);{q}
    if jsn.has('receiver') then
        result.receiver := ParseResourceReference{Resource}(jsn.vObj['receiver']);{q}
    if jsn.has('responsible') then
        result.responsible := ParseResourceReference{Resource}(jsn.vObj['responsible']);{q}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q}
    if jsn.has('data') then
      iterateArray(jsn.vArr['data'], result.dataList, parseResourceReference{Resource});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeMessageHeader(json : TJSONWriter; name : string; elem : TFhirMessageHeader);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeIdValue(json, 'identifier', elem.identifier, false);
  ComposeIdProps(json, 'identifier', elem.identifier, false);
  ComposeInstantValue(json, 'timestamp', elem.timestamp, false);
  ComposeInstantProps(json, 'timestamp', elem.timestamp, false);
  ComposeCoding(json, 'event', elem.event); {a}
  ComposeMessageHeaderResponse(json, 'response', elem.response); {a}
  ComposeMessageHeaderSource(json, 'source', elem.source); {a}
  if elem.destinationList.Count > 0 then
  begin
    json.valueArray('destination');
    for i := 0 to elem.destinationList.Count - 1 do
      ComposeMessageHeaderDestination(json, '',elem.destinationList[i]); {z - }
    json.FinishArray;
  end;
  ComposeResourceReference{TFhirPractitioner}(json, 'enterer', elem.enterer); {a}
  ComposeResourceReference{TFhirPractitioner}(json, 'author', elem.author); {a}
  ComposeResourceReference{Resource}(json, 'receiver', elem.receiver); {a}
  ComposeResourceReference{Resource}(json, 'responsible', elem.responsible); {a}
  ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  if elem.dataList.Count > 0 then
  begin
    json.valueArray('data');
    for i := 0 to elem.dataList.Count - 1 do
      ComposeResourceReference{Resource}(json, '',elem.dataList[i]); {z - Resource(Any)}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseObservationReferenceRange(element : IXmlDomElement; path : string) : TFhirObservationReferenceRange;
var
  child : IXMLDOMElement;
begin
  result := TFhirObservationReferenceRange.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'low') then
        result.low := ParseQuantity(child, path+'/low') {b}
      else if (child.baseName = 'high') then
        result.high := ParseQuantity(child, path+'/high') {b}
      else if (child.baseName = 'meaning') then
        result.meaning := ParseCodeableConcept(child, path+'/meaning') {b}
      else if (child.baseName = 'age') then
        result.age := ParseRange(child, path+'/age') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeObservationReferenceRange(xml : TXmlBuilder; name : string; elem : TFhirObservationReferenceRange);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeQuantity(xml, 'low', elem.low);
  ComposeQuantity(xml, 'high', elem.high);
  ComposeCodeableConcept(xml, 'meaning', elem.meaning);
  ComposeRange(xml, 'age', elem.age);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseObservationReferenceRange(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseObservationReferenceRange(jsn));
end;

function TFHIRJsonParser.ParseObservationReferenceRange(jsn : TJsonObject) : TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('low') then
        result.low := ParseQuantity(jsn.vObj['low']);{q}
    if jsn.has('high') then
        result.high := ParseQuantity(jsn.vObj['high']);{q}
    if jsn.has('meaning') then
        result.meaning := ParseCodeableConcept(jsn.vObj['meaning']);{q}
    if jsn.has('age') then
        result.age := ParseRange(jsn.vObj['age']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeObservationReferenceRange(json : TJSONWriter; name : string; elem : TFhirObservationReferenceRange);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeQuantity(json, 'low', elem.low); {a}
  ComposeQuantity(json, 'high', elem.high); {a}
  ComposeCodeableConcept(json, 'meaning', elem.meaning); {a}
  ComposeRange(json, 'age', elem.age); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseObservationRelated(element : IXmlDomElement; path : string) : TFhirObservationRelated;
var
  child : IXMLDOMElement;
begin
  result := TFhirObservationRelated.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseEnum(CODES_TFhirObservationRelationshiptypes, path+'/type', child)
      else if (child.baseName = 'target') then
        result.target := ParseResourceReference{TFhirObservation}(child, path+'/target') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeObservationRelated(xml : TXmlBuilder; name : string; elem : TFhirObservationRelated);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_, CODES_TFhirObservationRelationshiptypes);
  ComposeResourceReference{TFhirObservation}(xml, 'target', elem.target);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseObservationRelated(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseObservationRelated(jsn));
end;

function TFHIRJsonParser.ParseObservationRelated(jsn : TJsonObject) : TFhirObservationRelated;
begin
  result := TFhirObservationRelated.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_ := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirObservationRelationshiptypes);
    if jsn.has('target') then
        result.target := ParseResourceReference{TFhirObservation}(jsn.vObj['target']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeObservationRelated(json : TJSONWriter; name : string; elem : TFhirObservationRelated);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_, CODES_TFhirObservationRelationshiptypes, false);
  ComposeEnumProps(json, 'type', elem.Type_, CODES_TFhirObservationRelationshiptypes, false);
  ComposeResourceReference{TFhirObservation}(json, 'target', elem.target); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseObservation(element : IXmlDomElement; path : string) : TFhirObservation;
var
  child : IXMLDOMElement;
begin
  result := TFhirObservation.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.name := ParseCodeableConcept(child, path+'/name') {b}
      else if (child.baseName = 'valueQuantity') then
        result.value := ParseQuantity(child, path+'/valueQuantity')
      else if (child.baseName = 'valueCodeableConcept') then
        result.value := ParseCodeableConcept(child, path+'/valueCodeableConcept')
      else if (child.baseName = 'valueAttachment') then
        result.value := ParseAttachment(child, path+'/valueAttachment')
      else if (child.baseName = 'valueRatio') then
        result.value := ParseRatio(child, path+'/valueRatio')
      else if (child.baseName = 'valuePeriod') then
        result.value := ParsePeriod(child, path+'/valuePeriod')
      else if (child.baseName = 'valueSampledData') then
        result.value := ParseSampledData(child, path+'/valueSampledData')
      else if (child.baseName = 'valueString') then
        result.value := ParseString(child, path+'/valueString')
      else if (child.baseName = 'interpretation') then
        result.interpretation := ParseCodeableConcept(child, path+'/interpretation') {b}
      else if (child.baseName = 'comments') then
        result.comments := ParseString(child, path+'/comments') {b}
      else if (child.baseName = 'appliesDateTime') then
        result.applies := ParseDateTime(child, path+'/appliesDateTime')
      else if (child.baseName = 'appliesPeriod') then
        result.applies := ParsePeriod(child, path+'/appliesPeriod')
      else if (child.baseName = 'issued') then
        result.issued := ParseInstant(child, path+'/issued') {b}
      else if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirObservationStatus, path+'/status', child)
      else if (child.baseName = 'reliability') then
        result.reliability := ParseEnum(CODES_TFhirObservationReliability, path+'/reliability', child)
      else if (child.baseName = 'bodySite') then
        result.bodySite := ParseCodeableConcept(child, path+'/bodySite') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseResourceReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'specimen') then
        result.specimen := ParseResourceReference{TFhirSpecimen}(child, path+'/specimen') {b}
      else if (child.baseName = 'performer') then
        result.performerList.Add(ParseResourceReference{Resource}(child, path+'/performer'))
      else if (child.baseName = 'referenceRange') then
        result.referenceRangeList.Add(ParseObservationReferenceRange(child, path+'/referenceRange'))
      else if (child.baseName = 'related') then
        result.relatedList.Add(ParseObservationRelated(child, path+'/related'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeObservation(xml : TXmlBuilder; name : string; elem : TFhirObservation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeCodeableConcept(xml, 'name', elem.name);
  if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (elem.value is TFhirRatio) {6} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(elem.value))
  else if (elem.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value))
  else if (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(elem.value))
  else if (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value));
  ComposeCodeableConcept(xml, 'interpretation', elem.interpretation);
  ComposeString(xml, 'comments', elem.comments);
  if (elem.applies is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'appliesDateTime', TFhirDateTime(elem.applies))
  else if (elem.applies is TFhirPeriod) {6} then
    ComposePeriod(xml, 'appliesPeriod', TFhirPeriod(elem.applies));
  ComposeInstant(xml, 'issued', elem.issued);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirObservationStatus);
  ComposeEnum(xml, 'reliability', elem.Reliability, CODES_TFhirObservationReliability);
  ComposeCodeableConcept(xml, 'bodySite', elem.bodySite);
  ComposeCodeableConcept(xml, 'method', elem.method);
  ComposeIdentifier(xml, 'identifier', elem.identifier);
  ComposeResourceReference{Resource}(xml, 'subject', elem.subject);
  ComposeResourceReference{TFhirSpecimen}(xml, 'specimen', elem.specimen);
  for i := 0 to elem.performerList.Count - 1 do
    ComposeResourceReference{Resource}(xml, 'performer', elem.performerList[i]);
  for i := 0 to elem.referenceRangeList.Count - 1 do
    ComposeObservationReferenceRange(xml, 'referenceRange', elem.referenceRangeList[i]);
  for i := 0 to elem.relatedList.Count - 1 do
    ComposeObservationRelated(xml, 'related', elem.relatedList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseObservation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseObservation(jsn));
end;

function TFHIRJsonParser.ParseObservation(jsn : TJsonObject) : TFhirObservation;
begin
  result := TFhirObservation.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('name') then
        result.name := ParseCodeableConcept(jsn.vObj['name']);{q}
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueCodeableConcept') {a4} then
      result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueAttachment') {a4} then
      result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueRatio') {a4} then
      result.value := ParseRatio(jsn.vObj['valueRatio']);
    if jsn.has('valuePeriod') {a4} then
      result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('valueSampledData') {a4} then
      result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn['valueString'], jsn.vObj['_valueString']);
    if jsn.has('interpretation') then
        result.interpretation := ParseCodeableConcept(jsn.vObj['interpretation']);{q}
    if jsn.has('comments') or jsn.has('_comments') then
        result.comments := ParseString(jsn['comments'], jsn.vObj['_comments']);{q}
    if jsn.has('appliesDateTime') or jsn.has('_appliesDateTime') then
      result.applies := parseDateTime(jsn['appliesDateTime'], jsn.vObj['_appliesDateTime']);
    if jsn.has('appliesPeriod') {a4} then
      result.applies := ParsePeriod(jsn.vObj['appliesPeriod']);
    if jsn.has('issued') or jsn.has('_issued') then
        result.issued := ParseInstant(jsn['issued'], jsn.vObj['_issued']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirObservationStatus);
    if jsn.has('reliability') or jsn.has('_reliability')  then
      result.reliability := parseEnum(jsn['reliability'], jsn.vObj['_reliability'], CODES_TFhirObservationReliability);
    if jsn.has('bodySite') then
        result.bodySite := ParseCodeableConcept(jsn.vObj['bodySite']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('subject') then
        result.subject := ParseResourceReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('specimen') then
        result.specimen := ParseResourceReference{TFhirSpecimen}(jsn.vObj['specimen']);{q}
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseResourceReference{Resource});
    if jsn.has('referenceRange') then
      iterateArray(jsn.vArr['referenceRange'], result.referenceRangeList, parseObservationReferenceRange);
    if jsn.has('related') then
      iterateArray(jsn.vArr['related'], result.relatedList, parseObservationRelated);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeObservation(json : TJSONWriter; name : string; elem : TFhirObservation);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeCodeableConcept(json, 'name', elem.name); {a}
  if (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (elem.value is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value)) 
  else if (elem.value is TFhirAttachment) then 
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value)) 
  else if (elem.value is TFhirRatio) then 
    ComposeRatio(json, 'valueRatio', TFhirRatio(elem.value)) 
  else if (elem.value is TFhirPeriod) then 
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value)) 
  else if (elem.value is TFhirSampledData) then 
    ComposeSampledData(json, 'valueSampledData', TFhirSampledData(elem.value)) 
  else if (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end;
  ComposeCodeableConcept(json, 'interpretation', elem.interpretation); {a}
  ComposeStringValue(json, 'comments', elem.comments, false);
  ComposeStringProps(json, 'comments', elem.comments, false);
  if (elem.applies is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'appliesDateTime', TFhirDateTime(elem.applies), false);
    ComposeDateTimeProps(json, 'appliesDateTime', TFhirDateTime(elem.applies), false);
  end
  else if (elem.applies is TFhirPeriod) then 
    ComposePeriod(json, 'appliesPeriod', TFhirPeriod(elem.applies)) ;
  ComposeInstantValue(json, 'issued', elem.issued, false);
  ComposeInstantProps(json, 'issued', elem.issued, false);
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirObservationStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirObservationStatus, false);
  ComposeEnumValue(json, 'reliability', elem.Reliability, CODES_TFhirObservationReliability, false);
  ComposeEnumProps(json, 'reliability', elem.Reliability, CODES_TFhirObservationReliability, false);
  ComposeCodeableConcept(json, 'bodySite', elem.bodySite); {a}
  ComposeCodeableConcept(json, 'method', elem.method); {a}
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeResourceReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeResourceReference{TFhirSpecimen}(json, 'specimen', elem.specimen); {a}
  if elem.performerList.Count > 0 then
  begin
    json.valueArray('performer');
    for i := 0 to elem.performerList.Count - 1 do
      ComposeResourceReference{Resource}(json, '',elem.performerList[i]); {z - Resource(Practitioner|Device|Organization)}
    json.FinishArray;
  end;
  if elem.referenceRangeList.Count > 0 then
  begin
    json.valueArray('referenceRange');
    for i := 0 to elem.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(json, '',elem.referenceRangeList[i]); {z - }
    json.FinishArray;
  end;
  if elem.relatedList.Count > 0 then
  begin
    json.valueArray('related');
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeObservationRelated(json, '',elem.relatedList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseOperationOutcomeIssue(element : IXmlDomElement; path : string) : TFhirOperationOutcomeIssue;
var
  child : IXMLDOMElement;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'severity') then
        result.severity := ParseEnum(CODES_TFhirIssueSeverity, path+'/severity', child)
      else if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'details') then
        result.details := ParseString(child, path+'/details') {b}
      else if (child.baseName = 'location') then
        result.locationList.Add(ParseString(child, path+'/location'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOperationOutcomeIssue(xml : TXmlBuilder; name : string; elem : TFhirOperationOutcomeIssue);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'severity', elem.Severity, CODES_TFhirIssueSeverity);
  ComposeCoding(xml, 'type', elem.type_);
  ComposeString(xml, 'details', elem.details);
  for i := 0 to elem.locationList.Count - 1 do
    ComposeString(xml, 'location', elem.locationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOperationOutcomeIssue(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationOutcomeIssue(jsn));
end;

function TFHIRJsonParser.ParseOperationOutcomeIssue(jsn : TJsonObject) : TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('severity') or jsn.has('_severity')  then
      result.severity := parseEnum(jsn['severity'], jsn.vObj['_severity'], CODES_TFhirIssueSeverity);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('details') or jsn.has('_details') then
        result.details := ParseString(jsn['details'], jsn.vObj['_details']);{q}
      if jsn.has('location') or jsn.has('_location') then
      iteratePrimitiveArray(jsn.vArr['location'], jsn.vArr['_location'], result.locationList, parseString);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOperationOutcomeIssue(json : TJSONWriter; name : string; elem : TFhirOperationOutcomeIssue);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'severity', elem.Severity, CODES_TFhirIssueSeverity, false);
  ComposeEnumProps(json, 'severity', elem.Severity, CODES_TFhirIssueSeverity, false);
  ComposeCoding(json, 'type', elem.type_); {a}
  ComposeStringValue(json, 'details', elem.details, false);
  ComposeStringProps(json, 'details', elem.details, false);
  if elem.locationList.Count > 0 then
  begin
    json.valueArray('location');
    ext := false;
    for i := 0 to elem.locationList.Count - 1 do
    begin
      ext := ext or ((elem.locationList[i].xmlid <> '') or (elem.locationList[i].hasExtensions));
      ComposeStringValue(json, '',elem.locationList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_location');
      for i := 0 to elem.locationList.Count - 1 do
        ComposeStringProps(json, '',elem.locationList[i], true);
      json.FinishArray;
    end;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseOperationOutcome(element : IXmlDomElement; path : string) : TFhirOperationOutcome;
var
  child : IXMLDOMElement;
begin
  result := TFhirOperationOutcome.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'issue') then
        result.issueList.Add(ParseOperationOutcomeIssue(child, path+'/issue'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOperationOutcome(xml : TXmlBuilder; name : string; elem : TFhirOperationOutcome);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.issueList.Count - 1 do
    ComposeOperationOutcomeIssue(xml, 'issue', elem.issueList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOperationOutcome(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationOutcome(jsn));
end;

function TFHIRJsonParser.ParseOperationOutcome(jsn : TJsonObject) : TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('issue') then
      iterateArray(jsn.vArr['issue'], result.issueList, parseOperationOutcomeIssue);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOperationOutcome(json : TJSONWriter; name : string; elem : TFhirOperationOutcome);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.issueList.Count > 0 then
  begin
    json.valueArray('issue');
    for i := 0 to elem.issueList.Count - 1 do
      ComposeOperationOutcomeIssue(json, '',elem.issueList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseOrderWhen(element : IXmlDomElement; path : string) : TFhirOrderWhen;
var
  child : IXMLDOMElement;
begin
  result := TFhirOrderWhen.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'schedule') then
        result.schedule := ParseSchedule(child, path+'/schedule') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOrderWhen(xml : TXmlBuilder; name : string; elem : TFhirOrderWhen);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);
  ComposeSchedule(xml, 'schedule', elem.schedule);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOrderWhen(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrderWhen(jsn));
end;

function TFHIRJsonParser.ParseOrderWhen(jsn : TJsonObject) : TFhirOrderWhen;
begin
  result := TFhirOrderWhen.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('schedule') then
        result.schedule := ParseSchedule(jsn.vObj['schedule']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOrderWhen(json : TJSONWriter; name : string; elem : TFhirOrderWhen);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeSchedule(json, 'schedule', elem.schedule); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseOrder(element : IXmlDomElement; path : string) : TFhirOrder;
var
  child : IXMLDOMElement;
begin
  result := TFhirOrder.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'date') then
        result.date := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseResourceReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'source') then
        result.source := ParseResourceReference{TFhirPractitioner}(child, path+'/source') {b}
      else if (child.baseName = 'target') then
        result.target := ParseResourceReference{Resource}(child, path+'/target') {b}
      else if (child.baseName = 'reasonCodeableConcept') then
        result.reason := ParseCodeableConcept(child, path+'/reasonCodeableConcept')
      else if (child.baseName = 'reasonResource') then
        result.reason := ParseResourceReference(child, path+'/reasonResource') {a}
      else if (child.baseName = 'authority') then
        result.authority := ParseResourceReference{Resource}(child, path+'/authority') {b}
      else if (child.baseName = 'when') then
        result.when := ParseOrderWhen(child, path+'/when') {b}
      else if (child.baseName = 'detail') then
        result.detailList.Add(ParseResourceReference{Resource}(child, path+'/detail'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOrder(xml : TXmlBuilder; name : string; elem : TFhirOrder);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeDateTime(xml, 'date', elem.date);
  ComposeResourceReference{TFhirPatient}(xml, 'subject', elem.subject);
  ComposeResourceReference{TFhirPractitioner}(xml, 'source', elem.source);
  ComposeResourceReference{Resource}(xml, 'target', elem.target);
  if (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason))
  else if (elem.reason is TFhirResourceReference) {2} then
    ComposeResourceReference(xml, 'reasonResource', TFhirResourceReference(elem.reason));
  ComposeResourceReference{Resource}(xml, 'authority', elem.authority);
  ComposeOrderWhen(xml, 'when', elem.when);
  for i := 0 to elem.detailList.Count - 1 do
    ComposeResourceReference{Resource}(xml, 'detail', elem.detailList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOrder(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrder(jsn));
end;

function TFHIRJsonParser.ParseOrder(jsn : TJsonObject) : TFhirOrder;
begin
  result := TFhirOrder.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('date') or jsn.has('_date') then
        result.date := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('subject') then
        result.subject := ParseResourceReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('source') then
        result.source := ParseResourceReference{TFhirPractitioner}(jsn.vObj['source']);{q}
    if jsn.has('target') then
        result.target := ParseResourceReference{Resource}(jsn.vObj['target']);{q}
    if jsn.has('reasonCodeableConcept') {a4} then
      result.reason := ParseCodeableConcept(jsn.vObj['reasonCodeableConcept']);
    if jsn.has('reasonResource') {a3} then
      result.reason := ParseResourceReference(jsn.vObj['reasonResource']);
    if jsn.has('authority') then
        result.authority := ParseResourceReference{Resource}(jsn.vObj['authority']);{q}
    if jsn.has('when') then
        result.when := ParseOrderWhen(jsn.vObj['when']);{q}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseResourceReference{Resource});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOrder(json : TJSONWriter; name : string; elem : TFhirOrder);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeDateTimeValue(json, 'date', elem.date, false);
  ComposeDateTimeProps(json, 'date', elem.date, false);
  ComposeResourceReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  ComposeResourceReference{TFhirPractitioner}(json, 'source', elem.source); {a}
  ComposeResourceReference{Resource}(json, 'target', elem.target); {a}
  if (elem.reason is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason)) 
  else if (elem.reason is TFhirResourceReference) then
    ComposeResourceReference(json, 'reasonResource', TFhirResourceReference(elem.reason));
  ComposeResourceReference{Resource}(json, 'authority', elem.authority); {a}
  ComposeOrderWhen(json, 'when', elem.when); {a}
  if elem.detailList.Count > 0 then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeResourceReference{Resource}(json, '',elem.detailList[i]); {z - Resource(Any)}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseOrderResponse(element : IXmlDomElement; path : string) : TFhirOrderResponse;
var
  child : IXMLDOMElement;
begin
  result := TFhirOrderResponse.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'request') then
        result.request := ParseResourceReference{TFhirOrder}(child, path+'/request') {b}
      else if (child.baseName = 'date') then
        result.date := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'who') then
        result.who := ParseResourceReference{Resource}(child, path+'/who') {b}
      else if (child.baseName = 'authorityCodeableConcept') then
        result.authority := ParseCodeableConcept(child, path+'/authorityCodeableConcept')
      else if (child.baseName = 'authorityResource') then
        result.authority := ParseResourceReference(child, path+'/authorityResource') {a}
      else if (child.baseName = 'code') then
        result.code := ParseEnum(CODES_TFhirOrderOutcomeCode, path+'/code', child)
      else if (child.baseName = 'description') then
        result.description := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'fulfillment') then
        result.fulfillmentList.Add(ParseResourceReference{Resource}(child, path+'/fulfillment'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOrderResponse(xml : TXmlBuilder; name : string; elem : TFhirOrderResponse);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeResourceReference{TFhirOrder}(xml, 'request', elem.request);
  ComposeDateTime(xml, 'date', elem.date);
  ComposeResourceReference{Resource}(xml, 'who', elem.who);
  if (elem.authority is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'authorityCodeableConcept', TFhirCodeableConcept(elem.authority))
  else if (elem.authority is TFhirResourceReference) {2} then
    ComposeResourceReference(xml, 'authorityResource', TFhirResourceReference(elem.authority));
  ComposeEnum(xml, 'code', elem.Code, CODES_TFhirOrderOutcomeCode);
  ComposeString(xml, 'description', elem.description);
  for i := 0 to elem.fulfillmentList.Count - 1 do
    ComposeResourceReference{Resource}(xml, 'fulfillment', elem.fulfillmentList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOrderResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrderResponse(jsn));
end;

function TFHIRJsonParser.ParseOrderResponse(jsn : TJsonObject) : TFhirOrderResponse;
begin
  result := TFhirOrderResponse.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('request') then
        result.request := ParseResourceReference{TFhirOrder}(jsn.vObj['request']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.date := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('who') then
        result.who := ParseResourceReference{Resource}(jsn.vObj['who']);{q}
    if jsn.has('authorityCodeableConcept') {a4} then
      result.authority := ParseCodeableConcept(jsn.vObj['authorityCodeableConcept']);
    if jsn.has('authorityResource') {a3} then
      result.authority := ParseResourceReference(jsn.vObj['authorityResource']);
    if jsn.has('code') or jsn.has('_code')  then
      result.code := parseEnum(jsn['code'], jsn.vObj['_code'], CODES_TFhirOrderOutcomeCode);
    if jsn.has('description') or jsn.has('_description') then
        result.description := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('fulfillment') then
      iterateArray(jsn.vArr['fulfillment'], result.fulfillmentList, parseResourceReference{Resource});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOrderResponse(json : TJSONWriter; name : string; elem : TFhirOrderResponse);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeResourceReference{TFhirOrder}(json, 'request', elem.request); {a}
  ComposeDateTimeValue(json, 'date', elem.date, false);
  ComposeDateTimeProps(json, 'date', elem.date, false);
  ComposeResourceReference{Resource}(json, 'who', elem.who); {a}
  if (elem.authority is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'authorityCodeableConcept', TFhirCodeableConcept(elem.authority)) 
  else if (elem.authority is TFhirResourceReference) then
    ComposeResourceReference(json, 'authorityResource', TFhirResourceReference(elem.authority));
  ComposeEnumValue(json, 'code', elem.Code, CODES_TFhirOrderOutcomeCode, false);
  ComposeEnumProps(json, 'code', elem.Code, CODES_TFhirOrderOutcomeCode, false);
  ComposeStringValue(json, 'description', elem.description, false);
  ComposeStringProps(json, 'description', elem.description, false);
  if elem.fulfillmentList.Count > 0 then
  begin
    json.valueArray('fulfillment');
    for i := 0 to elem.fulfillmentList.Count - 1 do
      ComposeResourceReference{Resource}(json, '',elem.fulfillmentList[i]); {z - Resource(Any)}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseOrganizationContact(element : IXmlDomElement; path : string) : TFhirOrganizationContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirOrganizationContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'purpose') then
        result.purpose := ParseCodeableConcept(child, path+'/purpose') {b}
      else if (child.baseName = 'name') then
        result.name := ParseHumanName(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContact(child, path+'/telecom'))
      else if (child.baseName = 'address') then
        result.address := ParseAddress(child, path+'/address') {b}
      else if (child.baseName = 'gender') then
        result.gender := ParseCodeableConcept(child, path+'/gender') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOrganizationContact(xml : TXmlBuilder; name : string; elem : TFhirOrganizationContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'purpose', elem.purpose);
  ComposeHumanName(xml, 'name', elem.name);
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContact(xml, 'telecom', elem.telecomList[i]);
  ComposeAddress(xml, 'address', elem.address);
  ComposeCodeableConcept(xml, 'gender', elem.gender);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOrganizationContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrganizationContact(jsn));
end;

function TFHIRJsonParser.ParseOrganizationContact(jsn : TJsonObject) : TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('purpose') then
        result.purpose := ParseCodeableConcept(jsn.vObj['purpose']);{q}
    if jsn.has('name') then
        result.name := ParseHumanName(jsn.vObj['name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContact);
    if jsn.has('address') then
        result.address := ParseAddress(jsn.vObj['address']);{q}
    if jsn.has('gender') then
        result.gender := ParseCodeableConcept(jsn.vObj['gender']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOrganizationContact(json : TJSONWriter; name : string; elem : TFhirOrganizationContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'purpose', elem.purpose); {a}
  ComposeHumanName(json, 'name', elem.name); {a}
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContact(json, '',elem.telecomList[i]); {z - Contact}
    json.FinishArray;
  end;
  ComposeAddress(json, 'address', elem.address); {a}
  ComposeCodeableConcept(json, 'gender', elem.gender); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseOrganization(element : IXmlDomElement; path : string) : TFhirOrganization;
var
  child : IXMLDOMElement;
begin
  result := TFhirOrganization.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'name') then
        result.name := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContact(child, path+'/telecom'))
      else if (child.baseName = 'address') then
        result.addressList.Add(ParseAddress(child, path+'/address'))
      else if (child.baseName = 'partOf') then
        result.partOf := ParseResourceReference{TFhirOrganization}(child, path+'/partOf') {b}
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParseOrganizationContact(child, path+'/contact'))
      else if (child.baseName = 'location') then
        result.locationList.Add(ParseResourceReference{TFhirLocation}(child, path+'/location'))
      else if (child.baseName = 'active') then
        result.active := ParseBoolean(child, path+'/active') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOrganization(xml : TXmlBuilder; name : string; elem : TFhirOrganization);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeString(xml, 'name', elem.name);
  ComposeCodeableConcept(xml, 'type', elem.type_);
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContact(xml, 'telecom', elem.telecomList[i]);
  for i := 0 to elem.addressList.Count - 1 do
    ComposeAddress(xml, 'address', elem.addressList[i]);
  ComposeResourceReference{TFhirOrganization}(xml, 'partOf', elem.partOf);
  for i := 0 to elem.contactList.Count - 1 do
    ComposeOrganizationContact(xml, 'contact', elem.contactList[i]);
  for i := 0 to elem.locationList.Count - 1 do
    ComposeResourceReference{TFhirLocation}(xml, 'location', elem.locationList[i]);
  ComposeBoolean(xml, 'active', elem.active);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOrganization(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrganization(jsn));
end;

function TFHIRJsonParser.ParseOrganization(jsn : TJsonObject) : TFhirOrganization;
begin
  result := TFhirOrganization.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('name') or jsn.has('_name') then
        result.name := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContact);
    if jsn.has('address') then
      iterateArray(jsn.vArr['address'], result.addressList, parseAddress);
    if jsn.has('partOf') then
        result.partOf := ParseResourceReference{TFhirOrganization}(jsn.vObj['partOf']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseOrganizationContact);
    if jsn.has('location') then
      iterateArray(jsn.vArr['location'], result.locationList, parseResourceReference{TFhirLocation});
    if jsn.has('active') or jsn.has('_active') then
        result.active := ParseBoolean(jsn['active'], jsn.vObj['_active']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOrganization(json : TJSONWriter; name : string; elem : TFhirOrganization);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'name', elem.name, false);
  ComposeStringProps(json, 'name', elem.name, false);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContact(json, '',elem.telecomList[i]); {z - Contact}
    json.FinishArray;
  end;
  if elem.addressList.Count > 0 then
  begin
    json.valueArray('address');
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(json, '',elem.addressList[i]); {z - Address}
    json.FinishArray;
  end;
  ComposeResourceReference{TFhirOrganization}(json, 'partOf', elem.partOf); {a}
  if elem.contactList.Count > 0 then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeOrganizationContact(json, '',elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  if elem.locationList.Count > 0 then
  begin
    json.valueArray('location');
    for i := 0 to elem.locationList.Count - 1 do
      ComposeResourceReference{TFhirLocation}(json, '',elem.locationList[i]); {z - Resource(Location)}
    json.FinishArray;
  end;
  ComposeBooleanValue(json, 'active', elem.active, false);
  ComposeBooleanProps(json, 'active', elem.active, false);
end;

function TFHIRXmlParser.ParseOther(element : IXmlDomElement; path : string) : TFhirOther;
var
  child : IXMLDOMElement;
begin
  result := TFhirOther.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseResourceReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'author') then
        result.author := ParseResourceReference{Resource}(child, path+'/author') {b}
      else if (child.baseName = 'created') then
        result.created := ParseDate(child, path+'/created') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeOther(xml : TXmlBuilder; name : string; elem : TFhirOther);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'code', elem.code);
  ComposeResourceReference{Resource}(xml, 'subject', elem.subject);
  ComposeResourceReference{Resource}(xml, 'author', elem.author);
  ComposeDate(xml, 'created', elem.created);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseOther(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOther(jsn));
end;

function TFHIRJsonParser.ParseOther(jsn : TJsonObject) : TFhirOther;
begin
  result := TFhirOther.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('subject') then
        result.subject := ParseResourceReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('author') then
        result.author := ParseResourceReference{Resource}(jsn.vObj['author']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.created := ParseDate(jsn['created'], jsn.vObj['_created']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeOther(json : TJSONWriter; name : string; elem : TFhirOther);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeResourceReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeResourceReference{Resource}(json, 'author', elem.author); {a}
  ComposeDateValue(json, 'created', elem.created, false);
  ComposeDateProps(json, 'created', elem.created, false);
end;

function TFHIRXmlParser.ParsePatientContact(element : IXmlDomElement; path : string) : TFhirPatientContact;
var
  child : IXMLDOMElement;
begin
  result := TFhirPatientContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'relationship') then
        result.relationshipList.Add(ParseCodeableConcept(child, path+'/relationship'))
      else if (child.baseName = 'name') then
        result.name := ParseHumanName(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContact(child, path+'/telecom'))
      else if (child.baseName = 'address') then
        result.address := ParseAddress(child, path+'/address') {b}
      else if (child.baseName = 'gender') then
        result.gender := ParseCodeableConcept(child, path+'/gender') {b}
      else if (child.baseName = 'organization') then
        result.organization := ParseResourceReference{TFhirOrganization}(child, path+'/organization') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePatientContact(xml : TXmlBuilder; name : string; elem : TFhirPatientContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.relationshipList.Count - 1 do
    ComposeCodeableConcept(xml, 'relationship', elem.relationshipList[i]);
  ComposeHumanName(xml, 'name', elem.name);
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContact(xml, 'telecom', elem.telecomList[i]);
  ComposeAddress(xml, 'address', elem.address);
  ComposeCodeableConcept(xml, 'gender', elem.gender);
  ComposeResourceReference{TFhirOrganization}(xml, 'organization', elem.organization);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePatientContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatientContact(jsn));
end;

function TFHIRJsonParser.ParsePatientContact(jsn : TJsonObject) : TFhirPatientContact;
begin
  result := TFhirPatientContact.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('relationship') then
      iterateArray(jsn.vArr['relationship'], result.relationshipList, parseCodeableConcept);
    if jsn.has('name') then
        result.name := ParseHumanName(jsn.vObj['name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContact);
    if jsn.has('address') then
        result.address := ParseAddress(jsn.vObj['address']);{q}
    if jsn.has('gender') then
        result.gender := ParseCodeableConcept(jsn.vObj['gender']);{q}
    if jsn.has('organization') then
        result.organization := ParseResourceReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePatientContact(json : TJSONWriter; name : string; elem : TFhirPatientContact);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.relationshipList.Count > 0 then
  begin
    json.valueArray('relationship');
    for i := 0 to elem.relationshipList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.relationshipList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeHumanName(json, 'name', elem.name); {a}
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContact(json, '',elem.telecomList[i]); {z - Contact}
    json.FinishArray;
  end;
  ComposeAddress(json, 'address', elem.address); {a}
  ComposeCodeableConcept(json, 'gender', elem.gender); {a}
  ComposeResourceReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParsePatientAnimal(element : IXmlDomElement; path : string) : TFhirPatientAnimal;
var
  child : IXMLDOMElement;
begin
  result := TFhirPatientAnimal.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'species') then
        result.species := ParseCodeableConcept(child, path+'/species') {b}
      else if (child.baseName = 'breed') then
        result.breed := ParseCodeableConcept(child, path+'/breed') {b}
      else if (child.baseName = 'genderStatus') then
        result.genderStatus := ParseCodeableConcept(child, path+'/genderStatus') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePatientAnimal(xml : TXmlBuilder; name : string; elem : TFhirPatientAnimal);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'species', elem.species);
  ComposeCodeableConcept(xml, 'breed', elem.breed);
  ComposeCodeableConcept(xml, 'genderStatus', elem.genderStatus);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePatientAnimal(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatientAnimal(jsn));
end;

function TFHIRJsonParser.ParsePatientAnimal(jsn : TJsonObject) : TFhirPatientAnimal;
begin
  result := TFhirPatientAnimal.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('species') then
        result.species := ParseCodeableConcept(jsn.vObj['species']);{q}
    if jsn.has('breed') then
        result.breed := ParseCodeableConcept(jsn.vObj['breed']);{q}
    if jsn.has('genderStatus') then
        result.genderStatus := ParseCodeableConcept(jsn.vObj['genderStatus']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePatientAnimal(json : TJSONWriter; name : string; elem : TFhirPatientAnimal);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'species', elem.species); {a}
  ComposeCodeableConcept(json, 'breed', elem.breed); {a}
  ComposeCodeableConcept(json, 'genderStatus', elem.genderStatus); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParsePatientLink(element : IXmlDomElement; path : string) : TFhirPatientLink;
var
  child : IXMLDOMElement;
begin
  result := TFhirPatientLink.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'other') then
        result.other := ParseResourceReference{TFhirPatient}(child, path+'/other') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseEnum(CODES_TFhirLinkType, path+'/type', child)
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePatientLink(xml : TXmlBuilder; name : string; elem : TFhirPatientLink);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeResourceReference{TFhirPatient}(xml, 'other', elem.other);
  ComposeEnum(xml, 'type', elem.Type_, CODES_TFhirLinkType);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePatientLink(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatientLink(jsn));
end;

function TFHIRJsonParser.ParsePatientLink(jsn : TJsonObject) : TFhirPatientLink;
begin
  result := TFhirPatientLink.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('other') then
        result.other := ParseResourceReference{TFhirPatient}(jsn.vObj['other']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_ := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirLinkType);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePatientLink(json : TJSONWriter; name : string; elem : TFhirPatientLink);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeResourceReference{TFhirPatient}(json, 'other', elem.other); {a}
  ComposeEnumValue(json, 'type', elem.Type_, CODES_TFhirLinkType, false);
  ComposeEnumProps(json, 'type', elem.Type_, CODES_TFhirLinkType, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParsePatient(element : IXmlDomElement; path : string) : TFhirPatient;
var
  child : IXMLDOMElement;
begin
  result := TFhirPatient.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'name') then
        result.nameList.Add(ParseHumanName(child, path+'/name'))
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContact(child, path+'/telecom'))
      else if (child.baseName = 'gender') then
        result.gender := ParseCodeableConcept(child, path+'/gender') {b}
      else if (child.baseName = 'birthDate') then
        result.birthDate := ParseDateTime(child, path+'/birthDate') {b}
      else if (child.baseName = 'deceasedBoolean') then
        result.deceased := ParseBoolean(child, path+'/deceasedBoolean')
      else if (child.baseName = 'deceasedDateTime') then
        result.deceased := ParseDateTime(child, path+'/deceasedDateTime')
      else if (child.baseName = 'address') then
        result.addressList.Add(ParseAddress(child, path+'/address'))
      else if (child.baseName = 'maritalStatus') then
        result.maritalStatus := ParseCodeableConcept(child, path+'/maritalStatus') {b}
      else if (child.baseName = 'multipleBirthBoolean') then
        result.multipleBirth := ParseBoolean(child, path+'/multipleBirthBoolean')
      else if (child.baseName = 'multipleBirthInteger') then
        result.multipleBirth := ParseInteger(child, path+'/multipleBirthInteger')
      else if (child.baseName = 'photo') then
        result.photoList.Add(ParseAttachment(child, path+'/photo'))
      else if (child.baseName = 'contact') then
        result.contactList.Add(ParsePatientContact(child, path+'/contact'))
      else if (child.baseName = 'animal') then
        result.animal := ParsePatientAnimal(child, path+'/animal') {b}
      else if (child.baseName = 'communication') then
        result.communicationList.Add(ParseCodeableConcept(child, path+'/communication'))
      else if (child.baseName = 'careProvider') then
        result.careProviderList.Add(ParseResourceReference{Resource}(child, path+'/careProvider'))
      else if (child.baseName = 'managingOrganization') then
        result.managingOrganization := ParseResourceReference{TFhirOrganization}(child, path+'/managingOrganization') {b}
      else if (child.baseName = 'link') then
        result.link_List.Add(ParsePatientLink(child, path+'/link'))
      else if (child.baseName = 'active') then
        result.active := ParseBoolean(child, path+'/active') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePatient(xml : TXmlBuilder; name : string; elem : TFhirPatient);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  for i := 0 to elem.nameList.Count - 1 do
    ComposeHumanName(xml, 'name', elem.nameList[i]);
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContact(xml, 'telecom', elem.telecomList[i]);
  ComposeCodeableConcept(xml, 'gender', elem.gender);
  ComposeDateTime(xml, 'birthDate', elem.birthDate);
  if (elem.deceased is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'deceasedBoolean', TFhirBoolean(elem.deceased))
  else if (elem.deceased is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'deceasedDateTime', TFhirDateTime(elem.deceased));
  for i := 0 to elem.addressList.Count - 1 do
    ComposeAddress(xml, 'address', elem.addressList[i]);
  ComposeCodeableConcept(xml, 'maritalStatus', elem.maritalStatus);
  if (elem.multipleBirth is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'multipleBirthBoolean', TFhirBoolean(elem.multipleBirth))
  else if (elem.multipleBirth is TFhirInteger) {6} then
    ComposeInteger(xml, 'multipleBirthInteger', TFhirInteger(elem.multipleBirth));
  if not SummaryOnly then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(xml, 'photo', elem.photoList[i]);
  if not SummaryOnly then
    for i := 0 to elem.contactList.Count - 1 do
      ComposePatientContact(xml, 'contact', elem.contactList[i]);
  ComposePatientAnimal(xml, 'animal', elem.animal);
  if not SummaryOnly then
    for i := 0 to elem.communicationList.Count - 1 do
      ComposeCodeableConcept(xml, 'communication', elem.communicationList[i]);
  if not SummaryOnly then
    for i := 0 to elem.careProviderList.Count - 1 do
      ComposeResourceReference{Resource}(xml, 'careProvider', elem.careProviderList[i]);
  ComposeResourceReference{TFhirOrganization}(xml, 'managingOrganization', elem.managingOrganization);
  for i := 0 to elem.link_List.Count - 1 do
    ComposePatientLink(xml, 'link', elem.link_List[i]);
  ComposeBoolean(xml, 'active', elem.active);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePatient(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatient(jsn));
end;

function TFHIRJsonParser.ParsePatient(jsn : TJsonObject) : TFhirPatient;
begin
  result := TFhirPatient.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('name') then
      iterateArray(jsn.vArr['name'], result.nameList, parseHumanName);
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContact);
    if jsn.has('gender') then
        result.gender := ParseCodeableConcept(jsn.vObj['gender']);{q}
    if jsn.has('birthDate') or jsn.has('_birthDate') then
        result.birthDate := ParseDateTime(jsn['birthDate'], jsn.vObj['_birthDate']);{q}
    if jsn.has('deceasedBoolean') or jsn.has('_deceasedBoolean') then
      result.deceased := parseBoolean(jsn['deceasedBoolean'], jsn.vObj['_deceasedBoolean']);
    if jsn.has('deceasedDateTime') or jsn.has('_deceasedDateTime') then
      result.deceased := parseDateTime(jsn['deceasedDateTime'], jsn.vObj['_deceasedDateTime']);
    if jsn.has('address') then
      iterateArray(jsn.vArr['address'], result.addressList, parseAddress);
    if jsn.has('maritalStatus') then
        result.maritalStatus := ParseCodeableConcept(jsn.vObj['maritalStatus']);{q}
    if jsn.has('multipleBirthBoolean') or jsn.has('_multipleBirthBoolean') then
      result.multipleBirth := parseBoolean(jsn['multipleBirthBoolean'], jsn.vObj['_multipleBirthBoolean']);
    if jsn.has('multipleBirthInteger') or jsn.has('_multipleBirthInteger') then
      result.multipleBirth := parseInteger(jsn['multipleBirthInteger'], jsn.vObj['_multipleBirthInteger']);
    if jsn.has('photo') then
      iterateArray(jsn.vArr['photo'], result.photoList, parseAttachment);
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parsePatientContact);
    if jsn.has('animal') then
        result.animal := ParsePatientAnimal(jsn.vObj['animal']);{q}
    if jsn.has('communication') then
      iterateArray(jsn.vArr['communication'], result.communicationList, parseCodeableConcept);
    if jsn.has('careProvider') then
      iterateArray(jsn.vArr['careProvider'], result.careProviderList, parseResourceReference{Resource});
    if jsn.has('managingOrganization') then
        result.managingOrganization := ParseResourceReference{TFhirOrganization}(jsn.vObj['managingOrganization']);{q}
    if jsn.has('link') then
      iterateArray(jsn.vArr['link'], result.link_List, parsePatientLink);
    if jsn.has('active') or jsn.has('_active') then
        result.active := ParseBoolean(jsn['active'], jsn.vObj['_active']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePatient(json : TJSONWriter; name : string; elem : TFhirPatient);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if elem.nameList.Count > 0 then
  begin
    json.valueArray('name');
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(json, '',elem.nameList[i]); {z - HumanName}
    json.FinishArray;
  end;
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContact(json, '',elem.telecomList[i]); {z - Contact}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'gender', elem.gender); {a}
  ComposeDateTimeValue(json, 'birthDate', elem.birthDate, false);
  ComposeDateTimeProps(json, 'birthDate', elem.birthDate, false);
  if (elem.deceased is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'deceasedBoolean', TFhirBoolean(elem.deceased), false);
    ComposeBooleanProps(json, 'deceasedBoolean', TFhirBoolean(elem.deceased), false);
  end
  else if (elem.deceased is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'deceasedDateTime', TFhirDateTime(elem.deceased), false);
    ComposeDateTimeProps(json, 'deceasedDateTime', TFhirDateTime(elem.deceased), false);
  end;
  if elem.addressList.Count > 0 then
  begin
    json.valueArray('address');
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(json, '',elem.addressList[i]); {z - Address}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'maritalStatus', elem.maritalStatus); {a}
  if (elem.multipleBirth is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'multipleBirthBoolean', TFhirBoolean(elem.multipleBirth), false);
    ComposeBooleanProps(json, 'multipleBirthBoolean', TFhirBoolean(elem.multipleBirth), false);
  end
  else if (elem.multipleBirth is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'multipleBirthInteger', TFhirInteger(elem.multipleBirth), false);
    ComposeIntegerProps(json, 'multipleBirthInteger', TFhirInteger(elem.multipleBirth), false);
  end;
  if not SummaryOnly and (elem.photoList.Count > 0) then
  begin
    json.valueArray('photo');
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(json, '',elem.photoList[i]); {z - Attachment}
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposePatientContact(json, '',elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  ComposePatientAnimal(json, 'animal', elem.animal); {a}
  if not SummaryOnly and (elem.communicationList.Count > 0) then
  begin
    json.valueArray('communication');
    for i := 0 to elem.communicationList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.communicationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.careProviderList.Count > 0) then
  begin
    json.valueArray('careProvider');
    for i := 0 to elem.careProviderList.Count - 1 do
      ComposeResourceReference{Resource}(json, '',elem.careProviderList[i]); {z - Resource(Organization|Practitioner)}
    json.FinishArray;
  end;
  ComposeResourceReference{TFhirOrganization}(json, 'managingOrganization', elem.managingOrganization); {a}
  if elem.link_List.Count > 0 then
  begin
    json.valueArray('link');
    for i := 0 to elem.link_List.Count - 1 do
      ComposePatientLink(json, '',elem.link_List[i]); {z - }
    json.FinishArray;
  end;
  ComposeBooleanValue(json, 'active', elem.active, false);
  ComposeBooleanProps(json, 'active', elem.active, false);
end;

function TFHIRXmlParser.ParsePractitionerQualification(element : IXmlDomElement; path : string) : TFhirPractitionerQualification;
var
  child : IXMLDOMElement;
begin
  result := TFhirPractitionerQualification.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'issuer') then
        result.issuer := ParseResourceReference{TFhirOrganization}(child, path+'/issuer') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePractitionerQualification(xml : TXmlBuilder; name : string; elem : TFhirPractitionerQualification);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);
  ComposePeriod(xml, 'period', elem.period);
  ComposeResourceReference{TFhirOrganization}(xml, 'issuer', elem.issuer);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePractitionerQualification(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePractitionerQualification(jsn));
end;

function TFHIRJsonParser.ParsePractitionerQualification(jsn : TJsonObject) : TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('issuer') then
        result.issuer := ParseResourceReference{TFhirOrganization}(jsn.vObj['issuer']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePractitionerQualification(json : TJSONWriter; name : string; elem : TFhirPractitionerQualification);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposePeriod(json, 'period', elem.period); {a}
  ComposeResourceReference{TFhirOrganization}(json, 'issuer', elem.issuer); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParsePractitioner(element : IXmlDomElement; path : string) : TFhirPractitioner;
var
  child : IXMLDOMElement;
begin
  result := TFhirPractitioner.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'name') then
        result.name := ParseHumanName(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContact(child, path+'/telecom'))
      else if (child.baseName = 'address') then
        result.address := ParseAddress(child, path+'/address') {b}
      else if (child.baseName = 'gender') then
        result.gender := ParseCodeableConcept(child, path+'/gender') {b}
      else if (child.baseName = 'birthDate') then
        result.birthDate := ParseDateTime(child, path+'/birthDate') {b}
      else if (child.baseName = 'photo') then
        result.photoList.Add(ParseAttachment(child, path+'/photo'))
      else if (child.baseName = 'organization') then
        result.organization := ParseResourceReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.baseName = 'role') then
        result.roleList.Add(ParseCodeableConcept(child, path+'/role'))
      else if (child.baseName = 'specialty') then
        result.specialtyList.Add(ParseCodeableConcept(child, path+'/specialty'))
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'location') then
        result.locationList.Add(ParseResourceReference{TFhirLocation}(child, path+'/location'))
      else if (child.baseName = 'qualification') then
        result.qualificationList.Add(ParsePractitionerQualification(child, path+'/qualification'))
      else if (child.baseName = 'communication') then
        result.communicationList.Add(ParseCodeableConcept(child, path+'/communication'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposePractitioner(xml : TXmlBuilder; name : string; elem : TFhirPractitioner);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeHumanName(xml, 'name', elem.name);
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContact(xml, 'telecom', elem.telecomList[i]);
  ComposeAddress(xml, 'address', elem.address);
  ComposeCodeableConcept(xml, 'gender', elem.gender);
  ComposeDateTime(xml, 'birthDate', elem.birthDate);
  if not SummaryOnly then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(xml, 'photo', elem.photoList[i]);
  ComposeResourceReference{TFhirOrganization}(xml, 'organization', elem.organization);
  for i := 0 to elem.roleList.Count - 1 do
    ComposeCodeableConcept(xml, 'role', elem.roleList[i]);
  for i := 0 to elem.specialtyList.Count - 1 do
    ComposeCodeableConcept(xml, 'specialty', elem.specialtyList[i]);
  ComposePeriod(xml, 'period', elem.period);
  if not SummaryOnly then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeResourceReference{TFhirLocation}(xml, 'location', elem.locationList[i]);
  if not SummaryOnly then
    for i := 0 to elem.qualificationList.Count - 1 do
      ComposePractitionerQualification(xml, 'qualification', elem.qualificationList[i]);
  if not SummaryOnly then
    for i := 0 to elem.communicationList.Count - 1 do
      ComposeCodeableConcept(xml, 'communication', elem.communicationList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParsePractitioner(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePractitioner(jsn));
end;

function TFHIRJsonParser.ParsePractitioner(jsn : TJsonObject) : TFhirPractitioner;
begin
  result := TFhirPractitioner.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('name') then
        result.name := ParseHumanName(jsn.vObj['name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContact);
    if jsn.has('address') then
        result.address := ParseAddress(jsn.vObj['address']);{q}
    if jsn.has('gender') then
        result.gender := ParseCodeableConcept(jsn.vObj['gender']);{q}
    if jsn.has('birthDate') or jsn.has('_birthDate') then
        result.birthDate := ParseDateTime(jsn['birthDate'], jsn.vObj['_birthDate']);{q}
    if jsn.has('photo') then
      iterateArray(jsn.vArr['photo'], result.photoList, parseAttachment);
    if jsn.has('organization') then
        result.organization := ParseResourceReference{TFhirOrganization}(jsn.vObj['organization']);{q}
    if jsn.has('role') then
      iterateArray(jsn.vArr['role'], result.roleList, parseCodeableConcept);
    if jsn.has('specialty') then
      iterateArray(jsn.vArr['specialty'], result.specialtyList, parseCodeableConcept);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('location') then
      iterateArray(jsn.vArr['location'], result.locationList, parseResourceReference{TFhirLocation});
    if jsn.has('qualification') then
      iterateArray(jsn.vArr['qualification'], result.qualificationList, parsePractitionerQualification);
    if jsn.has('communication') then
      iterateArray(jsn.vArr['communication'], result.communicationList, parseCodeableConcept);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposePractitioner(json : TJSONWriter; name : string; elem : TFhirPractitioner);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeHumanName(json, 'name', elem.name); {a}
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContact(json, '',elem.telecomList[i]); {z - Contact}
    json.FinishArray;
  end;
  ComposeAddress(json, 'address', elem.address); {a}
  ComposeCodeableConcept(json, 'gender', elem.gender); {a}
  ComposeDateTimeValue(json, 'birthDate', elem.birthDate, false);
  ComposeDateTimeProps(json, 'birthDate', elem.birthDate, false);
  if not SummaryOnly and (elem.photoList.Count > 0) then
  begin
    json.valueArray('photo');
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(json, '',elem.photoList[i]); {z - Attachment}
    json.FinishArray;
  end;
  ComposeResourceReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if elem.roleList.Count > 0 then
  begin
    json.valueArray('role');
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.roleList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.specialtyList.Count > 0 then
  begin
    json.valueArray('specialty');
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.specialtyList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposePeriod(json, 'period', elem.period); {a}
  if not SummaryOnly and (elem.locationList.Count > 0) then
  begin
    json.valueArray('location');
    for i := 0 to elem.locationList.Count - 1 do
      ComposeResourceReference{TFhirLocation}(json, '',elem.locationList[i]); {z - Resource(Location)}
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.qualificationList.Count > 0) then
  begin
    json.valueArray('qualification');
    for i := 0 to elem.qualificationList.Count - 1 do
      ComposePractitionerQualification(json, '',elem.qualificationList[i]); {z - }
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.communicationList.Count > 0) then
  begin
    json.valueArray('communication');
    for i := 0 to elem.communicationList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.communicationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseProcedurePerformer(element : IXmlDomElement; path : string) : TFhirProcedurePerformer;
var
  child : IXMLDOMElement;
begin
  result := TFhirProcedurePerformer.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'person') then
        result.person := ParseResourceReference{TFhirPractitioner}(child, path+'/person') {b}
      else if (child.baseName = 'role') then
        result.role := ParseCodeableConcept(child, path+'/role') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProcedurePerformer(xml : TXmlBuilder; name : string; elem : TFhirProcedurePerformer);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeResourceReference{TFhirPractitioner}(xml, 'person', elem.person);
  ComposeCodeableConcept(xml, 'role', elem.role);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProcedurePerformer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcedurePerformer(jsn));
end;

function TFHIRJsonParser.ParseProcedurePerformer(jsn : TJsonObject) : TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('person') then
        result.person := ParseResourceReference{TFhirPractitioner}(jsn.vObj['person']);{q}
    if jsn.has('role') then
        result.role := ParseCodeableConcept(jsn.vObj['role']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProcedurePerformer(json : TJSONWriter; name : string; elem : TFhirProcedurePerformer);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeResourceReference{TFhirPractitioner}(json, 'person', elem.person); {a}
  ComposeCodeableConcept(json, 'role', elem.role); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseProcedureRelatedItem(element : IXmlDomElement; path : string) : TFhirProcedureRelatedItem;
var
  child : IXMLDOMElement;
begin
  result := TFhirProcedureRelatedItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseEnum(CODES_TFhirProcedureRelationshipType, path+'/type', child)
      else if (child.baseName = 'target') then
        result.target := ParseResourceReference{Resource}(child, path+'/target') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProcedureRelatedItem(xml : TXmlBuilder; name : string; elem : TFhirProcedureRelatedItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_, CODES_TFhirProcedureRelationshipType);
  ComposeResourceReference{Resource}(xml, 'target', elem.target);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProcedureRelatedItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcedureRelatedItem(jsn));
end;

function TFHIRJsonParser.ParseProcedureRelatedItem(jsn : TJsonObject) : TFhirProcedureRelatedItem;
begin
  result := TFhirProcedureRelatedItem.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_ := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirProcedureRelationshipType);
    if jsn.has('target') then
        result.target := ParseResourceReference{Resource}(jsn.vObj['target']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProcedureRelatedItem(json : TJSONWriter; name : string; elem : TFhirProcedureRelatedItem);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_, CODES_TFhirProcedureRelationshipType, false);
  ComposeEnumProps(json, 'type', elem.Type_, CODES_TFhirProcedureRelationshipType, false);
  ComposeResourceReference{Resource}(json, 'target', elem.target); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseProcedure(element : IXmlDomElement; path : string) : TFhirProcedure;
var
  child : IXMLDOMElement;
begin
  result := TFhirProcedure.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'subject') then
        result.subject := ParseResourceReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'bodySite') then
        result.bodySiteList.Add(ParseCodeableConcept(child, path+'/bodySite'))
      else if (child.baseName = 'indication') then
        result.indicationList.Add(ParseCodeableConcept(child, path+'/indication'))
      else if (child.baseName = 'performer') then
        result.performerList.Add(ParseProcedurePerformer(child, path+'/performer'))
      else if (child.baseName = 'date') then
        result.date := ParsePeriod(child, path+'/date') {b}
      else if (child.baseName = 'encounter') then
        result.encounter := ParseResourceReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'outcome') then
        result.outcome := ParseString(child, path+'/outcome') {b}
      else if (child.baseName = 'report') then
        result.reportList.Add(ParseResourceReference{TFhirDiagnosticReport}(child, path+'/report'))
      else if (child.baseName = 'complication') then
        result.complicationList.Add(ParseCodeableConcept(child, path+'/complication'))
      else if (child.baseName = 'followUp') then
        result.followUp := ParseString(child, path+'/followUp') {b}
      else if (child.baseName = 'relatedItem') then
        result.relatedItemList.Add(ParseProcedureRelatedItem(child, path+'/relatedItem'))
      else if (child.baseName = 'notes') then
        result.notes := ParseString(child, path+'/notes') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProcedure(xml : TXmlBuilder; name : string; elem : TFhirProcedure);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeResourceReference{TFhirPatient}(xml, 'subject', elem.subject);
  ComposeCodeableConcept(xml, 'type', elem.type_);
  for i := 0 to elem.bodySiteList.Count - 1 do
    ComposeCodeableConcept(xml, 'bodySite', elem.bodySiteList[i]);
  for i := 0 to elem.indicationList.Count - 1 do
    ComposeCodeableConcept(xml, 'indication', elem.indicationList[i]);
  for i := 0 to elem.performerList.Count - 1 do
    ComposeProcedurePerformer(xml, 'performer', elem.performerList[i]);
  ComposePeriod(xml, 'date', elem.date);
  ComposeResourceReference{TFhirEncounter}(xml, 'encounter', elem.encounter);
  ComposeString(xml, 'outcome', elem.outcome);
  if not SummaryOnly then
    for i := 0 to elem.reportList.Count - 1 do
      ComposeResourceReference{TFhirDiagnosticReport}(xml, 'report', elem.reportList[i]);
  if not SummaryOnly then
    for i := 0 to elem.complicationList.Count - 1 do
      ComposeCodeableConcept(xml, 'complication', elem.complicationList[i]);
  if not SummaryOnly then
    ComposeString(xml, 'followUp', elem.followUp);
  if not SummaryOnly then
    for i := 0 to elem.relatedItemList.Count - 1 do
      ComposeProcedureRelatedItem(xml, 'relatedItem', elem.relatedItemList[i]);
  if not SummaryOnly then
    ComposeString(xml, 'notes', elem.notes);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProcedure(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcedure(jsn));
end;

function TFHIRJsonParser.ParseProcedure(jsn : TJsonObject) : TFhirProcedure;
begin
  result := TFhirProcedure.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseResourceReference{TFhirPatient}(jsn.vObj['subject']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('bodySite') then
      iterateArray(jsn.vArr['bodySite'], result.bodySiteList, parseCodeableConcept);
    if jsn.has('indication') then
      iterateArray(jsn.vArr['indication'], result.indicationList, parseCodeableConcept);
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseProcedurePerformer);
    if jsn.has('date') then
        result.date := ParsePeriod(jsn.vObj['date']);{q}
    if jsn.has('encounter') then
        result.encounter := ParseResourceReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('outcome') or jsn.has('_outcome') then
        result.outcome := ParseString(jsn['outcome'], jsn.vObj['_outcome']);{q}
    if jsn.has('report') then
      iterateArray(jsn.vArr['report'], result.reportList, parseResourceReference{TFhirDiagnosticReport});
    if jsn.has('complication') then
      iterateArray(jsn.vArr['complication'], result.complicationList, parseCodeableConcept);
    if jsn.has('followUp') or jsn.has('_followUp') then
        result.followUp := ParseString(jsn['followUp'], jsn.vObj['_followUp']);{q}
    if jsn.has('relatedItem') then
      iterateArray(jsn.vArr['relatedItem'], result.relatedItemList, parseProcedureRelatedItem);
    if jsn.has('notes') or jsn.has('_notes') then
        result.notes := ParseString(jsn['notes'], jsn.vObj['_notes']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProcedure(json : TJSONWriter; name : string; elem : TFhirProcedure);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeResourceReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if elem.bodySiteList.Count > 0 then
  begin
    json.valueArray('bodySite');
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.bodySiteList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.indicationList.Count > 0 then
  begin
    json.valueArray('indication');
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.indicationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if elem.performerList.Count > 0 then
  begin
    json.valueArray('performer');
    for i := 0 to elem.performerList.Count - 1 do
      ComposeProcedurePerformer(json, '',elem.performerList[i]); {z - }
    json.FinishArray;
  end;
  ComposePeriod(json, 'date', elem.date); {a}
  ComposeResourceReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  ComposeStringValue(json, 'outcome', elem.outcome, false);
  ComposeStringProps(json, 'outcome', elem.outcome, false);
  if not SummaryOnly and (elem.reportList.Count > 0) then
  begin
    json.valueArray('report');
    for i := 0 to elem.reportList.Count - 1 do
      ComposeResourceReference{TFhirDiagnosticReport}(json, '',elem.reportList[i]); {z - Resource(DiagnosticReport)}
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.complicationList.Count > 0) then
  begin
    json.valueArray('complication');
    for i := 0 to elem.complicationList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.complicationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if not SummaryOnly then
    ComposeStringValue(json, 'followUp', elem.followUp, false);
  if not SummaryOnly then
    ComposeStringProps(json, 'followUp', elem.followUp, false);
  if not SummaryOnly and (elem.relatedItemList.Count > 0) then
  begin
    json.valueArray('relatedItem');
    for i := 0 to elem.relatedItemList.Count - 1 do
      ComposeProcedureRelatedItem(json, '',elem.relatedItemList[i]); {z - }
    json.FinishArray;
  end;
  if not SummaryOnly then
    ComposeStringValue(json, 'notes', elem.notes, false);
  if not SummaryOnly then
    ComposeStringProps(json, 'notes', elem.notes, false);
end;

function TFHIRXmlParser.ParseProfileMapping(element : IXmlDomElement; path : string) : TFhirProfileMapping;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfileMapping.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identity') then
        result.identity := ParseId(child, path+'/identity') {b}
      else if (child.baseName = 'uri') then
        result.uri := ParseUri(child, path+'/uri') {b}
      else if (child.baseName = 'name') then
        result.name := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'comments') then
        result.comments := ParseString(child, path+'/comments') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfileMapping(xml : TXmlBuilder; name : string; elem : TFhirProfileMapping);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'identity', elem.identity);
  ComposeUri(xml, 'uri', elem.uri);
  ComposeString(xml, 'name', elem.name);
  ComposeString(xml, 'comments', elem.comments);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfileMapping(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfileMapping(jsn));
end;

function TFHIRJsonParser.ParseProfileMapping(jsn : TJsonObject) : TFhirProfileMapping;
begin
  result := TFhirProfileMapping.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identity') or jsn.has('_identity') then
        result.identity := ParseId(jsn['identity'], jsn.vObj['_identity']);{q}
    if jsn.has('uri') or jsn.has('_uri') then
        result.uri := ParseUri(jsn['uri'], jsn.vObj['_uri']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.name := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('comments') or jsn.has('_comments') then
        result.comments := ParseString(jsn['comments'], jsn.vObj['_comments']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfileMapping(json : TJSONWriter; name : string; elem : TFhirProfileMapping);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'identity', elem.identity, false);
  ComposeIdProps(json, 'identity', elem.identity, false);
  ComposeUriValue(json, 'uri', elem.uri, false);
  ComposeUriProps(json, 'uri', elem.uri, false);
  ComposeStringValue(json, 'name', elem.name, false);
  ComposeStringProps(json, 'name', elem.name, false);
  ComposeStringValue(json, 'comments', elem.comments, false);
  ComposeStringProps(json, 'comments', elem.comments, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseProfileStructure(element : IXmlDomElement; path : string) : TFhirProfileStructure;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfileStructure.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCode(child, path+'/type') {b}
      else if (child.baseName = 'name') then
        result.name := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'publish') then
        result.publish := ParseBoolean(child, path+'/publish') {b}
      else if (child.baseName = 'purpose') then
        result.purpose := ParseString(child, path+'/purpose') {b}
      else if (child.baseName = 'element') then
        result.elementList.Add(ParseProfileStructureElement(child, path+'/element'))
      else if (child.baseName = 'searchParam') then
        result.searchParamList.Add(ParseProfileStructureSearchParam(child, path+'/searchParam'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfileStructure(xml : TXmlBuilder; name : string; elem : TFhirProfileStructure);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'type', elem.type_);
  ComposeString(xml, 'name', elem.name);
  ComposeBoolean(xml, 'publish', elem.publish);
  ComposeString(xml, 'purpose', elem.purpose);
  for i := 0 to elem.elementList.Count - 1 do
    ComposeProfileStructureElement(xml, 'element', elem.elementList[i]);
  for i := 0 to elem.searchParamList.Count - 1 do
    ComposeProfileStructureSearchParam(xml, 'searchParam', elem.searchParamList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfileStructure(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfileStructure(jsn));
end;

function TFHIRJsonParser.ParseProfileStructure(jsn : TJsonObject) : TFhirProfileStructure;
begin
  result := TFhirProfileStructure.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type') then
        result.type_ := ParseCode(jsn['type'], jsn.vObj['_type']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.name := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('publish') or jsn.has('_publish') then
        result.publish := ParseBoolean(jsn['publish'], jsn.vObj['_publish']);{q}
    if jsn.has('purpose') or jsn.has('_purpose') then
        result.purpose := ParseString(jsn['purpose'], jsn.vObj['_purpose']);{q}
    if jsn.has('element') then
      iterateArray(jsn.vArr['element'], result.elementList, parseProfileStructureElement);
    if jsn.has('searchParam') then
      iterateArray(jsn.vArr['searchParam'], result.searchParamList, parseProfileStructureSearchParam);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfileStructure(json : TJSONWriter; name : string; elem : TFhirProfileStructure);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'type', elem.type_, false);
  ComposeCodeProps(json, 'type', elem.type_, false);
  ComposeStringValue(json, 'name', elem.name, false);
  ComposeStringProps(json, 'name', elem.name, false);
  ComposeBooleanValue(json, 'publish', elem.publish, false);
  ComposeBooleanProps(json, 'publish', elem.publish, false);
  ComposeStringValue(json, 'purpose', elem.purpose, false);
  ComposeStringProps(json, 'purpose', elem.purpose, false);
  if elem.elementList.Count > 0 then
  begin
    json.valueArray('element');
    for i := 0 to elem.elementList.Count - 1 do
      ComposeProfileStructureElement(json, '',elem.elementList[i]); {z - }
    json.FinishArray;
  end;
  if elem.searchParamList.Count > 0 then
  begin
    json.valueArray('searchParam');
    for i := 0 to elem.searchParamList.Count - 1 do
      ComposeProfileStructureSearchParam(json, '',elem.searchParamList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseProfileStructureElement(element : IXmlDomElement; path : string) : TFhirProfileStructureElement;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfileStructureElement.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'path') then
        result.path := ParseString(child, path+'/path') {b}
      else if (child.baseName = 'representation') then
        result.representation.Add(ParseEnum(CODES_TFhirPropertyRepresentation, path+'/representation', child))
      else if (child.baseName = 'name') then
        result.name := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'slicing') then
        result.slicing := ParseProfileStructureElementSlicing(child, path+'/slicing') {b}
      else if (child.baseName = 'definition') then
        result.definition := ParseProfileStructureElementDefinition(child, path+'/definition') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfileStructureElement(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureElement);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'path', elem.path);
  for i := 0 to elem.representation.Count - 1 do
    ComposeEnum(xml, 'representation', elem.representation[i], CODES_TFhirPropertyRepresentation);
  ComposeString(xml, 'name', elem.name);
  ComposeProfileStructureElementSlicing(xml, 'slicing', elem.slicing);
  ComposeProfileStructureElementDefinition(xml, 'definition', elem.definition);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfileStructureElement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfileStructureElement(jsn));
end;

function TFHIRJsonParser.ParseProfileStructureElement(jsn : TJsonObject) : TFhirProfileStructureElement;
begin
  result := TFhirProfileStructureElement.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('path') or jsn.has('_path') then
        result.path := ParseString(jsn['path'], jsn.vObj['_path']);{q}
    if jsn.has('representation') or jsn.has('_representation') then
      iterateEnumArray(jsn.vArr['representation'], jsn.vArr['_representation'], result.representation, parseEnum, CODES_TFhirPropertyRepresentation);
    if jsn.has('name') or jsn.has('_name') then
        result.name := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('slicing') then
        result.slicing := ParseProfileStructureElementSlicing(jsn.vObj['slicing']);{q}
    if jsn.has('definition') then
        result.definition := ParseProfileStructureElementDefinition(jsn.vObj['definition']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfileStructureElement(json : TJSONWriter; name : string; elem : TFhirProfileStructureElement);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'path', elem.path, false);
  ComposeStringProps(json, 'path', elem.path, false);
  if elem.representation.Count > 0 then
  begin
    json.valueArray('representation');
    ext := false;
    for i := 0 to elem.representation.Count - 1 do
    begin
      ext := ext or ((elem.representation[i].xmlid <> '') or (elem.representation[i].hasExtensions));
      ComposeEnumValue(json, '', elem.representation[i], CODES_TFhirPropertyRepresentation, true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_representation');
      for i := 0 to elem.representation.Count - 1 do
        ComposeEnumProps(json, '', elem.representation[i], CODES_TFhirPropertyRepresentation, true);
      json.FinishArray;
    end;
  end;
  ComposeStringValue(json, 'name', elem.name, false);
  ComposeStringProps(json, 'name', elem.name, false);
  ComposeProfileStructureElementSlicing(json, 'slicing', elem.slicing); {a}
  ComposeProfileStructureElementDefinition(json, 'definition', elem.definition); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseProfileStructureElementSlicing(element : IXmlDomElement; path : string) : TFhirProfileStructureElementSlicing;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfileStructureElementSlicing.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'discriminator') then
        result.discriminator := ParseId(child, path+'/discriminator') {b}
      else if (child.baseName = 'ordered') then
        result.ordered := ParseBoolean(child, path+'/ordered') {b}
      else if (child.baseName = 'rules') then
        result.rules := ParseEnum(CODES_TFhirResourceSlicingRules, path+'/rules', child)
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfileStructureElementSlicing(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureElementSlicing);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'discriminator', elem.discriminator);
  ComposeBoolean(xml, 'ordered', elem.ordered);
  ComposeEnum(xml, 'rules', elem.Rules, CODES_TFhirResourceSlicingRules);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfileStructureElementSlicing(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfileStructureElementSlicing(jsn));
end;

function TFHIRJsonParser.ParseProfileStructureElementSlicing(jsn : TJsonObject) : TFhirProfileStructureElementSlicing;
begin
  result := TFhirProfileStructureElementSlicing.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('discriminator') or jsn.has('_discriminator') then
        result.discriminator := ParseId(jsn['discriminator'], jsn.vObj['_discriminator']);{q}
    if jsn.has('ordered') or jsn.has('_ordered') then
        result.ordered := ParseBoolean(jsn['ordered'], jsn.vObj['_ordered']);{q}
    if jsn.has('rules') or jsn.has('_rules')  then
      result.rules := parseEnum(jsn['rules'], jsn.vObj['_rules'], CODES_TFhirResourceSlicingRules);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfileStructureElementSlicing(json : TJSONWriter; name : string; elem : TFhirProfileStructureElementSlicing);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'discriminator', elem.discriminator, false);
  ComposeIdProps(json, 'discriminator', elem.discriminator, false);
  ComposeBooleanValue(json, 'ordered', elem.ordered, false);
  ComposeBooleanProps(json, 'ordered', elem.ordered, false);
  ComposeEnumValue(json, 'rules', elem.Rules, CODES_TFhirResourceSlicingRules, false);
  ComposeEnumProps(json, 'rules', elem.Rules, CODES_TFhirResourceSlicingRules, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseProfileStructureElementDefinition(element : IXmlDomElement; path : string) : TFhirProfileStructureElementDefinition;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfileStructureElementDefinition.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'short') then
        result.short := ParseString(child, path+'/short') {b}
      else if (child.baseName = 'formal') then
        result.formal := ParseString(child, path+'/formal') {b}
      else if (child.baseName = 'comments') then
        result.comments := ParseString(child, path+'/comments') {b}
      else if (child.baseName = 'requirements') then
        result.requirements := ParseString(child, path+'/requirements') {b}
      else if (child.baseName = 'synonym') then
        result.synonymList.Add(ParseString(child, path+'/synonym'))
      else if (child.baseName = 'min') then
        result.min := ParseInteger(child, path+'/min') {b}
      else if (child.baseName = 'max') then
        result.max := ParseString(child, path+'/max') {b}
      else if (child.baseName = 'type') then
        result.type_List.Add(ParseProfileStructureElementDefinitionType(child, path+'/type'))
      else if (child.baseName = 'nameReference') then
        result.nameReference := ParseString(child, path+'/nameReference') {b}
      else if (child.baseName = 'valueInteger') then
        result.value := ParseInteger(child, path+'.valueInteger') {c}
      else if (child.baseName = 'valueDateTime') then
        result.value := ParseDateTime(child, path+'.valueDateTime') {c}
      else if (child.baseName = 'valueCode') then
        result.value := ParseCode(child, path+'.valueCode') {c}
      else if (child.baseName = 'valueDate') then
        result.value := ParseDate(child, path+'.valueDate') {c}
      else if (child.baseName = 'valueDecimal') then
        result.value := ParseDecimal(child, path+'.valueDecimal') {c}
      else if (child.baseName = 'valueUri') then
        result.value := ParseUri(child, path+'.valueUri') {c}
      else if (child.baseName = 'valueId') then
        result.value := ParseId(child, path+'.valueId') {c}
      else if (child.baseName = 'valueBase64Binary') then
        result.value := ParseBase64Binary(child, path+'.valueBase64Binary') {c}
      else if (child.baseName = 'valueOid') then
        result.value := ParseOid(child, path+'.valueOid') {c}
      else if (child.baseName = 'valueString') then
        result.value := ParseString(child, path+'.valueString') {c}
      else if (child.baseName = 'valueBoolean') then
        result.value := ParseBoolean(child, path+'.valueBoolean') {c}
      else if (child.baseName = 'valueUuid') then
        result.value := ParseUuid(child, path+'.valueUuid') {c}
      else if (child.baseName = 'valueInstant') then
        result.value := ParseInstant(child, path+'.valueInstant') {c}
      else if (child.baseName = 'valuePeriod') then
        result.value := ParsePeriod(child, path+'.valuePeriod') {ePeriod}
      else if (child.baseName = 'valueCoding') then
        result.value := ParseCoding(child, path+'.valueCoding') {eCoding}
      else if (child.baseName = 'valueRange') then
        result.value := ParseRange(child, path+'.valueRange') {eRange}
      else if (child.baseName = 'valueQuantity') then
        result.value := ParseQuantity(child, path+'.valueQuantity') {eQuantity}
      else if (child.baseName = 'valueAttachment') then
        result.value := ParseAttachment(child, path+'.valueAttachment') {eAttachment}
      else if (child.baseName = 'valueRatio') then
        result.value := ParseRatio(child, path+'.valueRatio') {eRatio}
      else if (child.baseName = 'valueSampledData') then
        result.value := ParseSampledData(child, path+'.valueSampledData') {eSampledData}
      else if (child.baseName = 'valueResource') then
        result.value := ParseResourceReference(child, path+'/valueResource') {e0}
      else if (child.baseName = 'valueCodeableConcept') then
        result.value := ParseCodeableConcept(child, path+'.valueCodeableConcept') {eCodeableConcept}
      else if (child.baseName = 'valueIdentifier') then
        result.value := ParseIdentifier(child, path+'.valueIdentifier') {eIdentifier}
      else if (child.baseName = 'valueSchedule') then
        result.value := ParseSchedule(child, path+'/valueSchedule') {f}
      else if (child.baseName = 'valueContact') then
        result.value := ParseContact(child, path+'/valueContact') {f}
      else if (child.baseName = 'valueAddress') then
        result.value := ParseAddress(child, path+'/valueAddress') {f}
      else if (child.baseName = 'valueHumanName') then
        result.value := ParseHumanName(child, path+'/valueHumanName') {f}
      else if (child.baseName = 'exampleInteger') then
        result.example := ParseInteger(child, path+'.exampleInteger') {c}
      else if (child.baseName = 'exampleDateTime') then
        result.example := ParseDateTime(child, path+'.exampleDateTime') {c}
      else if (child.baseName = 'exampleCode') then
        result.example := ParseCode(child, path+'.exampleCode') {c}
      else if (child.baseName = 'exampleDate') then
        result.example := ParseDate(child, path+'.exampleDate') {c}
      else if (child.baseName = 'exampleDecimal') then
        result.example := ParseDecimal(child, path+'.exampleDecimal') {c}
      else if (child.baseName = 'exampleUri') then
        result.example := ParseUri(child, path+'.exampleUri') {c}
      else if (child.baseName = 'exampleId') then
        result.example := ParseId(child, path+'.exampleId') {c}
      else if (child.baseName = 'exampleBase64Binary') then
        result.example := ParseBase64Binary(child, path+'.exampleBase64Binary') {c}
      else if (child.baseName = 'exampleOid') then
        result.example := ParseOid(child, path+'.exampleOid') {c}
      else if (child.baseName = 'exampleString') then
        result.example := ParseString(child, path+'.exampleString') {c}
      else if (child.baseName = 'exampleBoolean') then
        result.example := ParseBoolean(child, path+'.exampleBoolean') {c}
      else if (child.baseName = 'exampleUuid') then
        result.example := ParseUuid(child, path+'.exampleUuid') {c}
      else if (child.baseName = 'exampleInstant') then
        result.example := ParseInstant(child, path+'.exampleInstant') {c}
      else if (child.baseName = 'examplePeriod') then
        result.example := ParsePeriod(child, path+'.examplePeriod') {ePeriod}
      else if (child.baseName = 'exampleCoding') then
        result.example := ParseCoding(child, path+'.exampleCoding') {eCoding}
      else if (child.baseName = 'exampleRange') then
        result.example := ParseRange(child, path+'.exampleRange') {eRange}
      else if (child.baseName = 'exampleQuantity') then
        result.example := ParseQuantity(child, path+'.exampleQuantity') {eQuantity}
      else if (child.baseName = 'exampleAttachment') then
        result.example := ParseAttachment(child, path+'.exampleAttachment') {eAttachment}
      else if (child.baseName = 'exampleRatio') then
        result.example := ParseRatio(child, path+'.exampleRatio') {eRatio}
      else if (child.baseName = 'exampleSampledData') then
        result.example := ParseSampledData(child, path+'.exampleSampledData') {eSampledData}
      else if (child.baseName = 'exampleResource') then
        result.example := ParseResourceReference(child, path+'/exampleResource') {e0}
      else if (child.baseName = 'exampleCodeableConcept') then
        result.example := ParseCodeableConcept(child, path+'.exampleCodeableConcept') {eCodeableConcept}
      else if (child.baseName = 'exampleIdentifier') then
        result.example := ParseIdentifier(child, path+'.exampleIdentifier') {eIdentifier}
      else if (child.baseName = 'exampleSchedule') then
        result.example := ParseSchedule(child, path+'/exampleSchedule') {f}
      else if (child.baseName = 'exampleContact') then
        result.example := ParseContact(child, path+'/exampleContact') {f}
      else if (child.baseName = 'exampleAddress') then
        result.example := ParseAddress(child, path+'/exampleAddress') {f}
      else if (child.baseName = 'exampleHumanName') then
        result.example := ParseHumanName(child, path+'/exampleHumanName') {f}
      else if (child.baseName = 'maxLength') then
        result.maxLength := ParseInteger(child, path+'/maxLength') {b}
      else if (child.baseName = 'condition') then
        result.conditionList.Add(ParseId(child, path+'/condition'))
      else if (child.baseName = 'constraint') then
        result.constraintList.Add(ParseProfileStructureElementDefinitionConstraint(child, path+'/constraint'))
      else if (child.baseName = 'mustSupport') then
        result.mustSupport := ParseBoolean(child, path+'/mustSupport') {b}
      else if (child.baseName = 'isModifier') then
        result.isModifier := ParseBoolean(child, path+'/isModifier') {b}
      else if (child.baseName = 'binding') then
        result.binding := ParseProfileStructureElementDefinitionBinding(child, path+'/binding') {b}
      else if (child.baseName = 'mapping') then
        result.mappingList.Add(ParseProfileStructureElementDefinitionMapping(child, path+'/mapping'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfileStructureElementDefinition(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureElementDefinition);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'short', elem.short);
  ComposeString(xml, 'formal', elem.formal);
  ComposeString(xml, 'comments', elem.comments);
  ComposeString(xml, 'requirements', elem.requirements);
  for i := 0 to elem.synonymList.Count - 1 do
    ComposeString(xml, 'synonym', elem.synonymList[i]);
  ComposeInteger(xml, 'min', elem.min);
  ComposeString(xml, 'max', elem.max);
  for i := 0 to elem.type_List.Count - 1 do
    ComposeProfileStructureElementDefinitionType(xml, 'type', elem.type_List[i]);
  ComposeString(xml, 'nameReference', elem.nameReference);
  if (elem.value is TFhirInteger) {1} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (elem.value is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value))
  else if (elem.value is TFhirCode) {1} then
    ComposeCode(xml, 'valueCode', TFhirCode(elem.value))
  else if (elem.value is TFhirDate) {1} then
    ComposeDate(xml, 'valueDate', TFhirDate(elem.value))
  else if (elem.value is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value))
  else if (elem.value is TFhirUri) {1} then
    ComposeUri(xml, 'valueUri', TFhirUri(elem.value))
  else if (elem.value is TFhirId) {1} then
    ComposeId(xml, 'valueId', TFhirId(elem.value))
  else if (elem.value is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(elem.value))
  else if (elem.value is TFhirOid) {1} then
    ComposeOid(xml, 'valueOid', TFhirOid(elem.value))
  else if (elem.value is TFhirString) {1} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (elem.value is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (elem.value is TFhirUuid) {1} then
    ComposeUuid(xml, 'valueUuid', TFhirUuid(elem.value))
  else if (elem.value is TFhirInstant) {1} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(elem.value))
  else if (elem.value is TFhirPeriod) {8} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value))
  else if (elem.value is TFhirCoding) {8} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(elem.value))
  else if (elem.value is TFhirRange) {8} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value))
  else if (elem.value is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (elem.value is TFhirRatio) {8} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(elem.value))
  else if (elem.value is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(elem.value))
  else if (elem.value is TFhirResourceReference) {8} then
    ComposeResourceReference(xml, 'valueResource', TFhirResourceReference(elem.value))
  else if (elem.value is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (elem.value is TFhirSchedule) {9} then
    ComposeSchedule(xml, 'valueSchedule', TFhirSchedule(elem.value))
  else if (elem.value is TFhirContact) {9} then
    ComposeContact(xml, 'valueContact', TFhirContact(elem.value))
  else if (elem.value is TFhirAddress) {9} then
    ComposeAddress(xml, 'valueAddress', TFhirAddress(elem.value))
  else if (elem.value is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'valueHumanName', TFhirHumanName(elem.value));
  if (elem.example is TFhirInteger) {1} then
    ComposeInteger(xml, 'exampleInteger', TFhirInteger(elem.example))
  else if (elem.example is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'exampleDateTime', TFhirDateTime(elem.example))
  else if (elem.example is TFhirCode) {1} then
    ComposeCode(xml, 'exampleCode', TFhirCode(elem.example))
  else if (elem.example is TFhirDate) {1} then
    ComposeDate(xml, 'exampleDate', TFhirDate(elem.example))
  else if (elem.example is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'exampleDecimal', TFhirDecimal(elem.example))
  else if (elem.example is TFhirUri) {1} then
    ComposeUri(xml, 'exampleUri', TFhirUri(elem.example))
  else if (elem.example is TFhirId) {1} then
    ComposeId(xml, 'exampleId', TFhirId(elem.example))
  else if (elem.example is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'exampleBase64Binary', TFhirBase64Binary(elem.example))
  else if (elem.example is TFhirOid) {1} then
    ComposeOid(xml, 'exampleOid', TFhirOid(elem.example))
  else if (elem.example is TFhirString) {1} then
    ComposeString(xml, 'exampleString', TFhirString(elem.example))
  else if (elem.example is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'exampleBoolean', TFhirBoolean(elem.example))
  else if (elem.example is TFhirUuid) {1} then
    ComposeUuid(xml, 'exampleUuid', TFhirUuid(elem.example))
  else if (elem.example is TFhirInstant) {1} then
    ComposeInstant(xml, 'exampleInstant', TFhirInstant(elem.example))
  else if (elem.example is TFhirPeriod) {8} then
    ComposePeriod(xml, 'examplePeriod', TFhirPeriod(elem.example))
  else if (elem.example is TFhirCoding) {8} then
    ComposeCoding(xml, 'exampleCoding', TFhirCoding(elem.example))
  else if (elem.example is TFhirRange) {8} then
    ComposeRange(xml, 'exampleRange', TFhirRange(elem.example))
  else if (elem.example is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'exampleQuantity', TFhirQuantity(elem.example))
  else if (elem.example is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'exampleAttachment', TFhirAttachment(elem.example))
  else if (elem.example is TFhirRatio) {8} then
    ComposeRatio(xml, 'exampleRatio', TFhirRatio(elem.example))
  else if (elem.example is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'exampleSampledData', TFhirSampledData(elem.example))
  else if (elem.example is TFhirResourceReference) {8} then
    ComposeResourceReference(xml, 'exampleResource', TFhirResourceReference(elem.example))
  else if (elem.example is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'exampleCodeableConcept', TFhirCodeableConcept(elem.example))
  else if (elem.example is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'exampleIdentifier', TFhirIdentifier(elem.example))
  else if (elem.example is TFhirSchedule) {9} then
    ComposeSchedule(xml, 'exampleSchedule', TFhirSchedule(elem.example))
  else if (elem.example is TFhirContact) {9} then
    ComposeContact(xml, 'exampleContact', TFhirContact(elem.example))
  else if (elem.example is TFhirAddress) {9} then
    ComposeAddress(xml, 'exampleAddress', TFhirAddress(elem.example))
  else if (elem.example is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'exampleHumanName', TFhirHumanName(elem.example));
  ComposeInteger(xml, 'maxLength', elem.maxLength);
  for i := 0 to elem.conditionList.Count - 1 do
    ComposeId(xml, 'condition', elem.conditionList[i]);
  for i := 0 to elem.constraintList.Count - 1 do
    ComposeProfileStructureElementDefinitionConstraint(xml, 'constraint', elem.constraintList[i]);
  ComposeBoolean(xml, 'mustSupport', elem.mustSupport);
  ComposeBoolean(xml, 'isModifier', elem.isModifier);
  ComposeProfileStructureElementDefinitionBinding(xml, 'binding', elem.binding);
  for i := 0 to elem.mappingList.Count - 1 do
    ComposeProfileStructureElementDefinitionMapping(xml, 'mapping', elem.mappingList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfileStructureElementDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfileStructureElementDefinition(jsn));
end;

function TFHIRJsonParser.ParseProfileStructureElementDefinition(jsn : TJsonObject) : TFhirProfileStructureElementDefinition;
begin
  result := TFhirProfileStructureElementDefinition.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('short') or jsn.has('_short') then
        result.short := ParseString(jsn['short'], jsn.vObj['_short']);{q}
    if jsn.has('formal') or jsn.has('_formal') then
        result.formal := ParseString(jsn['formal'], jsn.vObj['_formal']);{q}
    if jsn.has('comments') or jsn.has('_comments') then
        result.comments := ParseString(jsn['comments'], jsn.vObj['_comments']);{q}
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirements := ParseString(jsn['requirements'], jsn.vObj['_requirements']);{q}
      if jsn.has('synonym') or jsn.has('_synonym') then
      iteratePrimitiveArray(jsn.vArr['synonym'], jsn.vArr['_synonym'], result.synonymList, parseString);
    if jsn.has('min') or jsn.has('_min') then
        result.min := ParseInteger(jsn['min'], jsn.vObj['_min']);{q}
    if jsn.has('max') or jsn.has('_max') then
        result.max := ParseString(jsn['max'], jsn.vObj['_max']);{q}
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseProfileStructureElementDefinitionType);
    if jsn.has('nameReference') or jsn.has('_nameReference') then
        result.nameReference := ParseString(jsn['nameReference'], jsn.vObj['_nameReference']);{q}
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
        result.value := ParseInteger(jsn['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
        result.value := ParseDateTime(jsn['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valueCode') or jsn.has('_valueCode') then
        result.value := ParseCode(jsn['valueCode'], jsn.vObj['_valueCode']);
    if jsn.has('valueDate') or jsn.has('_valueDate') then
        result.value := ParseDate(jsn['valueDate'], jsn.vObj['_valueDate']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
        result.value := ParseDecimal(jsn['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
        result.value := ParseUri(jsn['valueUri'], jsn.vObj['_valueUri']);
    if jsn.has('valueId') or jsn.has('_valueId') then
        result.value := ParseId(jsn['valueId'], jsn.vObj['_valueId']);
    if jsn.has('valueBase64Binary') or jsn.has('_valueBase64Binary') then
        result.value := ParseBase64Binary(jsn['valueBase64Binary'], jsn.vObj['_valueBase64Binary']);
    if jsn.has('valueOid') or jsn.has('_valueOid') then
        result.value := ParseOid(jsn['valueOid'], jsn.vObj['_valueOid']);
    if jsn.has('valueString') or jsn.has('_valueString') then
        result.value := ParseString(jsn['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
        result.value := ParseBoolean(jsn['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueUuid') or jsn.has('_valueUuid') then
        result.value := ParseUuid(jsn['valueUuid'], jsn.vObj['_valueUuid']);
    if jsn.has('valueInstant') or jsn.has('_valueInstant') then
        result.value := ParseInstant(jsn['valueInstant'], jsn.vObj['_valueInstant']);
    if jsn.has('valuePeriod') {a7} then
        result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('valueCoding') {a7} then
        result.value := ParseCoding(jsn.vObj['valueCoding']);
    if jsn.has('valueRange') {a7} then
        result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueQuantity') {a7} then
        result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueAttachment') {a7} then
        result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueRatio') {a7} then
        result.value := ParseRatio(jsn.vObj['valueRatio']);
    if jsn.has('valueSampledData') {a7} then
        result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if jsn.has('valueResource') {a6} then
        result.value := ParseResourceReference(jsn.vObj['valueResource']);
    if jsn.has('valueCodeableConcept') {a7} then
        result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueIdentifier') {a7} then
        result.value := ParseIdentifier(jsn.vObj['valueIdentifier']);
    if jsn.has('valueSchedule') {a9} then
        result.value := ParseSchedule(jsn.vObj['valueSchedule']);
    if jsn.has('valueContact') {a9} then
        result.value := ParseContact(jsn.vObj['valueContact']);
    if jsn.has('valueAddress') {a9} then
        result.value := ParseAddress(jsn.vObj['valueAddress']);
    if jsn.has('valueHumanName') {a9} then
        result.value := ParseHumanName(jsn.vObj['valueHumanName']);
    if jsn.has('exampleInteger') or jsn.has('_exampleInteger') then
        result.example := ParseInteger(jsn['exampleInteger'], jsn.vObj['_exampleInteger']);
    if jsn.has('exampleDateTime') or jsn.has('_exampleDateTime') then
        result.example := ParseDateTime(jsn['exampleDateTime'], jsn.vObj['_exampleDateTime']);
    if jsn.has('exampleCode') or jsn.has('_exampleCode') then
        result.example := ParseCode(jsn['exampleCode'], jsn.vObj['_exampleCode']);
    if jsn.has('exampleDate') or jsn.has('_exampleDate') then
        result.example := ParseDate(jsn['exampleDate'], jsn.vObj['_exampleDate']);
    if jsn.has('exampleDecimal') or jsn.has('_exampleDecimal') then
        result.example := ParseDecimal(jsn['exampleDecimal'], jsn.vObj['_exampleDecimal']);
    if jsn.has('exampleUri') or jsn.has('_exampleUri') then
        result.example := ParseUri(jsn['exampleUri'], jsn.vObj['_exampleUri']);
    if jsn.has('exampleId') or jsn.has('_exampleId') then
        result.example := ParseId(jsn['exampleId'], jsn.vObj['_exampleId']);
    if jsn.has('exampleBase64Binary') or jsn.has('_exampleBase64Binary') then
        result.example := ParseBase64Binary(jsn['exampleBase64Binary'], jsn.vObj['_exampleBase64Binary']);
    if jsn.has('exampleOid') or jsn.has('_exampleOid') then
        result.example := ParseOid(jsn['exampleOid'], jsn.vObj['_exampleOid']);
    if jsn.has('exampleString') or jsn.has('_exampleString') then
        result.example := ParseString(jsn['exampleString'], jsn.vObj['_exampleString']);
    if jsn.has('exampleBoolean') or jsn.has('_exampleBoolean') then
        result.example := ParseBoolean(jsn['exampleBoolean'], jsn.vObj['_exampleBoolean']);
    if jsn.has('exampleUuid') or jsn.has('_exampleUuid') then
        result.example := ParseUuid(jsn['exampleUuid'], jsn.vObj['_exampleUuid']);
    if jsn.has('exampleInstant') or jsn.has('_exampleInstant') then
        result.example := ParseInstant(jsn['exampleInstant'], jsn.vObj['_exampleInstant']);
    if jsn.has('examplePeriod') {a7} then
        result.example := ParsePeriod(jsn.vObj['examplePeriod']);
    if jsn.has('exampleCoding') {a7} then
        result.example := ParseCoding(jsn.vObj['exampleCoding']);
    if jsn.has('exampleRange') {a7} then
        result.example := ParseRange(jsn.vObj['exampleRange']);
    if jsn.has('exampleQuantity') {a7} then
        result.example := ParseQuantity(jsn.vObj['exampleQuantity']);
    if jsn.has('exampleAttachment') {a7} then
        result.example := ParseAttachment(jsn.vObj['exampleAttachment']);
    if jsn.has('exampleRatio') {a7} then
        result.example := ParseRatio(jsn.vObj['exampleRatio']);
    if jsn.has('exampleSampledData') {a7} then
        result.example := ParseSampledData(jsn.vObj['exampleSampledData']);
    if jsn.has('exampleResource') {a6} then
        result.example := ParseResourceReference(jsn.vObj['exampleResource']);
    if jsn.has('exampleCodeableConcept') {a7} then
        result.example := ParseCodeableConcept(jsn.vObj['exampleCodeableConcept']);
    if jsn.has('exampleIdentifier') {a7} then
        result.example := ParseIdentifier(jsn.vObj['exampleIdentifier']);
    if jsn.has('exampleSchedule') {a9} then
        result.example := ParseSchedule(jsn.vObj['exampleSchedule']);
    if jsn.has('exampleContact') {a9} then
        result.example := ParseContact(jsn.vObj['exampleContact']);
    if jsn.has('exampleAddress') {a9} then
        result.example := ParseAddress(jsn.vObj['exampleAddress']);
    if jsn.has('exampleHumanName') {a9} then
        result.example := ParseHumanName(jsn.vObj['exampleHumanName']);
    if jsn.has('maxLength') or jsn.has('_maxLength') then
        result.maxLength := ParseInteger(jsn['maxLength'], jsn.vObj['_maxLength']);{q}
      if jsn.has('condition') or jsn.has('_condition') then
      iteratePrimitiveArray(jsn.vArr['condition'], jsn.vArr['_condition'], result.conditionList, parseId);
    if jsn.has('constraint') then
      iterateArray(jsn.vArr['constraint'], result.constraintList, parseProfileStructureElementDefinitionConstraint);
    if jsn.has('mustSupport') or jsn.has('_mustSupport') then
        result.mustSupport := ParseBoolean(jsn['mustSupport'], jsn.vObj['_mustSupport']);{q}
    if jsn.has('isModifier') or jsn.has('_isModifier') then
        result.isModifier := ParseBoolean(jsn['isModifier'], jsn.vObj['_isModifier']);{q}
    if jsn.has('binding') then
        result.binding := ParseProfileStructureElementDefinitionBinding(jsn.vObj['binding']);{q}
    if jsn.has('mapping') then
      iterateArray(jsn.vArr['mapping'], result.mappingList, parseProfileStructureElementDefinitionMapping);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfileStructureElementDefinition(json : TJSONWriter; name : string; elem : TFhirProfileStructureElementDefinition);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'short', elem.short, false);
  ComposeStringProps(json, 'short', elem.short, false);
  ComposeStringValue(json, 'formal', elem.formal, false);
  ComposeStringProps(json, 'formal', elem.formal, false);
  ComposeStringValue(json, 'comments', elem.comments, false);
  ComposeStringProps(json, 'comments', elem.comments, false);
  ComposeStringValue(json, 'requirements', elem.requirements, false);
  ComposeStringProps(json, 'requirements', elem.requirements, false);
  if elem.synonymList.Count > 0 then
  begin
    json.valueArray('synonym');
    ext := false;
    for i := 0 to elem.synonymList.Count - 1 do
    begin
      ext := ext or ((elem.synonymList[i].xmlid <> '') or (elem.synonymList[i].hasExtensions));
      ComposeStringValue(json, '',elem.synonymList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_synonym');
      for i := 0 to elem.synonymList.Count - 1 do
        ComposeStringProps(json, '',elem.synonymList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeIntegerValue(json, 'min', elem.min, false);
  ComposeIntegerProps(json, 'min', elem.min, false);
  ComposeStringValue(json, 'max', elem.max, false);
  ComposeStringProps(json, 'max', elem.max, false);
  if elem.type_List.Count > 0 then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeProfileStructureElementDefinitionType(json, '',elem.type_List[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'nameReference', elem.nameReference, false);
  ComposeStringProps(json, 'nameReference', elem.nameReference, false);
  if (elem.value is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false)
  end
  else if (elem.value is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false)
  end
  else if (elem.value is TFhirCode) then
  begin
    ComposeCodeValue(json, 'valueCode', TFhirCode(elem.value), false);
    ComposeCodeProps(json, 'valueCode', TFhirCode(elem.value), false)
  end
  else if (elem.value is TFhirDate) then
  begin
    ComposeDateValue(json, 'valueDate', TFhirDate(elem.value), false);
    ComposeDateProps(json, 'valueDate', TFhirDate(elem.value), false)
  end
  else if (elem.value is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false)
  end
  else if (elem.value is TFhirUri) then
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false)
  end
  else if (elem.value is TFhirId) then
  begin
    ComposeIdValue(json, 'valueId', TFhirId(elem.value), false);
    ComposeIdProps(json, 'valueId', TFhirId(elem.value), false)
  end
  else if (elem.value is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false);
    ComposeBase64BinaryProps(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false)
  end
  else if (elem.value is TFhirOid) then
  begin
    ComposeOidValue(json, 'valueOid', TFhirOid(elem.value), false);
    ComposeOidProps(json, 'valueOid', TFhirOid(elem.value), false)
  end
  else if (elem.value is TFhirString) then
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false)
  end
  else if (elem.value is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false)
  end
  else if (elem.value is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'valueUuid', TFhirUuid(elem.value), false);
    ComposeUuidProps(json, 'valueUuid', TFhirUuid(elem.value), false)
  end
  else if (elem.value is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'valueInstant', TFhirInstant(elem.value), false);
    ComposeInstantProps(json, 'valueInstant', TFhirInstant(elem.value), false)
  end
  else if (elem.value is TFhirPeriod) then
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value))
  else if (elem.value is TFhirCoding) then
    ComposeCoding(json, 'valueCoding', TFhirCoding(elem.value))
  else if (elem.value is TFhirRange) then
    ComposeRange(json, 'valueRange', TFhirRange(elem.value))
  else if (elem.value is TFhirQuantity) then
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirAttachment) then
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value))
  else if (elem.value is TFhirRatio) then
    ComposeRatio(json, 'valueRatio', TFhirRatio(elem.value))
  else if (elem.value is TFhirSampledData) then
    ComposeSampledData(json, 'valueSampledData', TFhirSampledData(elem.value))
  else if (elem.value is TFhirResourceReference) then
    ComposeResourceReference(json, 'valueResource', TFhirResourceReference(elem.value))
  else if (elem.value is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirIdentifier) then
    ComposeIdentifier(json, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (elem.value is TFhirSchedule) then
    ComposeSchedule(json, 'valueSchedule', TFhirSchedule(elem.value))
  else if (elem.value is TFhirContact) then
    ComposeContact(json, 'valueContact', TFhirContact(elem.value))
  else if (elem.value is TFhirAddress) then
    ComposeAddress(json, 'valueAddress', TFhirAddress(elem.value))
  else if (elem.value is TFhirHumanName) then
    ComposeHumanName(json, 'valueHumanName', TFhirHumanName(elem.value));
  if (elem.example is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'exampleInteger', TFhirInteger(elem.example), false);
    ComposeIntegerProps(json, 'exampleInteger', TFhirInteger(elem.example), false)
  end
  else if (elem.example is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'exampleDateTime', TFhirDateTime(elem.example), false);
    ComposeDateTimeProps(json, 'exampleDateTime', TFhirDateTime(elem.example), false)
  end
  else if (elem.example is TFhirCode) then
  begin
    ComposeCodeValue(json, 'exampleCode', TFhirCode(elem.example), false);
    ComposeCodeProps(json, 'exampleCode', TFhirCode(elem.example), false)
  end
  else if (elem.example is TFhirDate) then
  begin
    ComposeDateValue(json, 'exampleDate', TFhirDate(elem.example), false);
    ComposeDateProps(json, 'exampleDate', TFhirDate(elem.example), false)
  end
  else if (elem.example is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'exampleDecimal', TFhirDecimal(elem.example), false);
    ComposeDecimalProps(json, 'exampleDecimal', TFhirDecimal(elem.example), false)
  end
  else if (elem.example is TFhirUri) then
  begin
    ComposeUriValue(json, 'exampleUri', TFhirUri(elem.example), false);
    ComposeUriProps(json, 'exampleUri', TFhirUri(elem.example), false)
  end
  else if (elem.example is TFhirId) then
  begin
    ComposeIdValue(json, 'exampleId', TFhirId(elem.example), false);
    ComposeIdProps(json, 'exampleId', TFhirId(elem.example), false)
  end
  else if (elem.example is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'exampleBase64Binary', TFhirBase64Binary(elem.example), false);
    ComposeBase64BinaryProps(json, 'exampleBase64Binary', TFhirBase64Binary(elem.example), false)
  end
  else if (elem.example is TFhirOid) then
  begin
    ComposeOidValue(json, 'exampleOid', TFhirOid(elem.example), false);
    ComposeOidProps(json, 'exampleOid', TFhirOid(elem.example), false)
  end
  else if (elem.example is TFhirString) then
  begin
    ComposeStringValue(json, 'exampleString', TFhirString(elem.example), false);
    ComposeStringProps(json, 'exampleString', TFhirString(elem.example), false)
  end
  else if (elem.example is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'exampleBoolean', TFhirBoolean(elem.example), false);
    ComposeBooleanProps(json, 'exampleBoolean', TFhirBoolean(elem.example), false)
  end
  else if (elem.example is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'exampleUuid', TFhirUuid(elem.example), false);
    ComposeUuidProps(json, 'exampleUuid', TFhirUuid(elem.example), false)
  end
  else if (elem.example is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'exampleInstant', TFhirInstant(elem.example), false);
    ComposeInstantProps(json, 'exampleInstant', TFhirInstant(elem.example), false)
  end
  else if (elem.example is TFhirPeriod) then
    ComposePeriod(json, 'examplePeriod', TFhirPeriod(elem.example))
  else if (elem.example is TFhirCoding) then
    ComposeCoding(json, 'exampleCoding', TFhirCoding(elem.example))
  else if (elem.example is TFhirRange) then
    ComposeRange(json, 'exampleRange', TFhirRange(elem.example))
  else if (elem.example is TFhirQuantity) then
    ComposeQuantity(json, 'exampleQuantity', TFhirQuantity(elem.example))
  else if (elem.example is TFhirAttachment) then
    ComposeAttachment(json, 'exampleAttachment', TFhirAttachment(elem.example))
  else if (elem.example is TFhirRatio) then
    ComposeRatio(json, 'exampleRatio', TFhirRatio(elem.example))
  else if (elem.example is TFhirSampledData) then
    ComposeSampledData(json, 'exampleSampledData', TFhirSampledData(elem.example))
  else if (elem.example is TFhirResourceReference) then
    ComposeResourceReference(json, 'exampleResource', TFhirResourceReference(elem.example))
  else if (elem.example is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'exampleCodeableConcept', TFhirCodeableConcept(elem.example))
  else if (elem.example is TFhirIdentifier) then
    ComposeIdentifier(json, 'exampleIdentifier', TFhirIdentifier(elem.example))
  else if (elem.example is TFhirSchedule) then
    ComposeSchedule(json, 'exampleSchedule', TFhirSchedule(elem.example))
  else if (elem.example is TFhirContact) then
    ComposeContact(json, 'exampleContact', TFhirContact(elem.example))
  else if (elem.example is TFhirAddress) then
    ComposeAddress(json, 'exampleAddress', TFhirAddress(elem.example))
  else if (elem.example is TFhirHumanName) then
    ComposeHumanName(json, 'exampleHumanName', TFhirHumanName(elem.example));
  ComposeIntegerValue(json, 'maxLength', elem.maxLength, false);
  ComposeIntegerProps(json, 'maxLength', elem.maxLength, false);
  if elem.conditionList.Count > 0 then
  begin
    json.valueArray('condition');
    ext := false;
    for i := 0 to elem.conditionList.Count - 1 do
    begin
      ext := ext or ((elem.conditionList[i].xmlid <> '') or (elem.conditionList[i].hasExtensions));
      ComposeIdValue(json, '',elem.conditionList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_condition');
      for i := 0 to elem.conditionList.Count - 1 do
        ComposeIdProps(json, '',elem.conditionList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.constraintList.Count > 0 then
  begin
    json.valueArray('constraint');
    for i := 0 to elem.constraintList.Count - 1 do
      ComposeProfileStructureElementDefinitionConstraint(json, '',elem.constraintList[i]); {z - }
    json.FinishArray;
  end;
  ComposeBooleanValue(json, 'mustSupport', elem.mustSupport, false);
  ComposeBooleanProps(json, 'mustSupport', elem.mustSupport, false);
  ComposeBooleanValue(json, 'isModifier', elem.isModifier, false);
  ComposeBooleanProps(json, 'isModifier', elem.isModifier, false);
  ComposeProfileStructureElementDefinitionBinding(json, 'binding', elem.binding); {a}
  if elem.mappingList.Count > 0 then
  begin
    json.valueArray('mapping');
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeProfileStructureElementDefinitionMapping(json, '',elem.mappingList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseProfileStructureElementDefinitionType(element : IXmlDomElement; path : string) : TFhirProfileStructureElementDefinitionType;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfileStructureElementDefinitionType.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'profile') then
        result.profile := ParseUri(child, path+'/profile') {b}
      else if (child.baseName = 'aggregation') then
        result.aggregation.Add(ParseEnum(CODES_TFhirResourceAggregationMode, path+'/aggregation', child))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfileStructureElementDefinitionType(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureElementDefinitionType);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'code', elem.code);
  ComposeUri(xml, 'profile', elem.profile);
  for i := 0 to elem.aggregation.Count - 1 do
    ComposeEnum(xml, 'aggregation', elem.aggregation[i], CODES_TFhirResourceAggregationMode);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfileStructureElementDefinitionType(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfileStructureElementDefinitionType(jsn));
end;

function TFHIRJsonParser.ParseProfileStructureElementDefinitionType(jsn : TJsonObject) : TFhirProfileStructureElementDefinitionType;
begin
  result := TFhirProfileStructureElementDefinitionType.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.code := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('profile') or jsn.has('_profile') then
        result.profile := ParseUri(jsn['profile'], jsn.vObj['_profile']);{q}
    if jsn.has('aggregation') or jsn.has('_aggregation') then
      iterateEnumArray(jsn.vArr['aggregation'], jsn.vArr['_aggregation'], result.aggregation, parseEnum, CODES_TFhirResourceAggregationMode);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfileStructureElementDefinitionType(json : TJSONWriter; name : string; elem : TFhirProfileStructureElementDefinitionType);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'code', elem.code, false);
  ComposeCodeProps(json, 'code', elem.code, false);
  ComposeUriValue(json, 'profile', elem.profile, false);
  ComposeUriProps(json, 'profile', elem.profile, false);
  if elem.aggregation.Count > 0 then
  begin
    json.valueArray('aggregation');
    ext := false;
    for i := 0 to elem.aggregation.Count - 1 do
    begin
      ext := ext or ((elem.aggregation[i].xmlid <> '') or (elem.aggregation[i].hasExtensions));
      ComposeEnumValue(json, '', elem.aggregation[i], CODES_TFhirResourceAggregationMode, true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_aggregation');
      for i := 0 to elem.aggregation.Count - 1 do
        ComposeEnumProps(json, '', elem.aggregation[i], CODES_TFhirResourceAggregationMode, true);
      json.FinishArray;
    end;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseProfileStructureElementDefinitionConstraint(element : IXmlDomElement; path : string) : TFhirProfileStructureElementDefinitionConstraint;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfileStructureElementDefinitionConstraint.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'key') then
        result.key := ParseId(child, path+'/key') {b}
      else if (child.baseName = 'name') then
        result.name := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'severity') then
        result.severity := ParseEnum(CODES_TFhirConstraintSeverity, path+'/severity', child)
      else if (child.baseName = 'human') then
        result.human := ParseString(child, path+'/human') {b}
      else if (child.baseName = 'xpath') then
        result.xpath := ParseString(child, path+'/xpath') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfileStructureElementDefinitionConstraint(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureElementDefinitionConstraint);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'key', elem.key);
  ComposeString(xml, 'name', elem.name);
  ComposeEnum(xml, 'severity', elem.Severity, CODES_TFhirConstraintSeverity);
  ComposeString(xml, 'human', elem.human);
  ComposeString(xml, 'xpath', elem.xpath);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfileStructureElementDefinitionConstraint(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfileStructureElementDefinitionConstraint(jsn));
end;

function TFHIRJsonParser.ParseProfileStructureElementDefinitionConstraint(jsn : TJsonObject) : TFhirProfileStructureElementDefinitionConstraint;
begin
  result := TFhirProfileStructureElementDefinitionConstraint.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('key') or jsn.has('_key') then
        result.key := ParseId(jsn['key'], jsn.vObj['_key']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.name := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('severity') or jsn.has('_severity')  then
      result.severity := parseEnum(jsn['severity'], jsn.vObj['_severity'], CODES_TFhirConstraintSeverity);
    if jsn.has('human') or jsn.has('_human') then
        result.human := ParseString(jsn['human'], jsn.vObj['_human']);{q}
    if jsn.has('xpath') or jsn.has('_xpath') then
        result.xpath := ParseString(jsn['xpath'], jsn.vObj['_xpath']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfileStructureElementDefinitionConstraint(json : TJSONWriter; name : string; elem : TFhirProfileStructureElementDefinitionConstraint);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'key', elem.key, false);
  ComposeIdProps(json, 'key', elem.key, false);
  ComposeStringValue(json, 'name', elem.name, false);
  ComposeStringProps(json, 'name', elem.name, false);
  ComposeEnumValue(json, 'severity', elem.Severity, CODES_TFhirConstraintSeverity, false);
  ComposeEnumProps(json, 'severity', elem.Severity, CODES_TFhirConstraintSeverity, false);
  ComposeStringValue(json, 'human', elem.human, false);
  ComposeStringProps(json, 'human', elem.human, false);
  ComposeStringValue(json, 'xpath', elem.xpath, false);
  ComposeStringProps(json, 'xpath', elem.xpath, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseProfileStructureElementDefinitionBinding(element : IXmlDomElement; path : string) : TFhirProfileStructureElementDefinitionBinding;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfileStructureElementDefinitionBinding.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.name := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'isExtensible') then
        result.isExtensible := ParseBoolean(child, path+'/isExtensible') {b}
      else if (child.baseName = 'conformance') then
        result.conformance := ParseEnum(CODES_TFhirBindingConformance, path+'/conformance', child)
      else if (child.baseName = 'description') then
        result.description := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'referenceUri') then
        result.reference := ParseUri(child, path+'/referenceUri')
      else if (child.baseName = 'referenceResource') then
        result.reference := ParseResourceReference(child, path+'/referenceResource') {a}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfileStructureElementDefinitionBinding(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureElementDefinitionBinding);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.name);
  ComposeBoolean(xml, 'isExtensible', elem.isExtensible);
  ComposeEnum(xml, 'conformance', elem.Conformance, CODES_TFhirBindingConformance);
  ComposeString(xml, 'description', elem.description);
  if (elem.reference is TFhirUri) {6} then
    ComposeUri(xml, 'referenceUri', TFhirUri(elem.reference))
  else if (elem.reference is TFhirResourceReference) {2} then
    ComposeResourceReference(xml, 'referenceResource', TFhirResourceReference(elem.reference));
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfileStructureElementDefinitionBinding(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfileStructureElementDefinitionBinding(jsn));
end;

function TFHIRJsonParser.ParseProfileStructureElementDefinitionBinding(jsn : TJsonObject) : TFhirProfileStructureElementDefinitionBinding;
begin
  result := TFhirProfileStructureElementDefinitionBinding.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.name := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('isExtensible') or jsn.has('_isExtensible') then
        result.isExtensible := ParseBoolean(jsn['isExtensible'], jsn.vObj['_isExtensible']);{q}
    if jsn.has('conformance') or jsn.has('_conformance')  then
      result.conformance := parseEnum(jsn['conformance'], jsn.vObj['_conformance'], CODES_TFhirBindingConformance);
    if jsn.has('description') or jsn.has('_description') then
        result.description := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('referenceUri') or jsn.has('_referenceUri') then
      result.reference := parseUri(jsn['referenceUri'], jsn.vObj['_referenceUri']);
    if jsn.has('referenceResource') {a3} then
      result.reference := ParseResourceReference(jsn.vObj['referenceResource']);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfileStructureElementDefinitionBinding(json : TJSONWriter; name : string; elem : TFhirProfileStructureElementDefinitionBinding);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.name, false);
  ComposeStringProps(json, 'name', elem.name, false);
  ComposeBooleanValue(json, 'isExtensible', elem.isExtensible, false);
  ComposeBooleanProps(json, 'isExtensible', elem.isExtensible, false);
  ComposeEnumValue(json, 'conformance', elem.Conformance, CODES_TFhirBindingConformance, false);
  ComposeEnumProps(json, 'conformance', elem.Conformance, CODES_TFhirBindingConformance, false);
  ComposeStringValue(json, 'description', elem.description, false);
  ComposeStringProps(json, 'description', elem.description, false);
  if (elem.reference is TFhirUri) then 
  begin
    ComposeUriValue(json, 'referenceUri', TFhirUri(elem.reference), false);
    ComposeUriProps(json, 'referenceUri', TFhirUri(elem.reference), false);
  end
  else if (elem.reference is TFhirResourceReference) then
    ComposeResourceReference(json, 'referenceResource', TFhirResourceReference(elem.reference));
  json.finishObject;
end;

function TFHIRXmlParser.ParseProfileStructureElementDefinitionMapping(element : IXmlDomElement; path : string) : TFhirProfileStructureElementDefinitionMapping;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfileStructureElementDefinitionMapping.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identity') then
        result.identity := ParseId(child, path+'/identity') {b}
      else if (child.baseName = 'map') then
        result.map := ParseString(child, path+'/map') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfileStructureElementDefinitionMapping(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureElementDefinitionMapping);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'identity', elem.identity);
  ComposeString(xml, 'map', elem.map);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfileStructureElementDefinitionMapping(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfileStructureElementDefinitionMapping(jsn));
end;

function TFHIRJsonParser.ParseProfileStructureElementDefinitionMapping(jsn : TJsonObject) : TFhirProfileStructureElementDefinitionMapping;
begin
  result := TFhirProfileStructureElementDefinitionMapping.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identity') or jsn.has('_identity') then
        result.identity := ParseId(jsn['identity'], jsn.vObj['_identity']);{q}
    if jsn.has('map') or jsn.has('_map') then
        result.map := ParseString(jsn['map'], jsn.vObj['_map']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfileStructureElementDefinitionMapping(json : TJSONWriter; name : string; elem : TFhirProfileStructureElementDefinitionMapping);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'identity', elem.identity, false);
  ComposeIdProps(json, 'identity', elem.identity, false);
  ComposeStringValue(json, 'map', elem.map, false);
  ComposeStringProps(json, 'map', elem.map, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseProfileStructureSearchParam(element : IXmlDomElement; path : string) : TFhirProfileStructureSearchParam;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfileStructureSearchParam.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.name := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseEnum(CODES_TFhirSearchParamType, path+'/type', child)
      else if (child.baseName = 'documentation') then
        result.documentation := ParseString(child, path+'/documentation') {b}
      else if (child.baseName = 'xpath') then
        result.xpath := ParseString(child, path+'/xpath') {b}
      else if (child.baseName = 'target') then
        result.targetList.Add(ParseCode(child, path+'/target'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfileStructureSearchParam(xml : TXmlBuilder; name : string; elem : TFhirProfileStructureSearchParam);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.name);
  ComposeEnum(xml, 'type', elem.Type_, CODES_TFhirSearchParamType);
  ComposeString(xml, 'documentation', elem.documentation);
  ComposeString(xml, 'xpath', elem.xpath);
  for i := 0 to elem.targetList.Count - 1 do
    ComposeCode(xml, 'target', elem.targetList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfileStructureSearchParam(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfileStructureSearchParam(jsn));
end;

function TFHIRJsonParser.ParseProfileStructureSearchParam(jsn : TJsonObject) : TFhirProfileStructureSearchParam;
begin
  result := TFhirProfileStructureSearchParam.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.name := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_ := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirSearchParamType);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentation := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('xpath') or jsn.has('_xpath') then
        result.xpath := ParseString(jsn['xpath'], jsn.vObj['_xpath']);{q}
      if jsn.has('target') or jsn.has('_target') then
      iteratePrimitiveArray(jsn.vArr['target'], jsn.vArr['_target'], result.targetList, parseCode);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfileStructureSearchParam(json : TJSONWriter; name : string; elem : TFhirProfileStructureSearchParam);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.name, false);
  ComposeStringProps(json, 'name', elem.name, false);
  ComposeEnumValue(json, 'type', elem.Type_, CODES_TFhirSearchParamType, false);
  ComposeEnumProps(json, 'type', elem.Type_, CODES_TFhirSearchParamType, false);
  ComposeStringValue(json, 'documentation', elem.documentation, false);
  ComposeStringProps(json, 'documentation', elem.documentation, false);
  ComposeStringValue(json, 'xpath', elem.xpath, false);
  ComposeStringProps(json, 'xpath', elem.xpath, false);
  if elem.targetList.Count > 0 then
  begin
    json.valueArray('target');
    ext := false;
    for i := 0 to elem.targetList.Count - 1 do
    begin
      ext := ext or ((elem.targetList[i].xmlid <> '') or (elem.targetList[i].hasExtensions));
      ComposeCodeValue(json, '',elem.targetList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_target');
      for i := 0 to elem.targetList.Count - 1 do
        ComposeCodeProps(json, '',elem.targetList[i], true);
      json.FinishArray;
    end;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseProfileExtensionDefn(element : IXmlDomElement; path : string) : TFhirProfileExtensionDefn;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfileExtensionDefn.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'display') then
        result.display := ParseString(child, path+'/display') {b}
      else if (child.baseName = 'contextType') then
        result.contextType := ParseEnum(CODES_TFhirExtensionContext, path+'/contextType', child)
      else if (child.baseName = 'context') then
        result.contextList.Add(ParseString(child, path+'/context'))
      else if (child.baseName = 'definition') then
        result.definition := ParseProfileStructureElementDefinition(child, path+'/definition') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfileExtensionDefn(xml : TXmlBuilder; name : string; elem : TFhirProfileExtensionDefn);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'code', elem.code);
  ComposeString(xml, 'display', elem.display);
  ComposeEnum(xml, 'contextType', elem.ContextType, CODES_TFhirExtensionContext);
  for i := 0 to elem.contextList.Count - 1 do
    ComposeString(xml, 'context', elem.contextList[i]);
  ComposeProfileStructureElementDefinition(xml, 'definition', elem.definition);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfileExtensionDefn(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfileExtensionDefn(jsn));
end;

function TFHIRJsonParser.ParseProfileExtensionDefn(jsn : TJsonObject) : TFhirProfileExtensionDefn;
begin
  result := TFhirProfileExtensionDefn.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.code := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.display := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    if jsn.has('contextType') or jsn.has('_contextType')  then
      result.contextType := parseEnum(jsn['contextType'], jsn.vObj['_contextType'], CODES_TFhirExtensionContext);
      if jsn.has('context') or jsn.has('_context') then
      iteratePrimitiveArray(jsn.vArr['context'], jsn.vArr['_context'], result.contextList, parseString);
    if jsn.has('definition') then
        result.definition := ParseProfileStructureElementDefinition(jsn.vObj['definition']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfileExtensionDefn(json : TJSONWriter; name : string; elem : TFhirProfileExtensionDefn);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'code', elem.code, false);
  ComposeCodeProps(json, 'code', elem.code, false);
  ComposeStringValue(json, 'display', elem.display, false);
  ComposeStringProps(json, 'display', elem.display, false);
  ComposeEnumValue(json, 'contextType', elem.ContextType, CODES_TFhirExtensionContext, false);
  ComposeEnumProps(json, 'contextType', elem.ContextType, CODES_TFhirExtensionContext, false);
  if elem.contextList.Count > 0 then
  begin
    json.valueArray('context');
    ext := false;
    for i := 0 to elem.contextList.Count - 1 do
    begin
      ext := ext or ((elem.contextList[i].xmlid <> '') or (elem.contextList[i].hasExtensions));
      ComposeStringValue(json, '',elem.contextList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_context');
      for i := 0 to elem.contextList.Count - 1 do
        ComposeStringProps(json, '',elem.contextList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeProfileStructureElementDefinition(json, 'definition', elem.definition); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseProfileQuery(element : IXmlDomElement; path : string) : TFhirProfileQuery;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfileQuery.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.name := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'documentation') then
        result.documentation := ParseString(child, path+'/documentation') {b}
      else if (child.baseName = 'parameter') then
        result.parameterList.Add(ParseProfileStructureSearchParam(child, path+'/parameter'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfileQuery(xml : TXmlBuilder; name : string; elem : TFhirProfileQuery);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.name);
  ComposeString(xml, 'documentation', elem.documentation);
  for i := 0 to elem.parameterList.Count - 1 do
    ComposeProfileStructureSearchParam(xml, 'parameter', elem.parameterList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfileQuery(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfileQuery(jsn));
end;

function TFHIRJsonParser.ParseProfileQuery(jsn : TJsonObject) : TFhirProfileQuery;
begin
  result := TFhirProfileQuery.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.name := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentation := ParseString(jsn['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseProfileStructureSearchParam);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfileQuery(json : TJSONWriter; name : string; elem : TFhirProfileQuery);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.name, false);
  ComposeStringProps(json, 'name', elem.name, false);
  ComposeStringValue(json, 'documentation', elem.documentation, false);
  ComposeStringProps(json, 'documentation', elem.documentation, false);
  if elem.parameterList.Count > 0 then
  begin
    json.valueArray('parameter');
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeProfileStructureSearchParam(json, '',elem.parameterList[i]); {z - @Profile.structure.searchParam}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseProfile(element : IXmlDomElement; path : string) : TFhirProfile;
var
  child : IXMLDOMElement;
begin
  result := TFhirProfile.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseString(child, path+'/identifier') {b}
      else if (child.baseName = 'version') then
        result.version := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'name') then
        result.name := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'publisher') then
        result.publisher := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContact(child, path+'/telecom'))
      else if (child.baseName = 'description') then
        result.description := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'code') then
        result.codeList.Add(ParseCoding(child, path+'/code'))
      else if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirResourceProfileStatus, path+'/status', child)
      else if (child.baseName = 'experimental') then
        result.experimental := ParseBoolean(child, path+'/experimental') {b}
      else if (child.baseName = 'date') then
        result.date := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'requirements') then
        result.requirements := ParseString(child, path+'/requirements') {b}
      else if (child.baseName = 'fhirVersion') then
        result.fhirVersion := ParseId(child, path+'/fhirVersion') {b}
      else if (child.baseName = 'mapping') then
        result.mappingList.Add(ParseProfileMapping(child, path+'/mapping'))
      else if (child.baseName = 'structure') then
        result.structureList.Add(ParseProfileStructure(child, path+'/structure'))
      else if (child.baseName = 'extensionDefn') then
        result.extensionDefnList.Add(ParseProfileExtensionDefn(child, path+'/extensionDefn'))
      else if (child.baseName = 'query') then
        result.queryList.Add(ParseProfileQuery(child, path+'/query'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProfile(xml : TXmlBuilder; name : string; elem : TFhirProfile);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeString(xml, 'identifier', elem.identifier);
  ComposeString(xml, 'version', elem.version);
  ComposeString(xml, 'name', elem.name);
  ComposeString(xml, 'publisher', elem.publisher);
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContact(xml, 'telecom', elem.telecomList[i]);
  ComposeString(xml, 'description', elem.description);
  for i := 0 to elem.codeList.Count - 1 do
    ComposeCoding(xml, 'code', elem.codeList[i]);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirResourceProfileStatus);
  ComposeBoolean(xml, 'experimental', elem.experimental);
  ComposeDateTime(xml, 'date', elem.date);
  if not SummaryOnly then
    ComposeString(xml, 'requirements', elem.requirements);
  ComposeId(xml, 'fhirVersion', elem.fhirVersion);
  if not SummaryOnly then
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeProfileMapping(xml, 'mapping', elem.mappingList[i]);
  if not SummaryOnly then
    for i := 0 to elem.structureList.Count - 1 do
      ComposeProfileStructure(xml, 'structure', elem.structureList[i]);
  if not SummaryOnly then
    for i := 0 to elem.extensionDefnList.Count - 1 do
      ComposeProfileExtensionDefn(xml, 'extensionDefn', elem.extensionDefnList[i]);
  if not SummaryOnly then
    for i := 0 to elem.queryList.Count - 1 do
      ComposeProfileQuery(xml, 'query', elem.queryList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProfile(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProfile(jsn));
end;

function TFHIRJsonParser.ParseProfile(jsn : TJsonObject) : TFhirProfile;
begin
  result := TFhirProfile.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifier := ParseString(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.version := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.name := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisher := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContact);
    if jsn.has('description') or jsn.has('_description') then
        result.description := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCoding);
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirResourceProfileStatus);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimental := ParseBoolean(jsn['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.date := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirements := ParseString(jsn['requirements'], jsn.vObj['_requirements']);{q}
    if jsn.has('fhirVersion') or jsn.has('_fhirVersion') then
        result.fhirVersion := ParseId(jsn['fhirVersion'], jsn.vObj['_fhirVersion']);{q}
    if jsn.has('mapping') then
      iterateArray(jsn.vArr['mapping'], result.mappingList, parseProfileMapping);
    if jsn.has('structure') then
      iterateArray(jsn.vArr['structure'], result.structureList, parseProfileStructure);
    if jsn.has('extensionDefn') then
      iterateArray(jsn.vArr['extensionDefn'], result.extensionDefnList, parseProfileExtensionDefn);
    if jsn.has('query') then
      iterateArray(jsn.vArr['query'], result.queryList, parseProfileQuery);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProfile(json : TJSONWriter; name : string; elem : TFhirProfile);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeStringValue(json, 'identifier', elem.identifier, false);
  ComposeStringProps(json, 'identifier', elem.identifier, false);
  ComposeStringValue(json, 'version', elem.version, false);
  ComposeStringProps(json, 'version', elem.version, false);
  ComposeStringValue(json, 'name', elem.name, false);
  ComposeStringProps(json, 'name', elem.name, false);
  ComposeStringValue(json, 'publisher', elem.publisher, false);
  ComposeStringProps(json, 'publisher', elem.publisher, false);
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContact(json, '',elem.telecomList[i]); {z - Contact}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.description, false);
  ComposeStringProps(json, 'description', elem.description, false);
  if elem.codeList.Count > 0 then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(json, '',elem.codeList[i]); {z - Coding}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirResourceProfileStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirResourceProfileStatus, false);
  ComposeBooleanValue(json, 'experimental', elem.experimental, false);
  ComposeBooleanProps(json, 'experimental', elem.experimental, false);
  ComposeDateTimeValue(json, 'date', elem.date, false);
  ComposeDateTimeProps(json, 'date', elem.date, false);
  if not SummaryOnly then
    ComposeStringValue(json, 'requirements', elem.requirements, false);
  if not SummaryOnly then
    ComposeStringProps(json, 'requirements', elem.requirements, false);
  ComposeIdValue(json, 'fhirVersion', elem.fhirVersion, false);
  ComposeIdProps(json, 'fhirVersion', elem.fhirVersion, false);
  if not SummaryOnly and (elem.mappingList.Count > 0) then
  begin
    json.valueArray('mapping');
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeProfileMapping(json, '',elem.mappingList[i]); {z - }
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.structureList.Count > 0) then
  begin
    json.valueArray('structure');
    for i := 0 to elem.structureList.Count - 1 do
      ComposeProfileStructure(json, '',elem.structureList[i]); {z - }
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.extensionDefnList.Count > 0) then
  begin
    json.valueArray('extensionDefn');
    for i := 0 to elem.extensionDefnList.Count - 1 do
      ComposeProfileExtensionDefn(json, '',elem.extensionDefnList[i]); {z - }
    json.FinishArray;
  end;
  if not SummaryOnly and (elem.queryList.Count > 0) then
  begin
    json.valueArray('query');
    for i := 0 to elem.queryList.Count - 1 do
      ComposeProfileQuery(json, '',elem.queryList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseProvenanceAgent(element : IXmlDomElement; path : string) : TFhirProvenanceAgent;
var
  child : IXMLDOMElement;
begin
  result := TFhirProvenanceAgent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'role') then
        result.role := ParseCoding(child, path+'/role') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'reference') then
        result.reference := ParseUri(child, path+'/reference') {b}
      else if (child.baseName = 'display') then
        result.display := ParseString(child, path+'/display') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProvenanceAgent(xml : TXmlBuilder; name : string; elem : TFhirProvenanceAgent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'role', elem.role);
  ComposeCoding(xml, 'type', elem.type_);
  ComposeUri(xml, 'reference', elem.reference);
  ComposeString(xml, 'display', elem.display);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProvenanceAgent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProvenanceAgent(jsn));
end;

function TFHIRJsonParser.ParseProvenanceAgent(jsn : TJsonObject) : TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') then
        result.role := ParseCoding(jsn.vObj['role']);{q}
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('reference') or jsn.has('_reference') then
        result.reference := ParseUri(jsn['reference'], jsn.vObj['_reference']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.display := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProvenanceAgent(json : TJSONWriter; name : string; elem : TFhirProvenanceAgent);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'role', elem.role); {a}
  ComposeCoding(json, 'type', elem.type_); {a}
  ComposeUriValue(json, 'reference', elem.reference, false);
  ComposeUriProps(json, 'reference', elem.reference, false);
  ComposeStringValue(json, 'display', elem.display, false);
  ComposeStringProps(json, 'display', elem.display, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseProvenanceEntity(element : IXmlDomElement; path : string) : TFhirProvenanceEntity;
var
  child : IXMLDOMElement;
begin
  result := TFhirProvenanceEntity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'role') then
        result.role := ParseEnum(CODES_TFhirProvenanceEntityRole, path+'/role', child)
      else if (child.baseName = 'type') then
        result.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.baseName = 'reference') then
        result.reference := ParseUri(child, path+'/reference') {b}
      else if (child.baseName = 'display') then
        result.display := ParseString(child, path+'/display') {b}
      else if (child.baseName = 'agent') then
        result.agent := ParseProvenanceAgent(child, path+'/agent') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProvenanceEntity(xml : TXmlBuilder; name : string; elem : TFhirProvenanceEntity);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'role', elem.Role, CODES_TFhirProvenanceEntityRole);
  ComposeCoding(xml, 'type', elem.type_);
  ComposeUri(xml, 'reference', elem.reference);
  ComposeString(xml, 'display', elem.display);
  ComposeProvenanceAgent(xml, 'agent', elem.agent);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProvenanceEntity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProvenanceEntity(jsn));
end;

function TFHIRJsonParser.ParseProvenanceEntity(jsn : TJsonObject) : TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') or jsn.has('_role')  then
      result.role := parseEnum(jsn['role'], jsn.vObj['_role'], CODES_TFhirProvenanceEntityRole);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q}
    if jsn.has('reference') or jsn.has('_reference') then
        result.reference := ParseUri(jsn['reference'], jsn.vObj['_reference']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.display := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    if jsn.has('agent') then
        result.agent := ParseProvenanceAgent(jsn.vObj['agent']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProvenanceEntity(json : TJSONWriter; name : string; elem : TFhirProvenanceEntity);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'role', elem.Role, CODES_TFhirProvenanceEntityRole, false);
  ComposeEnumProps(json, 'role', elem.Role, CODES_TFhirProvenanceEntityRole, false);
  ComposeCoding(json, 'type', elem.type_); {a}
  ComposeUriValue(json, 'reference', elem.reference, false);
  ComposeUriProps(json, 'reference', elem.reference, false);
  ComposeStringValue(json, 'display', elem.display, false);
  ComposeStringProps(json, 'display', elem.display, false);
  ComposeProvenanceAgent(json, 'agent', elem.agent); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseProvenance(element : IXmlDomElement; path : string) : TFhirProvenance;
var
  child : IXMLDOMElement;
begin
  result := TFhirProvenance.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'target') then
        result.targetList.Add(ParseResourceReference{Resource}(child, path+'/target'))
      else if (child.baseName = 'period') then
        result.period := ParsePeriod(child, path+'/period') {b}
      else if (child.baseName = 'recorded') then
        result.recorded := ParseInstant(child, path+'/recorded') {b}
      else if (child.baseName = 'reason') then
        result.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if (child.baseName = 'location') then
        result.location := ParseResourceReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.baseName = 'policy') then
        result.policyList.Add(ParseUri(child, path+'/policy'))
      else if (child.baseName = 'agent') then
        result.agentList.Add(ParseProvenanceAgent(child, path+'/agent'))
      else if (child.baseName = 'entity') then
        result.entityList.Add(ParseProvenanceEntity(child, path+'/entity'))
      else if (child.baseName = 'integritySignature') then
        result.integritySignature := ParseString(child, path+'/integritySignature') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeProvenance(xml : TXmlBuilder; name : string; elem : TFhirProvenance);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.targetList.Count - 1 do
    ComposeResourceReference{Resource}(xml, 'target', elem.targetList[i]);
  ComposePeriod(xml, 'period', elem.period);
  ComposeInstant(xml, 'recorded', elem.recorded);
  ComposeCodeableConcept(xml, 'reason', elem.reason);
  ComposeResourceReference{TFhirLocation}(xml, 'location', elem.location);
  for i := 0 to elem.policyList.Count - 1 do
    ComposeUri(xml, 'policy', elem.policyList[i]);
  for i := 0 to elem.agentList.Count - 1 do
    ComposeProvenanceAgent(xml, 'agent', elem.agentList[i]);
  for i := 0 to elem.entityList.Count - 1 do
    ComposeProvenanceEntity(xml, 'entity', elem.entityList[i]);
  ComposeString(xml, 'integritySignature', elem.integritySignature);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseProvenance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProvenance(jsn));
end;

function TFHIRJsonParser.ParseProvenance(jsn : TJsonObject) : TFhirProvenance;
begin
  result := TFhirProvenance.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('target') then
      iterateArray(jsn.vArr['target'], result.targetList, parseResourceReference{Resource});
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q}
    if jsn.has('recorded') or jsn.has('_recorded') then
        result.recorded := ParseInstant(jsn['recorded'], jsn.vObj['_recorded']);{q}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q}
    if jsn.has('location') then
        result.location := ParseResourceReference{TFhirLocation}(jsn.vObj['location']);{q}
      if jsn.has('policy') or jsn.has('_policy') then
      iteratePrimitiveArray(jsn.vArr['policy'], jsn.vArr['_policy'], result.policyList, parseUri);
    if jsn.has('agent') then
      iterateArray(jsn.vArr['agent'], result.agentList, parseProvenanceAgent);
    if jsn.has('entity') then
      iterateArray(jsn.vArr['entity'], result.entityList, parseProvenanceEntity);
    if jsn.has('integritySignature') or jsn.has('_integritySignature') then
        result.integritySignature := ParseString(jsn['integritySignature'], jsn.vObj['_integritySignature']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeProvenance(json : TJSONWriter; name : string; elem : TFhirProvenance);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.targetList.Count > 0 then
  begin
    json.valueArray('target');
    for i := 0 to elem.targetList.Count - 1 do
      ComposeResourceReference{Resource}(json, '',elem.targetList[i]); {z - Resource(Any)}
    json.FinishArray;
  end;
  ComposePeriod(json, 'period', elem.period); {a}
  ComposeInstantValue(json, 'recorded', elem.recorded, false);
  ComposeInstantProps(json, 'recorded', elem.recorded, false);
  ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  ComposeResourceReference{TFhirLocation}(json, 'location', elem.location); {a}
  if elem.policyList.Count > 0 then
  begin
    json.valueArray('policy');
    ext := false;
    for i := 0 to elem.policyList.Count - 1 do
    begin
      ext := ext or ((elem.policyList[i].xmlid <> '') or (elem.policyList[i].hasExtensions));
      ComposeUriValue(json, '',elem.policyList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_policy');
      for i := 0 to elem.policyList.Count - 1 do
        ComposeUriProps(json, '',elem.policyList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.agentList.Count > 0 then
  begin
    json.valueArray('agent');
    for i := 0 to elem.agentList.Count - 1 do
      ComposeProvenanceAgent(json, '',elem.agentList[i]); {z - }
    json.FinishArray;
  end;
  if elem.entityList.Count > 0 then
  begin
    json.valueArray('entity');
    for i := 0 to elem.entityList.Count - 1 do
      ComposeProvenanceEntity(json, '',elem.entityList[i]); {z - }
    json.FinishArray;
  end;
  ComposeStringValue(json, 'integritySignature', elem.integritySignature, false);
  ComposeStringProps(json, 'integritySignature', elem.integritySignature, false);
end;

function TFHIRXmlParser.ParseQueryResponse(element : IXmlDomElement; path : string) : TFhirQueryResponse;
var
  child : IXMLDOMElement;
begin
  result := TFhirQueryResponse.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseUri(child, path+'/identifier') {b}
      else if (child.baseName = 'outcome') then
        result.outcome := ParseEnum(CODES_TFhirQueryOutcome, path+'/outcome', child)
      else if (child.baseName = 'total') then
        result.total := ParseInteger(child, path+'/total') {b}
      else if (child.baseName = 'parameter') then
        result.parameterList.Add(ParseExtension(child, path+'/parameter'))
      else if (child.baseName = 'first') then
        result.firstList.Add(ParseExtension(child, path+'/first'))
      else if (child.baseName = 'previous') then
        result.previousList.Add(ParseExtension(child, path+'/previous'))
      else if (child.baseName = 'next') then
        result.nextList.Add(ParseExtension(child, path+'/next'))
      else if (child.baseName = 'last') then
        result.lastList.Add(ParseExtension(child, path+'/last'))
      else if (child.baseName = 'reference') then
        result.referenceList.Add(ParseResourceReference{Resource}(child, path+'/reference'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQueryResponse(xml : TXmlBuilder; name : string; elem : TFhirQueryResponse);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'identifier', elem.identifier);
  ComposeEnum(xml, 'outcome', elem.Outcome, CODES_TFhirQueryOutcome);
  ComposeInteger(xml, 'total', elem.total);
  for i := 0 to elem.parameterList.Count - 1 do
    ComposeExtension(xml, 'parameter', elem.parameterList[i]);
  for i := 0 to elem.firstList.Count - 1 do
    ComposeExtension(xml, 'first', elem.firstList[i]);
  for i := 0 to elem.previousList.Count - 1 do
    ComposeExtension(xml, 'previous', elem.previousList[i]);
  for i := 0 to elem.nextList.Count - 1 do
    ComposeExtension(xml, 'next', elem.nextList[i]);
  for i := 0 to elem.lastList.Count - 1 do
    ComposeExtension(xml, 'last', elem.lastList[i]);
  for i := 0 to elem.referenceList.Count - 1 do
    ComposeResourceReference{Resource}(xml, 'reference', elem.referenceList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQueryResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQueryResponse(jsn));
end;

function TFHIRJsonParser.ParseQueryResponse(jsn : TJsonObject) : TFhirQueryResponse;
begin
  result := TFhirQueryResponse.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifier := ParseUri(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcome := parseEnum(jsn['outcome'], jsn.vObj['_outcome'], CODES_TFhirQueryOutcome);
    if jsn.has('total') or jsn.has('_total') then
        result.total := ParseInteger(jsn['total'], jsn.vObj['_total']);{q}
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseExtension);
    if jsn.has('first') then
      iterateArray(jsn.vArr['first'], result.firstList, parseExtension);
    if jsn.has('previous') then
      iterateArray(jsn.vArr['previous'], result.previousList, parseExtension);
    if jsn.has('next') then
      iterateArray(jsn.vArr['next'], result.nextList, parseExtension);
    if jsn.has('last') then
      iterateArray(jsn.vArr['last'], result.lastList, parseExtension);
    if jsn.has('reference') then
      iterateArray(jsn.vArr['reference'], result.referenceList, parseResourceReference{Resource});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQueryResponse(json : TJSONWriter; name : string; elem : TFhirQueryResponse);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'identifier', elem.identifier, false);
  ComposeUriProps(json, 'identifier', elem.identifier, false);
  ComposeEnumValue(json, 'outcome', elem.Outcome, CODES_TFhirQueryOutcome, false);
  ComposeEnumProps(json, 'outcome', elem.Outcome, CODES_TFhirQueryOutcome, false);
  ComposeIntegerValue(json, 'total', elem.total, false);
  ComposeIntegerProps(json, 'total', elem.total, false);
  if elem.parameterList.Count > 0 then
  begin
    json.valueArray('parameter');
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeExtension(json, '',elem.parameterList[i]); {z - Extension}
    json.FinishArray;
  end;
  if elem.firstList.Count > 0 then
  begin
    json.valueArray('first');
    for i := 0 to elem.firstList.Count - 1 do
      ComposeExtension(json, '',elem.firstList[i]); {z - Extension}
    json.FinishArray;
  end;
  if elem.previousList.Count > 0 then
  begin
    json.valueArray('previous');
    for i := 0 to elem.previousList.Count - 1 do
      ComposeExtension(json, '',elem.previousList[i]); {z - Extension}
    json.FinishArray;
  end;
  if elem.nextList.Count > 0 then
  begin
    json.valueArray('next');
    for i := 0 to elem.nextList.Count - 1 do
      ComposeExtension(json, '',elem.nextList[i]); {z - Extension}
    json.FinishArray;
  end;
  if elem.lastList.Count > 0 then
  begin
    json.valueArray('last');
    for i := 0 to elem.lastList.Count - 1 do
      ComposeExtension(json, '',elem.lastList[i]); {z - Extension}
    json.FinishArray;
  end;
  if elem.referenceList.Count > 0 then
  begin
    json.valueArray('reference');
    for i := 0 to elem.referenceList.Count - 1 do
      ComposeResourceReference{Resource}(json, '',elem.referenceList[i]); {z - Resource(Any)}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseQuery(element : IXmlDomElement; path : string) : TFhirQuery;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuery.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseUri(child, path+'/identifier') {b}
      else if (child.baseName = 'parameter') then
        result.parameterList.Add(ParseExtension(child, path+'/parameter'))
      else if (child.baseName = 'response') then
        result.response := ParseQueryResponse(child, path+'/response') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuery(xml : TXmlBuilder; name : string; elem : TFhirQuery);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeUri(xml, 'identifier', elem.identifier);
  for i := 0 to elem.parameterList.Count - 1 do
    ComposeExtension(xml, 'parameter', elem.parameterList[i]);
  ComposeQueryResponse(xml, 'response', elem.response);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuery(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuery(jsn));
end;

function TFHIRJsonParser.ParseQuery(jsn : TJsonObject) : TFhirQuery;
begin
  result := TFhirQuery.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifier := ParseUri(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseExtension);
    if jsn.has('response') then
        result.response := ParseQueryResponse(jsn.vObj['response']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuery(json : TJSONWriter; name : string; elem : TFhirQuery);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeUriValue(json, 'identifier', elem.identifier, false);
  ComposeUriProps(json, 'identifier', elem.identifier, false);
  if elem.parameterList.Count > 0 then
  begin
    json.valueArray('parameter');
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeExtension(json, '',elem.parameterList[i]); {z - Extension}
    json.FinishArray;
  end;
  ComposeQueryResponse(json, 'response', elem.response); {a}
end;

function TFHIRXmlParser.ParseQuestionnaireGroup(element : IXmlDomElement; path : string) : TFhirQuestionnaireGroup;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuestionnaireGroup.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.name := ParseCodeableConcept(child, path+'/name') {b}
      else if (child.baseName = 'header') then
        result.header := ParseString(child, path+'/header') {b}
      else if (child.baseName = 'text') then
        result.text := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseResourceReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'group') then
        result.groupList.Add(ParseQuestionnaireGroup(child, path+'/group'))
      else if (child.baseName = 'question') then
        result.questionList.Add(ParseQuestionnaireGroupQuestion(child, path+'/question'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireGroup(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireGroup);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'name', elem.name);
  ComposeString(xml, 'header', elem.header);
  ComposeString(xml, 'text', elem.text);
  ComposeResourceReference{Resource}(xml, 'subject', elem.subject);
  for i := 0 to elem.groupList.Count - 1 do
    ComposeQuestionnaireGroup(xml, 'group', elem.groupList[i]);
  for i := 0 to elem.questionList.Count - 1 do
    ComposeQuestionnaireGroupQuestion(xml, 'question', elem.questionList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuestionnaireGroup(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireGroup(jsn));
end;

function TFHIRJsonParser.ParseQuestionnaireGroup(jsn : TJsonObject) : TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') then
        result.name := ParseCodeableConcept(jsn.vObj['name']);{q}
    if jsn.has('header') or jsn.has('_header') then
        result.header := ParseString(jsn['header'], jsn.vObj['_header']);{q}
    if jsn.has('text') or jsn.has('_text') then
        result.text := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    if jsn.has('subject') then
        result.subject := ParseResourceReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseQuestionnaireGroup);
    if jsn.has('question') then
      iterateArray(jsn.vArr['question'], result.questionList, parseQuestionnaireGroupQuestion);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireGroup(json : TJSONWriter; name : string; elem : TFhirQuestionnaireGroup);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'name', elem.name); {a}
  ComposeStringValue(json, 'header', elem.header, false);
  ComposeStringProps(json, 'header', elem.header, false);
  ComposeStringValue(json, 'text', elem.text, false);
  ComposeStringProps(json, 'text', elem.text, false);
  ComposeResourceReference{Resource}(json, 'subject', elem.subject); {a}
  if elem.groupList.Count > 0 then
  begin
    json.valueArray('group');
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireGroup(json, '',elem.groupList[i]); {z - @Questionnaire.group}
    json.FinishArray;
  end;
  if elem.questionList.Count > 0 then
  begin
    json.valueArray('question');
    for i := 0 to elem.questionList.Count - 1 do
      ComposeQuestionnaireGroupQuestion(json, '',elem.questionList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseQuestionnaireGroupQuestion(element : IXmlDomElement; path : string) : TFhirQuestionnaireGroupQuestion;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuestionnaireGroupQuestion.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'name') then
        result.name := ParseCodeableConcept(child, path+'/name') {b}
      else if (child.baseName = 'text') then
        result.text := ParseString(child, path+'/text') {b}
      else if (child.baseName = 'answerDecimal') then
        result.answer := ParseDecimal(child, path+'/answerDecimal')
      else if (child.baseName = 'answerInteger') then
        result.answer := ParseInteger(child, path+'/answerInteger')
      else if (child.baseName = 'answerBoolean') then
        result.answer := ParseBoolean(child, path+'/answerBoolean')
      else if (child.baseName = 'answerDate') then
        result.answer := ParseDate(child, path+'/answerDate')
      else if (child.baseName = 'answerString') then
        result.answer := ParseString(child, path+'/answerString')
      else if (child.baseName = 'answerDateTime') then
        result.answer := ParseDateTime(child, path+'/answerDateTime')
      else if (child.baseName = 'answerInstant') then
        result.answer := ParseInstant(child, path+'/answerInstant')
      else if (child.baseName = 'choice') then
        result.choiceList.Add(ParseCoding(child, path+'/choice'))
      else if (child.baseName = 'options') then
        result.options := ParseResourceReference{TFhirValueSet}(child, path+'/options') {b}
      else if (child.baseName = 'dataInteger') then
        result.data := ParseInteger(child, path+'.dataInteger') {c}
      else if (child.baseName = 'dataDateTime') then
        result.data := ParseDateTime(child, path+'.dataDateTime') {c}
      else if (child.baseName = 'dataCode') then
        result.data := ParseCode(child, path+'.dataCode') {c}
      else if (child.baseName = 'dataDate') then
        result.data := ParseDate(child, path+'.dataDate') {c}
      else if (child.baseName = 'dataDecimal') then
        result.data := ParseDecimal(child, path+'.dataDecimal') {c}
      else if (child.baseName = 'dataUri') then
        result.data := ParseUri(child, path+'.dataUri') {c}
      else if (child.baseName = 'dataId') then
        result.data := ParseId(child, path+'.dataId') {c}
      else if (child.baseName = 'dataBase64Binary') then
        result.data := ParseBase64Binary(child, path+'.dataBase64Binary') {c}
      else if (child.baseName = 'dataOid') then
        result.data := ParseOid(child, path+'.dataOid') {c}
      else if (child.baseName = 'dataString') then
        result.data := ParseString(child, path+'.dataString') {c}
      else if (child.baseName = 'dataBoolean') then
        result.data := ParseBoolean(child, path+'.dataBoolean') {c}
      else if (child.baseName = 'dataUuid') then
        result.data := ParseUuid(child, path+'.dataUuid') {c}
      else if (child.baseName = 'dataInstant') then
        result.data := ParseInstant(child, path+'.dataInstant') {c}
      else if (child.baseName = 'dataPeriod') then
        result.data := ParsePeriod(child, path+'.dataPeriod') {ePeriod}
      else if (child.baseName = 'dataCoding') then
        result.data := ParseCoding(child, path+'.dataCoding') {eCoding}
      else if (child.baseName = 'dataRange') then
        result.data := ParseRange(child, path+'.dataRange') {eRange}
      else if (child.baseName = 'dataQuantity') then
        result.data := ParseQuantity(child, path+'.dataQuantity') {eQuantity}
      else if (child.baseName = 'dataAttachment') then
        result.data := ParseAttachment(child, path+'.dataAttachment') {eAttachment}
      else if (child.baseName = 'dataRatio') then
        result.data := ParseRatio(child, path+'.dataRatio') {eRatio}
      else if (child.baseName = 'dataSampledData') then
        result.data := ParseSampledData(child, path+'.dataSampledData') {eSampledData}
      else if (child.baseName = 'dataResource') then
        result.data := ParseResourceReference(child, path+'/dataResource') {e0}
      else if (child.baseName = 'dataCodeableConcept') then
        result.data := ParseCodeableConcept(child, path+'.dataCodeableConcept') {eCodeableConcept}
      else if (child.baseName = 'dataIdentifier') then
        result.data := ParseIdentifier(child, path+'.dataIdentifier') {eIdentifier}
      else if (child.baseName = 'dataSchedule') then
        result.data := ParseSchedule(child, path+'/dataSchedule') {f}
      else if (child.baseName = 'dataContact') then
        result.data := ParseContact(child, path+'/dataContact') {f}
      else if (child.baseName = 'dataAddress') then
        result.data := ParseAddress(child, path+'/dataAddress') {f}
      else if (child.baseName = 'dataHumanName') then
        result.data := ParseHumanName(child, path+'/dataHumanName') {f}
      else if (child.baseName = 'remarks') then
        result.remarks := ParseString(child, path+'/remarks') {b}
      else if (child.baseName = 'group') then
        result.groupList.Add(ParseQuestionnaireGroup(child, path+'/group'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireGroupQuestion(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireGroupQuestion);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'name', elem.name);
  ComposeString(xml, 'text', elem.text);
  if (elem.answer is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'answerDecimal', TFhirDecimal(elem.answer))
  else if (elem.answer is TFhirInteger) {6} then
    ComposeInteger(xml, 'answerInteger', TFhirInteger(elem.answer))
  else if (elem.answer is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'answerBoolean', TFhirBoolean(elem.answer))
  else if (elem.answer is TFhirDate) {6} then
    ComposeDate(xml, 'answerDate', TFhirDate(elem.answer))
  else if (elem.answer is TFhirString) {6} then
    ComposeString(xml, 'answerString', TFhirString(elem.answer))
  else if (elem.answer is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'answerDateTime', TFhirDateTime(elem.answer))
  else if (elem.answer is TFhirInstant) {6} then
    ComposeInstant(xml, 'answerInstant', TFhirInstant(elem.answer));
  for i := 0 to elem.choiceList.Count - 1 do
    ComposeCoding(xml, 'choice', elem.choiceList[i]);
  ComposeResourceReference{TFhirValueSet}(xml, 'options', elem.options);
  if (elem.data is TFhirInteger) {1} then
    ComposeInteger(xml, 'dataInteger', TFhirInteger(elem.data))
  else if (elem.data is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'dataDateTime', TFhirDateTime(elem.data))
  else if (elem.data is TFhirCode) {1} then
    ComposeCode(xml, 'dataCode', TFhirCode(elem.data))
  else if (elem.data is TFhirDate) {1} then
    ComposeDate(xml, 'dataDate', TFhirDate(elem.data))
  else if (elem.data is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'dataDecimal', TFhirDecimal(elem.data))
  else if (elem.data is TFhirUri) {1} then
    ComposeUri(xml, 'dataUri', TFhirUri(elem.data))
  else if (elem.data is TFhirId) {1} then
    ComposeId(xml, 'dataId', TFhirId(elem.data))
  else if (elem.data is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'dataBase64Binary', TFhirBase64Binary(elem.data))
  else if (elem.data is TFhirOid) {1} then
    ComposeOid(xml, 'dataOid', TFhirOid(elem.data))
  else if (elem.data is TFhirString) {1} then
    ComposeString(xml, 'dataString', TFhirString(elem.data))
  else if (elem.data is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'dataBoolean', TFhirBoolean(elem.data))
  else if (elem.data is TFhirUuid) {1} then
    ComposeUuid(xml, 'dataUuid', TFhirUuid(elem.data))
  else if (elem.data is TFhirInstant) {1} then
    ComposeInstant(xml, 'dataInstant', TFhirInstant(elem.data))
  else if (elem.data is TFhirPeriod) {8} then
    ComposePeriod(xml, 'dataPeriod', TFhirPeriod(elem.data))
  else if (elem.data is TFhirCoding) {8} then
    ComposeCoding(xml, 'dataCoding', TFhirCoding(elem.data))
  else if (elem.data is TFhirRange) {8} then
    ComposeRange(xml, 'dataRange', TFhirRange(elem.data))
  else if (elem.data is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'dataQuantity', TFhirQuantity(elem.data))
  else if (elem.data is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'dataAttachment', TFhirAttachment(elem.data))
  else if (elem.data is TFhirRatio) {8} then
    ComposeRatio(xml, 'dataRatio', TFhirRatio(elem.data))
  else if (elem.data is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'dataSampledData', TFhirSampledData(elem.data))
  else if (elem.data is TFhirResourceReference) {8} then
    ComposeResourceReference(xml, 'dataResource', TFhirResourceReference(elem.data))
  else if (elem.data is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'dataCodeableConcept', TFhirCodeableConcept(elem.data))
  else if (elem.data is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'dataIdentifier', TFhirIdentifier(elem.data))
  else if (elem.data is TFhirSchedule) {9} then
    ComposeSchedule(xml, 'dataSchedule', TFhirSchedule(elem.data))
  else if (elem.data is TFhirContact) {9} then
    ComposeContact(xml, 'dataContact', TFhirContact(elem.data))
  else if (elem.data is TFhirAddress) {9} then
    ComposeAddress(xml, 'dataAddress', TFhirAddress(elem.data))
  else if (elem.data is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'dataHumanName', TFhirHumanName(elem.data));
  ComposeString(xml, 'remarks', elem.remarks);
  for i := 0 to elem.groupList.Count - 1 do
    ComposeQuestionnaireGroup(xml, 'group', elem.groupList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuestionnaireGroupQuestion(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireGroupQuestion(jsn));
end;

function TFHIRJsonParser.ParseQuestionnaireGroupQuestion(jsn : TJsonObject) : TFhirQuestionnaireGroupQuestion;
begin
  result := TFhirQuestionnaireGroupQuestion.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') then
        result.name := ParseCodeableConcept(jsn.vObj['name']);{q}
    if jsn.has('text') or jsn.has('_text') then
        result.text := ParseString(jsn['text'], jsn.vObj['_text']);{q}
    if jsn.has('answerDecimal') or jsn.has('_answerDecimal') then
      result.answer := parseDecimal(jsn['answerDecimal'], jsn.vObj['_answerDecimal']);
    if jsn.has('answerInteger') or jsn.has('_answerInteger') then
      result.answer := parseInteger(jsn['answerInteger'], jsn.vObj['_answerInteger']);
    if jsn.has('answerBoolean') or jsn.has('_answerBoolean') then
      result.answer := parseBoolean(jsn['answerBoolean'], jsn.vObj['_answerBoolean']);
    if jsn.has('answerDate') or jsn.has('_answerDate') then
      result.answer := parseDate(jsn['answerDate'], jsn.vObj['_answerDate']);
    if jsn.has('answerString') or jsn.has('_answerString') then
      result.answer := parseString(jsn['answerString'], jsn.vObj['_answerString']);
    if jsn.has('answerDateTime') or jsn.has('_answerDateTime') then
      result.answer := parseDateTime(jsn['answerDateTime'], jsn.vObj['_answerDateTime']);
    if jsn.has('answerInstant') or jsn.has('_answerInstant') then
      result.answer := parseInstant(jsn['answerInstant'], jsn.vObj['_answerInstant']);
    if jsn.has('choice') then
      iterateArray(jsn.vArr['choice'], result.choiceList, parseCoding);
    if jsn.has('options') then
        result.options := ParseResourceReference{TFhirValueSet}(jsn.vObj['options']);{q}
    if jsn.has('dataInteger') or jsn.has('_dataInteger') then
        result.data := ParseInteger(jsn['dataInteger'], jsn.vObj['_dataInteger']);
    if jsn.has('dataDateTime') or jsn.has('_dataDateTime') then
        result.data := ParseDateTime(jsn['dataDateTime'], jsn.vObj['_dataDateTime']);
    if jsn.has('dataCode') or jsn.has('_dataCode') then
        result.data := ParseCode(jsn['dataCode'], jsn.vObj['_dataCode']);
    if jsn.has('dataDate') or jsn.has('_dataDate') then
        result.data := ParseDate(jsn['dataDate'], jsn.vObj['_dataDate']);
    if jsn.has('dataDecimal') or jsn.has('_dataDecimal') then
        result.data := ParseDecimal(jsn['dataDecimal'], jsn.vObj['_dataDecimal']);
    if jsn.has('dataUri') or jsn.has('_dataUri') then
        result.data := ParseUri(jsn['dataUri'], jsn.vObj['_dataUri']);
    if jsn.has('dataId') or jsn.has('_dataId') then
        result.data := ParseId(jsn['dataId'], jsn.vObj['_dataId']);
    if jsn.has('dataBase64Binary') or jsn.has('_dataBase64Binary') then
        result.data := ParseBase64Binary(jsn['dataBase64Binary'], jsn.vObj['_dataBase64Binary']);
    if jsn.has('dataOid') or jsn.has('_dataOid') then
        result.data := ParseOid(jsn['dataOid'], jsn.vObj['_dataOid']);
    if jsn.has('dataString') or jsn.has('_dataString') then
        result.data := ParseString(jsn['dataString'], jsn.vObj['_dataString']);
    if jsn.has('dataBoolean') or jsn.has('_dataBoolean') then
        result.data := ParseBoolean(jsn['dataBoolean'], jsn.vObj['_dataBoolean']);
    if jsn.has('dataUuid') or jsn.has('_dataUuid') then
        result.data := ParseUuid(jsn['dataUuid'], jsn.vObj['_dataUuid']);
    if jsn.has('dataInstant') or jsn.has('_dataInstant') then
        result.data := ParseInstant(jsn['dataInstant'], jsn.vObj['_dataInstant']);
    if jsn.has('dataPeriod') {a7} then
        result.data := ParsePeriod(jsn.vObj['dataPeriod']);
    if jsn.has('dataCoding') {a7} then
        result.data := ParseCoding(jsn.vObj['dataCoding']);
    if jsn.has('dataRange') {a7} then
        result.data := ParseRange(jsn.vObj['dataRange']);
    if jsn.has('dataQuantity') {a7} then
        result.data := ParseQuantity(jsn.vObj['dataQuantity']);
    if jsn.has('dataAttachment') {a7} then
        result.data := ParseAttachment(jsn.vObj['dataAttachment']);
    if jsn.has('dataRatio') {a7} then
        result.data := ParseRatio(jsn.vObj['dataRatio']);
    if jsn.has('dataSampledData') {a7} then
        result.data := ParseSampledData(jsn.vObj['dataSampledData']);
    if jsn.has('dataResource') {a6} then
        result.data := ParseResourceReference(jsn.vObj['dataResource']);
    if jsn.has('dataCodeableConcept') {a7} then
        result.data := ParseCodeableConcept(jsn.vObj['dataCodeableConcept']);
    if jsn.has('dataIdentifier') {a7} then
        result.data := ParseIdentifier(jsn.vObj['dataIdentifier']);
    if jsn.has('dataSchedule') {a9} then
        result.data := ParseSchedule(jsn.vObj['dataSchedule']);
    if jsn.has('dataContact') {a9} then
        result.data := ParseContact(jsn.vObj['dataContact']);
    if jsn.has('dataAddress') {a9} then
        result.data := ParseAddress(jsn.vObj['dataAddress']);
    if jsn.has('dataHumanName') {a9} then
        result.data := ParseHumanName(jsn.vObj['dataHumanName']);
    if jsn.has('remarks') or jsn.has('_remarks') then
        result.remarks := ParseString(jsn['remarks'], jsn.vObj['_remarks']);{q}
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseQuestionnaireGroup);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireGroupQuestion(json : TJSONWriter; name : string; elem : TFhirQuestionnaireGroupQuestion);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'name', elem.name); {a}
  ComposeStringValue(json, 'text', elem.text, false);
  ComposeStringProps(json, 'text', elem.text, false);
  if (elem.answer is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'answerDecimal', TFhirDecimal(elem.answer), false);
    ComposeDecimalProps(json, 'answerDecimal', TFhirDecimal(elem.answer), false);
  end
  else if (elem.answer is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'answerInteger', TFhirInteger(elem.answer), false);
    ComposeIntegerProps(json, 'answerInteger', TFhirInteger(elem.answer), false);
  end
  else if (elem.answer is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'answerBoolean', TFhirBoolean(elem.answer), false);
    ComposeBooleanProps(json, 'answerBoolean', TFhirBoolean(elem.answer), false);
  end
  else if (elem.answer is TFhirDate) then 
  begin
    ComposeDateValue(json, 'answerDate', TFhirDate(elem.answer), false);
    ComposeDateProps(json, 'answerDate', TFhirDate(elem.answer), false);
  end
  else if (elem.answer is TFhirString) then 
  begin
    ComposeStringValue(json, 'answerString', TFhirString(elem.answer), false);
    ComposeStringProps(json, 'answerString', TFhirString(elem.answer), false);
  end
  else if (elem.answer is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'answerDateTime', TFhirDateTime(elem.answer), false);
    ComposeDateTimeProps(json, 'answerDateTime', TFhirDateTime(elem.answer), false);
  end
  else if (elem.answer is TFhirInstant) then 
  begin
    ComposeInstantValue(json, 'answerInstant', TFhirInstant(elem.answer), false);
    ComposeInstantProps(json, 'answerInstant', TFhirInstant(elem.answer), false);
  end;
  if elem.choiceList.Count > 0 then
  begin
    json.valueArray('choice');
    for i := 0 to elem.choiceList.Count - 1 do
      ComposeCoding(json, '',elem.choiceList[i]); {z - Coding}
    json.FinishArray;
  end;
  ComposeResourceReference{TFhirValueSet}(json, 'options', elem.options); {a}
  if (elem.data is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'dataInteger', TFhirInteger(elem.data), false);
    ComposeIntegerProps(json, 'dataInteger', TFhirInteger(elem.data), false)
  end
  else if (elem.data is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'dataDateTime', TFhirDateTime(elem.data), false);
    ComposeDateTimeProps(json, 'dataDateTime', TFhirDateTime(elem.data), false)
  end
  else if (elem.data is TFhirCode) then
  begin
    ComposeCodeValue(json, 'dataCode', TFhirCode(elem.data), false);
    ComposeCodeProps(json, 'dataCode', TFhirCode(elem.data), false)
  end
  else if (elem.data is TFhirDate) then
  begin
    ComposeDateValue(json, 'dataDate', TFhirDate(elem.data), false);
    ComposeDateProps(json, 'dataDate', TFhirDate(elem.data), false)
  end
  else if (elem.data is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'dataDecimal', TFhirDecimal(elem.data), false);
    ComposeDecimalProps(json, 'dataDecimal', TFhirDecimal(elem.data), false)
  end
  else if (elem.data is TFhirUri) then
  begin
    ComposeUriValue(json, 'dataUri', TFhirUri(elem.data), false);
    ComposeUriProps(json, 'dataUri', TFhirUri(elem.data), false)
  end
  else if (elem.data is TFhirId) then
  begin
    ComposeIdValue(json, 'dataId', TFhirId(elem.data), false);
    ComposeIdProps(json, 'dataId', TFhirId(elem.data), false)
  end
  else if (elem.data is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'dataBase64Binary', TFhirBase64Binary(elem.data), false);
    ComposeBase64BinaryProps(json, 'dataBase64Binary', TFhirBase64Binary(elem.data), false)
  end
  else if (elem.data is TFhirOid) then
  begin
    ComposeOidValue(json, 'dataOid', TFhirOid(elem.data), false);
    ComposeOidProps(json, 'dataOid', TFhirOid(elem.data), false)
  end
  else if (elem.data is TFhirString) then
  begin
    ComposeStringValue(json, 'dataString', TFhirString(elem.data), false);
    ComposeStringProps(json, 'dataString', TFhirString(elem.data), false)
  end
  else if (elem.data is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'dataBoolean', TFhirBoolean(elem.data), false);
    ComposeBooleanProps(json, 'dataBoolean', TFhirBoolean(elem.data), false)
  end
  else if (elem.data is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'dataUuid', TFhirUuid(elem.data), false);
    ComposeUuidProps(json, 'dataUuid', TFhirUuid(elem.data), false)
  end
  else if (elem.data is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'dataInstant', TFhirInstant(elem.data), false);
    ComposeInstantProps(json, 'dataInstant', TFhirInstant(elem.data), false)
  end
  else if (elem.data is TFhirPeriod) then
    ComposePeriod(json, 'dataPeriod', TFhirPeriod(elem.data))
  else if (elem.data is TFhirCoding) then
    ComposeCoding(json, 'dataCoding', TFhirCoding(elem.data))
  else if (elem.data is TFhirRange) then
    ComposeRange(json, 'dataRange', TFhirRange(elem.data))
  else if (elem.data is TFhirQuantity) then
    ComposeQuantity(json, 'dataQuantity', TFhirQuantity(elem.data))
  else if (elem.data is TFhirAttachment) then
    ComposeAttachment(json, 'dataAttachment', TFhirAttachment(elem.data))
  else if (elem.data is TFhirRatio) then
    ComposeRatio(json, 'dataRatio', TFhirRatio(elem.data))
  else if (elem.data is TFhirSampledData) then
    ComposeSampledData(json, 'dataSampledData', TFhirSampledData(elem.data))
  else if (elem.data is TFhirResourceReference) then
    ComposeResourceReference(json, 'dataResource', TFhirResourceReference(elem.data))
  else if (elem.data is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'dataCodeableConcept', TFhirCodeableConcept(elem.data))
  else if (elem.data is TFhirIdentifier) then
    ComposeIdentifier(json, 'dataIdentifier', TFhirIdentifier(elem.data))
  else if (elem.data is TFhirSchedule) then
    ComposeSchedule(json, 'dataSchedule', TFhirSchedule(elem.data))
  else if (elem.data is TFhirContact) then
    ComposeContact(json, 'dataContact', TFhirContact(elem.data))
  else if (elem.data is TFhirAddress) then
    ComposeAddress(json, 'dataAddress', TFhirAddress(elem.data))
  else if (elem.data is TFhirHumanName) then
    ComposeHumanName(json, 'dataHumanName', TFhirHumanName(elem.data));
  ComposeStringValue(json, 'remarks', elem.remarks, false);
  ComposeStringProps(json, 'remarks', elem.remarks, false);
  if elem.groupList.Count > 0 then
  begin
    json.valueArray('group');
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireGroup(json, '',elem.groupList[i]); {z - @Questionnaire.group}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseQuestionnaire(element : IXmlDomElement; path : string) : TFhirQuestionnaire;
var
  child : IXMLDOMElement;
begin
  result := TFhirQuestionnaire.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirQuestionnaireStatus, path+'/status', child)
      else if (child.baseName = 'authored') then
        result.authored := ParseDateTime(child, path+'/authored') {b}
      else if (child.baseName = 'subject') then
        result.subject := ParseResourceReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'author') then
        result.author := ParseResourceReference{Resource}(child, path+'/author') {b}
      else if (child.baseName = 'source') then
        result.source := ParseResourceReference{Resource}(child, path+'/source') {b}
      else if (child.baseName = 'name') then
        result.name := ParseCodeableConcept(child, path+'/name') {b}
      else if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'encounter') then
        result.encounter := ParseResourceReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.baseName = 'group') then
        result.group := ParseQuestionnaireGroup(child, path+'/group') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaire(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaire);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirQuestionnaireStatus);
  ComposeDateTime(xml, 'authored', elem.authored);
  ComposeResourceReference{Resource}(xml, 'subject', elem.subject);
  ComposeResourceReference{Resource}(xml, 'author', elem.author);
  ComposeResourceReference{Resource}(xml, 'source', elem.source);
  ComposeCodeableConcept(xml, 'name', elem.name);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeResourceReference{TFhirEncounter}(xml, 'encounter', elem.encounter);
  if not SummaryOnly then
    ComposeQuestionnaireGroup(xml, 'group', elem.group);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseQuestionnaire(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaire(jsn));
end;

function TFHIRJsonParser.ParseQuestionnaire(jsn : TJsonObject) : TFhirQuestionnaire;
begin
  result := TFhirQuestionnaire.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirQuestionnaireStatus);
    if jsn.has('authored') or jsn.has('_authored') then
        result.authored := ParseDateTime(jsn['authored'], jsn.vObj['_authored']);{q}
    if jsn.has('subject') then
        result.subject := ParseResourceReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('author') then
        result.author := ParseResourceReference{Resource}(jsn.vObj['author']);{q}
    if jsn.has('source') then
        result.source := ParseResourceReference{Resource}(jsn.vObj['source']);{q}
    if jsn.has('name') then
        result.name := ParseCodeableConcept(jsn.vObj['name']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('encounter') then
        result.encounter := ParseResourceReference{TFhirEncounter}(jsn.vObj['encounter']);{q}
    if jsn.has('group') then
        result.group := ParseQuestionnaireGroup(jsn.vObj['group']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeQuestionnaire(json : TJSONWriter; name : string; elem : TFhirQuestionnaire);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirQuestionnaireStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirQuestionnaireStatus, false);
  ComposeDateTimeValue(json, 'authored', elem.authored, false);
  ComposeDateTimeProps(json, 'authored', elem.authored, false);
  ComposeResourceReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeResourceReference{Resource}(json, 'author', elem.author); {a}
  ComposeResourceReference{Resource}(json, 'source', elem.source); {a}
  ComposeCodeableConcept(json, 'name', elem.name); {a}
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeResourceReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if not SummaryOnly then
    ComposeQuestionnaireGroup(json, 'group', elem.group); {a}
end;

function TFHIRXmlParser.ParseRelatedPerson(element : IXmlDomElement; path : string) : TFhirRelatedPerson;
var
  child : IXMLDOMElement;
begin
  result := TFhirRelatedPerson.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'patient') then
        result.patient := ParseResourceReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'relationship') then
        result.relationship := ParseCodeableConcept(child, path+'/relationship') {b}
      else if (child.baseName = 'name') then
        result.name := ParseHumanName(child, path+'/name') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContact(child, path+'/telecom'))
      else if (child.baseName = 'gender') then
        result.gender := ParseCodeableConcept(child, path+'/gender') {b}
      else if (child.baseName = 'address') then
        result.address := ParseAddress(child, path+'/address') {b}
      else if (child.baseName = 'photo') then
        result.photoList.Add(ParseAttachment(child, path+'/photo'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeRelatedPerson(xml : TXmlBuilder; name : string; elem : TFhirRelatedPerson);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeResourceReference{TFhirPatient}(xml, 'patient', elem.patient);
  ComposeCodeableConcept(xml, 'relationship', elem.relationship);
  ComposeHumanName(xml, 'name', elem.name);
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContact(xml, 'telecom', elem.telecomList[i]);
  ComposeCodeableConcept(xml, 'gender', elem.gender);
  ComposeAddress(xml, 'address', elem.address);
  if not SummaryOnly then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(xml, 'photo', elem.photoList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseRelatedPerson(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRelatedPerson(jsn));
end;

function TFHIRJsonParser.ParseRelatedPerson(jsn : TJsonObject) : TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('patient') then
        result.patient := ParseResourceReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('relationship') then
        result.relationship := ParseCodeableConcept(jsn.vObj['relationship']);{q}
    if jsn.has('name') then
        result.name := ParseHumanName(jsn.vObj['name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContact);
    if jsn.has('gender') then
        result.gender := ParseCodeableConcept(jsn.vObj['gender']);{q}
    if jsn.has('address') then
        result.address := ParseAddress(jsn.vObj['address']);{q}
    if jsn.has('photo') then
      iterateArray(jsn.vArr['photo'], result.photoList, parseAttachment);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeRelatedPerson(json : TJSONWriter; name : string; elem : TFhirRelatedPerson);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeResourceReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeCodeableConcept(json, 'relationship', elem.relationship); {a}
  ComposeHumanName(json, 'name', elem.name); {a}
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContact(json, '',elem.telecomList[i]); {z - Contact}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'gender', elem.gender); {a}
  ComposeAddress(json, 'address', elem.address); {a}
  if not SummaryOnly and (elem.photoList.Count > 0) then
  begin
    json.valueArray('photo');
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(json, '',elem.photoList[i]); {z - Attachment}
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseSecurityEventEvent(element : IXmlDomElement; path : string) : TFhirSecurityEventEvent;
var
  child : IXMLDOMElement;
begin
  result := TFhirSecurityEventEvent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'subtype') then
        result.subtypeList.Add(ParseCodeableConcept(child, path+'/subtype'))
      else if (child.baseName = 'action') then
        result.action := ParseEnum(CODES_TFhirSecurityEventAction, path+'/action', child)
      else if (child.baseName = 'dateTime') then
        result.dateTime := ParseInstant(child, path+'/dateTime') {b}
      else if (child.baseName = 'outcome') then
        result.outcome := ParseEnum(CODES_TFhirSecurityEventOutcome, path+'/outcome', child)
      else if (child.baseName = 'outcomeDesc') then
        result.outcomeDesc := ParseString(child, path+'/outcomeDesc') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSecurityEventEvent(xml : TXmlBuilder; name : string; elem : TFhirSecurityEventEvent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);
  for i := 0 to elem.subtypeList.Count - 1 do
    ComposeCodeableConcept(xml, 'subtype', elem.subtypeList[i]);
  ComposeEnum(xml, 'action', elem.Action, CODES_TFhirSecurityEventAction);
  ComposeInstant(xml, 'dateTime', elem.dateTime);
  ComposeEnum(xml, 'outcome', elem.Outcome, CODES_TFhirSecurityEventOutcome);
  ComposeString(xml, 'outcomeDesc', elem.outcomeDesc);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSecurityEventEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSecurityEventEvent(jsn));
end;

function TFHIRJsonParser.ParseSecurityEventEvent(jsn : TJsonObject) : TFhirSecurityEventEvent;
begin
  result := TFhirSecurityEventEvent.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('subtype') then
      iterateArray(jsn.vArr['subtype'], result.subtypeList, parseCodeableConcept);
    if jsn.has('action') or jsn.has('_action')  then
      result.action := parseEnum(jsn['action'], jsn.vObj['_action'], CODES_TFhirSecurityEventAction);
    if jsn.has('dateTime') or jsn.has('_dateTime') then
        result.dateTime := ParseInstant(jsn['dateTime'], jsn.vObj['_dateTime']);{q}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcome := parseEnum(jsn['outcome'], jsn.vObj['_outcome'], CODES_TFhirSecurityEventOutcome);
    if jsn.has('outcomeDesc') or jsn.has('_outcomeDesc') then
        result.outcomeDesc := ParseString(jsn['outcomeDesc'], jsn.vObj['_outcomeDesc']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSecurityEventEvent(json : TJSONWriter; name : string; elem : TFhirSecurityEventEvent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if elem.subtypeList.Count > 0 then
  begin
    json.valueArray('subtype');
    for i := 0 to elem.subtypeList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.subtypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'action', elem.Action, CODES_TFhirSecurityEventAction, false);
  ComposeEnumProps(json, 'action', elem.Action, CODES_TFhirSecurityEventAction, false);
  ComposeInstantValue(json, 'dateTime', elem.dateTime, false);
  ComposeInstantProps(json, 'dateTime', elem.dateTime, false);
  ComposeEnumValue(json, 'outcome', elem.Outcome, CODES_TFhirSecurityEventOutcome, false);
  ComposeEnumProps(json, 'outcome', elem.Outcome, CODES_TFhirSecurityEventOutcome, false);
  ComposeStringValue(json, 'outcomeDesc', elem.outcomeDesc, false);
  ComposeStringProps(json, 'outcomeDesc', elem.outcomeDesc, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseSecurityEventParticipant(element : IXmlDomElement; path : string) : TFhirSecurityEventParticipant;
var
  child : IXMLDOMElement;
begin
  result := TFhirSecurityEventParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'role') then
        result.roleList.Add(ParseCodeableConcept(child, path+'/role'))
      else if (child.baseName = 'reference') then
        result.reference := ParseResourceReference{Resource}(child, path+'/reference') {b}
      else if (child.baseName = 'userId') then
        result.userId := ParseString(child, path+'/userId') {b}
      else if (child.baseName = 'altId') then
        result.altId := ParseString(child, path+'/altId') {b}
      else if (child.baseName = 'name') then
        result.name := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'requestor') then
        result.requestor := ParseBoolean(child, path+'/requestor') {b}
      else if (child.baseName = 'media') then
        result.media := ParseCoding(child, path+'/media') {b}
      else if (child.baseName = 'network') then
        result.network := ParseSecurityEventParticipantNetwork(child, path+'/network') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSecurityEventParticipant(xml : TXmlBuilder; name : string; elem : TFhirSecurityEventParticipant);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.roleList.Count - 1 do
    ComposeCodeableConcept(xml, 'role', elem.roleList[i]);
  ComposeResourceReference{Resource}(xml, 'reference', elem.reference);
  ComposeString(xml, 'userId', elem.userId);
  ComposeString(xml, 'altId', elem.altId);
  ComposeString(xml, 'name', elem.name);
  ComposeBoolean(xml, 'requestor', elem.requestor);
  ComposeCoding(xml, 'media', elem.media);
  ComposeSecurityEventParticipantNetwork(xml, 'network', elem.network);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSecurityEventParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSecurityEventParticipant(jsn));
end;

function TFHIRJsonParser.ParseSecurityEventParticipant(jsn : TJsonObject) : TFhirSecurityEventParticipant;
begin
  result := TFhirSecurityEventParticipant.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') then
      iterateArray(jsn.vArr['role'], result.roleList, parseCodeableConcept);
    if jsn.has('reference') then
        result.reference := ParseResourceReference{Resource}(jsn.vObj['reference']);{q}
    if jsn.has('userId') or jsn.has('_userId') then
        result.userId := ParseString(jsn['userId'], jsn.vObj['_userId']);{q}
    if jsn.has('altId') or jsn.has('_altId') then
        result.altId := ParseString(jsn['altId'], jsn.vObj['_altId']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.name := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('requestor') or jsn.has('_requestor') then
        result.requestor := ParseBoolean(jsn['requestor'], jsn.vObj['_requestor']);{q}
    if jsn.has('media') then
        result.media := ParseCoding(jsn.vObj['media']);{q}
    if jsn.has('network') then
        result.network := ParseSecurityEventParticipantNetwork(jsn.vObj['network']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSecurityEventParticipant(json : TJSONWriter; name : string; elem : TFhirSecurityEventParticipant);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.roleList.Count > 0 then
  begin
    json.valueArray('role');
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(json, '',elem.roleList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeResourceReference{Resource}(json, 'reference', elem.reference); {a}
  ComposeStringValue(json, 'userId', elem.userId, false);
  ComposeStringProps(json, 'userId', elem.userId, false);
  ComposeStringValue(json, 'altId', elem.altId, false);
  ComposeStringProps(json, 'altId', elem.altId, false);
  ComposeStringValue(json, 'name', elem.name, false);
  ComposeStringProps(json, 'name', elem.name, false);
  ComposeBooleanValue(json, 'requestor', elem.requestor, false);
  ComposeBooleanProps(json, 'requestor', elem.requestor, false);
  ComposeCoding(json, 'media', elem.media); {a}
  ComposeSecurityEventParticipantNetwork(json, 'network', elem.network); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseSecurityEventParticipantNetwork(element : IXmlDomElement; path : string) : TFhirSecurityEventParticipantNetwork;
var
  child : IXMLDOMElement;
begin
  result := TFhirSecurityEventParticipantNetwork.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseString(child, path+'/identifier') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseEnum(CODES_TFhirNetworkType, path+'/type', child)
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSecurityEventParticipantNetwork(xml : TXmlBuilder; name : string; elem : TFhirSecurityEventParticipantNetwork);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'identifier', elem.identifier);
  ComposeEnum(xml, 'type', elem.Type_, CODES_TFhirNetworkType);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSecurityEventParticipantNetwork(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSecurityEventParticipantNetwork(jsn));
end;

function TFHIRJsonParser.ParseSecurityEventParticipantNetwork(jsn : TJsonObject) : TFhirSecurityEventParticipantNetwork;
begin
  result := TFhirSecurityEventParticipantNetwork.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifier := ParseString(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_ := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirNetworkType);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSecurityEventParticipantNetwork(json : TJSONWriter; name : string; elem : TFhirSecurityEventParticipantNetwork);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'identifier', elem.identifier, false);
  ComposeStringProps(json, 'identifier', elem.identifier, false);
  ComposeEnumValue(json, 'type', elem.Type_, CODES_TFhirNetworkType, false);
  ComposeEnumProps(json, 'type', elem.Type_, CODES_TFhirNetworkType, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseSecurityEventSource(element : IXmlDomElement; path : string) : TFhirSecurityEventSource;
var
  child : IXMLDOMElement;
begin
  result := TFhirSecurityEventSource.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'site') then
        result.site := ParseString(child, path+'/site') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseString(child, path+'/identifier') {b}
      else if (child.baseName = 'type') then
        result.type_List.Add(ParseCoding(child, path+'/type'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSecurityEventSource(xml : TXmlBuilder; name : string; elem : TFhirSecurityEventSource);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'site', elem.site);
  ComposeString(xml, 'identifier', elem.identifier);
  for i := 0 to elem.type_List.Count - 1 do
    ComposeCoding(xml, 'type', elem.type_List[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSecurityEventSource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSecurityEventSource(jsn));
end;

function TFHIRJsonParser.ParseSecurityEventSource(jsn : TJsonObject) : TFhirSecurityEventSource;
begin
  result := TFhirSecurityEventSource.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('site') or jsn.has('_site') then
        result.site := ParseString(jsn['site'], jsn.vObj['_site']);{q}
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifier := ParseString(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCoding);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSecurityEventSource(json : TJSONWriter; name : string; elem : TFhirSecurityEventSource);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'site', elem.site, false);
  ComposeStringProps(json, 'site', elem.site, false);
  ComposeStringValue(json, 'identifier', elem.identifier, false);
  ComposeStringProps(json, 'identifier', elem.identifier, false);
  if elem.type_List.Count > 0 then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCoding(json, '',elem.type_List[i]); {z - Coding}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseSecurityEventObject(element : IXmlDomElement; path : string) : TFhirSecurityEventObject;
var
  child : IXMLDOMElement;
begin
  result := TFhirSecurityEventObject.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'reference') then
        result.reference := ParseResourceReference{Resource}(child, path+'/reference') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseEnum(CODES_TFhirObjectType, path+'/type', child)
      else if (child.baseName = 'role') then
        result.role := ParseEnum(CODES_TFhirObjectRole, path+'/role', child)
      else if (child.baseName = 'lifecycle') then
        result.lifecycle := ParseEnum(CODES_TFhirObjectLifecycle, path+'/lifecycle', child)
      else if (child.baseName = 'sensitivity') then
        result.sensitivity := ParseCodeableConcept(child, path+'/sensitivity') {b}
      else if (child.baseName = 'name') then
        result.name := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'description') then
        result.description := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'query') then
        result.query := ParseBase64Binary(child, path+'/query') {b}
      else if (child.baseName = 'detail') then
        result.detailList.Add(ParseSecurityEventObjectDetail(child, path+'/detail'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSecurityEventObject(xml : TXmlBuilder; name : string; elem : TFhirSecurityEventObject);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);
  ComposeResourceReference{Resource}(xml, 'reference', elem.reference);
  ComposeEnum(xml, 'type', elem.Type_, CODES_TFhirObjectType);
  ComposeEnum(xml, 'role', elem.Role, CODES_TFhirObjectRole);
  ComposeEnum(xml, 'lifecycle', elem.Lifecycle, CODES_TFhirObjectLifecycle);
  ComposeCodeableConcept(xml, 'sensitivity', elem.sensitivity);
  ComposeString(xml, 'name', elem.name);
  ComposeString(xml, 'description', elem.description);
  ComposeBase64Binary(xml, 'query', elem.query);
  for i := 0 to elem.detailList.Count - 1 do
    ComposeSecurityEventObjectDetail(xml, 'detail', elem.detailList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSecurityEventObject(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSecurityEventObject(jsn));
end;

function TFHIRJsonParser.ParseSecurityEventObject(jsn : TJsonObject) : TFhirSecurityEventObject;
begin
  result := TFhirSecurityEventObject.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('reference') then
        result.reference := ParseResourceReference{Resource}(jsn.vObj['reference']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_ := parseEnum(jsn['type'], jsn.vObj['_type'], CODES_TFhirObjectType);
    if jsn.has('role') or jsn.has('_role')  then
      result.role := parseEnum(jsn['role'], jsn.vObj['_role'], CODES_TFhirObjectRole);
    if jsn.has('lifecycle') or jsn.has('_lifecycle')  then
      result.lifecycle := parseEnum(jsn['lifecycle'], jsn.vObj['_lifecycle'], CODES_TFhirObjectLifecycle);
    if jsn.has('sensitivity') then
        result.sensitivity := ParseCodeableConcept(jsn.vObj['sensitivity']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.name := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.description := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('query') or jsn.has('_query') then
        result.query := ParseBase64Binary(jsn['query'], jsn.vObj['_query']);{q}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseSecurityEventObjectDetail);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSecurityEventObject(json : TJSONWriter; name : string; elem : TFhirSecurityEventObject);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeResourceReference{Resource}(json, 'reference', elem.reference); {a}
  ComposeEnumValue(json, 'type', elem.Type_, CODES_TFhirObjectType, false);
  ComposeEnumProps(json, 'type', elem.Type_, CODES_TFhirObjectType, false);
  ComposeEnumValue(json, 'role', elem.Role, CODES_TFhirObjectRole, false);
  ComposeEnumProps(json, 'role', elem.Role, CODES_TFhirObjectRole, false);
  ComposeEnumValue(json, 'lifecycle', elem.Lifecycle, CODES_TFhirObjectLifecycle, false);
  ComposeEnumProps(json, 'lifecycle', elem.Lifecycle, CODES_TFhirObjectLifecycle, false);
  ComposeCodeableConcept(json, 'sensitivity', elem.sensitivity); {a}
  ComposeStringValue(json, 'name', elem.name, false);
  ComposeStringProps(json, 'name', elem.name, false);
  ComposeStringValue(json, 'description', elem.description, false);
  ComposeStringProps(json, 'description', elem.description, false);
  ComposeBase64BinaryValue(json, 'query', elem.query, false);
  ComposeBase64BinaryProps(json, 'query', elem.query, false);
  if elem.detailList.Count > 0 then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeSecurityEventObjectDetail(json, '',elem.detailList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseSecurityEventObjectDetail(element : IXmlDomElement; path : string) : TFhirSecurityEventObjectDetail;
var
  child : IXMLDOMElement;
begin
  result := TFhirSecurityEventObjectDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseString(child, path+'/type') {b}
      else if (child.baseName = 'value') then
        result.value := ParseBase64Binary(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSecurityEventObjectDetail(xml : TXmlBuilder; name : string; elem : TFhirSecurityEventObjectDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'type', elem.type_);
  ComposeBase64Binary(xml, 'value', elem.value);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSecurityEventObjectDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSecurityEventObjectDetail(jsn));
end;

function TFHIRJsonParser.ParseSecurityEventObjectDetail(jsn : TJsonObject) : TFhirSecurityEventObjectDetail;
begin
  result := TFhirSecurityEventObjectDetail.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type') then
        result.type_ := ParseString(jsn['type'], jsn.vObj['_type']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.value := ParseBase64Binary(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSecurityEventObjectDetail(json : TJSONWriter; name : string; elem : TFhirSecurityEventObjectDetail);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'type', elem.type_, false);
  ComposeStringProps(json, 'type', elem.type_, false);
  ComposeBase64BinaryValue(json, 'value', elem.value, false);
  ComposeBase64BinaryProps(json, 'value', elem.value, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseSecurityEvent(element : IXmlDomElement; path : string) : TFhirSecurityEvent;
var
  child : IXMLDOMElement;
begin
  result := TFhirSecurityEvent.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'event') then
        result.event := ParseSecurityEventEvent(child, path+'/event') {b}
      else if (child.baseName = 'participant') then
        result.participantList.Add(ParseSecurityEventParticipant(child, path+'/participant'))
      else if (child.baseName = 'source') then
        result.source := ParseSecurityEventSource(child, path+'/source') {b}
      else if (child.baseName = 'object') then
        result.object_List.Add(ParseSecurityEventObject(child, path+'/object'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSecurityEvent(xml : TXmlBuilder; name : string; elem : TFhirSecurityEvent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeSecurityEventEvent(xml, 'event', elem.event);
  for i := 0 to elem.participantList.Count - 1 do
    ComposeSecurityEventParticipant(xml, 'participant', elem.participantList[i]);
  ComposeSecurityEventSource(xml, 'source', elem.source);
  for i := 0 to elem.object_List.Count - 1 do
    ComposeSecurityEventObject(xml, 'object', elem.object_List[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSecurityEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSecurityEvent(jsn));
end;

function TFHIRJsonParser.ParseSecurityEvent(jsn : TJsonObject) : TFhirSecurityEvent;
begin
  result := TFhirSecurityEvent.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('event') then
        result.event := ParseSecurityEventEvent(jsn.vObj['event']);{q}
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseSecurityEventParticipant);
    if jsn.has('source') then
        result.source := ParseSecurityEventSource(jsn.vObj['source']);{q}
    if jsn.has('object') then
      iterateArray(jsn.vArr['object'], result.object_List, parseSecurityEventObject);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSecurityEvent(json : TJSONWriter; name : string; elem : TFhirSecurityEvent);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeSecurityEventEvent(json, 'event', elem.event); {a}
  if elem.participantList.Count > 0 then
  begin
    json.valueArray('participant');
    for i := 0 to elem.participantList.Count - 1 do
      ComposeSecurityEventParticipant(json, '',elem.participantList[i]); {z - }
    json.FinishArray;
  end;
  ComposeSecurityEventSource(json, 'source', elem.source); {a}
  if elem.object_List.Count > 0 then
  begin
    json.valueArray('object');
    for i := 0 to elem.object_List.Count - 1 do
      ComposeSecurityEventObject(json, '',elem.object_List[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseSpecimenSource(element : IXmlDomElement; path : string) : TFhirSpecimenSource;
var
  child : IXMLDOMElement;
begin
  result := TFhirSpecimenSource.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'relationship') then
        result.relationship := ParseEnum(CODES_TFhirHierarchicalRelationshipType, path+'/relationship', child)
      else if (child.baseName = 'target') then
        result.targetList.Add(ParseResourceReference{TFhirSpecimen}(child, path+'/target'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSpecimenSource(xml : TXmlBuilder; name : string; elem : TFhirSpecimenSource);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'relationship', elem.Relationship, CODES_TFhirHierarchicalRelationshipType);
  for i := 0 to elem.targetList.Count - 1 do
    ComposeResourceReference{TFhirSpecimen}(xml, 'target', elem.targetList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSpecimenSource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimenSource(jsn));
end;

function TFHIRJsonParser.ParseSpecimenSource(jsn : TJsonObject) : TFhirSpecimenSource;
begin
  result := TFhirSpecimenSource.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('relationship') or jsn.has('_relationship')  then
      result.relationship := parseEnum(jsn['relationship'], jsn.vObj['_relationship'], CODES_TFhirHierarchicalRelationshipType);
    if jsn.has('target') then
      iterateArray(jsn.vArr['target'], result.targetList, parseResourceReference{TFhirSpecimen});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSpecimenSource(json : TJSONWriter; name : string; elem : TFhirSpecimenSource);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'relationship', elem.Relationship, CODES_TFhirHierarchicalRelationshipType, false);
  ComposeEnumProps(json, 'relationship', elem.Relationship, CODES_TFhirHierarchicalRelationshipType, false);
  if elem.targetList.Count > 0 then
  begin
    json.valueArray('target');
    for i := 0 to elem.targetList.Count - 1 do
      ComposeResourceReference{TFhirSpecimen}(json, '',elem.targetList[i]); {z - Resource(Specimen)}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseSpecimenCollection(element : IXmlDomElement; path : string) : TFhirSpecimenCollection;
var
  child : IXMLDOMElement;
begin
  result := TFhirSpecimenCollection.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'collector') then
        result.collector := ParseResourceReference{TFhirPractitioner}(child, path+'/collector') {b}
      else if (child.baseName = 'comment') then
        result.commentList.Add(ParseString(child, path+'/comment'))
      else if (child.baseName = 'collectedDateTime') then
        result.collected := ParseDateTime(child, path+'/collectedDateTime')
      else if (child.baseName = 'collectedPeriod') then
        result.collected := ParsePeriod(child, path+'/collectedPeriod')
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'method') then
        result.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.baseName = 'sourceSite') then
        result.sourceSite := ParseCodeableConcept(child, path+'/sourceSite') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSpecimenCollection(xml : TXmlBuilder; name : string; elem : TFhirSpecimenCollection);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeResourceReference{TFhirPractitioner}(xml, 'collector', elem.collector);
  for i := 0 to elem.commentList.Count - 1 do
    ComposeString(xml, 'comment', elem.commentList[i]);
  if (elem.collected is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'collectedDateTime', TFhirDateTime(elem.collected))
  else if (elem.collected is TFhirPeriod) {6} then
    ComposePeriod(xml, 'collectedPeriod', TFhirPeriod(elem.collected));
  ComposeQuantity(xml, 'quantity', elem.quantity);
  ComposeCodeableConcept(xml, 'method', elem.method);
  ComposeCodeableConcept(xml, 'sourceSite', elem.sourceSite);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSpecimenCollection(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimenCollection(jsn));
end;

function TFHIRJsonParser.ParseSpecimenCollection(jsn : TJsonObject) : TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('collector') then
        result.collector := ParseResourceReference{TFhirPractitioner}(jsn.vObj['collector']);{q}
      if jsn.has('comment') or jsn.has('_comment') then
      iteratePrimitiveArray(jsn.vArr['comment'], jsn.vArr['_comment'], result.commentList, parseString);
    if jsn.has('collectedDateTime') or jsn.has('_collectedDateTime') then
      result.collected := parseDateTime(jsn['collectedDateTime'], jsn.vObj['_collectedDateTime']);
    if jsn.has('collectedPeriod') {a4} then
      result.collected := ParsePeriod(jsn.vObj['collectedPeriod']);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q}
    if jsn.has('sourceSite') then
        result.sourceSite := ParseCodeableConcept(jsn.vObj['sourceSite']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSpecimenCollection(json : TJSONWriter; name : string; elem : TFhirSpecimenCollection);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeResourceReference{TFhirPractitioner}(json, 'collector', elem.collector); {a}
  if elem.commentList.Count > 0 then
  begin
    json.valueArray('comment');
    ext := false;
    for i := 0 to elem.commentList.Count - 1 do
    begin
      ext := ext or ((elem.commentList[i].xmlid <> '') or (elem.commentList[i].hasExtensions));
      ComposeStringValue(json, '',elem.commentList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_comment');
      for i := 0 to elem.commentList.Count - 1 do
        ComposeStringProps(json, '',elem.commentList[i], true);
      json.FinishArray;
    end;
  end;
  if (elem.collected is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'collectedDateTime', TFhirDateTime(elem.collected), false);
    ComposeDateTimeProps(json, 'collectedDateTime', TFhirDateTime(elem.collected), false);
  end
  else if (elem.collected is TFhirPeriod) then 
    ComposePeriod(json, 'collectedPeriod', TFhirPeriod(elem.collected)) ;
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeCodeableConcept(json, 'method', elem.method); {a}
  ComposeCodeableConcept(json, 'sourceSite', elem.sourceSite); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseSpecimenTreatment(element : IXmlDomElement; path : string) : TFhirSpecimenTreatment;
var
  child : IXMLDOMElement;
begin
  result := TFhirSpecimenTreatment.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'description') then
        result.description := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'procedure') then
        result.procedure_ := ParseCodeableConcept(child, path+'/procedure') {b}
      else if (child.baseName = 'additive') then
        result.additiveList.Add(ParseResourceReference{TFhirSubstance}(child, path+'/additive'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSpecimenTreatment(xml : TXmlBuilder; name : string; elem : TFhirSpecimenTreatment);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'description', elem.description);
  ComposeCodeableConcept(xml, 'procedure', elem.procedure_);
  for i := 0 to elem.additiveList.Count - 1 do
    ComposeResourceReference{TFhirSubstance}(xml, 'additive', elem.additiveList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSpecimenTreatment(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimenTreatment(jsn));
end;

function TFHIRJsonParser.ParseSpecimenTreatment(jsn : TJsonObject) : TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.description := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('procedure') then
        result.procedure_ := ParseCodeableConcept(jsn.vObj['procedure']);{q}
    if jsn.has('additive') then
      iterateArray(jsn.vArr['additive'], result.additiveList, parseResourceReference{TFhirSubstance});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSpecimenTreatment(json : TJSONWriter; name : string; elem : TFhirSpecimenTreatment);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'description', elem.description, false);
  ComposeStringProps(json, 'description', elem.description, false);
  ComposeCodeableConcept(json, 'procedure', elem.procedure_); {a}
  if elem.additiveList.Count > 0 then
  begin
    json.valueArray('additive');
    for i := 0 to elem.additiveList.Count - 1 do
      ComposeResourceReference{TFhirSubstance}(json, '',elem.additiveList[i]); {z - Resource(Substance)}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseSpecimenContainer(element : IXmlDomElement; path : string) : TFhirSpecimenContainer;
var
  child : IXMLDOMElement;
begin
  result := TFhirSpecimenContainer.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'description') then
        result.description := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'capacity') then
        result.capacity := ParseQuantity(child, path+'/capacity') {b}
      else if (child.baseName = 'specimenQuantity') then
        result.specimenQuantity := ParseQuantity(child, path+'/specimenQuantity') {b}
      else if (child.baseName = 'additive') then
        result.additive := ParseResourceReference{TFhirSubstance}(child, path+'/additive') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSpecimenContainer(xml : TXmlBuilder; name : string; elem : TFhirSpecimenContainer);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeString(xml, 'description', elem.description);
  ComposeCodeableConcept(xml, 'type', elem.type_);
  ComposeQuantity(xml, 'capacity', elem.capacity);
  ComposeQuantity(xml, 'specimenQuantity', elem.specimenQuantity);
  ComposeResourceReference{TFhirSubstance}(xml, 'additive', elem.additive);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSpecimenContainer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimenContainer(jsn));
end;

function TFHIRJsonParser.ParseSpecimenContainer(jsn : TJsonObject) : TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('description') or jsn.has('_description') then
        result.description := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('capacity') then
        result.capacity := ParseQuantity(jsn.vObj['capacity']);{q}
    if jsn.has('specimenQuantity') then
        result.specimenQuantity := ParseQuantity(jsn.vObj['specimenQuantity']);{q}
    if jsn.has('additive') then
        result.additive := ParseResourceReference{TFhirSubstance}(jsn.vObj['additive']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSpecimenContainer(json : TJSONWriter; name : string; elem : TFhirSpecimenContainer);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.description, false);
  ComposeStringProps(json, 'description', elem.description, false);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeQuantity(json, 'capacity', elem.capacity); {a}
  ComposeQuantity(json, 'specimenQuantity', elem.specimenQuantity); {a}
  ComposeResourceReference{TFhirSubstance}(json, 'additive', elem.additive); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseSpecimen(element : IXmlDomElement; path : string) : TFhirSpecimen;
var
  child : IXMLDOMElement;
begin
  result := TFhirSpecimen.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifierList.Add(ParseIdentifier(child, path+'/identifier'))
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'source') then
        result.sourceList.Add(ParseSpecimenSource(child, path+'/source'))
      else if (child.baseName = 'subject') then
        result.subject := ParseResourceReference{Resource}(child, path+'/subject') {b}
      else if (child.baseName = 'accessionIdentifier') then
        result.accessionIdentifier := ParseIdentifier(child, path+'/accessionIdentifier') {b}
      else if (child.baseName = 'receivedTime') then
        result.receivedTime := ParseDateTime(child, path+'/receivedTime') {b}
      else if (child.baseName = 'collection') then
        result.collection := ParseSpecimenCollection(child, path+'/collection') {b}
      else if (child.baseName = 'treatment') then
        result.treatmentList.Add(ParseSpecimenTreatment(child, path+'/treatment'))
      else if (child.baseName = 'container') then
        result.containerList.Add(ParseSpecimenContainer(child, path+'/container'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSpecimen(xml : TXmlBuilder; name : string; elem : TFhirSpecimen);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  for i := 0 to elem.identifierList.Count - 1 do
    ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'type', elem.type_);
  for i := 0 to elem.sourceList.Count - 1 do
    ComposeSpecimenSource(xml, 'source', elem.sourceList[i]);
  ComposeResourceReference{Resource}(xml, 'subject', elem.subject);
  ComposeIdentifier(xml, 'accessionIdentifier', elem.accessionIdentifier);
  ComposeDateTime(xml, 'receivedTime', elem.receivedTime);
  ComposeSpecimenCollection(xml, 'collection', elem.collection);
  for i := 0 to elem.treatmentList.Count - 1 do
    ComposeSpecimenTreatment(xml, 'treatment', elem.treatmentList[i]);
  for i := 0 to elem.containerList.Count - 1 do
    ComposeSpecimenContainer(xml, 'container', elem.containerList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSpecimen(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimen(jsn));
end;

function TFHIRJsonParser.ParseSpecimen(jsn : TJsonObject) : TFhirSpecimen;
begin
  result := TFhirSpecimen.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('source') then
      iterateArray(jsn.vArr['source'], result.sourceList, parseSpecimenSource);
    if jsn.has('subject') then
        result.subject := ParseResourceReference{Resource}(jsn.vObj['subject']);{q}
    if jsn.has('accessionIdentifier') then
        result.accessionIdentifier := ParseIdentifier(jsn.vObj['accessionIdentifier']);{q}
    if jsn.has('receivedTime') or jsn.has('_receivedTime') then
        result.receivedTime := ParseDateTime(jsn['receivedTime'], jsn.vObj['_receivedTime']);{q}
    if jsn.has('collection') then
        result.collection := ParseSpecimenCollection(jsn.vObj['collection']);{q}
    if jsn.has('treatment') then
      iterateArray(jsn.vArr['treatment'], result.treatmentList, parseSpecimenTreatment);
    if jsn.has('container') then
      iterateArray(jsn.vArr['container'], result.containerList, parseSpecimenContainer);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSpecimen(json : TJSONWriter; name : string; elem : TFhirSpecimen);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if elem.identifierList.Count > 0 then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '',elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if elem.sourceList.Count > 0 then
  begin
    json.valueArray('source');
    for i := 0 to elem.sourceList.Count - 1 do
      ComposeSpecimenSource(json, '',elem.sourceList[i]); {z - }
    json.FinishArray;
  end;
  ComposeResourceReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeIdentifier(json, 'accessionIdentifier', elem.accessionIdentifier); {a}
  ComposeDateTimeValue(json, 'receivedTime', elem.receivedTime, false);
  ComposeDateTimeProps(json, 'receivedTime', elem.receivedTime, false);
  ComposeSpecimenCollection(json, 'collection', elem.collection); {a}
  if elem.treatmentList.Count > 0 then
  begin
    json.valueArray('treatment');
    for i := 0 to elem.treatmentList.Count - 1 do
      ComposeSpecimenTreatment(json, '',elem.treatmentList[i]); {z - }
    json.FinishArray;
  end;
  if elem.containerList.Count > 0 then
  begin
    json.valueArray('container');
    for i := 0 to elem.containerList.Count - 1 do
      ComposeSpecimenContainer(json, '',elem.containerList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseSubstanceInstance(element : IXmlDomElement; path : string) : TFhirSubstanceInstance;
var
  child : IXMLDOMElement;
begin
  result := TFhirSubstanceInstance.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'expiry') then
        result.expiry := ParseDateTime(child, path+'/expiry') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSubstanceInstance(xml : TXmlBuilder; name : string; elem : TFhirSubstanceInstance);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);
  ComposeDateTime(xml, 'expiry', elem.expiry);
  ComposeQuantity(xml, 'quantity', elem.quantity);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSubstanceInstance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceInstance(jsn));
end;

function TFHIRJsonParser.ParseSubstanceInstance(jsn : TJsonObject) : TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('expiry') or jsn.has('_expiry') then
        result.expiry := ParseDateTime(jsn['expiry'], jsn.vObj['_expiry']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSubstanceInstance(json : TJSONWriter; name : string; elem : TFhirSubstanceInstance);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeDateTimeValue(json, 'expiry', elem.expiry, false);
  ComposeDateTimeProps(json, 'expiry', elem.expiry, false);
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseSubstanceIngredient(element : IXmlDomElement; path : string) : TFhirSubstanceIngredient;
var
  child : IXMLDOMElement;
begin
  result := TFhirSubstanceIngredient.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'quantity') then
        result.quantity := ParseRatio(child, path+'/quantity') {b}
      else if (child.baseName = 'substance') then
        result.substance := ParseResourceReference{TFhirSubstance}(child, path+'/substance') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSubstanceIngredient(xml : TXmlBuilder; name : string; elem : TFhirSubstanceIngredient);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeRatio(xml, 'quantity', elem.quantity);
  ComposeResourceReference{TFhirSubstance}(xml, 'substance', elem.substance);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSubstanceIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceIngredient(jsn));
end;

function TFHIRJsonParser.ParseSubstanceIngredient(jsn : TJsonObject) : TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('quantity') then
        result.quantity := ParseRatio(jsn.vObj['quantity']);{q}
    if jsn.has('substance') then
        result.substance := ParseResourceReference{TFhirSubstance}(jsn.vObj['substance']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSubstanceIngredient(json : TJSONWriter; name : string; elem : TFhirSubstanceIngredient);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeRatio(json, 'quantity', elem.quantity); {a}
  ComposeResourceReference{TFhirSubstance}(json, 'substance', elem.substance); {a}
  json.finishObject;
end;

function TFHIRXmlParser.ParseSubstance(element : IXmlDomElement; path : string) : TFhirSubstance;
var
  child : IXMLDOMElement;
begin
  result := TFhirSubstance.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'description') then
        result.description := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'instance') then
        result.instance := ParseSubstanceInstance(child, path+'/instance') {b}
      else if (child.baseName = 'ingredient') then
        result.ingredientList.Add(ParseSubstanceIngredient(child, path+'/ingredient'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSubstance(xml : TXmlBuilder; name : string; elem : TFhirSubstance);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);
  ComposeString(xml, 'description', elem.description);
  ComposeSubstanceInstance(xml, 'instance', elem.instance);
  for i := 0 to elem.ingredientList.Count - 1 do
    ComposeSubstanceIngredient(xml, 'ingredient', elem.ingredientList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSubstance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstance(jsn));
end;

function TFHIRJsonParser.ParseSubstance(jsn : TJsonObject) : TFhirSubstance;
begin
  result := TFhirSubstance.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.description := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('instance') then
        result.instance := ParseSubstanceInstance(jsn.vObj['instance']);{q}
    if jsn.has('ingredient') then
      iterateArray(jsn.vArr['ingredient'], result.ingredientList, parseSubstanceIngredient);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSubstance(json : TJSONWriter; name : string; elem : TFhirSubstance);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeStringValue(json, 'description', elem.description, false);
  ComposeStringProps(json, 'description', elem.description, false);
  ComposeSubstanceInstance(json, 'instance', elem.instance); {a}
  if elem.ingredientList.Count > 0 then
  begin
    json.valueArray('ingredient');
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeSubstanceIngredient(json, '',elem.ingredientList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseSupplyDispense(element : IXmlDomElement; path : string) : TFhirSupplyDispense;
var
  child : IXMLDOMElement;
begin
  result := TFhirSupplyDispense.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirValuesetSupplyDispenseStatus, path+'/status', child)
      else if (child.baseName = 'type') then
        result.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.baseName = 'quantity') then
        result.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.baseName = 'suppliedItem') then
        result.suppliedItem := ParseResourceReference{Resource}(child, path+'/suppliedItem') {b}
      else if (child.baseName = 'supplier') then
        result.supplier := ParseResourceReference{TFhirPractitioner}(child, path+'/supplier') {b}
      else if (child.baseName = 'whenPrepared') then
        result.whenPrepared := ParsePeriod(child, path+'/whenPrepared') {b}
      else if (child.baseName = 'whenHandedOver') then
        result.whenHandedOver := ParsePeriod(child, path+'/whenHandedOver') {b}
      else if (child.baseName = 'destination') then
        result.destination := ParseResourceReference{TFhirLocation}(child, path+'/destination') {b}
      else if (child.baseName = 'receiver') then
        result.receiverList.Add(ParseResourceReference{TFhirPractitioner}(child, path+'/receiver'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSupplyDispense(xml : TXmlBuilder; name : string; elem : TFhirSupplyDispense);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirValuesetSupplyDispenseStatus);
  ComposeCodeableConcept(xml, 'type', elem.type_);
  ComposeQuantity(xml, 'quantity', elem.quantity);
  ComposeResourceReference{Resource}(xml, 'suppliedItem', elem.suppliedItem);
  ComposeResourceReference{TFhirPractitioner}(xml, 'supplier', elem.supplier);
  ComposePeriod(xml, 'whenPrepared', elem.whenPrepared);
  ComposePeriod(xml, 'whenHandedOver', elem.whenHandedOver);
  ComposeResourceReference{TFhirLocation}(xml, 'destination', elem.destination);
  for i := 0 to elem.receiverList.Count - 1 do
    ComposeResourceReference{TFhirPractitioner}(xml, 'receiver', elem.receiverList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSupplyDispense(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSupplyDispense(jsn));
end;

function TFHIRJsonParser.ParseSupplyDispense(jsn : TJsonObject) : TFhirSupplyDispense;
begin
  result := TFhirSupplyDispense.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirValuesetSupplyDispenseStatus);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q}
    if jsn.has('suppliedItem') then
        result.suppliedItem := ParseResourceReference{Resource}(jsn.vObj['suppliedItem']);{q}
    if jsn.has('supplier') then
        result.supplier := ParseResourceReference{TFhirPractitioner}(jsn.vObj['supplier']);{q}
    if jsn.has('whenPrepared') then
        result.whenPrepared := ParsePeriod(jsn.vObj['whenPrepared']);{q}
    if jsn.has('whenHandedOver') then
        result.whenHandedOver := ParsePeriod(jsn.vObj['whenHandedOver']);{q}
    if jsn.has('destination') then
        result.destination := ParseResourceReference{TFhirLocation}(jsn.vObj['destination']);{q}
    if jsn.has('receiver') then
      iterateArray(jsn.vArr['receiver'], result.receiverList, parseResourceReference{TFhirPractitioner});
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSupplyDispense(json : TJSONWriter; name : string; elem : TFhirSupplyDispense);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirValuesetSupplyDispenseStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirValuesetSupplyDispenseStatus, false);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  ComposeResourceReference{Resource}(json, 'suppliedItem', elem.suppliedItem); {a}
  ComposeResourceReference{TFhirPractitioner}(json, 'supplier', elem.supplier); {a}
  ComposePeriod(json, 'whenPrepared', elem.whenPrepared); {a}
  ComposePeriod(json, 'whenHandedOver', elem.whenHandedOver); {a}
  ComposeResourceReference{TFhirLocation}(json, 'destination', elem.destination); {a}
  if elem.receiverList.Count > 0 then
  begin
    json.valueArray('receiver');
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeResourceReference{TFhirPractitioner}(json, '',elem.receiverList[i]); {z - Resource(Practitioner)}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseSupply(element : IXmlDomElement; path : string) : TFhirSupply;
var
  child : IXMLDOMElement;
begin
  result := TFhirSupply.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'kind') then
        result.kind := ParseCodeableConcept(child, path+'/kind') {b}
      else if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirValuesetSupplyStatus, path+'/status', child)
      else if (child.baseName = 'orderedItem') then
        result.orderedItem := ParseResourceReference{Resource}(child, path+'/orderedItem') {b}
      else if (child.baseName = 'patient') then
        result.patient := ParseResourceReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.baseName = 'dispense') then
        result.dispenseList.Add(ParseSupplyDispense(child, path+'/dispense'))
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeSupply(xml : TXmlBuilder; name : string; elem : TFhirSupply);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeCodeableConcept(xml, 'kind', elem.kind);
  ComposeIdentifier(xml, 'identifier', elem.identifier);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirValuesetSupplyStatus);
  ComposeResourceReference{Resource}(xml, 'orderedItem', elem.orderedItem);
  ComposeResourceReference{TFhirPatient}(xml, 'patient', elem.patient);
  for i := 0 to elem.dispenseList.Count - 1 do
    ComposeSupplyDispense(xml, 'dispense', elem.dispenseList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseSupply(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSupply(jsn));
end;

function TFHIRJsonParser.ParseSupply(jsn : TJsonObject) : TFhirSupply;
begin
  result := TFhirSupply.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('kind') then
        result.kind := ParseCodeableConcept(jsn.vObj['kind']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirValuesetSupplyStatus);
    if jsn.has('orderedItem') then
        result.orderedItem := ParseResourceReference{Resource}(jsn.vObj['orderedItem']);{q}
    if jsn.has('patient') then
        result.patient := ParseResourceReference{TFhirPatient}(jsn.vObj['patient']);{q}
    if jsn.has('dispense') then
      iterateArray(jsn.vArr['dispense'], result.dispenseList, parseSupplyDispense);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeSupply(json : TJSONWriter; name : string; elem : TFhirSupply);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeCodeableConcept(json, 'kind', elem.kind); {a}
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirValuesetSupplyStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirValuesetSupplyStatus, false);
  ComposeResourceReference{Resource}(json, 'orderedItem', elem.orderedItem); {a}
  ComposeResourceReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if elem.dispenseList.Count > 0 then
  begin
    json.valueArray('dispense');
    for i := 0 to elem.dispenseList.Count - 1 do
      ComposeSupplyDispense(json, '',elem.dispenseList[i]); {z - }
    json.FinishArray;
  end;
end;

function TFHIRXmlParser.ParseValueSetDefine(element : IXmlDomElement; path : string) : TFhirValueSetDefine;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetDefine.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'system') then
        result.system := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'version') then
        result.version := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'caseSensitive') then
        result.caseSensitive := ParseBoolean(child, path+'/caseSensitive') {b}
      else if (child.baseName = 'concept') then
        result.conceptList.Add(ParseValueSetDefineConcept(child, path+'/concept'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetDefine(xml : TXmlBuilder; name : string; elem : TFhirValueSetDefine);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'system', elem.system);
  ComposeString(xml, 'version', elem.version);
  ComposeBoolean(xml, 'caseSensitive', elem.caseSensitive);
  for i := 0 to elem.conceptList.Count - 1 do
    ComposeValueSetDefineConcept(xml, 'concept', elem.conceptList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetDefine(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetDefine(jsn));
end;

function TFHIRJsonParser.ParseValueSetDefine(jsn : TJsonObject) : TFhirValueSetDefine;
begin
  result := TFhirValueSetDefine.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system') then
        result.system := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.version := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('caseSensitive') or jsn.has('_caseSensitive') then
        result.caseSensitive := ParseBoolean(jsn['caseSensitive'], jsn.vObj['_caseSensitive']);{q}
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseValueSetDefineConcept);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetDefine(json : TJSONWriter; name : string; elem : TFhirValueSetDefine);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'system', elem.system, false);
  ComposeUriProps(json, 'system', elem.system, false);
  ComposeStringValue(json, 'version', elem.version, false);
  ComposeStringProps(json, 'version', elem.version, false);
  ComposeBooleanValue(json, 'caseSensitive', elem.caseSensitive, false);
  ComposeBooleanProps(json, 'caseSensitive', elem.caseSensitive, false);
  if elem.conceptList.Count > 0 then
  begin
    json.valueArray('concept');
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetDefineConcept(json, '',elem.conceptList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseValueSetDefineConcept(element : IXmlDomElement; path : string) : TFhirValueSetDefineConcept;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetDefineConcept.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'code') then
        result.code := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'abstract') then
        result.abstract := ParseBoolean(child, path+'/abstract') {b}
      else if (child.baseName = 'display') then
        result.display := ParseString(child, path+'/display') {b}
      else if (child.baseName = 'definition') then
        result.definition := ParseString(child, path+'/definition') {b}
      else if (child.baseName = 'concept') then
        result.conceptList.Add(ParseValueSetDefineConcept(child, path+'/concept'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetDefineConcept(xml : TXmlBuilder; name : string; elem : TFhirValueSetDefineConcept);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'code', elem.code);
  ComposeBoolean(xml, 'abstract', elem.abstract);
  ComposeString(xml, 'display', elem.display);
  ComposeString(xml, 'definition', elem.definition);
  for i := 0 to elem.conceptList.Count - 1 do
    ComposeValueSetDefineConcept(xml, 'concept', elem.conceptList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetDefineConcept(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetDefineConcept(jsn));
end;

function TFHIRJsonParser.ParseValueSetDefineConcept(jsn : TJsonObject) : TFhirValueSetDefineConcept;
begin
  result := TFhirValueSetDefineConcept.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.code := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('abstract') or jsn.has('_abstract') then
        result.abstract := ParseBoolean(jsn['abstract'], jsn.vObj['_abstract']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.display := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    if jsn.has('definition') or jsn.has('_definition') then
        result.definition := ParseString(jsn['definition'], jsn.vObj['_definition']);{q}
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseValueSetDefineConcept);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetDefineConcept(json : TJSONWriter; name : string; elem : TFhirValueSetDefineConcept);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'code', elem.code, false);
  ComposeCodeProps(json, 'code', elem.code, false);
  ComposeBooleanValue(json, 'abstract', elem.abstract, false);
  ComposeBooleanProps(json, 'abstract', elem.abstract, false);
  ComposeStringValue(json, 'display', elem.display, false);
  ComposeStringProps(json, 'display', elem.display, false);
  ComposeStringValue(json, 'definition', elem.definition, false);
  ComposeStringProps(json, 'definition', elem.definition, false);
  if elem.conceptList.Count > 0 then
  begin
    json.valueArray('concept');
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetDefineConcept(json, '',elem.conceptList[i]); {z - @ValueSet.define.concept}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseValueSetCompose(element : IXmlDomElement; path : string) : TFhirValueSetCompose;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetCompose.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'import') then
        result.importList.Add(ParseUri(child, path+'/import'))
      else if (child.baseName = 'include') then
        result.includeList.Add(ParseValueSetComposeInclude(child, path+'/include'))
      else if (child.baseName = 'exclude') then
        result.excludeList.Add(ParseValueSetComposeInclude(child, path+'/exclude'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetCompose(xml : TXmlBuilder; name : string; elem : TFhirValueSetCompose);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.importList.Count - 1 do
    ComposeUri(xml, 'import', elem.importList[i]);
  for i := 0 to elem.includeList.Count - 1 do
    ComposeValueSetComposeInclude(xml, 'include', elem.includeList[i]);
  for i := 0 to elem.excludeList.Count - 1 do
    ComposeValueSetComposeInclude(xml, 'exclude', elem.excludeList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetCompose(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetCompose(jsn));
end;

function TFHIRJsonParser.ParseValueSetCompose(jsn : TJsonObject) : TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose.create;
  try
    ParseBackboneElementProperties(jsn, result);
      if jsn.has('import') or jsn.has('_import') then
      iteratePrimitiveArray(jsn.vArr['import'], jsn.vArr['_import'], result.importList, parseUri);
    if jsn.has('include') then
      iterateArray(jsn.vArr['include'], result.includeList, parseValueSetComposeInclude);
    if jsn.has('exclude') then
      iterateArray(jsn.vArr['exclude'], result.excludeList, parseValueSetComposeInclude);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetCompose(json : TJSONWriter; name : string; elem : TFhirValueSetCompose);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if elem.importList.Count > 0 then
  begin
    json.valueArray('import');
    ext := false;
    for i := 0 to elem.importList.Count - 1 do
    begin
      ext := ext or ((elem.importList[i].xmlid <> '') or (elem.importList[i].hasExtensions));
      ComposeUriValue(json, '',elem.importList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_import');
      for i := 0 to elem.importList.Count - 1 do
        ComposeUriProps(json, '',elem.importList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.includeList.Count > 0 then
  begin
    json.valueArray('include');
    for i := 0 to elem.includeList.Count - 1 do
      ComposeValueSetComposeInclude(json, '',elem.includeList[i]); {z - }
    json.FinishArray;
  end;
  if elem.excludeList.Count > 0 then
  begin
    json.valueArray('exclude');
    for i := 0 to elem.excludeList.Count - 1 do
      ComposeValueSetComposeInclude(json, '',elem.excludeList[i]); {z - @ValueSet.compose.include}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseValueSetComposeInclude(element : IXmlDomElement; path : string) : TFhirValueSetComposeInclude;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetComposeInclude.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'system') then
        result.system := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'version') then
        result.version := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'code') then
        result.codeList.Add(ParseCode(child, path+'/code'))
      else if (child.baseName = 'filter') then
        result.filterList.Add(ParseValueSetComposeIncludeFilter(child, path+'/filter'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeInclude(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeInclude);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'system', elem.system);
  ComposeString(xml, 'version', elem.version);
  for i := 0 to elem.codeList.Count - 1 do
    ComposeCode(xml, 'code', elem.codeList[i]);
  for i := 0 to elem.filterList.Count - 1 do
    ComposeValueSetComposeIncludeFilter(xml, 'filter', elem.filterList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetComposeInclude(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetComposeInclude(jsn));
end;

function TFHIRJsonParser.ParseValueSetComposeInclude(jsn : TJsonObject) : TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system') then
        result.system := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.version := ParseString(jsn['version'], jsn.vObj['_version']);{q}
      if jsn.has('code') or jsn.has('_code') then
      iteratePrimitiveArray(jsn.vArr['code'], jsn.vArr['_code'], result.codeList, parseCode);
    if jsn.has('filter') then
      iterateArray(jsn.vArr['filter'], result.filterList, parseValueSetComposeIncludeFilter);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetComposeInclude(json : TJSONWriter; name : string; elem : TFhirValueSetComposeInclude);
var
  i : integer;
  ext : boolean;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'system', elem.system, false);
  ComposeUriProps(json, 'system', elem.system, false);
  ComposeStringValue(json, 'version', elem.version, false);
  ComposeStringProps(json, 'version', elem.version, false);
  if elem.codeList.Count > 0 then
  begin
    json.valueArray('code');
    ext := false;
    for i := 0 to elem.codeList.Count - 1 do
    begin
      ext := ext or ((elem.codeList[i].xmlid <> '') or (elem.codeList[i].hasExtensions));
      ComposeCodeValue(json, '',elem.codeList[i], true);
    end;
    json.FinishArray;
    if ext then
    begin
      json.valueArray('_code');
      for i := 0 to elem.codeList.Count - 1 do
        ComposeCodeProps(json, '',elem.codeList[i], true);
      json.FinishArray;
    end;
  end;
  if elem.filterList.Count > 0 then
  begin
    json.valueArray('filter');
    for i := 0 to elem.filterList.Count - 1 do
      ComposeValueSetComposeIncludeFilter(json, '',elem.filterList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeFilter(element : IXmlDomElement; path : string) : TFhirValueSetComposeIncludeFilter;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'property') then
        result.property_ := ParseCode(child, path+'/property') {b}
      else if (child.baseName = 'op') then
        result.op := ParseEnum(CODES_TFhirFilterOperator, path+'/op', child)
      else if (child.baseName = 'value') then
        result.value := ParseCode(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeFilter(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeIncludeFilter);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'property', elem.property_);
  ComposeEnum(xml, 'op', elem.Op, CODES_TFhirFilterOperator);
  ComposeCode(xml, 'value', elem.value);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetComposeIncludeFilter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetComposeIncludeFilter(jsn));
end;

function TFHIRJsonParser.ParseValueSetComposeIncludeFilter(jsn : TJsonObject) : TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('property') or jsn.has('_property') then
        result.property_ := ParseCode(jsn['property'], jsn.vObj['_property']);{q}
    if jsn.has('op') or jsn.has('_op')  then
      result.op := parseEnum(jsn['op'], jsn.vObj['_op'], CODES_TFhirFilterOperator);
    if jsn.has('value') or jsn.has('_value') then
        result.value := ParseCode(jsn['value'], jsn.vObj['_value']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetComposeIncludeFilter(json : TJSONWriter; name : string; elem : TFhirValueSetComposeIncludeFilter);
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'property', elem.property_, false);
  ComposeCodeProps(json, 'property', elem.property_, false);
  ComposeEnumValue(json, 'op', elem.Op, CODES_TFhirFilterOperator, false);
  ComposeEnumProps(json, 'op', elem.Op, CODES_TFhirFilterOperator, false);
  ComposeCodeValue(json, 'value', elem.value, false);
  ComposeCodeProps(json, 'value', elem.value, false);
  json.finishObject;
end;

function TFHIRXmlParser.ParseValueSetExpansion(element : IXmlDomElement; path : string) : TFhirValueSetExpansion;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetExpansion.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.baseName = 'timestamp') then
        result.timestamp := ParseInstant(child, path+'/timestamp') {b}
      else if (child.baseName = 'contains') then
        result.containsList.Add(ParseValueSetExpansionContains(child, path+'/contains'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansion(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansion);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeIdentifier(xml, 'identifier', elem.identifier);
  ComposeInstant(xml, 'timestamp', elem.timestamp);
  for i := 0 to elem.containsList.Count - 1 do
    ComposeValueSetExpansionContains(xml, 'contains', elem.containsList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetExpansion(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetExpansion(jsn));
end;

function TFHIRJsonParser.ParseValueSetExpansion(jsn : TJsonObject) : TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q}
    if jsn.has('timestamp') or jsn.has('_timestamp') then
        result.timestamp := ParseInstant(jsn['timestamp'], jsn.vObj['_timestamp']);{q}
    if jsn.has('contains') then
      iterateArray(jsn.vArr['contains'], result.containsList, parseValueSetExpansionContains);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetExpansion(json : TJSONWriter; name : string; elem : TFhirValueSetExpansion);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeInstantValue(json, 'timestamp', elem.timestamp, false);
  ComposeInstantProps(json, 'timestamp', elem.timestamp, false);
  if elem.containsList.Count > 0 then
  begin
    json.valueArray('contains');
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(json, '',elem.containsList[i]); {z - }
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseValueSetExpansionContains(element : IXmlDomElement; path : string) : TFhirValueSetExpansionContains;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSetExpansionContains.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'system') then
        result.system := ParseUri(child, path+'/system') {b}
      else if (child.baseName = 'code') then
        result.code := ParseCode(child, path+'/code') {b}
      else if (child.baseName = 'display') then
        result.display := ParseString(child, path+'/display') {b}
      else if (child.baseName = 'contains') then
        result.containsList.Add(ParseValueSetExpansionContains(child, path+'/contains'))
      else if Not ParseBackboneElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionContains(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansionContains);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'system', elem.system);
  ComposeCode(xml, 'code', elem.code);
  ComposeString(xml, 'display', elem.display);
  for i := 0 to elem.containsList.Count - 1 do
    ComposeValueSetExpansionContains(xml, 'contains', elem.containsList[i]);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSetExpansionContains(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetExpansionContains(jsn));
end;

function TFHIRJsonParser.ParseValueSetExpansionContains(jsn : TJsonObject) : TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains.create;
  try
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system') then
        result.system := ParseUri(jsn['system'], jsn.vObj['_system']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.code := ParseCode(jsn['code'], jsn.vObj['_code']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.display := ParseString(jsn['display'], jsn.vObj['_display']);{q}
    if jsn.has('contains') then
      iterateArray(jsn.vArr['contains'], result.containsList, parseValueSetExpansionContains);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSetExpansionContains(json : TJSONWriter; name : string; elem : TFhirValueSetExpansionContains);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'system', elem.system, false);
  ComposeUriProps(json, 'system', elem.system, false);
  ComposeCodeValue(json, 'code', elem.code, false);
  ComposeCodeProps(json, 'code', elem.code, false);
  ComposeStringValue(json, 'display', elem.display, false);
  ComposeStringProps(json, 'display', elem.display, false);
  if elem.containsList.Count > 0 then
  begin
    json.valueArray('contains');
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(json, '',elem.containsList[i]); {z - @ValueSet.expansion.contains}
    json.FinishArray;
  end;
  json.finishObject;
end;

function TFHIRXmlParser.ParseValueSet(element : IXmlDomElement; path : string) : TFhirValueSet;
var
  child : IXMLDOMElement;
begin
  result := TFhirValueSet.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if (child.baseName = 'identifier') then
        result.identifier := ParseString(child, path+'/identifier') {b}
      else if (child.baseName = 'version') then
        result.version := ParseString(child, path+'/version') {b}
      else if (child.baseName = 'name') then
        result.name := ParseString(child, path+'/name') {b}
      else if (child.baseName = 'publisher') then
        result.publisher := ParseString(child, path+'/publisher') {b}
      else if (child.baseName = 'telecom') then
        result.telecomList.Add(ParseContact(child, path+'/telecom'))
      else if (child.baseName = 'description') then
        result.description := ParseString(child, path+'/description') {b}
      else if (child.baseName = 'copyright') then
        result.copyright := ParseString(child, path+'/copyright') {b}
      else if (child.baseName = 'status') then
        result.status := ParseEnum(CODES_TFhirValuesetStatus, path+'/status', child)
      else if (child.baseName = 'experimental') then
        result.experimental := ParseBoolean(child, path+'/experimental') {b}
      else if (child.baseName = 'extensible') then
        result.extensible := ParseBoolean(child, path+'/extensible') {b}
      else if (child.baseName = 'date') then
        result.date := ParseDateTime(child, path+'/date') {b}
      else if (child.baseName = 'define') then
        result.define := ParseValueSetDefine(child, path+'/define') {b}
      else if (child.baseName = 'compose') then
        result.compose := ParseValueSetCompose(child, path+'/compose') {b}
      else if (child.baseName = 'expansion') then
        result.expansion := ParseValueSetExpansion(child, path+'/expansion') {b}
      else if Not ParseResourceChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeValueSet(xml : TXmlBuilder; name : string; elem : TFhirValueSet);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  xml.open(name);
  composeResourceChildren(xml, elem);
  ComposeString(xml, 'identifier', elem.identifier);
  ComposeString(xml, 'version', elem.version);
  ComposeString(xml, 'name', elem.name);
  ComposeString(xml, 'publisher', elem.publisher);
  for i := 0 to elem.telecomList.Count - 1 do
    ComposeContact(xml, 'telecom', elem.telecomList[i]);
  ComposeString(xml, 'description', elem.description);
  if not SummaryOnly then
    ComposeString(xml, 'copyright', elem.copyright);
  ComposeEnum(xml, 'status', elem.Status, CODES_TFhirValuesetStatus);
  ComposeBoolean(xml, 'experimental', elem.experimental);
  if not SummaryOnly then
    ComposeBoolean(xml, 'extensible', elem.extensible);
  ComposeDateTime(xml, 'date', elem.date);
  ComposeValueSetDefine(xml, 'define', elem.define);
  if not SummaryOnly then
    ComposeValueSetCompose(xml, 'compose', elem.compose);
  if not SummaryOnly then
    ComposeValueSetExpansion(xml, 'expansion', elem.expansion);
  closeOutElement(xml, elem);
  xml.close(name);
end;

procedure TFHIRJsonParser.ParseValueSet(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSet(jsn));
end;

function TFHIRJsonParser.ParseValueSet(jsn : TJsonObject) : TFhirValueSet;
begin
  result := TFhirValueSet.create;
  try
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifier := ParseString(jsn['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.version := ParseString(jsn['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.name := ParseString(jsn['name'], jsn.vObj['_name']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisher := ParseString(jsn['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContact);
    if jsn.has('description') or jsn.has('_description') then
        result.description := ParseString(jsn['description'], jsn.vObj['_description']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyright := ParseString(jsn['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.status := parseEnum(jsn['status'], jsn.vObj['_status'], CODES_TFhirValuesetStatus);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimental := ParseBoolean(jsn['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('extensible') or jsn.has('_extensible') then
        result.extensible := ParseBoolean(jsn['extensible'], jsn.vObj['_extensible']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.date := ParseDateTime(jsn['date'], jsn.vObj['_date']);{q}
    if jsn.has('define') then
        result.define := ParseValueSetDefine(jsn.vObj['define']);{q}
    if jsn.has('compose') then
        result.compose := ParseValueSetCompose(jsn.vObj['compose']);{q}
    if jsn.has('expansion') then
        result.expansion := ParseValueSetExpansion(jsn.vObj['expansion']);{q}
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeValueSet(json : TJSONWriter; name : string; elem : TFhirValueSet);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeStringValue(json, 'identifier', elem.identifier, false);
  ComposeStringProps(json, 'identifier', elem.identifier, false);
  ComposeStringValue(json, 'version', elem.version, false);
  ComposeStringProps(json, 'version', elem.version, false);
  ComposeStringValue(json, 'name', elem.name, false);
  ComposeStringProps(json, 'name', elem.name, false);
  ComposeStringValue(json, 'publisher', elem.publisher, false);
  ComposeStringProps(json, 'publisher', elem.publisher, false);
  if elem.telecomList.Count > 0 then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContact(json, '',elem.telecomList[i]); {z - Contact}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'description', elem.description, false);
  ComposeStringProps(json, 'description', elem.description, false);
  if not SummaryOnly then
    ComposeStringValue(json, 'copyright', elem.copyright, false);
  if not SummaryOnly then
    ComposeStringProps(json, 'copyright', elem.copyright, false);
  ComposeEnumValue(json, 'status', elem.Status, CODES_TFhirValuesetStatus, false);
  ComposeEnumProps(json, 'status', elem.Status, CODES_TFhirValuesetStatus, false);
  ComposeBooleanValue(json, 'experimental', elem.experimental, false);
  ComposeBooleanProps(json, 'experimental', elem.experimental, false);
  if not SummaryOnly then
    ComposeBooleanValue(json, 'extensible', elem.extensible, false);
  if not SummaryOnly then
    ComposeBooleanProps(json, 'extensible', elem.extensible, false);
  ComposeDateTimeValue(json, 'date', elem.date, false);
  ComposeDateTimeProps(json, 'date', elem.date, false);
  ComposeValueSetDefine(json, 'define', elem.define); {a}
  if not SummaryOnly then
    ComposeValueSetCompose(json, 'compose', elem.compose); {a}
  if not SummaryOnly then
    ComposeValueSetExpansion(json, 'expansion', elem.expansion); {a}
end;

function TFHIRXmlParser.ParseResource(element : IXmlDomElement; path : String) : TFhirResource;
begin
  if (element = nil) Then
    Raise Exception.Create('error - element is nil')
  else if element.baseName = 'AdverseReaction' Then
    result := ParseAdverseReaction(element, path+'/AdverseReaction')
  else if element.baseName = 'Alert' Then
    result := ParseAlert(element, path+'/Alert')
  else if element.baseName = 'AllergyIntolerance' Then
    result := ParseAllergyIntolerance(element, path+'/AllergyIntolerance')
  else if element.baseName = 'CarePlan' Then
    result := ParseCarePlan(element, path+'/CarePlan')
  else if element.baseName = 'Composition' Then
    result := ParseComposition(element, path+'/Composition')
  else if element.baseName = 'ConceptMap' Then
    result := ParseConceptMap(element, path+'/ConceptMap')
  else if element.baseName = 'Condition' Then
    result := ParseCondition(element, path+'/Condition')
  else if element.baseName = 'Conformance' Then
    result := ParseConformance(element, path+'/Conformance')
  else if element.baseName = 'Device' Then
    result := ParseDevice(element, path+'/Device')
  else if element.baseName = 'DeviceObservationReport' Then
    result := ParseDeviceObservationReport(element, path+'/DeviceObservationReport')
  else if element.baseName = 'DiagnosticOrder' Then
    result := ParseDiagnosticOrder(element, path+'/DiagnosticOrder')
  else if element.baseName = 'DiagnosticReport' Then
    result := ParseDiagnosticReport(element, path+'/DiagnosticReport')
  else if element.baseName = 'DocumentManifest' Then
    result := ParseDocumentManifest(element, path+'/DocumentManifest')
  else if element.baseName = 'DocumentReference' Then
    result := ParseDocumentReference(element, path+'/DocumentReference')
  else if element.baseName = 'Encounter' Then
    result := ParseEncounter(element, path+'/Encounter')
  else if element.baseName = 'FamilyHistory' Then
    result := ParseFamilyHistory(element, path+'/FamilyHistory')
  else if element.baseName = 'Group' Then
    result := ParseGroup(element, path+'/Group')
  else if element.baseName = 'ImagingStudy' Then
    result := ParseImagingStudy(element, path+'/ImagingStudy')
  else if element.baseName = 'Immunization' Then
    result := ParseImmunization(element, path+'/Immunization')
  else if element.baseName = 'ImmunizationRecommendation' Then
    result := ParseImmunizationRecommendation(element, path+'/ImmunizationRecommendation')
  else if element.baseName = 'List' Then
    result := ParseList(element, path+'/List')
  else if element.baseName = 'Location' Then
    result := ParseLocation(element, path+'/Location')
  else if element.baseName = 'Media' Then
    result := ParseMedia(element, path+'/Media')
  else if element.baseName = 'Medication' Then
    result := ParseMedication(element, path+'/Medication')
  else if element.baseName = 'MedicationAdministration' Then
    result := ParseMedicationAdministration(element, path+'/MedicationAdministration')
  else if element.baseName = 'MedicationDispense' Then
    result := ParseMedicationDispense(element, path+'/MedicationDispense')
  else if element.baseName = 'MedicationPrescription' Then
    result := ParseMedicationPrescription(element, path+'/MedicationPrescription')
  else if element.baseName = 'MedicationStatement' Then
    result := ParseMedicationStatement(element, path+'/MedicationStatement')
  else if element.baseName = 'MessageHeader' Then
    result := ParseMessageHeader(element, path+'/MessageHeader')
  else if element.baseName = 'Observation' Then
    result := ParseObservation(element, path+'/Observation')
  else if element.baseName = 'OperationOutcome' Then
    result := ParseOperationOutcome(element, path+'/OperationOutcome')
  else if element.baseName = 'Order' Then
    result := ParseOrder(element, path+'/Order')
  else if element.baseName = 'OrderResponse' Then
    result := ParseOrderResponse(element, path+'/OrderResponse')
  else if element.baseName = 'Organization' Then
    result := ParseOrganization(element, path+'/Organization')
  else if element.baseName = 'Other' Then
    result := ParseOther(element, path+'/Other')
  else if element.baseName = 'Patient' Then
    result := ParsePatient(element, path+'/Patient')
  else if element.baseName = 'Practitioner' Then
    result := ParsePractitioner(element, path+'/Practitioner')
  else if element.baseName = 'Procedure' Then
    result := ParseProcedure(element, path+'/Procedure')
  else if element.baseName = 'Profile' Then
    result := ParseProfile(element, path+'/Profile')
  else if element.baseName = 'Provenance' Then
    result := ParseProvenance(element, path+'/Provenance')
  else if element.baseName = 'Query' Then
    result := ParseQuery(element, path+'/Query')
  else if element.baseName = 'Questionnaire' Then
    result := ParseQuestionnaire(element, path+'/Questionnaire')
  else if element.baseName = 'RelatedPerson' Then
    result := ParseRelatedPerson(element, path+'/RelatedPerson')
  else if element.baseName = 'SecurityEvent' Then
    result := ParseSecurityEvent(element, path+'/SecurityEvent')
  else if element.baseName = 'Specimen' Then
    result := ParseSpecimen(element, path+'/Specimen')
  else if element.baseName = 'Substance' Then
    result := ParseSubstance(element, path+'/Substance')
  else if element.baseName = 'Supply' Then
    result := ParseSupply(element, path+'/Supply')
  else if element.baseName = 'ValueSet' Then
    result := ParseValueSet(element, path+'/ValueSet')
  else if (element.baseName = 'Binary') Then
    result := ParseBinary(element, path)
  else
    raise Exception.create('Error: the element '+element.baseName+' is not recognised as a valid resource name');
end;

procedure TFHIRXmlComposer.ComposeResource(xml : TXmlBuilder; id, ver : String; resource: TFhirResource);
begin
  if (resource = nil) Then
    Raise Exception.Create('error - resource is nil');
  Case resource.ResourceType of
    frtAdverseReaction: ComposeAdverseReaction(xml, 'AdverseReaction', TFhirAdverseReaction(resource));
    frtAlert: ComposeAlert(xml, 'Alert', TFhirAlert(resource));
    frtAllergyIntolerance: ComposeAllergyIntolerance(xml, 'AllergyIntolerance', TFhirAllergyIntolerance(resource));
    frtCarePlan: ComposeCarePlan(xml, 'CarePlan', TFhirCarePlan(resource));
    frtComposition: ComposeComposition(xml, 'Composition', TFhirComposition(resource));
    frtConceptMap: ComposeConceptMap(xml, 'ConceptMap', TFhirConceptMap(resource));
    frtCondition: ComposeCondition(xml, 'Condition', TFhirCondition(resource));
    frtConformance: ComposeConformance(xml, 'Conformance', TFhirConformance(resource));
    frtDevice: ComposeDevice(xml, 'Device', TFhirDevice(resource));
    frtDeviceObservationReport: ComposeDeviceObservationReport(xml, 'DeviceObservationReport', TFhirDeviceObservationReport(resource));
    frtDiagnosticOrder: ComposeDiagnosticOrder(xml, 'DiagnosticOrder', TFhirDiagnosticOrder(resource));
    frtDiagnosticReport: ComposeDiagnosticReport(xml, 'DiagnosticReport', TFhirDiagnosticReport(resource));
    frtDocumentManifest: ComposeDocumentManifest(xml, 'DocumentManifest', TFhirDocumentManifest(resource));
    frtDocumentReference: ComposeDocumentReference(xml, 'DocumentReference', TFhirDocumentReference(resource));
    frtEncounter: ComposeEncounter(xml, 'Encounter', TFhirEncounter(resource));
    frtFamilyHistory: ComposeFamilyHistory(xml, 'FamilyHistory', TFhirFamilyHistory(resource));
    frtGroup: ComposeGroup(xml, 'Group', TFhirGroup(resource));
    frtImagingStudy: ComposeImagingStudy(xml, 'ImagingStudy', TFhirImagingStudy(resource));
    frtImmunization: ComposeImmunization(xml, 'Immunization', TFhirImmunization(resource));
    frtImmunizationRecommendation: ComposeImmunizationRecommendation(xml, 'ImmunizationRecommendation', TFhirImmunizationRecommendation(resource));
    frtList: ComposeList(xml, 'List', TFhirList(resource));
    frtLocation: ComposeLocation(xml, 'Location', TFhirLocation(resource));
    frtMedia: ComposeMedia(xml, 'Media', TFhirMedia(resource));
    frtMedication: ComposeMedication(xml, 'Medication', TFhirMedication(resource));
    frtMedicationAdministration: ComposeMedicationAdministration(xml, 'MedicationAdministration', TFhirMedicationAdministration(resource));
    frtMedicationDispense: ComposeMedicationDispense(xml, 'MedicationDispense', TFhirMedicationDispense(resource));
    frtMedicationPrescription: ComposeMedicationPrescription(xml, 'MedicationPrescription', TFhirMedicationPrescription(resource));
    frtMedicationStatement: ComposeMedicationStatement(xml, 'MedicationStatement', TFhirMedicationStatement(resource));
    frtMessageHeader: ComposeMessageHeader(xml, 'MessageHeader', TFhirMessageHeader(resource));
    frtObservation: ComposeObservation(xml, 'Observation', TFhirObservation(resource));
    frtOperationOutcome: ComposeOperationOutcome(xml, 'OperationOutcome', TFhirOperationOutcome(resource));
    frtOrder: ComposeOrder(xml, 'Order', TFhirOrder(resource));
    frtOrderResponse: ComposeOrderResponse(xml, 'OrderResponse', TFhirOrderResponse(resource));
    frtOrganization: ComposeOrganization(xml, 'Organization', TFhirOrganization(resource));
    frtOther: ComposeOther(xml, 'Other', TFhirOther(resource));
    frtPatient: ComposePatient(xml, 'Patient', TFhirPatient(resource));
    frtPractitioner: ComposePractitioner(xml, 'Practitioner', TFhirPractitioner(resource));
    frtProcedure: ComposeProcedure(xml, 'Procedure', TFhirProcedure(resource));
    frtProfile: ComposeProfile(xml, 'Profile', TFhirProfile(resource));
    frtProvenance: ComposeProvenance(xml, 'Provenance', TFhirProvenance(resource));
    frtQuery: ComposeQuery(xml, 'Query', TFhirQuery(resource));
    frtQuestionnaire: ComposeQuestionnaire(xml, 'Questionnaire', TFhirQuestionnaire(resource));
    frtRelatedPerson: ComposeRelatedPerson(xml, 'RelatedPerson', TFhirRelatedPerson(resource));
    frtSecurityEvent: ComposeSecurityEvent(xml, 'SecurityEvent', TFhirSecurityEvent(resource));
    frtSpecimen: ComposeSpecimen(xml, 'Specimen', TFhirSpecimen(resource));
    frtSubstance: ComposeSubstance(xml, 'Substance', TFhirSubstance(resource));
    frtSupply: ComposeSupply(xml, 'Supply', TFhirSupply(resource));
    frtValueSet: ComposeValueSet(xml, 'ValueSet', TFhirValueSet(resource));
    frtBinary: ComposeBinary(xml, TFhirBinary(resource));
  else
    raise Exception.create('Internal error: the resource type '+CODES_TFhirResourceType[resource.ResourceType]+' is not a valid resource type');
  end;
end;

function TFHIRJsonParser.ParseResource(jsn : TJsonObject) : TFhirResource;
var
  s : String;
begin
  s := jsn['resourceType'];
  if s = 'AdverseReaction' Then
    result := ParseAdverseReaction(jsn)
  else if s = 'Alert' Then
    result := ParseAlert(jsn)
  else if s = 'AllergyIntolerance' Then
    result := ParseAllergyIntolerance(jsn)
  else if s = 'CarePlan' Then
    result := ParseCarePlan(jsn)
  else if s = 'Composition' Then
    result := ParseComposition(jsn)
  else if s = 'ConceptMap' Then
    result := ParseConceptMap(jsn)
  else if s = 'Condition' Then
    result := ParseCondition(jsn)
  else if s = 'Conformance' Then
    result := ParseConformance(jsn)
  else if s = 'Device' Then
    result := ParseDevice(jsn)
  else if s = 'DeviceObservationReport' Then
    result := ParseDeviceObservationReport(jsn)
  else if s = 'DiagnosticOrder' Then
    result := ParseDiagnosticOrder(jsn)
  else if s = 'DiagnosticReport' Then
    result := ParseDiagnosticReport(jsn)
  else if s = 'DocumentManifest' Then
    result := ParseDocumentManifest(jsn)
  else if s = 'DocumentReference' Then
    result := ParseDocumentReference(jsn)
  else if s = 'Encounter' Then
    result := ParseEncounter(jsn)
  else if s = 'FamilyHistory' Then
    result := ParseFamilyHistory(jsn)
  else if s = 'Group' Then
    result := ParseGroup(jsn)
  else if s = 'ImagingStudy' Then
    result := ParseImagingStudy(jsn)
  else if s = 'Immunization' Then
    result := ParseImmunization(jsn)
  else if s = 'ImmunizationRecommendation' Then
    result := ParseImmunizationRecommendation(jsn)
  else if s = 'List' Then
    result := ParseList(jsn)
  else if s = 'Location' Then
    result := ParseLocation(jsn)
  else if s = 'Media' Then
    result := ParseMedia(jsn)
  else if s = 'Medication' Then
    result := ParseMedication(jsn)
  else if s = 'MedicationAdministration' Then
    result := ParseMedicationAdministration(jsn)
  else if s = 'MedicationDispense' Then
    result := ParseMedicationDispense(jsn)
  else if s = 'MedicationPrescription' Then
    result := ParseMedicationPrescription(jsn)
  else if s = 'MedicationStatement' Then
    result := ParseMedicationStatement(jsn)
  else if s = 'MessageHeader' Then
    result := ParseMessageHeader(jsn)
  else if s = 'Observation' Then
    result := ParseObservation(jsn)
  else if s = 'OperationOutcome' Then
    result := ParseOperationOutcome(jsn)
  else if s = 'Order' Then
    result := ParseOrder(jsn)
  else if s = 'OrderResponse' Then
    result := ParseOrderResponse(jsn)
  else if s = 'Organization' Then
    result := ParseOrganization(jsn)
  else if s = 'Other' Then
    result := ParseOther(jsn)
  else if s = 'Patient' Then
    result := ParsePatient(jsn)
  else if s = 'Practitioner' Then
    result := ParsePractitioner(jsn)
  else if s = 'Procedure' Then
    result := ParseProcedure(jsn)
  else if s = 'Profile' Then
    result := ParseProfile(jsn)
  else if s = 'Provenance' Then
    result := ParseProvenance(jsn)
  else if s = 'Query' Then
    result := ParseQuery(jsn)
  else if s = 'Questionnaire' Then
    result := ParseQuestionnaire(jsn)
  else if s = 'RelatedPerson' Then
    result := ParseRelatedPerson(jsn)
  else if s = 'SecurityEvent' Then
    result := ParseSecurityEvent(jsn)
  else if s = 'Specimen' Then
    result := ParseSpecimen(jsn)
  else if s = 'Substance' Then
    result := ParseSubstance(jsn)
  else if s = 'Supply' Then
    result := ParseSupply(jsn)
  else if s = 'ValueSet' Then
    result := ParseValueSet(jsn)
  else if s = 'Binary' Then
    result := ParseBinary(jsn)
  else
    raise Exception.create('error: the element '+s+' is not a valid resource name');
end;

function TFHIRJsonParser.ParseFragment(jsn : TJsonObject; type_ : String) : TFhirElement;
begin
   if (type_ = 'TFhirExtension') then
    result := parseExtension(jsn)
  else if (type_ = 'TFhirNarrative') then
    result := parseNarrative(jsn)
  else if (type_ = 'TFhirPeriod') then
    result := parsePeriod(jsn)
  else if (type_ = 'TFhirCoding') then
    result := parseCoding(jsn)
  else if (type_ = 'TFhirRange') then
    result := parseRange(jsn)
  else if (type_ = 'TFhirQuantity') then
    result := parseQuantity(jsn)
  else if (type_ = 'TFhirAttachment') then
    result := parseAttachment(jsn)
  else if (type_ = 'TFhirRatio') then
    result := parseRatio(jsn)
  else if (type_ = 'TFhirSampledData') then
    result := parseSampledData(jsn)
  else if (type_ = 'TFhirResourceReference') then
    result := parseResourceReference(jsn)
  else if (type_ = 'TFhirCodeableConcept') then
    result := parseCodeableConcept(jsn)
  else if (type_ = 'TFhirIdentifier') then
    result := parseIdentifier(jsn)
  else if (type_ = 'TFhirSchedule') then
    result := parseSchedule(jsn)
  else if (type_ = 'TFhirContact') then
    result := parseContact(jsn)
  else if (type_ = 'TFhirAddress') then
    result := parseAddress(jsn)
  else if (type_ = 'TFhirHumanName') then
    result := parseHumanName(jsn)
  else if type_ = 'Binary' Then
    result := ParseBinary(jsn)
  else
    raise Exception.create('error: the element '+type_+' is not a valid fragment name');
end;

function TFHIRXmlParser.ParseFragment(element : IXMLDOMElement) : TFhirElement;
begin
   if SameText(element.NodeName, 'TFhirExtension') then
    result := parseExtension(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirNarrative') then
    result := parseNarrative(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirPeriod') then
    result := parsePeriod(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirCoding') then
    result := parseCoding(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirRange') then
    result := parseRange(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirQuantity') then
    result := parseQuantity(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirAttachment') then
    result := parseAttachment(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirRatio') then
    result := parseRatio(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirSampledData') then
    result := parseSampledData(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirResourceReference') then
    result := parseResourceReference(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirCodeableConcept') then
    result := parseCodeableConcept(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirIdentifier') then
    result := parseIdentifier(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirSchedule') then
    result := parseSchedule(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirContact') then
    result := parseContact(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirAddress') then
    result := parseAddress(element, element.nodeName)
  else if SameText(element.NodeName, 'TFhirHumanName') then
    result := parseHumanName(element, element.nodeName)
  else if sameText(element.nodeName, 'Binary') Then
    result := ParseBinary(element, element.nodeName)
  else
    raise Exception.create('error: the element '+element.nodeName+' is not a valid fragment name');
end;

procedure TFHIRJsonComposer.ComposeResource(json : TJSONWriter; id, ver : String; resource: TFhirResource);
begin
  if (resource = nil) Then
    Raise Exception.Create('error - resource is nil');
  json.value('resourceType', CODES_TFhirResourceType[resource.ResourceType]);
  Case resource.ResourceType of
    frtAdverseReaction: ComposeAdverseReaction(json, 'AdverseReaction', TFhirAdverseReaction(resource));
    frtAlert: ComposeAlert(json, 'Alert', TFhirAlert(resource));
    frtAllergyIntolerance: ComposeAllergyIntolerance(json, 'AllergyIntolerance', TFhirAllergyIntolerance(resource));
    frtCarePlan: ComposeCarePlan(json, 'CarePlan', TFhirCarePlan(resource));
    frtComposition: ComposeComposition(json, 'Composition', TFhirComposition(resource));
    frtConceptMap: ComposeConceptMap(json, 'ConceptMap', TFhirConceptMap(resource));
    frtCondition: ComposeCondition(json, 'Condition', TFhirCondition(resource));
    frtConformance: ComposeConformance(json, 'Conformance', TFhirConformance(resource));
    frtDevice: ComposeDevice(json, 'Device', TFhirDevice(resource));
    frtDeviceObservationReport: ComposeDeviceObservationReport(json, 'DeviceObservationReport', TFhirDeviceObservationReport(resource));
    frtDiagnosticOrder: ComposeDiagnosticOrder(json, 'DiagnosticOrder', TFhirDiagnosticOrder(resource));
    frtDiagnosticReport: ComposeDiagnosticReport(json, 'DiagnosticReport', TFhirDiagnosticReport(resource));
    frtDocumentManifest: ComposeDocumentManifest(json, 'DocumentManifest', TFhirDocumentManifest(resource));
    frtDocumentReference: ComposeDocumentReference(json, 'DocumentReference', TFhirDocumentReference(resource));
    frtEncounter: ComposeEncounter(json, 'Encounter', TFhirEncounter(resource));
    frtFamilyHistory: ComposeFamilyHistory(json, 'FamilyHistory', TFhirFamilyHistory(resource));
    frtGroup: ComposeGroup(json, 'Group', TFhirGroup(resource));
    frtImagingStudy: ComposeImagingStudy(json, 'ImagingStudy', TFhirImagingStudy(resource));
    frtImmunization: ComposeImmunization(json, 'Immunization', TFhirImmunization(resource));
    frtImmunizationRecommendation: ComposeImmunizationRecommendation(json, 'ImmunizationRecommendation', TFhirImmunizationRecommendation(resource));
    frtList: ComposeList(json, 'List', TFhirList(resource));
    frtLocation: ComposeLocation(json, 'Location', TFhirLocation(resource));
    frtMedia: ComposeMedia(json, 'Media', TFhirMedia(resource));
    frtMedication: ComposeMedication(json, 'Medication', TFhirMedication(resource));
    frtMedicationAdministration: ComposeMedicationAdministration(json, 'MedicationAdministration', TFhirMedicationAdministration(resource));
    frtMedicationDispense: ComposeMedicationDispense(json, 'MedicationDispense', TFhirMedicationDispense(resource));
    frtMedicationPrescription: ComposeMedicationPrescription(json, 'MedicationPrescription', TFhirMedicationPrescription(resource));
    frtMedicationStatement: ComposeMedicationStatement(json, 'MedicationStatement', TFhirMedicationStatement(resource));
    frtMessageHeader: ComposeMessageHeader(json, 'MessageHeader', TFhirMessageHeader(resource));
    frtObservation: ComposeObservation(json, 'Observation', TFhirObservation(resource));
    frtOperationOutcome: ComposeOperationOutcome(json, 'OperationOutcome', TFhirOperationOutcome(resource));
    frtOrder: ComposeOrder(json, 'Order', TFhirOrder(resource));
    frtOrderResponse: ComposeOrderResponse(json, 'OrderResponse', TFhirOrderResponse(resource));
    frtOrganization: ComposeOrganization(json, 'Organization', TFhirOrganization(resource));
    frtOther: ComposeOther(json, 'Other', TFhirOther(resource));
    frtPatient: ComposePatient(json, 'Patient', TFhirPatient(resource));
    frtPractitioner: ComposePractitioner(json, 'Practitioner', TFhirPractitioner(resource));
    frtProcedure: ComposeProcedure(json, 'Procedure', TFhirProcedure(resource));
    frtProfile: ComposeProfile(json, 'Profile', TFhirProfile(resource));
    frtProvenance: ComposeProvenance(json, 'Provenance', TFhirProvenance(resource));
    frtQuery: ComposeQuery(json, 'Query', TFhirQuery(resource));
    frtQuestionnaire: ComposeQuestionnaire(json, 'Questionnaire', TFhirQuestionnaire(resource));
    frtRelatedPerson: ComposeRelatedPerson(json, 'RelatedPerson', TFhirRelatedPerson(resource));
    frtSecurityEvent: ComposeSecurityEvent(json, 'SecurityEvent', TFhirSecurityEvent(resource));
    frtSpecimen: ComposeSpecimen(json, 'Specimen', TFhirSpecimen(resource));
    frtSubstance: ComposeSubstance(json, 'Substance', TFhirSubstance(resource));
    frtSupply: ComposeSupply(json, 'Supply', TFhirSupply(resource));
    frtValueSet: ComposeValueSet(json, 'ValueSet', TFhirValueSet(resource));
    frtBinary: ComposeBinary(json, TFhirBinary(resource));
  else
    raise Exception.create('Internal error: the resource type '+CODES_TFhirResourceType[resource.ResourceType]+' is not a valid resource type');
  end;
end;


end.

