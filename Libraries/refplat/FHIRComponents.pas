{!Wrapper uses FHIRBase, FHIRBase_Wrapper, FHIRTypes, FHIRTypes_Wrapper}

unit FHIRComponents;

{
  Copyright (c) 2011-2013, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
}

interface

// FHIR v0.80 generated Fri, Apr 18, 2014 22:46+1000

uses
  SysUtils, Classes, StringSupport, DecimalSupport, AdvBuffers, DateAndTime, FHIRBase, FHIRTypes;

Type
  TFhirAdverseReactionSymptom = class;
  TFhirAdverseReactionSymptomList = class;
  TFhirAdverseReactionExposure = class;
  TFhirAdverseReactionExposureList = class;
  TFhirCarePlanParticipant = class;
  TFhirCarePlanParticipantList = class;
  TFhirCarePlanGoal = class;
  TFhirCarePlanGoalList = class;
  TFhirCarePlanActivity = class;
  TFhirCarePlanActivityList = class;
  TFhirCarePlanActivitySimple = class;
  TFhirCarePlanActivitySimpleList = class;
  TFhirCompositionAttester = class;
  TFhirCompositionAttesterList = class;
  TFhirCompositionEvent = class;
  TFhirCompositionEventList = class;
  TFhirCompositionSection = class;
  TFhirCompositionSectionList = class;
  TFhirConceptMapConcept = class;
  TFhirConceptMapConceptList = class;
  TFhirConceptMapConceptDependsOn = class;
  TFhirConceptMapConceptDependsOnList = class;
  TFhirConceptMapConceptMap = class;
  TFhirConceptMapConceptMapList = class;
  TFhirConditionStage = class;
  TFhirConditionStageList = class;
  TFhirConditionEvidence = class;
  TFhirConditionEvidenceList = class;
  TFhirConditionLocation = class;
  TFhirConditionLocationList = class;
  TFhirConditionRelatedItem = class;
  TFhirConditionRelatedItemList = class;
  TFhirConformanceSoftware = class;
  TFhirConformanceSoftwareList = class;
  TFhirConformanceImplementation = class;
  TFhirConformanceImplementationList = class;
  TFhirConformanceRest = class;
  TFhirConformanceRestList = class;
  TFhirConformanceRestSecurity = class;
  TFhirConformanceRestSecurityList = class;
  TFhirConformanceRestSecurityCertificate = class;
  TFhirConformanceRestSecurityCertificateList = class;
  TFhirConformanceRestResource = class;
  TFhirConformanceRestResourceList = class;
  TFhirConformanceRestResourceOperation = class;
  TFhirConformanceRestResourceOperationList = class;
  TFhirConformanceRestResourceSearchParam = class;
  TFhirConformanceRestResourceSearchParamList = class;
  TFhirConformanceRestOperation = class;
  TFhirConformanceRestOperationList = class;
  TFhirConformanceRestQuery = class;
  TFhirConformanceRestQueryList = class;
  TFhirConformanceMessaging = class;
  TFhirConformanceMessagingList = class;
  TFhirConformanceMessagingEvent = class;
  TFhirConformanceMessagingEventList = class;
  TFhirConformanceDocument = class;
  TFhirConformanceDocumentList = class;
  TFhirDeviceObservationReportVirtualDevice = class;
  TFhirDeviceObservationReportVirtualDeviceList = class;
  TFhirDeviceObservationReportVirtualDeviceChannel = class;
  TFhirDeviceObservationReportVirtualDeviceChannelList = class;
  TFhirDeviceObservationReportVirtualDeviceChannelMetric = class;
  TFhirDeviceObservationReportVirtualDeviceChannelMetricList = class;
  TFhirDiagnosticOrderEvent = class;
  TFhirDiagnosticOrderEventList = class;
  TFhirDiagnosticOrderItem = class;
  TFhirDiagnosticOrderItemList = class;
  TFhirDiagnosticReportImage = class;
  TFhirDiagnosticReportImageList = class;
  TFhirDocumentReferenceRelatesTo = class;
  TFhirDocumentReferenceRelatesToList = class;
  TFhirDocumentReferenceService = class;
  TFhirDocumentReferenceServiceList = class;
  TFhirDocumentReferenceServiceParameter = class;
  TFhirDocumentReferenceServiceParameterList = class;
  TFhirDocumentReferenceContext = class;
  TFhirDocumentReferenceContextList = class;
  TFhirEncounterParticipant = class;
  TFhirEncounterParticipantList = class;
  TFhirEncounterHospitalization = class;
  TFhirEncounterHospitalizationList = class;
  TFhirEncounterHospitalizationAccomodation = class;
  TFhirEncounterHospitalizationAccomodationList = class;
  TFhirEncounterLocation = class;
  TFhirEncounterLocationList = class;
  TFhirFamilyHistoryRelation = class;
  TFhirFamilyHistoryRelationList = class;
  TFhirFamilyHistoryRelationCondition = class;
  TFhirFamilyHistoryRelationConditionList = class;
  TFhirGroupCharacteristic = class;
  TFhirGroupCharacteristicList = class;
  TFhirImagingStudySeries = class;
  TFhirImagingStudySeriesList = class;
  TFhirImagingStudySeriesInstance = class;
  TFhirImagingStudySeriesInstanceList = class;
  TFhirImmunizationExplanation = class;
  TFhirImmunizationExplanationList = class;
  TFhirImmunizationReaction = class;
  TFhirImmunizationReactionList = class;
  TFhirImmunizationVaccinationProtocol = class;
  TFhirImmunizationVaccinationProtocolList = class;
  TFhirImmunizationRecommendationRecommendation = class;
  TFhirImmunizationRecommendationRecommendationList = class;
  TFhirImmunizationRecommendationRecommendationDateCriterion = class;
  TFhirImmunizationRecommendationRecommendationDateCriterionList = class;
  TFhirImmunizationRecommendationRecommendationProtocol = class;
  TFhirImmunizationRecommendationRecommendationProtocolList = class;
  TFhirListEntry = class;
  TFhirListEntryList = class;
  TFhirLocationPosition = class;
  TFhirLocationPositionList = class;
  TFhirMedicationProduct = class;
  TFhirMedicationProductList = class;
  TFhirMedicationProductIngredient = class;
  TFhirMedicationProductIngredientList = class;
  TFhirMedicationPackage = class;
  TFhirMedicationPackageList = class;
  TFhirMedicationPackageContent = class;
  TFhirMedicationPackageContentList = class;
  TFhirMedicationAdministrationDosage = class;
  TFhirMedicationAdministrationDosageList = class;
  TFhirMedicationDispenseDispense = class;
  TFhirMedicationDispenseDispenseList = class;
  TFhirMedicationDispenseDispenseDosage = class;
  TFhirMedicationDispenseDispenseDosageList = class;
  TFhirMedicationDispenseSubstitution = class;
  TFhirMedicationDispenseSubstitutionList = class;
  TFhirMedicationPrescriptionDosageInstruction = class;
  TFhirMedicationPrescriptionDosageInstructionList = class;
  TFhirMedicationPrescriptionDispense = class;
  TFhirMedicationPrescriptionDispenseList = class;
  TFhirMedicationPrescriptionSubstitution = class;
  TFhirMedicationPrescriptionSubstitutionList = class;
  TFhirMedicationStatementDosage = class;
  TFhirMedicationStatementDosageList = class;
  TFhirMessageHeaderResponse = class;
  TFhirMessageHeaderResponseList = class;
  TFhirMessageHeaderSource = class;
  TFhirMessageHeaderSourceList = class;
  TFhirMessageHeaderDestination = class;
  TFhirMessageHeaderDestinationList = class;
  TFhirObservationReferenceRange = class;
  TFhirObservationReferenceRangeList = class;
  TFhirObservationRelated = class;
  TFhirObservationRelatedList = class;
  TFhirOperationOutcomeIssue = class;
  TFhirOperationOutcomeIssueList = class;
  TFhirOrderWhen = class;
  TFhirOrderWhenList = class;
  TFhirOrganizationContact = class;
  TFhirOrganizationContactList = class;
  TFhirPatientContact = class;
  TFhirPatientContactList = class;
  TFhirPatientAnimal = class;
  TFhirPatientAnimalList = class;
  TFhirPatientLink = class;
  TFhirPatientLinkList = class;
  TFhirPractitionerQualification = class;
  TFhirPractitionerQualificationList = class;
  TFhirProcedurePerformer = class;
  TFhirProcedurePerformerList = class;
  TFhirProcedureRelatedItem = class;
  TFhirProcedureRelatedItemList = class;
  TFhirProfileMapping = class;
  TFhirProfileMappingList = class;
  TFhirProfileStructure = class;
  TFhirProfileStructureList = class;
  TFhirProfileStructureElement = class;
  TFhirProfileStructureElementList = class;
  TFhirProfileStructureElementSlicing = class;
  TFhirProfileStructureElementSlicingList = class;
  TFhirProfileStructureElementDefinition = class;
  TFhirProfileStructureElementDefinitionList = class;
  TFhirProfileStructureElementDefinitionType = class;
  TFhirProfileStructureElementDefinitionTypeList = class;
  TFhirProfileStructureElementDefinitionConstraint = class;
  TFhirProfileStructureElementDefinitionConstraintList = class;
  TFhirProfileStructureElementDefinitionBinding = class;
  TFhirProfileStructureElementDefinitionBindingList = class;
  TFhirProfileStructureElementDefinitionMapping = class;
  TFhirProfileStructureElementDefinitionMappingList = class;
  TFhirProfileStructureSearchParam = class;
  TFhirProfileStructureSearchParamList = class;
  TFhirProfileExtensionDefn = class;
  TFhirProfileExtensionDefnList = class;
  TFhirProfileQuery = class;
  TFhirProfileQueryList = class;
  TFhirProvenanceAgent = class;
  TFhirProvenanceAgentList = class;
  TFhirProvenanceEntity = class;
  TFhirProvenanceEntityList = class;
  TFhirQueryResponse = class;
  TFhirQueryResponseList = class;
  TFhirQuestionnaireGroup = class;
  TFhirQuestionnaireGroupList = class;
  TFhirQuestionnaireGroupQuestion = class;
  TFhirQuestionnaireGroupQuestionList = class;
  TFhirSecurityEventEvent = class;
  TFhirSecurityEventEventList = class;
  TFhirSecurityEventParticipant = class;
  TFhirSecurityEventParticipantList = class;
  TFhirSecurityEventParticipantNetwork = class;
  TFhirSecurityEventParticipantNetworkList = class;
  TFhirSecurityEventSource = class;
  TFhirSecurityEventSourceList = class;
  TFhirSecurityEventObject = class;
  TFhirSecurityEventObjectList = class;
  TFhirSecurityEventObjectDetail = class;
  TFhirSecurityEventObjectDetailList = class;
  TFhirSpecimenSource = class;
  TFhirSpecimenSourceList = class;
  TFhirSpecimenCollection = class;
  TFhirSpecimenCollectionList = class;
  TFhirSpecimenTreatment = class;
  TFhirSpecimenTreatmentList = class;
  TFhirSpecimenContainer = class;
  TFhirSpecimenContainerList = class;
  TFhirSubstanceInstance = class;
  TFhirSubstanceInstanceList = class;
  TFhirSubstanceIngredient = class;
  TFhirSubstanceIngredientList = class;
  TFhirSupplyDispense = class;
  TFhirSupplyDispenseList = class;
  TFhirValueSetDefine = class;
  TFhirValueSetDefineList = class;
  TFhirValueSetDefineConcept = class;
  TFhirValueSetDefineConceptList = class;
  TFhirValueSetCompose = class;
  TFhirValueSetComposeList = class;
  TFhirValueSetComposeInclude = class;
  TFhirValueSetComposeIncludeList = class;
  TFhirValueSetComposeIncludeFilter = class;
  TFhirValueSetComposeIncludeFilterList = class;
  TFhirValueSetExpansion = class;
  TFhirValueSetExpansionList = class;
  TFhirValueSetExpansionContains = class;
  TFhirValueSetExpansionContainsList = class;

  {@Class TFhirAdverseReactionSymptom : TFhirElement
    The signs and symptoms that were observed as part of the reaction.
  }
  {!.Net HL7Connect.Fhir.AdverseReactionSymptom}
  TFhirAdverseReactionSymptom = class (TFhirBackboneElement)
  private
    FCode : TFhirCodeableConcept;
    FSeverity : TFhirEnum;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSeverity(value : TFhirEnum);
    Function GetSeverityST : TFhirReactionSeverity;
    Procedure SetSeverityST(value : TFhirReactionSeverity);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirAdverseReactionSymptom; overload;
    function Clone : TFhirAdverseReactionSymptom; overload;
    {!script show}
  published
    {@member code
      Indicates the specific sign or symptom that was observed.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member severity
      The severity of the sign or symptom.
    }
    property severity : TFhirEnum read FSeverity write SetSeverity;
    {@member severityST
      Typed access to The severity of the sign or symptom.
    }
    property severityST : TFhirReactionSeverity read GetSeverityST write SetSeverityST;

  end;


  {@Class TFhirAdverseReactionSymptomList
    A list of FhirAdverseReactionSymptom
  }
  {!.Net HL7Connect.Fhir.AdverseReactionSymptomList}
  TFhirAdverseReactionSymptomList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdverseReactionSymptom;
    procedure SetItemN(index : Integer; value : TFhirAdverseReactionSymptom);
  public
    {!script hide}
    function Link : TFhirAdverseReactionSymptomList; Overload;
    function Clone : TFhirAdverseReactionSymptomList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirAdverseReactionSymptom to the end of the list.
    }
    function Append : TFhirAdverseReactionSymptom;

    
    {@member AddItem
      Add an already existing FhirAdverseReactionSymptom to the end of the list.
    }
    procedure AddItem(value : TFhirAdverseReactionSymptom);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirAdverseReactionSymptom) : Integer;
    

    {@member Insert
      Insert FhirAdverseReactionSymptom before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirAdverseReactionSymptom;
    

    {@member InsertItem
       Insert an existing FhirAdverseReactionSymptom before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirAdverseReactionSymptom);
    
    {@member Item
       Get the iIndexth FhirAdverseReactionSymptom. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirAdverseReactionSymptom. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirAdverseReactionSymptom);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirAdverseReactionSymptom;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirAdverseReactionSymptoms[index : Integer] : TFhirAdverseReactionSymptom read GetItemN write SetItemN; default;
  End;


  {@Class TFhirAdverseReactionExposure : TFhirElement
    An exposure to a substance that preceded a reaction occurrence.
  }
  {!.Net HL7Connect.Fhir.AdverseReactionExposure}
  TFhirAdverseReactionExposure = class (TFhirBackboneElement)
  private
    FDate : TFhirDateTime;
    FType_ : TFhirEnum;
    FCausalityExpectation : TFhirEnum;
    FSubstance : TFhirResourceReference{TFhirSubstance};
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TDateAndTime;
    Procedure SetDateST(value : TDateAndTime);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirExposureType;
    Procedure SetType_ST(value : TFhirExposureType);
    Procedure SetCausalityExpectation(value : TFhirEnum);
    Function GetCausalityExpectationST : TFhirCausalityExpectation;
    Procedure SetCausalityExpectationST(value : TFhirCausalityExpectation);
    Procedure SetSubstance(value : TFhirResourceReference{TFhirSubstance});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirAdverseReactionExposure; overload;
    function Clone : TFhirAdverseReactionExposure; overload;
    {!script show}
  published
    {@member date
      Identifies the initial date of the exposure that is suspected to be related to the reaction.
    }
    property date : TFhirDateTime read FDate write SetDate;
    {@member dateST
      Typed access to Identifies the initial date of the exposure that is suspected to be related to the reaction.
    }
    property dateST : TDateAndTime read GetDateST write SetDateST;

    {@member type_
      The type of exposure: Drug Administration, Immunization, Coincidental.
    }
    property type_ : TFhirEnum read FType_ write SetType_;
    {@member type_ST
      Typed access to The type of exposure: Drug Administration, Immunization, Coincidental.
    }
    property type_ST : TFhirExposureType read GetType_ST write SetType_ST;

    {@member causalityExpectation
      A statement of how confident that the recorder was that this exposure caused the reaction.
    }
    property causalityExpectation : TFhirEnum read FCausalityExpectation write SetCausalityExpectation;
    {@member causalityExpectationST
      Typed access to A statement of how confident that the recorder was that this exposure caused the reaction.
    }
    property causalityExpectationST : TFhirCausalityExpectation read GetCausalityExpectationST write SetCausalityExpectationST;

    {@member substance
      Substance that is presumed to have caused the adverse reaction.
    }
    property substance : TFhirResourceReference{TFhirSubstance} read FSubstance write SetSubstance;

  end;


  {@Class TFhirAdverseReactionExposureList
    A list of FhirAdverseReactionExposure
  }
  {!.Net HL7Connect.Fhir.AdverseReactionExposureList}
  TFhirAdverseReactionExposureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdverseReactionExposure;
    procedure SetItemN(index : Integer; value : TFhirAdverseReactionExposure);
  public
    {!script hide}
    function Link : TFhirAdverseReactionExposureList; Overload;
    function Clone : TFhirAdverseReactionExposureList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirAdverseReactionExposure to the end of the list.
    }
    function Append : TFhirAdverseReactionExposure;

    
    {@member AddItem
      Add an already existing FhirAdverseReactionExposure to the end of the list.
    }
    procedure AddItem(value : TFhirAdverseReactionExposure);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirAdverseReactionExposure) : Integer;
    

    {@member Insert
      Insert FhirAdverseReactionExposure before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirAdverseReactionExposure;
    

    {@member InsertItem
       Insert an existing FhirAdverseReactionExposure before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirAdverseReactionExposure);
    
    {@member Item
       Get the iIndexth FhirAdverseReactionExposure. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirAdverseReactionExposure. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirAdverseReactionExposure);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirAdverseReactionExposure;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirAdverseReactionExposures[index : Integer] : TFhirAdverseReactionExposure read GetItemN write SetItemN; default;
  End;


  {@Class TFhirCarePlanParticipant : TFhirElement
    Identifies all people and organizations who are expected to be involved in the care envisioned by this plan.
  }
  {!.Net HL7Connect.Fhir.CarePlanParticipant}
  TFhirCarePlanParticipant = class (TFhirBackboneElement)
  private
    FRole : TFhirCodeableConcept;
    FMember : TFhirResourceReference{Resource};
    Procedure SetRole(value : TFhirCodeableConcept);
    Procedure SetMember(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirCarePlanParticipant; overload;
    function Clone : TFhirCarePlanParticipant; overload;
    {!script show}
  published
    {@member role
      Indicates specific responsibility of an individual within the care plan.  E.g. "Primary physician", "Team coordinator", "Caregiver", etc.
    }
    property role : TFhirCodeableConcept read FRole write SetRole;

    {@member member
      The specific person or organization who is participating/expected to participate in the care plan.
    }
    property member : TFhirResourceReference{Resource} read FMember write SetMember;

  end;


  {@Class TFhirCarePlanParticipantList
    A list of FhirCarePlanParticipant
  }
  {!.Net HL7Connect.Fhir.CarePlanParticipantList}
  TFhirCarePlanParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCarePlanParticipant;
    procedure SetItemN(index : Integer; value : TFhirCarePlanParticipant);
  public
    {!script hide}
    function Link : TFhirCarePlanParticipantList; Overload;
    function Clone : TFhirCarePlanParticipantList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirCarePlanParticipant to the end of the list.
    }
    function Append : TFhirCarePlanParticipant;

    
    {@member AddItem
      Add an already existing FhirCarePlanParticipant to the end of the list.
    }
    procedure AddItem(value : TFhirCarePlanParticipant);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirCarePlanParticipant) : Integer;
    

    {@member Insert
      Insert FhirCarePlanParticipant before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirCarePlanParticipant;
    

    {@member InsertItem
       Insert an existing FhirCarePlanParticipant before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirCarePlanParticipant);
    
    {@member Item
       Get the iIndexth FhirCarePlanParticipant. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirCarePlanParticipant. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirCarePlanParticipant);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirCarePlanParticipant;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirCarePlanParticipants[index : Integer] : TFhirCarePlanParticipant read GetItemN write SetItemN; default;
  End;


  {@Class TFhirCarePlanGoal : TFhirElement
    Describes the intended objective(s) of carrying out the Care Plan.
  }
  {!.Net HL7Connect.Fhir.CarePlanGoal}
  TFhirCarePlanGoal = class (TFhirBackboneElement)
  private
    FDescription : TFhirString;
    FStatus : TFhirEnum;
    FNotes : TFhirString;
    FconcernList : TFhirResourceReferenceList{TFhirCondition};
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirCarePlanGoalStatus;
    Procedure SetStatusST(value : TFhirCarePlanGoalStatus);
    Procedure SetNotes(value : TFhirString);
    Function GetNotesST : String;
    Procedure SetNotesST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirCarePlanGoal; overload;
    function Clone : TFhirCarePlanGoal; overload;
    {!script show}
  published
    {@member description
      Human-readable description of a specific desired objective of the care plan.
    }
    property description : TFhirString read FDescription write SetDescription;
    {@member descriptionST
      Typed access to Human-readable description of a specific desired objective of the care plan.
    }
    property descriptionST : String read GetDescriptionST write SetDescriptionST;

    {@member status
      Indicates whether the goal has been reached and is still considered relevant.
    }
    property status : TFhirEnum read FStatus write SetStatus;
    {@member statusST
      Typed access to Indicates whether the goal has been reached and is still considered relevant.
    }
    property statusST : TFhirCarePlanGoalStatus read GetStatusST write SetStatusST;

    {@member notes
      Any comments related to the goal.
    }
    property notes : TFhirString read FNotes write SetNotes;
    {@member notesST
      Typed access to Any comments related to the goal.
    }
    property notesST : String read GetNotesST write SetNotesST;

    {@member concernList
      The identified conditions that this goal relates to - the condition that caused it to be created, or that it is intended to address.
    }
    property concernList : TFhirResourceReferenceList{TFhirCondition} read FConcernList;

  end;


  {@Class TFhirCarePlanGoalList
    A list of FhirCarePlanGoal
  }
  {!.Net HL7Connect.Fhir.CarePlanGoalList}
  TFhirCarePlanGoalList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCarePlanGoal;
    procedure SetItemN(index : Integer; value : TFhirCarePlanGoal);
  public
    {!script hide}
    function Link : TFhirCarePlanGoalList; Overload;
    function Clone : TFhirCarePlanGoalList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirCarePlanGoal to the end of the list.
    }
    function Append : TFhirCarePlanGoal;

    
    {@member AddItem
      Add an already existing FhirCarePlanGoal to the end of the list.
    }
    procedure AddItem(value : TFhirCarePlanGoal);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirCarePlanGoal) : Integer;
    

    {@member Insert
      Insert FhirCarePlanGoal before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirCarePlanGoal;
    

    {@member InsertItem
       Insert an existing FhirCarePlanGoal before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirCarePlanGoal);
    
    {@member Item
       Get the iIndexth FhirCarePlanGoal. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirCarePlanGoal. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirCarePlanGoal);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirCarePlanGoal;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirCarePlanGoals[index : Integer] : TFhirCarePlanGoal read GetItemN write SetItemN; default;
  End;


  {@Class TFhirCarePlanActivity : TFhirElement
    Identifies a planned action to occur as part of the plan.  For example, a medication to be used, lab tests to perform, self-monitoring, education, etc.
  }
  {!.Net HL7Connect.Fhir.CarePlanActivity}
  TFhirCarePlanActivity = class (TFhirBackboneElement)
  private
    FgoalList : TFhirStringList;
    FStatus : TFhirEnum;
    FProhibited : TFhirBoolean;
    FactionResultingList : TFhirResourceReferenceList{Resource};
    FNotes : TFhirString;
    FDetail : TFhirResourceReference{Resource};
    FSimple : TFhirCarePlanActivitySimple;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirCarePlanActivityStatus;
    Procedure SetStatusST(value : TFhirCarePlanActivityStatus);
    Procedure SetProhibited(value : TFhirBoolean);
    Function GetProhibitedST : Boolean;
    Procedure SetProhibitedST(value : Boolean);
    Procedure SetNotes(value : TFhirString);
    Function GetNotesST : String;
    Procedure SetNotesST(value : String);
    Procedure SetDetail(value : TFhirResourceReference{Resource});
    Procedure SetSimple(value : TFhirCarePlanActivitySimple);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirCarePlanActivity; overload;
    function Clone : TFhirCarePlanActivity; overload;
    {!script show}
  published
    {@member goalList
      Internal reference that identifies the goals that this activity is intended to contribute towards meeting.
    }
    property goalList : TFhirStringList read FGoalList;

    {@member status
      Identifies what progress is being made for the specific activity.
    }
    property status : TFhirEnum read FStatus write SetStatus;
    {@member statusST
      Typed access to Identifies what progress is being made for the specific activity.
    }
    property statusST : TFhirCarePlanActivityStatus read GetStatusST write SetStatusST;

    {@member prohibited
      If true, indicates that the described activity is one that must NOT be engaged in when following the plan.
    }
    property prohibited : TFhirBoolean read FProhibited write SetProhibited;
    {@member prohibitedST
      Typed access to If true, indicates that the described activity is one that must NOT be engaged in when following the plan.
    }
    property prohibitedST : Boolean read GetProhibitedST write SetProhibitedST;

    {@member actionResultingList
      Resources that describe follow-on actions resulting from the plan, such as drug prescriptions, encounter records, appointments, etc.
    }
    property actionResultingList : TFhirResourceReferenceList{Resource} read FActionResultingList;

    {@member notes
      Notes about the execution of the activity.
    }
    property notes : TFhirString read FNotes write SetNotes;
    {@member notesST
      Typed access to Notes about the execution of the activity.
    }
    property notesST : String read GetNotesST write SetNotesST;

    {@member detail
      The details of the proposed activity represented in a specific resource.
    }
    property detail : TFhirResourceReference{Resource} read FDetail write SetDetail;

    {@member simple
      A simple summary of details suitable for a general care plan system (e.g. form driven) that doesn't know about specific resources such as procedure etc.
    }
    property simple : TFhirCarePlanActivitySimple read FSimple write SetSimple;

  end;


  {@Class TFhirCarePlanActivityList
    A list of FhirCarePlanActivity
  }
  {!.Net HL7Connect.Fhir.CarePlanActivityList}
  TFhirCarePlanActivityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCarePlanActivity;
    procedure SetItemN(index : Integer; value : TFhirCarePlanActivity);
  public
    {!script hide}
    function Link : TFhirCarePlanActivityList; Overload;
    function Clone : TFhirCarePlanActivityList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirCarePlanActivity to the end of the list.
    }
    function Append : TFhirCarePlanActivity;

    
    {@member AddItem
      Add an already existing FhirCarePlanActivity to the end of the list.
    }
    procedure AddItem(value : TFhirCarePlanActivity);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirCarePlanActivity) : Integer;
    

    {@member Insert
      Insert FhirCarePlanActivity before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirCarePlanActivity;
    

    {@member InsertItem
       Insert an existing FhirCarePlanActivity before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirCarePlanActivity);
    
    {@member Item
       Get the iIndexth FhirCarePlanActivity. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirCarePlanActivity. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirCarePlanActivity);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirCarePlanActivity;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirCarePlanActivities[index : Integer] : TFhirCarePlanActivity read GetItemN write SetItemN; default;
  End;


  {@Class TFhirCarePlanActivitySimple : TFhirElement
    A simple summary of details suitable for a general care plan system (e.g. form driven) that doesn't know about specific resources such as procedure etc.
  }
  {!.Net HL7Connect.Fhir.CarePlanActivitySimple}
  TFhirCarePlanActivitySimple = class (TFhirBackboneElement)
  private
    FCategory : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FTiming : TFhirType;
    FLocation : TFhirResourceReference{TFhirLocation};
    FperformerList : TFhirResourceReferenceList{Resource};
    FProduct : TFhirResourceReference{Resource};
    FDailyAmount : TFhirQuantity;
    FQuantity : TFhirQuantity;
    FDetails : TFhirString;
    Procedure SetCategory(value : TFhirEnum);
    Function GetCategoryST : TFhirCarePlanActivityCategory;
    Procedure SetCategoryST(value : TFhirCarePlanActivityCategory);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetTiming(value : TFhirType);
    Procedure SetLocation(value : TFhirResourceReference{TFhirLocation});
    Procedure SetProduct(value : TFhirResourceReference{Resource});
    Procedure SetDailyAmount(value : TFhirQuantity);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetDetails(value : TFhirString);
    Function GetDetailsST : String;
    Procedure SetDetailsST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirCarePlanActivitySimple; overload;
    function Clone : TFhirCarePlanActivitySimple; overload;
    {!script show}
  published
    {@member category
      High-level categorization of the type of activity in a care plan.
    }
    property category : TFhirEnum read FCategory write SetCategory;
    {@member categoryST
      Typed access to High-level categorization of the type of activity in a care plan.
    }
    property categoryST : TFhirCarePlanActivityCategory read GetCategoryST write SetCategoryST;

    {@member code
      Detailed description of the type of activity.  E.g. What lab test, what procedure, what kind of encounter.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member timing
      The period, timing or frequency upon which the described activity is to occur.
    }
    property timing : TFhirType read FTiming write SetTiming;

    {@member location
      Identifies the facility where the activity will occur.  E.g. home, hospital, specific clinic, etc.
    }
    property location : TFhirResourceReference{TFhirLocation} read FLocation write SetLocation;

    {@member performerList
      Identifies who's expected to be involved in the activity.
    }
    property performerList : TFhirResourceReferenceList{Resource} read FPerformerList;

    {@member product
      Identifies the food, drug or other product being consumed or supplied in the activity.
    }
    property product : TFhirResourceReference{Resource} read FProduct write SetProduct;

    {@member dailyAmount
      Identifies the quantity expected to be consumed in a given day.
    }
    property dailyAmount : TFhirQuantity read FDailyAmount write SetDailyAmount;

    {@member quantity
      Identifies the quantity expected to be supplied.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;

    {@member details
      This provides a textual description of constraints on the activity occurrence, including relation to other activities.  It may also include objectives, pre-conditions and end-conditions.  Finally, it may convey specifics about the activity such as body site, method, route, etc.
    }
    property details : TFhirString read FDetails write SetDetails;
    {@member detailsST
      Typed access to This provides a textual description of constraints on the activity occurrence, including relation to other activities.  It may also include objectives, pre-conditions and end-conditions.  Finally, it may convey specifics about the activity such as body site, method, route, etc.
    }
    property detailsST : String read GetDetailsST write SetDetailsST;

  end;


  {@Class TFhirCarePlanActivitySimpleList
    A list of FhirCarePlanActivitySimple
  }
  {!.Net HL7Connect.Fhir.CarePlanActivitySimpleList}
  TFhirCarePlanActivitySimpleList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCarePlanActivitySimple;
    procedure SetItemN(index : Integer; value : TFhirCarePlanActivitySimple);
  public
    {!script hide}
    function Link : TFhirCarePlanActivitySimpleList; Overload;
    function Clone : TFhirCarePlanActivitySimpleList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirCarePlanActivitySimple to the end of the list.
    }
    function Append : TFhirCarePlanActivitySimple;

    
    {@member AddItem
      Add an already existing FhirCarePlanActivitySimple to the end of the list.
    }
    procedure AddItem(value : TFhirCarePlanActivitySimple);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirCarePlanActivitySimple) : Integer;
    

    {@member Insert
      Insert FhirCarePlanActivitySimple before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirCarePlanActivitySimple;
    

    {@member InsertItem
       Insert an existing FhirCarePlanActivitySimple before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirCarePlanActivitySimple);
    
    {@member Item
       Get the iIndexth FhirCarePlanActivitySimple. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirCarePlanActivitySimple. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirCarePlanActivitySimple);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirCarePlanActivitySimple;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirCarePlanActivitySimples[index : Integer] : TFhirCarePlanActivitySimple read GetItemN write SetItemN; default;
  End;


  {@Class TFhirCompositionAttester : TFhirElement
    A participant who has attested to the accuracy of the composition/document.
  }
  {!.Net HL7Connect.Fhir.CompositionAttester}
  TFhirCompositionAttester = class (TFhirBackboneElement)
  private
    FMode : TFhirEnumList;
    FTime : TFhirDateTime;
    FParty : TFhirResourceReference{Resource};
    Function GetModeST : TFhirCompositionAttestationModeList;
    Procedure SetModeST(value : TFhirCompositionAttestationModeList);
    Procedure SetTime(value : TFhirDateTime);
    Function GetTimeST : TDateAndTime;
    Procedure SetTimeST(value : TDateAndTime);
    Procedure SetParty(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirCompositionAttester; overload;
    function Clone : TFhirCompositionAttester; overload;
    {!script show}
  published
    {@member mode
      The type of attestation the authenticator offers.
    }
    property mode : TFhirEnumList read FMode;
    {@member modeST
      Typed access to The type of attestation the authenticator offers.
    }
    property modeST : TFhirCompositionAttestationModeList read GetModeST write SetModeST;
    {@member time
      When composition was attested by the party.
    }
    property time : TFhirDateTime read FTime write SetTime;
    {@member timeST
      Typed access to When composition was attested by the party.
    }
    property timeST : TDateAndTime read GetTimeST write SetTimeST;

    {@member party
      Who attested the composition in the specified way.
    }
    property party : TFhirResourceReference{Resource} read FParty write SetParty;

  end;


  {@Class TFhirCompositionAttesterList
    A list of FhirCompositionAttester
  }
  {!.Net HL7Connect.Fhir.CompositionAttesterList}
  TFhirCompositionAttesterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCompositionAttester;
    procedure SetItemN(index : Integer; value : TFhirCompositionAttester);
  public
    {!script hide}
    function Link : TFhirCompositionAttesterList; Overload;
    function Clone : TFhirCompositionAttesterList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirCompositionAttester to the end of the list.
    }
    function Append : TFhirCompositionAttester;

    
    {@member AddItem
      Add an already existing FhirCompositionAttester to the end of the list.
    }
    procedure AddItem(value : TFhirCompositionAttester);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirCompositionAttester) : Integer;
    

    {@member Insert
      Insert FhirCompositionAttester before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirCompositionAttester;
    

    {@member InsertItem
       Insert an existing FhirCompositionAttester before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirCompositionAttester);
    
    {@member Item
       Get the iIndexth FhirCompositionAttester. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirCompositionAttester. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirCompositionAttester);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirCompositionAttester;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirCompositionAttesters[index : Integer] : TFhirCompositionAttester read GetItemN write SetItemN; default;
  End;


  {@Class TFhirCompositionEvent : TFhirElement
    The main event/act/item, such as a colonoscopy or an appendectomy, being documented.
  }
  {!.Net HL7Connect.Fhir.CompositionEvent}
  TFhirCompositionEvent = class (TFhirBackboneElement)
  private
    FcodeList : TFhirCodeableConceptList;
    FPeriod : TFhirPeriod;
    FdetailList : TFhirResourceReferenceList{Resource};
    Procedure SetPeriod(value : TFhirPeriod);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirCompositionEvent; overload;
    function Clone : TFhirCompositionEvent; overload;
    {!script show}
  published
    {@member codeList
      This list of codes represents the main clinical acts, such as a colonoscopy or an appendectomy, being documented. In some cases, the event is inherent in the typeCode, such as a "History and Physical Report" in which the procedure being documented is necessarily a "History and Physical" act.
    }
    property codeList : TFhirCodeableConceptList read FCodeList;

    {@member period
      The period of time covered by the documentation. There is no assertion that the documentation is a complete representation for this period, only that it documents events during this time.
    }
    property period : TFhirPeriod read FPeriod write SetPeriod;

    {@member detailList
      Full details for the event(s) the composition/documentation consents.
    }
    property detailList : TFhirResourceReferenceList{Resource} read FDetailList;

  end;


  {@Class TFhirCompositionEventList
    A list of FhirCompositionEvent
  }
  {!.Net HL7Connect.Fhir.CompositionEventList}
  TFhirCompositionEventList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCompositionEvent;
    procedure SetItemN(index : Integer; value : TFhirCompositionEvent);
  public
    {!script hide}
    function Link : TFhirCompositionEventList; Overload;
    function Clone : TFhirCompositionEventList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirCompositionEvent to the end of the list.
    }
    function Append : TFhirCompositionEvent;

    
    {@member AddItem
      Add an already existing FhirCompositionEvent to the end of the list.
    }
    procedure AddItem(value : TFhirCompositionEvent);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirCompositionEvent) : Integer;
    

    {@member Insert
      Insert FhirCompositionEvent before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirCompositionEvent;
    

    {@member InsertItem
       Insert an existing FhirCompositionEvent before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirCompositionEvent);
    
    {@member Item
       Get the iIndexth FhirCompositionEvent. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirCompositionEvent. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirCompositionEvent);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirCompositionEvent;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirCompositionEvents[index : Integer] : TFhirCompositionEvent read GetItemN write SetItemN; default;
  End;


  {@Class TFhirCompositionSection : TFhirElement
    The root of the sections that make up the composition.
  }
  {!.Net HL7Connect.Fhir.CompositionSection}
  TFhirCompositionSection = class (TFhirBackboneElement)
  private
    FTitle : TFhirString;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirResourceReference{Resource};
    FContent : TFhirResourceReference{Resource};
    FsectionList : TFhirCompositionSectionList;
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirResourceReference{Resource});
    Procedure SetContent(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirCompositionSection; overload;
    function Clone : TFhirCompositionSection; overload;
    {!script show}
  published
    {@member title
      The heading for this particular section.  This will be part of the rendered content for the document.
    }
    property title : TFhirString read FTitle write SetTitle;
    {@member titleST
      Typed access to The heading for this particular section.  This will be part of the rendered content for the document.
    }
    property titleST : String read GetTitleST write SetTitleST;

    {@member code
      A code identifying the kind of content contained within the section.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member subject
      Identifies the primary subject of the section.
    }
    property subject : TFhirResourceReference{Resource} read FSubject write SetSubject;

    {@member content
      Identifies the discrete data that provides the content for the section.
    }
    property content : TFhirResourceReference{Resource} read FContent write SetContent;

    {@member sectionList
      A nested sub-section within this section.
    }
    property sectionList : TFhirCompositionSectionList read FSectionList;

  end;


  {@Class TFhirCompositionSectionList
    A list of FhirCompositionSection
  }
  {!.Net HL7Connect.Fhir.CompositionSectionList}
  TFhirCompositionSectionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCompositionSection;
    procedure SetItemN(index : Integer; value : TFhirCompositionSection);
  public
    {!script hide}
    function Link : TFhirCompositionSectionList; Overload;
    function Clone : TFhirCompositionSectionList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirCompositionSection to the end of the list.
    }
    function Append : TFhirCompositionSection;

    
    {@member AddItem
      Add an already existing FhirCompositionSection to the end of the list.
    }
    procedure AddItem(value : TFhirCompositionSection);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirCompositionSection) : Integer;
    

    {@member Insert
      Insert FhirCompositionSection before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirCompositionSection;
    

    {@member InsertItem
       Insert an existing FhirCompositionSection before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirCompositionSection);
    
    {@member Item
       Get the iIndexth FhirCompositionSection. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirCompositionSection. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirCompositionSection);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirCompositionSection;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirCompositionSections[index : Integer] : TFhirCompositionSection read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConceptMapConcept : TFhirElement
    Mappings for a concept from the source valueset.
  }
  {!.Net HL7Connect.Fhir.ConceptMapConcept}
  TFhirConceptMapConcept = class (TFhirBackboneElement)
  private
    FSystem : TFhirUri;
    FCode : TFhirCode;
    FdependsOnList : TFhirConceptMapConceptDependsOnList;
    FmapList : TFhirConceptMapConceptMapList;
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConceptMapConcept; overload;
    function Clone : TFhirConceptMapConcept; overload;
    {!script show}
  published
    {@member system
      System that defines the concept being mapped.
    }
    property system : TFhirUri read FSystem write SetSystem;
    {@member systemST
      Typed access to System that defines the concept being mapped.
    }
    property systemST : String read GetSystemST write SetSystemST;

    {@member code
      Identifies concept being mapped.
    }
    property code : TFhirCode read FCode write SetCode;
    {@member codeST
      Typed access to Identifies concept being mapped.
    }
    property codeST : String read GetCodeST write SetCodeST;

    {@member dependsOnList
      A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified concept can be resolved, and it has the specified value.
    }
    property dependsOnList : TFhirConceptMapConceptDependsOnList read FDependsOnList;

    {@member mapList
      A concept from the target value set that this concept maps to.
    }
    property mapList : TFhirConceptMapConceptMapList read FMapList;

  end;


  {@Class TFhirConceptMapConceptList
    A list of FhirConceptMapConcept
  }
  {!.Net HL7Connect.Fhir.ConceptMapConceptList}
  TFhirConceptMapConceptList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConceptMapConcept;
    procedure SetItemN(index : Integer; value : TFhirConceptMapConcept);
  public
    {!script hide}
    function Link : TFhirConceptMapConceptList; Overload;
    function Clone : TFhirConceptMapConceptList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConceptMapConcept to the end of the list.
    }
    function Append : TFhirConceptMapConcept;

    
    {@member AddItem
      Add an already existing FhirConceptMapConcept to the end of the list.
    }
    procedure AddItem(value : TFhirConceptMapConcept);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConceptMapConcept) : Integer;
    

    {@member Insert
      Insert FhirConceptMapConcept before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConceptMapConcept;
    

    {@member InsertItem
       Insert an existing FhirConceptMapConcept before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConceptMapConcept);
    
    {@member Item
       Get the iIndexth FhirConceptMapConcept. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConceptMapConcept. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConceptMapConcept);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConceptMapConcept;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConceptMapConcepts[index : Integer] : TFhirConceptMapConcept read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConceptMapConceptDependsOn : TFhirElement
    A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified concept can be resolved, and it has the specified value.
  }
  {!.Net HL7Connect.Fhir.ConceptMapConceptDependsOn}
  TFhirConceptMapConceptDependsOn = class (TFhirBackboneElement)
  private
    FConcept : TFhirUri;
    FSystem : TFhirUri;
    FCode : TFhirCode;
    Procedure SetConcept(value : TFhirUri);
    Function GetConceptST : String;
    Procedure SetConceptST(value : String);
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConceptMapConceptDependsOn; overload;
    function Clone : TFhirConceptMapConceptDependsOn; overload;
    {!script show}
  published
    {@member concept
      A reference to a specific concept that holds a coded value. This can be an element in a FHIR resource, or a specific reference to a data element in a different specification (e.g. v2) or a general reference to a kind of data field, or a reference to a value set with an appropriately narrow definition.
    }
    property concept : TFhirUri read FConcept write SetConcept;
    {@member conceptST
      Typed access to A reference to a specific concept that holds a coded value. This can be an element in a FHIR resource, or a specific reference to a data element in a different specification (e.g. v2) or a general reference to a kind of data field, or a reference to a value set with an appropriately narrow definition.
    }
    property conceptST : String read GetConceptST write SetConceptST;

    {@member system
      System for a concept in the referenced concept.
    }
    property system : TFhirUri read FSystem write SetSystem;
    {@member systemST
      Typed access to System for a concept in the referenced concept.
    }
    property systemST : String read GetSystemST write SetSystemST;

    {@member code
      Code for a concept in the referenced concept.
    }
    property code : TFhirCode read FCode write SetCode;
    {@member codeST
      Typed access to Code for a concept in the referenced concept.
    }
    property codeST : String read GetCodeST write SetCodeST;

  end;


  {@Class TFhirConceptMapConceptDependsOnList
    A list of FhirConceptMapConceptDependsOn
  }
  {!.Net HL7Connect.Fhir.ConceptMapConceptDependsOnList}
  TFhirConceptMapConceptDependsOnList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConceptMapConceptDependsOn;
    procedure SetItemN(index : Integer; value : TFhirConceptMapConceptDependsOn);
  public
    {!script hide}
    function Link : TFhirConceptMapConceptDependsOnList; Overload;
    function Clone : TFhirConceptMapConceptDependsOnList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConceptMapConceptDependsOn to the end of the list.
    }
    function Append : TFhirConceptMapConceptDependsOn;

    
    {@member AddItem
      Add an already existing FhirConceptMapConceptDependsOn to the end of the list.
    }
    procedure AddItem(value : TFhirConceptMapConceptDependsOn);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConceptMapConceptDependsOn) : Integer;
    

    {@member Insert
      Insert FhirConceptMapConceptDependsOn before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConceptMapConceptDependsOn;
    

    {@member InsertItem
       Insert an existing FhirConceptMapConceptDependsOn before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConceptMapConceptDependsOn);
    
    {@member Item
       Get the iIndexth FhirConceptMapConceptDependsOn. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConceptMapConceptDependsOn. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConceptMapConceptDependsOn);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConceptMapConceptDependsOn;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConceptMapConceptDependsOns[index : Integer] : TFhirConceptMapConceptDependsOn read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConceptMapConceptMap : TFhirElement
    A concept from the target value set that this concept maps to.
  }
  {!.Net HL7Connect.Fhir.ConceptMapConceptMap}
  TFhirConceptMapConceptMap = class (TFhirBackboneElement)
  private
    FSystem : TFhirUri;
    FCode : TFhirCode;
    FEquivalence : TFhirEnum;
    FComments : TFhirString;
    FproductList : TFhirConceptMapConceptDependsOnList;
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetEquivalence(value : TFhirEnum);
    Function GetEquivalenceST : TFhirConceptEquivalence;
    Procedure SetEquivalenceST(value : TFhirConceptEquivalence);
    Procedure SetComments(value : TFhirString);
    Function GetCommentsST : String;
    Procedure SetCommentsST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConceptMapConceptMap; overload;
    function Clone : TFhirConceptMapConceptMap; overload;
    {!script show}
  published
    {@member system
      System of the target.
    }
    property system : TFhirUri read FSystem write SetSystem;
    {@member systemST
      Typed access to System of the target.
    }
    property systemST : String read GetSystemST write SetSystemST;

    {@member code
      Code that identifies the target concept.
    }
    property code : TFhirCode read FCode write SetCode;
    {@member codeST
      Typed access to Code that identifies the target concept.
    }
    property codeST : String read GetCodeST write SetCodeST;

    {@member equivalence
      equal | equivalent | wider | subsumes | narrower | specialises | inexact | unmatched | disjoint.
    }
    property equivalence : TFhirEnum read FEquivalence write SetEquivalence;
    {@member equivalenceST
      Typed access to equal | equivalent | wider | subsumes | narrower | specialises | inexact | unmatched | disjoint.
    }
    property equivalenceST : TFhirConceptEquivalence read GetEquivalenceST write SetEquivalenceST;

    {@member comments
      Description of status/issues in mapping.
    }
    property comments : TFhirString read FComments write SetComments;
    {@member commentsST
      Typed access to Description of status/issues in mapping.
    }
    property commentsST : String read GetCommentsST write SetCommentsST;

    {@member productList
      A set of additional outcomes from this mapping to other value sets. To properly execute this mapping, the specified value set must be mapped to some data element or source that is in context. The mapping may still be useful without a place for the additional data elements, but the equivalence cannot be relied on.
    }
    property productList : TFhirConceptMapConceptDependsOnList read FProductList;

  end;


  {@Class TFhirConceptMapConceptMapList
    A list of FhirConceptMapConceptMap
  }
  {!.Net HL7Connect.Fhir.ConceptMapConceptMapList}
  TFhirConceptMapConceptMapList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConceptMapConceptMap;
    procedure SetItemN(index : Integer; value : TFhirConceptMapConceptMap);
  public
    {!script hide}
    function Link : TFhirConceptMapConceptMapList; Overload;
    function Clone : TFhirConceptMapConceptMapList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConceptMapConceptMap to the end of the list.
    }
    function Append : TFhirConceptMapConceptMap;

    
    {@member AddItem
      Add an already existing FhirConceptMapConceptMap to the end of the list.
    }
    procedure AddItem(value : TFhirConceptMapConceptMap);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConceptMapConceptMap) : Integer;
    

    {@member Insert
      Insert FhirConceptMapConceptMap before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConceptMapConceptMap;
    

    {@member InsertItem
       Insert an existing FhirConceptMapConceptMap before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConceptMapConceptMap);
    
    {@member Item
       Get the iIndexth FhirConceptMapConceptMap. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConceptMapConceptMap. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConceptMapConceptMap);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConceptMapConceptMap;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConceptMapConceptMaps[index : Integer] : TFhirConceptMapConceptMap read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConditionStage : TFhirElement
    Clinical stage or grade of a condition. May include formal severity assessments.
  }
  {!.Net HL7Connect.Fhir.ConditionStage}
  TFhirConditionStage = class (TFhirBackboneElement)
  private
    FSummary : TFhirCodeableConcept;
    FassessmentList : TFhirResourceReferenceList{Resource};
    Procedure SetSummary(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConditionStage; overload;
    function Clone : TFhirConditionStage; overload;
    {!script show}
  published
    {@member summary
      A simple summary of the stage such as "Stage 3". The determination of the stage is disease-specific.
    }
    property summary : TFhirCodeableConcept read FSummary write SetSummary;

    {@member assessmentList
      Reference to a formal record of the evidence on which the staging assessment is based.
    }
    property assessmentList : TFhirResourceReferenceList{Resource} read FAssessmentList;

  end;


  {@Class TFhirConditionStageList
    A list of FhirConditionStage
  }
  {!.Net HL7Connect.Fhir.ConditionStageList}
  TFhirConditionStageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConditionStage;
    procedure SetItemN(index : Integer; value : TFhirConditionStage);
  public
    {!script hide}
    function Link : TFhirConditionStageList; Overload;
    function Clone : TFhirConditionStageList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConditionStage to the end of the list.
    }
    function Append : TFhirConditionStage;

    
    {@member AddItem
      Add an already existing FhirConditionStage to the end of the list.
    }
    procedure AddItem(value : TFhirConditionStage);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConditionStage) : Integer;
    

    {@member Insert
      Insert FhirConditionStage before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConditionStage;
    

    {@member InsertItem
       Insert an existing FhirConditionStage before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConditionStage);
    
    {@member Item
       Get the iIndexth FhirConditionStage. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConditionStage. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConditionStage);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConditionStage;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConditionStages[index : Integer] : TFhirConditionStage read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConditionEvidence : TFhirElement
    Supporting Evidence / manifestations that are the basis on which this condition is suspected or confirmed.
  }
  {!.Net HL7Connect.Fhir.ConditionEvidence}
  TFhirConditionEvidence = class (TFhirBackboneElement)
  private
    FCode : TFhirCodeableConcept;
    FdetailList : TFhirResourceReferenceList{Resource};
    Procedure SetCode(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConditionEvidence; overload;
    function Clone : TFhirConditionEvidence; overload;
    {!script show}
  published
    {@member code
      A manifestation or symptom that led to the recording of this condition.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member detailList
      Links to other relevant information, including pathology reports.
    }
    property detailList : TFhirResourceReferenceList{Resource} read FDetailList;

  end;


  {@Class TFhirConditionEvidenceList
    A list of FhirConditionEvidence
  }
  {!.Net HL7Connect.Fhir.ConditionEvidenceList}
  TFhirConditionEvidenceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConditionEvidence;
    procedure SetItemN(index : Integer; value : TFhirConditionEvidence);
  public
    {!script hide}
    function Link : TFhirConditionEvidenceList; Overload;
    function Clone : TFhirConditionEvidenceList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConditionEvidence to the end of the list.
    }
    function Append : TFhirConditionEvidence;

    
    {@member AddItem
      Add an already existing FhirConditionEvidence to the end of the list.
    }
    procedure AddItem(value : TFhirConditionEvidence);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConditionEvidence) : Integer;
    

    {@member Insert
      Insert FhirConditionEvidence before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConditionEvidence;
    

    {@member InsertItem
       Insert an existing FhirConditionEvidence before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConditionEvidence);
    
    {@member Item
       Get the iIndexth FhirConditionEvidence. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConditionEvidence. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConditionEvidence);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConditionEvidence;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConditionEvidences[index : Integer] : TFhirConditionEvidence read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConditionLocation : TFhirElement
    The anatomical location where this condition manifests itself.
  }
  {!.Net HL7Connect.Fhir.ConditionLocation}
  TFhirConditionLocation = class (TFhirBackboneElement)
  private
    FCode : TFhirCodeableConcept;
    FDetail : TFhirString;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetDetail(value : TFhirString);
    Function GetDetailST : String;
    Procedure SetDetailST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConditionLocation; overload;
    function Clone : TFhirConditionLocation; overload;
    {!script show}
  published
    {@member code
      Code that identifies the structural location.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member detail
      Detailed anatomical location information.
    }
    property detail : TFhirString read FDetail write SetDetail;
    {@member detailST
      Typed access to Detailed anatomical location information.
    }
    property detailST : String read GetDetailST write SetDetailST;

  end;


  {@Class TFhirConditionLocationList
    A list of FhirConditionLocation
  }
  {!.Net HL7Connect.Fhir.ConditionLocationList}
  TFhirConditionLocationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConditionLocation;
    procedure SetItemN(index : Integer; value : TFhirConditionLocation);
  public
    {!script hide}
    function Link : TFhirConditionLocationList; Overload;
    function Clone : TFhirConditionLocationList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConditionLocation to the end of the list.
    }
    function Append : TFhirConditionLocation;

    
    {@member AddItem
      Add an already existing FhirConditionLocation to the end of the list.
    }
    procedure AddItem(value : TFhirConditionLocation);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConditionLocation) : Integer;
    

    {@member Insert
      Insert FhirConditionLocation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConditionLocation;
    

    {@member InsertItem
       Insert an existing FhirConditionLocation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConditionLocation);
    
    {@member Item
       Get the iIndexth FhirConditionLocation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConditionLocation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConditionLocation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConditionLocation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConditionLocations[index : Integer] : TFhirConditionLocation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConditionRelatedItem : TFhirElement
    Further conditions, problems, diagnoses, procedures or events that are related in some way to this condition, or the substance that caused/triggered this Condition.
  }
  {!.Net HL7Connect.Fhir.ConditionRelatedItem}
  TFhirConditionRelatedItem = class (TFhirBackboneElement)
  private
    FType_ : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FTarget : TFhirResourceReference{Resource};
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirConditionRelationshipType;
    Procedure SetType_ST(value : TFhirConditionRelationshipType);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetTarget(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConditionRelatedItem; overload;
    function Clone : TFhirConditionRelatedItem; overload;
    {!script show}
  published
    {@member type_
      The type of relationship that this condition has to the related item.
    }
    property type_ : TFhirEnum read FType_ write SetType_;
    {@member type_ST
      Typed access to The type of relationship that this condition has to the related item.
    }
    property type_ST : TFhirConditionRelationshipType read GetType_ST write SetType_ST;

    {@member code
      Code that identifies the target of this relationship. The code takes the place of a detailed instance target.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member target
      Target of the relationship.
    }
    property target : TFhirResourceReference{Resource} read FTarget write SetTarget;

  end;


  {@Class TFhirConditionRelatedItemList
    A list of FhirConditionRelatedItem
  }
  {!.Net HL7Connect.Fhir.ConditionRelatedItemList}
  TFhirConditionRelatedItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConditionRelatedItem;
    procedure SetItemN(index : Integer; value : TFhirConditionRelatedItem);
  public
    {!script hide}
    function Link : TFhirConditionRelatedItemList; Overload;
    function Clone : TFhirConditionRelatedItemList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConditionRelatedItem to the end of the list.
    }
    function Append : TFhirConditionRelatedItem;

    
    {@member AddItem
      Add an already existing FhirConditionRelatedItem to the end of the list.
    }
    procedure AddItem(value : TFhirConditionRelatedItem);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConditionRelatedItem) : Integer;
    

    {@member Insert
      Insert FhirConditionRelatedItem before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConditionRelatedItem;
    

    {@member InsertItem
       Insert an existing FhirConditionRelatedItem before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConditionRelatedItem);
    
    {@member Item
       Get the iIndexth FhirConditionRelatedItem. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConditionRelatedItem. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConditionRelatedItem);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConditionRelatedItem;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConditionRelatedItems[index : Integer] : TFhirConditionRelatedItem read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceSoftware : TFhirElement
    Software that is covered by this conformance statement.  It is used when the profile describes the capabilities of a particular software version, independent of an installation.
  }
  {!.Net HL7Connect.Fhir.ConformanceSoftware}
  TFhirConformanceSoftware = class (TFhirBackboneElement)
  private
    FName : TFhirString;
    FVersion : TFhirString;
    FReleaseDate : TFhirDateTime;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetReleaseDate(value : TFhirDateTime);
    Function GetReleaseDateST : TDateAndTime;
    Procedure SetReleaseDateST(value : TDateAndTime);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceSoftware; overload;
    function Clone : TFhirConformanceSoftware; overload;
    {!script show}
  published
    {@member name
      Name software is known by.
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to Name software is known by.
    }
    property nameST : String read GetNameST write SetNameST;

    {@member version
      The version identifier for the software covered by this statement.
    }
    property version : TFhirString read FVersion write SetVersion;
    {@member versionST
      Typed access to The version identifier for the software covered by this statement.
    }
    property versionST : String read GetVersionST write SetVersionST;

    {@member releaseDate
      Date this version of the software released.
    }
    property releaseDate : TFhirDateTime read FReleaseDate write SetReleaseDate;
    {@member releaseDateST
      Typed access to Date this version of the software released.
    }
    property releaseDateST : TDateAndTime read GetReleaseDateST write SetReleaseDateST;

  end;


  {@Class TFhirConformanceSoftwareList
    A list of FhirConformanceSoftware
  }
  {!.Net HL7Connect.Fhir.ConformanceSoftwareList}
  TFhirConformanceSoftwareList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceSoftware;
    procedure SetItemN(index : Integer; value : TFhirConformanceSoftware);
  public
    {!script hide}
    function Link : TFhirConformanceSoftwareList; Overload;
    function Clone : TFhirConformanceSoftwareList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConformanceSoftware to the end of the list.
    }
    function Append : TFhirConformanceSoftware;

    
    {@member AddItem
      Add an already existing FhirConformanceSoftware to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceSoftware);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceSoftware) : Integer;
    

    {@member Insert
      Insert FhirConformanceSoftware before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceSoftware;
    

    {@member InsertItem
       Insert an existing FhirConformanceSoftware before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceSoftware);
    
    {@member Item
       Get the iIndexth FhirConformanceSoftware. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceSoftware. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceSoftware);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceSoftware;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceSoftwares[index : Integer] : TFhirConformanceSoftware read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceImplementation : TFhirElement
    Identifies a specific implementation instance that is described by the conformance statement - i.e. a particular installation, rather than the capabilities of a software program.
  }
  {!.Net HL7Connect.Fhir.ConformanceImplementation}
  TFhirConformanceImplementation = class (TFhirBackboneElement)
  private
    FDescription : TFhirString;
    FUrl : TFhirUri;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceImplementation; overload;
    function Clone : TFhirConformanceImplementation; overload;
    {!script show}
  published
    {@member description
      Information about the specific installation that this conformance statement relates to.
    }
    property description : TFhirString read FDescription write SetDescription;
    {@member descriptionST
      Typed access to Information about the specific installation that this conformance statement relates to.
    }
    property descriptionST : String read GetDescriptionST write SetDescriptionST;

    {@member url
      A base URL for the implementation.  This forms the base for REST interfaces as well as the mailbox and document interfaces.
    }
    property url : TFhirUri read FUrl write SetUrl;
    {@member urlST
      Typed access to A base URL for the implementation.  This forms the base for REST interfaces as well as the mailbox and document interfaces.
    }
    property urlST : String read GetUrlST write SetUrlST;

  end;


  {@Class TFhirConformanceImplementationList
    A list of FhirConformanceImplementation
  }
  {!.Net HL7Connect.Fhir.ConformanceImplementationList}
  TFhirConformanceImplementationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceImplementation;
    procedure SetItemN(index : Integer; value : TFhirConformanceImplementation);
  public
    {!script hide}
    function Link : TFhirConformanceImplementationList; Overload;
    function Clone : TFhirConformanceImplementationList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConformanceImplementation to the end of the list.
    }
    function Append : TFhirConformanceImplementation;

    
    {@member AddItem
      Add an already existing FhirConformanceImplementation to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceImplementation);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceImplementation) : Integer;
    

    {@member Insert
      Insert FhirConformanceImplementation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceImplementation;
    

    {@member InsertItem
       Insert an existing FhirConformanceImplementation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceImplementation);
    
    {@member Item
       Get the iIndexth FhirConformanceImplementation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceImplementation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceImplementation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceImplementation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceImplementations[index : Integer] : TFhirConformanceImplementation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceRest : TFhirElement
    A definition of the restful capabilities of the solution, if any.
  }
  {!.Net HL7Connect.Fhir.ConformanceRest}
  TFhirConformanceRest = class (TFhirBackboneElement)
  private
    FMode : TFhirEnum;
    FDocumentation : TFhirString;
    FSecurity : TFhirConformanceRestSecurity;
    FresourceList : TFhirConformanceRestResourceList;
    FoperationList : TFhirConformanceRestOperationList;
    FqueryList : TFhirConformanceRestQueryList;
    FdocumentMailboxList : TFhirUriList;
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirRestfulConformanceMode;
    Procedure SetModeST(value : TFhirRestfulConformanceMode);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
    Procedure SetSecurity(value : TFhirConformanceRestSecurity);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceRest; overload;
    function Clone : TFhirConformanceRest; overload;
    {!script show}
  published
    {@member mode
      Identifies whether this portion of the statement is describing ability to initiate or receive restful operations.
    }
    property mode : TFhirEnum read FMode write SetMode;
    {@member modeST
      Typed access to Identifies whether this portion of the statement is describing ability to initiate or receive restful operations.
    }
    property modeST : TFhirRestfulConformanceMode read GetModeST write SetModeST;

    {@member documentation
      Information about the system's restful capabilities that apply across all applications, such as security.
    }
    property documentation : TFhirString read FDocumentation write SetDocumentation;
    {@member documentationST
      Typed access to Information about the system's restful capabilities that apply across all applications, such as security.
    }
    property documentationST : String read GetDocumentationST write SetDocumentationST;

    {@member security
      Information about security of implementation.
    }
    property security : TFhirConformanceRestSecurity read FSecurity write SetSecurity;

    {@member resourceList
      A specification of the restful capabilities of the solution for a specific resource type.
    }
    property resourceList : TFhirConformanceRestResourceList read FResourceList;

    {@member operationList
      A specification of restful operations supported by the system.
    }
    property operationList : TFhirConformanceRestOperationList read FOperationList;

    {@member queryList
      Definition of a named query and its parameters and their meaning.
    }
    property queryList : TFhirConformanceRestQueryList read FQueryList;

    {@member documentMailboxList
      A list of profiles that this server implements for accepting documents in the mailbox. If this list is empty, then documents are not accepted. The base specification has the profile identifier "http://hl7.org/fhir/documents/mailbox". Other specifications can declare their own identifier for this purpose.
    }
    property documentMailboxList : TFhirUriList read FDocumentMailboxList;

  end;


  {@Class TFhirConformanceRestList
    A list of FhirConformanceRest
  }
  {!.Net HL7Connect.Fhir.ConformanceRestList}
  TFhirConformanceRestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceRest;
    procedure SetItemN(index : Integer; value : TFhirConformanceRest);
  public
    {!script hide}
    function Link : TFhirConformanceRestList; Overload;
    function Clone : TFhirConformanceRestList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConformanceRest to the end of the list.
    }
    function Append : TFhirConformanceRest;

    
    {@member AddItem
      Add an already existing FhirConformanceRest to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceRest);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceRest) : Integer;
    

    {@member Insert
      Insert FhirConformanceRest before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceRest;
    

    {@member InsertItem
       Insert an existing FhirConformanceRest before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceRest);
    
    {@member Item
       Get the iIndexth FhirConformanceRest. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceRest. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRest);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceRest;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceRests[index : Integer] : TFhirConformanceRest read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceRestSecurity : TFhirElement
    Information about security of implementation.
  }
  {!.Net HL7Connect.Fhir.ConformanceRestSecurity}
  TFhirConformanceRestSecurity = class (TFhirBackboneElement)
  private
    FCors : TFhirBoolean;
    FserviceList : TFhirCodeableConceptList;
    FDescription : TFhirString;
    FcertificateList : TFhirConformanceRestSecurityCertificateList;
    Procedure SetCors(value : TFhirBoolean);
    Function GetCorsST : Boolean;
    Procedure SetCorsST(value : Boolean);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceRestSecurity; overload;
    function Clone : TFhirConformanceRestSecurity; overload;
    {!script show}
  published
    {@member cors
      Server adds CORS headers when responding to requests - this enables javascript applications to yuse the server.
    }
    property cors : TFhirBoolean read FCors write SetCors;
    {@member corsST
      Typed access to Server adds CORS headers when responding to requests - this enables javascript applications to yuse the server.
    }
    property corsST : Boolean read GetCorsST write SetCorsST;

    {@member serviceList
      Types of security services are supported/required by the system.
    }
    property serviceList : TFhirCodeableConceptList read FServiceList;

    {@member description
      General description of how security works.
    }
    property description : TFhirString read FDescription write SetDescription;
    {@member descriptionST
      Typed access to General description of how security works.
    }
    property descriptionST : String read GetDescriptionST write SetDescriptionST;

    {@member certificateList
      Certificates associated with security profiles.
    }
    property certificateList : TFhirConformanceRestSecurityCertificateList read FCertificateList;

  end;


  {@Class TFhirConformanceRestSecurityList
    A list of FhirConformanceRestSecurity
  }
  {!.Net HL7Connect.Fhir.ConformanceRestSecurityList}
  TFhirConformanceRestSecurityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceRestSecurity;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestSecurity);
  public
    {!script hide}
    function Link : TFhirConformanceRestSecurityList; Overload;
    function Clone : TFhirConformanceRestSecurityList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConformanceRestSecurity to the end of the list.
    }
    function Append : TFhirConformanceRestSecurity;

    
    {@member AddItem
      Add an already existing FhirConformanceRestSecurity to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceRestSecurity);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceRestSecurity) : Integer;
    

    {@member Insert
      Insert FhirConformanceRestSecurity before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceRestSecurity;
    

    {@member InsertItem
       Insert an existing FhirConformanceRestSecurity before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceRestSecurity);
    
    {@member Item
       Get the iIndexth FhirConformanceRestSecurity. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceRestSecurity. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestSecurity);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceRestSecurity;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceRestSecurities[index : Integer] : TFhirConformanceRestSecurity read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceRestSecurityCertificate : TFhirElement
    Certificates associated with security profiles.
  }
  {!.Net HL7Connect.Fhir.ConformanceRestSecurityCertificate}
  TFhirConformanceRestSecurityCertificate = class (TFhirBackboneElement)
  private
    FType_ : TFhirCode;
    FBlob : TFhirBase64Binary;
    Procedure SetType_(value : TFhirCode);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetBlob(value : TFhirBase64Binary);
    Function GetBlobST : String;
    Procedure SetBlobST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceRestSecurityCertificate; overload;
    function Clone : TFhirConformanceRestSecurityCertificate; overload;
    {!script show}
  published
    {@member type_
      Mime type for certificate.
    }
    property type_ : TFhirCode read FType_ write SetType_;
    {@member type_ST
      Typed access to Mime type for certificate.
    }
    property type_ST : String read GetType_ST write SetType_ST;

    {@member blob
      Actual certificate.
    }
    property blob : TFhirBase64Binary read FBlob write SetBlob;
    {@member blobST
      Typed access to Actual certificate.
    }
    property blobST : String read GetBlobST write SetBlobST;

  end;


  {@Class TFhirConformanceRestSecurityCertificateList
    A list of FhirConformanceRestSecurityCertificate
  }
  {!.Net HL7Connect.Fhir.ConformanceRestSecurityCertificateList}
  TFhirConformanceRestSecurityCertificateList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceRestSecurityCertificate;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestSecurityCertificate);
  public
    {!script hide}
    function Link : TFhirConformanceRestSecurityCertificateList; Overload;
    function Clone : TFhirConformanceRestSecurityCertificateList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConformanceRestSecurityCertificate to the end of the list.
    }
    function Append : TFhirConformanceRestSecurityCertificate;

    
    {@member AddItem
      Add an already existing FhirConformanceRestSecurityCertificate to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceRestSecurityCertificate);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceRestSecurityCertificate) : Integer;
    

    {@member Insert
      Insert FhirConformanceRestSecurityCertificate before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceRestSecurityCertificate;
    

    {@member InsertItem
       Insert an existing FhirConformanceRestSecurityCertificate before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceRestSecurityCertificate);
    
    {@member Item
       Get the iIndexth FhirConformanceRestSecurityCertificate. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceRestSecurityCertificate. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestSecurityCertificate);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceRestSecurityCertificate;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceRestSecurityCertificates[index : Integer] : TFhirConformanceRestSecurityCertificate read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceRestResource : TFhirElement
    A specification of the restful capabilities of the solution for a specific resource type.
  }
  {!.Net HL7Connect.Fhir.ConformanceRestResource}
  TFhirConformanceRestResource = class (TFhirBackboneElement)
  private
    FType_ : TFhirCode;
    FProfile : TFhirResourceReference{TFhirProfile};
    FoperationList : TFhirConformanceRestResourceOperationList;
    FReadHistory : TFhirBoolean;
    FUpdateCreate : TFhirBoolean;
    FsearchIncludeList : TFhirStringList;
    FsearchParamList : TFhirConformanceRestResourceSearchParamList;
    Procedure SetType_(value : TFhirCode);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetProfile(value : TFhirResourceReference{TFhirProfile});
    Procedure SetReadHistory(value : TFhirBoolean);
    Function GetReadHistoryST : Boolean;
    Procedure SetReadHistoryST(value : Boolean);
    Procedure SetUpdateCreate(value : TFhirBoolean);
    Function GetUpdateCreateST : Boolean;
    Procedure SetUpdateCreateST(value : Boolean);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceRestResource; overload;
    function Clone : TFhirConformanceRestResource; overload;
    {!script show}
  published
    {@member type_
      A type of resource exposed via the restful interface.
    }
    property type_ : TFhirCode read FType_ write SetType_;
    {@member type_ST
      Typed access to A type of resource exposed via the restful interface.
    }
    property type_ST : String read GetType_ST write SetType_ST;

    {@member profile
      A specification of the profile that describes the solution's support for the resource, including any constraints on cardinality, bindings, lengths or other limitations.
    }
    property profile : TFhirResourceReference{TFhirProfile} read FProfile write SetProfile;

    {@member operationList
      Identifies a restful operation supported by the solution.
    }
    property operationList : TFhirConformanceRestResourceOperationList read FOperationList;

    {@member readHistory
      A flag for whether the server is able to return past versions as part of the vRead operation.
    }
    property readHistory : TFhirBoolean read FReadHistory write SetReadHistory;
    {@member readHistoryST
      Typed access to A flag for whether the server is able to return past versions as part of the vRead operation.
    }
    property readHistoryST : Boolean read GetReadHistoryST write SetReadHistoryST;

    {@member updateCreate
      A flag to indicate that the server allows the client to create new identities on the server. If the update operation is used (client) or allowed (server) to a new location where a resource doesn't already exist. This means that the server allows the client to create new identities on the server.
    }
    property updateCreate : TFhirBoolean read FUpdateCreate write SetUpdateCreate;
    {@member updateCreateST
      Typed access to A flag to indicate that the server allows the client to create new identities on the server. If the update operation is used (client) or allowed (server) to a new location where a resource doesn't already exist. This means that the server allows the client to create new identities on the server.
    }
    property updateCreateST : Boolean read GetUpdateCreateST write SetUpdateCreateST;

    {@member searchIncludeList
      A list of _include values supported by the server.
    }
    property searchIncludeList : TFhirStringList read FSearchIncludeList;

    {@member searchParamList
      Additional search parameters for implementations to support and/or make use of.
    }
    property searchParamList : TFhirConformanceRestResourceSearchParamList read FSearchParamList;

  end;


  {@Class TFhirConformanceRestResourceList
    A list of FhirConformanceRestResource
  }
  {!.Net HL7Connect.Fhir.ConformanceRestResourceList}
  TFhirConformanceRestResourceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceRestResource;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestResource);
  public
    {!script hide}
    function Link : TFhirConformanceRestResourceList; Overload;
    function Clone : TFhirConformanceRestResourceList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConformanceRestResource to the end of the list.
    }
    function Append : TFhirConformanceRestResource;

    
    {@member AddItem
      Add an already existing FhirConformanceRestResource to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceRestResource);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceRestResource) : Integer;
    

    {@member Insert
      Insert FhirConformanceRestResource before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceRestResource;
    

    {@member InsertItem
       Insert an existing FhirConformanceRestResource before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceRestResource);
    
    {@member Item
       Get the iIndexth FhirConformanceRestResource. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceRestResource. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestResource);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceRestResource;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceRestResources[index : Integer] : TFhirConformanceRestResource read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceRestResourceOperation : TFhirElement
    Identifies a restful operation supported by the solution.
  }
  {!.Net HL7Connect.Fhir.ConformanceRestResourceOperation}
  TFhirConformanceRestResourceOperation = class (TFhirBackboneElement)
  private
    FCode : TFhirEnum;
    FDocumentation : TFhirString;
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirTypeRestfulOperation;
    Procedure SetCodeST(value : TFhirTypeRestfulOperation);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceRestResourceOperation; overload;
    function Clone : TFhirConformanceRestResourceOperation; overload;
    {!script show}
  published
    {@member code
      Coded identifier of the operation, supported by the system resource.
    }
    property code : TFhirEnum read FCode write SetCode;
    {@member codeST
      Typed access to Coded identifier of the operation, supported by the system resource.
    }
    property codeST : TFhirTypeRestfulOperation read GetCodeST write SetCodeST;

    {@member documentation
      Guidance specific to the implementation of this operation, such as 'delete is a logical delete' or 'updates are only allowed with version id' or 'creates permitted from pre-authorized certificates only'.
    }
    property documentation : TFhirString read FDocumentation write SetDocumentation;
    {@member documentationST
      Typed access to Guidance specific to the implementation of this operation, such as 'delete is a logical delete' or 'updates are only allowed with version id' or 'creates permitted from pre-authorized certificates only'.
    }
    property documentationST : String read GetDocumentationST write SetDocumentationST;

  end;


  {@Class TFhirConformanceRestResourceOperationList
    A list of FhirConformanceRestResourceOperation
  }
  {!.Net HL7Connect.Fhir.ConformanceRestResourceOperationList}
  TFhirConformanceRestResourceOperationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceRestResourceOperation;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestResourceOperation);
  public
    {!script hide}
    function Link : TFhirConformanceRestResourceOperationList; Overload;
    function Clone : TFhirConformanceRestResourceOperationList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConformanceRestResourceOperation to the end of the list.
    }
    function Append : TFhirConformanceRestResourceOperation;

    
    {@member AddItem
      Add an already existing FhirConformanceRestResourceOperation to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceRestResourceOperation);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceRestResourceOperation) : Integer;
    

    {@member Insert
      Insert FhirConformanceRestResourceOperation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceRestResourceOperation;
    

    {@member InsertItem
       Insert an existing FhirConformanceRestResourceOperation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceRestResourceOperation);
    
    {@member Item
       Get the iIndexth FhirConformanceRestResourceOperation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceRestResourceOperation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestResourceOperation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceRestResourceOperation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceRestResourceOperations[index : Integer] : TFhirConformanceRestResourceOperation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceRestResourceSearchParam : TFhirElement
    Additional search parameters for implementations to support and/or make use of.
  }
  {!.Net HL7Connect.Fhir.ConformanceRestResourceSearchParam}
  TFhirConformanceRestResourceSearchParam = class (TFhirBackboneElement)
  private
    FName : TFhirString;
    FDefinition : TFhirUri;
    FType_ : TFhirEnum;
    FDocumentation : TFhirString;
    FtargetList : TFhirCodeList;
    FchainList : TFhirStringList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDefinition(value : TFhirUri);
    Function GetDefinitionST : String;
    Procedure SetDefinitionST(value : String);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirSearchParamType;
    Procedure SetType_ST(value : TFhirSearchParamType);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceRestResourceSearchParam; overload;
    function Clone : TFhirConformanceRestResourceSearchParam; overload;
    {!script show}
  published
    {@member name
      The name of the search parameter used in the interface.
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to The name of the search parameter used in the interface.
    }
    property nameST : String read GetNameST write SetNameST;

    {@member definition
      A formal reference to where this parameter was first defined, so that a client can be confident of the meaning of the search parameter.
    }
    property definition : TFhirUri read FDefinition write SetDefinition;
    {@member definitionST
      Typed access to A formal reference to where this parameter was first defined, so that a client can be confident of the meaning of the search parameter.
    }
    property definitionST : String read GetDefinitionST write SetDefinitionST;

    {@member type_
      The type of value a search parameter refers to, and how the content is interpreted.
    }
    property type_ : TFhirEnum read FType_ write SetType_;
    {@member type_ST
      Typed access to The type of value a search parameter refers to, and how the content is interpreted.
    }
    property type_ST : TFhirSearchParamType read GetType_ST write SetType_ST;

    {@member documentation
      This allows documentation of any distinct behaviors about how the search parameter is used.  For example, text matching algorithms.
    }
    property documentation : TFhirString read FDocumentation write SetDocumentation;
    {@member documentationST
      Typed access to This allows documentation of any distinct behaviors about how the search parameter is used.  For example, text matching algorithms.
    }
    property documentationST : String read GetDocumentationST write SetDocumentationST;

    {@member targetList
      Types of resource (if a resource is referenced).
    }
    property targetList : TFhirCodeList read FTargetList;

    {@member chainList
      Chained names supported.
    }
    property chainList : TFhirStringList read FChainList;

  end;


  {@Class TFhirConformanceRestResourceSearchParamList
    A list of FhirConformanceRestResourceSearchParam
  }
  {!.Net HL7Connect.Fhir.ConformanceRestResourceSearchParamList}
  TFhirConformanceRestResourceSearchParamList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceRestResourceSearchParam;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestResourceSearchParam);
  public
    {!script hide}
    function Link : TFhirConformanceRestResourceSearchParamList; Overload;
    function Clone : TFhirConformanceRestResourceSearchParamList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConformanceRestResourceSearchParam to the end of the list.
    }
    function Append : TFhirConformanceRestResourceSearchParam;

    
    {@member AddItem
      Add an already existing FhirConformanceRestResourceSearchParam to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceRestResourceSearchParam);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceRestResourceSearchParam) : Integer;
    

    {@member Insert
      Insert FhirConformanceRestResourceSearchParam before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceRestResourceSearchParam;
    

    {@member InsertItem
       Insert an existing FhirConformanceRestResourceSearchParam before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceRestResourceSearchParam);
    
    {@member Item
       Get the iIndexth FhirConformanceRestResourceSearchParam. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceRestResourceSearchParam. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestResourceSearchParam);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceRestResourceSearchParam;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceRestResourceSearchParams[index : Integer] : TFhirConformanceRestResourceSearchParam read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceRestOperation : TFhirElement
    A specification of restful operations supported by the system.
  }
  {!.Net HL7Connect.Fhir.ConformanceRestOperation}
  TFhirConformanceRestOperation = class (TFhirBackboneElement)
  private
    FCode : TFhirEnum;
    FDocumentation : TFhirString;
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirSystemRestfulOperation;
    Procedure SetCodeST(value : TFhirSystemRestfulOperation);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceRestOperation; overload;
    function Clone : TFhirConformanceRestOperation; overload;
    {!script show}
  published
    {@member code
      A coded identifier of the operation, supported by the system.
    }
    property code : TFhirEnum read FCode write SetCode;
    {@member codeST
      Typed access to A coded identifier of the operation, supported by the system.
    }
    property codeST : TFhirSystemRestfulOperation read GetCodeST write SetCodeST;

    {@member documentation
      Guidance specific to the implementation of this operation, such as limitations on the kind of transactions allowed, or information about system wide search is implemented.
    }
    property documentation : TFhirString read FDocumentation write SetDocumentation;
    {@member documentationST
      Typed access to Guidance specific to the implementation of this operation, such as limitations on the kind of transactions allowed, or information about system wide search is implemented.
    }
    property documentationST : String read GetDocumentationST write SetDocumentationST;

  end;


  {@Class TFhirConformanceRestOperationList
    A list of FhirConformanceRestOperation
  }
  {!.Net HL7Connect.Fhir.ConformanceRestOperationList}
  TFhirConformanceRestOperationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceRestOperation;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestOperation);
  public
    {!script hide}
    function Link : TFhirConformanceRestOperationList; Overload;
    function Clone : TFhirConformanceRestOperationList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConformanceRestOperation to the end of the list.
    }
    function Append : TFhirConformanceRestOperation;

    
    {@member AddItem
      Add an already existing FhirConformanceRestOperation to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceRestOperation);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceRestOperation) : Integer;
    

    {@member Insert
      Insert FhirConformanceRestOperation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceRestOperation;
    

    {@member InsertItem
       Insert an existing FhirConformanceRestOperation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceRestOperation);
    
    {@member Item
       Get the iIndexth FhirConformanceRestOperation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceRestOperation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestOperation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceRestOperation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceRestOperations[index : Integer] : TFhirConformanceRestOperation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceRestQuery : TFhirElement
    Definition of a named query and its parameters and their meaning.
  }
  {!.Net HL7Connect.Fhir.ConformanceRestQuery}
  TFhirConformanceRestQuery = class (TFhirBackboneElement)
  private
    FName : TFhirString;
    FDefinition : TFhirUri;
    FDocumentation : TFhirString;
    FparameterList : TFhirConformanceRestResourceSearchParamList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDefinition(value : TFhirUri);
    Function GetDefinitionST : String;
    Procedure SetDefinitionST(value : String);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceRestQuery; overload;
    function Clone : TFhirConformanceRestQuery; overload;
    {!script show}
  published
    {@member name
      The name of a query, which is used in the _query parameter when the query is called.
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to The name of a query, which is used in the _query parameter when the query is called.
    }
    property nameST : String read GetNameST write SetNameST;

    {@member definition
      Identifies the custom query, defined either in FHIR core or another profile.
    }
    property definition : TFhirUri read FDefinition write SetDefinition;
    {@member definitionST
      Typed access to Identifies the custom query, defined either in FHIR core or another profile.
    }
    property definitionST : String read GetDefinitionST write SetDefinitionST;

    {@member documentation
      Additional information about how the query functions in this particular implementation.
    }
    property documentation : TFhirString read FDocumentation write SetDocumentation;
    {@member documentationST
      Typed access to Additional information about how the query functions in this particular implementation.
    }
    property documentationST : String read GetDocumentationST write SetDocumentationST;

    {@member parameterList
      Identifies which of the parameters for the named query are supported.
    }
    property parameterList : TFhirConformanceRestResourceSearchParamList read FParameterList;

  end;


  {@Class TFhirConformanceRestQueryList
    A list of FhirConformanceRestQuery
  }
  {!.Net HL7Connect.Fhir.ConformanceRestQueryList}
  TFhirConformanceRestQueryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceRestQuery;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestQuery);
  public
    {!script hide}
    function Link : TFhirConformanceRestQueryList; Overload;
    function Clone : TFhirConformanceRestQueryList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConformanceRestQuery to the end of the list.
    }
    function Append : TFhirConformanceRestQuery;

    
    {@member AddItem
      Add an already existing FhirConformanceRestQuery to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceRestQuery);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceRestQuery) : Integer;
    

    {@member Insert
      Insert FhirConformanceRestQuery before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceRestQuery;
    

    {@member InsertItem
       Insert an existing FhirConformanceRestQuery before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceRestQuery);
    
    {@member Item
       Get the iIndexth FhirConformanceRestQuery. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceRestQuery. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestQuery);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceRestQuery;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceRestQueries[index : Integer] : TFhirConformanceRestQuery read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceMessaging : TFhirElement
    A description of the messaging capabilities of the solution.
  }
  {!.Net HL7Connect.Fhir.ConformanceMessaging}
  TFhirConformanceMessaging = class (TFhirBackboneElement)
  private
    FEndpoint : TFhirUri;
    FReliableCache : TFhirInteger;
    FDocumentation : TFhirString;
    FeventList : TFhirConformanceMessagingEventList;
    Procedure SetEndpoint(value : TFhirUri);
    Function GetEndpointST : String;
    Procedure SetEndpointST(value : String);
    Procedure SetReliableCache(value : TFhirInteger);
    Function GetReliableCacheST : String;
    Procedure SetReliableCacheST(value : String);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceMessaging; overload;
    function Clone : TFhirConformanceMessaging; overload;
    {!script show}
  published
    {@member endpoint
      An address to which messages and/or replies are to be sent.
    }
    property endpoint : TFhirUri read FEndpoint write SetEndpoint;
    {@member endpointST
      Typed access to An address to which messages and/or replies are to be sent.
    }
    property endpointST : String read GetEndpointST write SetEndpointST;

    {@member reliableCache
      Length if the receiver's reliable messaging cache (if a receiver) or how long the cache length on the receiver should be (if a sender).
    }
    property reliableCache : TFhirInteger read FReliableCache write SetReliableCache;
    {@member reliableCacheST
      Typed access to Length if the receiver's reliable messaging cache (if a receiver) or how long the cache length on the receiver should be (if a sender).
    }
    property reliableCacheST : String read GetReliableCacheST write SetReliableCacheST;

    {@member documentation
      Documentation about the system's messaging capabilities for this endpoint not otherwise documented by the conformance statement.  For example, process for becoming an authorized messaging exchange partner.
    }
    property documentation : TFhirString read FDocumentation write SetDocumentation;
    {@member documentationST
      Typed access to Documentation about the system's messaging capabilities for this endpoint not otherwise documented by the conformance statement.  For example, process for becoming an authorized messaging exchange partner.
    }
    property documentationST : String read GetDocumentationST write SetDocumentationST;

    {@member eventList
      A description of the solution's support for an event at this end point.
    }
    property eventList : TFhirConformanceMessagingEventList read FEventList;

  end;


  {@Class TFhirConformanceMessagingList
    A list of FhirConformanceMessaging
  }
  {!.Net HL7Connect.Fhir.ConformanceMessagingList}
  TFhirConformanceMessagingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceMessaging;
    procedure SetItemN(index : Integer; value : TFhirConformanceMessaging);
  public
    {!script hide}
    function Link : TFhirConformanceMessagingList; Overload;
    function Clone : TFhirConformanceMessagingList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConformanceMessaging to the end of the list.
    }
    function Append : TFhirConformanceMessaging;

    
    {@member AddItem
      Add an already existing FhirConformanceMessaging to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceMessaging);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceMessaging) : Integer;
    

    {@member Insert
      Insert FhirConformanceMessaging before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceMessaging;
    

    {@member InsertItem
       Insert an existing FhirConformanceMessaging before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceMessaging);
    
    {@member Item
       Get the iIndexth FhirConformanceMessaging. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceMessaging. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceMessaging);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceMessaging;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceMessagings[index : Integer] : TFhirConformanceMessaging read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceMessagingEvent : TFhirElement
    A description of the solution's support for an event at this end point.
  }
  {!.Net HL7Connect.Fhir.ConformanceMessagingEvent}
  TFhirConformanceMessagingEvent = class (TFhirBackboneElement)
  private
    FCode : TFhirCoding;
    FCategory : TFhirEnum;
    FMode : TFhirEnum;
    FprotocolList : TFhirCodingList;
    FFocus : TFhirCode;
    FRequest : TFhirResourceReference{TFhirProfile};
    FResponse : TFhirResourceReference{TFhirProfile};
    FDocumentation : TFhirString;
    Procedure SetCode(value : TFhirCoding);
    Procedure SetCategory(value : TFhirEnum);
    Function GetCategoryST : TFhirMessageSignificanceCategory;
    Procedure SetCategoryST(value : TFhirMessageSignificanceCategory);
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirMessageConformanceEventMode;
    Procedure SetModeST(value : TFhirMessageConformanceEventMode);
    Procedure SetFocus(value : TFhirCode);
    Function GetFocusST : String;
    Procedure SetFocusST(value : String);
    Procedure SetRequest(value : TFhirResourceReference{TFhirProfile});
    Procedure SetResponse(value : TFhirResourceReference{TFhirProfile});
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceMessagingEvent; overload;
    function Clone : TFhirConformanceMessagingEvent; overload;
    {!script show}
  published
    {@member code
      A coded identifier of a supported messaging event.
    }
    property code : TFhirCoding read FCode write SetCode;

    {@member category
      The impact of the content of the message.
    }
    property category : TFhirEnum read FCategory write SetCategory;
    {@member categoryST
      Typed access to The impact of the content of the message.
    }
    property categoryST : TFhirMessageSignificanceCategory read GetCategoryST write SetCategoryST;

    {@member mode
      The mode of this event declaration - whether application is sender or receiver.
    }
    property mode : TFhirEnum read FMode write SetMode;
    {@member modeST
      Typed access to The mode of this event declaration - whether application is sender or receiver.
    }
    property modeST : TFhirMessageConformanceEventMode read GetModeST write SetModeST;

    {@member protocolList
      A list of the messaging transport protocol(s) identifiers, supported by this endpoint.
    }
    property protocolList : TFhirCodingList read FProtocolList;

    {@member focus
      A resource associated with the event.  This is the resource that defines the event.
    }
    property focus : TFhirCode read FFocus write SetFocus;
    {@member focusST
      Typed access to A resource associated with the event.  This is the resource that defines the event.
    }
    property focusST : String read GetFocusST write SetFocusST;

    {@member request
      Information about the request for this event.
    }
    property request : TFhirResourceReference{TFhirProfile} read FRequest write SetRequest;

    {@member response
      Information about the response for this event.
    }
    property response : TFhirResourceReference{TFhirProfile} read FResponse write SetResponse;

    {@member documentation
      Guidance on how this event is handled, such as internal system trigger points, business rules, etc.
    }
    property documentation : TFhirString read FDocumentation write SetDocumentation;
    {@member documentationST
      Typed access to Guidance on how this event is handled, such as internal system trigger points, business rules, etc.
    }
    property documentationST : String read GetDocumentationST write SetDocumentationST;

  end;


  {@Class TFhirConformanceMessagingEventList
    A list of FhirConformanceMessagingEvent
  }
  {!.Net HL7Connect.Fhir.ConformanceMessagingEventList}
  TFhirConformanceMessagingEventList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceMessagingEvent;
    procedure SetItemN(index : Integer; value : TFhirConformanceMessagingEvent);
  public
    {!script hide}
    function Link : TFhirConformanceMessagingEventList; Overload;
    function Clone : TFhirConformanceMessagingEventList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConformanceMessagingEvent to the end of the list.
    }
    function Append : TFhirConformanceMessagingEvent;

    
    {@member AddItem
      Add an already existing FhirConformanceMessagingEvent to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceMessagingEvent);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceMessagingEvent) : Integer;
    

    {@member Insert
      Insert FhirConformanceMessagingEvent before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceMessagingEvent;
    

    {@member InsertItem
       Insert an existing FhirConformanceMessagingEvent before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceMessagingEvent);
    
    {@member Item
       Get the iIndexth FhirConformanceMessagingEvent. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceMessagingEvent. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceMessagingEvent);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceMessagingEvent;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceMessagingEvents[index : Integer] : TFhirConformanceMessagingEvent read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceDocument : TFhirElement
    A document definition.
  }
  {!.Net HL7Connect.Fhir.ConformanceDocument}
  TFhirConformanceDocument = class (TFhirBackboneElement)
  private
    FMode : TFhirEnum;
    FDocumentation : TFhirString;
    FProfile : TFhirResourceReference{TFhirProfile};
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirDocumentMode;
    Procedure SetModeST(value : TFhirDocumentMode);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
    Procedure SetProfile(value : TFhirResourceReference{TFhirProfile});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceDocument; overload;
    function Clone : TFhirConformanceDocument; overload;
    {!script show}
  published
    {@member mode
      Mode of this document declaration - whether application is producer or consumer.
    }
    property mode : TFhirEnum read FMode write SetMode;
    {@member modeST
      Typed access to Mode of this document declaration - whether application is producer or consumer.
    }
    property modeST : TFhirDocumentMode read GetModeST write SetModeST;

    {@member documentation
      A description of how the application supports or uses the specified document profile.  For example, when are documents created, what action is taken with consumed documents, etc.
    }
    property documentation : TFhirString read FDocumentation write SetDocumentation;
    {@member documentationST
      Typed access to A description of how the application supports or uses the specified document profile.  For example, when are documents created, what action is taken with consumed documents, etc.
    }
    property documentationST : String read GetDocumentationST write SetDocumentationST;

    {@member profile
      A constraint on a resource used in the document.
    }
    property profile : TFhirResourceReference{TFhirProfile} read FProfile write SetProfile;

  end;


  {@Class TFhirConformanceDocumentList
    A list of FhirConformanceDocument
  }
  {!.Net HL7Connect.Fhir.ConformanceDocumentList}
  TFhirConformanceDocumentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceDocument;
    procedure SetItemN(index : Integer; value : TFhirConformanceDocument);
  public
    {!script hide}
    function Link : TFhirConformanceDocumentList; Overload;
    function Clone : TFhirConformanceDocumentList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirConformanceDocument to the end of the list.
    }
    function Append : TFhirConformanceDocument;

    
    {@member AddItem
      Add an already existing FhirConformanceDocument to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceDocument);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceDocument) : Integer;
    

    {@member Insert
      Insert FhirConformanceDocument before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceDocument;
    

    {@member InsertItem
       Insert an existing FhirConformanceDocument before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceDocument);
    
    {@member Item
       Get the iIndexth FhirConformanceDocument. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceDocument. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceDocument);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceDocument;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceDocuments[index : Integer] : TFhirConformanceDocument read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDeviceObservationReportVirtualDevice : TFhirElement
    A medical-related subsystem of a medical device.
  }
  {!.Net HL7Connect.Fhir.DeviceObservationReportVirtualDevice}
  TFhirDeviceObservationReportVirtualDevice = class (TFhirBackboneElement)
  private
    FCode : TFhirCodeableConcept;
    FchannelList : TFhirDeviceObservationReportVirtualDeviceChannelList;
    Procedure SetCode(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDeviceObservationReportVirtualDevice; overload;
    function Clone : TFhirDeviceObservationReportVirtualDevice; overload;
    {!script show}
  published
    {@member code
      Describes the compartment.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member channelList
      Groups together physiological measurement data and derived data.
    }
    property channelList : TFhirDeviceObservationReportVirtualDeviceChannelList read FChannelList;

  end;


  {@Class TFhirDeviceObservationReportVirtualDeviceList
    A list of FhirDeviceObservationReportVirtualDevice
  }
  {!.Net HL7Connect.Fhir.DeviceObservationReportVirtualDeviceList}
  TFhirDeviceObservationReportVirtualDeviceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceObservationReportVirtualDevice;
    procedure SetItemN(index : Integer; value : TFhirDeviceObservationReportVirtualDevice);
  public
    {!script hide}
    function Link : TFhirDeviceObservationReportVirtualDeviceList; Overload;
    function Clone : TFhirDeviceObservationReportVirtualDeviceList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDeviceObservationReportVirtualDevice to the end of the list.
    }
    function Append : TFhirDeviceObservationReportVirtualDevice;

    
    {@member AddItem
      Add an already existing FhirDeviceObservationReportVirtualDevice to the end of the list.
    }
    procedure AddItem(value : TFhirDeviceObservationReportVirtualDevice);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDeviceObservationReportVirtualDevice) : Integer;
    

    {@member Insert
      Insert FhirDeviceObservationReportVirtualDevice before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDeviceObservationReportVirtualDevice;
    

    {@member InsertItem
       Insert an existing FhirDeviceObservationReportVirtualDevice before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDeviceObservationReportVirtualDevice);
    
    {@member Item
       Get the iIndexth FhirDeviceObservationReportVirtualDevice. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDeviceObservationReportVirtualDevice. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceObservationReportVirtualDevice);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDeviceObservationReportVirtualDevice;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDeviceObservationReportVirtualDevices[index : Integer] : TFhirDeviceObservationReportVirtualDevice read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDeviceObservationReportVirtualDeviceChannel : TFhirElement
    Groups together physiological measurement data and derived data.
  }
  {!.Net HL7Connect.Fhir.DeviceObservationReportVirtualDeviceChannel}
  TFhirDeviceObservationReportVirtualDeviceChannel = class (TFhirBackboneElement)
  private
    FCode : TFhirCodeableConcept;
    FmetricList : TFhirDeviceObservationReportVirtualDeviceChannelMetricList;
    Procedure SetCode(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDeviceObservationReportVirtualDeviceChannel; overload;
    function Clone : TFhirDeviceObservationReportVirtualDeviceChannel; overload;
    {!script show}
  published
    {@member code
      Describes the channel.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member metricList
      A piece of measured or derived data that is reported by the machine.
    }
    property metricList : TFhirDeviceObservationReportVirtualDeviceChannelMetricList read FMetricList;

  end;


  {@Class TFhirDeviceObservationReportVirtualDeviceChannelList
    A list of FhirDeviceObservationReportVirtualDeviceChannel
  }
  {!.Net HL7Connect.Fhir.DeviceObservationReportVirtualDeviceChannelList}
  TFhirDeviceObservationReportVirtualDeviceChannelList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceObservationReportVirtualDeviceChannel;
    procedure SetItemN(index : Integer; value : TFhirDeviceObservationReportVirtualDeviceChannel);
  public
    {!script hide}
    function Link : TFhirDeviceObservationReportVirtualDeviceChannelList; Overload;
    function Clone : TFhirDeviceObservationReportVirtualDeviceChannelList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDeviceObservationReportVirtualDeviceChannel to the end of the list.
    }
    function Append : TFhirDeviceObservationReportVirtualDeviceChannel;

    
    {@member AddItem
      Add an already existing FhirDeviceObservationReportVirtualDeviceChannel to the end of the list.
    }
    procedure AddItem(value : TFhirDeviceObservationReportVirtualDeviceChannel);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDeviceObservationReportVirtualDeviceChannel) : Integer;
    

    {@member Insert
      Insert FhirDeviceObservationReportVirtualDeviceChannel before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDeviceObservationReportVirtualDeviceChannel;
    

    {@member InsertItem
       Insert an existing FhirDeviceObservationReportVirtualDeviceChannel before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDeviceObservationReportVirtualDeviceChannel);
    
    {@member Item
       Get the iIndexth FhirDeviceObservationReportVirtualDeviceChannel. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDeviceObservationReportVirtualDeviceChannel. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceObservationReportVirtualDeviceChannel);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDeviceObservationReportVirtualDeviceChannel;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDeviceObservationReportVirtualDeviceChannels[index : Integer] : TFhirDeviceObservationReportVirtualDeviceChannel read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDeviceObservationReportVirtualDeviceChannelMetric : TFhirElement
    A piece of measured or derived data that is reported by the machine.
  }
  {!.Net HL7Connect.Fhir.DeviceObservationReportVirtualDeviceChannelMetric}
  TFhirDeviceObservationReportVirtualDeviceChannelMetric = class (TFhirBackboneElement)
  private
    FObservation : TFhirResourceReference{TFhirObservation};
    Procedure SetObservation(value : TFhirResourceReference{TFhirObservation});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDeviceObservationReportVirtualDeviceChannelMetric; overload;
    function Clone : TFhirDeviceObservationReportVirtualDeviceChannelMetric; overload;
    {!script show}
  published
    {@member observation
      The data for the metric.
    }
    property observation : TFhirResourceReference{TFhirObservation} read FObservation write SetObservation;

  end;


  {@Class TFhirDeviceObservationReportVirtualDeviceChannelMetricList
    A list of FhirDeviceObservationReportVirtualDeviceChannelMetric
  }
  {!.Net HL7Connect.Fhir.DeviceObservationReportVirtualDeviceChannelMetricList}
  TFhirDeviceObservationReportVirtualDeviceChannelMetricList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceObservationReportVirtualDeviceChannelMetric;
    procedure SetItemN(index : Integer; value : TFhirDeviceObservationReportVirtualDeviceChannelMetric);
  public
    {!script hide}
    function Link : TFhirDeviceObservationReportVirtualDeviceChannelMetricList; Overload;
    function Clone : TFhirDeviceObservationReportVirtualDeviceChannelMetricList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDeviceObservationReportVirtualDeviceChannelMetric to the end of the list.
    }
    function Append : TFhirDeviceObservationReportVirtualDeviceChannelMetric;

    
    {@member AddItem
      Add an already existing FhirDeviceObservationReportVirtualDeviceChannelMetric to the end of the list.
    }
    procedure AddItem(value : TFhirDeviceObservationReportVirtualDeviceChannelMetric);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDeviceObservationReportVirtualDeviceChannelMetric) : Integer;
    

    {@member Insert
      Insert FhirDeviceObservationReportVirtualDeviceChannelMetric before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDeviceObservationReportVirtualDeviceChannelMetric;
    

    {@member InsertItem
       Insert an existing FhirDeviceObservationReportVirtualDeviceChannelMetric before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDeviceObservationReportVirtualDeviceChannelMetric);
    
    {@member Item
       Get the iIndexth FhirDeviceObservationReportVirtualDeviceChannelMetric. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDeviceObservationReportVirtualDeviceChannelMetric. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceObservationReportVirtualDeviceChannelMetric);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDeviceObservationReportVirtualDeviceChannelMetric;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDeviceObservationReportVirtualDeviceChannelMetrics[index : Integer] : TFhirDeviceObservationReportVirtualDeviceChannelMetric read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDiagnosticOrderEvent : TFhirElement
    A summary of the events of interest that have occurred as the request is processed. E.g. when the order was made, various processing steps (specimens received), when it was completed.
  }
  {!.Net HL7Connect.Fhir.DiagnosticOrderEvent}
  TFhirDiagnosticOrderEvent = class (TFhirBackboneElement)
  private
    FStatus : TFhirEnum;
    FDescription : TFhirCodeableConcept;
    FDateTime : TFhirDateTime;
    FActor : TFhirResourceReference{Resource};
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirDiagnosticOrderStatus;
    Procedure SetStatusST(value : TFhirDiagnosticOrderStatus);
    Procedure SetDescription(value : TFhirCodeableConcept);
    Procedure SetDateTime(value : TFhirDateTime);
    Function GetDateTimeST : TDateAndTime;
    Procedure SetDateTimeST(value : TDateAndTime);
    Procedure SetActor(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDiagnosticOrderEvent; overload;
    function Clone : TFhirDiagnosticOrderEvent; overload;
    {!script show}
  published
    {@member status
      The status for the event.
    }
    property status : TFhirEnum read FStatus write SetStatus;
    {@member statusST
      Typed access to The status for the event.
    }
    property statusST : TFhirDiagnosticOrderStatus read GetStatusST write SetStatusST;

    {@member description
      Additional information about the event that occurred - e.g. if the status remained unchanged.
    }
    property description : TFhirCodeableConcept read FDescription write SetDescription;

    {@member dateTime
      The date/time at which the event occurred.
    }
    property dateTime : TFhirDateTime read FDateTime write SetDateTime;
    {@member dateTimeST
      Typed access to The date/time at which the event occurred.
    }
    property dateTimeST : TDateAndTime read GetDateTimeST write SetDateTimeST;

    {@member actor
      The person who was responsible for performing or recording the action.
    }
    property actor : TFhirResourceReference{Resource} read FActor write SetActor;

  end;


  {@Class TFhirDiagnosticOrderEventList
    A list of FhirDiagnosticOrderEvent
  }
  {!.Net HL7Connect.Fhir.DiagnosticOrderEventList}
  TFhirDiagnosticOrderEventList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDiagnosticOrderEvent;
    procedure SetItemN(index : Integer; value : TFhirDiagnosticOrderEvent);
  public
    {!script hide}
    function Link : TFhirDiagnosticOrderEventList; Overload;
    function Clone : TFhirDiagnosticOrderEventList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDiagnosticOrderEvent to the end of the list.
    }
    function Append : TFhirDiagnosticOrderEvent;

    
    {@member AddItem
      Add an already existing FhirDiagnosticOrderEvent to the end of the list.
    }
    procedure AddItem(value : TFhirDiagnosticOrderEvent);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDiagnosticOrderEvent) : Integer;
    

    {@member Insert
      Insert FhirDiagnosticOrderEvent before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDiagnosticOrderEvent;
    

    {@member InsertItem
       Insert an existing FhirDiagnosticOrderEvent before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDiagnosticOrderEvent);
    
    {@member Item
       Get the iIndexth FhirDiagnosticOrderEvent. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDiagnosticOrderEvent. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDiagnosticOrderEvent);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDiagnosticOrderEvent;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDiagnosticOrderEvents[index : Integer] : TFhirDiagnosticOrderEvent read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDiagnosticOrderItem : TFhirElement
    The specific diagnostic investigations that are requested as part of this request. Sometimes, there can only be one item per request, but in most contexts, more than one investigation can be requested.
  }
  {!.Net HL7Connect.Fhir.DiagnosticOrderItem}
  TFhirDiagnosticOrderItem = class (TFhirBackboneElement)
  private
    FCode : TFhirCodeableConcept;
    FspecimenList : TFhirResourceReferenceList{TFhirSpecimen};
    FBodySite : TFhirCodeableConcept;
    FStatus : TFhirEnum;
    FeventList : TFhirDiagnosticOrderEventList;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetBodySite(value : TFhirCodeableConcept);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirDiagnosticOrderStatus;
    Procedure SetStatusST(value : TFhirDiagnosticOrderStatus);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDiagnosticOrderItem; overload;
    function Clone : TFhirDiagnosticOrderItem; overload;
    {!script show}
  published
    {@member code
      A code that identifies a particular diagnostic investigation, or panel of investigations, that have been requested.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member specimenList
      If the item is related to a specific speciment.
    }
    property specimenList : TFhirResourceReferenceList{TFhirSpecimen} read FSpecimenList;

    {@member bodySite
      Anatomical location where the request test should be performed.
    }
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;

    {@member status
      The status of this individual item within the order.
    }
    property status : TFhirEnum read FStatus write SetStatus;
    {@member statusST
      Typed access to The status of this individual item within the order.
    }
    property statusST : TFhirDiagnosticOrderStatus read GetStatusST write SetStatusST;

    {@member eventList
      A summary of the events of interest that have occurred as this item of the request is processed.
    }
    property eventList : TFhirDiagnosticOrderEventList read FEventList;

  end;


  {@Class TFhirDiagnosticOrderItemList
    A list of FhirDiagnosticOrderItem
  }
  {!.Net HL7Connect.Fhir.DiagnosticOrderItemList}
  TFhirDiagnosticOrderItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDiagnosticOrderItem;
    procedure SetItemN(index : Integer; value : TFhirDiagnosticOrderItem);
  public
    {!script hide}
    function Link : TFhirDiagnosticOrderItemList; Overload;
    function Clone : TFhirDiagnosticOrderItemList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDiagnosticOrderItem to the end of the list.
    }
    function Append : TFhirDiagnosticOrderItem;

    
    {@member AddItem
      Add an already existing FhirDiagnosticOrderItem to the end of the list.
    }
    procedure AddItem(value : TFhirDiagnosticOrderItem);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDiagnosticOrderItem) : Integer;
    

    {@member Insert
      Insert FhirDiagnosticOrderItem before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDiagnosticOrderItem;
    

    {@member InsertItem
       Insert an existing FhirDiagnosticOrderItem before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDiagnosticOrderItem);
    
    {@member Item
       Get the iIndexth FhirDiagnosticOrderItem. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDiagnosticOrderItem. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDiagnosticOrderItem);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDiagnosticOrderItem;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDiagnosticOrderItems[index : Integer] : TFhirDiagnosticOrderItem read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDiagnosticReportImage : TFhirElement
    A list of key images associated with this report. The images are generally created during the diagnostic process, and may be directly of the patient, or of treated specimens (i.e. slides of interest).
  }
  {!.Net HL7Connect.Fhir.DiagnosticReportImage}
  TFhirDiagnosticReportImage = class (TFhirBackboneElement)
  private
    FComment : TFhirString;
    FLink_ : TFhirResourceReference{TFhirMedia};
    Procedure SetComment(value : TFhirString);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);
    Procedure SetLink_(value : TFhirResourceReference{TFhirMedia});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDiagnosticReportImage; overload;
    function Clone : TFhirDiagnosticReportImage; overload;
    {!script show}
  published
    {@member comment
      A comment about the image. Typically, this is used to provide an explanation for why the image is included, or to draw the viewer's attention to important features.
    }
    property comment : TFhirString read FComment write SetComment;
    {@member commentST
      Typed access to A comment about the image. Typically, this is used to provide an explanation for why the image is included, or to draw the viewer's attention to important features.
    }
    property commentST : String read GetCommentST write SetCommentST;

    {@member link_
      Reference to the image source.
    }
    property link_ : TFhirResourceReference{TFhirMedia} read FLink_ write SetLink_;

  end;


  {@Class TFhirDiagnosticReportImageList
    A list of FhirDiagnosticReportImage
  }
  {!.Net HL7Connect.Fhir.DiagnosticReportImageList}
  TFhirDiagnosticReportImageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDiagnosticReportImage;
    procedure SetItemN(index : Integer; value : TFhirDiagnosticReportImage);
  public
    {!script hide}
    function Link : TFhirDiagnosticReportImageList; Overload;
    function Clone : TFhirDiagnosticReportImageList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDiagnosticReportImage to the end of the list.
    }
    function Append : TFhirDiagnosticReportImage;

    
    {@member AddItem
      Add an already existing FhirDiagnosticReportImage to the end of the list.
    }
    procedure AddItem(value : TFhirDiagnosticReportImage);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDiagnosticReportImage) : Integer;
    

    {@member Insert
      Insert FhirDiagnosticReportImage before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDiagnosticReportImage;
    

    {@member InsertItem
       Insert an existing FhirDiagnosticReportImage before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDiagnosticReportImage);
    
    {@member Item
       Get the iIndexth FhirDiagnosticReportImage. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDiagnosticReportImage. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDiagnosticReportImage);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDiagnosticReportImage;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDiagnosticReportImages[index : Integer] : TFhirDiagnosticReportImage read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDocumentReferenceRelatesTo : TFhirElement
    Relationships that this document has with other document references that already exist.
  }
  {!.Net HL7Connect.Fhir.DocumentReferenceRelatesTo}
  TFhirDocumentReferenceRelatesTo = class (TFhirBackboneElement)
  private
    FCode : TFhirEnum;
    FTarget : TFhirResourceReference{TFhirDocumentReference};
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirDocumentRelationshipType;
    Procedure SetCodeST(value : TFhirDocumentRelationshipType);
    Procedure SetTarget(value : TFhirResourceReference{TFhirDocumentReference});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDocumentReferenceRelatesTo; overload;
    function Clone : TFhirDocumentReferenceRelatesTo; overload;
    {!script show}
  published
    {@member code
      The type of relationship that this document has with anther document.
    }
    property code : TFhirEnum read FCode write SetCode;
    {@member codeST
      Typed access to The type of relationship that this document has with anther document.
    }
    property codeST : TFhirDocumentRelationshipType read GetCodeST write SetCodeST;

    {@member target
      The target document of this relationship.
    }
    property target : TFhirResourceReference{TFhirDocumentReference} read FTarget write SetTarget;

  end;


  {@Class TFhirDocumentReferenceRelatesToList
    A list of FhirDocumentReferenceRelatesTo
  }
  {!.Net HL7Connect.Fhir.DocumentReferenceRelatesToList}
  TFhirDocumentReferenceRelatesToList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentReferenceRelatesTo;
    procedure SetItemN(index : Integer; value : TFhirDocumentReferenceRelatesTo);
  public
    {!script hide}
    function Link : TFhirDocumentReferenceRelatesToList; Overload;
    function Clone : TFhirDocumentReferenceRelatesToList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDocumentReferenceRelatesTo to the end of the list.
    }
    function Append : TFhirDocumentReferenceRelatesTo;

    
    {@member AddItem
      Add an already existing FhirDocumentReferenceRelatesTo to the end of the list.
    }
    procedure AddItem(value : TFhirDocumentReferenceRelatesTo);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDocumentReferenceRelatesTo) : Integer;
    

    {@member Insert
      Insert FhirDocumentReferenceRelatesTo before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDocumentReferenceRelatesTo;
    

    {@member InsertItem
       Insert an existing FhirDocumentReferenceRelatesTo before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDocumentReferenceRelatesTo);
    
    {@member Item
       Get the iIndexth FhirDocumentReferenceRelatesTo. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDocumentReferenceRelatesTo. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReferenceRelatesTo);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDocumentReferenceRelatesTo;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDocumentReferenceRelatesTos[index : Integer] : TFhirDocumentReferenceRelatesTo read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDocumentReferenceService : TFhirElement
    A description of a service call that can be used to retrieve the document.
  }
  {!.Net HL7Connect.Fhir.DocumentReferenceService}
  TFhirDocumentReferenceService = class (TFhirBackboneElement)
  private
    FType_ : TFhirCodeableConcept;
    FAddress : TFhirString;
    FparameterList : TFhirDocumentReferenceServiceParameterList;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetAddress(value : TFhirString);
    Function GetAddressST : String;
    Procedure SetAddressST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDocumentReferenceService; overload;
    function Clone : TFhirDocumentReferenceService; overload;
    {!script show}
  published
    {@member type_
      The type of the service that can be used to access the documents.
    }
    property type_ : TFhirCodeableConcept read FType_ write SetType_;

    {@member address
      Where the service end-point is located.
    }
    property address : TFhirString read FAddress write SetAddress;
    {@member addressST
      Typed access to Where the service end-point is located.
    }
    property addressST : String read GetAddressST write SetAddressST;

    {@member parameterList
      A list of named parameters that is used in the service call.
    }
    property parameterList : TFhirDocumentReferenceServiceParameterList read FParameterList;

  end;


  {@Class TFhirDocumentReferenceServiceList
    A list of FhirDocumentReferenceService
  }
  {!.Net HL7Connect.Fhir.DocumentReferenceServiceList}
  TFhirDocumentReferenceServiceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentReferenceService;
    procedure SetItemN(index : Integer; value : TFhirDocumentReferenceService);
  public
    {!script hide}
    function Link : TFhirDocumentReferenceServiceList; Overload;
    function Clone : TFhirDocumentReferenceServiceList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDocumentReferenceService to the end of the list.
    }
    function Append : TFhirDocumentReferenceService;

    
    {@member AddItem
      Add an already existing FhirDocumentReferenceService to the end of the list.
    }
    procedure AddItem(value : TFhirDocumentReferenceService);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDocumentReferenceService) : Integer;
    

    {@member Insert
      Insert FhirDocumentReferenceService before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDocumentReferenceService;
    

    {@member InsertItem
       Insert an existing FhirDocumentReferenceService before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDocumentReferenceService);
    
    {@member Item
       Get the iIndexth FhirDocumentReferenceService. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDocumentReferenceService. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReferenceService);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDocumentReferenceService;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDocumentReferenceServices[index : Integer] : TFhirDocumentReferenceService read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDocumentReferenceServiceParameter : TFhirElement
    A list of named parameters that is used in the service call.
  }
  {!.Net HL7Connect.Fhir.DocumentReferenceServiceParameter}
  TFhirDocumentReferenceServiceParameter = class (TFhirBackboneElement)
  private
    FName : TFhirString;
    FValue : TFhirString;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetValue(value : TFhirString);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDocumentReferenceServiceParameter; overload;
    function Clone : TFhirDocumentReferenceServiceParameter; overload;
    {!script show}
  published
    {@member name
      The name of a parameter.
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to The name of a parameter.
    }
    property nameST : String read GetNameST write SetNameST;

    {@member value
      The value of the named parameter.
    }
    property value : TFhirString read FValue write SetValue;
    {@member valueST
      Typed access to The value of the named parameter.
    }
    property valueST : String read GetValueST write SetValueST;

  end;


  {@Class TFhirDocumentReferenceServiceParameterList
    A list of FhirDocumentReferenceServiceParameter
  }
  {!.Net HL7Connect.Fhir.DocumentReferenceServiceParameterList}
  TFhirDocumentReferenceServiceParameterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentReferenceServiceParameter;
    procedure SetItemN(index : Integer; value : TFhirDocumentReferenceServiceParameter);
  public
    {!script hide}
    function Link : TFhirDocumentReferenceServiceParameterList; Overload;
    function Clone : TFhirDocumentReferenceServiceParameterList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDocumentReferenceServiceParameter to the end of the list.
    }
    function Append : TFhirDocumentReferenceServiceParameter;

    
    {@member AddItem
      Add an already existing FhirDocumentReferenceServiceParameter to the end of the list.
    }
    procedure AddItem(value : TFhirDocumentReferenceServiceParameter);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDocumentReferenceServiceParameter) : Integer;
    

    {@member Insert
      Insert FhirDocumentReferenceServiceParameter before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDocumentReferenceServiceParameter;
    

    {@member InsertItem
       Insert an existing FhirDocumentReferenceServiceParameter before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDocumentReferenceServiceParameter);
    
    {@member Item
       Get the iIndexth FhirDocumentReferenceServiceParameter. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDocumentReferenceServiceParameter. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReferenceServiceParameter);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDocumentReferenceServiceParameter;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDocumentReferenceServiceParameters[index : Integer] : TFhirDocumentReferenceServiceParameter read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDocumentReferenceContext : TFhirElement
    The clinical context in which the document was prepared.
  }
  {!.Net HL7Connect.Fhir.DocumentReferenceContext}
  TFhirDocumentReferenceContext = class (TFhirBackboneElement)
  private
    FeventList : TFhirCodeableConceptList;
    FPeriod : TFhirPeriod;
    FFacilityType : TFhirCodeableConcept;
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetFacilityType(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDocumentReferenceContext; overload;
    function Clone : TFhirDocumentReferenceContext; overload;
    {!script show}
  published
    {@member eventList
      This list of codes represents the main clinical acts, such as a colonoscopy or an appendectomy, being documented. In some cases, the event is inherent in the typeCode, such as a "History and Physical Report" in which the procedure being documented is necessarily a "History and Physical" act.
    }
    property eventList : TFhirCodeableConceptList read FEventList;

    {@member period
      The time period over which the service that is described by the document was provided.
    }
    property period : TFhirPeriod read FPeriod write SetPeriod;

    {@member facilityType
      The kind of facility where the patient was seen.
    }
    property facilityType : TFhirCodeableConcept read FFacilityType write SetFacilityType;

  end;


  {@Class TFhirDocumentReferenceContextList
    A list of FhirDocumentReferenceContext
  }
  {!.Net HL7Connect.Fhir.DocumentReferenceContextList}
  TFhirDocumentReferenceContextList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentReferenceContext;
    procedure SetItemN(index : Integer; value : TFhirDocumentReferenceContext);
  public
    {!script hide}
    function Link : TFhirDocumentReferenceContextList; Overload;
    function Clone : TFhirDocumentReferenceContextList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirDocumentReferenceContext to the end of the list.
    }
    function Append : TFhirDocumentReferenceContext;

    
    {@member AddItem
      Add an already existing FhirDocumentReferenceContext to the end of the list.
    }
    procedure AddItem(value : TFhirDocumentReferenceContext);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDocumentReferenceContext) : Integer;
    

    {@member Insert
      Insert FhirDocumentReferenceContext before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDocumentReferenceContext;
    

    {@member InsertItem
       Insert an existing FhirDocumentReferenceContext before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDocumentReferenceContext);
    
    {@member Item
       Get the iIndexth FhirDocumentReferenceContext. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDocumentReferenceContext. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReferenceContext);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDocumentReferenceContext;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDocumentReferenceContexts[index : Integer] : TFhirDocumentReferenceContext read GetItemN write SetItemN; default;
  End;


  {@Class TFhirEncounterParticipant : TFhirElement
    The main practitioner responsible for providing the service.
  }
  {!.Net HL7Connect.Fhir.EncounterParticipant}
  TFhirEncounterParticipant = class (TFhirBackboneElement)
  private
    Ftype_List : TFhirCodeableConceptList;
    FIndividual : TFhirResourceReference{Resource};
    Procedure SetIndividual(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirEncounterParticipant; overload;
    function Clone : TFhirEncounterParticipant; overload;
    {!script show}
  published
    {@member type_List
      Role of participant in encounter.
    }
    property type_List : TFhirCodeableConceptList read FType_List;

    {@member individual
      Persons involved in the encounter other than the patient.
    }
    property individual : TFhirResourceReference{Resource} read FIndividual write SetIndividual;

  end;


  {@Class TFhirEncounterParticipantList
    A list of FhirEncounterParticipant
  }
  {!.Net HL7Connect.Fhir.EncounterParticipantList}
  TFhirEncounterParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterParticipant;
    procedure SetItemN(index : Integer; value : TFhirEncounterParticipant);
  public
    {!script hide}
    function Link : TFhirEncounterParticipantList; Overload;
    function Clone : TFhirEncounterParticipantList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirEncounterParticipant to the end of the list.
    }
    function Append : TFhirEncounterParticipant;

    
    {@member AddItem
      Add an already existing FhirEncounterParticipant to the end of the list.
    }
    procedure AddItem(value : TFhirEncounterParticipant);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirEncounterParticipant) : Integer;
    

    {@member Insert
      Insert FhirEncounterParticipant before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirEncounterParticipant;
    

    {@member InsertItem
       Insert an existing FhirEncounterParticipant before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirEncounterParticipant);
    
    {@member Item
       Get the iIndexth FhirEncounterParticipant. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirEncounterParticipant. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterParticipant);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirEncounterParticipant;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirEncounterParticipants[index : Integer] : TFhirEncounterParticipant read GetItemN write SetItemN; default;
  End;


  {@Class TFhirEncounterHospitalization : TFhirElement
    Details about an admission to a clinic.
  }
  {!.Net HL7Connect.Fhir.EncounterHospitalization}
  TFhirEncounterHospitalization = class (TFhirBackboneElement)
  private
    FPreAdmissionIdentifier : TFhirIdentifier;
    FOrigin : TFhirResourceReference{TFhirLocation};
    FAdmitSource : TFhirCodeableConcept;
    FPeriod : TFhirPeriod;
    FaccomodationList : TFhirEncounterHospitalizationAccomodationList;
    FDiet : TFhirCodeableConcept;
    FspecialCourtesyList : TFhirCodeableConceptList;
    FspecialArrangementList : TFhirCodeableConceptList;
    FDestination : TFhirResourceReference{TFhirLocation};
    FDischargeDisposition : TFhirCodeableConcept;
    FDischargeDiagnosis : TFhirResourceReference{Resource};
    FReAdmission : TFhirBoolean;
    Procedure SetPreAdmissionIdentifier(value : TFhirIdentifier);
    Procedure SetOrigin(value : TFhirResourceReference{TFhirLocation});
    Procedure SetAdmitSource(value : TFhirCodeableConcept);
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetDiet(value : TFhirCodeableConcept);
    Procedure SetDestination(value : TFhirResourceReference{TFhirLocation});
    Procedure SetDischargeDisposition(value : TFhirCodeableConcept);
    Procedure SetDischargeDiagnosis(value : TFhirResourceReference{Resource});
    Procedure SetReAdmission(value : TFhirBoolean);
    Function GetReAdmissionST : Boolean;
    Procedure SetReAdmissionST(value : Boolean);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirEncounterHospitalization; overload;
    function Clone : TFhirEncounterHospitalization; overload;
    {!script show}
  published
    {@member preAdmissionIdentifier
      Pre-admission identifier.
    }
    property preAdmissionIdentifier : TFhirIdentifier read FPreAdmissionIdentifier write SetPreAdmissionIdentifier;

    {@member origin
      The location from which the patient came before admission.
    }
    property origin : TFhirResourceReference{TFhirLocation} read FOrigin write SetOrigin;

    {@member admitSource
      From where patient was admitted (physician referral, transfer).
    }
    property admitSource : TFhirCodeableConcept read FAdmitSource write SetAdmitSource;

    {@member period
      Period during which the patient was admitted.
    }
    property period : TFhirPeriod read FPeriod write SetPeriod;

    {@member accomodationList
      Where the patient stays during this encounter.
    }
    property accomodationList : TFhirEncounterHospitalizationAccomodationList read FAccomodationList;

    {@member diet
      Dietary restrictions for the patient.
    }
    property diet : TFhirCodeableConcept read FDiet write SetDiet;

    {@member specialCourtesyList
      Special courtesies (VIP, board member).
    }
    property specialCourtesyList : TFhirCodeableConceptList read FSpecialCourtesyList;

    {@member specialArrangementList
      Wheelchair, translator, stretcher, etc.
    }
    property specialArrangementList : TFhirCodeableConceptList read FSpecialArrangementList;

    {@member destination
      Location to which the patient is discharged.
    }
    property destination : TFhirResourceReference{TFhirLocation} read FDestination write SetDestination;

    {@member dischargeDisposition
      Category or kind of location after discharge.
    }
    property dischargeDisposition : TFhirCodeableConcept read FDischargeDisposition write SetDischargeDisposition;

    {@member dischargeDiagnosis
      The final diagnosis given a patient before release from the hospital after all testing, surgery, and workup are complete.
    }
    property dischargeDiagnosis : TFhirResourceReference{Resource} read FDischargeDiagnosis write SetDischargeDiagnosis;

    {@member reAdmission
      Whether this hospitalization is a readmission.
    }
    property reAdmission : TFhirBoolean read FReAdmission write SetReAdmission;
    {@member reAdmissionST
      Typed access to Whether this hospitalization is a readmission.
    }
    property reAdmissionST : Boolean read GetReAdmissionST write SetReAdmissionST;

  end;


  {@Class TFhirEncounterHospitalizationList
    A list of FhirEncounterHospitalization
  }
  {!.Net HL7Connect.Fhir.EncounterHospitalizationList}
  TFhirEncounterHospitalizationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterHospitalization;
    procedure SetItemN(index : Integer; value : TFhirEncounterHospitalization);
  public
    {!script hide}
    function Link : TFhirEncounterHospitalizationList; Overload;
    function Clone : TFhirEncounterHospitalizationList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirEncounterHospitalization to the end of the list.
    }
    function Append : TFhirEncounterHospitalization;

    
    {@member AddItem
      Add an already existing FhirEncounterHospitalization to the end of the list.
    }
    procedure AddItem(value : TFhirEncounterHospitalization);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirEncounterHospitalization) : Integer;
    

    {@member Insert
      Insert FhirEncounterHospitalization before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirEncounterHospitalization;
    

    {@member InsertItem
       Insert an existing FhirEncounterHospitalization before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirEncounterHospitalization);
    
    {@member Item
       Get the iIndexth FhirEncounterHospitalization. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirEncounterHospitalization. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterHospitalization);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirEncounterHospitalization;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirEncounterHospitalizations[index : Integer] : TFhirEncounterHospitalization read GetItemN write SetItemN; default;
  End;


  {@Class TFhirEncounterHospitalizationAccomodation : TFhirElement
    Where the patient stays during this encounter.
  }
  {!.Net HL7Connect.Fhir.EncounterHospitalizationAccomodation}
  TFhirEncounterHospitalizationAccomodation = class (TFhirBackboneElement)
  private
    FBed : TFhirResourceReference{TFhirLocation};
    FPeriod : TFhirPeriod;
    Procedure SetBed(value : TFhirResourceReference{TFhirLocation});
    Procedure SetPeriod(value : TFhirPeriod);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirEncounterHospitalizationAccomodation; overload;
    function Clone : TFhirEncounterHospitalizationAccomodation; overload;
    {!script show}
  published
    {@member bed
      The bed that is assigned to the patient.
    }
    property bed : TFhirResourceReference{TFhirLocation} read FBed write SetBed;

    {@member period
      Period during which the patient was assigned the bed.
    }
    property period : TFhirPeriod read FPeriod write SetPeriod;

  end;


  {@Class TFhirEncounterHospitalizationAccomodationList
    A list of FhirEncounterHospitalizationAccomodation
  }
  {!.Net HL7Connect.Fhir.EncounterHospitalizationAccomodationList}
  TFhirEncounterHospitalizationAccomodationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterHospitalizationAccomodation;
    procedure SetItemN(index : Integer; value : TFhirEncounterHospitalizationAccomodation);
  public
    {!script hide}
    function Link : TFhirEncounterHospitalizationAccomodationList; Overload;
    function Clone : TFhirEncounterHospitalizationAccomodationList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirEncounterHospitalizationAccomodation to the end of the list.
    }
    function Append : TFhirEncounterHospitalizationAccomodation;

    
    {@member AddItem
      Add an already existing FhirEncounterHospitalizationAccomodation to the end of the list.
    }
    procedure AddItem(value : TFhirEncounterHospitalizationAccomodation);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirEncounterHospitalizationAccomodation) : Integer;
    

    {@member Insert
      Insert FhirEncounterHospitalizationAccomodation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirEncounterHospitalizationAccomodation;
    

    {@member InsertItem
       Insert an existing FhirEncounterHospitalizationAccomodation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirEncounterHospitalizationAccomodation);
    
    {@member Item
       Get the iIndexth FhirEncounterHospitalizationAccomodation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirEncounterHospitalizationAccomodation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterHospitalizationAccomodation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirEncounterHospitalizationAccomodation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirEncounterHospitalizationAccomodations[index : Integer] : TFhirEncounterHospitalizationAccomodation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirEncounterLocation : TFhirElement
    List of locations at which the patient has been.
  }
  {!.Net HL7Connect.Fhir.EncounterLocation}
  TFhirEncounterLocation = class (TFhirBackboneElement)
  private
    FLocation : TFhirResourceReference{TFhirLocation};
    FPeriod : TFhirPeriod;
    Procedure SetLocation(value : TFhirResourceReference{TFhirLocation});
    Procedure SetPeriod(value : TFhirPeriod);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirEncounterLocation; overload;
    function Clone : TFhirEncounterLocation; overload;
    {!script show}
  published
    {@member location
      The location where the encounter takes place.
    }
    property location : TFhirResourceReference{TFhirLocation} read FLocation write SetLocation;

    {@member period
      Time period during which the patient was present at the location.
    }
    property period : TFhirPeriod read FPeriod write SetPeriod;

  end;


  {@Class TFhirEncounterLocationList
    A list of FhirEncounterLocation
  }
  {!.Net HL7Connect.Fhir.EncounterLocationList}
  TFhirEncounterLocationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterLocation;
    procedure SetItemN(index : Integer; value : TFhirEncounterLocation);
  public
    {!script hide}
    function Link : TFhirEncounterLocationList; Overload;
    function Clone : TFhirEncounterLocationList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirEncounterLocation to the end of the list.
    }
    function Append : TFhirEncounterLocation;

    
    {@member AddItem
      Add an already existing FhirEncounterLocation to the end of the list.
    }
    procedure AddItem(value : TFhirEncounterLocation);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirEncounterLocation) : Integer;
    

    {@member Insert
      Insert FhirEncounterLocation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirEncounterLocation;
    

    {@member InsertItem
       Insert an existing FhirEncounterLocation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirEncounterLocation);
    
    {@member Item
       Get the iIndexth FhirEncounterLocation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirEncounterLocation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterLocation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirEncounterLocation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirEncounterLocations[index : Integer] : TFhirEncounterLocation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirFamilyHistoryRelation : TFhirElement
    The related person. Each FamilyHistory resource contains the entire family history for a single person.
  }
  {!.Net HL7Connect.Fhir.FamilyHistoryRelation}
  TFhirFamilyHistoryRelation = class (TFhirBackboneElement)
  private
    FName : TFhirString;
    FRelationship : TFhirCodeableConcept;
    FBorn : TFhirType;
    FDeceased : TFhirType;
    FNote : TFhirString;
    FconditionList : TFhirFamilyHistoryRelationConditionList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetRelationship(value : TFhirCodeableConcept);
    Procedure SetBorn(value : TFhirType);
    Procedure SetDeceased(value : TFhirType);
    Procedure SetNote(value : TFhirString);
    Function GetNoteST : String;
    Procedure SetNoteST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirFamilyHistoryRelation; overload;
    function Clone : TFhirFamilyHistoryRelation; overload;
    {!script show}
  published
    {@member name
      This will either be a name or a description.  E.g. "Aunt Susan", "my cousin with the red hair".
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to This will either be a name or a description.  E.g. "Aunt Susan", "my cousin with the red hair".
    }
    property nameST : String read GetNameST write SetNameST;

    {@member relationship
      The type of relationship this person has to the patient (father, mother, brother etc.).
    }
    property relationship : TFhirCodeableConcept read FRelationship write SetRelationship;

    {@member born
      The actual or approximate date of birth of the relative.
    }
    property born : TFhirType read FBorn write SetBorn;

    {@member deceased
      If this resource is indicating that the related person is deceased, then an indicator of whether the person is deceased (yes) or not (no) or the age or age range or description of age at death - can be indicated here. If the reason for death is known, then it can be indicated in the outcome code of the condition - in this case the deceased property should still be set.
    }
    property deceased : TFhirType read FDeceased write SetDeceased;

    {@member note
      This property allows a non condition-specific note to the made about the related person. Ideally, the note would be in the condition property, but this is not always possible.
    }
    property note : TFhirString read FNote write SetNote;
    {@member noteST
      Typed access to This property allows a non condition-specific note to the made about the related person. Ideally, the note would be in the condition property, but this is not always possible.
    }
    property noteST : String read GetNoteST write SetNoteST;

    {@member conditionList
      The significant Conditions (or condition) that the family member had. This is a repeating section to allow a system to represent more than one condition per resource, though there is nothing stopping multiple resources - one per condition.
    }
    property conditionList : TFhirFamilyHistoryRelationConditionList read FConditionList;

  end;


  {@Class TFhirFamilyHistoryRelationList
    A list of FhirFamilyHistoryRelation
  }
  {!.Net HL7Connect.Fhir.FamilyHistoryRelationList}
  TFhirFamilyHistoryRelationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirFamilyHistoryRelation;
    procedure SetItemN(index : Integer; value : TFhirFamilyHistoryRelation);
  public
    {!script hide}
    function Link : TFhirFamilyHistoryRelationList; Overload;
    function Clone : TFhirFamilyHistoryRelationList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirFamilyHistoryRelation to the end of the list.
    }
    function Append : TFhirFamilyHistoryRelation;

    
    {@member AddItem
      Add an already existing FhirFamilyHistoryRelation to the end of the list.
    }
    procedure AddItem(value : TFhirFamilyHistoryRelation);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirFamilyHistoryRelation) : Integer;
    

    {@member Insert
      Insert FhirFamilyHistoryRelation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirFamilyHistoryRelation;
    

    {@member InsertItem
       Insert an existing FhirFamilyHistoryRelation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirFamilyHistoryRelation);
    
    {@member Item
       Get the iIndexth FhirFamilyHistoryRelation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirFamilyHistoryRelation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirFamilyHistoryRelation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirFamilyHistoryRelation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirFamilyHistoryRelations[index : Integer] : TFhirFamilyHistoryRelation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirFamilyHistoryRelationCondition : TFhirElement
    The significant Conditions (or condition) that the family member had. This is a repeating section to allow a system to represent more than one condition per resource, though there is nothing stopping multiple resources - one per condition.
  }
  {!.Net HL7Connect.Fhir.FamilyHistoryRelationCondition}
  TFhirFamilyHistoryRelationCondition = class (TFhirBackboneElement)
  private
    FType_ : TFhirCodeableConcept;
    FOutcome : TFhirCodeableConcept;
    FOnset : TFhirType;
    FNote : TFhirString;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetOutcome(value : TFhirCodeableConcept);
    Procedure SetOnset(value : TFhirType);
    Procedure SetNote(value : TFhirString);
    Function GetNoteST : String;
    Procedure SetNoteST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirFamilyHistoryRelationCondition; overload;
    function Clone : TFhirFamilyHistoryRelationCondition; overload;
    {!script show}
  published
    {@member type_
      The actual condition specified. Could be a coded condition (like MI or Diabetes) or a less specific string like 'cancer' depending on how much is known about the condition and the capabilities of the creating system.
    }
    property type_ : TFhirCodeableConcept read FType_ write SetType_;

    {@member outcome
      Indicates what happened as a result of this condition.  If the condition resulted in death, deceased date is captured on the relation.
    }
    property outcome : TFhirCodeableConcept read FOutcome write SetOutcome;

    {@member onset
      Either the age of onset, range of approximate age or descriptive string can be recorded.  For conditions with multiple occurrences, this describes the first known occurrence.
    }
    property onset : TFhirType read FOnset write SetOnset;

    {@member note
      An area where general notes can be placed about this specific condition.
    }
    property note : TFhirString read FNote write SetNote;
    {@member noteST
      Typed access to An area where general notes can be placed about this specific condition.
    }
    property noteST : String read GetNoteST write SetNoteST;

  end;


  {@Class TFhirFamilyHistoryRelationConditionList
    A list of FhirFamilyHistoryRelationCondition
  }
  {!.Net HL7Connect.Fhir.FamilyHistoryRelationConditionList}
  TFhirFamilyHistoryRelationConditionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirFamilyHistoryRelationCondition;
    procedure SetItemN(index : Integer; value : TFhirFamilyHistoryRelationCondition);
  public
    {!script hide}
    function Link : TFhirFamilyHistoryRelationConditionList; Overload;
    function Clone : TFhirFamilyHistoryRelationConditionList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirFamilyHistoryRelationCondition to the end of the list.
    }
    function Append : TFhirFamilyHistoryRelationCondition;

    
    {@member AddItem
      Add an already existing FhirFamilyHistoryRelationCondition to the end of the list.
    }
    procedure AddItem(value : TFhirFamilyHistoryRelationCondition);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirFamilyHistoryRelationCondition) : Integer;
    

    {@member Insert
      Insert FhirFamilyHistoryRelationCondition before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirFamilyHistoryRelationCondition;
    

    {@member InsertItem
       Insert an existing FhirFamilyHistoryRelationCondition before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirFamilyHistoryRelationCondition);
    
    {@member Item
       Get the iIndexth FhirFamilyHistoryRelationCondition. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirFamilyHistoryRelationCondition. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirFamilyHistoryRelationCondition);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirFamilyHistoryRelationCondition;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirFamilyHistoryRelationConditions[index : Integer] : TFhirFamilyHistoryRelationCondition read GetItemN write SetItemN; default;
  End;


  {@Class TFhirGroupCharacteristic : TFhirElement
    Identifies the traits shared by members of the group.
  }
  {!.Net HL7Connect.Fhir.GroupCharacteristic}
  TFhirGroupCharacteristic = class (TFhirBackboneElement)
  private
    FCode : TFhirCodeableConcept;
    FValue : TFhirType;
    FExclude : TFhirBoolean;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetValue(value : TFhirType);
    Procedure SetExclude(value : TFhirBoolean);
    Function GetExcludeST : Boolean;
    Procedure SetExcludeST(value : Boolean);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirGroupCharacteristic; overload;
    function Clone : TFhirGroupCharacteristic; overload;
    {!script show}
  published
    {@member code
      A code that identifies the kind of trait being asserted.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member value
      The value of the trait that holds (or does not hold - see 'exclude') for members of the group.
    }
    property value : TFhirType read FValue write SetValue;

    {@member exclude
      If true, indicates the characteristic is one that is NOT held by members of the group.
    }
    property exclude : TFhirBoolean read FExclude write SetExclude;
    {@member excludeST
      Typed access to If true, indicates the characteristic is one that is NOT held by members of the group.
    }
    property excludeST : Boolean read GetExcludeST write SetExcludeST;

  end;


  {@Class TFhirGroupCharacteristicList
    A list of FhirGroupCharacteristic
  }
  {!.Net HL7Connect.Fhir.GroupCharacteristicList}
  TFhirGroupCharacteristicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirGroupCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirGroupCharacteristic);
  public
    {!script hide}
    function Link : TFhirGroupCharacteristicList; Overload;
    function Clone : TFhirGroupCharacteristicList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirGroupCharacteristic to the end of the list.
    }
    function Append : TFhirGroupCharacteristic;

    
    {@member AddItem
      Add an already existing FhirGroupCharacteristic to the end of the list.
    }
    procedure AddItem(value : TFhirGroupCharacteristic);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirGroupCharacteristic) : Integer;
    

    {@member Insert
      Insert FhirGroupCharacteristic before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirGroupCharacteristic;
    

    {@member InsertItem
       Insert an existing FhirGroupCharacteristic before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirGroupCharacteristic);
    
    {@member Item
       Get the iIndexth FhirGroupCharacteristic. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirGroupCharacteristic. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirGroupCharacteristic);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirGroupCharacteristic;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirGroupCharacteristics[index : Integer] : TFhirGroupCharacteristic read GetItemN write SetItemN; default;
  End;


  {@Class TFhirImagingStudySeries : TFhirElement
    Each study has one or more series of image instances.
  }
  {!.Net HL7Connect.Fhir.ImagingStudySeries}
  TFhirImagingStudySeries = class (TFhirBackboneElement)
  private
    FNumber : TFhirInteger;
    FModality : TFhirEnum;
    FUid : TFhirOid;
    FDescription : TFhirString;
    FNumberOfInstances : TFhirInteger;
    FAvailability : TFhirEnum;
    FUrl : TFhirUri;
    FBodySite : TFhirCoding;
    FDateTime : TFhirDateTime;
    FinstanceList : TFhirImagingStudySeriesInstanceList;
    Procedure SetNumber(value : TFhirInteger);
    Function GetNumberST : String;
    Procedure SetNumberST(value : String);
    Procedure SetModality(value : TFhirEnum);
    Function GetModalityST : TFhirModality;
    Procedure SetModalityST(value : TFhirModality);
    Procedure SetUid(value : TFhirOid);
    Function GetUidST : String;
    Procedure SetUidST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetNumberOfInstances(value : TFhirInteger);
    Function GetNumberOfInstancesST : String;
    Procedure SetNumberOfInstancesST(value : String);
    Procedure SetAvailability(value : TFhirEnum);
    Function GetAvailabilityST : TFhirInstanceAvailability;
    Procedure SetAvailabilityST(value : TFhirInstanceAvailability);
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetBodySite(value : TFhirCoding);
    Procedure SetDateTime(value : TFhirDateTime);
    Function GetDateTimeST : TDateAndTime;
    Procedure SetDateTimeST(value : TDateAndTime);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirImagingStudySeries; overload;
    function Clone : TFhirImagingStudySeries; overload;
    {!script show}
  published
    {@member number
      The number of this series in the overall sequence.
    }
    property number : TFhirInteger read FNumber write SetNumber;
    {@member numberST
      Typed access to The number of this series in the overall sequence.
    }
    property numberST : String read GetNumberST write SetNumberST;

    {@member modality
      The modality of this series sequence.
    }
    property modality : TFhirEnum read FModality write SetModality;
    {@member modalityST
      Typed access to The modality of this series sequence.
    }
    property modalityST : TFhirModality read GetModalityST write SetModalityST;

    {@member uid
      Formal identifier for this series.
    }
    property uid : TFhirOid read FUid write SetUid;
    {@member uidST
      Typed access to Formal identifier for this series.
    }
    property uidST : String read GetUidST write SetUidST;

    {@member description
      A description of the series.
    }
    property description : TFhirString read FDescription write SetDescription;
    {@member descriptionST
      Typed access to A description of the series.
    }
    property descriptionST : String read GetDescriptionST write SetDescriptionST;

    {@member numberOfInstances
      Sequence that contains attributes from the.
    }
    property numberOfInstances : TFhirInteger read FNumberOfInstances write SetNumberOfInstances;
    {@member numberOfInstancesST
      Typed access to Sequence that contains attributes from the.
    }
    property numberOfInstancesST : String read GetNumberOfInstancesST write SetNumberOfInstancesST;

    {@member availability
      Availability of series (online, offline or nearline).
    }
    property availability : TFhirEnum read FAvailability write SetAvailability;
    {@member availabilityST
      Typed access to Availability of series (online, offline or nearline).
    }
    property availabilityST : TFhirInstanceAvailability read GetAvailabilityST write SetAvailabilityST;

    {@member url
      WADO-RS URI where Series is available.
    }
    property url : TFhirUri read FUrl write SetUrl;
    {@member urlST
      Typed access to WADO-RS URI where Series is available.
    }
    property urlST : String read GetUrlST write SetUrlST;

    {@member bodySite
      Body part examined. See  DICOM Part 16 Annex L for the mapping from DICOM to Snomed.
    }
    property bodySite : TFhirCoding read FBodySite write SetBodySite;

    {@member dateTime
      When the series started.
    }
    property dateTime : TFhirDateTime read FDateTime write SetDateTime;
    {@member dateTimeST
      Typed access to When the series started.
    }
    property dateTimeST : TDateAndTime read GetDateTimeST write SetDateTimeST;

    {@member instanceList
      A single image taken from a patient.
    }
    property instanceList : TFhirImagingStudySeriesInstanceList read FInstanceList;

  end;


  {@Class TFhirImagingStudySeriesList
    A list of FhirImagingStudySeries
  }
  {!.Net HL7Connect.Fhir.ImagingStudySeriesList}
  TFhirImagingStudySeriesList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImagingStudySeries;
    procedure SetItemN(index : Integer; value : TFhirImagingStudySeries);
  public
    {!script hide}
    function Link : TFhirImagingStudySeriesList; Overload;
    function Clone : TFhirImagingStudySeriesList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirImagingStudySeries to the end of the list.
    }
    function Append : TFhirImagingStudySeries;

    
    {@member AddItem
      Add an already existing FhirImagingStudySeries to the end of the list.
    }
    procedure AddItem(value : TFhirImagingStudySeries);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirImagingStudySeries) : Integer;
    

    {@member Insert
      Insert FhirImagingStudySeries before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirImagingStudySeries;
    

    {@member InsertItem
       Insert an existing FhirImagingStudySeries before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirImagingStudySeries);
    
    {@member Item
       Get the iIndexth FhirImagingStudySeries. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirImagingStudySeries. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirImagingStudySeries);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirImagingStudySeries;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirImagingStudySeries[index : Integer] : TFhirImagingStudySeries read GetItemN write SetItemN; default;
  End;


  {@Class TFhirImagingStudySeriesInstance : TFhirElement
    A single image taken from a patient.
  }
  {!.Net HL7Connect.Fhir.ImagingStudySeriesInstance}
  TFhirImagingStudySeriesInstance = class (TFhirBackboneElement)
  private
    FNumber : TFhirInteger;
    FUid : TFhirOid;
    FSopclass : TFhirOid;
    FType_ : TFhirString;
    FTitle : TFhirString;
    FUrl : TFhirUri;
    FAttachment : TFhirResourceReference{Resource};
    Procedure SetNumber(value : TFhirInteger);
    Function GetNumberST : String;
    Procedure SetNumberST(value : String);
    Procedure SetUid(value : TFhirOid);
    Function GetUidST : String;
    Procedure SetUidST(value : String);
    Procedure SetSopclass(value : TFhirOid);
    Function GetSopclassST : String;
    Procedure SetSopclassST(value : String);
    Procedure SetType_(value : TFhirString);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetAttachment(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirImagingStudySeriesInstance; overload;
    function Clone : TFhirImagingStudySeriesInstance; overload;
    {!script show}
  published
    {@member number
      The number of this image in the series.
    }
    property number : TFhirInteger read FNumber write SetNumber;
    {@member numberST
      Typed access to The number of this image in the series.
    }
    property numberST : String read GetNumberST write SetNumberST;

    {@member uid
      Formal identifier for this image.
    }
    property uid : TFhirOid read FUid write SetUid;
    {@member uidST
      Typed access to Formal identifier for this image.
    }
    property uidST : String read GetUidST write SetUidST;

    {@member sopclass
      DICOM Image type.
    }
    property sopclass : TFhirOid read FSopclass write SetSopclass;
    {@member sopclassST
      Typed access to DICOM Image type.
    }
    property sopclassST : String read GetSopclassST write SetSopclassST;

    {@member type_
      Type of instance (image etc) (0004,1430).
    }
    property type_ : TFhirString read FType_ write SetType_;
    {@member type_ST
      Typed access to Type of instance (image etc) (0004,1430).
    }
    property type_ST : String read GetType_ST write SetType_ST;

    {@member title
      Description (0070,0080 | 0040,A043 > 0008,0104 | 0042,0010 | 0008,0008).
    }
    property title : TFhirString read FTitle write SetTitle;
    {@member titleST
      Typed access to Description (0070,0080 | 0040,A043 > 0008,0104 | 0042,0010 | 0008,0008).
    }
    property titleST : String read GetTitleST write SetTitleST;

    {@member url
      WADO-RS url where image is available.
    }
    property url : TFhirUri read FUrl write SetUrl;
    {@member urlST
      Typed access to WADO-RS url where image is available.
    }
    property urlST : String read GetUrlST write SetUrlST;

    {@member attachment
      A FHIR resource with content for this instance.
    }
    property attachment : TFhirResourceReference{Resource} read FAttachment write SetAttachment;

  end;


  {@Class TFhirImagingStudySeriesInstanceList
    A list of FhirImagingStudySeriesInstance
  }
  {!.Net HL7Connect.Fhir.ImagingStudySeriesInstanceList}
  TFhirImagingStudySeriesInstanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImagingStudySeriesInstance;
    procedure SetItemN(index : Integer; value : TFhirImagingStudySeriesInstance);
  public
    {!script hide}
    function Link : TFhirImagingStudySeriesInstanceList; Overload;
    function Clone : TFhirImagingStudySeriesInstanceList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirImagingStudySeriesInstance to the end of the list.
    }
    function Append : TFhirImagingStudySeriesInstance;

    
    {@member AddItem
      Add an already existing FhirImagingStudySeriesInstance to the end of the list.
    }
    procedure AddItem(value : TFhirImagingStudySeriesInstance);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirImagingStudySeriesInstance) : Integer;
    

    {@member Insert
      Insert FhirImagingStudySeriesInstance before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirImagingStudySeriesInstance;
    

    {@member InsertItem
       Insert an existing FhirImagingStudySeriesInstance before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirImagingStudySeriesInstance);
    
    {@member Item
       Get the iIndexth FhirImagingStudySeriesInstance. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirImagingStudySeriesInstance. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirImagingStudySeriesInstance);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirImagingStudySeriesInstance;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirImagingStudySeriesInstances[index : Integer] : TFhirImagingStudySeriesInstance read GetItemN write SetItemN; default;
  End;


  {@Class TFhirImmunizationExplanation : TFhirElement
    Reasons why a vaccine was administered or refused.
  }
  {!.Net HL7Connect.Fhir.ImmunizationExplanation}
  TFhirImmunizationExplanation = class (TFhirBackboneElement)
  private
    FreasonList : TFhirCodeableConceptList;
    FrefusalReasonList : TFhirCodeableConceptList;
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirImmunizationExplanation; overload;
    function Clone : TFhirImmunizationExplanation; overload;
    {!script show}
  published
    {@member reasonList
      Reasons why a vaccine was administered.
    }
    property reasonList : TFhirCodeableConceptList read FReasonList;

    {@member refusalReasonList
      Refusal or exemption reasons.
    }
    property refusalReasonList : TFhirCodeableConceptList read FRefusalReasonList;

  end;


  {@Class TFhirImmunizationExplanationList
    A list of FhirImmunizationExplanation
  }
  {!.Net HL7Connect.Fhir.ImmunizationExplanationList}
  TFhirImmunizationExplanationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationExplanation;
    procedure SetItemN(index : Integer; value : TFhirImmunizationExplanation);
  public
    {!script hide}
    function Link : TFhirImmunizationExplanationList; Overload;
    function Clone : TFhirImmunizationExplanationList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirImmunizationExplanation to the end of the list.
    }
    function Append : TFhirImmunizationExplanation;

    
    {@member AddItem
      Add an already existing FhirImmunizationExplanation to the end of the list.
    }
    procedure AddItem(value : TFhirImmunizationExplanation);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirImmunizationExplanation) : Integer;
    

    {@member Insert
      Insert FhirImmunizationExplanation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirImmunizationExplanation;
    

    {@member InsertItem
       Insert an existing FhirImmunizationExplanation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirImmunizationExplanation);
    
    {@member Item
       Get the iIndexth FhirImmunizationExplanation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirImmunizationExplanation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationExplanation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirImmunizationExplanation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirImmunizationExplanations[index : Integer] : TFhirImmunizationExplanation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirImmunizationReaction : TFhirElement
    Categorical data indicating that an adverse event is associated in time to an immunization.
  }
  {!.Net HL7Connect.Fhir.ImmunizationReaction}
  TFhirImmunizationReaction = class (TFhirBackboneElement)
  private
    FDate : TFhirDateTime;
    FDetail : TFhirResourceReference{Resource};
    FReported : TFhirBoolean;
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TDateAndTime;
    Procedure SetDateST(value : TDateAndTime);
    Procedure SetDetail(value : TFhirResourceReference{Resource});
    Procedure SetReported(value : TFhirBoolean);
    Function GetReportedST : Boolean;
    Procedure SetReportedST(value : Boolean);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirImmunizationReaction; overload;
    function Clone : TFhirImmunizationReaction; overload;
    {!script show}
  published
    {@member date
      Date of reaction to the immunization.
    }
    property date : TFhirDateTime read FDate write SetDate;
    {@member dateST
      Typed access to Date of reaction to the immunization.
    }
    property dateST : TDateAndTime read GetDateST write SetDateST;

    {@member detail
      Details of the reaction.
    }
    property detail : TFhirResourceReference{Resource} read FDetail write SetDetail;

    {@member reported
      Self-reported indicator.
    }
    property reported : TFhirBoolean read FReported write SetReported;
    {@member reportedST
      Typed access to Self-reported indicator.
    }
    property reportedST : Boolean read GetReportedST write SetReportedST;

  end;


  {@Class TFhirImmunizationReactionList
    A list of FhirImmunizationReaction
  }
  {!.Net HL7Connect.Fhir.ImmunizationReactionList}
  TFhirImmunizationReactionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationReaction;
    procedure SetItemN(index : Integer; value : TFhirImmunizationReaction);
  public
    {!script hide}
    function Link : TFhirImmunizationReactionList; Overload;
    function Clone : TFhirImmunizationReactionList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirImmunizationReaction to the end of the list.
    }
    function Append : TFhirImmunizationReaction;

    
    {@member AddItem
      Add an already existing FhirImmunizationReaction to the end of the list.
    }
    procedure AddItem(value : TFhirImmunizationReaction);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirImmunizationReaction) : Integer;
    

    {@member Insert
      Insert FhirImmunizationReaction before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirImmunizationReaction;
    

    {@member InsertItem
       Insert an existing FhirImmunizationReaction before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirImmunizationReaction);
    
    {@member Item
       Get the iIndexth FhirImmunizationReaction. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirImmunizationReaction. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationReaction);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirImmunizationReaction;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirImmunizationReactions[index : Integer] : TFhirImmunizationReaction read GetItemN write SetItemN; default;
  End;


  {@Class TFhirImmunizationVaccinationProtocol : TFhirElement
    Contains information about the protocol(s) under which the vaccine was administered.
  }
  {!.Net HL7Connect.Fhir.ImmunizationVaccinationProtocol}
  TFhirImmunizationVaccinationProtocol = class (TFhirBackboneElement)
  private
    FDoseSequence : TFhirInteger;
    FDescription : TFhirString;
    FAuthority : TFhirResourceReference{TFhirOrganization};
    FSeries : TFhirString;
    FSeriesDoses : TFhirInteger;
    FDoseTarget : TFhirCodeableConcept;
    FDoseStatus : TFhirCodeableConcept;
    FDoseStatusReason : TFhirCodeableConcept;
    Procedure SetDoseSequence(value : TFhirInteger);
    Function GetDoseSequenceST : String;
    Procedure SetDoseSequenceST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetAuthority(value : TFhirResourceReference{TFhirOrganization});
    Procedure SetSeries(value : TFhirString);
    Function GetSeriesST : String;
    Procedure SetSeriesST(value : String);
    Procedure SetSeriesDoses(value : TFhirInteger);
    Function GetSeriesDosesST : String;
    Procedure SetSeriesDosesST(value : String);
    Procedure SetDoseTarget(value : TFhirCodeableConcept);
    Procedure SetDoseStatus(value : TFhirCodeableConcept);
    Procedure SetDoseStatusReason(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirImmunizationVaccinationProtocol; overload;
    function Clone : TFhirImmunizationVaccinationProtocol; overload;
    {!script show}
  published
    {@member doseSequence
      Nominal position in a series.
    }
    property doseSequence : TFhirInteger read FDoseSequence write SetDoseSequence;
    {@member doseSequenceST
      Typed access to Nominal position in a series.
    }
    property doseSequenceST : String read GetDoseSequenceST write SetDoseSequenceST;

    {@member description
      Contains the description about the protocol under which the vaccine was administered.
    }
    property description : TFhirString read FDescription write SetDescription;
    {@member descriptionST
      Typed access to Contains the description about the protocol under which the vaccine was administered.
    }
    property descriptionST : String read GetDescriptionST write SetDescriptionST;

    {@member authority
      Indicates the authority who published the protocol?  E.g. ACIP.
    }
    property authority : TFhirResourceReference{TFhirOrganization} read FAuthority write SetAuthority;

    {@member series
      One possible path to achieve presumed immunity against a disease - within the context of an authority.
    }
    property series : TFhirString read FSeries write SetSeries;
    {@member seriesST
      Typed access to One possible path to achieve presumed immunity against a disease - within the context of an authority.
    }
    property seriesST : String read GetSeriesST write SetSeriesST;

    {@member seriesDoses
      The recommended number of doses to achieve immunity.
    }
    property seriesDoses : TFhirInteger read FSeriesDoses write SetSeriesDoses;
    {@member seriesDosesST
      Typed access to The recommended number of doses to achieve immunity.
    }
    property seriesDosesST : String read GetSeriesDosesST write SetSeriesDosesST;

    {@member doseTarget
      The targeted disease.
    }
    property doseTarget : TFhirCodeableConcept read FDoseTarget write SetDoseTarget;

    {@member doseStatus
      Indicates if the immunization event should "count" against  the protocol.
    }
    property doseStatus : TFhirCodeableConcept read FDoseStatus write SetDoseStatus;

    {@member doseStatusReason
      Provides an explanation as to why a immunization event should or should not count against the protocol.
    }
    property doseStatusReason : TFhirCodeableConcept read FDoseStatusReason write SetDoseStatusReason;

  end;


  {@Class TFhirImmunizationVaccinationProtocolList
    A list of FhirImmunizationVaccinationProtocol
  }
  {!.Net HL7Connect.Fhir.ImmunizationVaccinationProtocolList}
  TFhirImmunizationVaccinationProtocolList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationVaccinationProtocol;
    procedure SetItemN(index : Integer; value : TFhirImmunizationVaccinationProtocol);
  public
    {!script hide}
    function Link : TFhirImmunizationVaccinationProtocolList; Overload;
    function Clone : TFhirImmunizationVaccinationProtocolList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirImmunizationVaccinationProtocol to the end of the list.
    }
    function Append : TFhirImmunizationVaccinationProtocol;

    
    {@member AddItem
      Add an already existing FhirImmunizationVaccinationProtocol to the end of the list.
    }
    procedure AddItem(value : TFhirImmunizationVaccinationProtocol);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirImmunizationVaccinationProtocol) : Integer;
    

    {@member Insert
      Insert FhirImmunizationVaccinationProtocol before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirImmunizationVaccinationProtocol;
    

    {@member InsertItem
       Insert an existing FhirImmunizationVaccinationProtocol before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirImmunizationVaccinationProtocol);
    
    {@member Item
       Get the iIndexth FhirImmunizationVaccinationProtocol. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirImmunizationVaccinationProtocol. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationVaccinationProtocol);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirImmunizationVaccinationProtocol;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirImmunizationVaccinationProtocols[index : Integer] : TFhirImmunizationVaccinationProtocol read GetItemN write SetItemN; default;
  End;


  {@Class TFhirImmunizationRecommendationRecommendation : TFhirElement
    Vaccine administration recommendations.
  }
  {!.Net HL7Connect.Fhir.ImmunizationRecommendationRecommendation}
  TFhirImmunizationRecommendationRecommendation = class (TFhirBackboneElement)
  private
    FDate : TFhirDateTime;
    FVaccineType : TFhirCodeableConcept;
    FDoseNumber : TFhirInteger;
    FForecastStatus : TFhirCodeableConcept;
    FdateCriterionList : TFhirImmunizationRecommendationRecommendationDateCriterionList;
    FProtocol : TFhirImmunizationRecommendationRecommendationProtocol;
    FsupportingImmunizationList : TFhirResourceReferenceList{TFhirImmunization};
    FsupportingPatientInformationList : TFhirResourceReferenceList{Resource};
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TDateAndTime;
    Procedure SetDateST(value : TDateAndTime);
    Procedure SetVaccineType(value : TFhirCodeableConcept);
    Procedure SetDoseNumber(value : TFhirInteger);
    Function GetDoseNumberST : String;
    Procedure SetDoseNumberST(value : String);
    Procedure SetForecastStatus(value : TFhirCodeableConcept);
    Procedure SetProtocol(value : TFhirImmunizationRecommendationRecommendationProtocol);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirImmunizationRecommendationRecommendation; overload;
    function Clone : TFhirImmunizationRecommendationRecommendation; overload;
    {!script show}
  published
    {@member date
      The date the immunization recommendation was created.
    }
    property date : TFhirDateTime read FDate write SetDate;
    {@member dateST
      Typed access to The date the immunization recommendation was created.
    }
    property dateST : TDateAndTime read GetDateST write SetDateST;

    {@member vaccineType
      Vaccine that pertains to the recommendation.
    }
    property vaccineType : TFhirCodeableConcept read FVaccineType write SetVaccineType;

    {@member doseNumber
      This indicates the next recommended dose number (e.g. dose 2 is the next recommended dose).
    }
    property doseNumber : TFhirInteger read FDoseNumber write SetDoseNumber;
    {@member doseNumberST
      Typed access to This indicates the next recommended dose number (e.g. dose 2 is the next recommended dose).
    }
    property doseNumberST : String read GetDoseNumberST write SetDoseNumberST;

    {@member forecastStatus
      Vaccine administration status.
    }
    property forecastStatus : TFhirCodeableConcept read FForecastStatus write SetForecastStatus;

    {@member dateCriterionList
      Vaccine date recommendations - e.g. earliest date to administer, latest date to administer, etc.
    }
    property dateCriterionList : TFhirImmunizationRecommendationRecommendationDateCriterionList read FDateCriterionList;

    {@member protocol
      Contains information about the protocol under which the vaccine was administered.
    }
    property protocol : TFhirImmunizationRecommendationRecommendationProtocol read FProtocol write SetProtocol;

    {@member supportingImmunizationList
      Immunization event history that supports the status and recommendation.
    }
    property supportingImmunizationList : TFhirResourceReferenceList{TFhirImmunization} read FSupportingImmunizationList;

    {@member supportingPatientInformationList
      Patient Information that supports the status and recommendation.  This includes patient observations, adverse reactions and allergy/intolerance information.
    }
    property supportingPatientInformationList : TFhirResourceReferenceList{Resource} read FSupportingPatientInformationList;

  end;


  {@Class TFhirImmunizationRecommendationRecommendationList
    A list of FhirImmunizationRecommendationRecommendation
  }
  {!.Net HL7Connect.Fhir.ImmunizationRecommendationRecommendationList}
  TFhirImmunizationRecommendationRecommendationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationRecommendationRecommendation;
    procedure SetItemN(index : Integer; value : TFhirImmunizationRecommendationRecommendation);
  public
    {!script hide}
    function Link : TFhirImmunizationRecommendationRecommendationList; Overload;
    function Clone : TFhirImmunizationRecommendationRecommendationList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirImmunizationRecommendationRecommendation to the end of the list.
    }
    function Append : TFhirImmunizationRecommendationRecommendation;

    
    {@member AddItem
      Add an already existing FhirImmunizationRecommendationRecommendation to the end of the list.
    }
    procedure AddItem(value : TFhirImmunizationRecommendationRecommendation);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirImmunizationRecommendationRecommendation) : Integer;
    

    {@member Insert
      Insert FhirImmunizationRecommendationRecommendation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirImmunizationRecommendationRecommendation;
    

    {@member InsertItem
       Insert an existing FhirImmunizationRecommendationRecommendation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirImmunizationRecommendationRecommendation);
    
    {@member Item
       Get the iIndexth FhirImmunizationRecommendationRecommendation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirImmunizationRecommendationRecommendation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationRecommendationRecommendation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirImmunizationRecommendationRecommendation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirImmunizationRecommendationRecommendations[index : Integer] : TFhirImmunizationRecommendationRecommendation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirImmunizationRecommendationRecommendationDateCriterion : TFhirElement
    Vaccine date recommendations - e.g. earliest date to administer, latest date to administer, etc.
  }
  {!.Net HL7Connect.Fhir.ImmunizationRecommendationRecommendationDateCriterion}
  TFhirImmunizationRecommendationRecommendationDateCriterion = class (TFhirBackboneElement)
  private
    FCode : TFhirCodeableConcept;
    FValue : TFhirDateTime;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetValue(value : TFhirDateTime);
    Function GetValueST : TDateAndTime;
    Procedure SetValueST(value : TDateAndTime);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirImmunizationRecommendationRecommendationDateCriterion; overload;
    function Clone : TFhirImmunizationRecommendationRecommendationDateCriterion; overload;
    {!script show}
  published
    {@member code
      Date classification of recommendation - e.g. earliest date to give, latest date to give, etc.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member value
      Date recommendation.
    }
    property value : TFhirDateTime read FValue write SetValue;
    {@member valueST
      Typed access to Date recommendation.
    }
    property valueST : TDateAndTime read GetValueST write SetValueST;

  end;


  {@Class TFhirImmunizationRecommendationRecommendationDateCriterionList
    A list of FhirImmunizationRecommendationRecommendationDateCriterion
  }
  {!.Net HL7Connect.Fhir.ImmunizationRecommendationRecommendationDateCriterionList}
  TFhirImmunizationRecommendationRecommendationDateCriterionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationRecommendationRecommendationDateCriterion;
    procedure SetItemN(index : Integer; value : TFhirImmunizationRecommendationRecommendationDateCriterion);
  public
    {!script hide}
    function Link : TFhirImmunizationRecommendationRecommendationDateCriterionList; Overload;
    function Clone : TFhirImmunizationRecommendationRecommendationDateCriterionList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirImmunizationRecommendationRecommendationDateCriterion to the end of the list.
    }
    function Append : TFhirImmunizationRecommendationRecommendationDateCriterion;

    
    {@member AddItem
      Add an already existing FhirImmunizationRecommendationRecommendationDateCriterion to the end of the list.
    }
    procedure AddItem(value : TFhirImmunizationRecommendationRecommendationDateCriterion);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirImmunizationRecommendationRecommendationDateCriterion) : Integer;
    

    {@member Insert
      Insert FhirImmunizationRecommendationRecommendationDateCriterion before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirImmunizationRecommendationRecommendationDateCriterion;
    

    {@member InsertItem
       Insert an existing FhirImmunizationRecommendationRecommendationDateCriterion before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirImmunizationRecommendationRecommendationDateCriterion);
    
    {@member Item
       Get the iIndexth FhirImmunizationRecommendationRecommendationDateCriterion. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirImmunizationRecommendationRecommendationDateCriterion. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationRecommendationRecommendationDateCriterion);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirImmunizationRecommendationRecommendationDateCriterion;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirImmunizationRecommendationRecommendationDateCriterions[index : Integer] : TFhirImmunizationRecommendationRecommendationDateCriterion read GetItemN write SetItemN; default;
  End;


  {@Class TFhirImmunizationRecommendationRecommendationProtocol : TFhirElement
    Contains information about the protocol under which the vaccine was administered.
  }
  {!.Net HL7Connect.Fhir.ImmunizationRecommendationRecommendationProtocol}
  TFhirImmunizationRecommendationRecommendationProtocol = class (TFhirBackboneElement)
  private
    FDoseSequence : TFhirInteger;
    FDescription : TFhirString;
    FAuthority : TFhirResourceReference{TFhirOrganization};
    FSeries : TFhirString;
    Procedure SetDoseSequence(value : TFhirInteger);
    Function GetDoseSequenceST : String;
    Procedure SetDoseSequenceST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetAuthority(value : TFhirResourceReference{TFhirOrganization});
    Procedure SetSeries(value : TFhirString);
    Function GetSeriesST : String;
    Procedure SetSeriesST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirImmunizationRecommendationRecommendationProtocol; overload;
    function Clone : TFhirImmunizationRecommendationRecommendationProtocol; overload;
    {!script show}
  published
    {@member doseSequence
      Indicates the nominal position in a series of the next dose.  This is the recommended dose number as per a specified protocol.
    }
    property doseSequence : TFhirInteger read FDoseSequence write SetDoseSequence;
    {@member doseSequenceST
      Typed access to Indicates the nominal position in a series of the next dose.  This is the recommended dose number as per a specified protocol.
    }
    property doseSequenceST : String read GetDoseSequenceST write SetDoseSequenceST;

    {@member description
      Contains the description about the protocol under which the vaccine was administered.
    }
    property description : TFhirString read FDescription write SetDescription;
    {@member descriptionST
      Typed access to Contains the description about the protocol under which the vaccine was administered.
    }
    property descriptionST : String read GetDescriptionST write SetDescriptionST;

    {@member authority
      Indicates the authority who published the protocol?  E.g. ACIP.
    }
    property authority : TFhirResourceReference{TFhirOrganization} read FAuthority write SetAuthority;

    {@member series
      One possible path to achieve presumed immunity against a disease - within the context of an authority.
    }
    property series : TFhirString read FSeries write SetSeries;
    {@member seriesST
      Typed access to One possible path to achieve presumed immunity against a disease - within the context of an authority.
    }
    property seriesST : String read GetSeriesST write SetSeriesST;

  end;


  {@Class TFhirImmunizationRecommendationRecommendationProtocolList
    A list of FhirImmunizationRecommendationRecommendationProtocol
  }
  {!.Net HL7Connect.Fhir.ImmunizationRecommendationRecommendationProtocolList}
  TFhirImmunizationRecommendationRecommendationProtocolList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationRecommendationRecommendationProtocol;
    procedure SetItemN(index : Integer; value : TFhirImmunizationRecommendationRecommendationProtocol);
  public
    {!script hide}
    function Link : TFhirImmunizationRecommendationRecommendationProtocolList; Overload;
    function Clone : TFhirImmunizationRecommendationRecommendationProtocolList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirImmunizationRecommendationRecommendationProtocol to the end of the list.
    }
    function Append : TFhirImmunizationRecommendationRecommendationProtocol;

    
    {@member AddItem
      Add an already existing FhirImmunizationRecommendationRecommendationProtocol to the end of the list.
    }
    procedure AddItem(value : TFhirImmunizationRecommendationRecommendationProtocol);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirImmunizationRecommendationRecommendationProtocol) : Integer;
    

    {@member Insert
      Insert FhirImmunizationRecommendationRecommendationProtocol before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirImmunizationRecommendationRecommendationProtocol;
    

    {@member InsertItem
       Insert an existing FhirImmunizationRecommendationRecommendationProtocol before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirImmunizationRecommendationRecommendationProtocol);
    
    {@member Item
       Get the iIndexth FhirImmunizationRecommendationRecommendationProtocol. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirImmunizationRecommendationRecommendationProtocol. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationRecommendationRecommendationProtocol);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirImmunizationRecommendationRecommendationProtocol;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirImmunizationRecommendationRecommendationProtocols[index : Integer] : TFhirImmunizationRecommendationRecommendationProtocol read GetItemN write SetItemN; default;
  End;


  {@Class TFhirListEntry : TFhirElement
    Entries in this list.
  }
  {!.Net HL7Connect.Fhir.ListEntry}
  TFhirListEntry = class (TFhirBackboneElement)
  private
    FflagList : TFhirCodeableConceptList;
    FDeleted : TFhirBoolean;
    FDate : TFhirDateTime;
    FItem : TFhirResourceReference{Resource};
    Procedure SetDeleted(value : TFhirBoolean);
    Function GetDeletedST : Boolean;
    Procedure SetDeletedST(value : Boolean);
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TDateAndTime;
    Procedure SetDateST(value : TDateAndTime);
    Procedure SetItem(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirListEntry; overload;
    function Clone : TFhirListEntry; overload;
    {!script show}
  published
    {@member flagList
      The flag allows the system constructing the list to make one or more statements about the role and significance of the item in the list.
    }
    property flagList : TFhirCodeableConceptList read FFlagList;

    {@member deleted
      True if this item is marked as deleted in the list.
    }
    property deleted : TFhirBoolean read FDeleted write SetDeleted;
    {@member deletedST
      Typed access to True if this item is marked as deleted in the list.
    }
    property deletedST : Boolean read GetDeletedST write SetDeletedST;

    {@member date
      When this item was added to the list.
    }
    property date : TFhirDateTime read FDate write SetDate;
    {@member dateST
      Typed access to When this item was added to the list.
    }
    property dateST : TDateAndTime read GetDateST write SetDateST;

    {@member item
      A reference to the actual resource from which data was derived.
    }
    property item : TFhirResourceReference{Resource} read FItem write SetItem;

  end;


  {@Class TFhirListEntryList
    A list of FhirListEntry
  }
  {!.Net HL7Connect.Fhir.ListEntryList}
  TFhirListEntryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirListEntry;
    procedure SetItemN(index : Integer; value : TFhirListEntry);
  public
    {!script hide}
    function Link : TFhirListEntryList; Overload;
    function Clone : TFhirListEntryList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirListEntry to the end of the list.
    }
    function Append : TFhirListEntry;

    
    {@member AddItem
      Add an already existing FhirListEntry to the end of the list.
    }
    procedure AddItem(value : TFhirListEntry);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirListEntry) : Integer;
    

    {@member Insert
      Insert FhirListEntry before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirListEntry;
    

    {@member InsertItem
       Insert an existing FhirListEntry before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirListEntry);
    
    {@member Item
       Get the iIndexth FhirListEntry. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirListEntry. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirListEntry);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirListEntry;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirListEntries[index : Integer] : TFhirListEntry read GetItemN write SetItemN; default;
  End;


  {@Class TFhirLocationPosition : TFhirElement
    The absolute geographic location of the Location, expressed in a KML compatible manner (see notes below for KML).
  }
  {!.Net HL7Connect.Fhir.LocationPosition}
  TFhirLocationPosition = class (TFhirBackboneElement)
  private
    FLongitude : TFhirDecimal;
    FLatitude : TFhirDecimal;
    FAltitude : TFhirDecimal;
    Procedure SetLongitude(value : TFhirDecimal);
    Function GetLongitudeST : String;
    Procedure SetLongitudeST(value : String);
    Procedure SetLatitude(value : TFhirDecimal);
    Function GetLatitudeST : String;
    Procedure SetLatitudeST(value : String);
    Procedure SetAltitude(value : TFhirDecimal);
    Function GetAltitudeST : String;
    Procedure SetAltitudeST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirLocationPosition; overload;
    function Clone : TFhirLocationPosition; overload;
    {!script show}
  published
    {@member longitude
      Longitude. The value domain and the interpretation are the same as for the text of the longitude element in KML (see notes below).
    }
    property longitude : TFhirDecimal read FLongitude write SetLongitude;
    {@member longitudeST
      Typed access to Longitude. The value domain and the interpretation are the same as for the text of the longitude element in KML (see notes below).
    }
    property longitudeST : String read GetLongitudeST write SetLongitudeST;

    {@member latitude
      Latitude. The value domain and the interpretation are the same as for the text of the latitude element in KML (see notes below).
    }
    property latitude : TFhirDecimal read FLatitude write SetLatitude;
    {@member latitudeST
      Typed access to Latitude. The value domain and the interpretation are the same as for the text of the latitude element in KML (see notes below).
    }
    property latitudeST : String read GetLatitudeST write SetLatitudeST;

    {@member altitude
      Altitude. The value domain and the interpretation are the same as for the text of the altitude element in KML (see notes below).
    }
    property altitude : TFhirDecimal read FAltitude write SetAltitude;
    {@member altitudeST
      Typed access to Altitude. The value domain and the interpretation are the same as for the text of the altitude element in KML (see notes below).
    }
    property altitudeST : String read GetAltitudeST write SetAltitudeST;

  end;


  {@Class TFhirLocationPositionList
    A list of FhirLocationPosition
  }
  {!.Net HL7Connect.Fhir.LocationPositionList}
  TFhirLocationPositionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirLocationPosition;
    procedure SetItemN(index : Integer; value : TFhirLocationPosition);
  public
    {!script hide}
    function Link : TFhirLocationPositionList; Overload;
    function Clone : TFhirLocationPositionList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirLocationPosition to the end of the list.
    }
    function Append : TFhirLocationPosition;

    
    {@member AddItem
      Add an already existing FhirLocationPosition to the end of the list.
    }
    procedure AddItem(value : TFhirLocationPosition);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirLocationPosition) : Integer;
    

    {@member Insert
      Insert FhirLocationPosition before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirLocationPosition;
    

    {@member InsertItem
       Insert an existing FhirLocationPosition before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirLocationPosition);
    
    {@member Item
       Get the iIndexth FhirLocationPosition. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirLocationPosition. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirLocationPosition);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirLocationPosition;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirLocationPositions[index : Integer] : TFhirLocationPosition read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationProduct : TFhirElement
    Information that only applies to products (not packages).
  }
  {!.Net HL7Connect.Fhir.MedicationProduct}
  TFhirMedicationProduct = class (TFhirBackboneElement)
  private
    FForm : TFhirCodeableConcept;
    FingredientList : TFhirMedicationProductIngredientList;
    Procedure SetForm(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationProduct; overload;
    function Clone : TFhirMedicationProduct; overload;
    {!script show}
  published
    {@member form
      Describes the form of the item.  Powder; tables; carton.
    }
    property form : TFhirCodeableConcept read FForm write SetForm;

    {@member ingredientList
      Identifies a particular constituent of interest in the product.
    }
    property ingredientList : TFhirMedicationProductIngredientList read FIngredientList;

  end;


  {@Class TFhirMedicationProductList
    A list of FhirMedicationProduct
  }
  {!.Net HL7Connect.Fhir.MedicationProductList}
  TFhirMedicationProductList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationProduct;
    procedure SetItemN(index : Integer; value : TFhirMedicationProduct);
  public
    {!script hide}
    function Link : TFhirMedicationProductList; Overload;
    function Clone : TFhirMedicationProductList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMedicationProduct to the end of the list.
    }
    function Append : TFhirMedicationProduct;

    
    {@member AddItem
      Add an already existing FhirMedicationProduct to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationProduct);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationProduct) : Integer;
    

    {@member Insert
      Insert FhirMedicationProduct before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationProduct;
    

    {@member InsertItem
       Insert an existing FhirMedicationProduct before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationProduct);
    
    {@member Item
       Get the iIndexth FhirMedicationProduct. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationProduct. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationProduct);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationProduct;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationProducts[index : Integer] : TFhirMedicationProduct read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationProductIngredient : TFhirElement
    Identifies a particular constituent of interest in the product.
  }
  {!.Net HL7Connect.Fhir.MedicationProductIngredient}
  TFhirMedicationProductIngredient = class (TFhirBackboneElement)
  private
    FItem : TFhirResourceReference{Resource};
    FAmount : TFhirRatio;
    Procedure SetItem(value : TFhirResourceReference{Resource});
    Procedure SetAmount(value : TFhirRatio);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationProductIngredient; overload;
    function Clone : TFhirMedicationProductIngredient; overload;
    {!script show}
  published
    {@member item
      The actual ingredient - either a substance (simple ingredient) or another medication.
    }
    property item : TFhirResourceReference{Resource} read FItem write SetItem;

    {@member amount
      Specifies how many (or how much) of the items there are in this Medication.  E.g. 250 mg per tablet.
    }
    property amount : TFhirRatio read FAmount write SetAmount;

  end;


  {@Class TFhirMedicationProductIngredientList
    A list of FhirMedicationProductIngredient
  }
  {!.Net HL7Connect.Fhir.MedicationProductIngredientList}
  TFhirMedicationProductIngredientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationProductIngredient;
    procedure SetItemN(index : Integer; value : TFhirMedicationProductIngredient);
  public
    {!script hide}
    function Link : TFhirMedicationProductIngredientList; Overload;
    function Clone : TFhirMedicationProductIngredientList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMedicationProductIngredient to the end of the list.
    }
    function Append : TFhirMedicationProductIngredient;

    
    {@member AddItem
      Add an already existing FhirMedicationProductIngredient to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationProductIngredient);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationProductIngredient) : Integer;
    

    {@member Insert
      Insert FhirMedicationProductIngredient before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationProductIngredient;
    

    {@member InsertItem
       Insert an existing FhirMedicationProductIngredient before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationProductIngredient);
    
    {@member Item
       Get the iIndexth FhirMedicationProductIngredient. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationProductIngredient. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationProductIngredient);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationProductIngredient;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationProductIngredients[index : Integer] : TFhirMedicationProductIngredient read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationPackage : TFhirElement
    Information that only applies to packages (not products).
  }
  {!.Net HL7Connect.Fhir.MedicationPackage}
  TFhirMedicationPackage = class (TFhirBackboneElement)
  private
    FContainer : TFhirCodeableConcept;
    FcontentList : TFhirMedicationPackageContentList;
    Procedure SetContainer(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationPackage; overload;
    function Clone : TFhirMedicationPackage; overload;
    {!script show}
  published
    {@member container
      The kind of container that this package comes as.
    }
    property container : TFhirCodeableConcept read FContainer write SetContainer;

    {@member contentList
      A set of components that go to make up the described item.
    }
    property contentList : TFhirMedicationPackageContentList read FContentList;

  end;


  {@Class TFhirMedicationPackageList
    A list of FhirMedicationPackage
  }
  {!.Net HL7Connect.Fhir.MedicationPackageList}
  TFhirMedicationPackageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationPackage;
    procedure SetItemN(index : Integer; value : TFhirMedicationPackage);
  public
    {!script hide}
    function Link : TFhirMedicationPackageList; Overload;
    function Clone : TFhirMedicationPackageList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMedicationPackage to the end of the list.
    }
    function Append : TFhirMedicationPackage;

    
    {@member AddItem
      Add an already existing FhirMedicationPackage to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationPackage);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationPackage) : Integer;
    

    {@member Insert
      Insert FhirMedicationPackage before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationPackage;
    

    {@member InsertItem
       Insert an existing FhirMedicationPackage before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationPackage);
    
    {@member Item
       Get the iIndexth FhirMedicationPackage. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationPackage. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationPackage);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationPackage;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationPackages[index : Integer] : TFhirMedicationPackage read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationPackageContent : TFhirElement
    A set of components that go to make up the described item.
  }
  {!.Net HL7Connect.Fhir.MedicationPackageContent}
  TFhirMedicationPackageContent = class (TFhirBackboneElement)
  private
    FItem : TFhirResourceReference{TFhirMedication};
    FAmount : TFhirQuantity;
    Procedure SetItem(value : TFhirResourceReference{TFhirMedication});
    Procedure SetAmount(value : TFhirQuantity);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationPackageContent; overload;
    function Clone : TFhirMedicationPackageContent; overload;
    {!script show}
  published
    {@member item
      Identifies one of the items in the package.
    }
    property item : TFhirResourceReference{TFhirMedication} read FItem write SetItem;

    {@member amount
      The amount of the product that is in the package.
    }
    property amount : TFhirQuantity read FAmount write SetAmount;

  end;


  {@Class TFhirMedicationPackageContentList
    A list of FhirMedicationPackageContent
  }
  {!.Net HL7Connect.Fhir.MedicationPackageContentList}
  TFhirMedicationPackageContentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationPackageContent;
    procedure SetItemN(index : Integer; value : TFhirMedicationPackageContent);
  public
    {!script hide}
    function Link : TFhirMedicationPackageContentList; Overload;
    function Clone : TFhirMedicationPackageContentList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMedicationPackageContent to the end of the list.
    }
    function Append : TFhirMedicationPackageContent;

    
    {@member AddItem
      Add an already existing FhirMedicationPackageContent to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationPackageContent);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationPackageContent) : Integer;
    

    {@member Insert
      Insert FhirMedicationPackageContent before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationPackageContent;
    

    {@member InsertItem
       Insert an existing FhirMedicationPackageContent before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationPackageContent);
    
    {@member Item
       Get the iIndexth FhirMedicationPackageContent. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationPackageContent. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationPackageContent);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationPackageContent;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationPackageContents[index : Integer] : TFhirMedicationPackageContent read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationAdministrationDosage : TFhirElement
    Provides details of how much of the medication was administered.
  }
  {!.Net HL7Connect.Fhir.MedicationAdministrationDosage}
  TFhirMedicationAdministrationDosage = class (TFhirBackboneElement)
  private
    FTiming : TFhirType;
    FAsNeeded : TFhirType;
    FSite : TFhirCodeableConcept;
    FRoute : TFhirCodeableConcept;
    FMethod : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FRate : TFhirRatio;
    FMaxDosePerPeriod : TFhirRatio;
    Procedure SetTiming(value : TFhirType);
    Procedure SetAsNeeded(value : TFhirType);
    Procedure SetSite(value : TFhirCodeableConcept);
    Procedure SetRoute(value : TFhirCodeableConcept);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetRate(value : TFhirRatio);
    Procedure SetMaxDosePerPeriod(value : TFhirRatio);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationAdministrationDosage; overload;
    function Clone : TFhirMedicationAdministrationDosage; overload;
    {!script show}
  published
    {@member timing
      The timing schedule for giving the medication to the patient.  This may be a single time point (using dateTime) or it may be a start and end dateTime (Period).
    }
    property timing : TFhirType read FTiming write SetTiming;

    {@member asNeeded
      If set to true or if specified as a CodeableConcept, indicates that the medication is only taken when needed within the specified schedule rather than at every scheduled dose.  If a CodeableConcept is present, it indicates the pre-condition for taking the Medication.
    }
    property asNeeded : TFhirType read FAsNeeded write SetAsNeeded;

    {@member site
      A coded specification of the anatomic site where the medication first entered the body.  E.g. "left arm".
    }
    property site : TFhirCodeableConcept read FSite write SetSite;

    {@member route
      A code specifying the route or physiological path of administration of a therapeutic agent into or onto the patient.   E.g. topical, intravenous, etc.
    }
    property route : TFhirCodeableConcept read FRoute write SetRoute;

    {@member method
      A coded value indicating the method by which the medication was introduced into or onto the body. Most commonly used for injections.  Examples:  Slow Push; Deep IV.

Terminologies used often pre-coordinate this term with the route and or form of administration.
    }
    property method : TFhirCodeableConcept read FMethod write SetMethod;

    {@member quantity
      The amount of the medication given at one administration event.   Use this value when the administration is essentially an instantaneous event such as a swallowing a tablet or giving an injection.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;

    {@member rate
      Identifies the speed with which the medication was introduced into the patient. Typically the rate for an infusion e.g. 200ml in 2 hours.  May also expressed as a rate per unit of time such as 100ml per hour - the duration is then not specified, or is specified in the quantity.
    }
    property rate : TFhirRatio read FRate write SetRate;

    {@member maxDosePerPeriod
      The maximum total quantity of a therapeutic substance that was administered to the patient over the specified period of time. E.g. 1000mg in 24 hours.
    }
    property maxDosePerPeriod : TFhirRatio read FMaxDosePerPeriod write SetMaxDosePerPeriod;

  end;


  {@Class TFhirMedicationAdministrationDosageList
    A list of FhirMedicationAdministrationDosage
  }
  {!.Net HL7Connect.Fhir.MedicationAdministrationDosageList}
  TFhirMedicationAdministrationDosageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationAdministrationDosage;
    procedure SetItemN(index : Integer; value : TFhirMedicationAdministrationDosage);
  public
    {!script hide}
    function Link : TFhirMedicationAdministrationDosageList; Overload;
    function Clone : TFhirMedicationAdministrationDosageList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMedicationAdministrationDosage to the end of the list.
    }
    function Append : TFhirMedicationAdministrationDosage;

    
    {@member AddItem
      Add an already existing FhirMedicationAdministrationDosage to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationAdministrationDosage);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationAdministrationDosage) : Integer;
    

    {@member Insert
      Insert FhirMedicationAdministrationDosage before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationAdministrationDosage;
    

    {@member InsertItem
       Insert an existing FhirMedicationAdministrationDosage before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationAdministrationDosage);
    
    {@member Item
       Get the iIndexth FhirMedicationAdministrationDosage. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationAdministrationDosage. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationAdministrationDosage);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationAdministrationDosage;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationAdministrationDosages[index : Integer] : TFhirMedicationAdministrationDosage read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationDispenseDispense : TFhirElement
    Indicates the details of the dispense event such as the days supply and quantity of medication dispensed.
  }
  {!.Net HL7Connect.Fhir.MedicationDispenseDispense}
  TFhirMedicationDispenseDispense = class (TFhirBackboneElement)
  private
    FIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FMedication : TFhirResourceReference{TFhirMedication};
    FWhenPrepared : TFhirDateTime;
    FWhenHandedOver : TFhirDateTime;
    FDestination : TFhirResourceReference{TFhirLocation};
    FreceiverList : TFhirResourceReferenceList{Resource};
    FdosageList : TFhirMedicationDispenseDispenseDosageList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirMedicationDispenseStatus;
    Procedure SetStatusST(value : TFhirMedicationDispenseStatus);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetMedication(value : TFhirResourceReference{TFhirMedication});
    Procedure SetWhenPrepared(value : TFhirDateTime);
    Function GetWhenPreparedST : TDateAndTime;
    Procedure SetWhenPreparedST(value : TDateAndTime);
    Procedure SetWhenHandedOver(value : TFhirDateTime);
    Function GetWhenHandedOverST : TDateAndTime;
    Procedure SetWhenHandedOverST(value : TDateAndTime);
    Procedure SetDestination(value : TFhirResourceReference{TFhirLocation});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationDispenseDispense; overload;
    function Clone : TFhirMedicationDispenseDispense; overload;
    {!script show}
  published
    {@member identifier
      Identifier assigned by the dispensing facility.   This is an identifier assigned outside FHIR.
    }
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;

    {@member status
      A code specifying the state of the dispense event.
    }
    property status : TFhirEnum read FStatus write SetStatus;
    {@member statusST
      Typed access to A code specifying the state of the dispense event.
    }
    property statusST : TFhirMedicationDispenseStatus read GetStatusST write SetStatusST;

    {@member type_
      Indicates the type of dispensing event that is performed. Examples include: Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc.
    }
    property type_ : TFhirCodeableConcept read FType_ write SetType_;

    {@member quantity
      The amount of medication that has been dispensed. Includes unit of measure.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;

    {@member medication
      Identifies the medication being administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications.
    }
    property medication : TFhirResourceReference{TFhirMedication} read FMedication write SetMedication;

    {@member whenPrepared
      The time when the dispensed product was packaged and reviewed.
    }
    property whenPrepared : TFhirDateTime read FWhenPrepared write SetWhenPrepared;
    {@member whenPreparedST
      Typed access to The time when the dispensed product was packaged and reviewed.
    }
    property whenPreparedST : TDateAndTime read GetWhenPreparedST write SetWhenPreparedST;

    {@member whenHandedOver
      The time the dispensed product was provided to the patient or their representative.
    }
    property whenHandedOver : TFhirDateTime read FWhenHandedOver write SetWhenHandedOver;
    {@member whenHandedOverST
      Typed access to The time the dispensed product was provided to the patient or their representative.
    }
    property whenHandedOverST : TDateAndTime read GetWhenHandedOverST write SetWhenHandedOverST;

    {@member destination
      Identification of the facility/location where the medication was shipped to, as part of the dispense event.
    }
    property destination : TFhirResourceReference{TFhirLocation} read FDestination write SetDestination;

    {@member receiverList
      Identifies the person who picked up the medication.  This will usually be a patient or their carer, but some cases exist where it can be a healthcare professional.
    }
    property receiverList : TFhirResourceReferenceList{Resource} read FReceiverList;

    {@member dosageList
      Indicates how the medication is to be used by the patient.
    }
    property dosageList : TFhirMedicationDispenseDispenseDosageList read FDosageList;

  end;


  {@Class TFhirMedicationDispenseDispenseList
    A list of FhirMedicationDispenseDispense
  }
  {!.Net HL7Connect.Fhir.MedicationDispenseDispenseList}
  TFhirMedicationDispenseDispenseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationDispenseDispense;
    procedure SetItemN(index : Integer; value : TFhirMedicationDispenseDispense);
  public
    {!script hide}
    function Link : TFhirMedicationDispenseDispenseList; Overload;
    function Clone : TFhirMedicationDispenseDispenseList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMedicationDispenseDispense to the end of the list.
    }
    function Append : TFhirMedicationDispenseDispense;

    
    {@member AddItem
      Add an already existing FhirMedicationDispenseDispense to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationDispenseDispense);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationDispenseDispense) : Integer;
    

    {@member Insert
      Insert FhirMedicationDispenseDispense before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationDispenseDispense;
    

    {@member InsertItem
       Insert an existing FhirMedicationDispenseDispense before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationDispenseDispense);
    
    {@member Item
       Get the iIndexth FhirMedicationDispenseDispense. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationDispenseDispense. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationDispenseDispense);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationDispenseDispense;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationDispenseDispenses[index : Integer] : TFhirMedicationDispenseDispense read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationDispenseDispenseDosage : TFhirElement
    Indicates how the medication is to be used by the patient.
  }
  {!.Net HL7Connect.Fhir.MedicationDispenseDispenseDosage}
  TFhirMedicationDispenseDispenseDosage = class (TFhirBackboneElement)
  private
    FAdditionalInstructions : TFhirCodeableConcept;
    FTiming : TFhirType;
    FAsNeeded : TFhirType;
    FSite : TFhirCodeableConcept;
    FRoute : TFhirCodeableConcept;
    FMethod : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FRate : TFhirRatio;
    FMaxDosePerPeriod : TFhirRatio;
    Procedure SetAdditionalInstructions(value : TFhirCodeableConcept);
    Procedure SetTiming(value : TFhirType);
    Procedure SetAsNeeded(value : TFhirType);
    Procedure SetSite(value : TFhirCodeableConcept);
    Procedure SetRoute(value : TFhirCodeableConcept);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetRate(value : TFhirRatio);
    Procedure SetMaxDosePerPeriod(value : TFhirRatio);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationDispenseDispenseDosage; overload;
    function Clone : TFhirMedicationDispenseDispenseDosage; overload;
    {!script show}
  published
    {@member additionalInstructions
      Additional instructions such as "Swallow with plenty of water" which may or may not be coded.
    }
    property additionalInstructions : TFhirCodeableConcept read FAdditionalInstructions write SetAdditionalInstructions;

    {@member timing
      The timing schedule for giving the medication to the patient.  The Schedule data type allows many different expressions, for example.  "Every  8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:";  "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    }
    property timing : TFhirType read FTiming write SetTiming;

    {@member asNeeded
      If set to true or if specified as a CodeableConcept, indicates that the medication is only taken when needed within the specified schedule rather than at every scheduled dose.  If a CodeableConcept is present, it indicates the pre-condition for taking the Medication.
    }
    property asNeeded : TFhirType read FAsNeeded write SetAsNeeded;

    {@member site
      A coded specification of the anatomic site where the medication first enters the body.
    }
    property site : TFhirCodeableConcept read FSite write SetSite;

    {@member route
      A code specifying the route or physiological path of administration of a therapeutic agent into or onto a subject.
    }
    property route : TFhirCodeableConcept read FRoute write SetRoute;

    {@member method
      A coded value indicating the method by which the medication is introduced into or onto the body. Most commonly used for injections.  Examples:  Slow Push; Deep IV.

Terminologies used often pre-coordinate this term with the route and or form of administration.
    }
    property method : TFhirCodeableConcept read FMethod write SetMethod;

    {@member quantity
      The amount of therapeutic or other substance given at one administration event.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;

    {@member rate
      Identifies the speed with which the substance is introduced into the subject. Typically the rate for an infusion. 200ml in 2 hours.
    }
    property rate : TFhirRatio read FRate write SetRate;

    {@member maxDosePerPeriod
      The maximum total quantity of a therapeutic substance that may be administered to a subject over the period of time,  e.g. 1000mg in 24 hours.
    }
    property maxDosePerPeriod : TFhirRatio read FMaxDosePerPeriod write SetMaxDosePerPeriod;

  end;


  {@Class TFhirMedicationDispenseDispenseDosageList
    A list of FhirMedicationDispenseDispenseDosage
  }
  {!.Net HL7Connect.Fhir.MedicationDispenseDispenseDosageList}
  TFhirMedicationDispenseDispenseDosageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationDispenseDispenseDosage;
    procedure SetItemN(index : Integer; value : TFhirMedicationDispenseDispenseDosage);
  public
    {!script hide}
    function Link : TFhirMedicationDispenseDispenseDosageList; Overload;
    function Clone : TFhirMedicationDispenseDispenseDosageList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMedicationDispenseDispenseDosage to the end of the list.
    }
    function Append : TFhirMedicationDispenseDispenseDosage;

    
    {@member AddItem
      Add an already existing FhirMedicationDispenseDispenseDosage to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationDispenseDispenseDosage);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationDispenseDispenseDosage) : Integer;
    

    {@member Insert
      Insert FhirMedicationDispenseDispenseDosage before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationDispenseDispenseDosage;
    

    {@member InsertItem
       Insert an existing FhirMedicationDispenseDispenseDosage before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationDispenseDispenseDosage);
    
    {@member Item
       Get the iIndexth FhirMedicationDispenseDispenseDosage. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationDispenseDispenseDosage. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationDispenseDispenseDosage);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationDispenseDispenseDosage;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationDispenseDispenseDosages[index : Integer] : TFhirMedicationDispenseDispenseDosage read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationDispenseSubstitution : TFhirElement
    Indicates whether or not substitution was made as part of the dispense.  In some cases substitution will be expected but doesn't happen, in other cases substitution is not expected but does happen.  This block explains what substitition did or did not happen and why.
  }
  {!.Net HL7Connect.Fhir.MedicationDispenseSubstitution}
  TFhirMedicationDispenseSubstitution = class (TFhirBackboneElement)
  private
    FType_ : TFhirCodeableConcept;
    FreasonList : TFhirCodeableConceptList;
    FresponsiblePartyList : TFhirResourceReferenceList{TFhirPractitioner};
    Procedure SetType_(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationDispenseSubstitution; overload;
    function Clone : TFhirMedicationDispenseSubstitution; overload;
    {!script show}
  published
    {@member type_
      A code signifying whether a different drug was dispensed from what was prescribed.
    }
    property type_ : TFhirCodeableConcept read FType_ write SetType_;

    {@member reasonList
      Indicates the reason for the substitution of (or lack of substitution) from what was prescribed.
    }
    property reasonList : TFhirCodeableConceptList read FReasonList;

    {@member responsiblePartyList
      The person or organization that has primary responsibility for the substitution.
    }
    property responsiblePartyList : TFhirResourceReferenceList{TFhirPractitioner} read FResponsiblePartyList;

  end;


  {@Class TFhirMedicationDispenseSubstitutionList
    A list of FhirMedicationDispenseSubstitution
  }
  {!.Net HL7Connect.Fhir.MedicationDispenseSubstitutionList}
  TFhirMedicationDispenseSubstitutionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationDispenseSubstitution;
    procedure SetItemN(index : Integer; value : TFhirMedicationDispenseSubstitution);
  public
    {!script hide}
    function Link : TFhirMedicationDispenseSubstitutionList; Overload;
    function Clone : TFhirMedicationDispenseSubstitutionList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMedicationDispenseSubstitution to the end of the list.
    }
    function Append : TFhirMedicationDispenseSubstitution;

    
    {@member AddItem
      Add an already existing FhirMedicationDispenseSubstitution to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationDispenseSubstitution);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationDispenseSubstitution) : Integer;
    

    {@member Insert
      Insert FhirMedicationDispenseSubstitution before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationDispenseSubstitution;
    

    {@member InsertItem
       Insert an existing FhirMedicationDispenseSubstitution before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationDispenseSubstitution);
    
    {@member Item
       Get the iIndexth FhirMedicationDispenseSubstitution. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationDispenseSubstitution. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationDispenseSubstitution);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationDispenseSubstitution;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationDispenseSubstitutions[index : Integer] : TFhirMedicationDispenseSubstitution read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationPrescriptionDosageInstruction : TFhirElement
    Indicates how the medication is to be used by the patient.
  }
  {!.Net HL7Connect.Fhir.MedicationPrescriptionDosageInstruction}
  TFhirMedicationPrescriptionDosageInstruction = class (TFhirBackboneElement)
  private
    FText : TFhirString;
    FAdditionalInstructions : TFhirCodeableConcept;
    FTiming : TFhirType;
    FAsNeeded : TFhirType;
    FSite : TFhirCodeableConcept;
    FRoute : TFhirCodeableConcept;
    FMethod : TFhirCodeableConcept;
    FDoseQuantity : TFhirQuantity;
    FRate : TFhirRatio;
    FMaxDosePerPeriod : TFhirRatio;
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    Procedure SetAdditionalInstructions(value : TFhirCodeableConcept);
    Procedure SetTiming(value : TFhirType);
    Procedure SetAsNeeded(value : TFhirType);
    Procedure SetSite(value : TFhirCodeableConcept);
    Procedure SetRoute(value : TFhirCodeableConcept);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetDoseQuantity(value : TFhirQuantity);
    Procedure SetRate(value : TFhirRatio);
    Procedure SetMaxDosePerPeriod(value : TFhirRatio);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationPrescriptionDosageInstruction; overload;
    function Clone : TFhirMedicationPrescriptionDosageInstruction; overload;
    {!script show}
  published
    {@member text
      Free text dosage instructions for cases where the instructions are too complex to code.
    }
    property text : TFhirString read FText write SetText;
    {@member textST
      Typed access to Free text dosage instructions for cases where the instructions are too complex to code.
    }
    property textST : String read GetTextST write SetTextST;

    {@member additionalInstructions
      Additional instructions such as "Swallow with plenty of water" which may or may not be coded.
    }
    property additionalInstructions : TFhirCodeableConcept read FAdditionalInstructions write SetAdditionalInstructions;

    {@member timing
      The timing schedule for giving the medication to the patient.  The Schedule data type allows many different expressions, for example.  "Every  8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:";  "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    }
    property timing : TFhirType read FTiming write SetTiming;

    {@member asNeeded
      If set to true or if specified as a CodeableConcept, indicates that the medication is only taken when needed within the specified schedule rather than at every scheduled dose.  If a CodeableConcept is present, it indicates the pre-condition for taking the Medication.
    }
    property asNeeded : TFhirType read FAsNeeded write SetAsNeeded;

    {@member site
      A coded specification of the anatomic site where the medication first enters the body.
    }
    property site : TFhirCodeableConcept read FSite write SetSite;

    {@member route
      A code specifying the route or physiological path of administration of a therapeutic agent into or onto a patient.
    }
    property route : TFhirCodeableConcept read FRoute write SetRoute;

    {@member method
      A coded value indicating the method by which the medication is introduced into or onto the body. Most commonly used for injections.  Examples:  Slow Push; Deep IV.

Terminologies used often pre-coordinate this term with the route and or form of administration.
    }
    property method : TFhirCodeableConcept read FMethod write SetMethod;

    {@member doseQuantity
      The amount of therapeutic or other substance given at one administration event.
    }
    property doseQuantity : TFhirQuantity read FDoseQuantity write SetDoseQuantity;

    {@member rate
      Identifies the speed with which the substance is introduced into the subject. Typically the rate for an infusion. 200ml in 2 hours.
    }
    property rate : TFhirRatio read FRate write SetRate;

    {@member maxDosePerPeriod
      The maximum total quantity of a therapeutic substance that may be administered to a subject over the period of time. E.g. 1000mg in 24 hours.
    }
    property maxDosePerPeriod : TFhirRatio read FMaxDosePerPeriod write SetMaxDosePerPeriod;

  end;


  {@Class TFhirMedicationPrescriptionDosageInstructionList
    A list of FhirMedicationPrescriptionDosageInstruction
  }
  {!.Net HL7Connect.Fhir.MedicationPrescriptionDosageInstructionList}
  TFhirMedicationPrescriptionDosageInstructionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationPrescriptionDosageInstruction;
    procedure SetItemN(index : Integer; value : TFhirMedicationPrescriptionDosageInstruction);
  public
    {!script hide}
    function Link : TFhirMedicationPrescriptionDosageInstructionList; Overload;
    function Clone : TFhirMedicationPrescriptionDosageInstructionList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMedicationPrescriptionDosageInstruction to the end of the list.
    }
    function Append : TFhirMedicationPrescriptionDosageInstruction;

    
    {@member AddItem
      Add an already existing FhirMedicationPrescriptionDosageInstruction to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationPrescriptionDosageInstruction);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationPrescriptionDosageInstruction) : Integer;
    

    {@member Insert
      Insert FhirMedicationPrescriptionDosageInstruction before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationPrescriptionDosageInstruction;
    

    {@member InsertItem
       Insert an existing FhirMedicationPrescriptionDosageInstruction before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationPrescriptionDosageInstruction);
    
    {@member Item
       Get the iIndexth FhirMedicationPrescriptionDosageInstruction. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationPrescriptionDosageInstruction. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationPrescriptionDosageInstruction);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationPrescriptionDosageInstruction;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationPrescriptionDosageInstructions[index : Integer] : TFhirMedicationPrescriptionDosageInstruction read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationPrescriptionDispense : TFhirElement
    Deals with details of the dispense part of the order.
  }
  {!.Net HL7Connect.Fhir.MedicationPrescriptionDispense}
  TFhirMedicationPrescriptionDispense = class (TFhirBackboneElement)
  private
    FMedication : TFhirResourceReference{TFhirMedication};
    FValidityPeriod : TFhirPeriod;
    FNumberOfRepeatsAllowed : TFhirInteger;
    FQuantity : TFhirQuantity;
    FExpectedSupplyDuration : TFhirQuantity;
    Procedure SetMedication(value : TFhirResourceReference{TFhirMedication});
    Procedure SetValidityPeriod(value : TFhirPeriod);
    Procedure SetNumberOfRepeatsAllowed(value : TFhirInteger);
    Function GetNumberOfRepeatsAllowedST : String;
    Procedure SetNumberOfRepeatsAllowedST(value : String);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetExpectedSupplyDuration(value : TFhirQuantity);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationPrescriptionDispense; overload;
    function Clone : TFhirMedicationPrescriptionDispense; overload;
    {!script show}
  published
    {@member medication
      Identifies the medication that is to be dispensed.  This may be a more specifically defined than the medicationPrescription.medication . This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications.
    }
    property medication : TFhirResourceReference{TFhirMedication} read FMedication write SetMedication;

    {@member validityPeriod
      Design Comments: This indicates the validity period of a prescription (stale dating the Prescription) 
It reflects the prescriber perspective for the validity of the prescription. Dispenses must not be made against the prescription outside of this period. The lower-bound of the Dispensing Window signifies the earliest date that the prescription can be filled for the first time. If an upper-bound is not specified then the Prescription is open-ended or will default to a stale-date based on regulations. 
Rationale: Indicates when the Prescription becomes valid, and when it ceases to be a dispensable Prescription.
    }
    property validityPeriod : TFhirPeriod read FValidityPeriod write SetValidityPeriod;

    {@member numberOfRepeatsAllowed
      An integer indicating the number of repeats of the Dispense. 
UsageNotes: For example, the number of times the prescribed quantity is to be supplied including the initial standard fill.
    }
    property numberOfRepeatsAllowed : TFhirInteger read FNumberOfRepeatsAllowed write SetNumberOfRepeatsAllowed;
    {@member numberOfRepeatsAllowedST
      Typed access to An integer indicating the number of repeats of the Dispense. 
UsageNotes: For example, the number of times the prescribed quantity is to be supplied including the initial standard fill.
    }
    property numberOfRepeatsAllowedST : String read GetNumberOfRepeatsAllowedST write SetNumberOfRepeatsAllowedST;

    {@member quantity
      The amount that is to be dispensed.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;

    {@member expectedSupplyDuration
      Identifies the period time over which the supplied product is expected to be used, or the length of time the dispense is expected to last. 
In some situations, this attribute may be used instead of quantity to identify the amount supplied by how long it is expected to last, rather than the physical quantity issued, e.g. 90 days supply of medication (based on an ordered dosage) When possible, it is always better to specify quantity, as this tends to be more precise. expectedSupplyDuration will always be an estimate that can be influenced by external factors.
    }
    property expectedSupplyDuration : TFhirQuantity read FExpectedSupplyDuration write SetExpectedSupplyDuration;

  end;


  {@Class TFhirMedicationPrescriptionDispenseList
    A list of FhirMedicationPrescriptionDispense
  }
  {!.Net HL7Connect.Fhir.MedicationPrescriptionDispenseList}
  TFhirMedicationPrescriptionDispenseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationPrescriptionDispense;
    procedure SetItemN(index : Integer; value : TFhirMedicationPrescriptionDispense);
  public
    {!script hide}
    function Link : TFhirMedicationPrescriptionDispenseList; Overload;
    function Clone : TFhirMedicationPrescriptionDispenseList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMedicationPrescriptionDispense to the end of the list.
    }
    function Append : TFhirMedicationPrescriptionDispense;

    
    {@member AddItem
      Add an already existing FhirMedicationPrescriptionDispense to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationPrescriptionDispense);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationPrescriptionDispense) : Integer;
    

    {@member Insert
      Insert FhirMedicationPrescriptionDispense before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationPrescriptionDispense;
    

    {@member InsertItem
       Insert an existing FhirMedicationPrescriptionDispense before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationPrescriptionDispense);
    
    {@member Item
       Get the iIndexth FhirMedicationPrescriptionDispense. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationPrescriptionDispense. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationPrescriptionDispense);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationPrescriptionDispense;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationPrescriptionDispenses[index : Integer] : TFhirMedicationPrescriptionDispense read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationPrescriptionSubstitution : TFhirElement
    Indicates whether or not substitution can or should be part of the dispense. In some cases substitution must happen, in other cases substitution must not happen, and in others it does not matter. This block explains the prescriber's intent. If nothing is specified substitution may be done.
  }
  {!.Net HL7Connect.Fhir.MedicationPrescriptionSubstitution}
  TFhirMedicationPrescriptionSubstitution = class (TFhirBackboneElement)
  private
    FType_ : TFhirCodeableConcept;
    FReason : TFhirCodeableConcept;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetReason(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationPrescriptionSubstitution; overload;
    function Clone : TFhirMedicationPrescriptionSubstitution; overload;
    {!script show}
  published
    {@member type_
      A code signifying whether a different drug should be dispensed from what was prescribed.
    }
    property type_ : TFhirCodeableConcept read FType_ write SetType_;

    {@member reason
      Indicates the reason for the substitution, or why substitution must or must not be performed.
    }
    property reason : TFhirCodeableConcept read FReason write SetReason;

  end;


  {@Class TFhirMedicationPrescriptionSubstitutionList
    A list of FhirMedicationPrescriptionSubstitution
  }
  {!.Net HL7Connect.Fhir.MedicationPrescriptionSubstitutionList}
  TFhirMedicationPrescriptionSubstitutionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationPrescriptionSubstitution;
    procedure SetItemN(index : Integer; value : TFhirMedicationPrescriptionSubstitution);
  public
    {!script hide}
    function Link : TFhirMedicationPrescriptionSubstitutionList; Overload;
    function Clone : TFhirMedicationPrescriptionSubstitutionList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMedicationPrescriptionSubstitution to the end of the list.
    }
    function Append : TFhirMedicationPrescriptionSubstitution;

    
    {@member AddItem
      Add an already existing FhirMedicationPrescriptionSubstitution to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationPrescriptionSubstitution);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationPrescriptionSubstitution) : Integer;
    

    {@member Insert
      Insert FhirMedicationPrescriptionSubstitution before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationPrescriptionSubstitution;
    

    {@member InsertItem
       Insert an existing FhirMedicationPrescriptionSubstitution before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationPrescriptionSubstitution);
    
    {@member Item
       Get the iIndexth FhirMedicationPrescriptionSubstitution. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationPrescriptionSubstitution. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationPrescriptionSubstitution);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationPrescriptionSubstitution;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationPrescriptionSubstitutions[index : Integer] : TFhirMedicationPrescriptionSubstitution read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationStatementDosage : TFhirElement
    Indicates how the medication is/was used by the patient.
  }
  {!.Net HL7Connect.Fhir.MedicationStatementDosage}
  TFhirMedicationStatementDosage = class (TFhirBackboneElement)
  private
    FTiming : TFhirSchedule;
    FAsNeeded : TFhirType;
    FSite : TFhirCodeableConcept;
    FRoute : TFhirCodeableConcept;
    FMethod : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FRate : TFhirRatio;
    FMaxDosePerPeriod : TFhirRatio;
    Procedure SetTiming(value : TFhirSchedule);
    Procedure SetAsNeeded(value : TFhirType);
    Procedure SetSite(value : TFhirCodeableConcept);
    Procedure SetRoute(value : TFhirCodeableConcept);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetRate(value : TFhirRatio);
    Procedure SetMaxDosePerPeriod(value : TFhirRatio);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationStatementDosage; overload;
    function Clone : TFhirMedicationStatementDosage; overload;
    {!script show}
  published
    {@member timing
      The timing schedule for giving the medication to the patient.  The Schedule data type allows many different expressions, for example.  "Every  8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:";  "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    }
    property timing : TFhirSchedule read FTiming write SetTiming;

    {@member asNeeded
      If set to true or if specified as a CodeableConcept, indicates that the medication is only taken when needed within the specified schedule rather than at every scheduled dose.  If a CodeableConcept is present, it indicates the pre-condition for taking the Medication.
    }
    property asNeeded : TFhirType read FAsNeeded write SetAsNeeded;

    {@member site
      A coded specification of the anatomic site where the medication first enters the body.
    }
    property site : TFhirCodeableConcept read FSite write SetSite;

    {@member route
      A code specifying the route or physiological path of administration of a therapeutic agent into or onto a subject.
    }
    property route : TFhirCodeableConcept read FRoute write SetRoute;

    {@member method
      A coded value indicating the method by which the medication is introduced into or onto the body. Most commonly used for injections.  Examples:  Slow Push; Deep IV.

Terminologies used often pre-coordinate this term with the route and or form of administration.
    }
    property method : TFhirCodeableConcept read FMethod write SetMethod;

    {@member quantity
      The amount of therapeutic or other substance given at one administration event.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;

    {@member rate
      Identifies the speed with which the substance is introduced into the subject. Typically the rate for an infusion. 200ml in 2 hours.
    }
    property rate : TFhirRatio read FRate write SetRate;

    {@member maxDosePerPeriod
      The maximum total quantity of a therapeutic substance that may be administered to a subject over the period of time. E.g. 1000mg in 24 hours.
    }
    property maxDosePerPeriod : TFhirRatio read FMaxDosePerPeriod write SetMaxDosePerPeriod;

  end;


  {@Class TFhirMedicationStatementDosageList
    A list of FhirMedicationStatementDosage
  }
  {!.Net HL7Connect.Fhir.MedicationStatementDosageList}
  TFhirMedicationStatementDosageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationStatementDosage;
    procedure SetItemN(index : Integer; value : TFhirMedicationStatementDosage);
  public
    {!script hide}
    function Link : TFhirMedicationStatementDosageList; Overload;
    function Clone : TFhirMedicationStatementDosageList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMedicationStatementDosage to the end of the list.
    }
    function Append : TFhirMedicationStatementDosage;

    
    {@member AddItem
      Add an already existing FhirMedicationStatementDosage to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationStatementDosage);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationStatementDosage) : Integer;
    

    {@member Insert
      Insert FhirMedicationStatementDosage before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationStatementDosage;
    

    {@member InsertItem
       Insert an existing FhirMedicationStatementDosage before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationStatementDosage);
    
    {@member Item
       Get the iIndexth FhirMedicationStatementDosage. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationStatementDosage. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationStatementDosage);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationStatementDosage;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationStatementDosages[index : Integer] : TFhirMedicationStatementDosage read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMessageHeaderResponse : TFhirElement
    Information about the message that this message is a response to.  Only present if this message is a response.
  }
  {!.Net HL7Connect.Fhir.MessageHeaderResponse}
  TFhirMessageHeaderResponse = class (TFhirBackboneElement)
  private
    FIdentifier : TFhirId;
    FCode : TFhirEnum;
    FDetails : TFhirResourceReference{TFhirOperationOutcome};
    Procedure SetIdentifier(value : TFhirId);
    Function GetIdentifierST : String;
    Procedure SetIdentifierST(value : String);
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirResponseCode;
    Procedure SetCodeST(value : TFhirResponseCode);
    Procedure SetDetails(value : TFhirResourceReference{TFhirOperationOutcome});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMessageHeaderResponse; overload;
    function Clone : TFhirMessageHeaderResponse; overload;
    {!script show}
  published
    {@member identifier
      The id of the message that this message is a response to.
    }
    property identifier : TFhirId read FIdentifier write SetIdentifier;
    {@member identifierST
      Typed access to The id of the message that this message is a response to.
    }
    property identifierST : String read GetIdentifierST write SetIdentifierST;

    {@member code
      Code that identifies the type of response to the message - whether it was successful or not, and whether it should be resent or not.
    }
    property code : TFhirEnum read FCode write SetCode;
    {@member codeST
      Typed access to Code that identifies the type of response to the message - whether it was successful or not, and whether it should be resent or not.
    }
    property codeST : TFhirResponseCode read GetCodeST write SetCodeST;

    {@member details
      Full details of any issues found in the message.
    }
    property details : TFhirResourceReference{TFhirOperationOutcome} read FDetails write SetDetails;

  end;


  {@Class TFhirMessageHeaderResponseList
    A list of FhirMessageHeaderResponse
  }
  {!.Net HL7Connect.Fhir.MessageHeaderResponseList}
  TFhirMessageHeaderResponseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMessageHeaderResponse;
    procedure SetItemN(index : Integer; value : TFhirMessageHeaderResponse);
  public
    {!script hide}
    function Link : TFhirMessageHeaderResponseList; Overload;
    function Clone : TFhirMessageHeaderResponseList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMessageHeaderResponse to the end of the list.
    }
    function Append : TFhirMessageHeaderResponse;

    
    {@member AddItem
      Add an already existing FhirMessageHeaderResponse to the end of the list.
    }
    procedure AddItem(value : TFhirMessageHeaderResponse);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMessageHeaderResponse) : Integer;
    

    {@member Insert
      Insert FhirMessageHeaderResponse before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMessageHeaderResponse;
    

    {@member InsertItem
       Insert an existing FhirMessageHeaderResponse before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMessageHeaderResponse);
    
    {@member Item
       Get the iIndexth FhirMessageHeaderResponse. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMessageHeaderResponse. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeaderResponse);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMessageHeaderResponse;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMessageHeaderResponses[index : Integer] : TFhirMessageHeaderResponse read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMessageHeaderSource : TFhirElement
    The source application from which this message originated.
  }
  {!.Net HL7Connect.Fhir.MessageHeaderSource}
  TFhirMessageHeaderSource = class (TFhirBackboneElement)
  private
    FName : TFhirString;
    FSoftware : TFhirString;
    FVersion : TFhirString;
    FContact : TFhirContact;
    FEndpoint : TFhirUri;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetSoftware(value : TFhirString);
    Function GetSoftwareST : String;
    Procedure SetSoftwareST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetContact(value : TFhirContact);
    Procedure SetEndpoint(value : TFhirUri);
    Function GetEndpointST : String;
    Procedure SetEndpointST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMessageHeaderSource; overload;
    function Clone : TFhirMessageHeaderSource; overload;
    {!script show}
  published
    {@member name
      Human-readable name for the target system.
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to Human-readable name for the target system.
    }
    property nameST : String read GetNameST write SetNameST;

    {@member software
      May include configuration or other information useful in debugging.
    }
    property software : TFhirString read FSoftware write SetSoftware;
    {@member softwareST
      Typed access to May include configuration or other information useful in debugging.
    }
    property softwareST : String read GetSoftwareST write SetSoftwareST;

    {@member version
      Can convey versions of multiple systems in situations where a message passes through multiple hands.
    }
    property version : TFhirString read FVersion write SetVersion;
    {@member versionST
      Typed access to Can convey versions of multiple systems in situations where a message passes through multiple hands.
    }
    property versionST : String read GetVersionST write SetVersionST;

    {@member contact
      An e-mail, phone, website or other contact point to use to resolve issues with message communications.
    }
    property contact : TFhirContact read FContact write SetContact;

    {@member endpoint
      Identifies the routing target to send acknowledgements to.
    }
    property endpoint : TFhirUri read FEndpoint write SetEndpoint;
    {@member endpointST
      Typed access to Identifies the routing target to send acknowledgements to.
    }
    property endpointST : String read GetEndpointST write SetEndpointST;

  end;


  {@Class TFhirMessageHeaderSourceList
    A list of FhirMessageHeaderSource
  }
  {!.Net HL7Connect.Fhir.MessageHeaderSourceList}
  TFhirMessageHeaderSourceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMessageHeaderSource;
    procedure SetItemN(index : Integer; value : TFhirMessageHeaderSource);
  public
    {!script hide}
    function Link : TFhirMessageHeaderSourceList; Overload;
    function Clone : TFhirMessageHeaderSourceList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMessageHeaderSource to the end of the list.
    }
    function Append : TFhirMessageHeaderSource;

    
    {@member AddItem
      Add an already existing FhirMessageHeaderSource to the end of the list.
    }
    procedure AddItem(value : TFhirMessageHeaderSource);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMessageHeaderSource) : Integer;
    

    {@member Insert
      Insert FhirMessageHeaderSource before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMessageHeaderSource;
    

    {@member InsertItem
       Insert an existing FhirMessageHeaderSource before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMessageHeaderSource);
    
    {@member Item
       Get the iIndexth FhirMessageHeaderSource. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMessageHeaderSource. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeaderSource);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMessageHeaderSource;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMessageHeaderSources[index : Integer] : TFhirMessageHeaderSource read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMessageHeaderDestination : TFhirElement
    The destination application which the message is intended for.
  }
  {!.Net HL7Connect.Fhir.MessageHeaderDestination}
  TFhirMessageHeaderDestination = class (TFhirBackboneElement)
  private
    FName : TFhirString;
    FTarget : TFhirResourceReference{TFhirDevice};
    FEndpoint : TFhirUri;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetTarget(value : TFhirResourceReference{TFhirDevice});
    Procedure SetEndpoint(value : TFhirUri);
    Function GetEndpointST : String;
    Procedure SetEndpointST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMessageHeaderDestination; overload;
    function Clone : TFhirMessageHeaderDestination; overload;
    {!script show}
  published
    {@member name
      Human-readable name for the source system.
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to Human-readable name for the source system.
    }
    property nameST : String read GetNameST write SetNameST;

    {@member target
      Identifies the target end system in situations where the initial message transmission is to an intermediary system.
    }
    property target : TFhirResourceReference{TFhirDevice} read FTarget write SetTarget;

    {@member endpoint
      Indicates where the message should be routed to.
    }
    property endpoint : TFhirUri read FEndpoint write SetEndpoint;
    {@member endpointST
      Typed access to Indicates where the message should be routed to.
    }
    property endpointST : String read GetEndpointST write SetEndpointST;

  end;


  {@Class TFhirMessageHeaderDestinationList
    A list of FhirMessageHeaderDestination
  }
  {!.Net HL7Connect.Fhir.MessageHeaderDestinationList}
  TFhirMessageHeaderDestinationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMessageHeaderDestination;
    procedure SetItemN(index : Integer; value : TFhirMessageHeaderDestination);
  public
    {!script hide}
    function Link : TFhirMessageHeaderDestinationList; Overload;
    function Clone : TFhirMessageHeaderDestinationList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirMessageHeaderDestination to the end of the list.
    }
    function Append : TFhirMessageHeaderDestination;

    
    {@member AddItem
      Add an already existing FhirMessageHeaderDestination to the end of the list.
    }
    procedure AddItem(value : TFhirMessageHeaderDestination);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMessageHeaderDestination) : Integer;
    

    {@member Insert
      Insert FhirMessageHeaderDestination before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMessageHeaderDestination;
    

    {@member InsertItem
       Insert an existing FhirMessageHeaderDestination before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMessageHeaderDestination);
    
    {@member Item
       Get the iIndexth FhirMessageHeaderDestination. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMessageHeaderDestination. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeaderDestination);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMessageHeaderDestination;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMessageHeaderDestinations[index : Integer] : TFhirMessageHeaderDestination read GetItemN write SetItemN; default;
  End;


  {@Class TFhirObservationReferenceRange : TFhirElement
    Guidance on how to interpret the value by comparison to a normal or recommended range.
  }
  {!.Net HL7Connect.Fhir.ObservationReferenceRange}
  TFhirObservationReferenceRange = class (TFhirBackboneElement)
  private
    FLow : TFhirQuantity;
    FHigh : TFhirQuantity;
    FMeaning : TFhirCodeableConcept;
    FAge : TFhirRange;
    Procedure SetLow(value : TFhirQuantity);
    Procedure SetHigh(value : TFhirQuantity);
    Procedure SetMeaning(value : TFhirCodeableConcept);
    Procedure SetAge(value : TFhirRange);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirObservationReferenceRange; overload;
    function Clone : TFhirObservationReferenceRange; overload;
    {!script show}
  published
    {@member low
      The value of the low bound of the reference range. If this is omitted, the low bound of the reference range is assumed to be meaningless. E.g. <2.3.
    }
    property low : TFhirQuantity read FLow write SetLow;

    {@member high
      The value of the high bound of the reference range. If this is omitted, the high bound of the reference range is assumed to be meaningless. E.g. >5.
    }
    property high : TFhirQuantity read FHigh write SetHigh;

    {@member meaning
      Code for the meaning of the reference range.
    }
    property meaning : TFhirCodeableConcept read FMeaning write SetMeaning;

    {@member age
      The age at which this reference range is applicable. This is a neonatal age (e.g. number of weeks at term) if the meaning says so.
    }
    property age : TFhirRange read FAge write SetAge;

  end;


  {@Class TFhirObservationReferenceRangeList
    A list of FhirObservationReferenceRange
  }
  {!.Net HL7Connect.Fhir.ObservationReferenceRangeList}
  TFhirObservationReferenceRangeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirObservationReferenceRange;
    procedure SetItemN(index : Integer; value : TFhirObservationReferenceRange);
  public
    {!script hide}
    function Link : TFhirObservationReferenceRangeList; Overload;
    function Clone : TFhirObservationReferenceRangeList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirObservationReferenceRange to the end of the list.
    }
    function Append : TFhirObservationReferenceRange;

    
    {@member AddItem
      Add an already existing FhirObservationReferenceRange to the end of the list.
    }
    procedure AddItem(value : TFhirObservationReferenceRange);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirObservationReferenceRange) : Integer;
    

    {@member Insert
      Insert FhirObservationReferenceRange before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirObservationReferenceRange;
    

    {@member InsertItem
       Insert an existing FhirObservationReferenceRange before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirObservationReferenceRange);
    
    {@member Item
       Get the iIndexth FhirObservationReferenceRange. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirObservationReferenceRange. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirObservationReferenceRange);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirObservationReferenceRange;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirObservationReferenceRanges[index : Integer] : TFhirObservationReferenceRange read GetItemN write SetItemN; default;
  End;


  {@Class TFhirObservationRelated : TFhirElement
    Related observations - either components, or previous observations, or statements of derivation.
  }
  {!.Net HL7Connect.Fhir.ObservationRelated}
  TFhirObservationRelated = class (TFhirBackboneElement)
  private
    FType_ : TFhirEnum;
    FTarget : TFhirResourceReference{TFhirObservation};
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirObservationRelationshiptypes;
    Procedure SetType_ST(value : TFhirObservationRelationshiptypes);
    Procedure SetTarget(value : TFhirResourceReference{TFhirObservation});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirObservationRelated; overload;
    function Clone : TFhirObservationRelated; overload;
    {!script show}
  published
    {@member type_
      A code specifying the kind of relationship that exists with the target observation.
    }
    property type_ : TFhirEnum read FType_ write SetType_;
    {@member type_ST
      Typed access to A code specifying the kind of relationship that exists with the target observation.
    }
    property type_ST : TFhirObservationRelationshiptypes read GetType_ST write SetType_ST;

    {@member target
      A reference to the observation that is related to this observation.
    }
    property target : TFhirResourceReference{TFhirObservation} read FTarget write SetTarget;

  end;


  {@Class TFhirObservationRelatedList
    A list of FhirObservationRelated
  }
  {!.Net HL7Connect.Fhir.ObservationRelatedList}
  TFhirObservationRelatedList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirObservationRelated;
    procedure SetItemN(index : Integer; value : TFhirObservationRelated);
  public
    {!script hide}
    function Link : TFhirObservationRelatedList; Overload;
    function Clone : TFhirObservationRelatedList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirObservationRelated to the end of the list.
    }
    function Append : TFhirObservationRelated;

    
    {@member AddItem
      Add an already existing FhirObservationRelated to the end of the list.
    }
    procedure AddItem(value : TFhirObservationRelated);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirObservationRelated) : Integer;
    

    {@member Insert
      Insert FhirObservationRelated before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirObservationRelated;
    

    {@member InsertItem
       Insert an existing FhirObservationRelated before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirObservationRelated);
    
    {@member Item
       Get the iIndexth FhirObservationRelated. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirObservationRelated. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirObservationRelated);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirObservationRelated;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirObservationRelateds[index : Integer] : TFhirObservationRelated read GetItemN write SetItemN; default;
  End;


  {@Class TFhirOperationOutcomeIssue : TFhirElement
    An error, warning or information message that results from a system action.
  }
  {!.Net HL7Connect.Fhir.OperationOutcomeIssue}
  TFhirOperationOutcomeIssue = class (TFhirBackboneElement)
  private
    FSeverity : TFhirEnum;
    FType_ : TFhirCoding;
    FDetails : TFhirString;
    FlocationList : TFhirStringList;
    Procedure SetSeverity(value : TFhirEnum);
    Function GetSeverityST : TFhirIssueSeverity;
    Procedure SetSeverityST(value : TFhirIssueSeverity);
    Procedure SetType_(value : TFhirCoding);
    Procedure SetDetails(value : TFhirString);
    Function GetDetailsST : String;
    Procedure SetDetailsST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirOperationOutcomeIssue; overload;
    function Clone : TFhirOperationOutcomeIssue; overload;
    {!script show}
  published
    {@member severity
      Indicates whether the issue indicates a variation from successful processing.
    }
    property severity : TFhirEnum read FSeverity write SetSeverity;
    {@member severityST
      Typed access to Indicates whether the issue indicates a variation from successful processing.
    }
    property severityST : TFhirIssueSeverity read GetSeverityST write SetSeverityST;

    {@member type_
      A code indicating the type of error, warning or information message.
    }
    property type_ : TFhirCoding read FType_ write SetType_;

    {@member details
      Additional description of the issue.
    }
    property details : TFhirString read FDetails write SetDetails;
    {@member detailsST
      Typed access to Additional description of the issue.
    }
    property detailsST : String read GetDetailsST write SetDetailsST;

    {@member locationList
      A simple XPath limited to element names, repetition indicators and the default child access that identifies one of the elements in the resource that caused this issue to be raised.
    }
    property locationList : TFhirStringList read FLocationList;

  end;


  {@Class TFhirOperationOutcomeIssueList
    A list of FhirOperationOutcomeIssue
  }
  {!.Net HL7Connect.Fhir.OperationOutcomeIssueList}
  TFhirOperationOutcomeIssueList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOperationOutcomeIssue;
    procedure SetItemN(index : Integer; value : TFhirOperationOutcomeIssue);
  public
    {!script hide}
    function Link : TFhirOperationOutcomeIssueList; Overload;
    function Clone : TFhirOperationOutcomeIssueList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirOperationOutcomeIssue to the end of the list.
    }
    function Append : TFhirOperationOutcomeIssue;

    
    {@member AddItem
      Add an already existing FhirOperationOutcomeIssue to the end of the list.
    }
    procedure AddItem(value : TFhirOperationOutcomeIssue);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirOperationOutcomeIssue) : Integer;
    

    {@member Insert
      Insert FhirOperationOutcomeIssue before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirOperationOutcomeIssue;
    

    {@member InsertItem
       Insert an existing FhirOperationOutcomeIssue before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirOperationOutcomeIssue);
    
    {@member Item
       Get the iIndexth FhirOperationOutcomeIssue. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirOperationOutcomeIssue. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirOperationOutcomeIssue);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirOperationOutcomeIssue;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirOperationOutcomeIssues[index : Integer] : TFhirOperationOutcomeIssue read GetItemN write SetItemN; default;
  End;


  {@Class TFhirOrderWhen : TFhirElement
    When order should be fulfilled.
  }
  {!.Net HL7Connect.Fhir.OrderWhen}
  TFhirOrderWhen = class (TFhirBackboneElement)
  private
    FCode : TFhirCodeableConcept;
    FSchedule : TFhirSchedule;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSchedule(value : TFhirSchedule);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirOrderWhen; overload;
    function Clone : TFhirOrderWhen; overload;
    {!script show}
  published
    {@member code
      Code specifies when request should be done. The code may simply be a priority code.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member schedule
      A formal schedule.
    }
    property schedule : TFhirSchedule read FSchedule write SetSchedule;

  end;


  {@Class TFhirOrderWhenList
    A list of FhirOrderWhen
  }
  {!.Net HL7Connect.Fhir.OrderWhenList}
  TFhirOrderWhenList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOrderWhen;
    procedure SetItemN(index : Integer; value : TFhirOrderWhen);
  public
    {!script hide}
    function Link : TFhirOrderWhenList; Overload;
    function Clone : TFhirOrderWhenList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirOrderWhen to the end of the list.
    }
    function Append : TFhirOrderWhen;

    
    {@member AddItem
      Add an already existing FhirOrderWhen to the end of the list.
    }
    procedure AddItem(value : TFhirOrderWhen);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirOrderWhen) : Integer;
    

    {@member Insert
      Insert FhirOrderWhen before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirOrderWhen;
    

    {@member InsertItem
       Insert an existing FhirOrderWhen before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirOrderWhen);
    
    {@member Item
       Get the iIndexth FhirOrderWhen. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirOrderWhen. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirOrderWhen);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirOrderWhen;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirOrderWhens[index : Integer] : TFhirOrderWhen read GetItemN write SetItemN; default;
  End;


  {@Class TFhirOrganizationContact : TFhirElement
    Contact for the organization for a certain purpose.
  }
  {!.Net HL7Connect.Fhir.OrganizationContact}
  TFhirOrganizationContact = class (TFhirBackboneElement)
  private
    FPurpose : TFhirCodeableConcept;
    FName : TFhirHumanName;
    FtelecomList : TFhirContactList;
    FAddress : TFhirAddress;
    FGender : TFhirCodeableConcept;
    Procedure SetPurpose(value : TFhirCodeableConcept);
    Procedure SetName(value : TFhirHumanName);
    Procedure SetAddress(value : TFhirAddress);
    Procedure SetGender(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirOrganizationContact; overload;
    function Clone : TFhirOrganizationContact; overload;
    {!script show}
  published
    {@member purpose
      Indicates a purpose for which the contact can be reached.
    }
    property purpose : TFhirCodeableConcept read FPurpose write SetPurpose;

    {@member name
      A name associated with the contact.
    }
    property name : TFhirHumanName read FName write SetName;

    {@member telecomList
      A contact detail (e.g. a telephone number or an email address) by which the party may be contacted.
    }
    property telecomList : TFhirContactList read FTelecomList;

    {@member address
      Visiting or postal addresses for the contact.
    }
    property address : TFhirAddress read FAddress write SetAddress;

    {@member gender
      Administrative Gender - the gender that the person is considered to have for administration and record keeping purposes.
    }
    property gender : TFhirCodeableConcept read FGender write SetGender;

  end;


  {@Class TFhirOrganizationContactList
    A list of FhirOrganizationContact
  }
  {!.Net HL7Connect.Fhir.OrganizationContactList}
  TFhirOrganizationContactList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOrganizationContact;
    procedure SetItemN(index : Integer; value : TFhirOrganizationContact);
  public
    {!script hide}
    function Link : TFhirOrganizationContactList; Overload;
    function Clone : TFhirOrganizationContactList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirOrganizationContact to the end of the list.
    }
    function Append : TFhirOrganizationContact;

    
    {@member AddItem
      Add an already existing FhirOrganizationContact to the end of the list.
    }
    procedure AddItem(value : TFhirOrganizationContact);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirOrganizationContact) : Integer;
    

    {@member Insert
      Insert FhirOrganizationContact before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirOrganizationContact;
    

    {@member InsertItem
       Insert an existing FhirOrganizationContact before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirOrganizationContact);
    
    {@member Item
       Get the iIndexth FhirOrganizationContact. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirOrganizationContact. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirOrganizationContact);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirOrganizationContact;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirOrganizationContacts[index : Integer] : TFhirOrganizationContact read GetItemN write SetItemN; default;
  End;


  {@Class TFhirPatientContact : TFhirElement
    A contact party (e.g. guardian, partner, friend) for the patient.
  }
  {!.Net HL7Connect.Fhir.PatientContact}
  TFhirPatientContact = class (TFhirBackboneElement)
  private
    FrelationshipList : TFhirCodeableConceptList;
    FName : TFhirHumanName;
    FtelecomList : TFhirContactList;
    FAddress : TFhirAddress;
    FGender : TFhirCodeableConcept;
    FOrganization : TFhirResourceReference{TFhirOrganization};
    Procedure SetName(value : TFhirHumanName);
    Procedure SetAddress(value : TFhirAddress);
    Procedure SetGender(value : TFhirCodeableConcept);
    Procedure SetOrganization(value : TFhirResourceReference{TFhirOrganization});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirPatientContact; overload;
    function Clone : TFhirPatientContact; overload;
    {!script show}
  published
    {@member relationshipList
      The nature of the relationship between the patient and the contact person.
    }
    property relationshipList : TFhirCodeableConceptList read FRelationshipList;

    {@member name
      A name associated with the person.
    }
    property name : TFhirHumanName read FName write SetName;

    {@member telecomList
      A contact detail for the person, e.g. a telephone number or an email address.
    }
    property telecomList : TFhirContactList read FTelecomList;

    {@member address
      Address for the contact person.
    }
    property address : TFhirAddress read FAddress write SetAddress;

    {@member gender
      Administrative Gender - the gender that the person is considered to have for administration and record keeping purposes.
    }
    property gender : TFhirCodeableConcept read FGender write SetGender;

    {@member organization
      Organization on behalf of which the contact is acting or for which the contact is working.
    }
    property organization : TFhirResourceReference{TFhirOrganization} read FOrganization write SetOrganization;

  end;


  {@Class TFhirPatientContactList
    A list of FhirPatientContact
  }
  {!.Net HL7Connect.Fhir.PatientContactList}
  TFhirPatientContactList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPatientContact;
    procedure SetItemN(index : Integer; value : TFhirPatientContact);
  public
    {!script hide}
    function Link : TFhirPatientContactList; Overload;
    function Clone : TFhirPatientContactList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirPatientContact to the end of the list.
    }
    function Append : TFhirPatientContact;

    
    {@member AddItem
      Add an already existing FhirPatientContact to the end of the list.
    }
    procedure AddItem(value : TFhirPatientContact);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirPatientContact) : Integer;
    

    {@member Insert
      Insert FhirPatientContact before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirPatientContact;
    

    {@member InsertItem
       Insert an existing FhirPatientContact before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirPatientContact);
    
    {@member Item
       Get the iIndexth FhirPatientContact. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirPatientContact. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirPatientContact);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirPatientContact;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirPatientContacts[index : Integer] : TFhirPatientContact read GetItemN write SetItemN; default;
  End;


  {@Class TFhirPatientAnimal : TFhirElement
    This element has a value if the patient is an animal.
  }
  {!.Net HL7Connect.Fhir.PatientAnimal}
  TFhirPatientAnimal = class (TFhirBackboneElement)
  private
    FSpecies : TFhirCodeableConcept;
    FBreed : TFhirCodeableConcept;
    FGenderStatus : TFhirCodeableConcept;
    Procedure SetSpecies(value : TFhirCodeableConcept);
    Procedure SetBreed(value : TFhirCodeableConcept);
    Procedure SetGenderStatus(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirPatientAnimal; overload;
    function Clone : TFhirPatientAnimal; overload;
    {!script show}
  published
    {@member species
      Identifies the high level categorization of the kind of animal.
    }
    property species : TFhirCodeableConcept read FSpecies write SetSpecies;

    {@member breed
      Identifies the detailed categorization of the kind of animal.
    }
    property breed : TFhirCodeableConcept read FBreed write SetBreed;

    {@member genderStatus
      Indicates the current state of the animal's reproductive organs.
    }
    property genderStatus : TFhirCodeableConcept read FGenderStatus write SetGenderStatus;

  end;


  {@Class TFhirPatientAnimalList
    A list of FhirPatientAnimal
  }
  {!.Net HL7Connect.Fhir.PatientAnimalList}
  TFhirPatientAnimalList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPatientAnimal;
    procedure SetItemN(index : Integer; value : TFhirPatientAnimal);
  public
    {!script hide}
    function Link : TFhirPatientAnimalList; Overload;
    function Clone : TFhirPatientAnimalList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirPatientAnimal to the end of the list.
    }
    function Append : TFhirPatientAnimal;

    
    {@member AddItem
      Add an already existing FhirPatientAnimal to the end of the list.
    }
    procedure AddItem(value : TFhirPatientAnimal);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirPatientAnimal) : Integer;
    

    {@member Insert
      Insert FhirPatientAnimal before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirPatientAnimal;
    

    {@member InsertItem
       Insert an existing FhirPatientAnimal before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirPatientAnimal);
    
    {@member Item
       Get the iIndexth FhirPatientAnimal. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirPatientAnimal. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirPatientAnimal);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirPatientAnimal;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirPatientAnimals[index : Integer] : TFhirPatientAnimal read GetItemN write SetItemN; default;
  End;


  {@Class TFhirPatientLink : TFhirElement
    Link to another patient resource that concerns the same actual person.
  }
  {!.Net HL7Connect.Fhir.PatientLink}
  TFhirPatientLink = class (TFhirBackboneElement)
  private
    FOther : TFhirResourceReference{TFhirPatient};
    FType_ : TFhirEnum;
    Procedure SetOther(value : TFhirResourceReference{TFhirPatient});
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirLinkType;
    Procedure SetType_ST(value : TFhirLinkType);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirPatientLink; overload;
    function Clone : TFhirPatientLink; overload;
    {!script show}
  published
    {@member other
      The other patient resource that the link refers to.
    }
    property other : TFhirResourceReference{TFhirPatient} read FOther write SetOther;

    {@member type_
      The type of link between this patient resource and another patient resource.
    }
    property type_ : TFhirEnum read FType_ write SetType_;
    {@member type_ST
      Typed access to The type of link between this patient resource and another patient resource.
    }
    property type_ST : TFhirLinkType read GetType_ST write SetType_ST;

  end;


  {@Class TFhirPatientLinkList
    A list of FhirPatientLink
  }
  {!.Net HL7Connect.Fhir.PatientLinkList}
  TFhirPatientLinkList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPatientLink;
    procedure SetItemN(index : Integer; value : TFhirPatientLink);
  public
    {!script hide}
    function Link : TFhirPatientLinkList; Overload;
    function Clone : TFhirPatientLinkList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirPatientLink to the end of the list.
    }
    function Append : TFhirPatientLink;

    
    {@member AddItem
      Add an already existing FhirPatientLink to the end of the list.
    }
    procedure AddItem(value : TFhirPatientLink);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirPatientLink) : Integer;
    

    {@member Insert
      Insert FhirPatientLink before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirPatientLink;
    

    {@member InsertItem
       Insert an existing FhirPatientLink before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirPatientLink);
    
    {@member Item
       Get the iIndexth FhirPatientLink. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirPatientLink. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirPatientLink);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirPatientLink;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirPatientLinks[index : Integer] : TFhirPatientLink read GetItemN write SetItemN; default;
  End;


  {@Class TFhirPractitionerQualification : TFhirElement
    Qualifications obtained by training and certification.
  }
  {!.Net HL7Connect.Fhir.PractitionerQualification}
  TFhirPractitionerQualification = class (TFhirBackboneElement)
  private
    FCode : TFhirCodeableConcept;
    FPeriod : TFhirPeriod;
    FIssuer : TFhirResourceReference{TFhirOrganization};
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetIssuer(value : TFhirResourceReference{TFhirOrganization});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirPractitionerQualification; overload;
    function Clone : TFhirPractitionerQualification; overload;
    {!script show}
  published
    {@member code
      Coded representation of the qualification.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;

    {@member period
      Period during which the qualification is valid.
    }
    property period : TFhirPeriod read FPeriod write SetPeriod;

    {@member issuer
      Organization that regulates and issues the qualification.
    }
    property issuer : TFhirResourceReference{TFhirOrganization} read FIssuer write SetIssuer;

  end;


  {@Class TFhirPractitionerQualificationList
    A list of FhirPractitionerQualification
  }
  {!.Net HL7Connect.Fhir.PractitionerQualificationList}
  TFhirPractitionerQualificationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPractitionerQualification;
    procedure SetItemN(index : Integer; value : TFhirPractitionerQualification);
  public
    {!script hide}
    function Link : TFhirPractitionerQualificationList; Overload;
    function Clone : TFhirPractitionerQualificationList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirPractitionerQualification to the end of the list.
    }
    function Append : TFhirPractitionerQualification;

    
    {@member AddItem
      Add an already existing FhirPractitionerQualification to the end of the list.
    }
    procedure AddItem(value : TFhirPractitionerQualification);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirPractitionerQualification) : Integer;
    

    {@member Insert
      Insert FhirPractitionerQualification before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirPractitionerQualification;
    

    {@member InsertItem
       Insert an existing FhirPractitionerQualification before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirPractitionerQualification);
    
    {@member Item
       Get the iIndexth FhirPractitionerQualification. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirPractitionerQualification. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirPractitionerQualification);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirPractitionerQualification;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirPractitionerQualifications[index : Integer] : TFhirPractitionerQualification read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProcedurePerformer : TFhirElement
    Limited to 'real' people rather than equipment.
  }
  {!.Net HL7Connect.Fhir.ProcedurePerformer}
  TFhirProcedurePerformer = class (TFhirBackboneElement)
  private
    FPerson : TFhirResourceReference{TFhirPractitioner};
    FRole : TFhirCodeableConcept;
    Procedure SetPerson(value : TFhirResourceReference{TFhirPractitioner});
    Procedure SetRole(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProcedurePerformer; overload;
    function Clone : TFhirProcedurePerformer; overload;
    {!script show}
  published
    {@member person
      The practitioner who was involved in the procedure.
    }
    property person : TFhirResourceReference{TFhirPractitioner} read FPerson write SetPerson;

    {@member role
      E.g. surgeon, anaethetist, endoscopist.
    }
    property role : TFhirCodeableConcept read FRole write SetRole;

  end;


  {@Class TFhirProcedurePerformerList
    A list of FhirProcedurePerformer
  }
  {!.Net HL7Connect.Fhir.ProcedurePerformerList}
  TFhirProcedurePerformerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProcedurePerformer;
    procedure SetItemN(index : Integer; value : TFhirProcedurePerformer);
  public
    {!script hide}
    function Link : TFhirProcedurePerformerList; Overload;
    function Clone : TFhirProcedurePerformerList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProcedurePerformer to the end of the list.
    }
    function Append : TFhirProcedurePerformer;

    
    {@member AddItem
      Add an already existing FhirProcedurePerformer to the end of the list.
    }
    procedure AddItem(value : TFhirProcedurePerformer);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProcedurePerformer) : Integer;
    

    {@member Insert
      Insert FhirProcedurePerformer before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProcedurePerformer;
    

    {@member InsertItem
       Insert an existing FhirProcedurePerformer before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProcedurePerformer);
    
    {@member Item
       Get the iIndexth FhirProcedurePerformer. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProcedurePerformer. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProcedurePerformer);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProcedurePerformer;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProcedurePerformers[index : Integer] : TFhirProcedurePerformer read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProcedureRelatedItem : TFhirElement
    Procedures may be related to other items such as procedures or medications. For example treating wound dehiscence following a previous procedure.
  }
  {!.Net HL7Connect.Fhir.ProcedureRelatedItem}
  TFhirProcedureRelatedItem = class (TFhirBackboneElement)
  private
    FType_ : TFhirEnum;
    FTarget : TFhirResourceReference{Resource};
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirProcedureRelationshipType;
    Procedure SetType_ST(value : TFhirProcedureRelationshipType);
    Procedure SetTarget(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProcedureRelatedItem; overload;
    function Clone : TFhirProcedureRelatedItem; overload;
    {!script show}
  published
    {@member type_
      The nature of the relationship.
    }
    property type_ : TFhirEnum read FType_ write SetType_;
    {@member type_ST
      Typed access to The nature of the relationship.
    }
    property type_ST : TFhirProcedureRelationshipType read GetType_ST write SetType_ST;

    {@member target
      The related item - e.g. a procedure.
    }
    property target : TFhirResourceReference{Resource} read FTarget write SetTarget;

  end;


  {@Class TFhirProcedureRelatedItemList
    A list of FhirProcedureRelatedItem
  }
  {!.Net HL7Connect.Fhir.ProcedureRelatedItemList}
  TFhirProcedureRelatedItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProcedureRelatedItem;
    procedure SetItemN(index : Integer; value : TFhirProcedureRelatedItem);
  public
    {!script hide}
    function Link : TFhirProcedureRelatedItemList; Overload;
    function Clone : TFhirProcedureRelatedItemList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProcedureRelatedItem to the end of the list.
    }
    function Append : TFhirProcedureRelatedItem;

    
    {@member AddItem
      Add an already existing FhirProcedureRelatedItem to the end of the list.
    }
    procedure AddItem(value : TFhirProcedureRelatedItem);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProcedureRelatedItem) : Integer;
    

    {@member Insert
      Insert FhirProcedureRelatedItem before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProcedureRelatedItem;
    

    {@member InsertItem
       Insert an existing FhirProcedureRelatedItem before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProcedureRelatedItem);
    
    {@member Item
       Get the iIndexth FhirProcedureRelatedItem. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProcedureRelatedItem. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProcedureRelatedItem);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProcedureRelatedItem;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProcedureRelatedItems[index : Integer] : TFhirProcedureRelatedItem read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileMapping : TFhirElement
    An external specification that the content is mapped to.
  }
  {!.Net HL7Connect.Fhir.ProfileMapping}
  TFhirProfileMapping = class (TFhirBackboneElement)
  private
    FIdentity : TFhirId;
    FUri : TFhirUri;
    FName : TFhirString;
    FComments : TFhirString;
    Procedure SetIdentity(value : TFhirId);
    Function GetIdentityST : String;
    Procedure SetIdentityST(value : String);
    Procedure SetUri(value : TFhirUri);
    Function GetUriST : String;
    Procedure SetUriST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetComments(value : TFhirString);
    Function GetCommentsST : String;
    Procedure SetCommentsST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileMapping; overload;
    function Clone : TFhirProfileMapping; overload;
    {!script show}
  published
    {@member identity
      An Internal id that is used to identify this mapping set when specific mappings are made.
    }
    property identity : TFhirId read FIdentity write SetIdentity;
    {@member identityST
      Typed access to An Internal id that is used to identify this mapping set when specific mappings are made.
    }
    property identityST : String read GetIdentityST write SetIdentityST;

    {@member uri
      A URI that identifies the specification that this mapping is expressed to.
    }
    property uri : TFhirUri read FUri write SetUri;
    {@member uriST
      Typed access to A URI that identifies the specification that this mapping is expressed to.
    }
    property uriST : String read GetUriST write SetUriST;

    {@member name
      A name for the specification that is being mapped to.
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to A name for the specification that is being mapped to.
    }
    property nameST : String read GetNameST write SetNameST;

    {@member comments
      Comments about this mapping, including version notes, issues, scope limitations, and other important notes for usage.
    }
    property comments : TFhirString read FComments write SetComments;
    {@member commentsST
      Typed access to Comments about this mapping, including version notes, issues, scope limitations, and other important notes for usage.
    }
    property commentsST : String read GetCommentsST write SetCommentsST;

  end;


  {@Class TFhirProfileMappingList
    A list of FhirProfileMapping
  }
  {!.Net HL7Connect.Fhir.ProfileMappingList}
  TFhirProfileMappingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileMapping;
    procedure SetItemN(index : Integer; value : TFhirProfileMapping);
  public
    {!script hide}
    function Link : TFhirProfileMappingList; Overload;
    function Clone : TFhirProfileMappingList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProfileMapping to the end of the list.
    }
    function Append : TFhirProfileMapping;

    
    {@member AddItem
      Add an already existing FhirProfileMapping to the end of the list.
    }
    procedure AddItem(value : TFhirProfileMapping);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileMapping) : Integer;
    

    {@member Insert
      Insert FhirProfileMapping before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileMapping;
    

    {@member InsertItem
       Insert an existing FhirProfileMapping before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileMapping);
    
    {@member Item
       Get the iIndexth FhirProfileMapping. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileMapping. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileMapping);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileMapping;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileMappings[index : Integer] : TFhirProfileMapping read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileStructure : TFhirElement
    A constraint statement about what contents a resource or data type may have.
  }
  {!.Net HL7Connect.Fhir.ProfileStructure}
  TFhirProfileStructure = class (TFhirBackboneElement)
  private
    FType_ : TFhirCode;
    FName : TFhirString;
    FPublish : TFhirBoolean;
    FPurpose : TFhirString;
    FelementList : TFhirProfileStructureElementList;
    FsearchParamList : TFhirProfileStructureSearchParamList;
    Procedure SetType_(value : TFhirCode);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetPublish(value : TFhirBoolean);
    Function GetPublishST : Boolean;
    Procedure SetPublishST(value : Boolean);
    Procedure SetPurpose(value : TFhirString);
    Function GetPurposeST : String;
    Procedure SetPurposeST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileStructure; overload;
    function Clone : TFhirProfileStructure; overload;
    {!script show}
  published
    {@member type_
      The Resource or Data type being described.
    }
    property type_ : TFhirCode read FType_ write SetType_;
    {@member type_ST
      Typed access to The Resource or Data type being described.
    }
    property type_ST : String read GetType_ST write SetType_ST;

    {@member name
      The name of this resource constraint statement (to refer to it from other resource constraints - from Profile.structure.element.definition.type.profile).
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to The name of this resource constraint statement (to refer to it from other resource constraints - from Profile.structure.element.definition.type.profile).
    }
    property nameST : String read GetNameST write SetNameST;

    {@member publish
      This definition of a profile on a structure is published as a formal statement. Some structural definitions might be defined purely for internal use within the profile, and not intended to be used outside that context.
    }
    property publish : TFhirBoolean read FPublish write SetPublish;
    {@member publishST
      Typed access to This definition of a profile on a structure is published as a formal statement. Some structural definitions might be defined purely for internal use within the profile, and not intended to be used outside that context.
    }
    property publishST : Boolean read GetPublishST write SetPublishST;

    {@member purpose
      Human summary: why describe this resource?.
    }
    property purpose : TFhirString read FPurpose write SetPurpose;
    {@member purposeST
      Typed access to Human summary: why describe this resource?.
    }
    property purposeST : String read GetPurposeST write SetPurposeST;

    {@member elementList
      Captures constraints on each element within the resource.
    }
    property elementList : TFhirProfileStructureElementList read FElementList;

    {@member searchParamList
      Additional search parameters for implementations to support and/or make use of.
    }
    property searchParamList : TFhirProfileStructureSearchParamList read FSearchParamList;

  end;


  {@Class TFhirProfileStructureList
    A list of FhirProfileStructure
  }
  {!.Net HL7Connect.Fhir.ProfileStructureList}
  TFhirProfileStructureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileStructure;
    procedure SetItemN(index : Integer; value : TFhirProfileStructure);
  public
    {!script hide}
    function Link : TFhirProfileStructureList; Overload;
    function Clone : TFhirProfileStructureList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProfileStructure to the end of the list.
    }
    function Append : TFhirProfileStructure;

    
    {@member AddItem
      Add an already existing FhirProfileStructure to the end of the list.
    }
    procedure AddItem(value : TFhirProfileStructure);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileStructure) : Integer;
    

    {@member Insert
      Insert FhirProfileStructure before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileStructure;
    

    {@member InsertItem
       Insert an existing FhirProfileStructure before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileStructure);
    
    {@member Item
       Get the iIndexth FhirProfileStructure. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileStructure. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileStructure);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileStructure;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileStructures[index : Integer] : TFhirProfileStructure read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileStructureElement : TFhirElement
    Captures constraints on each element within the resource.
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElement}
  TFhirProfileStructureElement = class (TFhirBackboneElement)
  private
    FPath : TFhirString;
    FRepresentation : TFhirEnumList;
    FName : TFhirString;
    FSlicing : TFhirProfileStructureElementSlicing;
    FDefinition : TFhirProfileStructureElementDefinition;
    Procedure SetPath(value : TFhirString);
    Function GetPathST : String;
    Procedure SetPathST(value : String);
    Function GetRepresentationST : TFhirPropertyRepresentationList;
    Procedure SetRepresentationST(value : TFhirPropertyRepresentationList);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetSlicing(value : TFhirProfileStructureElementSlicing);
    Procedure SetDefinition(value : TFhirProfileStructureElementDefinition);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileStructureElement; overload;
    function Clone : TFhirProfileStructureElement; overload;
    {!script show}
  published
    {@member path
      The path identifies the element and is expressed as a "."-separated list of ancestor elements, beginning with the name of the resource.
    }
    property path : TFhirString read FPath write SetPath;
    {@member pathST
      Typed access to The path identifies the element and is expressed as a "."-separated list of ancestor elements, beginning with the name of the resource.
    }
    property pathST : String read GetPathST write SetPathST;

    {@member representation
      Codes that define how this element is represented in instances, when the deviation varies from the normal case.
    }
    property representation : TFhirEnumList read FRepresentation;
    {@member representationST
      Typed access to Codes that define how this element is represented in instances, when the deviation varies from the normal case.
    }
    property representationST : TFhirPropertyRepresentationList read GetRepresentationST write SetRepresentationST;
    {@member name
      The name of this element definition (to refer to it from other element definitions using Profile.structure.element.definition.nameReference). This is a unique name referring to a specific set of constraints applied to this element. One use of this is to provide a name to different slices of the same element.
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to The name of this element definition (to refer to it from other element definitions using Profile.structure.element.definition.nameReference). This is a unique name referring to a specific set of constraints applied to this element. One use of this is to provide a name to different slices of the same element.
    }
    property nameST : String read GetNameST write SetNameST;

    {@member slicing
      Indicates that the element is sliced into a set of alternative definitions (there are multiple definitions on a single element in the base resource). The set of slices is any elements that come after this in the element sequence that have the same path, until a shorter path occurs (the shorter path terminates the set).
    }
    property slicing : TFhirProfileStructureElementSlicing read FSlicing write SetSlicing;

    {@member definition
      Definition of the content of the element to provide a more specific definition than that contained for the element in the base resource.
    }
    property definition : TFhirProfileStructureElementDefinition read FDefinition write SetDefinition;

  end;


  {@Class TFhirProfileStructureElementList
    A list of FhirProfileStructureElement
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementList}
  TFhirProfileStructureElementList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileStructureElement;
    procedure SetItemN(index : Integer; value : TFhirProfileStructureElement);
  public
    {!script hide}
    function Link : TFhirProfileStructureElementList; Overload;
    function Clone : TFhirProfileStructureElementList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProfileStructureElement to the end of the list.
    }
    function Append : TFhirProfileStructureElement;

    
    {@member AddItem
      Add an already existing FhirProfileStructureElement to the end of the list.
    }
    procedure AddItem(value : TFhirProfileStructureElement);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileStructureElement) : Integer;
    

    {@member Insert
      Insert FhirProfileStructureElement before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileStructureElement;
    

    {@member InsertItem
       Insert an existing FhirProfileStructureElement before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileStructureElement);
    
    {@member Item
       Get the iIndexth FhirProfileStructureElement. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileStructureElement. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileStructureElement);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileStructureElement;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileStructureElements[index : Integer] : TFhirProfileStructureElement read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileStructureElementSlicing : TFhirElement
    Indicates that the element is sliced into a set of alternative definitions (there are multiple definitions on a single element in the base resource). The set of slices is any elements that come after this in the element sequence that have the same path, until a shorter path occurs (the shorter path terminates the set).
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementSlicing}
  TFhirProfileStructureElementSlicing = class (TFhirBackboneElement)
  private
    FDiscriminator : TFhirId;
    FOrdered : TFhirBoolean;
    FRules : TFhirEnum;
    Procedure SetDiscriminator(value : TFhirId);
    Function GetDiscriminatorST : String;
    Procedure SetDiscriminatorST(value : String);
    Procedure SetOrdered(value : TFhirBoolean);
    Function GetOrderedST : Boolean;
    Procedure SetOrderedST(value : Boolean);
    Procedure SetRules(value : TFhirEnum);
    Function GetRulesST : TFhirResourceSlicingRules;
    Procedure SetRulesST(value : TFhirResourceSlicingRules);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileStructureElementSlicing; overload;
    function Clone : TFhirProfileStructureElementSlicing; overload;
    {!script show}
  published
    {@member discriminator
      Designates which child element is used to discriminate between the slices when processing an instance. The value of the child element in the instance SHALL completely distinguish which slice the element in the resource matches based on the allowed values for that element in each of the slices.
    }
    property discriminator : TFhirId read FDiscriminator write SetDiscriminator;
    {@member discriminatorST
      Typed access to Designates which child element is used to discriminate between the slices when processing an instance. The value of the child element in the instance SHALL completely distinguish which slice the element in the resource matches based on the allowed values for that element in each of the slices.
    }
    property discriminatorST : String read GetDiscriminatorST write SetDiscriminatorST;

    {@member ordered
      If the matching elements have to occur in the same order as defined in the profile.
    }
    property ordered : TFhirBoolean read FOrdered write SetOrdered;
    {@member orderedST
      Typed access to If the matching elements have to occur in the same order as defined in the profile.
    }
    property orderedST : Boolean read GetOrderedST write SetOrderedST;

    {@member rules
      Whether additional slices are allowed or not. When the slices are ordered, profile authors can also say that additional slices are only allowed at the end.
    }
    property rules : TFhirEnum read FRules write SetRules;
    {@member rulesST
      Typed access to Whether additional slices are allowed or not. When the slices are ordered, profile authors can also say that additional slices are only allowed at the end.
    }
    property rulesST : TFhirResourceSlicingRules read GetRulesST write SetRulesST;

  end;


  {@Class TFhirProfileStructureElementSlicingList
    A list of FhirProfileStructureElementSlicing
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementSlicingList}
  TFhirProfileStructureElementSlicingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileStructureElementSlicing;
    procedure SetItemN(index : Integer; value : TFhirProfileStructureElementSlicing);
  public
    {!script hide}
    function Link : TFhirProfileStructureElementSlicingList; Overload;
    function Clone : TFhirProfileStructureElementSlicingList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProfileStructureElementSlicing to the end of the list.
    }
    function Append : TFhirProfileStructureElementSlicing;

    
    {@member AddItem
      Add an already existing FhirProfileStructureElementSlicing to the end of the list.
    }
    procedure AddItem(value : TFhirProfileStructureElementSlicing);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileStructureElementSlicing) : Integer;
    

    {@member Insert
      Insert FhirProfileStructureElementSlicing before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileStructureElementSlicing;
    

    {@member InsertItem
       Insert an existing FhirProfileStructureElementSlicing before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileStructureElementSlicing);
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementSlicing. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementSlicing. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileStructureElementSlicing);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileStructureElementSlicing;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileStructureElementSlicings[index : Integer] : TFhirProfileStructureElementSlicing read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileStructureElementDefinition : TFhirElement
    Definition of the content of the element to provide a more specific definition than that contained for the element in the base resource.
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinition}
  TFhirProfileStructureElementDefinition = class (TFhirBackboneElement)
  private
    FShort : TFhirString;
    FFormal : TFhirString;
    FComments : TFhirString;
    FRequirements : TFhirString;
    FsynonymList : TFhirStringList;
    FMin : TFhirInteger;
    FMax : TFhirString;
    Ftype_List : TFhirProfileStructureElementDefinitionTypeList;
    FNameReference : TFhirString;
    FValue : TFhirType;
    FExample : TFhirType;
    FMaxLength : TFhirInteger;
    FconditionList : TFhirIdList;
    FconstraintList : TFhirProfileStructureElementDefinitionConstraintList;
    FMustSupport : TFhirBoolean;
    FIsModifier : TFhirBoolean;
    FBinding : TFhirProfileStructureElementDefinitionBinding;
    FmappingList : TFhirProfileStructureElementDefinitionMappingList;
    Procedure SetShort(value : TFhirString);
    Function GetShortST : String;
    Procedure SetShortST(value : String);
    Procedure SetFormal(value : TFhirString);
    Function GetFormalST : String;
    Procedure SetFormalST(value : String);
    Procedure SetComments(value : TFhirString);
    Function GetCommentsST : String;
    Procedure SetCommentsST(value : String);
    Procedure SetRequirements(value : TFhirString);
    Function GetRequirementsST : String;
    Procedure SetRequirementsST(value : String);
    Procedure SetMin(value : TFhirInteger);
    Function GetMinST : String;
    Procedure SetMinST(value : String);
    Procedure SetMax(value : TFhirString);
    Function GetMaxST : String;
    Procedure SetMaxST(value : String);
    Procedure SetNameReference(value : TFhirString);
    Function GetNameReferenceST : String;
    Procedure SetNameReferenceST(value : String);
    Procedure SetValue(value : TFhirType);
    Procedure SetExample(value : TFhirType);
    Procedure SetMaxLength(value : TFhirInteger);
    Function GetMaxLengthST : String;
    Procedure SetMaxLengthST(value : String);
    Procedure SetMustSupport(value : TFhirBoolean);
    Function GetMustSupportST : Boolean;
    Procedure SetMustSupportST(value : Boolean);
    Procedure SetIsModifier(value : TFhirBoolean);
    Function GetIsModifierST : Boolean;
    Procedure SetIsModifierST(value : Boolean);
    Procedure SetBinding(value : TFhirProfileStructureElementDefinitionBinding);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileStructureElementDefinition; overload;
    function Clone : TFhirProfileStructureElementDefinition; overload;
    {!script show}
  published
    {@member short
      A concise definition that  is shown in the generated XML format that summarizes profiles (used throughout the specification).
    }
    property short : TFhirString read FShort write SetShort;
    {@member shortST
      Typed access to A concise definition that  is shown in the generated XML format that summarizes profiles (used throughout the specification).
    }
    property shortST : String read GetShortST write SetShortST;

    {@member formal
      The definition SHALL be consistent with the base definition, but convey the meaning of the element in the particular context of use of the resource.
    }
    property formal : TFhirString read FFormal write SetFormal;
    {@member formalST
      Typed access to The definition SHALL be consistent with the base definition, but convey the meaning of the element in the particular context of use of the resource.
    }
    property formalST : String read GetFormalST write SetFormalST;

    {@member comments
      Comments about the use of the element, including notes about how to use the data properly, exceptions to proper use, etc.
    }
    property comments : TFhirString read FComments write SetComments;
    {@member commentsST
      Typed access to Comments about the use of the element, including notes about how to use the data properly, exceptions to proper use, etc.
    }
    property commentsST : String read GetCommentsST write SetCommentsST;

    {@member requirements
      Explains why this element is needed and why it's been constrained as it has.
    }
    property requirements : TFhirString read FRequirements write SetRequirements;
    {@member requirementsST
      Typed access to Explains why this element is needed and why it's been constrained as it has.
    }
    property requirementsST : String read GetRequirementsST write SetRequirementsST;

    {@member synonymList
      Identifies additional names by which this element might also be known.
    }
    property synonymList : TFhirStringList read FSynonymList;

    {@member min
      The minimum number of times this element SHALL appear in the instance.
    }
    property min : TFhirInteger read FMin write SetMin;
    {@member minST
      Typed access to The minimum number of times this element SHALL appear in the instance.
    }
    property minST : String read GetMinST write SetMinST;

    {@member max
      The maximum number of times this element is permitted to appear in the instance.
    }
    property max : TFhirString read FMax write SetMax;
    {@member maxST
      Typed access to The maximum number of times this element is permitted to appear in the instance.
    }
    property maxST : String read GetMaxST write SetMaxST;

    {@member type_List
      The data type or resource that the value of this element is permitted to be.
    }
    property type_List : TFhirProfileStructureElementDefinitionTypeList read FType_List;

    {@member nameReference
      Identifies the name of a slice defined elsewhere in the profile whose constraints should be applied to the current element.
    }
    property nameReference : TFhirString read FNameReference write SetNameReference;
    {@member nameReferenceST
      Typed access to Identifies the name of a slice defined elsewhere in the profile whose constraints should be applied to the current element.
    }
    property nameReferenceST : String read GetNameReferenceST write SetNameReferenceST;

    {@member value
      Specifies a primitive value that SHALL hold for this element in the instance.
    }
    property value : TFhirType read FValue write SetValue;

    {@member example
      An example value for this element.
    }
    property example : TFhirType read FExample write SetExample;

    {@member maxLength
      Indicates the shortest length that SHALL be supported by conformant instances without truncation.
    }
    property maxLength : TFhirInteger read FMaxLength write SetMaxLength;
    {@member maxLengthST
      Typed access to Indicates the shortest length that SHALL be supported by conformant instances without truncation.
    }
    property maxLengthST : String read GetMaxLengthST write SetMaxLengthST;

    {@member conditionList
      A reference to an invariant that may make additional statements about the cardinality or value in the instance.
    }
    property conditionList : TFhirIdList read FConditionList;

    {@member constraintList
      Formal constraints such as co-occurrence and other constraints that can be computationally evaluated within the context of the instance.
    }
    property constraintList : TFhirProfileStructureElementDefinitionConstraintList read FConstraintList;

    {@member mustSupport
      If true, conformant resource authors SHALL be capable of providing a value for the element and resource consumers SHALL be capable of extracting and doing something useful with the data element.  If false, the element may be ignored and not supported.
    }
    property mustSupport : TFhirBoolean read FMustSupport write SetMustSupport;
    {@member mustSupportST
      Typed access to If true, conformant resource authors SHALL be capable of providing a value for the element and resource consumers SHALL be capable of extracting and doing something useful with the data element.  If false, the element may be ignored and not supported.
    }
    property mustSupportST : Boolean read GetMustSupportST write SetMustSupportST;

    {@member isModifier
      If true, the value of this element affects the interpretation of the element or resource that contains it, and the value of the element cannot be ignored. Typically, this is used for status, negation and qualification codes. The effect of this is that the element cannot be ignored by systems: they SHALL either recognize the element and process it, and/or a pre-determination has been made that it is not relevant to their particular system.
    }
    property isModifier : TFhirBoolean read FIsModifier write SetIsModifier;
    {@member isModifierST
      Typed access to If true, the value of this element affects the interpretation of the element or resource that contains it, and the value of the element cannot be ignored. Typically, this is used for status, negation and qualification codes. The effect of this is that the element cannot be ignored by systems: they SHALL either recognize the element and process it, and/or a pre-determination has been made that it is not relevant to their particular system.
    }
    property isModifierST : Boolean read GetIsModifierST write SetIsModifierST;

    {@member binding
      Binds to a value set if this element is coded (code, Coding, CodeableConcept).
    }
    property binding : TFhirProfileStructureElementDefinitionBinding read FBinding write SetBinding;

    {@member mappingList
      Identifies a concept from an external specification that roughly corresponds to this element.
    }
    property mappingList : TFhirProfileStructureElementDefinitionMappingList read FMappingList;

  end;


  {@Class TFhirProfileStructureElementDefinitionList
    A list of FhirProfileStructureElementDefinition
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinitionList}
  TFhirProfileStructureElementDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileStructureElementDefinition;
    procedure SetItemN(index : Integer; value : TFhirProfileStructureElementDefinition);
  public
    {!script hide}
    function Link : TFhirProfileStructureElementDefinitionList; Overload;
    function Clone : TFhirProfileStructureElementDefinitionList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProfileStructureElementDefinition to the end of the list.
    }
    function Append : TFhirProfileStructureElementDefinition;

    
    {@member AddItem
      Add an already existing FhirProfileStructureElementDefinition to the end of the list.
    }
    procedure AddItem(value : TFhirProfileStructureElementDefinition);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileStructureElementDefinition) : Integer;
    

    {@member Insert
      Insert FhirProfileStructureElementDefinition before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileStructureElementDefinition;
    

    {@member InsertItem
       Insert an existing FhirProfileStructureElementDefinition before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileStructureElementDefinition);
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinition. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinition. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileStructureElementDefinition);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileStructureElementDefinition;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileStructureElementDefinitions[index : Integer] : TFhirProfileStructureElementDefinition read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileStructureElementDefinitionType : TFhirElement
    The data type or resource that the value of this element is permitted to be.
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinitionType}
  TFhirProfileStructureElementDefinitionType = class (TFhirBackboneElement)
  private
    FCode : TFhirCode;
    FProfile : TFhirUri;
    FAggregation : TFhirEnumList;
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetProfile(value : TFhirUri);
    Function GetProfileST : String;
    Procedure SetProfileST(value : String);
    Function GetAggregationST : TFhirResourceAggregationModeList;
    Procedure SetAggregationST(value : TFhirResourceAggregationModeList);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileStructureElementDefinitionType; overload;
    function Clone : TFhirProfileStructureElementDefinitionType; overload;
    {!script show}
  published
    {@member code
      Name of Data type or Resource.
    }
    property code : TFhirCode read FCode write SetCode;
    {@member codeST
      Typed access to Name of Data type or Resource.
    }
    property codeST : String read GetCodeST write SetCodeST;

    {@member profile
      Identifies a profile that SHALL hold for resources or datatypes referenced as the type of this element. Can be a local reference - to another structure in this profile, or a reference to a structure in another profile.
    }
    property profile : TFhirUri read FProfile write SetProfile;
    {@member profileST
      Typed access to Identifies a profile that SHALL hold for resources or datatypes referenced as the type of this element. Can be a local reference - to another structure in this profile, or a reference to a structure in another profile.
    }
    property profileST : String read GetProfileST write SetProfileST;

    {@member aggregation
      If the type is a reference to another resource, how the resource is or can be aggreated - is it a contained resource, or a reference, and if the context is a bundle, is it included in the bundle.
    }
    property aggregation : TFhirEnumList read FAggregation;
    {@member aggregationST
      Typed access to If the type is a reference to another resource, how the resource is or can be aggreated - is it a contained resource, or a reference, and if the context is a bundle, is it included in the bundle.
    }
    property aggregationST : TFhirResourceAggregationModeList read GetAggregationST write SetAggregationST;
  end;


  {@Class TFhirProfileStructureElementDefinitionTypeList
    A list of FhirProfileStructureElementDefinitionType
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinitionTypeList}
  TFhirProfileStructureElementDefinitionTypeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileStructureElementDefinitionType;
    procedure SetItemN(index : Integer; value : TFhirProfileStructureElementDefinitionType);
  public
    {!script hide}
    function Link : TFhirProfileStructureElementDefinitionTypeList; Overload;
    function Clone : TFhirProfileStructureElementDefinitionTypeList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProfileStructureElementDefinitionType to the end of the list.
    }
    function Append : TFhirProfileStructureElementDefinitionType;

    
    {@member AddItem
      Add an already existing FhirProfileStructureElementDefinitionType to the end of the list.
    }
    procedure AddItem(value : TFhirProfileStructureElementDefinitionType);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileStructureElementDefinitionType) : Integer;
    

    {@member Insert
      Insert FhirProfileStructureElementDefinitionType before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileStructureElementDefinitionType;
    

    {@member InsertItem
       Insert an existing FhirProfileStructureElementDefinitionType before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileStructureElementDefinitionType);
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinitionType. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinitionType. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileStructureElementDefinitionType);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileStructureElementDefinitionType;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileStructureElementDefinitionTypes[index : Integer] : TFhirProfileStructureElementDefinitionType read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileStructureElementDefinitionConstraint : TFhirElement
    Formal constraints such as co-occurrence and other constraints that can be computationally evaluated within the context of the instance.
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinitionConstraint}
  TFhirProfileStructureElementDefinitionConstraint = class (TFhirBackboneElement)
  private
    FKey : TFhirId;
    FName : TFhirString;
    FSeverity : TFhirEnum;
    FHuman : TFhirString;
    FXpath : TFhirString;
    Procedure SetKey(value : TFhirId);
    Function GetKeyST : String;
    Procedure SetKeyST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetSeverity(value : TFhirEnum);
    Function GetSeverityST : TFhirConstraintSeverity;
    Procedure SetSeverityST(value : TFhirConstraintSeverity);
    Procedure SetHuman(value : TFhirString);
    Function GetHumanST : String;
    Procedure SetHumanST(value : String);
    Procedure SetXpath(value : TFhirString);
    Function GetXpathST : String;
    Procedure SetXpathST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileStructureElementDefinitionConstraint; overload;
    function Clone : TFhirProfileStructureElementDefinitionConstraint; overload;
    {!script show}
  published
    {@member key
      Allows identification of which elements have their cardinalities impacted by the constraint.  Will not be referenced for constraints that do not affect cardinality.
    }
    property key : TFhirId read FKey write SetKey;
    {@member keyST
      Typed access to Allows identification of which elements have their cardinalities impacted by the constraint.  Will not be referenced for constraints that do not affect cardinality.
    }
    property keyST : String read GetKeyST write SetKeyST;

    {@member name
      Used to label the constraint in OCL or in short displays incapable of displaying the full human description.
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to Used to label the constraint in OCL or in short displays incapable of displaying the full human description.
    }
    property nameST : String read GetNameST write SetNameST;

    {@member severity
      Identifies the impact constraint violation has on the conformance of the instance.
    }
    property severity : TFhirEnum read FSeverity write SetSeverity;
    {@member severityST
      Typed access to Identifies the impact constraint violation has on the conformance of the instance.
    }
    property severityST : TFhirConstraintSeverity read GetSeverityST write SetSeverityST;

    {@member human
      Text that can be used to describe the constraint in messages identifying that the constraint has been violated.
    }
    property human : TFhirString read FHuman write SetHuman;
    {@member humanST
      Typed access to Text that can be used to describe the constraint in messages identifying that the constraint has been violated.
    }
    property humanST : String read GetHumanST write SetHumanST;

    {@member xpath
      XPath expression of constraint.
    }
    property xpath : TFhirString read FXpath write SetXpath;
    {@member xpathST
      Typed access to XPath expression of constraint.
    }
    property xpathST : String read GetXpathST write SetXpathST;

  end;


  {@Class TFhirProfileStructureElementDefinitionConstraintList
    A list of FhirProfileStructureElementDefinitionConstraint
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinitionConstraintList}
  TFhirProfileStructureElementDefinitionConstraintList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileStructureElementDefinitionConstraint;
    procedure SetItemN(index : Integer; value : TFhirProfileStructureElementDefinitionConstraint);
  public
    {!script hide}
    function Link : TFhirProfileStructureElementDefinitionConstraintList; Overload;
    function Clone : TFhirProfileStructureElementDefinitionConstraintList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProfileStructureElementDefinitionConstraint to the end of the list.
    }
    function Append : TFhirProfileStructureElementDefinitionConstraint;

    
    {@member AddItem
      Add an already existing FhirProfileStructureElementDefinitionConstraint to the end of the list.
    }
    procedure AddItem(value : TFhirProfileStructureElementDefinitionConstraint);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileStructureElementDefinitionConstraint) : Integer;
    

    {@member Insert
      Insert FhirProfileStructureElementDefinitionConstraint before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileStructureElementDefinitionConstraint;
    

    {@member InsertItem
       Insert an existing FhirProfileStructureElementDefinitionConstraint before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileStructureElementDefinitionConstraint);
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinitionConstraint. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinitionConstraint. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileStructureElementDefinitionConstraint);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileStructureElementDefinitionConstraint;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileStructureElementDefinitionConstraints[index : Integer] : TFhirProfileStructureElementDefinitionConstraint read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileStructureElementDefinitionBinding : TFhirElement
    Binds to a value set if this element is coded (code, Coding, CodeableConcept).
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinitionBinding}
  TFhirProfileStructureElementDefinitionBinding = class (TFhirBackboneElement)
  private
    FName : TFhirString;
    FIsExtensible : TFhirBoolean;
    FConformance : TFhirEnum;
    FDescription : TFhirString;
    FReference : TFhirType;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetIsExtensible(value : TFhirBoolean);
    Function GetIsExtensibleST : Boolean;
    Procedure SetIsExtensibleST(value : Boolean);
    Procedure SetConformance(value : TFhirEnum);
    Function GetConformanceST : TFhirBindingConformance;
    Procedure SetConformanceST(value : TFhirBindingConformance);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetReference(value : TFhirType);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileStructureElementDefinitionBinding; overload;
    function Clone : TFhirProfileStructureElementDefinitionBinding; overload;
    {!script show}
  published
    {@member name
      A descriptive name for this - can be useful for generating implementation artifacts.
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to A descriptive name for this - can be useful for generating implementation artifacts.
    }
    property nameST : String read GetNameST write SetNameST;

    {@member isExtensible
      If true, then conformant systems may use additional codes or (where the data type permits) text alone to convey concepts not covered by the set of codes identified in the binding.  If false, then conformant systems are constrained to the provided codes alone.
    }
    property isExtensible : TFhirBoolean read FIsExtensible write SetIsExtensible;
    {@member isExtensibleST
      Typed access to If true, then conformant systems may use additional codes or (where the data type permits) text alone to convey concepts not covered by the set of codes identified in the binding.  If false, then conformant systems are constrained to the provided codes alone.
    }
    property isExtensibleST : Boolean read GetIsExtensibleST write SetIsExtensibleST;

    {@member conformance
      Indicates the degree of conformance expectations associated with this binding.
    }
    property conformance : TFhirEnum read FConformance write SetConformance;
    {@member conformanceST
      Typed access to Indicates the degree of conformance expectations associated with this binding.
    }
    property conformanceST : TFhirBindingConformance read GetConformanceST write SetConformanceST;

    {@member description
      Describes the intended use of this particular set of codes.
    }
    property description : TFhirString read FDescription write SetDescription;
    {@member descriptionST
      Typed access to Describes the intended use of this particular set of codes.
    }
    property descriptionST : String read GetDescriptionST write SetDescriptionST;

    {@member reference
      Points to the value set or external definition that identifies the set of codes to be used.
    }
    property reference : TFhirType read FReference write SetReference;

  end;


  {@Class TFhirProfileStructureElementDefinitionBindingList
    A list of FhirProfileStructureElementDefinitionBinding
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinitionBindingList}
  TFhirProfileStructureElementDefinitionBindingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileStructureElementDefinitionBinding;
    procedure SetItemN(index : Integer; value : TFhirProfileStructureElementDefinitionBinding);
  public
    {!script hide}
    function Link : TFhirProfileStructureElementDefinitionBindingList; Overload;
    function Clone : TFhirProfileStructureElementDefinitionBindingList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProfileStructureElementDefinitionBinding to the end of the list.
    }
    function Append : TFhirProfileStructureElementDefinitionBinding;

    
    {@member AddItem
      Add an already existing FhirProfileStructureElementDefinitionBinding to the end of the list.
    }
    procedure AddItem(value : TFhirProfileStructureElementDefinitionBinding);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileStructureElementDefinitionBinding) : Integer;
    

    {@member Insert
      Insert FhirProfileStructureElementDefinitionBinding before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileStructureElementDefinitionBinding;
    

    {@member InsertItem
       Insert an existing FhirProfileStructureElementDefinitionBinding before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileStructureElementDefinitionBinding);
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinitionBinding. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinitionBinding. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileStructureElementDefinitionBinding);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileStructureElementDefinitionBinding;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileStructureElementDefinitionBindings[index : Integer] : TFhirProfileStructureElementDefinitionBinding read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileStructureElementDefinitionMapping : TFhirElement
    Identifies a concept from an external specification that roughly corresponds to this element.
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinitionMapping}
  TFhirProfileStructureElementDefinitionMapping = class (TFhirBackboneElement)
  private
    FIdentity : TFhirId;
    FMap : TFhirString;
    Procedure SetIdentity(value : TFhirId);
    Function GetIdentityST : String;
    Procedure SetIdentityST(value : String);
    Procedure SetMap(value : TFhirString);
    Function GetMapST : String;
    Procedure SetMapST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileStructureElementDefinitionMapping; overload;
    function Clone : TFhirProfileStructureElementDefinitionMapping; overload;
    {!script show}
  published
    {@member identity
      An internal reference to the definition of a mapping.
    }
    property identity : TFhirId read FIdentity write SetIdentity;
    {@member identityST
      Typed access to An internal reference to the definition of a mapping.
    }
    property identityST : String read GetIdentityST write SetIdentityST;

    {@member map
      Expresses what part of the target specification corresponds to this element.
    }
    property map : TFhirString read FMap write SetMap;
    {@member mapST
      Typed access to Expresses what part of the target specification corresponds to this element.
    }
    property mapST : String read GetMapST write SetMapST;

  end;


  {@Class TFhirProfileStructureElementDefinitionMappingList
    A list of FhirProfileStructureElementDefinitionMapping
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinitionMappingList}
  TFhirProfileStructureElementDefinitionMappingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileStructureElementDefinitionMapping;
    procedure SetItemN(index : Integer; value : TFhirProfileStructureElementDefinitionMapping);
  public
    {!script hide}
    function Link : TFhirProfileStructureElementDefinitionMappingList; Overload;
    function Clone : TFhirProfileStructureElementDefinitionMappingList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProfileStructureElementDefinitionMapping to the end of the list.
    }
    function Append : TFhirProfileStructureElementDefinitionMapping;

    
    {@member AddItem
      Add an already existing FhirProfileStructureElementDefinitionMapping to the end of the list.
    }
    procedure AddItem(value : TFhirProfileStructureElementDefinitionMapping);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileStructureElementDefinitionMapping) : Integer;
    

    {@member Insert
      Insert FhirProfileStructureElementDefinitionMapping before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileStructureElementDefinitionMapping;
    

    {@member InsertItem
       Insert an existing FhirProfileStructureElementDefinitionMapping before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileStructureElementDefinitionMapping);
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinitionMapping. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinitionMapping. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileStructureElementDefinitionMapping);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileStructureElementDefinitionMapping;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileStructureElementDefinitionMappings[index : Integer] : TFhirProfileStructureElementDefinitionMapping read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileStructureSearchParam : TFhirElement
    Additional search parameters for implementations to support and/or make use of.
  }
  {!.Net HL7Connect.Fhir.ProfileStructureSearchParam}
  TFhirProfileStructureSearchParam = class (TFhirBackboneElement)
  private
    FName : TFhirString;
    FType_ : TFhirEnum;
    FDocumentation : TFhirString;
    FXpath : TFhirString;
    FtargetList : TFhirCodeList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirSearchParamType;
    Procedure SetType_ST(value : TFhirSearchParamType);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
    Procedure SetXpath(value : TFhirString);
    Function GetXpathST : String;
    Procedure SetXpathST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileStructureSearchParam; overload;
    function Clone : TFhirProfileStructureSearchParam; overload;
    {!script show}
  published
    {@member name
      The name of the standard or custom search parameter.
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to The name of the standard or custom search parameter.
    }
    property nameST : String read GetNameST write SetNameST;

    {@member type_
      The type of value a search parameter refers to, and how the content is interpreted.
    }
    property type_ : TFhirEnum read FType_ write SetType_;
    {@member type_ST
      Typed access to The type of value a search parameter refers to, and how the content is interpreted.
    }
    property type_ST : TFhirSearchParamType read GetType_ST write SetType_ST;

    {@member documentation
      A specification for search parameters. For standard parameters, provides additional information on how the parameter is used in this solution.  For custom parameters, provides a description of what the parameter does.
    }
    property documentation : TFhirString read FDocumentation write SetDocumentation;
    {@member documentationST
      Typed access to A specification for search parameters. For standard parameters, provides additional information on how the parameter is used in this solution.  For custom parameters, provides a description of what the parameter does.
    }
    property documentationST : String read GetDocumentationST write SetDocumentationST;

    {@member xpath
      An XPath expression that returns a set of elements for the search parameter.
    }
    property xpath : TFhirString read FXpath write SetXpath;
    {@member xpathST
      Typed access to An XPath expression that returns a set of elements for the search parameter.
    }
    property xpathST : String read GetXpathST write SetXpathST;

    {@member targetList
      Types of resource (if a resource is referenced).
    }
    property targetList : TFhirCodeList read FTargetList;

  end;


  {@Class TFhirProfileStructureSearchParamList
    A list of FhirProfileStructureSearchParam
  }
  {!.Net HL7Connect.Fhir.ProfileStructureSearchParamList}
  TFhirProfileStructureSearchParamList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileStructureSearchParam;
    procedure SetItemN(index : Integer; value : TFhirProfileStructureSearchParam);
  public
    {!script hide}
    function Link : TFhirProfileStructureSearchParamList; Overload;
    function Clone : TFhirProfileStructureSearchParamList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProfileStructureSearchParam to the end of the list.
    }
    function Append : TFhirProfileStructureSearchParam;

    
    {@member AddItem
      Add an already existing FhirProfileStructureSearchParam to the end of the list.
    }
    procedure AddItem(value : TFhirProfileStructureSearchParam);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileStructureSearchParam) : Integer;
    

    {@member Insert
      Insert FhirProfileStructureSearchParam before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileStructureSearchParam;
    

    {@member InsertItem
       Insert an existing FhirProfileStructureSearchParam before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileStructureSearchParam);
    
    {@member Item
       Get the iIndexth FhirProfileStructureSearchParam. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileStructureSearchParam. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileStructureSearchParam);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileStructureSearchParam;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileStructureSearchParams[index : Integer] : TFhirProfileStructureSearchParam read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileExtensionDefn : TFhirElement
    An extension defined as part of the profile.
  }
  {!.Net HL7Connect.Fhir.ProfileExtensionDefn}
  TFhirProfileExtensionDefn = class (TFhirBackboneElement)
  private
    FCode : TFhirCode;
    FDisplay : TFhirString;
    FContextType : TFhirEnum;
    FcontextList : TFhirStringList;
    FDefinition : TFhirProfileStructureElementDefinition;
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
    Procedure SetContextType(value : TFhirEnum);
    Function GetContextTypeST : TFhirExtensionContext;
    Procedure SetContextTypeST(value : TFhirExtensionContext);
    Procedure SetDefinition(value : TFhirProfileStructureElementDefinition);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileExtensionDefn; overload;
    function Clone : TFhirProfileExtensionDefn; overload;
    {!script show}
  published
    {@member code
      A unique code (within the profile) used to identify the extension.
    }
    property code : TFhirCode read FCode write SetCode;
    {@member codeST
      Typed access to A unique code (within the profile) used to identify the extension.
    }
    property codeST : String read GetCodeST write SetCodeST;

    {@member display
      Defined so that applications can use this name when displaying the value of the extension to the user.
    }
    property display : TFhirString read FDisplay write SetDisplay;
    {@member displayST
      Typed access to Defined so that applications can use this name when displaying the value of the extension to the user.
    }
    property displayST : String read GetDisplayST write SetDisplayST;

    {@member contextType
      Identifies the type of context to which the extension applies.
    }
    property contextType : TFhirEnum read FContextType write SetContextType;
    {@member contextTypeST
      Typed access to Identifies the type of context to which the extension applies.
    }
    property contextTypeST : TFhirExtensionContext read GetContextTypeST write SetContextTypeST;

    {@member contextList
      Identifies the types of resource or data type elements to which the extension can be applied.
    }
    property contextList : TFhirStringList read FContextList;

    {@member definition
      Definition of the extension and its content.
    }
    property definition : TFhirProfileStructureElementDefinition read FDefinition write SetDefinition;

  end;


  {@Class TFhirProfileExtensionDefnList
    A list of FhirProfileExtensionDefn
  }
  {!.Net HL7Connect.Fhir.ProfileExtensionDefnList}
  TFhirProfileExtensionDefnList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileExtensionDefn;
    procedure SetItemN(index : Integer; value : TFhirProfileExtensionDefn);
  public
    {!script hide}
    function Link : TFhirProfileExtensionDefnList; Overload;
    function Clone : TFhirProfileExtensionDefnList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProfileExtensionDefn to the end of the list.
    }
    function Append : TFhirProfileExtensionDefn;

    
    {@member AddItem
      Add an already existing FhirProfileExtensionDefn to the end of the list.
    }
    procedure AddItem(value : TFhirProfileExtensionDefn);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileExtensionDefn) : Integer;
    

    {@member Insert
      Insert FhirProfileExtensionDefn before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileExtensionDefn;
    

    {@member InsertItem
       Insert an existing FhirProfileExtensionDefn before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileExtensionDefn);
    
    {@member Item
       Get the iIndexth FhirProfileExtensionDefn. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileExtensionDefn. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileExtensionDefn);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileExtensionDefn;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileExtensionDefns[index : Integer] : TFhirProfileExtensionDefn read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileQuery : TFhirElement
    Definition of a named query and its parameters and their meaning.
  }
  {!.Net HL7Connect.Fhir.ProfileQuery}
  TFhirProfileQuery = class (TFhirBackboneElement)
  private
    FName : TFhirString;
    FDocumentation : TFhirString;
    FparameterList : TFhirProfileStructureSearchParamList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileQuery; overload;
    function Clone : TFhirProfileQuery; overload;
    {!script show}
  published
    {@member name
      The name of a query, which is used in the URI from Conformance statements declaring use of the query.  Typically this will also be the name for the _query parameter when the query is called, though in some cases it may be aliased by a server to avoid collisions.
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to The name of a query, which is used in the URI from Conformance statements declaring use of the query.  Typically this will also be the name for the _query parameter when the query is called, though in some cases it may be aliased by a server to avoid collisions.
    }
    property nameST : String read GetNameST write SetNameST;

    {@member documentation
      Description of the query - the functionality it offers, and considerations about how it functions and to use it.
    }
    property documentation : TFhirString read FDocumentation write SetDocumentation;
    {@member documentationST
      Typed access to Description of the query - the functionality it offers, and considerations about how it functions and to use it.
    }
    property documentationST : String read GetDocumentationST write SetDocumentationST;

    {@member parameterList
      A parameter of a named query.
    }
    property parameterList : TFhirProfileStructureSearchParamList read FParameterList;

  end;


  {@Class TFhirProfileQueryList
    A list of FhirProfileQuery
  }
  {!.Net HL7Connect.Fhir.ProfileQueryList}
  TFhirProfileQueryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileQuery;
    procedure SetItemN(index : Integer; value : TFhirProfileQuery);
  public
    {!script hide}
    function Link : TFhirProfileQueryList; Overload;
    function Clone : TFhirProfileQueryList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProfileQuery to the end of the list.
    }
    function Append : TFhirProfileQuery;

    
    {@member AddItem
      Add an already existing FhirProfileQuery to the end of the list.
    }
    procedure AddItem(value : TFhirProfileQuery);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileQuery) : Integer;
    

    {@member Insert
      Insert FhirProfileQuery before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileQuery;
    

    {@member InsertItem
       Insert an existing FhirProfileQuery before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileQuery);
    
    {@member Item
       Get the iIndexth FhirProfileQuery. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileQuery. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileQuery);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileQuery;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileQueries[index : Integer] : TFhirProfileQuery read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProvenanceAgent : TFhirElement
    An agent takes a role in an activity such that the agent can be assigned some degree of responsibility for the activity taking place. An agent can be a person, a piece of software, an inanimate object, an organization, or other entities that may be ascribed responsibility.
  }
  {!.Net HL7Connect.Fhir.ProvenanceAgent}
  TFhirProvenanceAgent = class (TFhirBackboneElement)
  private
    FRole : TFhirCoding;
    FType_ : TFhirCoding;
    FReference : TFhirUri;
    FDisplay : TFhirString;
    Procedure SetRole(value : TFhirCoding);
    Procedure SetType_(value : TFhirCoding);
    Procedure SetReference(value : TFhirUri);
    Function GetReferenceST : String;
    Procedure SetReferenceST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProvenanceAgent; overload;
    function Clone : TFhirProvenanceAgent; overload;
    {!script show}
  published
    {@member role
      The role that the participant played.
    }
    property role : TFhirCoding read FRole write SetRole;

    {@member type_
      The type of the participant.
    }
    property type_ : TFhirCoding read FType_ write SetType_;

    {@member reference
      Identity of participant. May be a logical or physical uri and maybe absolute or relative.
    }
    property reference : TFhirUri read FReference write SetReference;
    {@member referenceST
      Typed access to Identity of participant. May be a logical or physical uri and maybe absolute or relative.
    }
    property referenceST : String read GetReferenceST write SetReferenceST;

    {@member display
      Human-readable description of the participant.
    }
    property display : TFhirString read FDisplay write SetDisplay;
    {@member displayST
      Typed access to Human-readable description of the participant.
    }
    property displayST : String read GetDisplayST write SetDisplayST;

  end;


  {@Class TFhirProvenanceAgentList
    A list of FhirProvenanceAgent
  }
  {!.Net HL7Connect.Fhir.ProvenanceAgentList}
  TFhirProvenanceAgentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProvenanceAgent;
    procedure SetItemN(index : Integer; value : TFhirProvenanceAgent);
  public
    {!script hide}
    function Link : TFhirProvenanceAgentList; Overload;
    function Clone : TFhirProvenanceAgentList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProvenanceAgent to the end of the list.
    }
    function Append : TFhirProvenanceAgent;

    
    {@member AddItem
      Add an already existing FhirProvenanceAgent to the end of the list.
    }
    procedure AddItem(value : TFhirProvenanceAgent);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProvenanceAgent) : Integer;
    

    {@member Insert
      Insert FhirProvenanceAgent before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProvenanceAgent;
    

    {@member InsertItem
       Insert an existing FhirProvenanceAgent before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProvenanceAgent);
    
    {@member Item
       Get the iIndexth FhirProvenanceAgent. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProvenanceAgent. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProvenanceAgent);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProvenanceAgent;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProvenanceAgents[index : Integer] : TFhirProvenanceAgent read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProvenanceEntity : TFhirElement
    An entity used in this activity.
  }
  {!.Net HL7Connect.Fhir.ProvenanceEntity}
  TFhirProvenanceEntity = class (TFhirBackboneElement)
  private
    FRole : TFhirEnum;
    FType_ : TFhirCoding;
    FReference : TFhirUri;
    FDisplay : TFhirString;
    FAgent : TFhirProvenanceAgent;
    Procedure SetRole(value : TFhirEnum);
    Function GetRoleST : TFhirProvenanceEntityRole;
    Procedure SetRoleST(value : TFhirProvenanceEntityRole);
    Procedure SetType_(value : TFhirCoding);
    Procedure SetReference(value : TFhirUri);
    Function GetReferenceST : String;
    Procedure SetReferenceST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
    Procedure SetAgent(value : TFhirProvenanceAgent);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProvenanceEntity; overload;
    function Clone : TFhirProvenanceEntity; overload;
    {!script show}
  published
    {@member role
      How the entity was used during the activity.
    }
    property role : TFhirEnum read FRole write SetRole;
    {@member roleST
      Typed access to How the entity was used during the activity.
    }
    property roleST : TFhirProvenanceEntityRole read GetRoleST write SetRoleST;

    {@member type_
      The type of the entity. If the entity is a resource, then this is a resource type.
    }
    property type_ : TFhirCoding read FType_ write SetType_;

    {@member reference
      Identity of participant. May be a logical or physical uri and maybe absolute or relative.
    }
    property reference : TFhirUri read FReference write SetReference;
    {@member referenceST
      Typed access to Identity of participant. May be a logical or physical uri and maybe absolute or relative.
    }
    property referenceST : String read GetReferenceST write SetReferenceST;

    {@member display
      Human-readable description of the entity.
    }
    property display : TFhirString read FDisplay write SetDisplay;
    {@member displayST
      Typed access to Human-readable description of the entity.
    }
    property displayST : String read GetDisplayST write SetDisplayST;

    {@member agent
      The entity is attributed to an agent to express the agent's responsibility for that entity, possibly along with other agents. This description can be understood as shorthand for saying that the agent was responsible for the activity which generated the entity.
    }
    property agent : TFhirProvenanceAgent read FAgent write SetAgent;

  end;


  {@Class TFhirProvenanceEntityList
    A list of FhirProvenanceEntity
  }
  {!.Net HL7Connect.Fhir.ProvenanceEntityList}
  TFhirProvenanceEntityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProvenanceEntity;
    procedure SetItemN(index : Integer; value : TFhirProvenanceEntity);
  public
    {!script hide}
    function Link : TFhirProvenanceEntityList; Overload;
    function Clone : TFhirProvenanceEntityList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirProvenanceEntity to the end of the list.
    }
    function Append : TFhirProvenanceEntity;

    
    {@member AddItem
      Add an already existing FhirProvenanceEntity to the end of the list.
    }
    procedure AddItem(value : TFhirProvenanceEntity);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProvenanceEntity) : Integer;
    

    {@member Insert
      Insert FhirProvenanceEntity before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProvenanceEntity;
    

    {@member InsertItem
       Insert an existing FhirProvenanceEntity before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProvenanceEntity);
    
    {@member Item
       Get the iIndexth FhirProvenanceEntity. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProvenanceEntity. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProvenanceEntity);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProvenanceEntity;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProvenanceEntities[index : Integer] : TFhirProvenanceEntity read GetItemN write SetItemN; default;
  End;


  {@Class TFhirQueryResponse : TFhirElement
    If this is a response to a query.
  }
  {!.Net HL7Connect.Fhir.QueryResponse}
  TFhirQueryResponse = class (TFhirBackboneElement)
  private
    FIdentifier : TFhirUri;
    FOutcome : TFhirEnum;
    FTotal : TFhirInteger;
    FparameterList : TFhirExtensionList;
    FfirstList : TFhirExtensionList;
    FpreviousList : TFhirExtensionList;
    FnextList : TFhirExtensionList;
    FlastList : TFhirExtensionList;
    FreferenceList : TFhirResourceReferenceList{Resource};
    Procedure SetIdentifier(value : TFhirUri);
    Function GetIdentifierST : String;
    Procedure SetIdentifierST(value : String);
    Procedure SetOutcome(value : TFhirEnum);
    Function GetOutcomeST : TFhirQueryOutcome;
    Procedure SetOutcomeST(value : TFhirQueryOutcome);
    Procedure SetTotal(value : TFhirInteger);
    Function GetTotalST : String;
    Procedure SetTotalST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirQueryResponse; overload;
    function Clone : TFhirQueryResponse; overload;
    {!script show}
  published
    {@member identifier
      Links response to source query.
    }
    property identifier : TFhirUri read FIdentifier write SetIdentifier;
    {@member identifierST
      Typed access to Links response to source query.
    }
    property identifierST : String read GetIdentifierST write SetIdentifierST;

    {@member outcome
      Outcome of processing the query.
    }
    property outcome : TFhirEnum read FOutcome write SetOutcome;
    {@member outcomeST
      Typed access to Outcome of processing the query.
    }
    property outcomeST : TFhirQueryOutcome read GetOutcomeST write SetOutcomeST;

    {@member total
      Total number of matching records.
    }
    property total : TFhirInteger read FTotal write SetTotal;
    {@member totalST
      Typed access to Total number of matching records.
    }
    property totalST : String read GetTotalST write SetTotalST;

    {@member parameterList
      Parameters server used.
    }
    property parameterList : TFhirExtensionList read FParameterList;

    {@member firstList
      To get first page (if paged).
    }
    property firstList : TFhirExtensionList read FFirstList;

    {@member previousList
      To get previous page (if paged).
    }
    property previousList : TFhirExtensionList read FPreviousList;

    {@member nextList
      To get next page (if paged).
    }
    property nextList : TFhirExtensionList read FNextList;

    {@member lastList
      To get last page (if paged).
    }
    property lastList : TFhirExtensionList read FLastList;

    {@member referenceList
      Resources that are the results of the search.
    }
    property referenceList : TFhirResourceReferenceList{Resource} read FReferenceList;

  end;


  {@Class TFhirQueryResponseList
    A list of FhirQueryResponse
  }
  {!.Net HL7Connect.Fhir.QueryResponseList}
  TFhirQueryResponseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirQueryResponse;
    procedure SetItemN(index : Integer; value : TFhirQueryResponse);
  public
    {!script hide}
    function Link : TFhirQueryResponseList; Overload;
    function Clone : TFhirQueryResponseList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirQueryResponse to the end of the list.
    }
    function Append : TFhirQueryResponse;

    
    {@member AddItem
      Add an already existing FhirQueryResponse to the end of the list.
    }
    procedure AddItem(value : TFhirQueryResponse);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirQueryResponse) : Integer;
    

    {@member Insert
      Insert FhirQueryResponse before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirQueryResponse;
    

    {@member InsertItem
       Insert an existing FhirQueryResponse before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirQueryResponse);
    
    {@member Item
       Get the iIndexth FhirQueryResponse. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirQueryResponse. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirQueryResponse);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirQueryResponse;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirQueryResponses[index : Integer] : TFhirQueryResponse read GetItemN write SetItemN; default;
  End;


  {@Class TFhirQuestionnaireGroup : TFhirElement
    A group of questions to a possibly similarly grouped set of questions in the questionnaire.
  }
  {!.Net HL7Connect.Fhir.QuestionnaireGroup}
  TFhirQuestionnaireGroup = class (TFhirBackboneElement)
  private
    FName : TFhirCodeableConcept;
    FHeader : TFhirString;
    FText : TFhirString;
    FSubject : TFhirResourceReference{Resource};
    FgroupList : TFhirQuestionnaireGroupList;
    FquestionList : TFhirQuestionnaireGroupQuestionList;
    Procedure SetName(value : TFhirCodeableConcept);
    Procedure SetHeader(value : TFhirString);
    Function GetHeaderST : String;
    Procedure SetHeaderST(value : String);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    Procedure SetSubject(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirQuestionnaireGroup; overload;
    function Clone : TFhirQuestionnaireGroup; overload;
    {!script show}
  published
    {@member name
      Structured name for a section of a predefined list of questions this questionnaire is responding to.
    }
    property name : TFhirCodeableConcept read FName write SetName;

    {@member header
      Text that is displayed above the contents of the group.
    }
    property header : TFhirString read FHeader write SetHeader;
    {@member headerST
      Typed access to Text that is displayed above the contents of the group.
    }
    property headerST : String read GetHeaderST write SetHeaderST;

    {@member text
      Additional text for the group, used for display purposes.
    }
    property text : TFhirString read FText write SetText;
    {@member textST
      Typed access to Additional text for the group, used for display purposes.
    }
    property textST : String read GetTextST write SetTextST;

    {@member subject
      More specific subject this section's answers are about, details the subject given in Questionnaire.
    }
    property subject : TFhirResourceReference{Resource} read FSubject write SetSubject;

    {@member groupList
      A sub-group within a group. The ordering of groups within this group is relevant.
    }
    property groupList : TFhirQuestionnaireGroupList read FGroupList;

    {@member questionList
      Set of questions within this group. The order of questions within the group is relevant.
    }
    property questionList : TFhirQuestionnaireGroupQuestionList read FQuestionList;

  end;


  {@Class TFhirQuestionnaireGroupList
    A list of FhirQuestionnaireGroup
  }
  {!.Net HL7Connect.Fhir.QuestionnaireGroupList}
  TFhirQuestionnaireGroupList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirQuestionnaireGroup;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireGroup);
  public
    {!script hide}
    function Link : TFhirQuestionnaireGroupList; Overload;
    function Clone : TFhirQuestionnaireGroupList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirQuestionnaireGroup to the end of the list.
    }
    function Append : TFhirQuestionnaireGroup;

    
    {@member AddItem
      Add an already existing FhirQuestionnaireGroup to the end of the list.
    }
    procedure AddItem(value : TFhirQuestionnaireGroup);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirQuestionnaireGroup) : Integer;
    

    {@member Insert
      Insert FhirQuestionnaireGroup before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirQuestionnaireGroup;
    

    {@member InsertItem
       Insert an existing FhirQuestionnaireGroup before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireGroup);
    
    {@member Item
       Get the iIndexth FhirQuestionnaireGroup. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirQuestionnaireGroup. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireGroup);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirQuestionnaireGroup;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirQuestionnaireGroups[index : Integer] : TFhirQuestionnaireGroup read GetItemN write SetItemN; default;
  End;


  {@Class TFhirQuestionnaireGroupQuestion : TFhirElement
    Set of questions within this group. The order of questions within the group is relevant.
  }
  {!.Net HL7Connect.Fhir.QuestionnaireGroupQuestion}
  TFhirQuestionnaireGroupQuestion = class (TFhirBackboneElement)
  private
    FName : TFhirCodeableConcept;
    FText : TFhirString;
    FAnswer : TFhirType;
    FchoiceList : TFhirCodingList;
    FOptions : TFhirResourceReference{TFhirValueSet};
    FData : TFhirType;
    FRemarks : TFhirString;
    FgroupList : TFhirQuestionnaireGroupList;
    Procedure SetName(value : TFhirCodeableConcept);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    Procedure SetAnswer(value : TFhirType);
    Procedure SetOptions(value : TFhirResourceReference{TFhirValueSet});
    Procedure SetData(value : TFhirType);
    Procedure SetRemarks(value : TFhirString);
    Function GetRemarksST : String;
    Procedure SetRemarksST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirQuestionnaireGroupQuestion; overload;
    function Clone : TFhirQuestionnaireGroupQuestion; overload;
    {!script show}
  published
    {@member name
      Structured name for the question that identifies this question within the Questionnaire or Group.
    }
    property name : TFhirCodeableConcept read FName write SetName;

    {@member text
      Text of the question as it is shown to the user.
    }
    property text : TFhirString read FText write SetText;
    {@member textST
      Typed access to Text of the question as it is shown to the user.
    }
    property textST : String read GetTextST write SetTextST;

    {@member answer
      Single-valued answer to the question.
    }
    property answer : TFhirType read FAnswer write SetAnswer;

    {@member choiceList
      Selections made by the user from the list of options.
    }
    property choiceList : TFhirCodingList read FChoiceList;

    {@member options
      Reference to a valueset containing the possible options.
    }
    property options : TFhirResourceReference{TFhirValueSet} read FOptions write SetOptions;

    {@member data
      Structured answer in the form of a FHIR Resource or datatype.
    }
    property data : TFhirType read FData write SetData;

    {@member remarks
      The remark contains information about the answer given. This is additional information about the answer the author wishes to convey, but should not be used to contain information that is part of the answer itself.
    }
    property remarks : TFhirString read FRemarks write SetRemarks;
    {@member remarksST
      Typed access to The remark contains information about the answer given. This is additional information about the answer the author wishes to convey, but should not be used to contain information that is part of the answer itself.
    }
    property remarksST : String read GetRemarksST write SetRemarksST;

    {@member groupList
      Nested group, containing nested question for this question. The order of groups within the question is relevant.
    }
    property groupList : TFhirQuestionnaireGroupList read FGroupList;

  end;


  {@Class TFhirQuestionnaireGroupQuestionList
    A list of FhirQuestionnaireGroupQuestion
  }
  {!.Net HL7Connect.Fhir.QuestionnaireGroupQuestionList}
  TFhirQuestionnaireGroupQuestionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirQuestionnaireGroupQuestion;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireGroupQuestion);
  public
    {!script hide}
    function Link : TFhirQuestionnaireGroupQuestionList; Overload;
    function Clone : TFhirQuestionnaireGroupQuestionList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirQuestionnaireGroupQuestion to the end of the list.
    }
    function Append : TFhirQuestionnaireGroupQuestion;

    
    {@member AddItem
      Add an already existing FhirQuestionnaireGroupQuestion to the end of the list.
    }
    procedure AddItem(value : TFhirQuestionnaireGroupQuestion);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirQuestionnaireGroupQuestion) : Integer;
    

    {@member Insert
      Insert FhirQuestionnaireGroupQuestion before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirQuestionnaireGroupQuestion;
    

    {@member InsertItem
       Insert an existing FhirQuestionnaireGroupQuestion before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireGroupQuestion);
    
    {@member Item
       Get the iIndexth FhirQuestionnaireGroupQuestion. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirQuestionnaireGroupQuestion. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireGroupQuestion);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirQuestionnaireGroupQuestion;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirQuestionnaireGroupQuestions[index : Integer] : TFhirQuestionnaireGroupQuestion read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSecurityEventEvent : TFhirElement
    Identifies the name, action type, time, and disposition of the audited event.
  }
  {!.Net HL7Connect.Fhir.SecurityEventEvent}
  TFhirSecurityEventEvent = class (TFhirBackboneElement)
  private
    FType_ : TFhirCodeableConcept;
    FsubtypeList : TFhirCodeableConceptList;
    FAction : TFhirEnum;
    FDateTime : TFhirInstant;
    FOutcome : TFhirEnum;
    FOutcomeDesc : TFhirString;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetAction(value : TFhirEnum);
    Function GetActionST : TFhirSecurityEventAction;
    Procedure SetActionST(value : TFhirSecurityEventAction);
    Procedure SetDateTime(value : TFhirInstant);
    Function GetDateTimeST : TDateAndTime;
    Procedure SetDateTimeST(value : TDateAndTime);
    Procedure SetOutcome(value : TFhirEnum);
    Function GetOutcomeST : TFhirSecurityEventOutcome;
    Procedure SetOutcomeST(value : TFhirSecurityEventOutcome);
    Procedure SetOutcomeDesc(value : TFhirString);
    Function GetOutcomeDescST : String;
    Procedure SetOutcomeDescST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSecurityEventEvent; overload;
    function Clone : TFhirSecurityEventEvent; overload;
    {!script show}
  published
    {@member type_
      Identifier for a family of the event.
    }
    property type_ : TFhirCodeableConcept read FType_ write SetType_;

    {@member subtypeList
      Identifier for the category of event.
    }
    property subtypeList : TFhirCodeableConceptList read FSubtypeList;

    {@member action
      Indicator for type of action performed during the event that generated the audit.
    }
    property action : TFhirEnum read FAction write SetAction;
    {@member actionST
      Typed access to Indicator for type of action performed during the event that generated the audit.
    }
    property actionST : TFhirSecurityEventAction read GetActionST write SetActionST;

    {@member dateTime
      The time when the event occurred on the source.
    }
    property dateTime : TFhirInstant read FDateTime write SetDateTime;
    {@member dateTimeST
      Typed access to The time when the event occurred on the source.
    }
    property dateTimeST : TDateAndTime read GetDateTimeST write SetDateTimeST;

    {@member outcome
      Indicates whether the event succeeded or failed.
    }
    property outcome : TFhirEnum read FOutcome write SetOutcome;
    {@member outcomeST
      Typed access to Indicates whether the event succeeded or failed.
    }
    property outcomeST : TFhirSecurityEventOutcome read GetOutcomeST write SetOutcomeST;

    {@member outcomeDesc
      A free text description of the outcome of the event.
    }
    property outcomeDesc : TFhirString read FOutcomeDesc write SetOutcomeDesc;
    {@member outcomeDescST
      Typed access to A free text description of the outcome of the event.
    }
    property outcomeDescST : String read GetOutcomeDescST write SetOutcomeDescST;

  end;


  {@Class TFhirSecurityEventEventList
    A list of FhirSecurityEventEvent
  }
  {!.Net HL7Connect.Fhir.SecurityEventEventList}
  TFhirSecurityEventEventList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSecurityEventEvent;
    procedure SetItemN(index : Integer; value : TFhirSecurityEventEvent);
  public
    {!script hide}
    function Link : TFhirSecurityEventEventList; Overload;
    function Clone : TFhirSecurityEventEventList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirSecurityEventEvent to the end of the list.
    }
    function Append : TFhirSecurityEventEvent;

    
    {@member AddItem
      Add an already existing FhirSecurityEventEvent to the end of the list.
    }
    procedure AddItem(value : TFhirSecurityEventEvent);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSecurityEventEvent) : Integer;
    

    {@member Insert
      Insert FhirSecurityEventEvent before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSecurityEventEvent;
    

    {@member InsertItem
       Insert an existing FhirSecurityEventEvent before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSecurityEventEvent);
    
    {@member Item
       Get the iIndexth FhirSecurityEventEvent. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSecurityEventEvent. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSecurityEventEvent);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSecurityEventEvent;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSecurityEventEvents[index : Integer] : TFhirSecurityEventEvent read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSecurityEventParticipant : TFhirElement
    A person, a hardware device or software process.
  }
  {!.Net HL7Connect.Fhir.SecurityEventParticipant}
  TFhirSecurityEventParticipant = class (TFhirBackboneElement)
  private
    FroleList : TFhirCodeableConceptList;
    FReference : TFhirResourceReference{Resource};
    FUserId : TFhirString;
    FAltId : TFhirString;
    FName : TFhirString;
    FRequestor : TFhirBoolean;
    FMedia : TFhirCoding;
    FNetwork : TFhirSecurityEventParticipantNetwork;
    Procedure SetReference(value : TFhirResourceReference{Resource});
    Procedure SetUserId(value : TFhirString);
    Function GetUserIdST : String;
    Procedure SetUserIdST(value : String);
    Procedure SetAltId(value : TFhirString);
    Function GetAltIdST : String;
    Procedure SetAltIdST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetRequestor(value : TFhirBoolean);
    Function GetRequestorST : Boolean;
    Procedure SetRequestorST(value : Boolean);
    Procedure SetMedia(value : TFhirCoding);
    Procedure SetNetwork(value : TFhirSecurityEventParticipantNetwork);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSecurityEventParticipant; overload;
    function Clone : TFhirSecurityEventParticipant; overload;
    {!script show}
  published
    {@member roleList
      Specification of the role(s) the user plays when performing the event. Usually the codes used in this element are local codes defined by the role-based access control security system used in the local context.
    }
    property roleList : TFhirCodeableConceptList read FRoleList;

    {@member reference
      Direct reference to a resource that identifies the participant.
    }
    property reference : TFhirResourceReference{Resource} read FReference write SetReference;

    {@member userId
      Unique identifier for the user actively participating in the event.
    }
    property userId : TFhirString read FUserId write SetUserId;
    {@member userIdST
      Typed access to Unique identifier for the user actively participating in the event.
    }
    property userIdST : String read GetUserIdST write SetUserIdST;

    {@member altId
      Alternative Participant Identifier. For a human, this should be a user identifier text string from authentication system. This identifier would be one known to a common authentication system (e.g., single sign-on), if available.
    }
    property altId : TFhirString read FAltId write SetAltId;
    {@member altIdST
      Typed access to Alternative Participant Identifier. For a human, this should be a user identifier text string from authentication system. This identifier would be one known to a common authentication system (e.g., single sign-on), if available.
    }
    property altIdST : String read GetAltIdST write SetAltIdST;

    {@member name
      Human-meaningful name for the user.
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to Human-meaningful name for the user.
    }
    property nameST : String read GetNameST write SetNameST;

    {@member requestor
      Indicator that the user is or is not the requestor, or initiator, for the event being audited.
    }
    property requestor : TFhirBoolean read FRequestor write SetRequestor;
    {@member requestorST
      Typed access to Indicator that the user is or is not the requestor, or initiator, for the event being audited.
    }
    property requestorST : Boolean read GetRequestorST write SetRequestorST;

    {@member media
      Type of media involved. Used when the event is about exporting/importing onto media.
    }
    property media : TFhirCoding read FMedia write SetMedia;

    {@member network
      Logical network location for application activity, if the activity has a network location.
    }
    property network : TFhirSecurityEventParticipantNetwork read FNetwork write SetNetwork;

  end;


  {@Class TFhirSecurityEventParticipantList
    A list of FhirSecurityEventParticipant
  }
  {!.Net HL7Connect.Fhir.SecurityEventParticipantList}
  TFhirSecurityEventParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSecurityEventParticipant;
    procedure SetItemN(index : Integer; value : TFhirSecurityEventParticipant);
  public
    {!script hide}
    function Link : TFhirSecurityEventParticipantList; Overload;
    function Clone : TFhirSecurityEventParticipantList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirSecurityEventParticipant to the end of the list.
    }
    function Append : TFhirSecurityEventParticipant;

    
    {@member AddItem
      Add an already existing FhirSecurityEventParticipant to the end of the list.
    }
    procedure AddItem(value : TFhirSecurityEventParticipant);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSecurityEventParticipant) : Integer;
    

    {@member Insert
      Insert FhirSecurityEventParticipant before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSecurityEventParticipant;
    

    {@member InsertItem
       Insert an existing FhirSecurityEventParticipant before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSecurityEventParticipant);
    
    {@member Item
       Get the iIndexth FhirSecurityEventParticipant. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSecurityEventParticipant. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSecurityEventParticipant);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSecurityEventParticipant;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSecurityEventParticipants[index : Integer] : TFhirSecurityEventParticipant read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSecurityEventParticipantNetwork : TFhirElement
    Logical network location for application activity, if the activity has a network location.
  }
  {!.Net HL7Connect.Fhir.SecurityEventParticipantNetwork}
  TFhirSecurityEventParticipantNetwork = class (TFhirBackboneElement)
  private
    FIdentifier : TFhirString;
    FType_ : TFhirEnum;
    Procedure SetIdentifier(value : TFhirString);
    Function GetIdentifierST : String;
    Procedure SetIdentifierST(value : String);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirNetworkType;
    Procedure SetType_ST(value : TFhirNetworkType);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSecurityEventParticipantNetwork; overload;
    function Clone : TFhirSecurityEventParticipantNetwork; overload;
    {!script show}
  published
    {@member identifier
      An identifier for the network access point of the user device for the audit event.
    }
    property identifier : TFhirString read FIdentifier write SetIdentifier;
    {@member identifierST
      Typed access to An identifier for the network access point of the user device for the audit event.
    }
    property identifierST : String read GetIdentifierST write SetIdentifierST;

    {@member type_
      An identifier for the type of network access point that originated the audit event.
    }
    property type_ : TFhirEnum read FType_ write SetType_;
    {@member type_ST
      Typed access to An identifier for the type of network access point that originated the audit event.
    }
    property type_ST : TFhirNetworkType read GetType_ST write SetType_ST;

  end;


  {@Class TFhirSecurityEventParticipantNetworkList
    A list of FhirSecurityEventParticipantNetwork
  }
  {!.Net HL7Connect.Fhir.SecurityEventParticipantNetworkList}
  TFhirSecurityEventParticipantNetworkList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSecurityEventParticipantNetwork;
    procedure SetItemN(index : Integer; value : TFhirSecurityEventParticipantNetwork);
  public
    {!script hide}
    function Link : TFhirSecurityEventParticipantNetworkList; Overload;
    function Clone : TFhirSecurityEventParticipantNetworkList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirSecurityEventParticipantNetwork to the end of the list.
    }
    function Append : TFhirSecurityEventParticipantNetwork;

    
    {@member AddItem
      Add an already existing FhirSecurityEventParticipantNetwork to the end of the list.
    }
    procedure AddItem(value : TFhirSecurityEventParticipantNetwork);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSecurityEventParticipantNetwork) : Integer;
    

    {@member Insert
      Insert FhirSecurityEventParticipantNetwork before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSecurityEventParticipantNetwork;
    

    {@member InsertItem
       Insert an existing FhirSecurityEventParticipantNetwork before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSecurityEventParticipantNetwork);
    
    {@member Item
       Get the iIndexth FhirSecurityEventParticipantNetwork. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSecurityEventParticipantNetwork. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSecurityEventParticipantNetwork);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSecurityEventParticipantNetwork;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSecurityEventParticipantNetworks[index : Integer] : TFhirSecurityEventParticipantNetwork read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSecurityEventSource : TFhirElement
    Application systems and processes.
  }
  {!.Net HL7Connect.Fhir.SecurityEventSource}
  TFhirSecurityEventSource = class (TFhirBackboneElement)
  private
    FSite : TFhirString;
    FIdentifier : TFhirString;
    Ftype_List : TFhirCodingList;
    Procedure SetSite(value : TFhirString);
    Function GetSiteST : String;
    Procedure SetSiteST(value : String);
    Procedure SetIdentifier(value : TFhirString);
    Function GetIdentifierST : String;
    Procedure SetIdentifierST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSecurityEventSource; overload;
    function Clone : TFhirSecurityEventSource; overload;
    {!script show}
  published
    {@member site
      Logical source location within the healthcare enterprise network.
    }
    property site : TFhirString read FSite write SetSite;
    {@member siteST
      Typed access to Logical source location within the healthcare enterprise network.
    }
    property siteST : String read GetSiteST write SetSiteST;

    {@member identifier
      Identifier of the source where the event originated.
    }
    property identifier : TFhirString read FIdentifier write SetIdentifier;
    {@member identifierST
      Typed access to Identifier of the source where the event originated.
    }
    property identifierST : String read GetIdentifierST write SetIdentifierST;

    {@member type_List
      Code specifying the type of source where event originated.
    }
    property type_List : TFhirCodingList read FType_List;

  end;


  {@Class TFhirSecurityEventSourceList
    A list of FhirSecurityEventSource
  }
  {!.Net HL7Connect.Fhir.SecurityEventSourceList}
  TFhirSecurityEventSourceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSecurityEventSource;
    procedure SetItemN(index : Integer; value : TFhirSecurityEventSource);
  public
    {!script hide}
    function Link : TFhirSecurityEventSourceList; Overload;
    function Clone : TFhirSecurityEventSourceList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirSecurityEventSource to the end of the list.
    }
    function Append : TFhirSecurityEventSource;

    
    {@member AddItem
      Add an already existing FhirSecurityEventSource to the end of the list.
    }
    procedure AddItem(value : TFhirSecurityEventSource);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSecurityEventSource) : Integer;
    

    {@member Insert
      Insert FhirSecurityEventSource before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSecurityEventSource;
    

    {@member InsertItem
       Insert an existing FhirSecurityEventSource before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSecurityEventSource);
    
    {@member Item
       Get the iIndexth FhirSecurityEventSource. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSecurityEventSource. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSecurityEventSource);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSecurityEventSource;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSecurityEventSources[index : Integer] : TFhirSecurityEventSource read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSecurityEventObject : TFhirElement
    Specific instances of data or objects that have been accessed.
  }
  {!.Net HL7Connect.Fhir.SecurityEventObject}
  TFhirSecurityEventObject = class (TFhirBackboneElement)
  private
    FIdentifier : TFhirIdentifier;
    FReference : TFhirResourceReference{Resource};
    FType_ : TFhirEnum;
    FRole : TFhirEnum;
    FLifecycle : TFhirEnum;
    FSensitivity : TFhirCodeableConcept;
    FName : TFhirString;
    FDescription : TFhirString;
    FQuery : TFhirBase64Binary;
    FdetailList : TFhirSecurityEventObjectDetailList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetReference(value : TFhirResourceReference{Resource});
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirObjectType;
    Procedure SetType_ST(value : TFhirObjectType);
    Procedure SetRole(value : TFhirEnum);
    Function GetRoleST : TFhirObjectRole;
    Procedure SetRoleST(value : TFhirObjectRole);
    Procedure SetLifecycle(value : TFhirEnum);
    Function GetLifecycleST : TFhirObjectLifecycle;
    Procedure SetLifecycleST(value : TFhirObjectLifecycle);
    Procedure SetSensitivity(value : TFhirCodeableConcept);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetQuery(value : TFhirBase64Binary);
    Function GetQueryST : String;
    Procedure SetQueryST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSecurityEventObject; overload;
    function Clone : TFhirSecurityEventObject; overload;
    {!script show}
  published
    {@member identifier
      Identifies a specific instance of the participant object. The reference should always be version specific.
    }
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;

    {@member reference
      Identifies a specific instance of the participant object. The reference should always be version specific.
    }
    property reference : TFhirResourceReference{Resource} read FReference write SetReference;

    {@member type_
      Object type being audited.
    }
    property type_ : TFhirEnum read FType_ write SetType_;
    {@member type_ST
      Typed access to Object type being audited.
    }
    property type_ST : TFhirObjectType read GetType_ST write SetType_ST;

    {@member role
      Code representing the functional application role of Participant Object being audited.
    }
    property role : TFhirEnum read FRole write SetRole;
    {@member roleST
      Typed access to Code representing the functional application role of Participant Object being audited.
    }
    property roleST : TFhirObjectRole read GetRoleST write SetRoleST;

    {@member lifecycle
      Identifier for the data life-cycle stage for the participant object.
    }
    property lifecycle : TFhirEnum read FLifecycle write SetLifecycle;
    {@member lifecycleST
      Typed access to Identifier for the data life-cycle stage for the participant object.
    }
    property lifecycleST : TFhirObjectLifecycle read GetLifecycleST write SetLifecycleST;

    {@member sensitivity
      Denotes policy-defined sensitivity for the Participant Object ID such as VIP, HIV status, mental health status or similar topics.
    }
    property sensitivity : TFhirCodeableConcept read FSensitivity write SetSensitivity;

    {@member name
      An instance-specific descriptor of the Participant Object ID audited, such as a person's name.
    }
    property name : TFhirString read FName write SetName;
    {@member nameST
      Typed access to An instance-specific descriptor of the Participant Object ID audited, such as a person's name.
    }
    property nameST : String read GetNameST write SetNameST;

    {@member description
      Text that describes the object in more detail.
    }
    property description : TFhirString read FDescription write SetDescription;
    {@member descriptionST
      Typed access to Text that describes the object in more detail.
    }
    property descriptionST : String read GetDescriptionST write SetDescriptionST;

    {@member query
      The actual query for a query-type participant object.
    }
    property query : TFhirBase64Binary read FQuery write SetQuery;
    {@member queryST
      Typed access to The actual query for a query-type participant object.
    }
    property queryST : String read GetQueryST write SetQueryST;

    {@member detailList
      Additional Information about the Object.
    }
    property detailList : TFhirSecurityEventObjectDetailList read FDetailList;

  end;


  {@Class TFhirSecurityEventObjectList
    A list of FhirSecurityEventObject
  }
  {!.Net HL7Connect.Fhir.SecurityEventObjectList}
  TFhirSecurityEventObjectList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSecurityEventObject;
    procedure SetItemN(index : Integer; value : TFhirSecurityEventObject);
  public
    {!script hide}
    function Link : TFhirSecurityEventObjectList; Overload;
    function Clone : TFhirSecurityEventObjectList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirSecurityEventObject to the end of the list.
    }
    function Append : TFhirSecurityEventObject;

    
    {@member AddItem
      Add an already existing FhirSecurityEventObject to the end of the list.
    }
    procedure AddItem(value : TFhirSecurityEventObject);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSecurityEventObject) : Integer;
    

    {@member Insert
      Insert FhirSecurityEventObject before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSecurityEventObject;
    

    {@member InsertItem
       Insert an existing FhirSecurityEventObject before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSecurityEventObject);
    
    {@member Item
       Get the iIndexth FhirSecurityEventObject. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSecurityEventObject. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSecurityEventObject);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSecurityEventObject;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSecurityEventObjects[index : Integer] : TFhirSecurityEventObject read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSecurityEventObjectDetail : TFhirElement
    Additional Information about the Object.
  }
  {!.Net HL7Connect.Fhir.SecurityEventObjectDetail}
  TFhirSecurityEventObjectDetail = class (TFhirBackboneElement)
  private
    FType_ : TFhirString;
    FValue : TFhirBase64Binary;
    Procedure SetType_(value : TFhirString);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetValue(value : TFhirBase64Binary);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSecurityEventObjectDetail; overload;
    function Clone : TFhirSecurityEventObjectDetail; overload;
    {!script show}
  published
    {@member type_
      Name of the property.
    }
    property type_ : TFhirString read FType_ write SetType_;
    {@member type_ST
      Typed access to Name of the property.
    }
    property type_ST : String read GetType_ST write SetType_ST;

    {@member value
      Property value.
    }
    property value : TFhirBase64Binary read FValue write SetValue;
    {@member valueST
      Typed access to Property value.
    }
    property valueST : String read GetValueST write SetValueST;

  end;


  {@Class TFhirSecurityEventObjectDetailList
    A list of FhirSecurityEventObjectDetail
  }
  {!.Net HL7Connect.Fhir.SecurityEventObjectDetailList}
  TFhirSecurityEventObjectDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSecurityEventObjectDetail;
    procedure SetItemN(index : Integer; value : TFhirSecurityEventObjectDetail);
  public
    {!script hide}
    function Link : TFhirSecurityEventObjectDetailList; Overload;
    function Clone : TFhirSecurityEventObjectDetailList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirSecurityEventObjectDetail to the end of the list.
    }
    function Append : TFhirSecurityEventObjectDetail;

    
    {@member AddItem
      Add an already existing FhirSecurityEventObjectDetail to the end of the list.
    }
    procedure AddItem(value : TFhirSecurityEventObjectDetail);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSecurityEventObjectDetail) : Integer;
    

    {@member Insert
      Insert FhirSecurityEventObjectDetail before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSecurityEventObjectDetail;
    

    {@member InsertItem
       Insert an existing FhirSecurityEventObjectDetail before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSecurityEventObjectDetail);
    
    {@member Item
       Get the iIndexth FhirSecurityEventObjectDetail. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSecurityEventObjectDetail. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSecurityEventObjectDetail);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSecurityEventObjectDetail;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSecurityEventObjectDetails[index : Integer] : TFhirSecurityEventObjectDetail read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSpecimenSource : TFhirElement
    Parent specimen from which the focal specimen was a component.
  }
  {!.Net HL7Connect.Fhir.SpecimenSource}
  TFhirSpecimenSource = class (TFhirBackboneElement)
  private
    FRelationship : TFhirEnum;
    FtargetList : TFhirResourceReferenceList{TFhirSpecimen};
    Procedure SetRelationship(value : TFhirEnum);
    Function GetRelationshipST : TFhirHierarchicalRelationshipType;
    Procedure SetRelationshipST(value : TFhirHierarchicalRelationshipType);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSpecimenSource; overload;
    function Clone : TFhirSpecimenSource; overload;
    {!script show}
  published
    {@member relationship
      Whether this relationship is to a parent or to a child.
    }
    property relationship : TFhirEnum read FRelationship write SetRelationship;
    {@member relationshipST
      Typed access to Whether this relationship is to a parent or to a child.
    }
    property relationshipST : TFhirHierarchicalRelationshipType read GetRelationshipST write SetRelationshipST;

    {@member targetList
      The specimen resource that is the target of this relationship.
    }
    property targetList : TFhirResourceReferenceList{TFhirSpecimen} read FTargetList;

  end;


  {@Class TFhirSpecimenSourceList
    A list of FhirSpecimenSource
  }
  {!.Net HL7Connect.Fhir.SpecimenSourceList}
  TFhirSpecimenSourceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSpecimenSource;
    procedure SetItemN(index : Integer; value : TFhirSpecimenSource);
  public
    {!script hide}
    function Link : TFhirSpecimenSourceList; Overload;
    function Clone : TFhirSpecimenSourceList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirSpecimenSource to the end of the list.
    }
    function Append : TFhirSpecimenSource;

    
    {@member AddItem
      Add an already existing FhirSpecimenSource to the end of the list.
    }
    procedure AddItem(value : TFhirSpecimenSource);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSpecimenSource) : Integer;
    

    {@member Insert
      Insert FhirSpecimenSource before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSpecimenSource;
    

    {@member InsertItem
       Insert an existing FhirSpecimenSource before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSpecimenSource);
    
    {@member Item
       Get the iIndexth FhirSpecimenSource. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSpecimenSource. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenSource);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSpecimenSource;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSpecimenSources[index : Integer] : TFhirSpecimenSource read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSpecimenCollection : TFhirElement
    Details concerning the specimen collection.
  }
  {!.Net HL7Connect.Fhir.SpecimenCollection}
  TFhirSpecimenCollection = class (TFhirBackboneElement)
  private
    FCollector : TFhirResourceReference{TFhirPractitioner};
    FcommentList : TFhirStringList;
    FCollected : TFhirType;
    FQuantity : TFhirQuantity;
    FMethod : TFhirCodeableConcept;
    FSourceSite : TFhirCodeableConcept;
    Procedure SetCollector(value : TFhirResourceReference{TFhirPractitioner});
    Procedure SetCollected(value : TFhirType);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetSourceSite(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSpecimenCollection; overload;
    function Clone : TFhirSpecimenCollection; overload;
    {!script show}
  published
    {@member collector
      Person who collected the specimen.
    }
    property collector : TFhirResourceReference{TFhirPractitioner} read FCollector write SetCollector;

    {@member commentList
      To communicate any details or issues encountered during the specimen collection procedure.
    }
    property commentList : TFhirStringList read FCommentList;

    {@member collected
      Time when specimen was collected from subject - the physiologically relevant time.
    }
    property collected : TFhirType read FCollected write SetCollected;

    {@member quantity
      The quantity of specimen collected; for instance the volume of a blood sample, or the physical measurement of an anatomic pathology sample.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;

    {@member method
      A coded value specifying the technique that is used to perform the procedure.
    }
    property method : TFhirCodeableConcept read FMethod write SetMethod;

    {@member sourceSite
      Anatomical location from which the specimen should be collected (if subject is a patient). This element is not used for environmental specimens.
    }
    property sourceSite : TFhirCodeableConcept read FSourceSite write SetSourceSite;

  end;


  {@Class TFhirSpecimenCollectionList
    A list of FhirSpecimenCollection
  }
  {!.Net HL7Connect.Fhir.SpecimenCollectionList}
  TFhirSpecimenCollectionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSpecimenCollection;
    procedure SetItemN(index : Integer; value : TFhirSpecimenCollection);
  public
    {!script hide}
    function Link : TFhirSpecimenCollectionList; Overload;
    function Clone : TFhirSpecimenCollectionList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirSpecimenCollection to the end of the list.
    }
    function Append : TFhirSpecimenCollection;

    
    {@member AddItem
      Add an already existing FhirSpecimenCollection to the end of the list.
    }
    procedure AddItem(value : TFhirSpecimenCollection);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSpecimenCollection) : Integer;
    

    {@member Insert
      Insert FhirSpecimenCollection before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSpecimenCollection;
    

    {@member InsertItem
       Insert an existing FhirSpecimenCollection before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSpecimenCollection);
    
    {@member Item
       Get the iIndexth FhirSpecimenCollection. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSpecimenCollection. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenCollection);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSpecimenCollection;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSpecimenCollections[index : Integer] : TFhirSpecimenCollection read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSpecimenTreatment : TFhirElement
    Details concerning treatment and processing steps for the specimen.
  }
  {!.Net HL7Connect.Fhir.SpecimenTreatment}
  TFhirSpecimenTreatment = class (TFhirBackboneElement)
  private
    FDescription : TFhirString;
    FProcedure_ : TFhirCodeableConcept;
    FadditiveList : TFhirResourceReferenceList{TFhirSubstance};
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetProcedure_(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSpecimenTreatment; overload;
    function Clone : TFhirSpecimenTreatment; overload;
    {!script show}
  published
    {@member description
      Textual description of procedure.
    }
    property description : TFhirString read FDescription write SetDescription;
    {@member descriptionST
      Typed access to Textual description of procedure.
    }
    property descriptionST : String read GetDescriptionST write SetDescriptionST;

    {@member procedure_
      A coded value specifying the procedure used to process the specimen.
    }
    property procedure_ : TFhirCodeableConcept read FProcedure_ write SetProcedure_;

    {@member additiveList
      Material used in the processing step.
    }
    property additiveList : TFhirResourceReferenceList{TFhirSubstance} read FAdditiveList;

  end;


  {@Class TFhirSpecimenTreatmentList
    A list of FhirSpecimenTreatment
  }
  {!.Net HL7Connect.Fhir.SpecimenTreatmentList}
  TFhirSpecimenTreatmentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSpecimenTreatment;
    procedure SetItemN(index : Integer; value : TFhirSpecimenTreatment);
  public
    {!script hide}
    function Link : TFhirSpecimenTreatmentList; Overload;
    function Clone : TFhirSpecimenTreatmentList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirSpecimenTreatment to the end of the list.
    }
    function Append : TFhirSpecimenTreatment;

    
    {@member AddItem
      Add an already existing FhirSpecimenTreatment to the end of the list.
    }
    procedure AddItem(value : TFhirSpecimenTreatment);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSpecimenTreatment) : Integer;
    

    {@member Insert
      Insert FhirSpecimenTreatment before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSpecimenTreatment;
    

    {@member InsertItem
       Insert an existing FhirSpecimenTreatment before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSpecimenTreatment);
    
    {@member Item
       Get the iIndexth FhirSpecimenTreatment. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSpecimenTreatment. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenTreatment);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSpecimenTreatment;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSpecimenTreatments[index : Integer] : TFhirSpecimenTreatment read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSpecimenContainer : TFhirElement
    The container holding the specimen.  The recursive nature of containers; i.e. blood in tube in tray in rack is not addressed here.
  }
  {!.Net HL7Connect.Fhir.SpecimenContainer}
  TFhirSpecimenContainer = class (TFhirBackboneElement)
  private
    FidentifierList : TFhirIdentifierList;
    FDescription : TFhirString;
    FType_ : TFhirCodeableConcept;
    FCapacity : TFhirQuantity;
    FSpecimenQuantity : TFhirQuantity;
    FAdditive : TFhirResourceReference{TFhirSubstance};
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetCapacity(value : TFhirQuantity);
    Procedure SetSpecimenQuantity(value : TFhirQuantity);
    Procedure SetAdditive(value : TFhirResourceReference{TFhirSubstance});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSpecimenContainer; overload;
    function Clone : TFhirSpecimenContainer; overload;
    {!script show}
  published
    {@member identifierList
      Id for container. There may be multiple; a manufacturer's bar code, lab assigned identifier, etc. The container ID may differ from the specimen id in some circumstances.
    }
    property identifierList : TFhirIdentifierList read FIdentifierList;

    {@member description
      Textual description of the container.
    }
    property description : TFhirString read FDescription write SetDescription;
    {@member descriptionST
      Typed access to Textual description of the container.
    }
    property descriptionST : String read GetDescriptionST write SetDescriptionST;

    {@member type_
      The type of container associated with the specimen (e.g. slide, aliquot, etc).
    }
    property type_ : TFhirCodeableConcept read FType_ write SetType_;

    {@member capacity
      The capacity (volume or other measure) the container may contain.
    }
    property capacity : TFhirQuantity read FCapacity write SetCapacity;

    {@member specimenQuantity
      The quantity of specimen in the container; may be volume, dimensions, or other appropriate measurements, depending on the specimen type.
    }
    property specimenQuantity : TFhirQuantity read FSpecimenQuantity write SetSpecimenQuantity;

    {@member additive
      Additive associated with the container.
    }
    property additive : TFhirResourceReference{TFhirSubstance} read FAdditive write SetAdditive;

  end;


  {@Class TFhirSpecimenContainerList
    A list of FhirSpecimenContainer
  }
  {!.Net HL7Connect.Fhir.SpecimenContainerList}
  TFhirSpecimenContainerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSpecimenContainer;
    procedure SetItemN(index : Integer; value : TFhirSpecimenContainer);
  public
    {!script hide}
    function Link : TFhirSpecimenContainerList; Overload;
    function Clone : TFhirSpecimenContainerList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirSpecimenContainer to the end of the list.
    }
    function Append : TFhirSpecimenContainer;

    
    {@member AddItem
      Add an already existing FhirSpecimenContainer to the end of the list.
    }
    procedure AddItem(value : TFhirSpecimenContainer);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSpecimenContainer) : Integer;
    

    {@member Insert
      Insert FhirSpecimenContainer before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSpecimenContainer;
    

    {@member InsertItem
       Insert an existing FhirSpecimenContainer before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSpecimenContainer);
    
    {@member Item
       Get the iIndexth FhirSpecimenContainer. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSpecimenContainer. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenContainer);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSpecimenContainer;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSpecimenContainers[index : Integer] : TFhirSpecimenContainer read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSubstanceInstance : TFhirElement
    Substance may be used to describe a kind of substance, or a specific package/container of the substance: an instance.
  }
  {!.Net HL7Connect.Fhir.SubstanceInstance}
  TFhirSubstanceInstance = class (TFhirBackboneElement)
  private
    FIdentifier : TFhirIdentifier;
    FExpiry : TFhirDateTime;
    FQuantity : TFhirQuantity;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetExpiry(value : TFhirDateTime);
    Function GetExpiryST : TDateAndTime;
    Procedure SetExpiryST(value : TDateAndTime);
    Procedure SetQuantity(value : TFhirQuantity);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSubstanceInstance; overload;
    function Clone : TFhirSubstanceInstance; overload;
    {!script show}
  published
    {@member identifier
      Identifier associated with the package/container (usually a label affixed directly).
    }
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;

    {@member expiry
      When the substance is no longer valid to use. For some substances, a single arbitrary date is used for expiry.
    }
    property expiry : TFhirDateTime read FExpiry write SetExpiry;
    {@member expiryST
      Typed access to When the substance is no longer valid to use. For some substances, a single arbitrary date is used for expiry.
    }
    property expiryST : TDateAndTime read GetExpiryST write SetExpiryST;

    {@member quantity
      The amount of the substance.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;

  end;


  {@Class TFhirSubstanceInstanceList
    A list of FhirSubstanceInstance
  }
  {!.Net HL7Connect.Fhir.SubstanceInstanceList}
  TFhirSubstanceInstanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceInstance;
    procedure SetItemN(index : Integer; value : TFhirSubstanceInstance);
  public
    {!script hide}
    function Link : TFhirSubstanceInstanceList; Overload;
    function Clone : TFhirSubstanceInstanceList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirSubstanceInstance to the end of the list.
    }
    function Append : TFhirSubstanceInstance;

    
    {@member AddItem
      Add an already existing FhirSubstanceInstance to the end of the list.
    }
    procedure AddItem(value : TFhirSubstanceInstance);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSubstanceInstance) : Integer;
    

    {@member Insert
      Insert FhirSubstanceInstance before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSubstanceInstance;
    

    {@member InsertItem
       Insert an existing FhirSubstanceInstance before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSubstanceInstance);
    
    {@member Item
       Get the iIndexth FhirSubstanceInstance. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSubstanceInstance. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceInstance);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSubstanceInstance;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSubstanceInstances[index : Integer] : TFhirSubstanceInstance read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSubstanceIngredient : TFhirElement
    A substance can be composed of other substances.
  }
  {!.Net HL7Connect.Fhir.SubstanceIngredient}
  TFhirSubstanceIngredient = class (TFhirBackboneElement)
  private
    FQuantity : TFhirRatio;
    FSubstance : TFhirResourceReference{TFhirSubstance};
    Procedure SetQuantity(value : TFhirRatio);
    Procedure SetSubstance(value : TFhirResourceReference{TFhirSubstance});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSubstanceIngredient; overload;
    function Clone : TFhirSubstanceIngredient; overload;
    {!script show}
  published
    {@member quantity
      The amount of the ingredient in the substance - a concentration ratio.
    }
    property quantity : TFhirRatio read FQuantity write SetQuantity;

    {@member substance
      Another substance that is a component of this substance.
    }
    property substance : TFhirResourceReference{TFhirSubstance} read FSubstance write SetSubstance;

  end;


  {@Class TFhirSubstanceIngredientList
    A list of FhirSubstanceIngredient
  }
  {!.Net HL7Connect.Fhir.SubstanceIngredientList}
  TFhirSubstanceIngredientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceIngredient;
    procedure SetItemN(index : Integer; value : TFhirSubstanceIngredient);
  public
    {!script hide}
    function Link : TFhirSubstanceIngredientList; Overload;
    function Clone : TFhirSubstanceIngredientList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirSubstanceIngredient to the end of the list.
    }
    function Append : TFhirSubstanceIngredient;

    
    {@member AddItem
      Add an already existing FhirSubstanceIngredient to the end of the list.
    }
    procedure AddItem(value : TFhirSubstanceIngredient);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSubstanceIngredient) : Integer;
    

    {@member Insert
      Insert FhirSubstanceIngredient before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSubstanceIngredient;
    

    {@member InsertItem
       Insert an existing FhirSubstanceIngredient before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSubstanceIngredient);
    
    {@member Item
       Get the iIndexth FhirSubstanceIngredient. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSubstanceIngredient. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceIngredient);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSubstanceIngredient;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSubstanceIngredients[index : Integer] : TFhirSubstanceIngredient read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSupplyDispense : TFhirElement
    Indicates the details of the dispense event such as the days supply and quantity of a supply dispensed.
  }
  {!.Net HL7Connect.Fhir.SupplyDispense}
  TFhirSupplyDispense = class (TFhirBackboneElement)
  private
    FIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FSuppliedItem : TFhirResourceReference{Resource};
    FSupplier : TFhirResourceReference{TFhirPractitioner};
    FWhenPrepared : TFhirPeriod;
    FWhenHandedOver : TFhirPeriod;
    FDestination : TFhirResourceReference{TFhirLocation};
    FreceiverList : TFhirResourceReferenceList{TFhirPractitioner};
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirValuesetSupplyDispenseStatus;
    Procedure SetStatusST(value : TFhirValuesetSupplyDispenseStatus);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetSuppliedItem(value : TFhirResourceReference{Resource});
    Procedure SetSupplier(value : TFhirResourceReference{TFhirPractitioner});
    Procedure SetWhenPrepared(value : TFhirPeriod);
    Procedure SetWhenHandedOver(value : TFhirPeriod);
    Procedure SetDestination(value : TFhirResourceReference{TFhirLocation});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSupplyDispense; overload;
    function Clone : TFhirSupplyDispense; overload;
    {!script show}
  published
    {@member identifier
      Identifier assigned by the dispensing facility when the dispense occurs.
    }
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;

    {@member status
      A code specifying the state of the dispense event.
    }
    property status : TFhirEnum read FStatus write SetStatus;
    {@member statusST
      Typed access to A code specifying the state of the dispense event.
    }
    property statusST : TFhirValuesetSupplyDispenseStatus read GetStatusST write SetStatusST;

    {@member type_
      Indicates the type of dispensing event that is performed. Examples include: Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc.
    }
    property type_ : TFhirCodeableConcept read FType_ write SetType_;

    {@member quantity
      The amount of supply that has been dispensed. Includes unit of measure.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;

    {@member suppliedItem
      Identifies the medication or substance being dispensed. This is either a link to a resource representing the details of the medication or substance or a simple attribute carrying a code that identifies the medication from a known list of medications.
    }
    property suppliedItem : TFhirResourceReference{Resource} read FSuppliedItem write SetSuppliedItem;

    {@member supplier
      The individual responsible for dispensing the medication.
    }
    property supplier : TFhirResourceReference{TFhirPractitioner} read FSupplier write SetSupplier;

    {@member whenPrepared
      The time the dispense event occurred.
    }
    property whenPrepared : TFhirPeriod read FWhenPrepared write SetWhenPrepared;

    {@member whenHandedOver
      The time the dispensed item was sent or handed to the patient (or agent).
    }
    property whenHandedOver : TFhirPeriod read FWhenHandedOver write SetWhenHandedOver;

    {@member destination
      Identification of the facility/location where the Supply was shipped to, as part of the dispense event.
    }
    property destination : TFhirResourceReference{TFhirLocation} read FDestination write SetDestination;

    {@member receiverList
      Identifies the person who picked up the Supply.
    }
    property receiverList : TFhirResourceReferenceList{TFhirPractitioner} read FReceiverList;

  end;


  {@Class TFhirSupplyDispenseList
    A list of FhirSupplyDispense
  }
  {!.Net HL7Connect.Fhir.SupplyDispenseList}
  TFhirSupplyDispenseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSupplyDispense;
    procedure SetItemN(index : Integer; value : TFhirSupplyDispense);
  public
    {!script hide}
    function Link : TFhirSupplyDispenseList; Overload;
    function Clone : TFhirSupplyDispenseList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirSupplyDispense to the end of the list.
    }
    function Append : TFhirSupplyDispense;

    
    {@member AddItem
      Add an already existing FhirSupplyDispense to the end of the list.
    }
    procedure AddItem(value : TFhirSupplyDispense);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSupplyDispense) : Integer;
    

    {@member Insert
      Insert FhirSupplyDispense before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSupplyDispense;
    

    {@member InsertItem
       Insert an existing FhirSupplyDispense before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSupplyDispense);
    
    {@member Item
       Get the iIndexth FhirSupplyDispense. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSupplyDispense. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSupplyDispense);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSupplyDispense;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSupplyDispenses[index : Integer] : TFhirSupplyDispense read GetItemN write SetItemN; default;
  End;


  {@Class TFhirValueSetDefine : TFhirElement
    When value set defines its own codes.
  }
  {!.Net HL7Connect.Fhir.ValueSetDefine}
  TFhirValueSetDefine = class (TFhirBackboneElement)
  private
    FSystem : TFhirUri;
    FVersion : TFhirString;
    FCaseSensitive : TFhirBoolean;
    FconceptList : TFhirValueSetDefineConceptList;
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetCaseSensitive(value : TFhirBoolean);
    Function GetCaseSensitiveST : Boolean;
    Procedure SetCaseSensitiveST(value : Boolean);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirValueSetDefine; overload;
    function Clone : TFhirValueSetDefine; overload;
    {!script show}
  published
    {@member system
      URI to identify the code system.
    }
    property system : TFhirUri read FSystem write SetSystem;
    {@member systemST
      Typed access to URI to identify the code system.
    }
    property systemST : String read GetSystemST write SetSystemST;

    {@member version
      The version of this code system that defines the codes. Note that the version is optional because a well maintained code system does not suffer from versioning, and therefore the version does not need to be maintained. However many code systems are not well maintained, and the version needs to be defined and tracked.
    }
    property version : TFhirString read FVersion write SetVersion;
    {@member versionST
      Typed access to The version of this code system that defines the codes. Note that the version is optional because a well maintained code system does not suffer from versioning, and therefore the version does not need to be maintained. However many code systems are not well maintained, and the version needs to be defined and tracked.
    }
    property versionST : String read GetVersionST write SetVersionST;

    {@member caseSensitive
      If code comparison is case sensitive when codes within this system are compared to each other.
    }
    property caseSensitive : TFhirBoolean read FCaseSensitive write SetCaseSensitive;
    {@member caseSensitiveST
      Typed access to If code comparison is case sensitive when codes within this system are compared to each other.
    }
    property caseSensitiveST : Boolean read GetCaseSensitiveST write SetCaseSensitiveST;

    {@member conceptList
      Concepts in the code system.
    }
    property conceptList : TFhirValueSetDefineConceptList read FConceptList;

  end;


  {@Class TFhirValueSetDefineList
    A list of FhirValueSetDefine
  }
  {!.Net HL7Connect.Fhir.ValueSetDefineList}
  TFhirValueSetDefineList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetDefine;
    procedure SetItemN(index : Integer; value : TFhirValueSetDefine);
  public
    {!script hide}
    function Link : TFhirValueSetDefineList; Overload;
    function Clone : TFhirValueSetDefineList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirValueSetDefine to the end of the list.
    }
    function Append : TFhirValueSetDefine;

    
    {@member AddItem
      Add an already existing FhirValueSetDefine to the end of the list.
    }
    procedure AddItem(value : TFhirValueSetDefine);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirValueSetDefine) : Integer;
    

    {@member Insert
      Insert FhirValueSetDefine before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirValueSetDefine;
    

    {@member InsertItem
       Insert an existing FhirValueSetDefine before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirValueSetDefine);
    
    {@member Item
       Get the iIndexth FhirValueSetDefine. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirValueSetDefine. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetDefine);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirValueSetDefine;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirValueSetDefines[index : Integer] : TFhirValueSetDefine read GetItemN write SetItemN; default;
  End;


  {@Class TFhirValueSetDefineConcept : TFhirElement
    Concepts in the code system.
  }
  {!.Net HL7Connect.Fhir.ValueSetDefineConcept}
  TFhirValueSetDefineConcept = class (TFhirBackboneElement)
  private
    FCode : TFhirCode;
    FAbstract : TFhirBoolean;
    FDisplay : TFhirString;
    FDefinition : TFhirString;
    FconceptList : TFhirValueSetDefineConceptList;
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetAbstract(value : TFhirBoolean);
    Function GetAbstractST : Boolean;
    Procedure SetAbstractST(value : Boolean);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
    Procedure SetDefinition(value : TFhirString);
    Function GetDefinitionST : String;
    Procedure SetDefinitionST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirValueSetDefineConcept; overload;
    function Clone : TFhirValueSetDefineConcept; overload;
    {!script show}
  published
    {@member code
      Code that identifies concept.
    }
    property code : TFhirCode read FCode write SetCode;
    {@member codeST
      Typed access to Code that identifies concept.
    }
    property codeST : String read GetCodeST write SetCodeST;

    {@member abstract
      If this code is not for use as a real concept.
    }
    property abstract : TFhirBoolean read FAbstract write SetAbstract;
    {@member abstractST
      Typed access to If this code is not for use as a real concept.
    }
    property abstractST : Boolean read GetAbstractST write SetAbstractST;

    {@member display
      Text to Display to the user.
    }
    property display : TFhirString read FDisplay write SetDisplay;
    {@member displayST
      Typed access to Text to Display to the user.
    }
    property displayST : String read GetDisplayST write SetDisplayST;

    {@member definition
      The formal definition of the concept. Formal definitions are not required, because of the prevalence of legacy systems without them, but they are highly recommended, as without them there is no formal meaning associated with the concept.
    }
    property definition : TFhirString read FDefinition write SetDefinition;
    {@member definitionST
      Typed access to The formal definition of the concept. Formal definitions are not required, because of the prevalence of legacy systems without them, but they are highly recommended, as without them there is no formal meaning associated with the concept.
    }
    property definitionST : String read GetDefinitionST write SetDefinitionST;

    {@member conceptList
      Child Concepts (is-a / contains).
    }
    property conceptList : TFhirValueSetDefineConceptList read FConceptList;

  end;


  {@Class TFhirValueSetDefineConceptList
    A list of FhirValueSetDefineConcept
  }
  {!.Net HL7Connect.Fhir.ValueSetDefineConceptList}
  TFhirValueSetDefineConceptList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetDefineConcept;
    procedure SetItemN(index : Integer; value : TFhirValueSetDefineConcept);
  public
    {!script hide}
    function Link : TFhirValueSetDefineConceptList; Overload;
    function Clone : TFhirValueSetDefineConceptList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirValueSetDefineConcept to the end of the list.
    }
    function Append : TFhirValueSetDefineConcept;

    
    {@member AddItem
      Add an already existing FhirValueSetDefineConcept to the end of the list.
    }
    procedure AddItem(value : TFhirValueSetDefineConcept);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirValueSetDefineConcept) : Integer;
    

    {@member Insert
      Insert FhirValueSetDefineConcept before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirValueSetDefineConcept;
    

    {@member InsertItem
       Insert an existing FhirValueSetDefineConcept before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirValueSetDefineConcept);
    
    {@member Item
       Get the iIndexth FhirValueSetDefineConcept. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirValueSetDefineConcept. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetDefineConcept);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirValueSetDefineConcept;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirValueSetDefineConcepts[index : Integer] : TFhirValueSetDefineConcept read GetItemN write SetItemN; default;
  End;


  {@Class TFhirValueSetCompose : TFhirElement
    When value set includes codes from elsewhere.
  }
  {!.Net HL7Connect.Fhir.ValueSetCompose}
  TFhirValueSetCompose = class (TFhirBackboneElement)
  private
    FimportList : TFhirUriList;
    FincludeList : TFhirValueSetComposeIncludeList;
    FexcludeList : TFhirValueSetComposeIncludeList;
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirValueSetCompose; overload;
    function Clone : TFhirValueSetCompose; overload;
    {!script show}
  published
    {@member importList
      Includes the contents of the referenced value set as a part of the contents of this value set.
    }
    property importList : TFhirUriList read FImportList;

    {@member includeList
      Include one or more codes from a code system.
    }
    property includeList : TFhirValueSetComposeIncludeList read FIncludeList;

    {@member excludeList
      Exclude one or more codes from the value set.
    }
    property excludeList : TFhirValueSetComposeIncludeList read FExcludeList;

  end;


  {@Class TFhirValueSetComposeList
    A list of FhirValueSetCompose
  }
  {!.Net HL7Connect.Fhir.ValueSetComposeList}
  TFhirValueSetComposeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetCompose;
    procedure SetItemN(index : Integer; value : TFhirValueSetCompose);
  public
    {!script hide}
    function Link : TFhirValueSetComposeList; Overload;
    function Clone : TFhirValueSetComposeList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirValueSetCompose to the end of the list.
    }
    function Append : TFhirValueSetCompose;

    
    {@member AddItem
      Add an already existing FhirValueSetCompose to the end of the list.
    }
    procedure AddItem(value : TFhirValueSetCompose);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirValueSetCompose) : Integer;
    

    {@member Insert
      Insert FhirValueSetCompose before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirValueSetCompose;
    

    {@member InsertItem
       Insert an existing FhirValueSetCompose before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirValueSetCompose);
    
    {@member Item
       Get the iIndexth FhirValueSetCompose. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirValueSetCompose. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetCompose);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirValueSetCompose;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirValueSetComposes[index : Integer] : TFhirValueSetCompose read GetItemN write SetItemN; default;
  End;


  {@Class TFhirValueSetComposeInclude : TFhirElement
    Include one or more codes from a code system.
  }
  {!.Net HL7Connect.Fhir.ValueSetComposeInclude}
  TFhirValueSetComposeInclude = class (TFhirBackboneElement)
  private
    FSystem : TFhirUri;
    FVersion : TFhirString;
    FcodeList : TFhirCodeList;
    FfilterList : TFhirValueSetComposeIncludeFilterList;
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirValueSetComposeInclude; overload;
    function Clone : TFhirValueSetComposeInclude; overload;
    {!script show}
  published
    {@member system
      The code system from which the selected codes come from.
    }
    property system : TFhirUri read FSystem write SetSystem;
    {@member systemST
      Typed access to The code system from which the selected codes come from.
    }
    property systemST : String read GetSystemST write SetSystemST;

    {@member version
      The version of the code system that the codes are selected from.
    }
    property version : TFhirString read FVersion write SetVersion;
    {@member versionST
      Typed access to The version of the code system that the codes are selected from.
    }
    property versionST : String read GetVersionST write SetVersionST;

    {@member codeList
      Specifies a code or concept to be included or excluded. The list of codes is considered ordered, though the order may not have any particular significance.
    }
    property codeList : TFhirCodeList read FCodeList;

    {@member filterList
      Select concepts by specify a matching criteria based on the properties (including relationships) defined by the system. If multiple filters are specified, they SHALL all be true.
    }
    property filterList : TFhirValueSetComposeIncludeFilterList read FFilterList;

  end;


  {@Class TFhirValueSetComposeIncludeList
    A list of FhirValueSetComposeInclude
  }
  {!.Net HL7Connect.Fhir.ValueSetComposeIncludeList}
  TFhirValueSetComposeIncludeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetComposeInclude;
    procedure SetItemN(index : Integer; value : TFhirValueSetComposeInclude);
  public
    {!script hide}
    function Link : TFhirValueSetComposeIncludeList; Overload;
    function Clone : TFhirValueSetComposeIncludeList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirValueSetComposeInclude to the end of the list.
    }
    function Append : TFhirValueSetComposeInclude;

    
    {@member AddItem
      Add an already existing FhirValueSetComposeInclude to the end of the list.
    }
    procedure AddItem(value : TFhirValueSetComposeInclude);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirValueSetComposeInclude) : Integer;
    

    {@member Insert
      Insert FhirValueSetComposeInclude before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirValueSetComposeInclude;
    

    {@member InsertItem
       Insert an existing FhirValueSetComposeInclude before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirValueSetComposeInclude);
    
    {@member Item
       Get the iIndexth FhirValueSetComposeInclude. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirValueSetComposeInclude. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetComposeInclude);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirValueSetComposeInclude;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirValueSetComposeIncludes[index : Integer] : TFhirValueSetComposeInclude read GetItemN write SetItemN; default;
  End;


  {@Class TFhirValueSetComposeIncludeFilter : TFhirElement
    Select concepts by specify a matching criteria based on the properties (including relationships) defined by the system. If multiple filters are specified, they SHALL all be true.
  }
  {!.Net HL7Connect.Fhir.ValueSetComposeIncludeFilter}
  TFhirValueSetComposeIncludeFilter = class (TFhirBackboneElement)
  private
    FProperty_ : TFhirCode;
    FOp : TFhirEnum;
    FValue : TFhirCode;
    Procedure SetProperty_(value : TFhirCode);
    Function GetProperty_ST : String;
    Procedure SetProperty_ST(value : String);
    Procedure SetOp(value : TFhirEnum);
    Function GetOpST : TFhirFilterOperator;
    Procedure SetOpST(value : TFhirFilterOperator);
    Procedure SetValue(value : TFhirCode);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirValueSetComposeIncludeFilter; overload;
    function Clone : TFhirValueSetComposeIncludeFilter; overload;
    {!script show}
  published
    {@member property_
      A code that identifies a property defined in the code system.
    }
    property property_ : TFhirCode read FProperty_ write SetProperty_;
    {@member property_ST
      Typed access to A code that identifies a property defined in the code system.
    }
    property property_ST : String read GetProperty_ST write SetProperty_ST;

    {@member op
      The kind of operation to perform as a part of the filter criteria.
    }
    property op : TFhirEnum read FOp write SetOp;
    {@member opST
      Typed access to The kind of operation to perform as a part of the filter criteria.
    }
    property opST : TFhirFilterOperator read GetOpST write SetOpST;

    {@member value
      The match value may be either a code defined by the system, or a string value which is used a regex match on the literal string of the property value.
    }
    property value : TFhirCode read FValue write SetValue;
    {@member valueST
      Typed access to The match value may be either a code defined by the system, or a string value which is used a regex match on the literal string of the property value.
    }
    property valueST : String read GetValueST write SetValueST;

  end;


  {@Class TFhirValueSetComposeIncludeFilterList
    A list of FhirValueSetComposeIncludeFilter
  }
  {!.Net HL7Connect.Fhir.ValueSetComposeIncludeFilterList}
  TFhirValueSetComposeIncludeFilterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetComposeIncludeFilter;
    procedure SetItemN(index : Integer; value : TFhirValueSetComposeIncludeFilter);
  public
    {!script hide}
    function Link : TFhirValueSetComposeIncludeFilterList; Overload;
    function Clone : TFhirValueSetComposeIncludeFilterList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirValueSetComposeIncludeFilter to the end of the list.
    }
    function Append : TFhirValueSetComposeIncludeFilter;

    
    {@member AddItem
      Add an already existing FhirValueSetComposeIncludeFilter to the end of the list.
    }
    procedure AddItem(value : TFhirValueSetComposeIncludeFilter);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirValueSetComposeIncludeFilter) : Integer;
    

    {@member Insert
      Insert FhirValueSetComposeIncludeFilter before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirValueSetComposeIncludeFilter;
    

    {@member InsertItem
       Insert an existing FhirValueSetComposeIncludeFilter before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirValueSetComposeIncludeFilter);
    
    {@member Item
       Get the iIndexth FhirValueSetComposeIncludeFilter. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirValueSetComposeIncludeFilter. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetComposeIncludeFilter);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirValueSetComposeIncludeFilter;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirValueSetComposeIncludeFilters[index : Integer] : TFhirValueSetComposeIncludeFilter read GetItemN write SetItemN; default;
  End;


  {@Class TFhirValueSetExpansion : TFhirElement
    When value set is an expansion.
  }
  {!.Net HL7Connect.Fhir.ValueSetExpansion}
  TFhirValueSetExpansion = class (TFhirBackboneElement)
  private
    FIdentifier : TFhirIdentifier;
    FTimestamp : TFhirInstant;
    FcontainsList : TFhirValueSetExpansionContainsList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetTimestamp(value : TFhirInstant);
    Function GetTimestampST : TDateAndTime;
    Procedure SetTimestampST(value : TDateAndTime);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirValueSetExpansion; overload;
    function Clone : TFhirValueSetExpansion; overload;
    {!script show}
  published
    {@member identifier
      An identifier that uniquely identifies this expansion of the valueset. Systems may re-use the same identifier as long as the expansion and the definition remain the same, but are not required to do so.
    }
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;

    {@member timestamp
      Time valueset expansion happened.
    }
    property timestamp : TFhirInstant read FTimestamp write SetTimestamp;
    {@member timestampST
      Typed access to Time valueset expansion happened.
    }
    property timestampST : TDateAndTime read GetTimestampST write SetTimestampST;

    {@member containsList
      Codes in the value set.
    }
    property containsList : TFhirValueSetExpansionContainsList read FContainsList;

  end;


  {@Class TFhirValueSetExpansionList
    A list of FhirValueSetExpansion
  }
  {!.Net HL7Connect.Fhir.ValueSetExpansionList}
  TFhirValueSetExpansionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetExpansion;
    procedure SetItemN(index : Integer; value : TFhirValueSetExpansion);
  public
    {!script hide}
    function Link : TFhirValueSetExpansionList; Overload;
    function Clone : TFhirValueSetExpansionList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirValueSetExpansion to the end of the list.
    }
    function Append : TFhirValueSetExpansion;

    
    {@member AddItem
      Add an already existing FhirValueSetExpansion to the end of the list.
    }
    procedure AddItem(value : TFhirValueSetExpansion);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirValueSetExpansion) : Integer;
    

    {@member Insert
      Insert FhirValueSetExpansion before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirValueSetExpansion;
    

    {@member InsertItem
       Insert an existing FhirValueSetExpansion before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirValueSetExpansion);
    
    {@member Item
       Get the iIndexth FhirValueSetExpansion. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirValueSetExpansion. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetExpansion);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirValueSetExpansion;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirValueSetExpansions[index : Integer] : TFhirValueSetExpansion read GetItemN write SetItemN; default;
  End;


  {@Class TFhirValueSetExpansionContains : TFhirElement
    Codes in the value set.
  }
  {!.Net HL7Connect.Fhir.ValueSetExpansionContains}
  TFhirValueSetExpansionContains = class (TFhirBackboneElement)
  private
    FSystem : TFhirUri;
    FCode : TFhirCode;
    FDisplay : TFhirString;
    FcontainsList : TFhirValueSetExpansionContainsList;
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirValueSetExpansionContains; overload;
    function Clone : TFhirValueSetExpansionContains; overload;
    {!script show}
  published
    {@member system
      System value for the code.
    }
    property system : TFhirUri read FSystem write SetSystem;
    {@member systemST
      Typed access to System value for the code.
    }
    property systemST : String read GetSystemST write SetSystemST;

    {@member code
      Code - if blank, this is not a choosable code.
    }
    property code : TFhirCode read FCode write SetCode;
    {@member codeST
      Typed access to Code - if blank, this is not a choosable code.
    }
    property codeST : String read GetCodeST write SetCodeST;

    {@member display
      User display for the concept.
    }
    property display : TFhirString read FDisplay write SetDisplay;
    {@member displayST
      Typed access to User display for the concept.
    }
    property displayST : String read GetDisplayST write SetDisplayST;

    {@member containsList
      Codes contained in this concept.
    }
    property containsList : TFhirValueSetExpansionContainsList read FContainsList;

  end;


  {@Class TFhirValueSetExpansionContainsList
    A list of FhirValueSetExpansionContains
  }
  {!.Net HL7Connect.Fhir.ValueSetExpansionContainsList}
  TFhirValueSetExpansionContainsList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetExpansionContains;
    procedure SetItemN(index : Integer; value : TFhirValueSetExpansionContains);
  public
    {!script hide}
    function Link : TFhirValueSetExpansionContainsList; Overload;
    function Clone : TFhirValueSetExpansionContainsList; Overload;
    {!script show}
    

    {@member Append
      Add a FhirValueSetExpansionContains to the end of the list.
    }
    function Append : TFhirValueSetExpansionContains;

    
    {@member AddItem
      Add an already existing FhirValueSetExpansionContains to the end of the list.
    }
    procedure AddItem(value : TFhirValueSetExpansionContains);
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirValueSetExpansionContains) : Integer;
    

    {@member Insert
      Insert FhirValueSetExpansionContains before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirValueSetExpansionContains;
    

    {@member InsertItem
       Insert an existing FhirValueSetExpansionContains before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirValueSetExpansionContains);
    
    {@member Item
       Get the iIndexth FhirValueSetExpansionContains. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirValueSetExpansionContains. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetExpansionContains);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirValueSetExpansionContains;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirValueSetExpansionContains[index : Integer] : TFhirValueSetExpansionContains read GetItemN write SetItemN; default;
  End;


implementation

{ TFhirAdverseReactionSymptom }

constructor TFhirAdverseReactionSymptom.Create;
begin
  inherited;
end;

destructor TFhirAdverseReactionSymptom.Destroy;
begin
  FCode.free;
  FSeverity.free;
  inherited;
end;

procedure TFhirAdverseReactionSymptom.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirAdverseReactionSymptom(oSource).code.Clone;
  FSeverity := TFhirAdverseReactionSymptom(oSource).FSeverity.Link;
end;

procedure TFhirAdverseReactionSymptom.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'severity') Then
     list.add(FSeverity.Link);
end;

procedure TFhirAdverseReactionSymptom.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'severity', 'code', FSeverity.Link));{1}
end;

function TFhirAdverseReactionSymptom.Link : TFhirAdverseReactionSymptom;
begin
  result := TFhirAdverseReactionSymptom(inherited Link);
end;

function TFhirAdverseReactionSymptom.Clone : TFhirAdverseReactionSymptom;
begin
  result := TFhirAdverseReactionSymptom(inherited Clone);
end;

{ TFhirAdverseReactionSymptom }

Procedure TFhirAdverseReactionSymptom.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirAdverseReactionSymptom.SetSeverity(value : TFhirEnum);
begin
  FSeverity.free;
  FSeverity := value;
end;

Function TFhirAdverseReactionSymptom.GetSeverityST : TFhirReactionSeverity;
begin
  if FSeverity = nil then
    result := TFhirReactionSeverity(0)
  else
    result := TFhirReactionSeverity(StringArrayIndexOf(CODES_TFhirReactionSeverity, Severity.value));
end;

Procedure TFhirAdverseReactionSymptom.SetSeverityST(value : TFhirReactionSeverity);
begin
  if ord(value) = 0 then
    Severity := nil
  else
    Severity := TFhirEnum.create(CODES_TFhirReactionSeverity[value]);
end;


{ TFhirAdverseReactionSymptomList }
procedure TFhirAdverseReactionSymptomList.AddItem(value: TFhirAdverseReactionSymptom);
begin
  assert(value.ClassName = 'TFhirAdverseReactionSymptom', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdverseReactionSymptom');
  add(value);
end;


function TFhirAdverseReactionSymptomList.Append: TFhirAdverseReactionSymptom;
begin
  result := TFhirAdverseReactionSymptom.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirAdverseReactionSymptomList.ClearItems;
begin
  Clear;
end;

function TFhirAdverseReactionSymptomList.Clone: TFhirAdverseReactionSymptomList;
begin
  result := TFhirAdverseReactionSymptomList(inherited Clone);
end;

function TFhirAdverseReactionSymptomList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdverseReactionSymptomList.GetItemN(index: Integer): TFhirAdverseReactionSymptom;
begin
  result := TFhirAdverseReactionSymptom(ObjectByIndex[index]);
end;

function TFhirAdverseReactionSymptomList.IndexOf(value: TFhirAdverseReactionSymptom): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirAdverseReactionSymptomList.Insert(index: Integer): TFhirAdverseReactionSymptom;
begin
  result := TFhirAdverseReactionSymptom.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirAdverseReactionSymptomList.InsertItem(index: Integer; value: TFhirAdverseReactionSymptom);
begin
  assert(value is TFhirAdverseReactionSymptom);
  Inherited Insert(index, value);
end;

function TFhirAdverseReactionSymptomList.Item(index: Integer): TFhirAdverseReactionSymptom;
begin
  result := TFhirAdverseReactionSymptom(ObjectByIndex[index]);
end;

function TFhirAdverseReactionSymptomList.Link: TFhirAdverseReactionSymptomList;
begin
  result := TFhirAdverseReactionSymptomList(inherited Link);
end;

procedure TFhirAdverseReactionSymptomList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdverseReactionSymptomList.SetItemByIndex(index: Integer; value: TFhirAdverseReactionSymptom);
begin
  assert(value is TFhirAdverseReactionSymptom);
  FhirAdverseReactionSymptoms[index] := value;
end;

procedure TFhirAdverseReactionSymptomList.SetItemN(index: Integer; value: TFhirAdverseReactionSymptom);
begin
  assert(value is TFhirAdverseReactionSymptom);
  ObjectByIndex[index] := value;
end;

{ TFhirAdverseReactionExposure }

constructor TFhirAdverseReactionExposure.Create;
begin
  inherited;
end;

destructor TFhirAdverseReactionExposure.Destroy;
begin
  FDate.free;
  FType_.free;
  FCausalityExpectation.free;
  FSubstance.free;
  inherited;
end;

procedure TFhirAdverseReactionExposure.Assign(oSource : TAdvObject);
begin
  inherited;
  date := TFhirAdverseReactionExposure(oSource).date.Clone;
  FType_ := TFhirAdverseReactionExposure(oSource).FType_.Link;
  FCausalityExpectation := TFhirAdverseReactionExposure(oSource).FCausalityExpectation.Link;
  substance := TFhirAdverseReactionExposure(oSource).substance.Clone;
end;

procedure TFhirAdverseReactionExposure.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'date') Then
     list.add(Date.Link);
  if (child_name = 'type_') Then
     list.add(FType_.Link);
  if (child_name = 'causalityExpectation') Then
     list.add(FCausalityExpectation.Link);
  if (child_name = 'substance') Then
     list.add(Substance.Link);
end;

procedure TFhirAdverseReactionExposure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', FDate.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'causalityExpectation', 'code', FCausalityExpectation.Link));{1}
  oList.add(TFHIRProperty.create(self, 'substance', 'Resource(Substance)', FSubstance.Link.Link));{2}
end;

function TFhirAdverseReactionExposure.Link : TFhirAdverseReactionExposure;
begin
  result := TFhirAdverseReactionExposure(inherited Link);
end;

function TFhirAdverseReactionExposure.Clone : TFhirAdverseReactionExposure;
begin
  result := TFhirAdverseReactionExposure(inherited Clone);
end;

{ TFhirAdverseReactionExposure }

Procedure TFhirAdverseReactionExposure.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirAdverseReactionExposure.GetDateST : TDateAndTime;
begin
  if FDate = nil then
    result := nil
  else
    result := Date.value;
end;

Procedure TFhirAdverseReactionExposure.SetDateST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FDate = nil then
      FDate := TFhirDateTime.create;
    FDate.value := value
  end
  else if FDate <> nil then
    FDate.value := nil;
end;

Procedure TFhirAdverseReactionExposure.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirAdverseReactionExposure.GetType_ST : TFhirExposureType;
begin
  if FType_ = nil then
    result := TFhirExposureType(0)
  else
    result := TFhirExposureType(StringArrayIndexOf(CODES_TFhirExposureType, Type_.value));
end;

Procedure TFhirAdverseReactionExposure.SetType_ST(value : TFhirExposureType);
begin
  if ord(value) = 0 then
    Type_ := nil
  else
    Type_ := TFhirEnum.create(CODES_TFhirExposureType[value]);
end;

Procedure TFhirAdverseReactionExposure.SetCausalityExpectation(value : TFhirEnum);
begin
  FCausalityExpectation.free;
  FCausalityExpectation := value;
end;

Function TFhirAdverseReactionExposure.GetCausalityExpectationST : TFhirCausalityExpectation;
begin
  if FCausalityExpectation = nil then
    result := TFhirCausalityExpectation(0)
  else
    result := TFhirCausalityExpectation(StringArrayIndexOf(CODES_TFhirCausalityExpectation, CausalityExpectation.value));
end;

Procedure TFhirAdverseReactionExposure.SetCausalityExpectationST(value : TFhirCausalityExpectation);
begin
  if ord(value) = 0 then
    CausalityExpectation := nil
  else
    CausalityExpectation := TFhirEnum.create(CODES_TFhirCausalityExpectation[value]);
end;

Procedure TFhirAdverseReactionExposure.SetSubstance(value : TFhirResourceReference{TFhirSubstance});
begin
  FSubstance.free;
  FSubstance := value;
end;


{ TFhirAdverseReactionExposureList }
procedure TFhirAdverseReactionExposureList.AddItem(value: TFhirAdverseReactionExposure);
begin
  assert(value.ClassName = 'TFhirAdverseReactionExposure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdverseReactionExposure');
  add(value);
end;


function TFhirAdverseReactionExposureList.Append: TFhirAdverseReactionExposure;
begin
  result := TFhirAdverseReactionExposure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirAdverseReactionExposureList.ClearItems;
begin
  Clear;
end;

function TFhirAdverseReactionExposureList.Clone: TFhirAdverseReactionExposureList;
begin
  result := TFhirAdverseReactionExposureList(inherited Clone);
end;

function TFhirAdverseReactionExposureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdverseReactionExposureList.GetItemN(index: Integer): TFhirAdverseReactionExposure;
begin
  result := TFhirAdverseReactionExposure(ObjectByIndex[index]);
end;

function TFhirAdverseReactionExposureList.IndexOf(value: TFhirAdverseReactionExposure): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirAdverseReactionExposureList.Insert(index: Integer): TFhirAdverseReactionExposure;
begin
  result := TFhirAdverseReactionExposure.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirAdverseReactionExposureList.InsertItem(index: Integer; value: TFhirAdverseReactionExposure);
begin
  assert(value is TFhirAdverseReactionExposure);
  Inherited Insert(index, value);
end;

function TFhirAdverseReactionExposureList.Item(index: Integer): TFhirAdverseReactionExposure;
begin
  result := TFhirAdverseReactionExposure(ObjectByIndex[index]);
end;

function TFhirAdverseReactionExposureList.Link: TFhirAdverseReactionExposureList;
begin
  result := TFhirAdverseReactionExposureList(inherited Link);
end;

procedure TFhirAdverseReactionExposureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdverseReactionExposureList.SetItemByIndex(index: Integer; value: TFhirAdverseReactionExposure);
begin
  assert(value is TFhirAdverseReactionExposure);
  FhirAdverseReactionExposures[index] := value;
end;

procedure TFhirAdverseReactionExposureList.SetItemN(index: Integer; value: TFhirAdverseReactionExposure);
begin
  assert(value is TFhirAdverseReactionExposure);
  ObjectByIndex[index] := value;
end;

{ TFhirCarePlanParticipant }

constructor TFhirCarePlanParticipant.Create;
begin
  inherited;
end;

destructor TFhirCarePlanParticipant.Destroy;
begin
  FRole.free;
  FMember.free;
  inherited;
end;

procedure TFhirCarePlanParticipant.Assign(oSource : TAdvObject);
begin
  inherited;
  role := TFhirCarePlanParticipant(oSource).role.Clone;
  member := TFhirCarePlanParticipant(oSource).member.Clone;
end;

procedure TFhirCarePlanParticipant.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(Role.Link);
  if (child_name = 'member') Then
     list.add(Member.Link);
end;

procedure TFhirCarePlanParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', FRole.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'member', 'Resource(Practitioner|RelatedPerson|Patient|Organization)', FMember.Link.Link));{2}
end;

function TFhirCarePlanParticipant.Link : TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant(inherited Link);
end;

function TFhirCarePlanParticipant.Clone : TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant(inherited Clone);
end;

{ TFhirCarePlanParticipant }

Procedure TFhirCarePlanParticipant.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirCarePlanParticipant.SetMember(value : TFhirResourceReference{Resource});
begin
  FMember.free;
  FMember := value;
end;


{ TFhirCarePlanParticipantList }
procedure TFhirCarePlanParticipantList.AddItem(value: TFhirCarePlanParticipant);
begin
  assert(value.ClassName = 'TFhirCarePlanParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCarePlanParticipant');
  add(value);
end;


function TFhirCarePlanParticipantList.Append: TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirCarePlanParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirCarePlanParticipantList.Clone: TFhirCarePlanParticipantList;
begin
  result := TFhirCarePlanParticipantList(inherited Clone);
end;

function TFhirCarePlanParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCarePlanParticipantList.GetItemN(index: Integer): TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant(ObjectByIndex[index]);
end;

function TFhirCarePlanParticipantList.IndexOf(value: TFhirCarePlanParticipant): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirCarePlanParticipantList.Insert(index: Integer): TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirCarePlanParticipantList.InsertItem(index: Integer; value: TFhirCarePlanParticipant);
begin
  assert(value is TFhirCarePlanParticipant);
  Inherited Insert(index, value);
end;

function TFhirCarePlanParticipantList.Item(index: Integer): TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant(ObjectByIndex[index]);
end;

function TFhirCarePlanParticipantList.Link: TFhirCarePlanParticipantList;
begin
  result := TFhirCarePlanParticipantList(inherited Link);
end;

procedure TFhirCarePlanParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCarePlanParticipantList.SetItemByIndex(index: Integer; value: TFhirCarePlanParticipant);
begin
  assert(value is TFhirCarePlanParticipant);
  FhirCarePlanParticipants[index] := value;
end;

procedure TFhirCarePlanParticipantList.SetItemN(index: Integer; value: TFhirCarePlanParticipant);
begin
  assert(value is TFhirCarePlanParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirCarePlanGoal }

constructor TFhirCarePlanGoal.Create;
begin
  inherited;
  FConcernList := TFhirResourceReferenceList{TFhirCondition}.Create;
end;

destructor TFhirCarePlanGoal.Destroy;
begin
  FDescription.free;
  FStatus.free;
  FNotes.free;
  FConcernList.Free;
  inherited;
end;

procedure TFhirCarePlanGoal.Assign(oSource : TAdvObject);
begin
  inherited;
  description := TFhirCarePlanGoal(oSource).description.Clone;
  FStatus := TFhirCarePlanGoal(oSource).FStatus.Link;
  notes := TFhirCarePlanGoal(oSource).notes.Clone;
  FConcernList.Assign(TFhirCarePlanGoal(oSource).FConcernList);
end;

procedure TFhirCarePlanGoal.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(Description.Link);
  if (child_name = 'status') Then
     list.add(FStatus.Link);
  if (child_name = 'notes') Then
     list.add(Notes.Link);
  if (child_name = 'concern') Then
     list.addAll(FConcernList);
end;

procedure TFhirCarePlanGoal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'notes', 'string', FNotes.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'concern', 'Resource(Condition)', FConcernList.Link)){3};
end;

function TFhirCarePlanGoal.Link : TFhirCarePlanGoal;
begin
  result := TFhirCarePlanGoal(inherited Link);
end;

function TFhirCarePlanGoal.Clone : TFhirCarePlanGoal;
begin
  result := TFhirCarePlanGoal(inherited Clone);
end;

{ TFhirCarePlanGoal }

Procedure TFhirCarePlanGoal.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirCarePlanGoal.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := Description.value;
end;

Procedure TFhirCarePlanGoal.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirCarePlanGoal.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirCarePlanGoal.GetStatusST : TFhirCarePlanGoalStatus;
begin
  if FStatus = nil then
    result := TFhirCarePlanGoalStatus(0)
  else
    result := TFhirCarePlanGoalStatus(StringArrayIndexOf(CODES_TFhirCarePlanGoalStatus, Status.value));
end;

Procedure TFhirCarePlanGoal.SetStatusST(value : TFhirCarePlanGoalStatus);
begin
  if ord(value) = 0 then
    Status := nil
  else
    Status := TFhirEnum.create(CODES_TFhirCarePlanGoalStatus[value]);
end;

Procedure TFhirCarePlanGoal.SetNotes(value : TFhirString);
begin
  FNotes.free;
  FNotes := value;
end;

Function TFhirCarePlanGoal.GetNotesST : String;
begin
  if FNotes = nil then
    result := ''
  else
    result := Notes.value;
end;

Procedure TFhirCarePlanGoal.SetNotesST(value : String);
begin
  if value <> '' then
  begin
    if FNotes = nil then
      FNotes := TFhirString.create;
    FNotes.value := value
  end
  else if FNotes <> nil then
    FNotes.value := '';
end;


{ TFhirCarePlanGoalList }
procedure TFhirCarePlanGoalList.AddItem(value: TFhirCarePlanGoal);
begin
  assert(value.ClassName = 'TFhirCarePlanGoal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCarePlanGoal');
  add(value);
end;


function TFhirCarePlanGoalList.Append: TFhirCarePlanGoal;
begin
  result := TFhirCarePlanGoal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirCarePlanGoalList.ClearItems;
begin
  Clear;
end;

function TFhirCarePlanGoalList.Clone: TFhirCarePlanGoalList;
begin
  result := TFhirCarePlanGoalList(inherited Clone);
end;

function TFhirCarePlanGoalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCarePlanGoalList.GetItemN(index: Integer): TFhirCarePlanGoal;
begin
  result := TFhirCarePlanGoal(ObjectByIndex[index]);
end;

function TFhirCarePlanGoalList.IndexOf(value: TFhirCarePlanGoal): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirCarePlanGoalList.Insert(index: Integer): TFhirCarePlanGoal;
begin
  result := TFhirCarePlanGoal.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirCarePlanGoalList.InsertItem(index: Integer; value: TFhirCarePlanGoal);
begin
  assert(value is TFhirCarePlanGoal);
  Inherited Insert(index, value);
end;

function TFhirCarePlanGoalList.Item(index: Integer): TFhirCarePlanGoal;
begin
  result := TFhirCarePlanGoal(ObjectByIndex[index]);
end;

function TFhirCarePlanGoalList.Link: TFhirCarePlanGoalList;
begin
  result := TFhirCarePlanGoalList(inherited Link);
end;

procedure TFhirCarePlanGoalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCarePlanGoalList.SetItemByIndex(index: Integer; value: TFhirCarePlanGoal);
begin
  assert(value is TFhirCarePlanGoal);
  FhirCarePlanGoals[index] := value;
end;

procedure TFhirCarePlanGoalList.SetItemN(index: Integer; value: TFhirCarePlanGoal);
begin
  assert(value is TFhirCarePlanGoal);
  ObjectByIndex[index] := value;
end;

{ TFhirCarePlanActivity }

constructor TFhirCarePlanActivity.Create;
begin
  inherited;
  FGoalList := TFhirStringList.Create;
  FActionResultingList := TFhirResourceReferenceList{Resource}.Create;
end;

destructor TFhirCarePlanActivity.Destroy;
begin
  FGoalList.Free;
  FStatus.free;
  FProhibited.free;
  FActionResultingList.Free;
  FNotes.free;
  FDetail.free;
  FSimple.free;
  inherited;
end;

procedure TFhirCarePlanActivity.Assign(oSource : TAdvObject);
begin
  inherited;
  FGoalList.Assign(TFhirCarePlanActivity(oSource).FGoalList);
  FStatus := TFhirCarePlanActivity(oSource).FStatus.Link;
  prohibited := TFhirCarePlanActivity(oSource).prohibited.Clone;
  FActionResultingList.Assign(TFhirCarePlanActivity(oSource).FActionResultingList);
  notes := TFhirCarePlanActivity(oSource).notes.Clone;
  detail := TFhirCarePlanActivity(oSource).detail.Clone;
  simple := TFhirCarePlanActivity(oSource).simple.Clone;
end;

procedure TFhirCarePlanActivity.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'goal') Then
     list.addAll(FGoalList);
  if (child_name = 'status') Then
     list.add(FStatus.Link);
  if (child_name = 'prohibited') Then
     list.add(Prohibited.Link);
  if (child_name = 'actionResulting') Then
     list.addAll(FActionResultingList);
  if (child_name = 'notes') Then
     list.add(Notes.Link);
  if (child_name = 'detail') Then
     list.add(Detail.Link);
  if (child_name = 'simple') Then
     list.add(Simple.Link);
end;

procedure TFhirCarePlanActivity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'goal', 'idref', FGoalList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'prohibited', 'boolean', FProhibited.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'actionResulting', 'Resource(Any)', FActionResultingList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'notes', 'string', FNotes.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', 'Resource(Procedure|MedicationPrescription|DiagnosticOrder|Encounter)', FDetail.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'simple', '', FSimple.Link.Link));{2}
end;

function TFhirCarePlanActivity.Link : TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(inherited Link);
end;

function TFhirCarePlanActivity.Clone : TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(inherited Clone);
end;

{ TFhirCarePlanActivity }

Procedure TFhirCarePlanActivity.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirCarePlanActivity.GetStatusST : TFhirCarePlanActivityStatus;
begin
  if FStatus = nil then
    result := TFhirCarePlanActivityStatus(0)
  else
    result := TFhirCarePlanActivityStatus(StringArrayIndexOf(CODES_TFhirCarePlanActivityStatus, Status.value));
end;

Procedure TFhirCarePlanActivity.SetStatusST(value : TFhirCarePlanActivityStatus);
begin
  if ord(value) = 0 then
    Status := nil
  else
    Status := TFhirEnum.create(CODES_TFhirCarePlanActivityStatus[value]);
end;

Procedure TFhirCarePlanActivity.SetProhibited(value : TFhirBoolean);
begin
  FProhibited.free;
  FProhibited := value;
end;

Function TFhirCarePlanActivity.GetProhibitedST : Boolean;
begin
  if FProhibited = nil then
    result := false
  else
    result := Prohibited.value;
end;

Procedure TFhirCarePlanActivity.SetProhibitedST(value : Boolean);
begin
  if FProhibited = nil then
    FProhibited := TFhirBoolean.create;
  FProhibited.value := value
end;

Procedure TFhirCarePlanActivity.SetNotes(value : TFhirString);
begin
  FNotes.free;
  FNotes := value;
end;

Function TFhirCarePlanActivity.GetNotesST : String;
begin
  if FNotes = nil then
    result := ''
  else
    result := Notes.value;
end;

Procedure TFhirCarePlanActivity.SetNotesST(value : String);
begin
  if value <> '' then
  begin
    if FNotes = nil then
      FNotes := TFhirString.create;
    FNotes.value := value
  end
  else if FNotes <> nil then
    FNotes.value := '';
end;

Procedure TFhirCarePlanActivity.SetDetail(value : TFhirResourceReference{Resource});
begin
  FDetail.free;
  FDetail := value;
end;

Procedure TFhirCarePlanActivity.SetSimple(value : TFhirCarePlanActivitySimple);
begin
  FSimple.free;
  FSimple := value;
end;


{ TFhirCarePlanActivityList }
procedure TFhirCarePlanActivityList.AddItem(value: TFhirCarePlanActivity);
begin
  assert(value.ClassName = 'TFhirCarePlanActivity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCarePlanActivity');
  add(value);
end;


function TFhirCarePlanActivityList.Append: TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirCarePlanActivityList.ClearItems;
begin
  Clear;
end;

function TFhirCarePlanActivityList.Clone: TFhirCarePlanActivityList;
begin
  result := TFhirCarePlanActivityList(inherited Clone);
end;

function TFhirCarePlanActivityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCarePlanActivityList.GetItemN(index: Integer): TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(ObjectByIndex[index]);
end;

function TFhirCarePlanActivityList.IndexOf(value: TFhirCarePlanActivity): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirCarePlanActivityList.Insert(index: Integer): TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirCarePlanActivityList.InsertItem(index: Integer; value: TFhirCarePlanActivity);
begin
  assert(value is TFhirCarePlanActivity);
  Inherited Insert(index, value);
end;

function TFhirCarePlanActivityList.Item(index: Integer): TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(ObjectByIndex[index]);
end;

function TFhirCarePlanActivityList.Link: TFhirCarePlanActivityList;
begin
  result := TFhirCarePlanActivityList(inherited Link);
end;

procedure TFhirCarePlanActivityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCarePlanActivityList.SetItemByIndex(index: Integer; value: TFhirCarePlanActivity);
begin
  assert(value is TFhirCarePlanActivity);
  FhirCarePlanActivities[index] := value;
end;

procedure TFhirCarePlanActivityList.SetItemN(index: Integer; value: TFhirCarePlanActivity);
begin
  assert(value is TFhirCarePlanActivity);
  ObjectByIndex[index] := value;
end;

{ TFhirCarePlanActivitySimple }

constructor TFhirCarePlanActivitySimple.Create;
begin
  inherited;
  FPerformerList := TFhirResourceReferenceList{Resource}.Create;
end;

destructor TFhirCarePlanActivitySimple.Destroy;
begin
  FCategory.free;
  FCode.free;
  FTiming.free;
  FLocation.free;
  FPerformerList.Free;
  FProduct.free;
  FDailyAmount.free;
  FQuantity.free;
  FDetails.free;
  inherited;
end;

procedure TFhirCarePlanActivitySimple.Assign(oSource : TAdvObject);
begin
  inherited;
  FCategory := TFhirCarePlanActivitySimple(oSource).FCategory.Link;
  code := TFhirCarePlanActivitySimple(oSource).code.Clone;
  timing := TFhirCarePlanActivitySimple(oSource).timing.Clone;
  location := TFhirCarePlanActivitySimple(oSource).location.Clone;
  FPerformerList.Assign(TFhirCarePlanActivitySimple(oSource).FPerformerList);
  product := TFhirCarePlanActivitySimple(oSource).product.Clone;
  dailyAmount := TFhirCarePlanActivitySimple(oSource).dailyAmount.Clone;
  quantity := TFhirCarePlanActivitySimple(oSource).quantity.Clone;
  details := TFhirCarePlanActivitySimple(oSource).details.Clone;
end;

procedure TFhirCarePlanActivitySimple.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(FCategory.Link);
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'timing') Then
     list.add(Timing.Link);
  if (child_name = 'location') Then
     list.add(Location.Link);
  if (child_name = 'performer') Then
     list.addAll(FPerformerList);
  if (child_name = 'product') Then
     list.add(Product.Link);
  if (child_name = 'dailyAmount') Then
     list.add(DailyAmount.Link);
  if (child_name = 'quantity') Then
     list.add(Quantity.Link);
  if (child_name = 'details') Then
     list.add(Details.Link);
end;

procedure TFhirCarePlanActivitySimple.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'code', FCategory.Link));{1}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'Schedule|Period|string', FTiming.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location', 'Resource(Location)', FLocation.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', 'Resource(Practitioner|Organization|RelatedPerson|Patient)', FPerformerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'product', 'Resource(Medication|Substance)', FProduct.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dailyAmount', 'Quantity', FDailyAmount.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'details', 'string', FDetails.Link.Link));{2}
end;

function TFhirCarePlanActivitySimple.Link : TFhirCarePlanActivitySimple;
begin
  result := TFhirCarePlanActivitySimple(inherited Link);
end;

function TFhirCarePlanActivitySimple.Clone : TFhirCarePlanActivitySimple;
begin
  result := TFhirCarePlanActivitySimple(inherited Clone);
end;

{ TFhirCarePlanActivitySimple }

Procedure TFhirCarePlanActivitySimple.SetCategory(value : TFhirEnum);
begin
  FCategory.free;
  FCategory := value;
end;

Function TFhirCarePlanActivitySimple.GetCategoryST : TFhirCarePlanActivityCategory;
begin
  if FCategory = nil then
    result := TFhirCarePlanActivityCategory(0)
  else
    result := TFhirCarePlanActivityCategory(StringArrayIndexOf(CODES_TFhirCarePlanActivityCategory, Category.value));
end;

Procedure TFhirCarePlanActivitySimple.SetCategoryST(value : TFhirCarePlanActivityCategory);
begin
  if ord(value) = 0 then
    Category := nil
  else
    Category := TFhirEnum.create(CODES_TFhirCarePlanActivityCategory[value]);
end;

Procedure TFhirCarePlanActivitySimple.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirCarePlanActivitySimple.SetTiming(value : TFhirType);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirCarePlanActivitySimple.SetLocation(value : TFhirResourceReference{TFhirLocation});
begin
  FLocation.free;
  FLocation := value;
end;

Procedure TFhirCarePlanActivitySimple.SetProduct(value : TFhirResourceReference{Resource});
begin
  FProduct.free;
  FProduct := value;
end;

Procedure TFhirCarePlanActivitySimple.SetDailyAmount(value : TFhirQuantity);
begin
  FDailyAmount.free;
  FDailyAmount := value;
end;

Procedure TFhirCarePlanActivitySimple.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirCarePlanActivitySimple.SetDetails(value : TFhirString);
begin
  FDetails.free;
  FDetails := value;
end;

Function TFhirCarePlanActivitySimple.GetDetailsST : String;
begin
  if FDetails = nil then
    result := ''
  else
    result := Details.value;
end;

Procedure TFhirCarePlanActivitySimple.SetDetailsST(value : String);
begin
  if value <> '' then
  begin
    if FDetails = nil then
      FDetails := TFhirString.create;
    FDetails.value := value
  end
  else if FDetails <> nil then
    FDetails.value := '';
end;


{ TFhirCarePlanActivitySimpleList }
procedure TFhirCarePlanActivitySimpleList.AddItem(value: TFhirCarePlanActivitySimple);
begin
  assert(value.ClassName = 'TFhirCarePlanActivitySimple', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCarePlanActivitySimple');
  add(value);
end;


function TFhirCarePlanActivitySimpleList.Append: TFhirCarePlanActivitySimple;
begin
  result := TFhirCarePlanActivitySimple.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirCarePlanActivitySimpleList.ClearItems;
begin
  Clear;
end;

function TFhirCarePlanActivitySimpleList.Clone: TFhirCarePlanActivitySimpleList;
begin
  result := TFhirCarePlanActivitySimpleList(inherited Clone);
end;

function TFhirCarePlanActivitySimpleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCarePlanActivitySimpleList.GetItemN(index: Integer): TFhirCarePlanActivitySimple;
begin
  result := TFhirCarePlanActivitySimple(ObjectByIndex[index]);
end;

function TFhirCarePlanActivitySimpleList.IndexOf(value: TFhirCarePlanActivitySimple): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirCarePlanActivitySimpleList.Insert(index: Integer): TFhirCarePlanActivitySimple;
begin
  result := TFhirCarePlanActivitySimple.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirCarePlanActivitySimpleList.InsertItem(index: Integer; value: TFhirCarePlanActivitySimple);
begin
  assert(value is TFhirCarePlanActivitySimple);
  Inherited Insert(index, value);
end;

function TFhirCarePlanActivitySimpleList.Item(index: Integer): TFhirCarePlanActivitySimple;
begin
  result := TFhirCarePlanActivitySimple(ObjectByIndex[index]);
end;

function TFhirCarePlanActivitySimpleList.Link: TFhirCarePlanActivitySimpleList;
begin
  result := TFhirCarePlanActivitySimpleList(inherited Link);
end;

procedure TFhirCarePlanActivitySimpleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCarePlanActivitySimpleList.SetItemByIndex(index: Integer; value: TFhirCarePlanActivitySimple);
begin
  assert(value is TFhirCarePlanActivitySimple);
  FhirCarePlanActivitySimples[index] := value;
end;

procedure TFhirCarePlanActivitySimpleList.SetItemN(index: Integer; value: TFhirCarePlanActivitySimple);
begin
  assert(value is TFhirCarePlanActivitySimple);
  ObjectByIndex[index] := value;
end;

{ TFhirCompositionAttester }

constructor TFhirCompositionAttester.Create;
begin
  inherited;
  FMode := TFHIREnumList.Create;
end;

destructor TFhirCompositionAttester.Destroy;
begin
  FMode.Free;
  FTime.free;
  FParty.free;
  inherited;
end;

procedure TFhirCompositionAttester.Assign(oSource : TAdvObject);
begin
  inherited;
  FMode.Assign(TFhirCompositionAttester(oSource).FMode);
  time := TFhirCompositionAttester(oSource).time.Clone;
  party := TFhirCompositionAttester(oSource).party.Clone;
end;

procedure TFhirCompositionAttester.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.addAll(FMode);
  if (child_name = 'time') Then
     list.add(Time.Link);
  if (child_name = 'party') Then
     list.add(Party.Link);
end;

procedure TFhirCompositionAttester.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', FMode.Link)){3};
  oList.add(TFHIRProperty.create(self, 'time', 'dateTime', FTime.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'party', 'Resource(Patient|Practitioner|Organization)', FParty.Link.Link));{2}
end;

function TFhirCompositionAttester.Link : TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester(inherited Link);
end;

function TFhirCompositionAttester.Clone : TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester(inherited Clone);
end;

{ TFhirCompositionAttester }

Function TFhirCompositionAttester.GetModeST : TFhirCompositionAttestationModeList;
  var i : integer;
begin
  result := [];
  for i := 0 to mode.count - 1 do
    result := result + [TFhirCompositionAttestationMode(StringArrayIndexOf(CODES_TFhirCompositionAttestationMode, mode[i].value))];
end;

Procedure TFhirCompositionAttester.SetModeST(value : TFhirCompositionAttestationModeList);
var a : TFhirCompositionAttestationMode;
begin
  mode.clear;
  for a := low(TFhirCompositionAttestationMode) to high(TFhirCompositionAttestationMode) do
    if a in value then
      mode.add(TFhirEnum.create(CODES_TFhirCompositionAttestationMode[a]));
end;

Procedure TFhirCompositionAttester.SetTime(value : TFhirDateTime);
begin
  FTime.free;
  FTime := value;
end;

Function TFhirCompositionAttester.GetTimeST : TDateAndTime;
begin
  if FTime = nil then
    result := nil
  else
    result := Time.value;
end;

Procedure TFhirCompositionAttester.SetTimeST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FTime = nil then
      FTime := TFhirDateTime.create;
    FTime.value := value
  end
  else if FTime <> nil then
    FTime.value := nil;
end;

Procedure TFhirCompositionAttester.SetParty(value : TFhirResourceReference{Resource});
begin
  FParty.free;
  FParty := value;
end;


{ TFhirCompositionAttesterList }
procedure TFhirCompositionAttesterList.AddItem(value: TFhirCompositionAttester);
begin
  assert(value.ClassName = 'TFhirCompositionAttester', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCompositionAttester');
  add(value);
end;


function TFhirCompositionAttesterList.Append: TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirCompositionAttesterList.ClearItems;
begin
  Clear;
end;

function TFhirCompositionAttesterList.Clone: TFhirCompositionAttesterList;
begin
  result := TFhirCompositionAttesterList(inherited Clone);
end;

function TFhirCompositionAttesterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompositionAttesterList.GetItemN(index: Integer): TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester(ObjectByIndex[index]);
end;

function TFhirCompositionAttesterList.IndexOf(value: TFhirCompositionAttester): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirCompositionAttesterList.Insert(index: Integer): TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirCompositionAttesterList.InsertItem(index: Integer; value: TFhirCompositionAttester);
begin
  assert(value is TFhirCompositionAttester);
  Inherited Insert(index, value);
end;

function TFhirCompositionAttesterList.Item(index: Integer): TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester(ObjectByIndex[index]);
end;

function TFhirCompositionAttesterList.Link: TFhirCompositionAttesterList;
begin
  result := TFhirCompositionAttesterList(inherited Link);
end;

procedure TFhirCompositionAttesterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompositionAttesterList.SetItemByIndex(index: Integer; value: TFhirCompositionAttester);
begin
  assert(value is TFhirCompositionAttester);
  FhirCompositionAttesters[index] := value;
end;

procedure TFhirCompositionAttesterList.SetItemN(index: Integer; value: TFhirCompositionAttester);
begin
  assert(value is TFhirCompositionAttester);
  ObjectByIndex[index] := value;
end;

{ TFhirCompositionEvent }

constructor TFhirCompositionEvent.Create;
begin
  inherited;
  FCodeList := TFhirCodeableConceptList.Create;
  FDetailList := TFhirResourceReferenceList{Resource}.Create;
end;

destructor TFhirCompositionEvent.Destroy;
begin
  FCodeList.Free;
  FPeriod.free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirCompositionEvent.Assign(oSource : TAdvObject);
begin
  inherited;
  FCodeList.Assign(TFhirCompositionEvent(oSource).FCodeList);
  period := TFhirCompositionEvent(oSource).period.Clone;
  FDetailList.Assign(TFhirCompositionEvent(oSource).FDetailList);
end;

procedure TFhirCompositionEvent.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.addAll(FCodeList);
  if (child_name = 'period') Then
     list.add(Period.Link);
  if (child_name = 'detail') Then
     list.addAll(FDetailList);
end;

procedure TFhirCompositionEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'period', 'Period', FPeriod.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', 'Resource(Any)', FDetailList.Link)){3};
end;

function TFhirCompositionEvent.Link : TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent(inherited Link);
end;

function TFhirCompositionEvent.Clone : TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent(inherited Clone);
end;

{ TFhirCompositionEvent }

Procedure TFhirCompositionEvent.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;


{ TFhirCompositionEventList }
procedure TFhirCompositionEventList.AddItem(value: TFhirCompositionEvent);
begin
  assert(value.ClassName = 'TFhirCompositionEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCompositionEvent');
  add(value);
end;


function TFhirCompositionEventList.Append: TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirCompositionEventList.ClearItems;
begin
  Clear;
end;

function TFhirCompositionEventList.Clone: TFhirCompositionEventList;
begin
  result := TFhirCompositionEventList(inherited Clone);
end;

function TFhirCompositionEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompositionEventList.GetItemN(index: Integer): TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent(ObjectByIndex[index]);
end;

function TFhirCompositionEventList.IndexOf(value: TFhirCompositionEvent): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirCompositionEventList.Insert(index: Integer): TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirCompositionEventList.InsertItem(index: Integer; value: TFhirCompositionEvent);
begin
  assert(value is TFhirCompositionEvent);
  Inherited Insert(index, value);
end;

function TFhirCompositionEventList.Item(index: Integer): TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent(ObjectByIndex[index]);
end;

function TFhirCompositionEventList.Link: TFhirCompositionEventList;
begin
  result := TFhirCompositionEventList(inherited Link);
end;

procedure TFhirCompositionEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompositionEventList.SetItemByIndex(index: Integer; value: TFhirCompositionEvent);
begin
  assert(value is TFhirCompositionEvent);
  FhirCompositionEvents[index] := value;
end;

procedure TFhirCompositionEventList.SetItemN(index: Integer; value: TFhirCompositionEvent);
begin
  assert(value is TFhirCompositionEvent);
  ObjectByIndex[index] := value;
end;

{ TFhirCompositionSection }

constructor TFhirCompositionSection.Create;
begin
  inherited;
  FSectionList := TFhirCompositionSectionList.Create;
end;

destructor TFhirCompositionSection.Destroy;
begin
  FTitle.free;
  FCode.free;
  FSubject.free;
  FContent.free;
  FSectionList.Free;
  inherited;
end;

procedure TFhirCompositionSection.Assign(oSource : TAdvObject);
begin
  inherited;
  title := TFhirCompositionSection(oSource).title.Clone;
  code := TFhirCompositionSection(oSource).code.Clone;
  subject := TFhirCompositionSection(oSource).subject.Clone;
  content := TFhirCompositionSection(oSource).content.Clone;
  FSectionList.Assign(TFhirCompositionSection(oSource).FSectionList);
end;

procedure TFhirCompositionSection.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'title') Then
     list.add(Title.Link);
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'subject') Then
     list.add(Subject.Link);
  if (child_name = 'content') Then
     list.add(Content.Link);
  if (child_name = 'section') Then
     list.addAll(FSectionList);
end;

procedure TFhirCompositionSection.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'title', 'string', FTitle.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Resource(Patient|Group|Device)', FSubject.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'content', 'Resource(Any)', FContent.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'section', '@Composition.section', FSectionList.Link)){3};
end;

function TFhirCompositionSection.Link : TFhirCompositionSection;
begin
  result := TFhirCompositionSection(inherited Link);
end;

function TFhirCompositionSection.Clone : TFhirCompositionSection;
begin
  result := TFhirCompositionSection(inherited Clone);
end;

{ TFhirCompositionSection }

Procedure TFhirCompositionSection.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirCompositionSection.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := Title.value;
end;

Procedure TFhirCompositionSection.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

Procedure TFhirCompositionSection.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirCompositionSection.SetSubject(value : TFhirResourceReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirCompositionSection.SetContent(value : TFhirResourceReference{Resource});
begin
  FContent.free;
  FContent := value;
end;


{ TFhirCompositionSectionList }
procedure TFhirCompositionSectionList.AddItem(value: TFhirCompositionSection);
begin
  assert(value.ClassName = 'TFhirCompositionSection', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCompositionSection');
  add(value);
end;


function TFhirCompositionSectionList.Append: TFhirCompositionSection;
begin
  result := TFhirCompositionSection.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirCompositionSectionList.ClearItems;
begin
  Clear;
end;

function TFhirCompositionSectionList.Clone: TFhirCompositionSectionList;
begin
  result := TFhirCompositionSectionList(inherited Clone);
end;

function TFhirCompositionSectionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompositionSectionList.GetItemN(index: Integer): TFhirCompositionSection;
begin
  result := TFhirCompositionSection(ObjectByIndex[index]);
end;

function TFhirCompositionSectionList.IndexOf(value: TFhirCompositionSection): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirCompositionSectionList.Insert(index: Integer): TFhirCompositionSection;
begin
  result := TFhirCompositionSection.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirCompositionSectionList.InsertItem(index: Integer; value: TFhirCompositionSection);
begin
  assert(value is TFhirCompositionSection);
  Inherited Insert(index, value);
end;

function TFhirCompositionSectionList.Item(index: Integer): TFhirCompositionSection;
begin
  result := TFhirCompositionSection(ObjectByIndex[index]);
end;

function TFhirCompositionSectionList.Link: TFhirCompositionSectionList;
begin
  result := TFhirCompositionSectionList(inherited Link);
end;

procedure TFhirCompositionSectionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompositionSectionList.SetItemByIndex(index: Integer; value: TFhirCompositionSection);
begin
  assert(value is TFhirCompositionSection);
  FhirCompositionSections[index] := value;
end;

procedure TFhirCompositionSectionList.SetItemN(index: Integer; value: TFhirCompositionSection);
begin
  assert(value is TFhirCompositionSection);
  ObjectByIndex[index] := value;
end;

{ TFhirConceptMapConcept }

constructor TFhirConceptMapConcept.Create;
begin
  inherited;
  FDependsOnList := TFhirConceptMapConceptDependsOnList.Create;
  FMapList := TFhirConceptMapConceptMapList.Create;
end;

destructor TFhirConceptMapConcept.Destroy;
begin
  FSystem.free;
  FCode.free;
  FDependsOnList.Free;
  FMapList.Free;
  inherited;
end;

procedure TFhirConceptMapConcept.Assign(oSource : TAdvObject);
begin
  inherited;
  system := TFhirConceptMapConcept(oSource).system.Clone;
  code := TFhirConceptMapConcept(oSource).code.Clone;
  FDependsOnList.Assign(TFhirConceptMapConcept(oSource).FDependsOnList);
  FMapList.Assign(TFhirConceptMapConcept(oSource).FMapList);
end;

procedure TFhirConceptMapConcept.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'system') Then
     list.add(System.Link);
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'dependsOn') Then
     list.addAll(FDependsOnList);
  if (child_name = 'map') Then
     list.addAll(FMapList);
end;

procedure TFhirConceptMapConcept.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'system', 'uri', FSystem.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dependsOn', '', FDependsOnList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'map', '', FMapList.Link)){3};
end;

function TFhirConceptMapConcept.Link : TFhirConceptMapConcept;
begin
  result := TFhirConceptMapConcept(inherited Link);
end;

function TFhirConceptMapConcept.Clone : TFhirConceptMapConcept;
begin
  result := TFhirConceptMapConcept(inherited Clone);
end;

{ TFhirConceptMapConcept }

Procedure TFhirConceptMapConcept.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirConceptMapConcept.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := System.value;
end;

Procedure TFhirConceptMapConcept.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirConceptMapConcept.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirConceptMapConcept.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := Code.value;
end;

Procedure TFhirConceptMapConcept.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;


{ TFhirConceptMapConceptList }
procedure TFhirConceptMapConceptList.AddItem(value: TFhirConceptMapConcept);
begin
  assert(value.ClassName = 'TFhirConceptMapConcept', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConceptMapConcept');
  add(value);
end;


function TFhirConceptMapConceptList.Append: TFhirConceptMapConcept;
begin
  result := TFhirConceptMapConcept.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConceptMapConceptList.ClearItems;
begin
  Clear;
end;

function TFhirConceptMapConceptList.Clone: TFhirConceptMapConceptList;
begin
  result := TFhirConceptMapConceptList(inherited Clone);
end;

function TFhirConceptMapConceptList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConceptMapConceptList.GetItemN(index: Integer): TFhirConceptMapConcept;
begin
  result := TFhirConceptMapConcept(ObjectByIndex[index]);
end;

function TFhirConceptMapConceptList.IndexOf(value: TFhirConceptMapConcept): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConceptMapConceptList.Insert(index: Integer): TFhirConceptMapConcept;
begin
  result := TFhirConceptMapConcept.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConceptMapConceptList.InsertItem(index: Integer; value: TFhirConceptMapConcept);
begin
  assert(value is TFhirConceptMapConcept);
  Inherited Insert(index, value);
end;

function TFhirConceptMapConceptList.Item(index: Integer): TFhirConceptMapConcept;
begin
  result := TFhirConceptMapConcept(ObjectByIndex[index]);
end;

function TFhirConceptMapConceptList.Link: TFhirConceptMapConceptList;
begin
  result := TFhirConceptMapConceptList(inherited Link);
end;

procedure TFhirConceptMapConceptList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConceptMapConceptList.SetItemByIndex(index: Integer; value: TFhirConceptMapConcept);
begin
  assert(value is TFhirConceptMapConcept);
  FhirConceptMapConcepts[index] := value;
end;

procedure TFhirConceptMapConceptList.SetItemN(index: Integer; value: TFhirConceptMapConcept);
begin
  assert(value is TFhirConceptMapConcept);
  ObjectByIndex[index] := value;
end;

{ TFhirConceptMapConceptDependsOn }

constructor TFhirConceptMapConceptDependsOn.Create;
begin
  inherited;
end;

destructor TFhirConceptMapConceptDependsOn.Destroy;
begin
  FConcept.free;
  FSystem.free;
  FCode.free;
  inherited;
end;

procedure TFhirConceptMapConceptDependsOn.Assign(oSource : TAdvObject);
begin
  inherited;
  concept := TFhirConceptMapConceptDependsOn(oSource).concept.Clone;
  system := TFhirConceptMapConceptDependsOn(oSource).system.Clone;
  code := TFhirConceptMapConceptDependsOn(oSource).code.Clone;
end;

procedure TFhirConceptMapConceptDependsOn.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'concept') Then
     list.add(Concept.Link);
  if (child_name = 'system') Then
     list.add(System.Link);
  if (child_name = 'code') Then
     list.add(Code.Link);
end;

procedure TFhirConceptMapConceptDependsOn.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'concept', 'uri', FConcept.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'system', 'uri', FSystem.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link.Link));{2}
end;

function TFhirConceptMapConceptDependsOn.Link : TFhirConceptMapConceptDependsOn;
begin
  result := TFhirConceptMapConceptDependsOn(inherited Link);
end;

function TFhirConceptMapConceptDependsOn.Clone : TFhirConceptMapConceptDependsOn;
begin
  result := TFhirConceptMapConceptDependsOn(inherited Clone);
end;

{ TFhirConceptMapConceptDependsOn }

Procedure TFhirConceptMapConceptDependsOn.SetConcept(value : TFhirUri);
begin
  FConcept.free;
  FConcept := value;
end;

Function TFhirConceptMapConceptDependsOn.GetConceptST : String;
begin
  if FConcept = nil then
    result := ''
  else
    result := Concept.value;
end;

Procedure TFhirConceptMapConceptDependsOn.SetConceptST(value : String);
begin
  if value <> '' then
  begin
    if FConcept = nil then
      FConcept := TFhirUri.create;
    FConcept.value := value
  end
  else if FConcept <> nil then
    FConcept.value := '';
end;

Procedure TFhirConceptMapConceptDependsOn.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirConceptMapConceptDependsOn.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := System.value;
end;

Procedure TFhirConceptMapConceptDependsOn.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirConceptMapConceptDependsOn.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirConceptMapConceptDependsOn.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := Code.value;
end;

Procedure TFhirConceptMapConceptDependsOn.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;


{ TFhirConceptMapConceptDependsOnList }
procedure TFhirConceptMapConceptDependsOnList.AddItem(value: TFhirConceptMapConceptDependsOn);
begin
  assert(value.ClassName = 'TFhirConceptMapConceptDependsOn', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConceptMapConceptDependsOn');
  add(value);
end;


function TFhirConceptMapConceptDependsOnList.Append: TFhirConceptMapConceptDependsOn;
begin
  result := TFhirConceptMapConceptDependsOn.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConceptMapConceptDependsOnList.ClearItems;
begin
  Clear;
end;

function TFhirConceptMapConceptDependsOnList.Clone: TFhirConceptMapConceptDependsOnList;
begin
  result := TFhirConceptMapConceptDependsOnList(inherited Clone);
end;

function TFhirConceptMapConceptDependsOnList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConceptMapConceptDependsOnList.GetItemN(index: Integer): TFhirConceptMapConceptDependsOn;
begin
  result := TFhirConceptMapConceptDependsOn(ObjectByIndex[index]);
end;

function TFhirConceptMapConceptDependsOnList.IndexOf(value: TFhirConceptMapConceptDependsOn): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConceptMapConceptDependsOnList.Insert(index: Integer): TFhirConceptMapConceptDependsOn;
begin
  result := TFhirConceptMapConceptDependsOn.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConceptMapConceptDependsOnList.InsertItem(index: Integer; value: TFhirConceptMapConceptDependsOn);
begin
  assert(value is TFhirConceptMapConceptDependsOn);
  Inherited Insert(index, value);
end;

function TFhirConceptMapConceptDependsOnList.Item(index: Integer): TFhirConceptMapConceptDependsOn;
begin
  result := TFhirConceptMapConceptDependsOn(ObjectByIndex[index]);
end;

function TFhirConceptMapConceptDependsOnList.Link: TFhirConceptMapConceptDependsOnList;
begin
  result := TFhirConceptMapConceptDependsOnList(inherited Link);
end;

procedure TFhirConceptMapConceptDependsOnList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConceptMapConceptDependsOnList.SetItemByIndex(index: Integer; value: TFhirConceptMapConceptDependsOn);
begin
  assert(value is TFhirConceptMapConceptDependsOn);
  FhirConceptMapConceptDependsOns[index] := value;
end;

procedure TFhirConceptMapConceptDependsOnList.SetItemN(index: Integer; value: TFhirConceptMapConceptDependsOn);
begin
  assert(value is TFhirConceptMapConceptDependsOn);
  ObjectByIndex[index] := value;
end;

{ TFhirConceptMapConceptMap }

constructor TFhirConceptMapConceptMap.Create;
begin
  inherited;
  FProductList := TFhirConceptMapConceptDependsOnList.Create;
end;

destructor TFhirConceptMapConceptMap.Destroy;
begin
  FSystem.free;
  FCode.free;
  FEquivalence.free;
  FComments.free;
  FProductList.Free;
  inherited;
end;

procedure TFhirConceptMapConceptMap.Assign(oSource : TAdvObject);
begin
  inherited;
  system := TFhirConceptMapConceptMap(oSource).system.Clone;
  code := TFhirConceptMapConceptMap(oSource).code.Clone;
  FEquivalence := TFhirConceptMapConceptMap(oSource).FEquivalence.Link;
  comments := TFhirConceptMapConceptMap(oSource).comments.Clone;
  FProductList.Assign(TFhirConceptMapConceptMap(oSource).FProductList);
end;

procedure TFhirConceptMapConceptMap.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'system') Then
     list.add(System.Link);
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'equivalence') Then
     list.add(FEquivalence.Link);
  if (child_name = 'comments') Then
     list.add(Comments.Link);
  if (child_name = 'product') Then
     list.addAll(FProductList);
end;

procedure TFhirConceptMapConceptMap.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'system', 'uri', FSystem.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'equivalence', 'code', FEquivalence.Link));{1}
  oList.add(TFHIRProperty.create(self, 'comments', 'string', FComments.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'product', '@ConceptMap.concept.dependsOn', FProductList.Link)){3};
end;

function TFhirConceptMapConceptMap.Link : TFhirConceptMapConceptMap;
begin
  result := TFhirConceptMapConceptMap(inherited Link);
end;

function TFhirConceptMapConceptMap.Clone : TFhirConceptMapConceptMap;
begin
  result := TFhirConceptMapConceptMap(inherited Clone);
end;

{ TFhirConceptMapConceptMap }

Procedure TFhirConceptMapConceptMap.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirConceptMapConceptMap.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := System.value;
end;

Procedure TFhirConceptMapConceptMap.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirConceptMapConceptMap.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirConceptMapConceptMap.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := Code.value;
end;

Procedure TFhirConceptMapConceptMap.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirConceptMapConceptMap.SetEquivalence(value : TFhirEnum);
begin
  FEquivalence.free;
  FEquivalence := value;
end;

Function TFhirConceptMapConceptMap.GetEquivalenceST : TFhirConceptEquivalence;
begin
  if FEquivalence = nil then
    result := TFhirConceptEquivalence(0)
  else
    result := TFhirConceptEquivalence(StringArrayIndexOf(CODES_TFhirConceptEquivalence, Equivalence.value));
end;

Procedure TFhirConceptMapConceptMap.SetEquivalenceST(value : TFhirConceptEquivalence);
begin
  if ord(value) = 0 then
    Equivalence := nil
  else
    Equivalence := TFhirEnum.create(CODES_TFhirConceptEquivalence[value]);
end;

Procedure TFhirConceptMapConceptMap.SetComments(value : TFhirString);
begin
  FComments.free;
  FComments := value;
end;

Function TFhirConceptMapConceptMap.GetCommentsST : String;
begin
  if FComments = nil then
    result := ''
  else
    result := Comments.value;
end;

Procedure TFhirConceptMapConceptMap.SetCommentsST(value : String);
begin
  if value <> '' then
  begin
    if FComments = nil then
      FComments := TFhirString.create;
    FComments.value := value
  end
  else if FComments <> nil then
    FComments.value := '';
end;


{ TFhirConceptMapConceptMapList }
procedure TFhirConceptMapConceptMapList.AddItem(value: TFhirConceptMapConceptMap);
begin
  assert(value.ClassName = 'TFhirConceptMapConceptMap', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConceptMapConceptMap');
  add(value);
end;


function TFhirConceptMapConceptMapList.Append: TFhirConceptMapConceptMap;
begin
  result := TFhirConceptMapConceptMap.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConceptMapConceptMapList.ClearItems;
begin
  Clear;
end;

function TFhirConceptMapConceptMapList.Clone: TFhirConceptMapConceptMapList;
begin
  result := TFhirConceptMapConceptMapList(inherited Clone);
end;

function TFhirConceptMapConceptMapList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConceptMapConceptMapList.GetItemN(index: Integer): TFhirConceptMapConceptMap;
begin
  result := TFhirConceptMapConceptMap(ObjectByIndex[index]);
end;

function TFhirConceptMapConceptMapList.IndexOf(value: TFhirConceptMapConceptMap): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConceptMapConceptMapList.Insert(index: Integer): TFhirConceptMapConceptMap;
begin
  result := TFhirConceptMapConceptMap.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConceptMapConceptMapList.InsertItem(index: Integer; value: TFhirConceptMapConceptMap);
begin
  assert(value is TFhirConceptMapConceptMap);
  Inherited Insert(index, value);
end;

function TFhirConceptMapConceptMapList.Item(index: Integer): TFhirConceptMapConceptMap;
begin
  result := TFhirConceptMapConceptMap(ObjectByIndex[index]);
end;

function TFhirConceptMapConceptMapList.Link: TFhirConceptMapConceptMapList;
begin
  result := TFhirConceptMapConceptMapList(inherited Link);
end;

procedure TFhirConceptMapConceptMapList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConceptMapConceptMapList.SetItemByIndex(index: Integer; value: TFhirConceptMapConceptMap);
begin
  assert(value is TFhirConceptMapConceptMap);
  FhirConceptMapConceptMaps[index] := value;
end;

procedure TFhirConceptMapConceptMapList.SetItemN(index: Integer; value: TFhirConceptMapConceptMap);
begin
  assert(value is TFhirConceptMapConceptMap);
  ObjectByIndex[index] := value;
end;

{ TFhirConditionStage }

constructor TFhirConditionStage.Create;
begin
  inherited;
  FAssessmentList := TFhirResourceReferenceList{Resource}.Create;
end;

destructor TFhirConditionStage.Destroy;
begin
  FSummary.free;
  FAssessmentList.Free;
  inherited;
end;

procedure TFhirConditionStage.Assign(oSource : TAdvObject);
begin
  inherited;
  summary := TFhirConditionStage(oSource).summary.Clone;
  FAssessmentList.Assign(TFhirConditionStage(oSource).FAssessmentList);
end;

procedure TFhirConditionStage.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'summary') Then
     list.add(Summary.Link);
  if (child_name = 'assessment') Then
     list.addAll(FAssessmentList);
end;

procedure TFhirConditionStage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'summary', 'CodeableConcept', FSummary.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'assessment', 'Resource(Any)', FAssessmentList.Link)){3};
end;

function TFhirConditionStage.Link : TFhirConditionStage;
begin
  result := TFhirConditionStage(inherited Link);
end;

function TFhirConditionStage.Clone : TFhirConditionStage;
begin
  result := TFhirConditionStage(inherited Clone);
end;

{ TFhirConditionStage }

Procedure TFhirConditionStage.SetSummary(value : TFhirCodeableConcept);
begin
  FSummary.free;
  FSummary := value;
end;


{ TFhirConditionStageList }
procedure TFhirConditionStageList.AddItem(value: TFhirConditionStage);
begin
  assert(value.ClassName = 'TFhirConditionStage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConditionStage');
  add(value);
end;


function TFhirConditionStageList.Append: TFhirConditionStage;
begin
  result := TFhirConditionStage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConditionStageList.ClearItems;
begin
  Clear;
end;

function TFhirConditionStageList.Clone: TFhirConditionStageList;
begin
  result := TFhirConditionStageList(inherited Clone);
end;

function TFhirConditionStageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConditionStageList.GetItemN(index: Integer): TFhirConditionStage;
begin
  result := TFhirConditionStage(ObjectByIndex[index]);
end;

function TFhirConditionStageList.IndexOf(value: TFhirConditionStage): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConditionStageList.Insert(index: Integer): TFhirConditionStage;
begin
  result := TFhirConditionStage.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConditionStageList.InsertItem(index: Integer; value: TFhirConditionStage);
begin
  assert(value is TFhirConditionStage);
  Inherited Insert(index, value);
end;

function TFhirConditionStageList.Item(index: Integer): TFhirConditionStage;
begin
  result := TFhirConditionStage(ObjectByIndex[index]);
end;

function TFhirConditionStageList.Link: TFhirConditionStageList;
begin
  result := TFhirConditionStageList(inherited Link);
end;

procedure TFhirConditionStageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConditionStageList.SetItemByIndex(index: Integer; value: TFhirConditionStage);
begin
  assert(value is TFhirConditionStage);
  FhirConditionStages[index] := value;
end;

procedure TFhirConditionStageList.SetItemN(index: Integer; value: TFhirConditionStage);
begin
  assert(value is TFhirConditionStage);
  ObjectByIndex[index] := value;
end;

{ TFhirConditionEvidence }

constructor TFhirConditionEvidence.Create;
begin
  inherited;
  FDetailList := TFhirResourceReferenceList{Resource}.Create;
end;

destructor TFhirConditionEvidence.Destroy;
begin
  FCode.free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirConditionEvidence.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirConditionEvidence(oSource).code.Clone;
  FDetailList.Assign(TFhirConditionEvidence(oSource).FDetailList);
end;

procedure TFhirConditionEvidence.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'detail') Then
     list.addAll(FDetailList);
end;

procedure TFhirConditionEvidence.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', 'Resource(Any)', FDetailList.Link)){3};
end;

function TFhirConditionEvidence.Link : TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(inherited Link);
end;

function TFhirConditionEvidence.Clone : TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(inherited Clone);
end;

{ TFhirConditionEvidence }

Procedure TFhirConditionEvidence.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;


{ TFhirConditionEvidenceList }
procedure TFhirConditionEvidenceList.AddItem(value: TFhirConditionEvidence);
begin
  assert(value.ClassName = 'TFhirConditionEvidence', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConditionEvidence');
  add(value);
end;


function TFhirConditionEvidenceList.Append: TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConditionEvidenceList.ClearItems;
begin
  Clear;
end;

function TFhirConditionEvidenceList.Clone: TFhirConditionEvidenceList;
begin
  result := TFhirConditionEvidenceList(inherited Clone);
end;

function TFhirConditionEvidenceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConditionEvidenceList.GetItemN(index: Integer): TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(ObjectByIndex[index]);
end;

function TFhirConditionEvidenceList.IndexOf(value: TFhirConditionEvidence): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConditionEvidenceList.Insert(index: Integer): TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConditionEvidenceList.InsertItem(index: Integer; value: TFhirConditionEvidence);
begin
  assert(value is TFhirConditionEvidence);
  Inherited Insert(index, value);
end;

function TFhirConditionEvidenceList.Item(index: Integer): TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(ObjectByIndex[index]);
end;

function TFhirConditionEvidenceList.Link: TFhirConditionEvidenceList;
begin
  result := TFhirConditionEvidenceList(inherited Link);
end;

procedure TFhirConditionEvidenceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConditionEvidenceList.SetItemByIndex(index: Integer; value: TFhirConditionEvidence);
begin
  assert(value is TFhirConditionEvidence);
  FhirConditionEvidences[index] := value;
end;

procedure TFhirConditionEvidenceList.SetItemN(index: Integer; value: TFhirConditionEvidence);
begin
  assert(value is TFhirConditionEvidence);
  ObjectByIndex[index] := value;
end;

{ TFhirConditionLocation }

constructor TFhirConditionLocation.Create;
begin
  inherited;
end;

destructor TFhirConditionLocation.Destroy;
begin
  FCode.free;
  FDetail.free;
  inherited;
end;

procedure TFhirConditionLocation.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirConditionLocation(oSource).code.Clone;
  detail := TFhirConditionLocation(oSource).detail.Clone;
end;

procedure TFhirConditionLocation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'detail') Then
     list.add(Detail.Link);
end;

procedure TFhirConditionLocation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', 'string', FDetail.Link.Link));{2}
end;

function TFhirConditionLocation.Link : TFhirConditionLocation;
begin
  result := TFhirConditionLocation(inherited Link);
end;

function TFhirConditionLocation.Clone : TFhirConditionLocation;
begin
  result := TFhirConditionLocation(inherited Clone);
end;

{ TFhirConditionLocation }

Procedure TFhirConditionLocation.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirConditionLocation.SetDetail(value : TFhirString);
begin
  FDetail.free;
  FDetail := value;
end;

Function TFhirConditionLocation.GetDetailST : String;
begin
  if FDetail = nil then
    result := ''
  else
    result := Detail.value;
end;

Procedure TFhirConditionLocation.SetDetailST(value : String);
begin
  if value <> '' then
  begin
    if FDetail = nil then
      FDetail := TFhirString.create;
    FDetail.value := value
  end
  else if FDetail <> nil then
    FDetail.value := '';
end;


{ TFhirConditionLocationList }
procedure TFhirConditionLocationList.AddItem(value: TFhirConditionLocation);
begin
  assert(value.ClassName = 'TFhirConditionLocation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConditionLocation');
  add(value);
end;


function TFhirConditionLocationList.Append: TFhirConditionLocation;
begin
  result := TFhirConditionLocation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConditionLocationList.ClearItems;
begin
  Clear;
end;

function TFhirConditionLocationList.Clone: TFhirConditionLocationList;
begin
  result := TFhirConditionLocationList(inherited Clone);
end;

function TFhirConditionLocationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConditionLocationList.GetItemN(index: Integer): TFhirConditionLocation;
begin
  result := TFhirConditionLocation(ObjectByIndex[index]);
end;

function TFhirConditionLocationList.IndexOf(value: TFhirConditionLocation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConditionLocationList.Insert(index: Integer): TFhirConditionLocation;
begin
  result := TFhirConditionLocation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConditionLocationList.InsertItem(index: Integer; value: TFhirConditionLocation);
begin
  assert(value is TFhirConditionLocation);
  Inherited Insert(index, value);
end;

function TFhirConditionLocationList.Item(index: Integer): TFhirConditionLocation;
begin
  result := TFhirConditionLocation(ObjectByIndex[index]);
end;

function TFhirConditionLocationList.Link: TFhirConditionLocationList;
begin
  result := TFhirConditionLocationList(inherited Link);
end;

procedure TFhirConditionLocationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConditionLocationList.SetItemByIndex(index: Integer; value: TFhirConditionLocation);
begin
  assert(value is TFhirConditionLocation);
  FhirConditionLocations[index] := value;
end;

procedure TFhirConditionLocationList.SetItemN(index: Integer; value: TFhirConditionLocation);
begin
  assert(value is TFhirConditionLocation);
  ObjectByIndex[index] := value;
end;

{ TFhirConditionRelatedItem }

constructor TFhirConditionRelatedItem.Create;
begin
  inherited;
end;

destructor TFhirConditionRelatedItem.Destroy;
begin
  FType_.free;
  FCode.free;
  FTarget.free;
  inherited;
end;

procedure TFhirConditionRelatedItem.Assign(oSource : TAdvObject);
begin
  inherited;
  FType_ := TFhirConditionRelatedItem(oSource).FType_.Link;
  code := TFhirConditionRelatedItem(oSource).code.Clone;
  target := TFhirConditionRelatedItem(oSource).target.Clone;
end;

procedure TFhirConditionRelatedItem.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.add(FType_.Link);
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'target') Then
     list.add(Target.Link);
end;

procedure TFhirConditionRelatedItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', 'Resource(Condition|Procedure|MedicationAdministration|Immunization|MedicationStatement)', FTarget.Link.Link));{2}
end;

function TFhirConditionRelatedItem.Link : TFhirConditionRelatedItem;
begin
  result := TFhirConditionRelatedItem(inherited Link);
end;

function TFhirConditionRelatedItem.Clone : TFhirConditionRelatedItem;
begin
  result := TFhirConditionRelatedItem(inherited Clone);
end;

{ TFhirConditionRelatedItem }

Procedure TFhirConditionRelatedItem.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirConditionRelatedItem.GetType_ST : TFhirConditionRelationshipType;
begin
  if FType_ = nil then
    result := TFhirConditionRelationshipType(0)
  else
    result := TFhirConditionRelationshipType(StringArrayIndexOf(CODES_TFhirConditionRelationshipType, Type_.value));
end;

Procedure TFhirConditionRelatedItem.SetType_ST(value : TFhirConditionRelationshipType);
begin
  if ord(value) = 0 then
    Type_ := nil
  else
    Type_ := TFhirEnum.create(CODES_TFhirConditionRelationshipType[value]);
end;

Procedure TFhirConditionRelatedItem.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirConditionRelatedItem.SetTarget(value : TFhirResourceReference{Resource});
begin
  FTarget.free;
  FTarget := value;
end;


{ TFhirConditionRelatedItemList }
procedure TFhirConditionRelatedItemList.AddItem(value: TFhirConditionRelatedItem);
begin
  assert(value.ClassName = 'TFhirConditionRelatedItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConditionRelatedItem');
  add(value);
end;


function TFhirConditionRelatedItemList.Append: TFhirConditionRelatedItem;
begin
  result := TFhirConditionRelatedItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConditionRelatedItemList.ClearItems;
begin
  Clear;
end;

function TFhirConditionRelatedItemList.Clone: TFhirConditionRelatedItemList;
begin
  result := TFhirConditionRelatedItemList(inherited Clone);
end;

function TFhirConditionRelatedItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConditionRelatedItemList.GetItemN(index: Integer): TFhirConditionRelatedItem;
begin
  result := TFhirConditionRelatedItem(ObjectByIndex[index]);
end;

function TFhirConditionRelatedItemList.IndexOf(value: TFhirConditionRelatedItem): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConditionRelatedItemList.Insert(index: Integer): TFhirConditionRelatedItem;
begin
  result := TFhirConditionRelatedItem.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConditionRelatedItemList.InsertItem(index: Integer; value: TFhirConditionRelatedItem);
begin
  assert(value is TFhirConditionRelatedItem);
  Inherited Insert(index, value);
end;

function TFhirConditionRelatedItemList.Item(index: Integer): TFhirConditionRelatedItem;
begin
  result := TFhirConditionRelatedItem(ObjectByIndex[index]);
end;

function TFhirConditionRelatedItemList.Link: TFhirConditionRelatedItemList;
begin
  result := TFhirConditionRelatedItemList(inherited Link);
end;

procedure TFhirConditionRelatedItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConditionRelatedItemList.SetItemByIndex(index: Integer; value: TFhirConditionRelatedItem);
begin
  assert(value is TFhirConditionRelatedItem);
  FhirConditionRelatedItems[index] := value;
end;

procedure TFhirConditionRelatedItemList.SetItemN(index: Integer; value: TFhirConditionRelatedItem);
begin
  assert(value is TFhirConditionRelatedItem);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceSoftware }

constructor TFhirConformanceSoftware.Create;
begin
  inherited;
end;

destructor TFhirConformanceSoftware.Destroy;
begin
  FName.free;
  FVersion.free;
  FReleaseDate.free;
  inherited;
end;

procedure TFhirConformanceSoftware.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirConformanceSoftware(oSource).name.Clone;
  version := TFhirConformanceSoftware(oSource).version.Clone;
  releaseDate := TFhirConformanceSoftware(oSource).releaseDate.Clone;
end;

procedure TFhirConformanceSoftware.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'version') Then
     list.add(Version.Link);
  if (child_name = 'releaseDate') Then
     list.add(ReleaseDate.Link);
end;

procedure TFhirConformanceSoftware.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', FVersion.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'releaseDate', 'dateTime', FReleaseDate.Link.Link));{2}
end;

function TFhirConformanceSoftware.Link : TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware(inherited Link);
end;

function TFhirConformanceSoftware.Clone : TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware(inherited Clone);
end;

{ TFhirConformanceSoftware }

Procedure TFhirConformanceSoftware.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirConformanceSoftware.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirConformanceSoftware.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirConformanceSoftware.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirConformanceSoftware.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := Version.value;
end;

Procedure TFhirConformanceSoftware.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirConformanceSoftware.SetReleaseDate(value : TFhirDateTime);
begin
  FReleaseDate.free;
  FReleaseDate := value;
end;

Function TFhirConformanceSoftware.GetReleaseDateST : TDateAndTime;
begin
  if FReleaseDate = nil then
    result := nil
  else
    result := ReleaseDate.value;
end;

Procedure TFhirConformanceSoftware.SetReleaseDateST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FReleaseDate = nil then
      FReleaseDate := TFhirDateTime.create;
    FReleaseDate.value := value
  end
  else if FReleaseDate <> nil then
    FReleaseDate.value := nil;
end;


{ TFhirConformanceSoftwareList }
procedure TFhirConformanceSoftwareList.AddItem(value: TFhirConformanceSoftware);
begin
  assert(value.ClassName = 'TFhirConformanceSoftware', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceSoftware');
  add(value);
end;


function TFhirConformanceSoftwareList.Append: TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceSoftwareList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceSoftwareList.Clone: TFhirConformanceSoftwareList;
begin
  result := TFhirConformanceSoftwareList(inherited Clone);
end;

function TFhirConformanceSoftwareList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceSoftwareList.GetItemN(index: Integer): TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware(ObjectByIndex[index]);
end;

function TFhirConformanceSoftwareList.IndexOf(value: TFhirConformanceSoftware): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceSoftwareList.Insert(index: Integer): TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceSoftwareList.InsertItem(index: Integer; value: TFhirConformanceSoftware);
begin
  assert(value is TFhirConformanceSoftware);
  Inherited Insert(index, value);
end;

function TFhirConformanceSoftwareList.Item(index: Integer): TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware(ObjectByIndex[index]);
end;

function TFhirConformanceSoftwareList.Link: TFhirConformanceSoftwareList;
begin
  result := TFhirConformanceSoftwareList(inherited Link);
end;

procedure TFhirConformanceSoftwareList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceSoftwareList.SetItemByIndex(index: Integer; value: TFhirConformanceSoftware);
begin
  assert(value is TFhirConformanceSoftware);
  FhirConformanceSoftwares[index] := value;
end;

procedure TFhirConformanceSoftwareList.SetItemN(index: Integer; value: TFhirConformanceSoftware);
begin
  assert(value is TFhirConformanceSoftware);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceImplementation }

constructor TFhirConformanceImplementation.Create;
begin
  inherited;
end;

destructor TFhirConformanceImplementation.Destroy;
begin
  FDescription.free;
  FUrl.free;
  inherited;
end;

procedure TFhirConformanceImplementation.Assign(oSource : TAdvObject);
begin
  inherited;
  description := TFhirConformanceImplementation(oSource).description.Clone;
  url := TFhirConformanceImplementation(oSource).url.Clone;
end;

procedure TFhirConformanceImplementation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(Description.Link);
  if (child_name = 'url') Then
     list.add(Url.Link);
end;

procedure TFhirConformanceImplementation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', FUrl.Link.Link));{2}
end;

function TFhirConformanceImplementation.Link : TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation(inherited Link);
end;

function TFhirConformanceImplementation.Clone : TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation(inherited Clone);
end;

{ TFhirConformanceImplementation }

Procedure TFhirConformanceImplementation.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirConformanceImplementation.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := Description.value;
end;

Procedure TFhirConformanceImplementation.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirConformanceImplementation.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirConformanceImplementation.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := Url.value;
end;

Procedure TFhirConformanceImplementation.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;


{ TFhirConformanceImplementationList }
procedure TFhirConformanceImplementationList.AddItem(value: TFhirConformanceImplementation);
begin
  assert(value.ClassName = 'TFhirConformanceImplementation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceImplementation');
  add(value);
end;


function TFhirConformanceImplementationList.Append: TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceImplementationList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceImplementationList.Clone: TFhirConformanceImplementationList;
begin
  result := TFhirConformanceImplementationList(inherited Clone);
end;

function TFhirConformanceImplementationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceImplementationList.GetItemN(index: Integer): TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation(ObjectByIndex[index]);
end;

function TFhirConformanceImplementationList.IndexOf(value: TFhirConformanceImplementation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceImplementationList.Insert(index: Integer): TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceImplementationList.InsertItem(index: Integer; value: TFhirConformanceImplementation);
begin
  assert(value is TFhirConformanceImplementation);
  Inherited Insert(index, value);
end;

function TFhirConformanceImplementationList.Item(index: Integer): TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation(ObjectByIndex[index]);
end;

function TFhirConformanceImplementationList.Link: TFhirConformanceImplementationList;
begin
  result := TFhirConformanceImplementationList(inherited Link);
end;

procedure TFhirConformanceImplementationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceImplementationList.SetItemByIndex(index: Integer; value: TFhirConformanceImplementation);
begin
  assert(value is TFhirConformanceImplementation);
  FhirConformanceImplementations[index] := value;
end;

procedure TFhirConformanceImplementationList.SetItemN(index: Integer; value: TFhirConformanceImplementation);
begin
  assert(value is TFhirConformanceImplementation);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRest }

constructor TFhirConformanceRest.Create;
begin
  inherited;
  FResourceList := TFhirConformanceRestResourceList.Create;
  FOperationList := TFhirConformanceRestOperationList.Create;
  FQueryList := TFhirConformanceRestQueryList.Create;
  FDocumentMailboxList := TFhirUriList.Create;
end;

destructor TFhirConformanceRest.Destroy;
begin
  FMode.free;
  FDocumentation.free;
  FSecurity.free;
  FResourceList.Free;
  FOperationList.Free;
  FQueryList.Free;
  FDocumentMailboxList.Free;
  inherited;
end;

procedure TFhirConformanceRest.Assign(oSource : TAdvObject);
begin
  inherited;
  FMode := TFhirConformanceRest(oSource).FMode.Link;
  documentation := TFhirConformanceRest(oSource).documentation.Clone;
  security := TFhirConformanceRest(oSource).security.Clone;
  FResourceList.Assign(TFhirConformanceRest(oSource).FResourceList);
  FOperationList.Assign(TFhirConformanceRest(oSource).FOperationList);
  FQueryList.Assign(TFhirConformanceRest(oSource).FQueryList);
  FDocumentMailboxList.Assign(TFhirConformanceRest(oSource).FDocumentMailboxList);
end;

procedure TFhirConformanceRest.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.add(FMode.Link);
  if (child_name = 'documentation') Then
     list.add(Documentation.Link);
  if (child_name = 'security') Then
     list.add(Security.Link);
  if (child_name = 'resource') Then
     list.addAll(FResourceList);
  if (child_name = 'operation') Then
     list.addAll(FOperationList);
  if (child_name = 'query') Then
     list.addAll(FQueryList);
  if (child_name = 'documentMailbox') Then
     list.addAll(FDocumentMailboxList);
end;

procedure TFhirConformanceRest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'security', '', FSecurity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'resource', '', FResourceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'operation', '', FOperationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'query', '', FQueryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'documentMailbox', 'uri', FDocumentMailboxList.Link)){3};
end;

function TFhirConformanceRest.Link : TFhirConformanceRest;
begin
  result := TFhirConformanceRest(inherited Link);
end;

function TFhirConformanceRest.Clone : TFhirConformanceRest;
begin
  result := TFhirConformanceRest(inherited Clone);
end;

{ TFhirConformanceRest }

Procedure TFhirConformanceRest.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirConformanceRest.GetModeST : TFhirRestfulConformanceMode;
begin
  if FMode = nil then
    result := TFhirRestfulConformanceMode(0)
  else
    result := TFhirRestfulConformanceMode(StringArrayIndexOf(CODES_TFhirRestfulConformanceMode, Mode.value));
end;

Procedure TFhirConformanceRest.SetModeST(value : TFhirRestfulConformanceMode);
begin
  if ord(value) = 0 then
    Mode := nil
  else
    Mode := TFhirEnum.create(CODES_TFhirRestfulConformanceMode[value]);
end;

Procedure TFhirConformanceRest.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceRest.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := Documentation.value;
end;

Procedure TFhirConformanceRest.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

Procedure TFhirConformanceRest.SetSecurity(value : TFhirConformanceRestSecurity);
begin
  FSecurity.free;
  FSecurity := value;
end;


{ TFhirConformanceRestList }
procedure TFhirConformanceRestList.AddItem(value: TFhirConformanceRest);
begin
  assert(value.ClassName = 'TFhirConformanceRest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRest');
  add(value);
end;


function TFhirConformanceRestList.Append: TFhirConformanceRest;
begin
  result := TFhirConformanceRest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestList.Clone: TFhirConformanceRestList;
begin
  result := TFhirConformanceRestList(inherited Clone);
end;

function TFhirConformanceRestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestList.GetItemN(index: Integer): TFhirConformanceRest;
begin
  result := TFhirConformanceRest(ObjectByIndex[index]);
end;

function TFhirConformanceRestList.IndexOf(value: TFhirConformanceRest): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceRestList.Insert(index: Integer): TFhirConformanceRest;
begin
  result := TFhirConformanceRest.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestList.InsertItem(index: Integer; value: TFhirConformanceRest);
begin
  assert(value is TFhirConformanceRest);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestList.Item(index: Integer): TFhirConformanceRest;
begin
  result := TFhirConformanceRest(ObjectByIndex[index]);
end;

function TFhirConformanceRestList.Link: TFhirConformanceRestList;
begin
  result := TFhirConformanceRestList(inherited Link);
end;

procedure TFhirConformanceRestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestList.SetItemByIndex(index: Integer; value: TFhirConformanceRest);
begin
  assert(value is TFhirConformanceRest);
  FhirConformanceRests[index] := value;
end;

procedure TFhirConformanceRestList.SetItemN(index: Integer; value: TFhirConformanceRest);
begin
  assert(value is TFhirConformanceRest);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestSecurity }

constructor TFhirConformanceRestSecurity.Create;
begin
  inherited;
  FServiceList := TFhirCodeableConceptList.Create;
  FCertificateList := TFhirConformanceRestSecurityCertificateList.Create;
end;

destructor TFhirConformanceRestSecurity.Destroy;
begin
  FCors.free;
  FServiceList.Free;
  FDescription.free;
  FCertificateList.Free;
  inherited;
end;

procedure TFhirConformanceRestSecurity.Assign(oSource : TAdvObject);
begin
  inherited;
  cors := TFhirConformanceRestSecurity(oSource).cors.Clone;
  FServiceList.Assign(TFhirConformanceRestSecurity(oSource).FServiceList);
  description := TFhirConformanceRestSecurity(oSource).description.Clone;
  FCertificateList.Assign(TFhirConformanceRestSecurity(oSource).FCertificateList);
end;

procedure TFhirConformanceRestSecurity.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'cors') Then
     list.add(Cors.Link);
  if (child_name = 'service') Then
     list.addAll(FServiceList);
  if (child_name = 'description') Then
     list.add(Description.Link);
  if (child_name = 'certificate') Then
     list.addAll(FCertificateList);
end;

procedure TFhirConformanceRestSecurity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'cors', 'boolean', FCors.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'service', 'CodeableConcept', FServiceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'certificate', '', FCertificateList.Link)){3};
end;

function TFhirConformanceRestSecurity.Link : TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity(inherited Link);
end;

function TFhirConformanceRestSecurity.Clone : TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity(inherited Clone);
end;

{ TFhirConformanceRestSecurity }

Procedure TFhirConformanceRestSecurity.SetCors(value : TFhirBoolean);
begin
  FCors.free;
  FCors := value;
end;

Function TFhirConformanceRestSecurity.GetCorsST : Boolean;
begin
  if FCors = nil then
    result := false
  else
    result := Cors.value;
end;

Procedure TFhirConformanceRestSecurity.SetCorsST(value : Boolean);
begin
  if FCors = nil then
    FCors := TFhirBoolean.create;
  FCors.value := value
end;

Procedure TFhirConformanceRestSecurity.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirConformanceRestSecurity.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := Description.value;
end;

Procedure TFhirConformanceRestSecurity.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;


{ TFhirConformanceRestSecurityList }
procedure TFhirConformanceRestSecurityList.AddItem(value: TFhirConformanceRestSecurity);
begin
  assert(value.ClassName = 'TFhirConformanceRestSecurity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestSecurity');
  add(value);
end;


function TFhirConformanceRestSecurityList.Append: TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestSecurityList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestSecurityList.Clone: TFhirConformanceRestSecurityList;
begin
  result := TFhirConformanceRestSecurityList(inherited Clone);
end;

function TFhirConformanceRestSecurityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestSecurityList.GetItemN(index: Integer): TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity(ObjectByIndex[index]);
end;

function TFhirConformanceRestSecurityList.IndexOf(value: TFhirConformanceRestSecurity): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceRestSecurityList.Insert(index: Integer): TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestSecurityList.InsertItem(index: Integer; value: TFhirConformanceRestSecurity);
begin
  assert(value is TFhirConformanceRestSecurity);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestSecurityList.Item(index: Integer): TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity(ObjectByIndex[index]);
end;

function TFhirConformanceRestSecurityList.Link: TFhirConformanceRestSecurityList;
begin
  result := TFhirConformanceRestSecurityList(inherited Link);
end;

procedure TFhirConformanceRestSecurityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestSecurityList.SetItemByIndex(index: Integer; value: TFhirConformanceRestSecurity);
begin
  assert(value is TFhirConformanceRestSecurity);
  FhirConformanceRestSecurities[index] := value;
end;

procedure TFhirConformanceRestSecurityList.SetItemN(index: Integer; value: TFhirConformanceRestSecurity);
begin
  assert(value is TFhirConformanceRestSecurity);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestSecurityCertificate }

constructor TFhirConformanceRestSecurityCertificate.Create;
begin
  inherited;
end;

destructor TFhirConformanceRestSecurityCertificate.Destroy;
begin
  FType_.free;
  FBlob.free;
  inherited;
end;

procedure TFhirConformanceRestSecurityCertificate.Assign(oSource : TAdvObject);
begin
  inherited;
  type_ := TFhirConformanceRestSecurityCertificate(oSource).type_.Clone;
  blob := TFhirConformanceRestSecurityCertificate(oSource).blob.Clone;
end;

procedure TFhirConformanceRestSecurityCertificate.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'blob') Then
     list.add(Blob.Link);
end;

procedure TFhirConformanceRestSecurityCertificate.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'blob', 'base64Binary', FBlob.Link.Link));{2}
end;

function TFhirConformanceRestSecurityCertificate.Link : TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate(inherited Link);
end;

function TFhirConformanceRestSecurityCertificate.Clone : TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate(inherited Clone);
end;

{ TFhirConformanceRestSecurityCertificate }

Procedure TFhirConformanceRestSecurityCertificate.SetType_(value : TFhirCode);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirConformanceRestSecurityCertificate.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := Type_.value;
end;

Procedure TFhirConformanceRestSecurityCertificate.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirCode.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirConformanceRestSecurityCertificate.SetBlob(value : TFhirBase64Binary);
begin
  FBlob.free;
  FBlob := value;
end;

Function TFhirConformanceRestSecurityCertificate.GetBlobST : String;
begin
  if FBlob = nil then
    result := ''
  else
    result := Blob.value;
end;

Procedure TFhirConformanceRestSecurityCertificate.SetBlobST(value : String);
begin
  if value <> '' then
  begin
    if FBlob = nil then
      FBlob := TFhirBase64Binary.create;
    FBlob.value := value
  end
  else if FBlob <> nil then
    FBlob.value := '';
end;


{ TFhirConformanceRestSecurityCertificateList }
procedure TFhirConformanceRestSecurityCertificateList.AddItem(value: TFhirConformanceRestSecurityCertificate);
begin
  assert(value.ClassName = 'TFhirConformanceRestSecurityCertificate', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestSecurityCertificate');
  add(value);
end;


function TFhirConformanceRestSecurityCertificateList.Append: TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestSecurityCertificateList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestSecurityCertificateList.Clone: TFhirConformanceRestSecurityCertificateList;
begin
  result := TFhirConformanceRestSecurityCertificateList(inherited Clone);
end;

function TFhirConformanceRestSecurityCertificateList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestSecurityCertificateList.GetItemN(index: Integer): TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate(ObjectByIndex[index]);
end;

function TFhirConformanceRestSecurityCertificateList.IndexOf(value: TFhirConformanceRestSecurityCertificate): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceRestSecurityCertificateList.Insert(index: Integer): TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestSecurityCertificateList.InsertItem(index: Integer; value: TFhirConformanceRestSecurityCertificate);
begin
  assert(value is TFhirConformanceRestSecurityCertificate);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestSecurityCertificateList.Item(index: Integer): TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate(ObjectByIndex[index]);
end;

function TFhirConformanceRestSecurityCertificateList.Link: TFhirConformanceRestSecurityCertificateList;
begin
  result := TFhirConformanceRestSecurityCertificateList(inherited Link);
end;

procedure TFhirConformanceRestSecurityCertificateList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestSecurityCertificateList.SetItemByIndex(index: Integer; value: TFhirConformanceRestSecurityCertificate);
begin
  assert(value is TFhirConformanceRestSecurityCertificate);
  FhirConformanceRestSecurityCertificates[index] := value;
end;

procedure TFhirConformanceRestSecurityCertificateList.SetItemN(index: Integer; value: TFhirConformanceRestSecurityCertificate);
begin
  assert(value is TFhirConformanceRestSecurityCertificate);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestResource }

constructor TFhirConformanceRestResource.Create;
begin
  inherited;
  FOperationList := TFhirConformanceRestResourceOperationList.Create;
  FSearchIncludeList := TFhirStringList.Create;
  FSearchParamList := TFhirConformanceRestResourceSearchParamList.Create;
end;

destructor TFhirConformanceRestResource.Destroy;
begin
  FType_.free;
  FProfile.free;
  FOperationList.Free;
  FReadHistory.free;
  FUpdateCreate.free;
  FSearchIncludeList.Free;
  FSearchParamList.Free;
  inherited;
end;

procedure TFhirConformanceRestResource.Assign(oSource : TAdvObject);
begin
  inherited;
  type_ := TFhirConformanceRestResource(oSource).type_.Clone;
  profile := TFhirConformanceRestResource(oSource).profile.Clone;
  FOperationList.Assign(TFhirConformanceRestResource(oSource).FOperationList);
  readHistory := TFhirConformanceRestResource(oSource).readHistory.Clone;
  updateCreate := TFhirConformanceRestResource(oSource).updateCreate.Clone;
  FSearchIncludeList.Assign(TFhirConformanceRestResource(oSource).FSearchIncludeList);
  FSearchParamList.Assign(TFhirConformanceRestResource(oSource).FSearchParamList);
end;

procedure TFhirConformanceRestResource.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'profile') Then
     list.add(Profile.Link);
  if (child_name = 'operation') Then
     list.addAll(FOperationList);
  if (child_name = 'readHistory') Then
     list.add(ReadHistory.Link);
  if (child_name = 'updateCreate') Then
     list.add(UpdateCreate.Link);
  if (child_name = 'searchInclude') Then
     list.addAll(FSearchIncludeList);
  if (child_name = 'searchParam') Then
     list.addAll(FSearchParamList);
end;

procedure TFhirConformanceRestResource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'profile', 'Resource(Profile)', FProfile.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'operation', '', FOperationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'readHistory', 'boolean', FReadHistory.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'updateCreate', 'boolean', FUpdateCreate.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'searchInclude', 'string', FSearchIncludeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'searchParam', '', FSearchParamList.Link)){3};
end;

function TFhirConformanceRestResource.Link : TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource(inherited Link);
end;

function TFhirConformanceRestResource.Clone : TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource(inherited Clone);
end;

{ TFhirConformanceRestResource }

Procedure TFhirConformanceRestResource.SetType_(value : TFhirCode);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirConformanceRestResource.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := Type_.value;
end;

Procedure TFhirConformanceRestResource.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirCode.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirConformanceRestResource.SetProfile(value : TFhirResourceReference{TFhirProfile});
begin
  FProfile.free;
  FProfile := value;
end;

Procedure TFhirConformanceRestResource.SetReadHistory(value : TFhirBoolean);
begin
  FReadHistory.free;
  FReadHistory := value;
end;

Function TFhirConformanceRestResource.GetReadHistoryST : Boolean;
begin
  if FReadHistory = nil then
    result := false
  else
    result := ReadHistory.value;
end;

Procedure TFhirConformanceRestResource.SetReadHistoryST(value : Boolean);
begin
  if FReadHistory = nil then
    FReadHistory := TFhirBoolean.create;
  FReadHistory.value := value
end;

Procedure TFhirConformanceRestResource.SetUpdateCreate(value : TFhirBoolean);
begin
  FUpdateCreate.free;
  FUpdateCreate := value;
end;

Function TFhirConformanceRestResource.GetUpdateCreateST : Boolean;
begin
  if FUpdateCreate = nil then
    result := false
  else
    result := UpdateCreate.value;
end;

Procedure TFhirConformanceRestResource.SetUpdateCreateST(value : Boolean);
begin
  if FUpdateCreate = nil then
    FUpdateCreate := TFhirBoolean.create;
  FUpdateCreate.value := value
end;


{ TFhirConformanceRestResourceList }
procedure TFhirConformanceRestResourceList.AddItem(value: TFhirConformanceRestResource);
begin
  assert(value.ClassName = 'TFhirConformanceRestResource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestResource');
  add(value);
end;


function TFhirConformanceRestResourceList.Append: TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestResourceList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestResourceList.Clone: TFhirConformanceRestResourceList;
begin
  result := TFhirConformanceRestResourceList(inherited Clone);
end;

function TFhirConformanceRestResourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestResourceList.GetItemN(index: Integer): TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource(ObjectByIndex[index]);
end;

function TFhirConformanceRestResourceList.IndexOf(value: TFhirConformanceRestResource): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceRestResourceList.Insert(index: Integer): TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestResourceList.InsertItem(index: Integer; value: TFhirConformanceRestResource);
begin
  assert(value is TFhirConformanceRestResource);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestResourceList.Item(index: Integer): TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource(ObjectByIndex[index]);
end;

function TFhirConformanceRestResourceList.Link: TFhirConformanceRestResourceList;
begin
  result := TFhirConformanceRestResourceList(inherited Link);
end;

procedure TFhirConformanceRestResourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestResourceList.SetItemByIndex(index: Integer; value: TFhirConformanceRestResource);
begin
  assert(value is TFhirConformanceRestResource);
  FhirConformanceRestResources[index] := value;
end;

procedure TFhirConformanceRestResourceList.SetItemN(index: Integer; value: TFhirConformanceRestResource);
begin
  assert(value is TFhirConformanceRestResource);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestResourceOperation }

constructor TFhirConformanceRestResourceOperation.Create;
begin
  inherited;
end;

destructor TFhirConformanceRestResourceOperation.Destroy;
begin
  FCode.free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirConformanceRestResourceOperation.Assign(oSource : TAdvObject);
begin
  inherited;
  FCode := TFhirConformanceRestResourceOperation(oSource).FCode.Link;
  documentation := TFhirConformanceRestResourceOperation(oSource).documentation.Clone;
end;

procedure TFhirConformanceRestResourceOperation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'documentation') Then
     list.add(Documentation.Link);
end;

procedure TFhirConformanceRestResourceOperation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link.Link));{2}
end;

function TFhirConformanceRestResourceOperation.Link : TFhirConformanceRestResourceOperation;
begin
  result := TFhirConformanceRestResourceOperation(inherited Link);
end;

function TFhirConformanceRestResourceOperation.Clone : TFhirConformanceRestResourceOperation;
begin
  result := TFhirConformanceRestResourceOperation(inherited Clone);
end;

{ TFhirConformanceRestResourceOperation }

Procedure TFhirConformanceRestResourceOperation.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirConformanceRestResourceOperation.GetCodeST : TFhirTypeRestfulOperation;
begin
  if FCode = nil then
    result := TFhirTypeRestfulOperation(0)
  else
    result := TFhirTypeRestfulOperation(StringArrayIndexOf(CODES_TFhirTypeRestfulOperation, Code.value));
end;

Procedure TFhirConformanceRestResourceOperation.SetCodeST(value : TFhirTypeRestfulOperation);
begin
  if ord(value) = 0 then
    Code := nil
  else
    Code := TFhirEnum.create(CODES_TFhirTypeRestfulOperation[value]);
end;

Procedure TFhirConformanceRestResourceOperation.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceRestResourceOperation.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := Documentation.value;
end;

Procedure TFhirConformanceRestResourceOperation.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;


{ TFhirConformanceRestResourceOperationList }
procedure TFhirConformanceRestResourceOperationList.AddItem(value: TFhirConformanceRestResourceOperation);
begin
  assert(value.ClassName = 'TFhirConformanceRestResourceOperation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestResourceOperation');
  add(value);
end;


function TFhirConformanceRestResourceOperationList.Append: TFhirConformanceRestResourceOperation;
begin
  result := TFhirConformanceRestResourceOperation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestResourceOperationList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestResourceOperationList.Clone: TFhirConformanceRestResourceOperationList;
begin
  result := TFhirConformanceRestResourceOperationList(inherited Clone);
end;

function TFhirConformanceRestResourceOperationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestResourceOperationList.GetItemN(index: Integer): TFhirConformanceRestResourceOperation;
begin
  result := TFhirConformanceRestResourceOperation(ObjectByIndex[index]);
end;

function TFhirConformanceRestResourceOperationList.IndexOf(value: TFhirConformanceRestResourceOperation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceRestResourceOperationList.Insert(index: Integer): TFhirConformanceRestResourceOperation;
begin
  result := TFhirConformanceRestResourceOperation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestResourceOperationList.InsertItem(index: Integer; value: TFhirConformanceRestResourceOperation);
begin
  assert(value is TFhirConformanceRestResourceOperation);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestResourceOperationList.Item(index: Integer): TFhirConformanceRestResourceOperation;
begin
  result := TFhirConformanceRestResourceOperation(ObjectByIndex[index]);
end;

function TFhirConformanceRestResourceOperationList.Link: TFhirConformanceRestResourceOperationList;
begin
  result := TFhirConformanceRestResourceOperationList(inherited Link);
end;

procedure TFhirConformanceRestResourceOperationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestResourceOperationList.SetItemByIndex(index: Integer; value: TFhirConformanceRestResourceOperation);
begin
  assert(value is TFhirConformanceRestResourceOperation);
  FhirConformanceRestResourceOperations[index] := value;
end;

procedure TFhirConformanceRestResourceOperationList.SetItemN(index: Integer; value: TFhirConformanceRestResourceOperation);
begin
  assert(value is TFhirConformanceRestResourceOperation);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestResourceSearchParam }

constructor TFhirConformanceRestResourceSearchParam.Create;
begin
  inherited;
  FTargetList := TFhirCodeList.Create;
  FChainList := TFhirStringList.Create;
end;

destructor TFhirConformanceRestResourceSearchParam.Destroy;
begin
  FName.free;
  FDefinition.free;
  FType_.free;
  FDocumentation.free;
  FTargetList.Free;
  FChainList.Free;
  inherited;
end;

procedure TFhirConformanceRestResourceSearchParam.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirConformanceRestResourceSearchParam(oSource).name.Clone;
  definition := TFhirConformanceRestResourceSearchParam(oSource).definition.Clone;
  FType_ := TFhirConformanceRestResourceSearchParam(oSource).FType_.Link;
  documentation := TFhirConformanceRestResourceSearchParam(oSource).documentation.Clone;
  FTargetList.Assign(TFhirConformanceRestResourceSearchParam(oSource).FTargetList);
  FChainList.Assign(TFhirConformanceRestResourceSearchParam(oSource).FChainList);
end;

procedure TFhirConformanceRestResourceSearchParam.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'definition') Then
     list.add(Definition.Link);
  if (child_name = 'type_') Then
     list.add(FType_.Link);
  if (child_name = 'documentation') Then
     list.add(Documentation.Link);
  if (child_name = 'target') Then
     list.addAll(FTargetList);
  if (child_name = 'chain') Then
     list.addAll(FChainList);
end;

procedure TFhirConformanceRestResourceSearchParam.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'definition', 'uri', FDefinition.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', 'code', FTargetList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'chain', 'string', FChainList.Link)){3};
end;

function TFhirConformanceRestResourceSearchParam.Link : TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam(inherited Link);
end;

function TFhirConformanceRestResourceSearchParam.Clone : TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam(inherited Clone);
end;

{ TFhirConformanceRestResourceSearchParam }

Procedure TFhirConformanceRestResourceSearchParam.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirConformanceRestResourceSearchParam.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirConformanceRestResourceSearchParam.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirConformanceRestResourceSearchParam.SetDefinition(value : TFhirUri);
begin
  FDefinition.free;
  FDefinition := value;
end;

Function TFhirConformanceRestResourceSearchParam.GetDefinitionST : String;
begin
  if FDefinition = nil then
    result := ''
  else
    result := Definition.value;
end;

Procedure TFhirConformanceRestResourceSearchParam.SetDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FDefinition = nil then
      FDefinition := TFhirUri.create;
    FDefinition.value := value
  end
  else if FDefinition <> nil then
    FDefinition.value := '';
end;

Procedure TFhirConformanceRestResourceSearchParam.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirConformanceRestResourceSearchParam.GetType_ST : TFhirSearchParamType;
begin
  if FType_ = nil then
    result := TFhirSearchParamType(0)
  else
    result := TFhirSearchParamType(StringArrayIndexOf(CODES_TFhirSearchParamType, Type_.value));
end;

Procedure TFhirConformanceRestResourceSearchParam.SetType_ST(value : TFhirSearchParamType);
begin
  if ord(value) = 0 then
    Type_ := nil
  else
    Type_ := TFhirEnum.create(CODES_TFhirSearchParamType[value]);
end;

Procedure TFhirConformanceRestResourceSearchParam.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceRestResourceSearchParam.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := Documentation.value;
end;

Procedure TFhirConformanceRestResourceSearchParam.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;


{ TFhirConformanceRestResourceSearchParamList }
procedure TFhirConformanceRestResourceSearchParamList.AddItem(value: TFhirConformanceRestResourceSearchParam);
begin
  assert(value.ClassName = 'TFhirConformanceRestResourceSearchParam', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestResourceSearchParam');
  add(value);
end;


function TFhirConformanceRestResourceSearchParamList.Append: TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestResourceSearchParamList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestResourceSearchParamList.Clone: TFhirConformanceRestResourceSearchParamList;
begin
  result := TFhirConformanceRestResourceSearchParamList(inherited Clone);
end;

function TFhirConformanceRestResourceSearchParamList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestResourceSearchParamList.GetItemN(index: Integer): TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam(ObjectByIndex[index]);
end;

function TFhirConformanceRestResourceSearchParamList.IndexOf(value: TFhirConformanceRestResourceSearchParam): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceRestResourceSearchParamList.Insert(index: Integer): TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestResourceSearchParamList.InsertItem(index: Integer; value: TFhirConformanceRestResourceSearchParam);
begin
  assert(value is TFhirConformanceRestResourceSearchParam);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestResourceSearchParamList.Item(index: Integer): TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam(ObjectByIndex[index]);
end;

function TFhirConformanceRestResourceSearchParamList.Link: TFhirConformanceRestResourceSearchParamList;
begin
  result := TFhirConformanceRestResourceSearchParamList(inherited Link);
end;

procedure TFhirConformanceRestResourceSearchParamList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestResourceSearchParamList.SetItemByIndex(index: Integer; value: TFhirConformanceRestResourceSearchParam);
begin
  assert(value is TFhirConformanceRestResourceSearchParam);
  FhirConformanceRestResourceSearchParams[index] := value;
end;

procedure TFhirConformanceRestResourceSearchParamList.SetItemN(index: Integer; value: TFhirConformanceRestResourceSearchParam);
begin
  assert(value is TFhirConformanceRestResourceSearchParam);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestOperation }

constructor TFhirConformanceRestOperation.Create;
begin
  inherited;
end;

destructor TFhirConformanceRestOperation.Destroy;
begin
  FCode.free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirConformanceRestOperation.Assign(oSource : TAdvObject);
begin
  inherited;
  FCode := TFhirConformanceRestOperation(oSource).FCode.Link;
  documentation := TFhirConformanceRestOperation(oSource).documentation.Clone;
end;

procedure TFhirConformanceRestOperation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'documentation') Then
     list.add(Documentation.Link);
end;

procedure TFhirConformanceRestOperation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link.Link));{2}
end;

function TFhirConformanceRestOperation.Link : TFhirConformanceRestOperation;
begin
  result := TFhirConformanceRestOperation(inherited Link);
end;

function TFhirConformanceRestOperation.Clone : TFhirConformanceRestOperation;
begin
  result := TFhirConformanceRestOperation(inherited Clone);
end;

{ TFhirConformanceRestOperation }

Procedure TFhirConformanceRestOperation.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirConformanceRestOperation.GetCodeST : TFhirSystemRestfulOperation;
begin
  if FCode = nil then
    result := TFhirSystemRestfulOperation(0)
  else
    result := TFhirSystemRestfulOperation(StringArrayIndexOf(CODES_TFhirSystemRestfulOperation, Code.value));
end;

Procedure TFhirConformanceRestOperation.SetCodeST(value : TFhirSystemRestfulOperation);
begin
  if ord(value) = 0 then
    Code := nil
  else
    Code := TFhirEnum.create(CODES_TFhirSystemRestfulOperation[value]);
end;

Procedure TFhirConformanceRestOperation.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceRestOperation.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := Documentation.value;
end;

Procedure TFhirConformanceRestOperation.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;


{ TFhirConformanceRestOperationList }
procedure TFhirConformanceRestOperationList.AddItem(value: TFhirConformanceRestOperation);
begin
  assert(value.ClassName = 'TFhirConformanceRestOperation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestOperation');
  add(value);
end;


function TFhirConformanceRestOperationList.Append: TFhirConformanceRestOperation;
begin
  result := TFhirConformanceRestOperation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestOperationList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestOperationList.Clone: TFhirConformanceRestOperationList;
begin
  result := TFhirConformanceRestOperationList(inherited Clone);
end;

function TFhirConformanceRestOperationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestOperationList.GetItemN(index: Integer): TFhirConformanceRestOperation;
begin
  result := TFhirConformanceRestOperation(ObjectByIndex[index]);
end;

function TFhirConformanceRestOperationList.IndexOf(value: TFhirConformanceRestOperation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceRestOperationList.Insert(index: Integer): TFhirConformanceRestOperation;
begin
  result := TFhirConformanceRestOperation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestOperationList.InsertItem(index: Integer; value: TFhirConformanceRestOperation);
begin
  assert(value is TFhirConformanceRestOperation);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestOperationList.Item(index: Integer): TFhirConformanceRestOperation;
begin
  result := TFhirConformanceRestOperation(ObjectByIndex[index]);
end;

function TFhirConformanceRestOperationList.Link: TFhirConformanceRestOperationList;
begin
  result := TFhirConformanceRestOperationList(inherited Link);
end;

procedure TFhirConformanceRestOperationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestOperationList.SetItemByIndex(index: Integer; value: TFhirConformanceRestOperation);
begin
  assert(value is TFhirConformanceRestOperation);
  FhirConformanceRestOperations[index] := value;
end;

procedure TFhirConformanceRestOperationList.SetItemN(index: Integer; value: TFhirConformanceRestOperation);
begin
  assert(value is TFhirConformanceRestOperation);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestQuery }

constructor TFhirConformanceRestQuery.Create;
begin
  inherited;
  FParameterList := TFhirConformanceRestResourceSearchParamList.Create;
end;

destructor TFhirConformanceRestQuery.Destroy;
begin
  FName.free;
  FDefinition.free;
  FDocumentation.free;
  FParameterList.Free;
  inherited;
end;

procedure TFhirConformanceRestQuery.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirConformanceRestQuery(oSource).name.Clone;
  definition := TFhirConformanceRestQuery(oSource).definition.Clone;
  documentation := TFhirConformanceRestQuery(oSource).documentation.Clone;
  FParameterList.Assign(TFhirConformanceRestQuery(oSource).FParameterList);
end;

procedure TFhirConformanceRestQuery.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'definition') Then
     list.add(Definition.Link);
  if (child_name = 'documentation') Then
     list.add(Documentation.Link);
  if (child_name = 'parameter') Then
     list.addAll(FParameterList);
end;

procedure TFhirConformanceRestQuery.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'definition', 'uri', FDefinition.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'parameter', '@Conformance.rest.resource.searchParam', FParameterList.Link)){3};
end;

function TFhirConformanceRestQuery.Link : TFhirConformanceRestQuery;
begin
  result := TFhirConformanceRestQuery(inherited Link);
end;

function TFhirConformanceRestQuery.Clone : TFhirConformanceRestQuery;
begin
  result := TFhirConformanceRestQuery(inherited Clone);
end;

{ TFhirConformanceRestQuery }

Procedure TFhirConformanceRestQuery.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirConformanceRestQuery.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirConformanceRestQuery.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirConformanceRestQuery.SetDefinition(value : TFhirUri);
begin
  FDefinition.free;
  FDefinition := value;
end;

Function TFhirConformanceRestQuery.GetDefinitionST : String;
begin
  if FDefinition = nil then
    result := ''
  else
    result := Definition.value;
end;

Procedure TFhirConformanceRestQuery.SetDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FDefinition = nil then
      FDefinition := TFhirUri.create;
    FDefinition.value := value
  end
  else if FDefinition <> nil then
    FDefinition.value := '';
end;

Procedure TFhirConformanceRestQuery.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceRestQuery.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := Documentation.value;
end;

Procedure TFhirConformanceRestQuery.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;


{ TFhirConformanceRestQueryList }
procedure TFhirConformanceRestQueryList.AddItem(value: TFhirConformanceRestQuery);
begin
  assert(value.ClassName = 'TFhirConformanceRestQuery', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestQuery');
  add(value);
end;


function TFhirConformanceRestQueryList.Append: TFhirConformanceRestQuery;
begin
  result := TFhirConformanceRestQuery.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestQueryList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestQueryList.Clone: TFhirConformanceRestQueryList;
begin
  result := TFhirConformanceRestQueryList(inherited Clone);
end;

function TFhirConformanceRestQueryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestQueryList.GetItemN(index: Integer): TFhirConformanceRestQuery;
begin
  result := TFhirConformanceRestQuery(ObjectByIndex[index]);
end;

function TFhirConformanceRestQueryList.IndexOf(value: TFhirConformanceRestQuery): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceRestQueryList.Insert(index: Integer): TFhirConformanceRestQuery;
begin
  result := TFhirConformanceRestQuery.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestQueryList.InsertItem(index: Integer; value: TFhirConformanceRestQuery);
begin
  assert(value is TFhirConformanceRestQuery);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestQueryList.Item(index: Integer): TFhirConformanceRestQuery;
begin
  result := TFhirConformanceRestQuery(ObjectByIndex[index]);
end;

function TFhirConformanceRestQueryList.Link: TFhirConformanceRestQueryList;
begin
  result := TFhirConformanceRestQueryList(inherited Link);
end;

procedure TFhirConformanceRestQueryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestQueryList.SetItemByIndex(index: Integer; value: TFhirConformanceRestQuery);
begin
  assert(value is TFhirConformanceRestQuery);
  FhirConformanceRestQueries[index] := value;
end;

procedure TFhirConformanceRestQueryList.SetItemN(index: Integer; value: TFhirConformanceRestQuery);
begin
  assert(value is TFhirConformanceRestQuery);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceMessaging }

constructor TFhirConformanceMessaging.Create;
begin
  inherited;
  FEventList := TFhirConformanceMessagingEventList.Create;
end;

destructor TFhirConformanceMessaging.Destroy;
begin
  FEndpoint.free;
  FReliableCache.free;
  FDocumentation.free;
  FEventList.Free;
  inherited;
end;

procedure TFhirConformanceMessaging.Assign(oSource : TAdvObject);
begin
  inherited;
  endpoint := TFhirConformanceMessaging(oSource).endpoint.Clone;
  reliableCache := TFhirConformanceMessaging(oSource).reliableCache.Clone;
  documentation := TFhirConformanceMessaging(oSource).documentation.Clone;
  FEventList.Assign(TFhirConformanceMessaging(oSource).FEventList);
end;

procedure TFhirConformanceMessaging.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'endpoint') Then
     list.add(Endpoint.Link);
  if (child_name = 'reliableCache') Then
     list.add(ReliableCache.Link);
  if (child_name = 'documentation') Then
     list.add(Documentation.Link);
  if (child_name = 'event') Then
     list.addAll(FEventList);
end;

procedure TFhirConformanceMessaging.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'endpoint', 'uri', FEndpoint.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reliableCache', 'integer', FReliableCache.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'event', '', FEventList.Link)){3};
end;

function TFhirConformanceMessaging.Link : TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging(inherited Link);
end;

function TFhirConformanceMessaging.Clone : TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging(inherited Clone);
end;

{ TFhirConformanceMessaging }

Procedure TFhirConformanceMessaging.SetEndpoint(value : TFhirUri);
begin
  FEndpoint.free;
  FEndpoint := value;
end;

Function TFhirConformanceMessaging.GetEndpointST : String;
begin
  if FEndpoint = nil then
    result := ''
  else
    result := Endpoint.value;
end;

Procedure TFhirConformanceMessaging.SetEndpointST(value : String);
begin
  if value <> '' then
  begin
    if FEndpoint = nil then
      FEndpoint := TFhirUri.create;
    FEndpoint.value := value
  end
  else if FEndpoint <> nil then
    FEndpoint.value := '';
end;

Procedure TFhirConformanceMessaging.SetReliableCache(value : TFhirInteger);
begin
  FReliableCache.free;
  FReliableCache := value;
end;

Function TFhirConformanceMessaging.GetReliableCacheST : String;
begin
  if FReliableCache = nil then
    result := ''
  else
    result := ReliableCache.value;
end;

Procedure TFhirConformanceMessaging.SetReliableCacheST(value : String);
begin
  if value <> '' then
  begin
    if FReliableCache = nil then
      FReliableCache := TFhirInteger.create;
    FReliableCache.value := value
  end
  else if FReliableCache <> nil then
    FReliableCache.value := '';
end;

Procedure TFhirConformanceMessaging.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceMessaging.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := Documentation.value;
end;

Procedure TFhirConformanceMessaging.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;


{ TFhirConformanceMessagingList }
procedure TFhirConformanceMessagingList.AddItem(value: TFhirConformanceMessaging);
begin
  assert(value.ClassName = 'TFhirConformanceMessaging', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceMessaging');
  add(value);
end;


function TFhirConformanceMessagingList.Append: TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceMessagingList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceMessagingList.Clone: TFhirConformanceMessagingList;
begin
  result := TFhirConformanceMessagingList(inherited Clone);
end;

function TFhirConformanceMessagingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceMessagingList.GetItemN(index: Integer): TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging(ObjectByIndex[index]);
end;

function TFhirConformanceMessagingList.IndexOf(value: TFhirConformanceMessaging): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceMessagingList.Insert(index: Integer): TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceMessagingList.InsertItem(index: Integer; value: TFhirConformanceMessaging);
begin
  assert(value is TFhirConformanceMessaging);
  Inherited Insert(index, value);
end;

function TFhirConformanceMessagingList.Item(index: Integer): TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging(ObjectByIndex[index]);
end;

function TFhirConformanceMessagingList.Link: TFhirConformanceMessagingList;
begin
  result := TFhirConformanceMessagingList(inherited Link);
end;

procedure TFhirConformanceMessagingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceMessagingList.SetItemByIndex(index: Integer; value: TFhirConformanceMessaging);
begin
  assert(value is TFhirConformanceMessaging);
  FhirConformanceMessagings[index] := value;
end;

procedure TFhirConformanceMessagingList.SetItemN(index: Integer; value: TFhirConformanceMessaging);
begin
  assert(value is TFhirConformanceMessaging);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceMessagingEvent }

constructor TFhirConformanceMessagingEvent.Create;
begin
  inherited;
  FProtocolList := TFhirCodingList.Create;
end;

destructor TFhirConformanceMessagingEvent.Destroy;
begin
  FCode.free;
  FCategory.free;
  FMode.free;
  FProtocolList.Free;
  FFocus.free;
  FRequest.free;
  FResponse.free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirConformanceMessagingEvent.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirConformanceMessagingEvent(oSource).code.Clone;
  FCategory := TFhirConformanceMessagingEvent(oSource).FCategory.Link;
  FMode := TFhirConformanceMessagingEvent(oSource).FMode.Link;
  FProtocolList.Assign(TFhirConformanceMessagingEvent(oSource).FProtocolList);
  focus := TFhirConformanceMessagingEvent(oSource).focus.Clone;
  request := TFhirConformanceMessagingEvent(oSource).request.Clone;
  response := TFhirConformanceMessagingEvent(oSource).response.Clone;
  documentation := TFhirConformanceMessagingEvent(oSource).documentation.Clone;
end;

procedure TFhirConformanceMessagingEvent.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'category') Then
     list.add(FCategory.Link);
  if (child_name = 'mode') Then
     list.add(FMode.Link);
  if (child_name = 'protocol') Then
     list.addAll(FProtocolList);
  if (child_name = 'focus') Then
     list.add(Focus.Link);
  if (child_name = 'request') Then
     list.add(Request.Link);
  if (child_name = 'response') Then
     list.add(Response.Link);
  if (child_name = 'documentation') Then
     list.add(Documentation.Link);
end;

procedure TFhirConformanceMessagingEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'Coding', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'code', FCategory.Link));{1}
  oList.add(TFHIRProperty.create(self, 'mode', 'code', FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'protocol', 'Coding', FProtocolList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'focus', 'code', FFocus.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'request', 'Resource(Profile)', FRequest.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'response', 'Resource(Profile)', FResponse.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link.Link));{2}
end;

function TFhirConformanceMessagingEvent.Link : TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent(inherited Link);
end;

function TFhirConformanceMessagingEvent.Clone : TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent(inherited Clone);
end;

{ TFhirConformanceMessagingEvent }

Procedure TFhirConformanceMessagingEvent.SetCode(value : TFhirCoding);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirConformanceMessagingEvent.SetCategory(value : TFhirEnum);
begin
  FCategory.free;
  FCategory := value;
end;

Function TFhirConformanceMessagingEvent.GetCategoryST : TFhirMessageSignificanceCategory;
begin
  if FCategory = nil then
    result := TFhirMessageSignificanceCategory(0)
  else
    result := TFhirMessageSignificanceCategory(StringArrayIndexOf(CODES_TFhirMessageSignificanceCategory, Category.value));
end;

Procedure TFhirConformanceMessagingEvent.SetCategoryST(value : TFhirMessageSignificanceCategory);
begin
  if ord(value) = 0 then
    Category := nil
  else
    Category := TFhirEnum.create(CODES_TFhirMessageSignificanceCategory[value]);
end;

Procedure TFhirConformanceMessagingEvent.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirConformanceMessagingEvent.GetModeST : TFhirMessageConformanceEventMode;
begin
  if FMode = nil then
    result := TFhirMessageConformanceEventMode(0)
  else
    result := TFhirMessageConformanceEventMode(StringArrayIndexOf(CODES_TFhirMessageConformanceEventMode, Mode.value));
end;

Procedure TFhirConformanceMessagingEvent.SetModeST(value : TFhirMessageConformanceEventMode);
begin
  if ord(value) = 0 then
    Mode := nil
  else
    Mode := TFhirEnum.create(CODES_TFhirMessageConformanceEventMode[value]);
end;

Procedure TFhirConformanceMessagingEvent.SetFocus(value : TFhirCode);
begin
  FFocus.free;
  FFocus := value;
end;

Function TFhirConformanceMessagingEvent.GetFocusST : String;
begin
  if FFocus = nil then
    result := ''
  else
    result := Focus.value;
end;

Procedure TFhirConformanceMessagingEvent.SetFocusST(value : String);
begin
  if value <> '' then
  begin
    if FFocus = nil then
      FFocus := TFhirCode.create;
    FFocus.value := value
  end
  else if FFocus <> nil then
    FFocus.value := '';
end;

Procedure TFhirConformanceMessagingEvent.SetRequest(value : TFhirResourceReference{TFhirProfile});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirConformanceMessagingEvent.SetResponse(value : TFhirResourceReference{TFhirProfile});
begin
  FResponse.free;
  FResponse := value;
end;

Procedure TFhirConformanceMessagingEvent.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceMessagingEvent.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := Documentation.value;
end;

Procedure TFhirConformanceMessagingEvent.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;


{ TFhirConformanceMessagingEventList }
procedure TFhirConformanceMessagingEventList.AddItem(value: TFhirConformanceMessagingEvent);
begin
  assert(value.ClassName = 'TFhirConformanceMessagingEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceMessagingEvent');
  add(value);
end;


function TFhirConformanceMessagingEventList.Append: TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceMessagingEventList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceMessagingEventList.Clone: TFhirConformanceMessagingEventList;
begin
  result := TFhirConformanceMessagingEventList(inherited Clone);
end;

function TFhirConformanceMessagingEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceMessagingEventList.GetItemN(index: Integer): TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent(ObjectByIndex[index]);
end;

function TFhirConformanceMessagingEventList.IndexOf(value: TFhirConformanceMessagingEvent): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceMessagingEventList.Insert(index: Integer): TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceMessagingEventList.InsertItem(index: Integer; value: TFhirConformanceMessagingEvent);
begin
  assert(value is TFhirConformanceMessagingEvent);
  Inherited Insert(index, value);
end;

function TFhirConformanceMessagingEventList.Item(index: Integer): TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent(ObjectByIndex[index]);
end;

function TFhirConformanceMessagingEventList.Link: TFhirConformanceMessagingEventList;
begin
  result := TFhirConformanceMessagingEventList(inherited Link);
end;

procedure TFhirConformanceMessagingEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceMessagingEventList.SetItemByIndex(index: Integer; value: TFhirConformanceMessagingEvent);
begin
  assert(value is TFhirConformanceMessagingEvent);
  FhirConformanceMessagingEvents[index] := value;
end;

procedure TFhirConformanceMessagingEventList.SetItemN(index: Integer; value: TFhirConformanceMessagingEvent);
begin
  assert(value is TFhirConformanceMessagingEvent);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceDocument }

constructor TFhirConformanceDocument.Create;
begin
  inherited;
end;

destructor TFhirConformanceDocument.Destroy;
begin
  FMode.free;
  FDocumentation.free;
  FProfile.free;
  inherited;
end;

procedure TFhirConformanceDocument.Assign(oSource : TAdvObject);
begin
  inherited;
  FMode := TFhirConformanceDocument(oSource).FMode.Link;
  documentation := TFhirConformanceDocument(oSource).documentation.Clone;
  profile := TFhirConformanceDocument(oSource).profile.Clone;
end;

procedure TFhirConformanceDocument.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.add(FMode.Link);
  if (child_name = 'documentation') Then
     list.add(Documentation.Link);
  if (child_name = 'profile') Then
     list.add(Profile.Link);
end;

procedure TFhirConformanceDocument.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'profile', 'Resource(Profile)', FProfile.Link.Link));{2}
end;

function TFhirConformanceDocument.Link : TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument(inherited Link);
end;

function TFhirConformanceDocument.Clone : TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument(inherited Clone);
end;

{ TFhirConformanceDocument }

Procedure TFhirConformanceDocument.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirConformanceDocument.GetModeST : TFhirDocumentMode;
begin
  if FMode = nil then
    result := TFhirDocumentMode(0)
  else
    result := TFhirDocumentMode(StringArrayIndexOf(CODES_TFhirDocumentMode, Mode.value));
end;

Procedure TFhirConformanceDocument.SetModeST(value : TFhirDocumentMode);
begin
  if ord(value) = 0 then
    Mode := nil
  else
    Mode := TFhirEnum.create(CODES_TFhirDocumentMode[value]);
end;

Procedure TFhirConformanceDocument.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceDocument.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := Documentation.value;
end;

Procedure TFhirConformanceDocument.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

Procedure TFhirConformanceDocument.SetProfile(value : TFhirResourceReference{TFhirProfile});
begin
  FProfile.free;
  FProfile := value;
end;


{ TFhirConformanceDocumentList }
procedure TFhirConformanceDocumentList.AddItem(value: TFhirConformanceDocument);
begin
  assert(value.ClassName = 'TFhirConformanceDocument', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceDocument');
  add(value);
end;


function TFhirConformanceDocumentList.Append: TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceDocumentList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceDocumentList.Clone: TFhirConformanceDocumentList;
begin
  result := TFhirConformanceDocumentList(inherited Clone);
end;

function TFhirConformanceDocumentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceDocumentList.GetItemN(index: Integer): TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument(ObjectByIndex[index]);
end;

function TFhirConformanceDocumentList.IndexOf(value: TFhirConformanceDocument): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceDocumentList.Insert(index: Integer): TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceDocumentList.InsertItem(index: Integer; value: TFhirConformanceDocument);
begin
  assert(value is TFhirConformanceDocument);
  Inherited Insert(index, value);
end;

function TFhirConformanceDocumentList.Item(index: Integer): TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument(ObjectByIndex[index]);
end;

function TFhirConformanceDocumentList.Link: TFhirConformanceDocumentList;
begin
  result := TFhirConformanceDocumentList(inherited Link);
end;

procedure TFhirConformanceDocumentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceDocumentList.SetItemByIndex(index: Integer; value: TFhirConformanceDocument);
begin
  assert(value is TFhirConformanceDocument);
  FhirConformanceDocuments[index] := value;
end;

procedure TFhirConformanceDocumentList.SetItemN(index: Integer; value: TFhirConformanceDocument);
begin
  assert(value is TFhirConformanceDocument);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceObservationReportVirtualDevice }

constructor TFhirDeviceObservationReportVirtualDevice.Create;
begin
  inherited;
  FChannelList := TFhirDeviceObservationReportVirtualDeviceChannelList.Create;
end;

destructor TFhirDeviceObservationReportVirtualDevice.Destroy;
begin
  FCode.free;
  FChannelList.Free;
  inherited;
end;

procedure TFhirDeviceObservationReportVirtualDevice.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirDeviceObservationReportVirtualDevice(oSource).code.Clone;
  FChannelList.Assign(TFhirDeviceObservationReportVirtualDevice(oSource).FChannelList);
end;

procedure TFhirDeviceObservationReportVirtualDevice.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'channel') Then
     list.addAll(FChannelList);
end;

procedure TFhirDeviceObservationReportVirtualDevice.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'channel', '', FChannelList.Link)){3};
end;

function TFhirDeviceObservationReportVirtualDevice.Link : TFhirDeviceObservationReportVirtualDevice;
begin
  result := TFhirDeviceObservationReportVirtualDevice(inherited Link);
end;

function TFhirDeviceObservationReportVirtualDevice.Clone : TFhirDeviceObservationReportVirtualDevice;
begin
  result := TFhirDeviceObservationReportVirtualDevice(inherited Clone);
end;

{ TFhirDeviceObservationReportVirtualDevice }

Procedure TFhirDeviceObservationReportVirtualDevice.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;


{ TFhirDeviceObservationReportVirtualDeviceList }
procedure TFhirDeviceObservationReportVirtualDeviceList.AddItem(value: TFhirDeviceObservationReportVirtualDevice);
begin
  assert(value.ClassName = 'TFhirDeviceObservationReportVirtualDevice', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceObservationReportVirtualDevice');
  add(value);
end;


function TFhirDeviceObservationReportVirtualDeviceList.Append: TFhirDeviceObservationReportVirtualDevice;
begin
  result := TFhirDeviceObservationReportVirtualDevice.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceObservationReportVirtualDeviceList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceObservationReportVirtualDeviceList.Clone: TFhirDeviceObservationReportVirtualDeviceList;
begin
  result := TFhirDeviceObservationReportVirtualDeviceList(inherited Clone);
end;

function TFhirDeviceObservationReportVirtualDeviceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceObservationReportVirtualDeviceList.GetItemN(index: Integer): TFhirDeviceObservationReportVirtualDevice;
begin
  result := TFhirDeviceObservationReportVirtualDevice(ObjectByIndex[index]);
end;

function TFhirDeviceObservationReportVirtualDeviceList.IndexOf(value: TFhirDeviceObservationReportVirtualDevice): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDeviceObservationReportVirtualDeviceList.Insert(index: Integer): TFhirDeviceObservationReportVirtualDevice;
begin
  result := TFhirDeviceObservationReportVirtualDevice.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceObservationReportVirtualDeviceList.InsertItem(index: Integer; value: TFhirDeviceObservationReportVirtualDevice);
begin
  assert(value is TFhirDeviceObservationReportVirtualDevice);
  Inherited Insert(index, value);
end;

function TFhirDeviceObservationReportVirtualDeviceList.Item(index: Integer): TFhirDeviceObservationReportVirtualDevice;
begin
  result := TFhirDeviceObservationReportVirtualDevice(ObjectByIndex[index]);
end;

function TFhirDeviceObservationReportVirtualDeviceList.Link: TFhirDeviceObservationReportVirtualDeviceList;
begin
  result := TFhirDeviceObservationReportVirtualDeviceList(inherited Link);
end;

procedure TFhirDeviceObservationReportVirtualDeviceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceObservationReportVirtualDeviceList.SetItemByIndex(index: Integer; value: TFhirDeviceObservationReportVirtualDevice);
begin
  assert(value is TFhirDeviceObservationReportVirtualDevice);
  FhirDeviceObservationReportVirtualDevices[index] := value;
end;

procedure TFhirDeviceObservationReportVirtualDeviceList.SetItemN(index: Integer; value: TFhirDeviceObservationReportVirtualDevice);
begin
  assert(value is TFhirDeviceObservationReportVirtualDevice);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceObservationReportVirtualDeviceChannel }

constructor TFhirDeviceObservationReportVirtualDeviceChannel.Create;
begin
  inherited;
  FMetricList := TFhirDeviceObservationReportVirtualDeviceChannelMetricList.Create;
end;

destructor TFhirDeviceObservationReportVirtualDeviceChannel.Destroy;
begin
  FCode.free;
  FMetricList.Free;
  inherited;
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannel.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirDeviceObservationReportVirtualDeviceChannel(oSource).code.Clone;
  FMetricList.Assign(TFhirDeviceObservationReportVirtualDeviceChannel(oSource).FMetricList);
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannel.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'metric') Then
     list.addAll(FMetricList);
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannel.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'metric', '', FMetricList.Link)){3};
end;

function TFhirDeviceObservationReportVirtualDeviceChannel.Link : TFhirDeviceObservationReportVirtualDeviceChannel;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannel(inherited Link);
end;

function TFhirDeviceObservationReportVirtualDeviceChannel.Clone : TFhirDeviceObservationReportVirtualDeviceChannel;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannel(inherited Clone);
end;

{ TFhirDeviceObservationReportVirtualDeviceChannel }

Procedure TFhirDeviceObservationReportVirtualDeviceChannel.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;


{ TFhirDeviceObservationReportVirtualDeviceChannelList }
procedure TFhirDeviceObservationReportVirtualDeviceChannelList.AddItem(value: TFhirDeviceObservationReportVirtualDeviceChannel);
begin
  assert(value.ClassName = 'TFhirDeviceObservationReportVirtualDeviceChannel', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceObservationReportVirtualDeviceChannel');
  add(value);
end;


function TFhirDeviceObservationReportVirtualDeviceChannelList.Append: TFhirDeviceObservationReportVirtualDeviceChannel;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannel.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceObservationReportVirtualDeviceChannelList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceObservationReportVirtualDeviceChannelList.Clone: TFhirDeviceObservationReportVirtualDeviceChannelList;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelList(inherited Clone);
end;

function TFhirDeviceObservationReportVirtualDeviceChannelList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceObservationReportVirtualDeviceChannelList.GetItemN(index: Integer): TFhirDeviceObservationReportVirtualDeviceChannel;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannel(ObjectByIndex[index]);
end;

function TFhirDeviceObservationReportVirtualDeviceChannelList.IndexOf(value: TFhirDeviceObservationReportVirtualDeviceChannel): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDeviceObservationReportVirtualDeviceChannelList.Insert(index: Integer): TFhirDeviceObservationReportVirtualDeviceChannel;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannel.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceObservationReportVirtualDeviceChannelList.InsertItem(index: Integer; value: TFhirDeviceObservationReportVirtualDeviceChannel);
begin
  assert(value is TFhirDeviceObservationReportVirtualDeviceChannel);
  Inherited Insert(index, value);
end;

function TFhirDeviceObservationReportVirtualDeviceChannelList.Item(index: Integer): TFhirDeviceObservationReportVirtualDeviceChannel;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannel(ObjectByIndex[index]);
end;

function TFhirDeviceObservationReportVirtualDeviceChannelList.Link: TFhirDeviceObservationReportVirtualDeviceChannelList;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelList(inherited Link);
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannelList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannelList.SetItemByIndex(index: Integer; value: TFhirDeviceObservationReportVirtualDeviceChannel);
begin
  assert(value is TFhirDeviceObservationReportVirtualDeviceChannel);
  FhirDeviceObservationReportVirtualDeviceChannels[index] := value;
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannelList.SetItemN(index: Integer; value: TFhirDeviceObservationReportVirtualDeviceChannel);
begin
  assert(value is TFhirDeviceObservationReportVirtualDeviceChannel);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceObservationReportVirtualDeviceChannelMetric }

constructor TFhirDeviceObservationReportVirtualDeviceChannelMetric.Create;
begin
  inherited;
end;

destructor TFhirDeviceObservationReportVirtualDeviceChannelMetric.Destroy;
begin
  FObservation.free;
  inherited;
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannelMetric.Assign(oSource : TAdvObject);
begin
  inherited;
  observation := TFhirDeviceObservationReportVirtualDeviceChannelMetric(oSource).observation.Clone;
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannelMetric.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'observation') Then
     list.add(Observation.Link);
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannelMetric.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'observation', 'Resource(Observation)', FObservation.Link.Link));{2}
end;

function TFhirDeviceObservationReportVirtualDeviceChannelMetric.Link : TFhirDeviceObservationReportVirtualDeviceChannelMetric;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelMetric(inherited Link);
end;

function TFhirDeviceObservationReportVirtualDeviceChannelMetric.Clone : TFhirDeviceObservationReportVirtualDeviceChannelMetric;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelMetric(inherited Clone);
end;

{ TFhirDeviceObservationReportVirtualDeviceChannelMetric }

Procedure TFhirDeviceObservationReportVirtualDeviceChannelMetric.SetObservation(value : TFhirResourceReference{TFhirObservation});
begin
  FObservation.free;
  FObservation := value;
end;


{ TFhirDeviceObservationReportVirtualDeviceChannelMetricList }
procedure TFhirDeviceObservationReportVirtualDeviceChannelMetricList.AddItem(value: TFhirDeviceObservationReportVirtualDeviceChannelMetric);
begin
  assert(value.ClassName = 'TFhirDeviceObservationReportVirtualDeviceChannelMetric', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceObservationReportVirtualDeviceChannelMetric');
  add(value);
end;


function TFhirDeviceObservationReportVirtualDeviceChannelMetricList.Append: TFhirDeviceObservationReportVirtualDeviceChannelMetric;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelMetric.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceObservationReportVirtualDeviceChannelMetricList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceObservationReportVirtualDeviceChannelMetricList.Clone: TFhirDeviceObservationReportVirtualDeviceChannelMetricList;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelMetricList(inherited Clone);
end;

function TFhirDeviceObservationReportVirtualDeviceChannelMetricList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceObservationReportVirtualDeviceChannelMetricList.GetItemN(index: Integer): TFhirDeviceObservationReportVirtualDeviceChannelMetric;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelMetric(ObjectByIndex[index]);
end;

function TFhirDeviceObservationReportVirtualDeviceChannelMetricList.IndexOf(value: TFhirDeviceObservationReportVirtualDeviceChannelMetric): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDeviceObservationReportVirtualDeviceChannelMetricList.Insert(index: Integer): TFhirDeviceObservationReportVirtualDeviceChannelMetric;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelMetric.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceObservationReportVirtualDeviceChannelMetricList.InsertItem(index: Integer; value: TFhirDeviceObservationReportVirtualDeviceChannelMetric);
begin
  assert(value is TFhirDeviceObservationReportVirtualDeviceChannelMetric);
  Inherited Insert(index, value);
end;

function TFhirDeviceObservationReportVirtualDeviceChannelMetricList.Item(index: Integer): TFhirDeviceObservationReportVirtualDeviceChannelMetric;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelMetric(ObjectByIndex[index]);
end;

function TFhirDeviceObservationReportVirtualDeviceChannelMetricList.Link: TFhirDeviceObservationReportVirtualDeviceChannelMetricList;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelMetricList(inherited Link);
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannelMetricList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannelMetricList.SetItemByIndex(index: Integer; value: TFhirDeviceObservationReportVirtualDeviceChannelMetric);
begin
  assert(value is TFhirDeviceObservationReportVirtualDeviceChannelMetric);
  FhirDeviceObservationReportVirtualDeviceChannelMetrics[index] := value;
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannelMetricList.SetItemN(index: Integer; value: TFhirDeviceObservationReportVirtualDeviceChannelMetric);
begin
  assert(value is TFhirDeviceObservationReportVirtualDeviceChannelMetric);
  ObjectByIndex[index] := value;
end;

{ TFhirDiagnosticOrderEvent }

constructor TFhirDiagnosticOrderEvent.Create;
begin
  inherited;
end;

destructor TFhirDiagnosticOrderEvent.Destroy;
begin
  FStatus.free;
  FDescription.free;
  FDateTime.free;
  FActor.free;
  inherited;
end;

procedure TFhirDiagnosticOrderEvent.Assign(oSource : TAdvObject);
begin
  inherited;
  FStatus := TFhirDiagnosticOrderEvent(oSource).FStatus.Link;
  description := TFhirDiagnosticOrderEvent(oSource).description.Clone;
  dateTime := TFhirDiagnosticOrderEvent(oSource).dateTime.Clone;
  actor := TFhirDiagnosticOrderEvent(oSource).actor.Clone;
end;

procedure TFhirDiagnosticOrderEvent.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(FStatus.Link);
  if (child_name = 'description') Then
     list.add(Description.Link);
  if (child_name = 'dateTime') Then
     list.add(DateTime.Link);
  if (child_name = 'actor') Then
     list.add(Actor.Link);
end;

procedure TFhirDiagnosticOrderEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'status', 'code', FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'description', 'CodeableConcept', FDescription.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dateTime', 'dateTime', FDateTime.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'actor', 'Resource(Practitioner|Device)', FActor.Link.Link));{2}
end;

function TFhirDiagnosticOrderEvent.Link : TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent(inherited Link);
end;

function TFhirDiagnosticOrderEvent.Clone : TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent(inherited Clone);
end;

{ TFhirDiagnosticOrderEvent }

Procedure TFhirDiagnosticOrderEvent.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirDiagnosticOrderEvent.GetStatusST : TFhirDiagnosticOrderStatus;
begin
  if FStatus = nil then
    result := TFhirDiagnosticOrderStatus(0)
  else
    result := TFhirDiagnosticOrderStatus(StringArrayIndexOf(CODES_TFhirDiagnosticOrderStatus, Status.value));
end;

Procedure TFhirDiagnosticOrderEvent.SetStatusST(value : TFhirDiagnosticOrderStatus);
begin
  if ord(value) = 0 then
    Status := nil
  else
    Status := TFhirEnum.create(CODES_TFhirDiagnosticOrderStatus[value]);
end;

Procedure TFhirDiagnosticOrderEvent.SetDescription(value : TFhirCodeableConcept);
begin
  FDescription.free;
  FDescription := value;
end;

Procedure TFhirDiagnosticOrderEvent.SetDateTime(value : TFhirDateTime);
begin
  FDateTime.free;
  FDateTime := value;
end;

Function TFhirDiagnosticOrderEvent.GetDateTimeST : TDateAndTime;
begin
  if FDateTime = nil then
    result := nil
  else
    result := DateTime.value;
end;

Procedure TFhirDiagnosticOrderEvent.SetDateTimeST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FDateTime = nil then
      FDateTime := TFhirDateTime.create;
    FDateTime.value := value
  end
  else if FDateTime <> nil then
    FDateTime.value := nil;
end;

Procedure TFhirDiagnosticOrderEvent.SetActor(value : TFhirResourceReference{Resource});
begin
  FActor.free;
  FActor := value;
end;


{ TFhirDiagnosticOrderEventList }
procedure TFhirDiagnosticOrderEventList.AddItem(value: TFhirDiagnosticOrderEvent);
begin
  assert(value.ClassName = 'TFhirDiagnosticOrderEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDiagnosticOrderEvent');
  add(value);
end;


function TFhirDiagnosticOrderEventList.Append: TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDiagnosticOrderEventList.ClearItems;
begin
  Clear;
end;

function TFhirDiagnosticOrderEventList.Clone: TFhirDiagnosticOrderEventList;
begin
  result := TFhirDiagnosticOrderEventList(inherited Clone);
end;

function TFhirDiagnosticOrderEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDiagnosticOrderEventList.GetItemN(index: Integer): TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent(ObjectByIndex[index]);
end;

function TFhirDiagnosticOrderEventList.IndexOf(value: TFhirDiagnosticOrderEvent): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDiagnosticOrderEventList.Insert(index: Integer): TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDiagnosticOrderEventList.InsertItem(index: Integer; value: TFhirDiagnosticOrderEvent);
begin
  assert(value is TFhirDiagnosticOrderEvent);
  Inherited Insert(index, value);
end;

function TFhirDiagnosticOrderEventList.Item(index: Integer): TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent(ObjectByIndex[index]);
end;

function TFhirDiagnosticOrderEventList.Link: TFhirDiagnosticOrderEventList;
begin
  result := TFhirDiagnosticOrderEventList(inherited Link);
end;

procedure TFhirDiagnosticOrderEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDiagnosticOrderEventList.SetItemByIndex(index: Integer; value: TFhirDiagnosticOrderEvent);
begin
  assert(value is TFhirDiagnosticOrderEvent);
  FhirDiagnosticOrderEvents[index] := value;
end;

procedure TFhirDiagnosticOrderEventList.SetItemN(index: Integer; value: TFhirDiagnosticOrderEvent);
begin
  assert(value is TFhirDiagnosticOrderEvent);
  ObjectByIndex[index] := value;
end;

{ TFhirDiagnosticOrderItem }

constructor TFhirDiagnosticOrderItem.Create;
begin
  inherited;
  FSpecimenList := TFhirResourceReferenceList{TFhirSpecimen}.Create;
  FEventList := TFhirDiagnosticOrderEventList.Create;
end;

destructor TFhirDiagnosticOrderItem.Destroy;
begin
  FCode.free;
  FSpecimenList.Free;
  FBodySite.free;
  FStatus.free;
  FEventList.Free;
  inherited;
end;

procedure TFhirDiagnosticOrderItem.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirDiagnosticOrderItem(oSource).code.Clone;
  FSpecimenList.Assign(TFhirDiagnosticOrderItem(oSource).FSpecimenList);
  bodySite := TFhirDiagnosticOrderItem(oSource).bodySite.Clone;
  FStatus := TFhirDiagnosticOrderItem(oSource).FStatus.Link;
  FEventList.Assign(TFhirDiagnosticOrderItem(oSource).FEventList);
end;

procedure TFhirDiagnosticOrderItem.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'specimen') Then
     list.addAll(FSpecimenList);
  if (child_name = 'bodySite') Then
     list.add(BodySite.Link);
  if (child_name = 'status') Then
     list.add(FStatus.Link);
  if (child_name = 'event') Then
     list.addAll(FEventList);
end;

procedure TFhirDiagnosticOrderItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'specimen', 'Resource(Specimen)', FSpecimenList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', FBodySite.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'event', '@DiagnosticOrder.event', FEventList.Link)){3};
end;

function TFhirDiagnosticOrderItem.Link : TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem(inherited Link);
end;

function TFhirDiagnosticOrderItem.Clone : TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem(inherited Clone);
end;

{ TFhirDiagnosticOrderItem }

Procedure TFhirDiagnosticOrderItem.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirDiagnosticOrderItem.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value;
end;

Procedure TFhirDiagnosticOrderItem.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirDiagnosticOrderItem.GetStatusST : TFhirDiagnosticOrderStatus;
begin
  if FStatus = nil then
    result := TFhirDiagnosticOrderStatus(0)
  else
    result := TFhirDiagnosticOrderStatus(StringArrayIndexOf(CODES_TFhirDiagnosticOrderStatus, Status.value));
end;

Procedure TFhirDiagnosticOrderItem.SetStatusST(value : TFhirDiagnosticOrderStatus);
begin
  if ord(value) = 0 then
    Status := nil
  else
    Status := TFhirEnum.create(CODES_TFhirDiagnosticOrderStatus[value]);
end;


{ TFhirDiagnosticOrderItemList }
procedure TFhirDiagnosticOrderItemList.AddItem(value: TFhirDiagnosticOrderItem);
begin
  assert(value.ClassName = 'TFhirDiagnosticOrderItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDiagnosticOrderItem');
  add(value);
end;


function TFhirDiagnosticOrderItemList.Append: TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDiagnosticOrderItemList.ClearItems;
begin
  Clear;
end;

function TFhirDiagnosticOrderItemList.Clone: TFhirDiagnosticOrderItemList;
begin
  result := TFhirDiagnosticOrderItemList(inherited Clone);
end;

function TFhirDiagnosticOrderItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDiagnosticOrderItemList.GetItemN(index: Integer): TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem(ObjectByIndex[index]);
end;

function TFhirDiagnosticOrderItemList.IndexOf(value: TFhirDiagnosticOrderItem): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDiagnosticOrderItemList.Insert(index: Integer): TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDiagnosticOrderItemList.InsertItem(index: Integer; value: TFhirDiagnosticOrderItem);
begin
  assert(value is TFhirDiagnosticOrderItem);
  Inherited Insert(index, value);
end;

function TFhirDiagnosticOrderItemList.Item(index: Integer): TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem(ObjectByIndex[index]);
end;

function TFhirDiagnosticOrderItemList.Link: TFhirDiagnosticOrderItemList;
begin
  result := TFhirDiagnosticOrderItemList(inherited Link);
end;

procedure TFhirDiagnosticOrderItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDiagnosticOrderItemList.SetItemByIndex(index: Integer; value: TFhirDiagnosticOrderItem);
begin
  assert(value is TFhirDiagnosticOrderItem);
  FhirDiagnosticOrderItems[index] := value;
end;

procedure TFhirDiagnosticOrderItemList.SetItemN(index: Integer; value: TFhirDiagnosticOrderItem);
begin
  assert(value is TFhirDiagnosticOrderItem);
  ObjectByIndex[index] := value;
end;

{ TFhirDiagnosticReportImage }

constructor TFhirDiagnosticReportImage.Create;
begin
  inherited;
end;

destructor TFhirDiagnosticReportImage.Destroy;
begin
  FComment.free;
  FLink_.free;
  inherited;
end;

procedure TFhirDiagnosticReportImage.Assign(oSource : TAdvObject);
begin
  inherited;
  comment := TFhirDiagnosticReportImage(oSource).comment.Clone;
  link_ := TFhirDiagnosticReportImage(oSource).link_.Clone;
end;

procedure TFhirDiagnosticReportImage.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'comment') Then
     list.add(Comment.Link);
  if (child_name = 'link_') Then
     list.add(Link_.Link);
end;

procedure TFhirDiagnosticReportImage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'comment', 'string', FComment.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'link', 'Resource(Media)', FLink_.Link.Link));{2}
end;

function TFhirDiagnosticReportImage.Link : TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage(inherited Link);
end;

function TFhirDiagnosticReportImage.Clone : TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage(inherited Clone);
end;

{ TFhirDiagnosticReportImage }

Procedure TFhirDiagnosticReportImage.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirDiagnosticReportImage.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := Comment.value;
end;

Procedure TFhirDiagnosticReportImage.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

Procedure TFhirDiagnosticReportImage.SetLink_(value : TFhirResourceReference{TFhirMedia});
begin
  FLink_.free;
  FLink_ := value;
end;


{ TFhirDiagnosticReportImageList }
procedure TFhirDiagnosticReportImageList.AddItem(value: TFhirDiagnosticReportImage);
begin
  assert(value.ClassName = 'TFhirDiagnosticReportImage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDiagnosticReportImage');
  add(value);
end;


function TFhirDiagnosticReportImageList.Append: TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDiagnosticReportImageList.ClearItems;
begin
  Clear;
end;

function TFhirDiagnosticReportImageList.Clone: TFhirDiagnosticReportImageList;
begin
  result := TFhirDiagnosticReportImageList(inherited Clone);
end;

function TFhirDiagnosticReportImageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDiagnosticReportImageList.GetItemN(index: Integer): TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportImageList.IndexOf(value: TFhirDiagnosticReportImage): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDiagnosticReportImageList.Insert(index: Integer): TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDiagnosticReportImageList.InsertItem(index: Integer; value: TFhirDiagnosticReportImage);
begin
  assert(value is TFhirDiagnosticReportImage);
  Inherited Insert(index, value);
end;

function TFhirDiagnosticReportImageList.Item(index: Integer): TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportImageList.Link: TFhirDiagnosticReportImageList;
begin
  result := TFhirDiagnosticReportImageList(inherited Link);
end;

procedure TFhirDiagnosticReportImageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDiagnosticReportImageList.SetItemByIndex(index: Integer; value: TFhirDiagnosticReportImage);
begin
  assert(value is TFhirDiagnosticReportImage);
  FhirDiagnosticReportImages[index] := value;
end;

procedure TFhirDiagnosticReportImageList.SetItemN(index: Integer; value: TFhirDiagnosticReportImage);
begin
  assert(value is TFhirDiagnosticReportImage);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentReferenceRelatesTo }

constructor TFhirDocumentReferenceRelatesTo.Create;
begin
  inherited;
end;

destructor TFhirDocumentReferenceRelatesTo.Destroy;
begin
  FCode.free;
  FTarget.free;
  inherited;
end;

procedure TFhirDocumentReferenceRelatesTo.Assign(oSource : TAdvObject);
begin
  inherited;
  FCode := TFhirDocumentReferenceRelatesTo(oSource).FCode.Link;
  target := TFhirDocumentReferenceRelatesTo(oSource).target.Clone;
end;

procedure TFhirDocumentReferenceRelatesTo.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'target') Then
     list.add(Target.Link);
end;

procedure TFhirDocumentReferenceRelatesTo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'target', 'Resource(DocumentReference)', FTarget.Link.Link));{2}
end;

function TFhirDocumentReferenceRelatesTo.Link : TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo(inherited Link);
end;

function TFhirDocumentReferenceRelatesTo.Clone : TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo(inherited Clone);
end;

{ TFhirDocumentReferenceRelatesTo }

Procedure TFhirDocumentReferenceRelatesTo.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirDocumentReferenceRelatesTo.GetCodeST : TFhirDocumentRelationshipType;
begin
  if FCode = nil then
    result := TFhirDocumentRelationshipType(0)
  else
    result := TFhirDocumentRelationshipType(StringArrayIndexOf(CODES_TFhirDocumentRelationshipType, Code.value));
end;

Procedure TFhirDocumentReferenceRelatesTo.SetCodeST(value : TFhirDocumentRelationshipType);
begin
  if ord(value) = 0 then
    Code := nil
  else
    Code := TFhirEnum.create(CODES_TFhirDocumentRelationshipType[value]);
end;

Procedure TFhirDocumentReferenceRelatesTo.SetTarget(value : TFhirResourceReference{TFhirDocumentReference});
begin
  FTarget.free;
  FTarget := value;
end;


{ TFhirDocumentReferenceRelatesToList }
procedure TFhirDocumentReferenceRelatesToList.AddItem(value: TFhirDocumentReferenceRelatesTo);
begin
  assert(value.ClassName = 'TFhirDocumentReferenceRelatesTo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReferenceRelatesTo');
  add(value);
end;


function TFhirDocumentReferenceRelatesToList.Append: TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentReferenceRelatesToList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceRelatesToList.Clone: TFhirDocumentReferenceRelatesToList;
begin
  result := TFhirDocumentReferenceRelatesToList(inherited Clone);
end;

function TFhirDocumentReferenceRelatesToList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceRelatesToList.GetItemN(index: Integer): TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceRelatesToList.IndexOf(value: TFhirDocumentReferenceRelatesTo): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDocumentReferenceRelatesToList.Insert(index: Integer): TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentReferenceRelatesToList.InsertItem(index: Integer; value: TFhirDocumentReferenceRelatesTo);
begin
  assert(value is TFhirDocumentReferenceRelatesTo);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceRelatesToList.Item(index: Integer): TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceRelatesToList.Link: TFhirDocumentReferenceRelatesToList;
begin
  result := TFhirDocumentReferenceRelatesToList(inherited Link);
end;

procedure TFhirDocumentReferenceRelatesToList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceRelatesToList.SetItemByIndex(index: Integer; value: TFhirDocumentReferenceRelatesTo);
begin
  assert(value is TFhirDocumentReferenceRelatesTo);
  FhirDocumentReferenceRelatesTos[index] := value;
end;

procedure TFhirDocumentReferenceRelatesToList.SetItemN(index: Integer; value: TFhirDocumentReferenceRelatesTo);
begin
  assert(value is TFhirDocumentReferenceRelatesTo);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentReferenceService }

constructor TFhirDocumentReferenceService.Create;
begin
  inherited;
  FParameterList := TFhirDocumentReferenceServiceParameterList.Create;
end;

destructor TFhirDocumentReferenceService.Destroy;
begin
  FType_.free;
  FAddress.free;
  FParameterList.Free;
  inherited;
end;

procedure TFhirDocumentReferenceService.Assign(oSource : TAdvObject);
begin
  inherited;
  type_ := TFhirDocumentReferenceService(oSource).type_.Clone;
  address := TFhirDocumentReferenceService(oSource).address.Clone;
  FParameterList.Assign(TFhirDocumentReferenceService(oSource).FParameterList);
end;

procedure TFhirDocumentReferenceService.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'address') Then
     list.add(Address.Link);
  if (child_name = 'parameter') Then
     list.addAll(FParameterList);
end;

procedure TFhirDocumentReferenceService.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'address', 'string', FAddress.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'parameter', '', FParameterList.Link)){3};
end;

function TFhirDocumentReferenceService.Link : TFhirDocumentReferenceService;
begin
  result := TFhirDocumentReferenceService(inherited Link);
end;

function TFhirDocumentReferenceService.Clone : TFhirDocumentReferenceService;
begin
  result := TFhirDocumentReferenceService(inherited Clone);
end;

{ TFhirDocumentReferenceService }

Procedure TFhirDocumentReferenceService.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirDocumentReferenceService.SetAddress(value : TFhirString);
begin
  FAddress.free;
  FAddress := value;
end;

Function TFhirDocumentReferenceService.GetAddressST : String;
begin
  if FAddress = nil then
    result := ''
  else
    result := Address.value;
end;

Procedure TFhirDocumentReferenceService.SetAddressST(value : String);
begin
  if value <> '' then
  begin
    if FAddress = nil then
      FAddress := TFhirString.create;
    FAddress.value := value
  end
  else if FAddress <> nil then
    FAddress.value := '';
end;


{ TFhirDocumentReferenceServiceList }
procedure TFhirDocumentReferenceServiceList.AddItem(value: TFhirDocumentReferenceService);
begin
  assert(value.ClassName = 'TFhirDocumentReferenceService', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReferenceService');
  add(value);
end;


function TFhirDocumentReferenceServiceList.Append: TFhirDocumentReferenceService;
begin
  result := TFhirDocumentReferenceService.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentReferenceServiceList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceServiceList.Clone: TFhirDocumentReferenceServiceList;
begin
  result := TFhirDocumentReferenceServiceList(inherited Clone);
end;

function TFhirDocumentReferenceServiceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceServiceList.GetItemN(index: Integer): TFhirDocumentReferenceService;
begin
  result := TFhirDocumentReferenceService(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceServiceList.IndexOf(value: TFhirDocumentReferenceService): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDocumentReferenceServiceList.Insert(index: Integer): TFhirDocumentReferenceService;
begin
  result := TFhirDocumentReferenceService.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentReferenceServiceList.InsertItem(index: Integer; value: TFhirDocumentReferenceService);
begin
  assert(value is TFhirDocumentReferenceService);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceServiceList.Item(index: Integer): TFhirDocumentReferenceService;
begin
  result := TFhirDocumentReferenceService(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceServiceList.Link: TFhirDocumentReferenceServiceList;
begin
  result := TFhirDocumentReferenceServiceList(inherited Link);
end;

procedure TFhirDocumentReferenceServiceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceServiceList.SetItemByIndex(index: Integer; value: TFhirDocumentReferenceService);
begin
  assert(value is TFhirDocumentReferenceService);
  FhirDocumentReferenceServices[index] := value;
end;

procedure TFhirDocumentReferenceServiceList.SetItemN(index: Integer; value: TFhirDocumentReferenceService);
begin
  assert(value is TFhirDocumentReferenceService);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentReferenceServiceParameter }

constructor TFhirDocumentReferenceServiceParameter.Create;
begin
  inherited;
end;

destructor TFhirDocumentReferenceServiceParameter.Destroy;
begin
  FName.free;
  FValue.free;
  inherited;
end;

procedure TFhirDocumentReferenceServiceParameter.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirDocumentReferenceServiceParameter(oSource).name.Clone;
  value := TFhirDocumentReferenceServiceParameter(oSource).value.Clone;
end;

procedure TFhirDocumentReferenceServiceParameter.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'value') Then
     list.add(Value.Link);
end;

procedure TFhirDocumentReferenceServiceParameter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'string', FValue.Link.Link));{2}
end;

function TFhirDocumentReferenceServiceParameter.Link : TFhirDocumentReferenceServiceParameter;
begin
  result := TFhirDocumentReferenceServiceParameter(inherited Link);
end;

function TFhirDocumentReferenceServiceParameter.Clone : TFhirDocumentReferenceServiceParameter;
begin
  result := TFhirDocumentReferenceServiceParameter(inherited Clone);
end;

{ TFhirDocumentReferenceServiceParameter }

Procedure TFhirDocumentReferenceServiceParameter.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirDocumentReferenceServiceParameter.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirDocumentReferenceServiceParameter.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirDocumentReferenceServiceParameter.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirDocumentReferenceServiceParameter.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := Value.value;
end;

Procedure TFhirDocumentReferenceServiceParameter.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;


{ TFhirDocumentReferenceServiceParameterList }
procedure TFhirDocumentReferenceServiceParameterList.AddItem(value: TFhirDocumentReferenceServiceParameter);
begin
  assert(value.ClassName = 'TFhirDocumentReferenceServiceParameter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReferenceServiceParameter');
  add(value);
end;


function TFhirDocumentReferenceServiceParameterList.Append: TFhirDocumentReferenceServiceParameter;
begin
  result := TFhirDocumentReferenceServiceParameter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentReferenceServiceParameterList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceServiceParameterList.Clone: TFhirDocumentReferenceServiceParameterList;
begin
  result := TFhirDocumentReferenceServiceParameterList(inherited Clone);
end;

function TFhirDocumentReferenceServiceParameterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceServiceParameterList.GetItemN(index: Integer): TFhirDocumentReferenceServiceParameter;
begin
  result := TFhirDocumentReferenceServiceParameter(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceServiceParameterList.IndexOf(value: TFhirDocumentReferenceServiceParameter): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDocumentReferenceServiceParameterList.Insert(index: Integer): TFhirDocumentReferenceServiceParameter;
begin
  result := TFhirDocumentReferenceServiceParameter.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentReferenceServiceParameterList.InsertItem(index: Integer; value: TFhirDocumentReferenceServiceParameter);
begin
  assert(value is TFhirDocumentReferenceServiceParameter);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceServiceParameterList.Item(index: Integer): TFhirDocumentReferenceServiceParameter;
begin
  result := TFhirDocumentReferenceServiceParameter(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceServiceParameterList.Link: TFhirDocumentReferenceServiceParameterList;
begin
  result := TFhirDocumentReferenceServiceParameterList(inherited Link);
end;

procedure TFhirDocumentReferenceServiceParameterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceServiceParameterList.SetItemByIndex(index: Integer; value: TFhirDocumentReferenceServiceParameter);
begin
  assert(value is TFhirDocumentReferenceServiceParameter);
  FhirDocumentReferenceServiceParameters[index] := value;
end;

procedure TFhirDocumentReferenceServiceParameterList.SetItemN(index: Integer; value: TFhirDocumentReferenceServiceParameter);
begin
  assert(value is TFhirDocumentReferenceServiceParameter);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentReferenceContext }

constructor TFhirDocumentReferenceContext.Create;
begin
  inherited;
  FEventList := TFhirCodeableConceptList.Create;
end;

destructor TFhirDocumentReferenceContext.Destroy;
begin
  FEventList.Free;
  FPeriod.free;
  FFacilityType.free;
  inherited;
end;

procedure TFhirDocumentReferenceContext.Assign(oSource : TAdvObject);
begin
  inherited;
  FEventList.Assign(TFhirDocumentReferenceContext(oSource).FEventList);
  period := TFhirDocumentReferenceContext(oSource).period.Clone;
  facilityType := TFhirDocumentReferenceContext(oSource).facilityType.Clone;
end;

procedure TFhirDocumentReferenceContext.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'event') Then
     list.addAll(FEventList);
  if (child_name = 'period') Then
     list.add(Period.Link);
  if (child_name = 'facilityType') Then
     list.add(FacilityType.Link);
end;

procedure TFhirDocumentReferenceContext.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'event', 'CodeableConcept', FEventList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'period', 'Period', FPeriod.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'facilityType', 'CodeableConcept', FFacilityType.Link.Link));{2}
end;

function TFhirDocumentReferenceContext.Link : TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext(inherited Link);
end;

function TFhirDocumentReferenceContext.Clone : TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext(inherited Clone);
end;

{ TFhirDocumentReferenceContext }

Procedure TFhirDocumentReferenceContext.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirDocumentReferenceContext.SetFacilityType(value : TFhirCodeableConcept);
begin
  FFacilityType.free;
  FFacilityType := value;
end;


{ TFhirDocumentReferenceContextList }
procedure TFhirDocumentReferenceContextList.AddItem(value: TFhirDocumentReferenceContext);
begin
  assert(value.ClassName = 'TFhirDocumentReferenceContext', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReferenceContext');
  add(value);
end;


function TFhirDocumentReferenceContextList.Append: TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentReferenceContextList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceContextList.Clone: TFhirDocumentReferenceContextList;
begin
  result := TFhirDocumentReferenceContextList(inherited Clone);
end;

function TFhirDocumentReferenceContextList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceContextList.GetItemN(index: Integer): TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceContextList.IndexOf(value: TFhirDocumentReferenceContext): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDocumentReferenceContextList.Insert(index: Integer): TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentReferenceContextList.InsertItem(index: Integer; value: TFhirDocumentReferenceContext);
begin
  assert(value is TFhirDocumentReferenceContext);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceContextList.Item(index: Integer): TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceContextList.Link: TFhirDocumentReferenceContextList;
begin
  result := TFhirDocumentReferenceContextList(inherited Link);
end;

procedure TFhirDocumentReferenceContextList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceContextList.SetItemByIndex(index: Integer; value: TFhirDocumentReferenceContext);
begin
  assert(value is TFhirDocumentReferenceContext);
  FhirDocumentReferenceContexts[index] := value;
end;

procedure TFhirDocumentReferenceContextList.SetItemN(index: Integer; value: TFhirDocumentReferenceContext);
begin
  assert(value is TFhirDocumentReferenceContext);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterParticipant }

constructor TFhirEncounterParticipant.Create;
begin
  inherited;
  FType_List := TFhirCodeableConceptList.Create;
end;

destructor TFhirEncounterParticipant.Destroy;
begin
  FType_List.Free;
  FIndividual.free;
  inherited;
end;

procedure TFhirEncounterParticipant.Assign(oSource : TAdvObject);
begin
  inherited;
  FType_List.Assign(TFhirEncounterParticipant(oSource).FType_List);
  individual := TFhirEncounterParticipant(oSource).individual.Clone;
end;

procedure TFhirEncounterParticipant.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.addAll(FType_List);
  if (child_name = 'individual') Then
     list.add(Individual.Link);
end;

procedure TFhirEncounterParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'individual', 'Resource(Practitioner|RelatedPerson)', FIndividual.Link.Link));{2}
end;

function TFhirEncounterParticipant.Link : TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(inherited Link);
end;

function TFhirEncounterParticipant.Clone : TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(inherited Clone);
end;

{ TFhirEncounterParticipant }

Procedure TFhirEncounterParticipant.SetIndividual(value : TFhirResourceReference{Resource});
begin
  FIndividual.free;
  FIndividual := value;
end;


{ TFhirEncounterParticipantList }
procedure TFhirEncounterParticipantList.AddItem(value: TFhirEncounterParticipant);
begin
  assert(value.ClassName = 'TFhirEncounterParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterParticipant');
  add(value);
end;


function TFhirEncounterParticipantList.Append: TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirEncounterParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterParticipantList.Clone: TFhirEncounterParticipantList;
begin
  result := TFhirEncounterParticipantList(inherited Clone);
end;

function TFhirEncounterParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterParticipantList.GetItemN(index: Integer): TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(ObjectByIndex[index]);
end;

function TFhirEncounterParticipantList.IndexOf(value: TFhirEncounterParticipant): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirEncounterParticipantList.Insert(index: Integer): TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirEncounterParticipantList.InsertItem(index: Integer; value: TFhirEncounterParticipant);
begin
  assert(value is TFhirEncounterParticipant);
  Inherited Insert(index, value);
end;

function TFhirEncounterParticipantList.Item(index: Integer): TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(ObjectByIndex[index]);
end;

function TFhirEncounterParticipantList.Link: TFhirEncounterParticipantList;
begin
  result := TFhirEncounterParticipantList(inherited Link);
end;

procedure TFhirEncounterParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterParticipantList.SetItemByIndex(index: Integer; value: TFhirEncounterParticipant);
begin
  assert(value is TFhirEncounterParticipant);
  FhirEncounterParticipants[index] := value;
end;

procedure TFhirEncounterParticipantList.SetItemN(index: Integer; value: TFhirEncounterParticipant);
begin
  assert(value is TFhirEncounterParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterHospitalization }

constructor TFhirEncounterHospitalization.Create;
begin
  inherited;
  FAccomodationList := TFhirEncounterHospitalizationAccomodationList.Create;
  FSpecialCourtesyList := TFhirCodeableConceptList.Create;
  FSpecialArrangementList := TFhirCodeableConceptList.Create;
end;

destructor TFhirEncounterHospitalization.Destroy;
begin
  FPreAdmissionIdentifier.free;
  FOrigin.free;
  FAdmitSource.free;
  FPeriod.free;
  FAccomodationList.Free;
  FDiet.free;
  FSpecialCourtesyList.Free;
  FSpecialArrangementList.Free;
  FDestination.free;
  FDischargeDisposition.free;
  FDischargeDiagnosis.free;
  FReAdmission.free;
  inherited;
end;

procedure TFhirEncounterHospitalization.Assign(oSource : TAdvObject);
begin
  inherited;
  preAdmissionIdentifier := TFhirEncounterHospitalization(oSource).preAdmissionIdentifier.Clone;
  origin := TFhirEncounterHospitalization(oSource).origin.Clone;
  admitSource := TFhirEncounterHospitalization(oSource).admitSource.Clone;
  period := TFhirEncounterHospitalization(oSource).period.Clone;
  FAccomodationList.Assign(TFhirEncounterHospitalization(oSource).FAccomodationList);
  diet := TFhirEncounterHospitalization(oSource).diet.Clone;
  FSpecialCourtesyList.Assign(TFhirEncounterHospitalization(oSource).FSpecialCourtesyList);
  FSpecialArrangementList.Assign(TFhirEncounterHospitalization(oSource).FSpecialArrangementList);
  destination := TFhirEncounterHospitalization(oSource).destination.Clone;
  dischargeDisposition := TFhirEncounterHospitalization(oSource).dischargeDisposition.Clone;
  dischargeDiagnosis := TFhirEncounterHospitalization(oSource).dischargeDiagnosis.Clone;
  reAdmission := TFhirEncounterHospitalization(oSource).reAdmission.Clone;
end;

procedure TFhirEncounterHospitalization.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'preAdmissionIdentifier') Then
     list.add(PreAdmissionIdentifier.Link);
  if (child_name = 'origin') Then
     list.add(Origin.Link);
  if (child_name = 'admitSource') Then
     list.add(AdmitSource.Link);
  if (child_name = 'period') Then
     list.add(Period.Link);
  if (child_name = 'accomodation') Then
     list.addAll(FAccomodationList);
  if (child_name = 'diet') Then
     list.add(Diet.Link);
  if (child_name = 'specialCourtesy') Then
     list.addAll(FSpecialCourtesyList);
  if (child_name = 'specialArrangement') Then
     list.addAll(FSpecialArrangementList);
  if (child_name = 'destination') Then
     list.add(Destination.Link);
  if (child_name = 'dischargeDisposition') Then
     list.add(DischargeDisposition.Link);
  if (child_name = 'dischargeDiagnosis') Then
     list.add(DischargeDiagnosis.Link);
  if (child_name = 'reAdmission') Then
     list.add(ReAdmission.Link);
end;

procedure TFhirEncounterHospitalization.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'preAdmissionIdentifier', 'Identifier', FPreAdmissionIdentifier.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'origin', 'Resource(Location)', FOrigin.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'admitSource', 'CodeableConcept', FAdmitSource.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', FPeriod.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'accomodation', '', FAccomodationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'diet', 'CodeableConcept', FDiet.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'specialCourtesy', 'CodeableConcept', FSpecialCourtesyList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'specialArrangement', 'CodeableConcept', FSpecialArrangementList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'destination', 'Resource(Location)', FDestination.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dischargeDisposition', 'CodeableConcept', FDischargeDisposition.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dischargeDiagnosis', 'Resource(Any)', FDischargeDiagnosis.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reAdmission', 'boolean', FReAdmission.Link.Link));{2}
end;

function TFhirEncounterHospitalization.Link : TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization(inherited Link);
end;

function TFhirEncounterHospitalization.Clone : TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization(inherited Clone);
end;

{ TFhirEncounterHospitalization }

Procedure TFhirEncounterHospitalization.SetPreAdmissionIdentifier(value : TFhirIdentifier);
begin
  FPreAdmissionIdentifier.free;
  FPreAdmissionIdentifier := value;
end;

Procedure TFhirEncounterHospitalization.SetOrigin(value : TFhirResourceReference{TFhirLocation});
begin
  FOrigin.free;
  FOrigin := value;
end;

Procedure TFhirEncounterHospitalization.SetAdmitSource(value : TFhirCodeableConcept);
begin
  FAdmitSource.free;
  FAdmitSource := value;
end;

Procedure TFhirEncounterHospitalization.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirEncounterHospitalization.SetDiet(value : TFhirCodeableConcept);
begin
  FDiet.free;
  FDiet := value;
end;

Procedure TFhirEncounterHospitalization.SetDestination(value : TFhirResourceReference{TFhirLocation});
begin
  FDestination.free;
  FDestination := value;
end;

Procedure TFhirEncounterHospitalization.SetDischargeDisposition(value : TFhirCodeableConcept);
begin
  FDischargeDisposition.free;
  FDischargeDisposition := value;
end;

Procedure TFhirEncounterHospitalization.SetDischargeDiagnosis(value : TFhirResourceReference{Resource});
begin
  FDischargeDiagnosis.free;
  FDischargeDiagnosis := value;
end;

Procedure TFhirEncounterHospitalization.SetReAdmission(value : TFhirBoolean);
begin
  FReAdmission.free;
  FReAdmission := value;
end;

Function TFhirEncounterHospitalization.GetReAdmissionST : Boolean;
begin
  if FReAdmission = nil then
    result := false
  else
    result := ReAdmission.value;
end;

Procedure TFhirEncounterHospitalization.SetReAdmissionST(value : Boolean);
begin
  if FReAdmission = nil then
    FReAdmission := TFhirBoolean.create;
  FReAdmission.value := value
end;


{ TFhirEncounterHospitalizationList }
procedure TFhirEncounterHospitalizationList.AddItem(value: TFhirEncounterHospitalization);
begin
  assert(value.ClassName = 'TFhirEncounterHospitalization', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterHospitalization');
  add(value);
end;


function TFhirEncounterHospitalizationList.Append: TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirEncounterHospitalizationList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterHospitalizationList.Clone: TFhirEncounterHospitalizationList;
begin
  result := TFhirEncounterHospitalizationList(inherited Clone);
end;

function TFhirEncounterHospitalizationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterHospitalizationList.GetItemN(index: Integer): TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization(ObjectByIndex[index]);
end;

function TFhirEncounterHospitalizationList.IndexOf(value: TFhirEncounterHospitalization): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirEncounterHospitalizationList.Insert(index: Integer): TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirEncounterHospitalizationList.InsertItem(index: Integer; value: TFhirEncounterHospitalization);
begin
  assert(value is TFhirEncounterHospitalization);
  Inherited Insert(index, value);
end;

function TFhirEncounterHospitalizationList.Item(index: Integer): TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization(ObjectByIndex[index]);
end;

function TFhirEncounterHospitalizationList.Link: TFhirEncounterHospitalizationList;
begin
  result := TFhirEncounterHospitalizationList(inherited Link);
end;

procedure TFhirEncounterHospitalizationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterHospitalizationList.SetItemByIndex(index: Integer; value: TFhirEncounterHospitalization);
begin
  assert(value is TFhirEncounterHospitalization);
  FhirEncounterHospitalizations[index] := value;
end;

procedure TFhirEncounterHospitalizationList.SetItemN(index: Integer; value: TFhirEncounterHospitalization);
begin
  assert(value is TFhirEncounterHospitalization);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterHospitalizationAccomodation }

constructor TFhirEncounterHospitalizationAccomodation.Create;
begin
  inherited;
end;

destructor TFhirEncounterHospitalizationAccomodation.Destroy;
begin
  FBed.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirEncounterHospitalizationAccomodation.Assign(oSource : TAdvObject);
begin
  inherited;
  bed := TFhirEncounterHospitalizationAccomodation(oSource).bed.Clone;
  period := TFhirEncounterHospitalizationAccomodation(oSource).period.Clone;
end;

procedure TFhirEncounterHospitalizationAccomodation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'bed') Then
     list.add(Bed.Link);
  if (child_name = 'period') Then
     list.add(Period.Link);
end;

procedure TFhirEncounterHospitalizationAccomodation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'bed', 'Resource(Location)', FBed.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', FPeriod.Link.Link));{2}
end;

function TFhirEncounterHospitalizationAccomodation.Link : TFhirEncounterHospitalizationAccomodation;
begin
  result := TFhirEncounterHospitalizationAccomodation(inherited Link);
end;

function TFhirEncounterHospitalizationAccomodation.Clone : TFhirEncounterHospitalizationAccomodation;
begin
  result := TFhirEncounterHospitalizationAccomodation(inherited Clone);
end;

{ TFhirEncounterHospitalizationAccomodation }

Procedure TFhirEncounterHospitalizationAccomodation.SetBed(value : TFhirResourceReference{TFhirLocation});
begin
  FBed.free;
  FBed := value;
end;

Procedure TFhirEncounterHospitalizationAccomodation.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;


{ TFhirEncounterHospitalizationAccomodationList }
procedure TFhirEncounterHospitalizationAccomodationList.AddItem(value: TFhirEncounterHospitalizationAccomodation);
begin
  assert(value.ClassName = 'TFhirEncounterHospitalizationAccomodation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterHospitalizationAccomodation');
  add(value);
end;


function TFhirEncounterHospitalizationAccomodationList.Append: TFhirEncounterHospitalizationAccomodation;
begin
  result := TFhirEncounterHospitalizationAccomodation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirEncounterHospitalizationAccomodationList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterHospitalizationAccomodationList.Clone: TFhirEncounterHospitalizationAccomodationList;
begin
  result := TFhirEncounterHospitalizationAccomodationList(inherited Clone);
end;

function TFhirEncounterHospitalizationAccomodationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterHospitalizationAccomodationList.GetItemN(index: Integer): TFhirEncounterHospitalizationAccomodation;
begin
  result := TFhirEncounterHospitalizationAccomodation(ObjectByIndex[index]);
end;

function TFhirEncounterHospitalizationAccomodationList.IndexOf(value: TFhirEncounterHospitalizationAccomodation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirEncounterHospitalizationAccomodationList.Insert(index: Integer): TFhirEncounterHospitalizationAccomodation;
begin
  result := TFhirEncounterHospitalizationAccomodation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirEncounterHospitalizationAccomodationList.InsertItem(index: Integer; value: TFhirEncounterHospitalizationAccomodation);
begin
  assert(value is TFhirEncounterHospitalizationAccomodation);
  Inherited Insert(index, value);
end;

function TFhirEncounterHospitalizationAccomodationList.Item(index: Integer): TFhirEncounterHospitalizationAccomodation;
begin
  result := TFhirEncounterHospitalizationAccomodation(ObjectByIndex[index]);
end;

function TFhirEncounterHospitalizationAccomodationList.Link: TFhirEncounterHospitalizationAccomodationList;
begin
  result := TFhirEncounterHospitalizationAccomodationList(inherited Link);
end;

procedure TFhirEncounterHospitalizationAccomodationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterHospitalizationAccomodationList.SetItemByIndex(index: Integer; value: TFhirEncounterHospitalizationAccomodation);
begin
  assert(value is TFhirEncounterHospitalizationAccomodation);
  FhirEncounterHospitalizationAccomodations[index] := value;
end;

procedure TFhirEncounterHospitalizationAccomodationList.SetItemN(index: Integer; value: TFhirEncounterHospitalizationAccomodation);
begin
  assert(value is TFhirEncounterHospitalizationAccomodation);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterLocation }

constructor TFhirEncounterLocation.Create;
begin
  inherited;
end;

destructor TFhirEncounterLocation.Destroy;
begin
  FLocation.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirEncounterLocation.Assign(oSource : TAdvObject);
begin
  inherited;
  location := TFhirEncounterLocation(oSource).location.Clone;
  period := TFhirEncounterLocation(oSource).period.Clone;
end;

procedure TFhirEncounterLocation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'location') Then
     list.add(Location.Link);
  if (child_name = 'period') Then
     list.add(Period.Link);
end;

procedure TFhirEncounterLocation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'location', 'Resource(Location)', FLocation.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', FPeriod.Link.Link));{2}
end;

function TFhirEncounterLocation.Link : TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(inherited Link);
end;

function TFhirEncounterLocation.Clone : TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(inherited Clone);
end;

{ TFhirEncounterLocation }

Procedure TFhirEncounterLocation.SetLocation(value : TFhirResourceReference{TFhirLocation});
begin
  FLocation.free;
  FLocation := value;
end;

Procedure TFhirEncounterLocation.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;


{ TFhirEncounterLocationList }
procedure TFhirEncounterLocationList.AddItem(value: TFhirEncounterLocation);
begin
  assert(value.ClassName = 'TFhirEncounterLocation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterLocation');
  add(value);
end;


function TFhirEncounterLocationList.Append: TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirEncounterLocationList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterLocationList.Clone: TFhirEncounterLocationList;
begin
  result := TFhirEncounterLocationList(inherited Clone);
end;

function TFhirEncounterLocationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterLocationList.GetItemN(index: Integer): TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(ObjectByIndex[index]);
end;

function TFhirEncounterLocationList.IndexOf(value: TFhirEncounterLocation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirEncounterLocationList.Insert(index: Integer): TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirEncounterLocationList.InsertItem(index: Integer; value: TFhirEncounterLocation);
begin
  assert(value is TFhirEncounterLocation);
  Inherited Insert(index, value);
end;

function TFhirEncounterLocationList.Item(index: Integer): TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(ObjectByIndex[index]);
end;

function TFhirEncounterLocationList.Link: TFhirEncounterLocationList;
begin
  result := TFhirEncounterLocationList(inherited Link);
end;

procedure TFhirEncounterLocationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterLocationList.SetItemByIndex(index: Integer; value: TFhirEncounterLocation);
begin
  assert(value is TFhirEncounterLocation);
  FhirEncounterLocations[index] := value;
end;

procedure TFhirEncounterLocationList.SetItemN(index: Integer; value: TFhirEncounterLocation);
begin
  assert(value is TFhirEncounterLocation);
  ObjectByIndex[index] := value;
end;

{ TFhirFamilyHistoryRelation }

constructor TFhirFamilyHistoryRelation.Create;
begin
  inherited;
  FConditionList := TFhirFamilyHistoryRelationConditionList.Create;
end;

destructor TFhirFamilyHistoryRelation.Destroy;
begin
  FName.free;
  FRelationship.free;
  FBorn.free;
  FDeceased.free;
  FNote.free;
  FConditionList.Free;
  inherited;
end;

procedure TFhirFamilyHistoryRelation.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirFamilyHistoryRelation(oSource).name.Clone;
  relationship := TFhirFamilyHistoryRelation(oSource).relationship.Clone;
  born := TFhirFamilyHistoryRelation(oSource).born.Clone;
  deceased := TFhirFamilyHistoryRelation(oSource).deceased.Clone;
  note := TFhirFamilyHistoryRelation(oSource).note.Clone;
  FConditionList.Assign(TFhirFamilyHistoryRelation(oSource).FConditionList);
end;

procedure TFhirFamilyHistoryRelation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'relationship') Then
     list.add(Relationship.Link);
  if (child_name = 'born') Then
     list.add(Born.Link);
  if (child_name = 'deceased') Then
     list.add(Deceased.Link);
  if (child_name = 'note') Then
     list.add(Note.Link);
  if (child_name = 'condition') Then
     list.addAll(FConditionList);
end;

procedure TFhirFamilyHistoryRelation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', FRelationship.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'born[x]', 'Period|date|string', FBorn.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'deceased[x]', 'boolean|Age|Range|date|string', FDeceased.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'string', FNote.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'condition', '', FConditionList.Link)){3};
end;

function TFhirFamilyHistoryRelation.Link : TFhirFamilyHistoryRelation;
begin
  result := TFhirFamilyHistoryRelation(inherited Link);
end;

function TFhirFamilyHistoryRelation.Clone : TFhirFamilyHistoryRelation;
begin
  result := TFhirFamilyHistoryRelation(inherited Clone);
end;

{ TFhirFamilyHistoryRelation }

Procedure TFhirFamilyHistoryRelation.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirFamilyHistoryRelation.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirFamilyHistoryRelation.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirFamilyHistoryRelation.SetRelationship(value : TFhirCodeableConcept);
begin
  FRelationship.free;
  FRelationship := value;
end;

Procedure TFhirFamilyHistoryRelation.SetBorn(value : TFhirType);
begin
  FBorn.free;
  FBorn := value;
end;

Procedure TFhirFamilyHistoryRelation.SetDeceased(value : TFhirType);
begin
  FDeceased.free;
  FDeceased := value;
end;

Procedure TFhirFamilyHistoryRelation.SetNote(value : TFhirString);
begin
  FNote.free;
  FNote := value;
end;

Function TFhirFamilyHistoryRelation.GetNoteST : String;
begin
  if FNote = nil then
    result := ''
  else
    result := Note.value;
end;

Procedure TFhirFamilyHistoryRelation.SetNoteST(value : String);
begin
  if value <> '' then
  begin
    if FNote = nil then
      FNote := TFhirString.create;
    FNote.value := value
  end
  else if FNote <> nil then
    FNote.value := '';
end;


{ TFhirFamilyHistoryRelationList }
procedure TFhirFamilyHistoryRelationList.AddItem(value: TFhirFamilyHistoryRelation);
begin
  assert(value.ClassName = 'TFhirFamilyHistoryRelation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirFamilyHistoryRelation');
  add(value);
end;


function TFhirFamilyHistoryRelationList.Append: TFhirFamilyHistoryRelation;
begin
  result := TFhirFamilyHistoryRelation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirFamilyHistoryRelationList.ClearItems;
begin
  Clear;
end;

function TFhirFamilyHistoryRelationList.Clone: TFhirFamilyHistoryRelationList;
begin
  result := TFhirFamilyHistoryRelationList(inherited Clone);
end;

function TFhirFamilyHistoryRelationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirFamilyHistoryRelationList.GetItemN(index: Integer): TFhirFamilyHistoryRelation;
begin
  result := TFhirFamilyHistoryRelation(ObjectByIndex[index]);
end;

function TFhirFamilyHistoryRelationList.IndexOf(value: TFhirFamilyHistoryRelation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirFamilyHistoryRelationList.Insert(index: Integer): TFhirFamilyHistoryRelation;
begin
  result := TFhirFamilyHistoryRelation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirFamilyHistoryRelationList.InsertItem(index: Integer; value: TFhirFamilyHistoryRelation);
begin
  assert(value is TFhirFamilyHistoryRelation);
  Inherited Insert(index, value);
end;

function TFhirFamilyHistoryRelationList.Item(index: Integer): TFhirFamilyHistoryRelation;
begin
  result := TFhirFamilyHistoryRelation(ObjectByIndex[index]);
end;

function TFhirFamilyHistoryRelationList.Link: TFhirFamilyHistoryRelationList;
begin
  result := TFhirFamilyHistoryRelationList(inherited Link);
end;

procedure TFhirFamilyHistoryRelationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirFamilyHistoryRelationList.SetItemByIndex(index: Integer; value: TFhirFamilyHistoryRelation);
begin
  assert(value is TFhirFamilyHistoryRelation);
  FhirFamilyHistoryRelations[index] := value;
end;

procedure TFhirFamilyHistoryRelationList.SetItemN(index: Integer; value: TFhirFamilyHistoryRelation);
begin
  assert(value is TFhirFamilyHistoryRelation);
  ObjectByIndex[index] := value;
end;

{ TFhirFamilyHistoryRelationCondition }

constructor TFhirFamilyHistoryRelationCondition.Create;
begin
  inherited;
end;

destructor TFhirFamilyHistoryRelationCondition.Destroy;
begin
  FType_.free;
  FOutcome.free;
  FOnset.free;
  FNote.free;
  inherited;
end;

procedure TFhirFamilyHistoryRelationCondition.Assign(oSource : TAdvObject);
begin
  inherited;
  type_ := TFhirFamilyHistoryRelationCondition(oSource).type_.Clone;
  outcome := TFhirFamilyHistoryRelationCondition(oSource).outcome.Clone;
  onset := TFhirFamilyHistoryRelationCondition(oSource).onset.Clone;
  note := TFhirFamilyHistoryRelationCondition(oSource).note.Clone;
end;

procedure TFhirFamilyHistoryRelationCondition.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'outcome') Then
     list.add(Outcome.Link);
  if (child_name = 'onset') Then
     list.add(Onset.Link);
  if (child_name = 'note') Then
     list.add(Note.Link);
end;

procedure TFhirFamilyHistoryRelationCondition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableConcept', FOutcome.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onset[x]', 'Age|Range|string', FOnset.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'string', FNote.Link.Link));{2}
end;

function TFhirFamilyHistoryRelationCondition.Link : TFhirFamilyHistoryRelationCondition;
begin
  result := TFhirFamilyHistoryRelationCondition(inherited Link);
end;

function TFhirFamilyHistoryRelationCondition.Clone : TFhirFamilyHistoryRelationCondition;
begin
  result := TFhirFamilyHistoryRelationCondition(inherited Clone);
end;

{ TFhirFamilyHistoryRelationCondition }

Procedure TFhirFamilyHistoryRelationCondition.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirFamilyHistoryRelationCondition.SetOutcome(value : TFhirCodeableConcept);
begin
  FOutcome.free;
  FOutcome := value;
end;

Procedure TFhirFamilyHistoryRelationCondition.SetOnset(value : TFhirType);
begin
  FOnset.free;
  FOnset := value;
end;

Procedure TFhirFamilyHistoryRelationCondition.SetNote(value : TFhirString);
begin
  FNote.free;
  FNote := value;
end;

Function TFhirFamilyHistoryRelationCondition.GetNoteST : String;
begin
  if FNote = nil then
    result := ''
  else
    result := Note.value;
end;

Procedure TFhirFamilyHistoryRelationCondition.SetNoteST(value : String);
begin
  if value <> '' then
  begin
    if FNote = nil then
      FNote := TFhirString.create;
    FNote.value := value
  end
  else if FNote <> nil then
    FNote.value := '';
end;


{ TFhirFamilyHistoryRelationConditionList }
procedure TFhirFamilyHistoryRelationConditionList.AddItem(value: TFhirFamilyHistoryRelationCondition);
begin
  assert(value.ClassName = 'TFhirFamilyHistoryRelationCondition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirFamilyHistoryRelationCondition');
  add(value);
end;


function TFhirFamilyHistoryRelationConditionList.Append: TFhirFamilyHistoryRelationCondition;
begin
  result := TFhirFamilyHistoryRelationCondition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirFamilyHistoryRelationConditionList.ClearItems;
begin
  Clear;
end;

function TFhirFamilyHistoryRelationConditionList.Clone: TFhirFamilyHistoryRelationConditionList;
begin
  result := TFhirFamilyHistoryRelationConditionList(inherited Clone);
end;

function TFhirFamilyHistoryRelationConditionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirFamilyHistoryRelationConditionList.GetItemN(index: Integer): TFhirFamilyHistoryRelationCondition;
begin
  result := TFhirFamilyHistoryRelationCondition(ObjectByIndex[index]);
end;

function TFhirFamilyHistoryRelationConditionList.IndexOf(value: TFhirFamilyHistoryRelationCondition): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirFamilyHistoryRelationConditionList.Insert(index: Integer): TFhirFamilyHistoryRelationCondition;
begin
  result := TFhirFamilyHistoryRelationCondition.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirFamilyHistoryRelationConditionList.InsertItem(index: Integer; value: TFhirFamilyHistoryRelationCondition);
begin
  assert(value is TFhirFamilyHistoryRelationCondition);
  Inherited Insert(index, value);
end;

function TFhirFamilyHistoryRelationConditionList.Item(index: Integer): TFhirFamilyHistoryRelationCondition;
begin
  result := TFhirFamilyHistoryRelationCondition(ObjectByIndex[index]);
end;

function TFhirFamilyHistoryRelationConditionList.Link: TFhirFamilyHistoryRelationConditionList;
begin
  result := TFhirFamilyHistoryRelationConditionList(inherited Link);
end;

procedure TFhirFamilyHistoryRelationConditionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirFamilyHistoryRelationConditionList.SetItemByIndex(index: Integer; value: TFhirFamilyHistoryRelationCondition);
begin
  assert(value is TFhirFamilyHistoryRelationCondition);
  FhirFamilyHistoryRelationConditions[index] := value;
end;

procedure TFhirFamilyHistoryRelationConditionList.SetItemN(index: Integer; value: TFhirFamilyHistoryRelationCondition);
begin
  assert(value is TFhirFamilyHistoryRelationCondition);
  ObjectByIndex[index] := value;
end;

{ TFhirGroupCharacteristic }

constructor TFhirGroupCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirGroupCharacteristic.Destroy;
begin
  FCode.free;
  FValue.free;
  FExclude.free;
  inherited;
end;

procedure TFhirGroupCharacteristic.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirGroupCharacteristic(oSource).code.Clone;
  value := TFhirGroupCharacteristic(oSource).value.Clone;
  exclude := TFhirGroupCharacteristic(oSource).exclude.Clone;
end;

procedure TFhirGroupCharacteristic.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'value') Then
     list.add(Value.Link);
  if (child_name = 'exclude') Then
     list.add(Exclude.Link);
end;

procedure TFhirGroupCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|boolean|Quantity|Range', FValue.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'exclude', 'boolean', FExclude.Link.Link));{2}
end;

function TFhirGroupCharacteristic.Link : TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(inherited Link);
end;

function TFhirGroupCharacteristic.Clone : TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(inherited Clone);
end;

{ TFhirGroupCharacteristic }

Procedure TFhirGroupCharacteristic.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirGroupCharacteristic.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

Procedure TFhirGroupCharacteristic.SetExclude(value : TFhirBoolean);
begin
  FExclude.free;
  FExclude := value;
end;

Function TFhirGroupCharacteristic.GetExcludeST : Boolean;
begin
  if FExclude = nil then
    result := false
  else
    result := Exclude.value;
end;

Procedure TFhirGroupCharacteristic.SetExcludeST(value : Boolean);
begin
  if FExclude = nil then
    FExclude := TFhirBoolean.create;
  FExclude.value := value
end;


{ TFhirGroupCharacteristicList }
procedure TFhirGroupCharacteristicList.AddItem(value: TFhirGroupCharacteristic);
begin
  assert(value.ClassName = 'TFhirGroupCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGroupCharacteristic');
  add(value);
end;


function TFhirGroupCharacteristicList.Append: TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirGroupCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirGroupCharacteristicList.Clone: TFhirGroupCharacteristicList;
begin
  result := TFhirGroupCharacteristicList(inherited Clone);
end;

function TFhirGroupCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGroupCharacteristicList.GetItemN(index: Integer): TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(ObjectByIndex[index]);
end;

function TFhirGroupCharacteristicList.IndexOf(value: TFhirGroupCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirGroupCharacteristicList.Insert(index: Integer): TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirGroupCharacteristicList.InsertItem(index: Integer; value: TFhirGroupCharacteristic);
begin
  assert(value is TFhirGroupCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirGroupCharacteristicList.Item(index: Integer): TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(ObjectByIndex[index]);
end;

function TFhirGroupCharacteristicList.Link: TFhirGroupCharacteristicList;
begin
  result := TFhirGroupCharacteristicList(inherited Link);
end;

procedure TFhirGroupCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGroupCharacteristicList.SetItemByIndex(index: Integer; value: TFhirGroupCharacteristic);
begin
  assert(value is TFhirGroupCharacteristic);
  FhirGroupCharacteristics[index] := value;
end;

procedure TFhirGroupCharacteristicList.SetItemN(index: Integer; value: TFhirGroupCharacteristic);
begin
  assert(value is TFhirGroupCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirImagingStudySeries }

constructor TFhirImagingStudySeries.Create;
begin
  inherited;
  FInstanceList := TFhirImagingStudySeriesInstanceList.Create;
end;

destructor TFhirImagingStudySeries.Destroy;
begin
  FNumber.free;
  FModality.free;
  FUid.free;
  FDescription.free;
  FNumberOfInstances.free;
  FAvailability.free;
  FUrl.free;
  FBodySite.free;
  FDateTime.free;
  FInstanceList.Free;
  inherited;
end;

procedure TFhirImagingStudySeries.Assign(oSource : TAdvObject);
begin
  inherited;
  number := TFhirImagingStudySeries(oSource).number.Clone;
  FModality := TFhirImagingStudySeries(oSource).FModality.Link;
  uid := TFhirImagingStudySeries(oSource).uid.Clone;
  description := TFhirImagingStudySeries(oSource).description.Clone;
  numberOfInstances := TFhirImagingStudySeries(oSource).numberOfInstances.Clone;
  FAvailability := TFhirImagingStudySeries(oSource).FAvailability.Link;
  url := TFhirImagingStudySeries(oSource).url.Clone;
  bodySite := TFhirImagingStudySeries(oSource).bodySite.Clone;
  dateTime := TFhirImagingStudySeries(oSource).dateTime.Clone;
  FInstanceList.Assign(TFhirImagingStudySeries(oSource).FInstanceList);
end;

procedure TFhirImagingStudySeries.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'number') Then
     list.add(Number.Link);
  if (child_name = 'modality') Then
     list.add(FModality.Link);
  if (child_name = 'uid') Then
     list.add(Uid.Link);
  if (child_name = 'description') Then
     list.add(Description.Link);
  if (child_name = 'numberOfInstances') Then
     list.add(NumberOfInstances.Link);
  if (child_name = 'availability') Then
     list.add(FAvailability.Link);
  if (child_name = 'url') Then
     list.add(Url.Link);
  if (child_name = 'bodySite') Then
     list.add(BodySite.Link);
  if (child_name = 'dateTime') Then
     list.add(DateTime.Link);
  if (child_name = 'instance') Then
     list.addAll(FInstanceList);
end;

procedure TFhirImagingStudySeries.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'number', 'integer', FNumber.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modality', 'code', FModality.Link));{1}
  oList.add(TFHIRProperty.create(self, 'uid', 'oid', FUid.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'numberOfInstances', 'integer', FNumberOfInstances.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'availability', 'code', FAvailability.Link));{1}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', FUrl.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'bodySite', 'Coding', FBodySite.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dateTime', 'dateTime', FDateTime.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'instance', '', FInstanceList.Link)){3};
end;

function TFhirImagingStudySeries.Link : TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(inherited Link);
end;

function TFhirImagingStudySeries.Clone : TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(inherited Clone);
end;

{ TFhirImagingStudySeries }

Procedure TFhirImagingStudySeries.SetNumber(value : TFhirInteger);
begin
  FNumber.free;
  FNumber := value;
end;

Function TFhirImagingStudySeries.GetNumberST : String;
begin
  if FNumber = nil then
    result := ''
  else
    result := Number.value;
end;

Procedure TFhirImagingStudySeries.SetNumberST(value : String);
begin
  if value <> '' then
  begin
    if FNumber = nil then
      FNumber := TFhirInteger.create;
    FNumber.value := value
  end
  else if FNumber <> nil then
    FNumber.value := '';
end;

Procedure TFhirImagingStudySeries.SetModality(value : TFhirEnum);
begin
  FModality.free;
  FModality := value;
end;

Function TFhirImagingStudySeries.GetModalityST : TFhirModality;
begin
  if FModality = nil then
    result := TFhirModality(0)
  else
    result := TFhirModality(StringArrayIndexOf(CODES_TFhirModality, Modality.value));
end;

Procedure TFhirImagingStudySeries.SetModalityST(value : TFhirModality);
begin
  if ord(value) = 0 then
    Modality := nil
  else
    Modality := TFhirEnum.create(CODES_TFhirModality[value]);
end;

Procedure TFhirImagingStudySeries.SetUid(value : TFhirOid);
begin
  FUid.free;
  FUid := value;
end;

Function TFhirImagingStudySeries.GetUidST : String;
begin
  if FUid = nil then
    result := ''
  else
    result := Uid.value;
end;

Procedure TFhirImagingStudySeries.SetUidST(value : String);
begin
  if value <> '' then
  begin
    if FUid = nil then
      FUid := TFhirOid.create;
    FUid.value := value
  end
  else if FUid <> nil then
    FUid.value := '';
end;

Procedure TFhirImagingStudySeries.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirImagingStudySeries.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := Description.value;
end;

Procedure TFhirImagingStudySeries.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirImagingStudySeries.SetNumberOfInstances(value : TFhirInteger);
begin
  FNumberOfInstances.free;
  FNumberOfInstances := value;
end;

Function TFhirImagingStudySeries.GetNumberOfInstancesST : String;
begin
  if FNumberOfInstances = nil then
    result := ''
  else
    result := NumberOfInstances.value;
end;

Procedure TFhirImagingStudySeries.SetNumberOfInstancesST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfInstances = nil then
      FNumberOfInstances := TFhirInteger.create;
    FNumberOfInstances.value := value
  end
  else if FNumberOfInstances <> nil then
    FNumberOfInstances.value := '';
end;

Procedure TFhirImagingStudySeries.SetAvailability(value : TFhirEnum);
begin
  FAvailability.free;
  FAvailability := value;
end;

Function TFhirImagingStudySeries.GetAvailabilityST : TFhirInstanceAvailability;
begin
  if FAvailability = nil then
    result := TFhirInstanceAvailability(0)
  else
    result := TFhirInstanceAvailability(StringArrayIndexOf(CODES_TFhirInstanceAvailability, Availability.value));
end;

Procedure TFhirImagingStudySeries.SetAvailabilityST(value : TFhirInstanceAvailability);
begin
  if ord(value) = 0 then
    Availability := nil
  else
    Availability := TFhirEnum.create(CODES_TFhirInstanceAvailability[value]);
end;

Procedure TFhirImagingStudySeries.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirImagingStudySeries.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := Url.value;
end;

Procedure TFhirImagingStudySeries.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirImagingStudySeries.SetBodySite(value : TFhirCoding);
begin
  FBodySite.free;
  FBodySite := value;
end;

Procedure TFhirImagingStudySeries.SetDateTime(value : TFhirDateTime);
begin
  FDateTime.free;
  FDateTime := value;
end;

Function TFhirImagingStudySeries.GetDateTimeST : TDateAndTime;
begin
  if FDateTime = nil then
    result := nil
  else
    result := DateTime.value;
end;

Procedure TFhirImagingStudySeries.SetDateTimeST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FDateTime = nil then
      FDateTime := TFhirDateTime.create;
    FDateTime.value := value
  end
  else if FDateTime <> nil then
    FDateTime.value := nil;
end;


{ TFhirImagingStudySeriesList }
procedure TFhirImagingStudySeriesList.AddItem(value: TFhirImagingStudySeries);
begin
  assert(value.ClassName = 'TFhirImagingStudySeries', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingStudySeries');
  add(value);
end;


function TFhirImagingStudySeriesList.Append: TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirImagingStudySeriesList.ClearItems;
begin
  Clear;
end;

function TFhirImagingStudySeriesList.Clone: TFhirImagingStudySeriesList;
begin
  result := TFhirImagingStudySeriesList(inherited Clone);
end;

function TFhirImagingStudySeriesList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingStudySeriesList.GetItemN(index: Integer): TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesList.IndexOf(value: TFhirImagingStudySeries): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirImagingStudySeriesList.Insert(index: Integer): TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirImagingStudySeriesList.InsertItem(index: Integer; value: TFhirImagingStudySeries);
begin
  assert(value is TFhirImagingStudySeries);
  Inherited Insert(index, value);
end;

function TFhirImagingStudySeriesList.Item(index: Integer): TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesList.Link: TFhirImagingStudySeriesList;
begin
  result := TFhirImagingStudySeriesList(inherited Link);
end;

procedure TFhirImagingStudySeriesList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingStudySeriesList.SetItemByIndex(index: Integer; value: TFhirImagingStudySeries);
begin
  assert(value is TFhirImagingStudySeries);
  FhirImagingStudySeries[index] := value;
end;

procedure TFhirImagingStudySeriesList.SetItemN(index: Integer; value: TFhirImagingStudySeries);
begin
  assert(value is TFhirImagingStudySeries);
  ObjectByIndex[index] := value;
end;

{ TFhirImagingStudySeriesInstance }

constructor TFhirImagingStudySeriesInstance.Create;
begin
  inherited;
end;

destructor TFhirImagingStudySeriesInstance.Destroy;
begin
  FNumber.free;
  FUid.free;
  FSopclass.free;
  FType_.free;
  FTitle.free;
  FUrl.free;
  FAttachment.free;
  inherited;
end;

procedure TFhirImagingStudySeriesInstance.Assign(oSource : TAdvObject);
begin
  inherited;
  number := TFhirImagingStudySeriesInstance(oSource).number.Clone;
  uid := TFhirImagingStudySeriesInstance(oSource).uid.Clone;
  sopclass := TFhirImagingStudySeriesInstance(oSource).sopclass.Clone;
  type_ := TFhirImagingStudySeriesInstance(oSource).type_.Clone;
  title := TFhirImagingStudySeriesInstance(oSource).title.Clone;
  url := TFhirImagingStudySeriesInstance(oSource).url.Clone;
  attachment := TFhirImagingStudySeriesInstance(oSource).attachment.Clone;
end;

procedure TFhirImagingStudySeriesInstance.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'number') Then
     list.add(Number.Link);
  if (child_name = 'uid') Then
     list.add(Uid.Link);
  if (child_name = 'sopclass') Then
     list.add(Sopclass.Link);
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'title') Then
     list.add(Title.Link);
  if (child_name = 'url') Then
     list.add(Url.Link);
  if (child_name = 'attachment') Then
     list.add(Attachment.Link);
end;

procedure TFhirImagingStudySeriesInstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'number', 'integer', FNumber.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'uid', 'oid', FUid.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sopclass', 'oid', FSopclass.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'string', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'title', 'string', FTitle.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', FUrl.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'attachment', 'Resource(Any)', FAttachment.Link.Link));{2}
end;

function TFhirImagingStudySeriesInstance.Link : TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(inherited Link);
end;

function TFhirImagingStudySeriesInstance.Clone : TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(inherited Clone);
end;

{ TFhirImagingStudySeriesInstance }

Procedure TFhirImagingStudySeriesInstance.SetNumber(value : TFhirInteger);
begin
  FNumber.free;
  FNumber := value;
end;

Function TFhirImagingStudySeriesInstance.GetNumberST : String;
begin
  if FNumber = nil then
    result := ''
  else
    result := Number.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetNumberST(value : String);
begin
  if value <> '' then
  begin
    if FNumber = nil then
      FNumber := TFhirInteger.create;
    FNumber.value := value
  end
  else if FNumber <> nil then
    FNumber.value := '';
end;

Procedure TFhirImagingStudySeriesInstance.SetUid(value : TFhirOid);
begin
  FUid.free;
  FUid := value;
end;

Function TFhirImagingStudySeriesInstance.GetUidST : String;
begin
  if FUid = nil then
    result := ''
  else
    result := Uid.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetUidST(value : String);
begin
  if value <> '' then
  begin
    if FUid = nil then
      FUid := TFhirOid.create;
    FUid.value := value
  end
  else if FUid <> nil then
    FUid.value := '';
end;

Procedure TFhirImagingStudySeriesInstance.SetSopclass(value : TFhirOid);
begin
  FSopclass.free;
  FSopclass := value;
end;

Function TFhirImagingStudySeriesInstance.GetSopclassST : String;
begin
  if FSopclass = nil then
    result := ''
  else
    result := Sopclass.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetSopclassST(value : String);
begin
  if value <> '' then
  begin
    if FSopclass = nil then
      FSopclass := TFhirOid.create;
    FSopclass.value := value
  end
  else if FSopclass <> nil then
    FSopclass.value := '';
end;

Procedure TFhirImagingStudySeriesInstance.SetType_(value : TFhirString);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirImagingStudySeriesInstance.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := Type_.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirString.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirImagingStudySeriesInstance.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirImagingStudySeriesInstance.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := Title.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

Procedure TFhirImagingStudySeriesInstance.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirImagingStudySeriesInstance.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := Url.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirImagingStudySeriesInstance.SetAttachment(value : TFhirResourceReference{Resource});
begin
  FAttachment.free;
  FAttachment := value;
end;


{ TFhirImagingStudySeriesInstanceList }
procedure TFhirImagingStudySeriesInstanceList.AddItem(value: TFhirImagingStudySeriesInstance);
begin
  assert(value.ClassName = 'TFhirImagingStudySeriesInstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingStudySeriesInstance');
  add(value);
end;


function TFhirImagingStudySeriesInstanceList.Append: TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirImagingStudySeriesInstanceList.ClearItems;
begin
  Clear;
end;

function TFhirImagingStudySeriesInstanceList.Clone: TFhirImagingStudySeriesInstanceList;
begin
  result := TFhirImagingStudySeriesInstanceList(inherited Clone);
end;

function TFhirImagingStudySeriesInstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingStudySeriesInstanceList.GetItemN(index: Integer): TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesInstanceList.IndexOf(value: TFhirImagingStudySeriesInstance): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirImagingStudySeriesInstanceList.Insert(index: Integer): TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirImagingStudySeriesInstanceList.InsertItem(index: Integer; value: TFhirImagingStudySeriesInstance);
begin
  assert(value is TFhirImagingStudySeriesInstance);
  Inherited Insert(index, value);
end;

function TFhirImagingStudySeriesInstanceList.Item(index: Integer): TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesInstanceList.Link: TFhirImagingStudySeriesInstanceList;
begin
  result := TFhirImagingStudySeriesInstanceList(inherited Link);
end;

procedure TFhirImagingStudySeriesInstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingStudySeriesInstanceList.SetItemByIndex(index: Integer; value: TFhirImagingStudySeriesInstance);
begin
  assert(value is TFhirImagingStudySeriesInstance);
  FhirImagingStudySeriesInstances[index] := value;
end;

procedure TFhirImagingStudySeriesInstanceList.SetItemN(index: Integer; value: TFhirImagingStudySeriesInstance);
begin
  assert(value is TFhirImagingStudySeriesInstance);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationExplanation }

constructor TFhirImmunizationExplanation.Create;
begin
  inherited;
  FReasonList := TFhirCodeableConceptList.Create;
  FRefusalReasonList := TFhirCodeableConceptList.Create;
end;

destructor TFhirImmunizationExplanation.Destroy;
begin
  FReasonList.Free;
  FRefusalReasonList.Free;
  inherited;
end;

procedure TFhirImmunizationExplanation.Assign(oSource : TAdvObject);
begin
  inherited;
  FReasonList.Assign(TFhirImmunizationExplanation(oSource).FReasonList);
  FRefusalReasonList.Assign(TFhirImmunizationExplanation(oSource).FRefusalReasonList);
end;

procedure TFhirImmunizationExplanation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'reason') Then
     list.addAll(FReasonList);
  if (child_name = 'refusalReason') Then
     list.addAll(FRefusalReasonList);
end;

procedure TFhirImmunizationExplanation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', FReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'refusalReason', 'CodeableConcept', FRefusalReasonList.Link)){3};
end;

function TFhirImmunizationExplanation.Link : TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation(inherited Link);
end;

function TFhirImmunizationExplanation.Clone : TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation(inherited Clone);
end;

{ TFhirImmunizationExplanation }


{ TFhirImmunizationExplanationList }
procedure TFhirImmunizationExplanationList.AddItem(value: TFhirImmunizationExplanation);
begin
  assert(value.ClassName = 'TFhirImmunizationExplanation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationExplanation');
  add(value);
end;


function TFhirImmunizationExplanationList.Append: TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationExplanationList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationExplanationList.Clone: TFhirImmunizationExplanationList;
begin
  result := TFhirImmunizationExplanationList(inherited Clone);
end;

function TFhirImmunizationExplanationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationExplanationList.GetItemN(index: Integer): TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation(ObjectByIndex[index]);
end;

function TFhirImmunizationExplanationList.IndexOf(value: TFhirImmunizationExplanation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirImmunizationExplanationList.Insert(index: Integer): TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationExplanationList.InsertItem(index: Integer; value: TFhirImmunizationExplanation);
begin
  assert(value is TFhirImmunizationExplanation);
  Inherited Insert(index, value);
end;

function TFhirImmunizationExplanationList.Item(index: Integer): TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation(ObjectByIndex[index]);
end;

function TFhirImmunizationExplanationList.Link: TFhirImmunizationExplanationList;
begin
  result := TFhirImmunizationExplanationList(inherited Link);
end;

procedure TFhirImmunizationExplanationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationExplanationList.SetItemByIndex(index: Integer; value: TFhirImmunizationExplanation);
begin
  assert(value is TFhirImmunizationExplanation);
  FhirImmunizationExplanations[index] := value;
end;

procedure TFhirImmunizationExplanationList.SetItemN(index: Integer; value: TFhirImmunizationExplanation);
begin
  assert(value is TFhirImmunizationExplanation);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationReaction }

constructor TFhirImmunizationReaction.Create;
begin
  inherited;
end;

destructor TFhirImmunizationReaction.Destroy;
begin
  FDate.free;
  FDetail.free;
  FReported.free;
  inherited;
end;

procedure TFhirImmunizationReaction.Assign(oSource : TAdvObject);
begin
  inherited;
  date := TFhirImmunizationReaction(oSource).date.Clone;
  detail := TFhirImmunizationReaction(oSource).detail.Clone;
  reported := TFhirImmunizationReaction(oSource).reported.Clone;
end;

procedure TFhirImmunizationReaction.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'date') Then
     list.add(Date.Link);
  if (child_name = 'detail') Then
     list.add(Detail.Link);
  if (child_name = 'reported') Then
     list.add(Reported.Link);
end;

procedure TFhirImmunizationReaction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', FDate.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', 'Resource(AdverseReaction|Observation)', FDetail.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reported', 'boolean', FReported.Link.Link));{2}
end;

function TFhirImmunizationReaction.Link : TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(inherited Link);
end;

function TFhirImmunizationReaction.Clone : TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(inherited Clone);
end;

{ TFhirImmunizationReaction }

Procedure TFhirImmunizationReaction.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirImmunizationReaction.GetDateST : TDateAndTime;
begin
  if FDate = nil then
    result := nil
  else
    result := Date.value;
end;

Procedure TFhirImmunizationReaction.SetDateST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FDate = nil then
      FDate := TFhirDateTime.create;
    FDate.value := value
  end
  else if FDate <> nil then
    FDate.value := nil;
end;

Procedure TFhirImmunizationReaction.SetDetail(value : TFhirResourceReference{Resource});
begin
  FDetail.free;
  FDetail := value;
end;

Procedure TFhirImmunizationReaction.SetReported(value : TFhirBoolean);
begin
  FReported.free;
  FReported := value;
end;

Function TFhirImmunizationReaction.GetReportedST : Boolean;
begin
  if FReported = nil then
    result := false
  else
    result := Reported.value;
end;

Procedure TFhirImmunizationReaction.SetReportedST(value : Boolean);
begin
  if FReported = nil then
    FReported := TFhirBoolean.create;
  FReported.value := value
end;


{ TFhirImmunizationReactionList }
procedure TFhirImmunizationReactionList.AddItem(value: TFhirImmunizationReaction);
begin
  assert(value.ClassName = 'TFhirImmunizationReaction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationReaction');
  add(value);
end;


function TFhirImmunizationReactionList.Append: TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationReactionList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationReactionList.Clone: TFhirImmunizationReactionList;
begin
  result := TFhirImmunizationReactionList(inherited Clone);
end;

function TFhirImmunizationReactionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationReactionList.GetItemN(index: Integer): TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(ObjectByIndex[index]);
end;

function TFhirImmunizationReactionList.IndexOf(value: TFhirImmunizationReaction): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirImmunizationReactionList.Insert(index: Integer): TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationReactionList.InsertItem(index: Integer; value: TFhirImmunizationReaction);
begin
  assert(value is TFhirImmunizationReaction);
  Inherited Insert(index, value);
end;

function TFhirImmunizationReactionList.Item(index: Integer): TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(ObjectByIndex[index]);
end;

function TFhirImmunizationReactionList.Link: TFhirImmunizationReactionList;
begin
  result := TFhirImmunizationReactionList(inherited Link);
end;

procedure TFhirImmunizationReactionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationReactionList.SetItemByIndex(index: Integer; value: TFhirImmunizationReaction);
begin
  assert(value is TFhirImmunizationReaction);
  FhirImmunizationReactions[index] := value;
end;

procedure TFhirImmunizationReactionList.SetItemN(index: Integer; value: TFhirImmunizationReaction);
begin
  assert(value is TFhirImmunizationReaction);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationVaccinationProtocol }

constructor TFhirImmunizationVaccinationProtocol.Create;
begin
  inherited;
end;

destructor TFhirImmunizationVaccinationProtocol.Destroy;
begin
  FDoseSequence.free;
  FDescription.free;
  FAuthority.free;
  FSeries.free;
  FSeriesDoses.free;
  FDoseTarget.free;
  FDoseStatus.free;
  FDoseStatusReason.free;
  inherited;
end;

procedure TFhirImmunizationVaccinationProtocol.Assign(oSource : TAdvObject);
begin
  inherited;
  doseSequence := TFhirImmunizationVaccinationProtocol(oSource).doseSequence.Clone;
  description := TFhirImmunizationVaccinationProtocol(oSource).description.Clone;
  authority := TFhirImmunizationVaccinationProtocol(oSource).authority.Clone;
  series := TFhirImmunizationVaccinationProtocol(oSource).series.Clone;
  seriesDoses := TFhirImmunizationVaccinationProtocol(oSource).seriesDoses.Clone;
  doseTarget := TFhirImmunizationVaccinationProtocol(oSource).doseTarget.Clone;
  doseStatus := TFhirImmunizationVaccinationProtocol(oSource).doseStatus.Clone;
  doseStatusReason := TFhirImmunizationVaccinationProtocol(oSource).doseStatusReason.Clone;
end;

procedure TFhirImmunizationVaccinationProtocol.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'doseSequence') Then
     list.add(DoseSequence.Link);
  if (child_name = 'description') Then
     list.add(Description.Link);
  if (child_name = 'authority') Then
     list.add(Authority.Link);
  if (child_name = 'series') Then
     list.add(Series.Link);
  if (child_name = 'seriesDoses') Then
     list.add(SeriesDoses.Link);
  if (child_name = 'doseTarget') Then
     list.add(DoseTarget.Link);
  if (child_name = 'doseStatus') Then
     list.add(DoseStatus.Link);
  if (child_name = 'doseStatusReason') Then
     list.add(DoseStatusReason.Link);
end;

procedure TFhirImmunizationVaccinationProtocol.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'doseSequence', 'integer', FDoseSequence.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authority', 'Resource(Organization)', FAuthority.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'series', 'string', FSeries.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'seriesDoses', 'integer', FSeriesDoses.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'doseTarget', 'CodeableConcept', FDoseTarget.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'doseStatus', 'CodeableConcept', FDoseStatus.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'doseStatusReason', 'CodeableConcept', FDoseStatusReason.Link.Link));{2}
end;

function TFhirImmunizationVaccinationProtocol.Link : TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol(inherited Link);
end;

function TFhirImmunizationVaccinationProtocol.Clone : TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol(inherited Clone);
end;

{ TFhirImmunizationVaccinationProtocol }

Procedure TFhirImmunizationVaccinationProtocol.SetDoseSequence(value : TFhirInteger);
begin
  FDoseSequence.free;
  FDoseSequence := value;
end;

Function TFhirImmunizationVaccinationProtocol.GetDoseSequenceST : String;
begin
  if FDoseSequence = nil then
    result := ''
  else
    result := DoseSequence.value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDoseSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FDoseSequence = nil then
      FDoseSequence := TFhirInteger.create;
    FDoseSequence.value := value
  end
  else if FDoseSequence <> nil then
    FDoseSequence.value := '';
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirImmunizationVaccinationProtocol.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := Description.value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirImmunizationVaccinationProtocol.SetAuthority(value : TFhirResourceReference{TFhirOrganization});
begin
  FAuthority.free;
  FAuthority := value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetSeries(value : TFhirString);
begin
  FSeries.free;
  FSeries := value;
end;

Function TFhirImmunizationVaccinationProtocol.GetSeriesST : String;
begin
  if FSeries = nil then
    result := ''
  else
    result := Series.value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetSeriesST(value : String);
begin
  if value <> '' then
  begin
    if FSeries = nil then
      FSeries := TFhirString.create;
    FSeries.value := value
  end
  else if FSeries <> nil then
    FSeries.value := '';
end;

Procedure TFhirImmunizationVaccinationProtocol.SetSeriesDoses(value : TFhirInteger);
begin
  FSeriesDoses.free;
  FSeriesDoses := value;
end;

Function TFhirImmunizationVaccinationProtocol.GetSeriesDosesST : String;
begin
  if FSeriesDoses = nil then
    result := ''
  else
    result := SeriesDoses.value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetSeriesDosesST(value : String);
begin
  if value <> '' then
  begin
    if FSeriesDoses = nil then
      FSeriesDoses := TFhirInteger.create;
    FSeriesDoses.value := value
  end
  else if FSeriesDoses <> nil then
    FSeriesDoses.value := '';
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDoseTarget(value : TFhirCodeableConcept);
begin
  FDoseTarget.free;
  FDoseTarget := value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDoseStatus(value : TFhirCodeableConcept);
begin
  FDoseStatus.free;
  FDoseStatus := value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDoseStatusReason(value : TFhirCodeableConcept);
begin
  FDoseStatusReason.free;
  FDoseStatusReason := value;
end;


{ TFhirImmunizationVaccinationProtocolList }
procedure TFhirImmunizationVaccinationProtocolList.AddItem(value: TFhirImmunizationVaccinationProtocol);
begin
  assert(value.ClassName = 'TFhirImmunizationVaccinationProtocol', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationVaccinationProtocol');
  add(value);
end;


function TFhirImmunizationVaccinationProtocolList.Append: TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationVaccinationProtocolList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationVaccinationProtocolList.Clone: TFhirImmunizationVaccinationProtocolList;
begin
  result := TFhirImmunizationVaccinationProtocolList(inherited Clone);
end;

function TFhirImmunizationVaccinationProtocolList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationVaccinationProtocolList.GetItemN(index: Integer): TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol(ObjectByIndex[index]);
end;

function TFhirImmunizationVaccinationProtocolList.IndexOf(value: TFhirImmunizationVaccinationProtocol): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirImmunizationVaccinationProtocolList.Insert(index: Integer): TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationVaccinationProtocolList.InsertItem(index: Integer; value: TFhirImmunizationVaccinationProtocol);
begin
  assert(value is TFhirImmunizationVaccinationProtocol);
  Inherited Insert(index, value);
end;

function TFhirImmunizationVaccinationProtocolList.Item(index: Integer): TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol(ObjectByIndex[index]);
end;

function TFhirImmunizationVaccinationProtocolList.Link: TFhirImmunizationVaccinationProtocolList;
begin
  result := TFhirImmunizationVaccinationProtocolList(inherited Link);
end;

procedure TFhirImmunizationVaccinationProtocolList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationVaccinationProtocolList.SetItemByIndex(index: Integer; value: TFhirImmunizationVaccinationProtocol);
begin
  assert(value is TFhirImmunizationVaccinationProtocol);
  FhirImmunizationVaccinationProtocols[index] := value;
end;

procedure TFhirImmunizationVaccinationProtocolList.SetItemN(index: Integer; value: TFhirImmunizationVaccinationProtocol);
begin
  assert(value is TFhirImmunizationVaccinationProtocol);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationRecommendationRecommendation }

constructor TFhirImmunizationRecommendationRecommendation.Create;
begin
  inherited;
  FDateCriterionList := TFhirImmunizationRecommendationRecommendationDateCriterionList.Create;
  FSupportingImmunizationList := TFhirResourceReferenceList{TFhirImmunization}.Create;
  FSupportingPatientInformationList := TFhirResourceReferenceList{Resource}.Create;
end;

destructor TFhirImmunizationRecommendationRecommendation.Destroy;
begin
  FDate.free;
  FVaccineType.free;
  FDoseNumber.free;
  FForecastStatus.free;
  FDateCriterionList.Free;
  FProtocol.free;
  FSupportingImmunizationList.Free;
  FSupportingPatientInformationList.Free;
  inherited;
end;

procedure TFhirImmunizationRecommendationRecommendation.Assign(oSource : TAdvObject);
begin
  inherited;
  date := TFhirImmunizationRecommendationRecommendation(oSource).date.Clone;
  vaccineType := TFhirImmunizationRecommendationRecommendation(oSource).vaccineType.Clone;
  doseNumber := TFhirImmunizationRecommendationRecommendation(oSource).doseNumber.Clone;
  forecastStatus := TFhirImmunizationRecommendationRecommendation(oSource).forecastStatus.Clone;
  FDateCriterionList.Assign(TFhirImmunizationRecommendationRecommendation(oSource).FDateCriterionList);
  protocol := TFhirImmunizationRecommendationRecommendation(oSource).protocol.Clone;
  FSupportingImmunizationList.Assign(TFhirImmunizationRecommendationRecommendation(oSource).FSupportingImmunizationList);
  FSupportingPatientInformationList.Assign(TFhirImmunizationRecommendationRecommendation(oSource).FSupportingPatientInformationList);
end;

procedure TFhirImmunizationRecommendationRecommendation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'date') Then
     list.add(Date.Link);
  if (child_name = 'vaccineType') Then
     list.add(VaccineType.Link);
  if (child_name = 'doseNumber') Then
     list.add(DoseNumber.Link);
  if (child_name = 'forecastStatus') Then
     list.add(ForecastStatus.Link);
  if (child_name = 'dateCriterion') Then
     list.addAll(FDateCriterionList);
  if (child_name = 'protocol') Then
     list.add(Protocol.Link);
  if (child_name = 'supportingImmunization') Then
     list.addAll(FSupportingImmunizationList);
  if (child_name = 'supportingPatientInformation') Then
     list.addAll(FSupportingPatientInformationList);
end;

procedure TFhirImmunizationRecommendationRecommendation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', FDate.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'vaccineType', 'CodeableConcept', FVaccineType.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'doseNumber', 'integer', FDoseNumber.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'forecastStatus', 'CodeableConcept', FForecastStatus.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dateCriterion', '', FDateCriterionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'protocol', '', FProtocol.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'supportingImmunization', 'Resource(Immunization)', FSupportingImmunizationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'supportingPatientInformation', 'Resource(Observation|AdverseReaction|AllergyIntolerance)', FSupportingPatientInformationList.Link)){3};
end;

function TFhirImmunizationRecommendationRecommendation.Link : TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation(inherited Link);
end;

function TFhirImmunizationRecommendationRecommendation.Clone : TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation(inherited Clone);
end;

{ TFhirImmunizationRecommendationRecommendation }

Procedure TFhirImmunizationRecommendationRecommendation.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirImmunizationRecommendationRecommendation.GetDateST : TDateAndTime;
begin
  if FDate = nil then
    result := nil
  else
    result := Date.value;
end;

Procedure TFhirImmunizationRecommendationRecommendation.SetDateST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FDate = nil then
      FDate := TFhirDateTime.create;
    FDate.value := value
  end
  else if FDate <> nil then
    FDate.value := nil;
end;

Procedure TFhirImmunizationRecommendationRecommendation.SetVaccineType(value : TFhirCodeableConcept);
begin
  FVaccineType.free;
  FVaccineType := value;
end;

Procedure TFhirImmunizationRecommendationRecommendation.SetDoseNumber(value : TFhirInteger);
begin
  FDoseNumber.free;
  FDoseNumber := value;
end;

Function TFhirImmunizationRecommendationRecommendation.GetDoseNumberST : String;
begin
  if FDoseNumber = nil then
    result := ''
  else
    result := DoseNumber.value;
end;

Procedure TFhirImmunizationRecommendationRecommendation.SetDoseNumberST(value : String);
begin
  if value <> '' then
  begin
    if FDoseNumber = nil then
      FDoseNumber := TFhirInteger.create;
    FDoseNumber.value := value
  end
  else if FDoseNumber <> nil then
    FDoseNumber.value := '';
end;

Procedure TFhirImmunizationRecommendationRecommendation.SetForecastStatus(value : TFhirCodeableConcept);
begin
  FForecastStatus.free;
  FForecastStatus := value;
end;

Procedure TFhirImmunizationRecommendationRecommendation.SetProtocol(value : TFhirImmunizationRecommendationRecommendationProtocol);
begin
  FProtocol.free;
  FProtocol := value;
end;


{ TFhirImmunizationRecommendationRecommendationList }
procedure TFhirImmunizationRecommendationRecommendationList.AddItem(value: TFhirImmunizationRecommendationRecommendation);
begin
  assert(value.ClassName = 'TFhirImmunizationRecommendationRecommendation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationRecommendationRecommendation');
  add(value);
end;


function TFhirImmunizationRecommendationRecommendationList.Append: TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationRecommendationRecommendationList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationRecommendationRecommendationList.Clone: TFhirImmunizationRecommendationRecommendationList;
begin
  result := TFhirImmunizationRecommendationRecommendationList(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationRecommendationRecommendationList.GetItemN(index: Integer): TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationList.IndexOf(value: TFhirImmunizationRecommendationRecommendation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirImmunizationRecommendationRecommendationList.Insert(index: Integer): TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationRecommendationRecommendationList.InsertItem(index: Integer; value: TFhirImmunizationRecommendationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendationRecommendation);
  Inherited Insert(index, value);
end;

function TFhirImmunizationRecommendationRecommendationList.Item(index: Integer): TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationList.Link: TFhirImmunizationRecommendationRecommendationList;
begin
  result := TFhirImmunizationRecommendationRecommendationList(inherited Link);
end;

procedure TFhirImmunizationRecommendationRecommendationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationRecommendationRecommendationList.SetItemByIndex(index: Integer; value: TFhirImmunizationRecommendationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendationRecommendation);
  FhirImmunizationRecommendationRecommendations[index] := value;
end;

procedure TFhirImmunizationRecommendationRecommendationList.SetItemN(index: Integer; value: TFhirImmunizationRecommendationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendationRecommendation);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationRecommendationRecommendationDateCriterion }

constructor TFhirImmunizationRecommendationRecommendationDateCriterion.Create;
begin
  inherited;
end;

destructor TFhirImmunizationRecommendationRecommendationDateCriterion.Destroy;
begin
  FCode.free;
  FValue.free;
  inherited;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirImmunizationRecommendationRecommendationDateCriterion(oSource).code.Clone;
  value := TFhirImmunizationRecommendationRecommendationDateCriterion(oSource).value.Clone;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'value') Then
     list.add(Value.Link);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'dateTime', FValue.Link.Link));{2}
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.Link : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion(inherited Link);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.Clone : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion(inherited Clone);
end;

{ TFhirImmunizationRecommendationRecommendationDateCriterion }

Procedure TFhirImmunizationRecommendationRecommendationDateCriterion.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirImmunizationRecommendationRecommendationDateCriterion.SetValue(value : TFhirDateTime);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirImmunizationRecommendationRecommendationDateCriterion.GetValueST : TDateAndTime;
begin
  if FValue = nil then
    result := nil
  else
    result := Value.value;
end;

Procedure TFhirImmunizationRecommendationRecommendationDateCriterion.SetValueST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FValue = nil then
      FValue := TFhirDateTime.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := nil;
end;


{ TFhirImmunizationRecommendationRecommendationDateCriterionList }
procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.AddItem(value: TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  assert(value.ClassName = 'TFhirImmunizationRecommendationRecommendationDateCriterion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationRecommendationRecommendationDateCriterion');
  add(value);
end;


function TFhirImmunizationRecommendationRecommendationDateCriterionList.Append: TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Clone: TFhirImmunizationRecommendationRecommendationDateCriterionList;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterionList(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.GetItemN(index: Integer): TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.IndexOf(value: TFhirImmunizationRecommendationRecommendationDateCriterion): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirImmunizationRecommendationRecommendationDateCriterionList.Insert(index: Integer): TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.InsertItem(index: Integer; value: TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationDateCriterion);
  Inherited Insert(index, value);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Item(index: Integer): TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Link: TFhirImmunizationRecommendationRecommendationDateCriterionList;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterionList(inherited Link);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.SetItemByIndex(index: Integer; value: TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationDateCriterion);
  FhirImmunizationRecommendationRecommendationDateCriterions[index] := value;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.SetItemN(index: Integer; value: TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationDateCriterion);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationRecommendationRecommendationProtocol }

constructor TFhirImmunizationRecommendationRecommendationProtocol.Create;
begin
  inherited;
end;

destructor TFhirImmunizationRecommendationRecommendationProtocol.Destroy;
begin
  FDoseSequence.free;
  FDescription.free;
  FAuthority.free;
  FSeries.free;
  inherited;
end;

procedure TFhirImmunizationRecommendationRecommendationProtocol.Assign(oSource : TAdvObject);
begin
  inherited;
  doseSequence := TFhirImmunizationRecommendationRecommendationProtocol(oSource).doseSequence.Clone;
  description := TFhirImmunizationRecommendationRecommendationProtocol(oSource).description.Clone;
  authority := TFhirImmunizationRecommendationRecommendationProtocol(oSource).authority.Clone;
  series := TFhirImmunizationRecommendationRecommendationProtocol(oSource).series.Clone;
end;

procedure TFhirImmunizationRecommendationRecommendationProtocol.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'doseSequence') Then
     list.add(DoseSequence.Link);
  if (child_name = 'description') Then
     list.add(Description.Link);
  if (child_name = 'authority') Then
     list.add(Authority.Link);
  if (child_name = 'series') Then
     list.add(Series.Link);
end;

procedure TFhirImmunizationRecommendationRecommendationProtocol.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'doseSequence', 'integer', FDoseSequence.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authority', 'Resource(Organization)', FAuthority.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'series', 'string', FSeries.Link.Link));{2}
end;

function TFhirImmunizationRecommendationRecommendationProtocol.Link : TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol(inherited Link);
end;

function TFhirImmunizationRecommendationRecommendationProtocol.Clone : TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol(inherited Clone);
end;

{ TFhirImmunizationRecommendationRecommendationProtocol }

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetDoseSequence(value : TFhirInteger);
begin
  FDoseSequence.free;
  FDoseSequence := value;
end;

Function TFhirImmunizationRecommendationRecommendationProtocol.GetDoseSequenceST : String;
begin
  if FDoseSequence = nil then
    result := ''
  else
    result := DoseSequence.value;
end;

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetDoseSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FDoseSequence = nil then
      FDoseSequence := TFhirInteger.create;
    FDoseSequence.value := value
  end
  else if FDoseSequence <> nil then
    FDoseSequence.value := '';
end;

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirImmunizationRecommendationRecommendationProtocol.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := Description.value;
end;

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetAuthority(value : TFhirResourceReference{TFhirOrganization});
begin
  FAuthority.free;
  FAuthority := value;
end;

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetSeries(value : TFhirString);
begin
  FSeries.free;
  FSeries := value;
end;

Function TFhirImmunizationRecommendationRecommendationProtocol.GetSeriesST : String;
begin
  if FSeries = nil then
    result := ''
  else
    result := Series.value;
end;

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetSeriesST(value : String);
begin
  if value <> '' then
  begin
    if FSeries = nil then
      FSeries := TFhirString.create;
    FSeries.value := value
  end
  else if FSeries <> nil then
    FSeries.value := '';
end;


{ TFhirImmunizationRecommendationRecommendationProtocolList }
procedure TFhirImmunizationRecommendationRecommendationProtocolList.AddItem(value: TFhirImmunizationRecommendationRecommendationProtocol);
begin
  assert(value.ClassName = 'TFhirImmunizationRecommendationRecommendationProtocol', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationRecommendationRecommendationProtocol');
  add(value);
end;


function TFhirImmunizationRecommendationRecommendationProtocolList.Append: TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationRecommendationRecommendationProtocolList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.Clone: TFhirImmunizationRecommendationRecommendationProtocolList;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocolList(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.GetItemN(index: Integer): TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.IndexOf(value: TFhirImmunizationRecommendationRecommendationProtocol): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirImmunizationRecommendationRecommendationProtocolList.Insert(index: Integer): TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationRecommendationRecommendationProtocolList.InsertItem(index: Integer; value: TFhirImmunizationRecommendationRecommendationProtocol);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationProtocol);
  Inherited Insert(index, value);
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.Item(index: Integer): TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.Link: TFhirImmunizationRecommendationRecommendationProtocolList;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocolList(inherited Link);
end;

procedure TFhirImmunizationRecommendationRecommendationProtocolList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationRecommendationRecommendationProtocolList.SetItemByIndex(index: Integer; value: TFhirImmunizationRecommendationRecommendationProtocol);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationProtocol);
  FhirImmunizationRecommendationRecommendationProtocols[index] := value;
end;

procedure TFhirImmunizationRecommendationRecommendationProtocolList.SetItemN(index: Integer; value: TFhirImmunizationRecommendationRecommendationProtocol);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationProtocol);
  ObjectByIndex[index] := value;
end;

{ TFhirListEntry }

constructor TFhirListEntry.Create;
begin
  inherited;
  FFlagList := TFhirCodeableConceptList.Create;
end;

destructor TFhirListEntry.Destroy;
begin
  FFlagList.Free;
  FDeleted.free;
  FDate.free;
  FItem.free;
  inherited;
end;

procedure TFhirListEntry.Assign(oSource : TAdvObject);
begin
  inherited;
  FFlagList.Assign(TFhirListEntry(oSource).FFlagList);
  deleted := TFhirListEntry(oSource).deleted.Clone;
  date := TFhirListEntry(oSource).date.Clone;
  item := TFhirListEntry(oSource).item.Clone;
end;

procedure TFhirListEntry.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'flag') Then
     list.addAll(FFlagList);
  if (child_name = 'deleted') Then
     list.add(Deleted.Link);
  if (child_name = 'date') Then
     list.add(Date.Link);
  if (child_name = 'item') Then
     list.add(Item.Link);
end;

procedure TFhirListEntry.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'flag', 'CodeableConcept', FFlagList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'deleted', 'boolean', FDeleted.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', FDate.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'item', 'Resource(Any)', FItem.Link.Link));{2}
end;

function TFhirListEntry.Link : TFhirListEntry;
begin
  result := TFhirListEntry(inherited Link);
end;

function TFhirListEntry.Clone : TFhirListEntry;
begin
  result := TFhirListEntry(inherited Clone);
end;

{ TFhirListEntry }

Procedure TFhirListEntry.SetDeleted(value : TFhirBoolean);
begin
  FDeleted.free;
  FDeleted := value;
end;

Function TFhirListEntry.GetDeletedST : Boolean;
begin
  if FDeleted = nil then
    result := false
  else
    result := Deleted.value;
end;

Procedure TFhirListEntry.SetDeletedST(value : Boolean);
begin
  if FDeleted = nil then
    FDeleted := TFhirBoolean.create;
  FDeleted.value := value
end;

Procedure TFhirListEntry.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirListEntry.GetDateST : TDateAndTime;
begin
  if FDate = nil then
    result := nil
  else
    result := Date.value;
end;

Procedure TFhirListEntry.SetDateST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FDate = nil then
      FDate := TFhirDateTime.create;
    FDate.value := value
  end
  else if FDate <> nil then
    FDate.value := nil;
end;

Procedure TFhirListEntry.SetItem(value : TFhirResourceReference{Resource});
begin
  FItem.free;
  FItem := value;
end;


{ TFhirListEntryList }
procedure TFhirListEntryList.AddItem(value: TFhirListEntry);
begin
  assert(value.ClassName = 'TFhirListEntry', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirListEntry');
  add(value);
end;


function TFhirListEntryList.Append: TFhirListEntry;
begin
  result := TFhirListEntry.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirListEntryList.ClearItems;
begin
  Clear;
end;

function TFhirListEntryList.Clone: TFhirListEntryList;
begin
  result := TFhirListEntryList(inherited Clone);
end;

function TFhirListEntryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirListEntryList.GetItemN(index: Integer): TFhirListEntry;
begin
  result := TFhirListEntry(ObjectByIndex[index]);
end;

function TFhirListEntryList.IndexOf(value: TFhirListEntry): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirListEntryList.Insert(index: Integer): TFhirListEntry;
begin
  result := TFhirListEntry.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirListEntryList.InsertItem(index: Integer; value: TFhirListEntry);
begin
  assert(value is TFhirListEntry);
  Inherited Insert(index, value);
end;

function TFhirListEntryList.Item(index: Integer): TFhirListEntry;
begin
  result := TFhirListEntry(ObjectByIndex[index]);
end;

function TFhirListEntryList.Link: TFhirListEntryList;
begin
  result := TFhirListEntryList(inherited Link);
end;

procedure TFhirListEntryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirListEntryList.SetItemByIndex(index: Integer; value: TFhirListEntry);
begin
  assert(value is TFhirListEntry);
  FhirListEntries[index] := value;
end;

procedure TFhirListEntryList.SetItemN(index: Integer; value: TFhirListEntry);
begin
  assert(value is TFhirListEntry);
  ObjectByIndex[index] := value;
end;

{ TFhirLocationPosition }

constructor TFhirLocationPosition.Create;
begin
  inherited;
end;

destructor TFhirLocationPosition.Destroy;
begin
  FLongitude.free;
  FLatitude.free;
  FAltitude.free;
  inherited;
end;

procedure TFhirLocationPosition.Assign(oSource : TAdvObject);
begin
  inherited;
  longitude := TFhirLocationPosition(oSource).longitude.Clone;
  latitude := TFhirLocationPosition(oSource).latitude.Clone;
  altitude := TFhirLocationPosition(oSource).altitude.Clone;
end;

procedure TFhirLocationPosition.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'longitude') Then
     list.add(Longitude.Link);
  if (child_name = 'latitude') Then
     list.add(Latitude.Link);
  if (child_name = 'altitude') Then
     list.add(Altitude.Link);
end;

procedure TFhirLocationPosition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'longitude', 'decimal', FLongitude.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'latitude', 'decimal', FLatitude.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'altitude', 'decimal', FAltitude.Link.Link));{2}
end;

function TFhirLocationPosition.Link : TFhirLocationPosition;
begin
  result := TFhirLocationPosition(inherited Link);
end;

function TFhirLocationPosition.Clone : TFhirLocationPosition;
begin
  result := TFhirLocationPosition(inherited Clone);
end;

{ TFhirLocationPosition }

Procedure TFhirLocationPosition.SetLongitude(value : TFhirDecimal);
begin
  FLongitude.free;
  FLongitude := value;
end;

Function TFhirLocationPosition.GetLongitudeST : String;
begin
  if FLongitude = nil then
    result := ''
  else
    result := Longitude.value;
end;

Procedure TFhirLocationPosition.SetLongitudeST(value : String);
begin
  if value <> '' then
  begin
    if FLongitude = nil then
      FLongitude := TFhirDecimal.create;
    FLongitude.value := value
  end
  else if FLongitude <> nil then
    FLongitude.value := '';
end;

Procedure TFhirLocationPosition.SetLatitude(value : TFhirDecimal);
begin
  FLatitude.free;
  FLatitude := value;
end;

Function TFhirLocationPosition.GetLatitudeST : String;
begin
  if FLatitude = nil then
    result := ''
  else
    result := Latitude.value;
end;

Procedure TFhirLocationPosition.SetLatitudeST(value : String);
begin
  if value <> '' then
  begin
    if FLatitude = nil then
      FLatitude := TFhirDecimal.create;
    FLatitude.value := value
  end
  else if FLatitude <> nil then
    FLatitude.value := '';
end;

Procedure TFhirLocationPosition.SetAltitude(value : TFhirDecimal);
begin
  FAltitude.free;
  FAltitude := value;
end;

Function TFhirLocationPosition.GetAltitudeST : String;
begin
  if FAltitude = nil then
    result := ''
  else
    result := Altitude.value;
end;

Procedure TFhirLocationPosition.SetAltitudeST(value : String);
begin
  if value <> '' then
  begin
    if FAltitude = nil then
      FAltitude := TFhirDecimal.create;
    FAltitude.value := value
  end
  else if FAltitude <> nil then
    FAltitude.value := '';
end;


{ TFhirLocationPositionList }
procedure TFhirLocationPositionList.AddItem(value: TFhirLocationPosition);
begin
  assert(value.ClassName = 'TFhirLocationPosition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirLocationPosition');
  add(value);
end;


function TFhirLocationPositionList.Append: TFhirLocationPosition;
begin
  result := TFhirLocationPosition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirLocationPositionList.ClearItems;
begin
  Clear;
end;

function TFhirLocationPositionList.Clone: TFhirLocationPositionList;
begin
  result := TFhirLocationPositionList(inherited Clone);
end;

function TFhirLocationPositionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirLocationPositionList.GetItemN(index: Integer): TFhirLocationPosition;
begin
  result := TFhirLocationPosition(ObjectByIndex[index]);
end;

function TFhirLocationPositionList.IndexOf(value: TFhirLocationPosition): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirLocationPositionList.Insert(index: Integer): TFhirLocationPosition;
begin
  result := TFhirLocationPosition.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirLocationPositionList.InsertItem(index: Integer; value: TFhirLocationPosition);
begin
  assert(value is TFhirLocationPosition);
  Inherited Insert(index, value);
end;

function TFhirLocationPositionList.Item(index: Integer): TFhirLocationPosition;
begin
  result := TFhirLocationPosition(ObjectByIndex[index]);
end;

function TFhirLocationPositionList.Link: TFhirLocationPositionList;
begin
  result := TFhirLocationPositionList(inherited Link);
end;

procedure TFhirLocationPositionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirLocationPositionList.SetItemByIndex(index: Integer; value: TFhirLocationPosition);
begin
  assert(value is TFhirLocationPosition);
  FhirLocationPositions[index] := value;
end;

procedure TFhirLocationPositionList.SetItemN(index: Integer; value: TFhirLocationPosition);
begin
  assert(value is TFhirLocationPosition);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationProduct }

constructor TFhirMedicationProduct.Create;
begin
  inherited;
  FIngredientList := TFhirMedicationProductIngredientList.Create;
end;

destructor TFhirMedicationProduct.Destroy;
begin
  FForm.free;
  FIngredientList.Free;
  inherited;
end;

procedure TFhirMedicationProduct.Assign(oSource : TAdvObject);
begin
  inherited;
  form := TFhirMedicationProduct(oSource).form.Clone;
  FIngredientList.Assign(TFhirMedicationProduct(oSource).FIngredientList);
end;

procedure TFhirMedicationProduct.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'form') Then
     list.add(Form.Link);
  if (child_name = 'ingredient') Then
     list.addAll(FIngredientList);
end;

procedure TFhirMedicationProduct.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'form', 'CodeableConcept', FForm.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ingredient', '', FIngredientList.Link)){3};
end;

function TFhirMedicationProduct.Link : TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct(inherited Link);
end;

function TFhirMedicationProduct.Clone : TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct(inherited Clone);
end;

{ TFhirMedicationProduct }

Procedure TFhirMedicationProduct.SetForm(value : TFhirCodeableConcept);
begin
  FForm.free;
  FForm := value;
end;


{ TFhirMedicationProductList }
procedure TFhirMedicationProductList.AddItem(value: TFhirMedicationProduct);
begin
  assert(value.ClassName = 'TFhirMedicationProduct', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationProduct');
  add(value);
end;


function TFhirMedicationProductList.Append: TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationProductList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationProductList.Clone: TFhirMedicationProductList;
begin
  result := TFhirMedicationProductList(inherited Clone);
end;

function TFhirMedicationProductList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationProductList.GetItemN(index: Integer): TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct(ObjectByIndex[index]);
end;

function TFhirMedicationProductList.IndexOf(value: TFhirMedicationProduct): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationProductList.Insert(index: Integer): TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationProductList.InsertItem(index: Integer; value: TFhirMedicationProduct);
begin
  assert(value is TFhirMedicationProduct);
  Inherited Insert(index, value);
end;

function TFhirMedicationProductList.Item(index: Integer): TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct(ObjectByIndex[index]);
end;

function TFhirMedicationProductList.Link: TFhirMedicationProductList;
begin
  result := TFhirMedicationProductList(inherited Link);
end;

procedure TFhirMedicationProductList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationProductList.SetItemByIndex(index: Integer; value: TFhirMedicationProduct);
begin
  assert(value is TFhirMedicationProduct);
  FhirMedicationProducts[index] := value;
end;

procedure TFhirMedicationProductList.SetItemN(index: Integer; value: TFhirMedicationProduct);
begin
  assert(value is TFhirMedicationProduct);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationProductIngredient }

constructor TFhirMedicationProductIngredient.Create;
begin
  inherited;
end;

destructor TFhirMedicationProductIngredient.Destroy;
begin
  FItem.free;
  FAmount.free;
  inherited;
end;

procedure TFhirMedicationProductIngredient.Assign(oSource : TAdvObject);
begin
  inherited;
  item := TFhirMedicationProductIngredient(oSource).item.Clone;
  amount := TFhirMedicationProductIngredient(oSource).amount.Clone;
end;

procedure TFhirMedicationProductIngredient.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'item') Then
     list.add(Item.Link);
  if (child_name = 'amount') Then
     list.add(Amount.Link);
end;

procedure TFhirMedicationProductIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item', 'Resource(Substance|Medication)', FItem.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Ratio', FAmount.Link.Link));{2}
end;

function TFhirMedicationProductIngredient.Link : TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient(inherited Link);
end;

function TFhirMedicationProductIngredient.Clone : TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient(inherited Clone);
end;

{ TFhirMedicationProductIngredient }

Procedure TFhirMedicationProductIngredient.SetItem(value : TFhirResourceReference{Resource});
begin
  FItem.free;
  FItem := value;
end;

Procedure TFhirMedicationProductIngredient.SetAmount(value : TFhirRatio);
begin
  FAmount.free;
  FAmount := value;
end;


{ TFhirMedicationProductIngredientList }
procedure TFhirMedicationProductIngredientList.AddItem(value: TFhirMedicationProductIngredient);
begin
  assert(value.ClassName = 'TFhirMedicationProductIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationProductIngredient');
  add(value);
end;


function TFhirMedicationProductIngredientList.Append: TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationProductIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationProductIngredientList.Clone: TFhirMedicationProductIngredientList;
begin
  result := TFhirMedicationProductIngredientList(inherited Clone);
end;

function TFhirMedicationProductIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationProductIngredientList.GetItemN(index: Integer): TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationProductIngredientList.IndexOf(value: TFhirMedicationProductIngredient): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationProductIngredientList.Insert(index: Integer): TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationProductIngredientList.InsertItem(index: Integer; value: TFhirMedicationProductIngredient);
begin
  assert(value is TFhirMedicationProductIngredient);
  Inherited Insert(index, value);
end;

function TFhirMedicationProductIngredientList.Item(index: Integer): TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationProductIngredientList.Link: TFhirMedicationProductIngredientList;
begin
  result := TFhirMedicationProductIngredientList(inherited Link);
end;

procedure TFhirMedicationProductIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationProductIngredientList.SetItemByIndex(index: Integer; value: TFhirMedicationProductIngredient);
begin
  assert(value is TFhirMedicationProductIngredient);
  FhirMedicationProductIngredients[index] := value;
end;

procedure TFhirMedicationProductIngredientList.SetItemN(index: Integer; value: TFhirMedicationProductIngredient);
begin
  assert(value is TFhirMedicationProductIngredient);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationPackage }

constructor TFhirMedicationPackage.Create;
begin
  inherited;
  FContentList := TFhirMedicationPackageContentList.Create;
end;

destructor TFhirMedicationPackage.Destroy;
begin
  FContainer.free;
  FContentList.Free;
  inherited;
end;

procedure TFhirMedicationPackage.Assign(oSource : TAdvObject);
begin
  inherited;
  container := TFhirMedicationPackage(oSource).container.Clone;
  FContentList.Assign(TFhirMedicationPackage(oSource).FContentList);
end;

procedure TFhirMedicationPackage.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'container') Then
     list.add(Container.Link);
  if (child_name = 'content') Then
     list.addAll(FContentList);
end;

procedure TFhirMedicationPackage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'container', 'CodeableConcept', FContainer.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'content', '', FContentList.Link)){3};
end;

function TFhirMedicationPackage.Link : TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage(inherited Link);
end;

function TFhirMedicationPackage.Clone : TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage(inherited Clone);
end;

{ TFhirMedicationPackage }

Procedure TFhirMedicationPackage.SetContainer(value : TFhirCodeableConcept);
begin
  FContainer.free;
  FContainer := value;
end;


{ TFhirMedicationPackageList }
procedure TFhirMedicationPackageList.AddItem(value: TFhirMedicationPackage);
begin
  assert(value.ClassName = 'TFhirMedicationPackage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationPackage');
  add(value);
end;


function TFhirMedicationPackageList.Append: TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPackageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationPackageList.Clone: TFhirMedicationPackageList;
begin
  result := TFhirMedicationPackageList(inherited Clone);
end;

function TFhirMedicationPackageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationPackageList.GetItemN(index: Integer): TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage(ObjectByIndex[index]);
end;

function TFhirMedicationPackageList.IndexOf(value: TFhirMedicationPackage): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationPackageList.Insert(index: Integer): TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPackageList.InsertItem(index: Integer; value: TFhirMedicationPackage);
begin
  assert(value is TFhirMedicationPackage);
  Inherited Insert(index, value);
end;

function TFhirMedicationPackageList.Item(index: Integer): TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage(ObjectByIndex[index]);
end;

function TFhirMedicationPackageList.Link: TFhirMedicationPackageList;
begin
  result := TFhirMedicationPackageList(inherited Link);
end;

procedure TFhirMedicationPackageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationPackageList.SetItemByIndex(index: Integer; value: TFhirMedicationPackage);
begin
  assert(value is TFhirMedicationPackage);
  FhirMedicationPackages[index] := value;
end;

procedure TFhirMedicationPackageList.SetItemN(index: Integer; value: TFhirMedicationPackage);
begin
  assert(value is TFhirMedicationPackage);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationPackageContent }

constructor TFhirMedicationPackageContent.Create;
begin
  inherited;
end;

destructor TFhirMedicationPackageContent.Destroy;
begin
  FItem.free;
  FAmount.free;
  inherited;
end;

procedure TFhirMedicationPackageContent.Assign(oSource : TAdvObject);
begin
  inherited;
  item := TFhirMedicationPackageContent(oSource).item.Clone;
  amount := TFhirMedicationPackageContent(oSource).amount.Clone;
end;

procedure TFhirMedicationPackageContent.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'item') Then
     list.add(Item.Link);
  if (child_name = 'amount') Then
     list.add(Amount.Link);
end;

procedure TFhirMedicationPackageContent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item', 'Resource(Medication)', FItem.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', FAmount.Link.Link));{2}
end;

function TFhirMedicationPackageContent.Link : TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent(inherited Link);
end;

function TFhirMedicationPackageContent.Clone : TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent(inherited Clone);
end;

{ TFhirMedicationPackageContent }

Procedure TFhirMedicationPackageContent.SetItem(value : TFhirResourceReference{TFhirMedication});
begin
  FItem.free;
  FItem := value;
end;

Procedure TFhirMedicationPackageContent.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value;
end;


{ TFhirMedicationPackageContentList }
procedure TFhirMedicationPackageContentList.AddItem(value: TFhirMedicationPackageContent);
begin
  assert(value.ClassName = 'TFhirMedicationPackageContent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationPackageContent');
  add(value);
end;


function TFhirMedicationPackageContentList.Append: TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPackageContentList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationPackageContentList.Clone: TFhirMedicationPackageContentList;
begin
  result := TFhirMedicationPackageContentList(inherited Clone);
end;

function TFhirMedicationPackageContentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationPackageContentList.GetItemN(index: Integer): TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent(ObjectByIndex[index]);
end;

function TFhirMedicationPackageContentList.IndexOf(value: TFhirMedicationPackageContent): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationPackageContentList.Insert(index: Integer): TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPackageContentList.InsertItem(index: Integer; value: TFhirMedicationPackageContent);
begin
  assert(value is TFhirMedicationPackageContent);
  Inherited Insert(index, value);
end;

function TFhirMedicationPackageContentList.Item(index: Integer): TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent(ObjectByIndex[index]);
end;

function TFhirMedicationPackageContentList.Link: TFhirMedicationPackageContentList;
begin
  result := TFhirMedicationPackageContentList(inherited Link);
end;

procedure TFhirMedicationPackageContentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationPackageContentList.SetItemByIndex(index: Integer; value: TFhirMedicationPackageContent);
begin
  assert(value is TFhirMedicationPackageContent);
  FhirMedicationPackageContents[index] := value;
end;

procedure TFhirMedicationPackageContentList.SetItemN(index: Integer; value: TFhirMedicationPackageContent);
begin
  assert(value is TFhirMedicationPackageContent);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationAdministrationDosage }

constructor TFhirMedicationAdministrationDosage.Create;
begin
  inherited;
end;

destructor TFhirMedicationAdministrationDosage.Destroy;
begin
  FTiming.free;
  FAsNeeded.free;
  FSite.free;
  FRoute.free;
  FMethod.free;
  FQuantity.free;
  FRate.free;
  FMaxDosePerPeriod.free;
  inherited;
end;

procedure TFhirMedicationAdministrationDosage.Assign(oSource : TAdvObject);
begin
  inherited;
  timing := TFhirMedicationAdministrationDosage(oSource).timing.Clone;
  asNeeded := TFhirMedicationAdministrationDosage(oSource).asNeeded.Clone;
  site := TFhirMedicationAdministrationDosage(oSource).site.Clone;
  route := TFhirMedicationAdministrationDosage(oSource).route.Clone;
  method := TFhirMedicationAdministrationDosage(oSource).method.Clone;
  quantity := TFhirMedicationAdministrationDosage(oSource).quantity.Clone;
  rate := TFhirMedicationAdministrationDosage(oSource).rate.Clone;
  maxDosePerPeriod := TFhirMedicationAdministrationDosage(oSource).maxDosePerPeriod.Clone;
end;

procedure TFhirMedicationAdministrationDosage.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'timing') Then
     list.add(Timing.Link);
  if (child_name = 'asNeeded') Then
     list.add(AsNeeded.Link);
  if (child_name = 'site') Then
     list.add(Site.Link);
  if (child_name = 'route') Then
     list.add(Route.Link);
  if (child_name = 'method') Then
     list.add(Method.Link);
  if (child_name = 'quantity') Then
     list.add(Quantity.Link);
  if (child_name = 'rate') Then
     list.add(Rate.Link);
  if (child_name = 'maxDosePerPeriod') Then
     list.add(MaxDosePerPeriod.Link);
end;

procedure TFhirMedicationAdministrationDosage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'dateTime|Period', FTiming.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'asNeeded[x]', 'boolean|CodeableConcept', FAsNeeded.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'site', 'CodeableConcept', FSite.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', FRoute.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', FMethod.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rate', 'Ratio', FRate.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxDosePerPeriod', 'Ratio', FMaxDosePerPeriod.Link.Link));{2}
end;

function TFhirMedicationAdministrationDosage.Link : TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(inherited Link);
end;

function TFhirMedicationAdministrationDosage.Clone : TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(inherited Clone);
end;

{ TFhirMedicationAdministrationDosage }

Procedure TFhirMedicationAdministrationDosage.SetTiming(value : TFhirType);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetAsNeeded(value : TFhirType);
begin
  FAsNeeded.free;
  FAsNeeded := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetSite(value : TFhirCodeableConcept);
begin
  FSite.free;
  FSite := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetRoute(value : TFhirCodeableConcept);
begin
  FRoute.free;
  FRoute := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetRate(value : TFhirRatio);
begin
  FRate.free;
  FRate := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetMaxDosePerPeriod(value : TFhirRatio);
begin
  FMaxDosePerPeriod.free;
  FMaxDosePerPeriod := value;
end;


{ TFhirMedicationAdministrationDosageList }
procedure TFhirMedicationAdministrationDosageList.AddItem(value: TFhirMedicationAdministrationDosage);
begin
  assert(value.ClassName = 'TFhirMedicationAdministrationDosage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationAdministrationDosage');
  add(value);
end;


function TFhirMedicationAdministrationDosageList.Append: TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationAdministrationDosageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationAdministrationDosageList.Clone: TFhirMedicationAdministrationDosageList;
begin
  result := TFhirMedicationAdministrationDosageList(inherited Clone);
end;

function TFhirMedicationAdministrationDosageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationAdministrationDosageList.GetItemN(index: Integer): TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationDosageList.IndexOf(value: TFhirMedicationAdministrationDosage): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationAdministrationDosageList.Insert(index: Integer): TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationAdministrationDosageList.InsertItem(index: Integer; value: TFhirMedicationAdministrationDosage);
begin
  assert(value is TFhirMedicationAdministrationDosage);
  Inherited Insert(index, value);
end;

function TFhirMedicationAdministrationDosageList.Item(index: Integer): TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationDosageList.Link: TFhirMedicationAdministrationDosageList;
begin
  result := TFhirMedicationAdministrationDosageList(inherited Link);
end;

procedure TFhirMedicationAdministrationDosageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationAdministrationDosageList.SetItemByIndex(index: Integer; value: TFhirMedicationAdministrationDosage);
begin
  assert(value is TFhirMedicationAdministrationDosage);
  FhirMedicationAdministrationDosages[index] := value;
end;

procedure TFhirMedicationAdministrationDosageList.SetItemN(index: Integer; value: TFhirMedicationAdministrationDosage);
begin
  assert(value is TFhirMedicationAdministrationDosage);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationDispenseDispense }

constructor TFhirMedicationDispenseDispense.Create;
begin
  inherited;
  FReceiverList := TFhirResourceReferenceList{Resource}.Create;
  FDosageList := TFhirMedicationDispenseDispenseDosageList.Create;
end;

destructor TFhirMedicationDispenseDispense.Destroy;
begin
  FIdentifier.free;
  FStatus.free;
  FType_.free;
  FQuantity.free;
  FMedication.free;
  FWhenPrepared.free;
  FWhenHandedOver.free;
  FDestination.free;
  FReceiverList.Free;
  FDosageList.Free;
  inherited;
end;

procedure TFhirMedicationDispenseDispense.Assign(oSource : TAdvObject);
begin
  inherited;
  identifier := TFhirMedicationDispenseDispense(oSource).identifier.Clone;
  FStatus := TFhirMedicationDispenseDispense(oSource).FStatus.Link;
  type_ := TFhirMedicationDispenseDispense(oSource).type_.Clone;
  quantity := TFhirMedicationDispenseDispense(oSource).quantity.Clone;
  medication := TFhirMedicationDispenseDispense(oSource).medication.Clone;
  whenPrepared := TFhirMedicationDispenseDispense(oSource).whenPrepared.Clone;
  whenHandedOver := TFhirMedicationDispenseDispense(oSource).whenHandedOver.Clone;
  destination := TFhirMedicationDispenseDispense(oSource).destination.Clone;
  FReceiverList.Assign(TFhirMedicationDispenseDispense(oSource).FReceiverList);
  FDosageList.Assign(TFhirMedicationDispenseDispense(oSource).FDosageList);
end;

procedure TFhirMedicationDispenseDispense.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(Identifier.Link);
  if (child_name = 'status') Then
     list.add(FStatus.Link);
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'quantity') Then
     list.add(Quantity.Link);
  if (child_name = 'medication') Then
     list.add(Medication.Link);
  if (child_name = 'whenPrepared') Then
     list.add(WhenPrepared.Link);
  if (child_name = 'whenHandedOver') Then
     list.add(WhenHandedOver.Link);
  if (child_name = 'destination') Then
     list.add(Destination.Link);
  if (child_name = 'receiver') Then
     list.addAll(FReceiverList);
  if (child_name = 'dosage') Then
     list.addAll(FDosageList);
end;

procedure TFhirMedicationDispenseDispense.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', FIdentifier.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'medication', 'Resource(Medication)', FMedication.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'whenPrepared', 'dateTime', FWhenPrepared.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'whenHandedOver', 'dateTime', FWhenHandedOver.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'destination', 'Resource(Location)', FDestination.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'receiver', 'Resource(Patient|Practitioner)', FReceiverList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'dosage', '', FDosageList.Link)){3};
end;

function TFhirMedicationDispenseDispense.Link : TFhirMedicationDispenseDispense;
begin
  result := TFhirMedicationDispenseDispense(inherited Link);
end;

function TFhirMedicationDispenseDispense.Clone : TFhirMedicationDispenseDispense;
begin
  result := TFhirMedicationDispenseDispense(inherited Clone);
end;

{ TFhirMedicationDispenseDispense }

Procedure TFhirMedicationDispenseDispense.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirMedicationDispenseDispense.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirMedicationDispenseDispense.GetStatusST : TFhirMedicationDispenseStatus;
begin
  if FStatus = nil then
    result := TFhirMedicationDispenseStatus(0)
  else
    result := TFhirMedicationDispenseStatus(StringArrayIndexOf(CODES_TFhirMedicationDispenseStatus, Status.value));
end;

Procedure TFhirMedicationDispenseDispense.SetStatusST(value : TFhirMedicationDispenseStatus);
begin
  if ord(value) = 0 then
    Status := nil
  else
    Status := TFhirEnum.create(CODES_TFhirMedicationDispenseStatus[value]);
end;

Procedure TFhirMedicationDispenseDispense.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirMedicationDispenseDispense.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirMedicationDispenseDispense.SetMedication(value : TFhirResourceReference{TFhirMedication});
begin
  FMedication.free;
  FMedication := value;
end;

Procedure TFhirMedicationDispenseDispense.SetWhenPrepared(value : TFhirDateTime);
begin
  FWhenPrepared.free;
  FWhenPrepared := value;
end;

Function TFhirMedicationDispenseDispense.GetWhenPreparedST : TDateAndTime;
begin
  if FWhenPrepared = nil then
    result := nil
  else
    result := WhenPrepared.value;
end;

Procedure TFhirMedicationDispenseDispense.SetWhenPreparedST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FWhenPrepared = nil then
      FWhenPrepared := TFhirDateTime.create;
    FWhenPrepared.value := value
  end
  else if FWhenPrepared <> nil then
    FWhenPrepared.value := nil;
end;

Procedure TFhirMedicationDispenseDispense.SetWhenHandedOver(value : TFhirDateTime);
begin
  FWhenHandedOver.free;
  FWhenHandedOver := value;
end;

Function TFhirMedicationDispenseDispense.GetWhenHandedOverST : TDateAndTime;
begin
  if FWhenHandedOver = nil then
    result := nil
  else
    result := WhenHandedOver.value;
end;

Procedure TFhirMedicationDispenseDispense.SetWhenHandedOverST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FWhenHandedOver = nil then
      FWhenHandedOver := TFhirDateTime.create;
    FWhenHandedOver.value := value
  end
  else if FWhenHandedOver <> nil then
    FWhenHandedOver.value := nil;
end;

Procedure TFhirMedicationDispenseDispense.SetDestination(value : TFhirResourceReference{TFhirLocation});
begin
  FDestination.free;
  FDestination := value;
end;


{ TFhirMedicationDispenseDispenseList }
procedure TFhirMedicationDispenseDispenseList.AddItem(value: TFhirMedicationDispenseDispense);
begin
  assert(value.ClassName = 'TFhirMedicationDispenseDispense', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationDispenseDispense');
  add(value);
end;


function TFhirMedicationDispenseDispenseList.Append: TFhirMedicationDispenseDispense;
begin
  result := TFhirMedicationDispenseDispense.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationDispenseDispenseList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationDispenseDispenseList.Clone: TFhirMedicationDispenseDispenseList;
begin
  result := TFhirMedicationDispenseDispenseList(inherited Clone);
end;

function TFhirMedicationDispenseDispenseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationDispenseDispenseList.GetItemN(index: Integer): TFhirMedicationDispenseDispense;
begin
  result := TFhirMedicationDispenseDispense(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseDispenseList.IndexOf(value: TFhirMedicationDispenseDispense): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationDispenseDispenseList.Insert(index: Integer): TFhirMedicationDispenseDispense;
begin
  result := TFhirMedicationDispenseDispense.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationDispenseDispenseList.InsertItem(index: Integer; value: TFhirMedicationDispenseDispense);
begin
  assert(value is TFhirMedicationDispenseDispense);
  Inherited Insert(index, value);
end;

function TFhirMedicationDispenseDispenseList.Item(index: Integer): TFhirMedicationDispenseDispense;
begin
  result := TFhirMedicationDispenseDispense(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseDispenseList.Link: TFhirMedicationDispenseDispenseList;
begin
  result := TFhirMedicationDispenseDispenseList(inherited Link);
end;

procedure TFhirMedicationDispenseDispenseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationDispenseDispenseList.SetItemByIndex(index: Integer; value: TFhirMedicationDispenseDispense);
begin
  assert(value is TFhirMedicationDispenseDispense);
  FhirMedicationDispenseDispenses[index] := value;
end;

procedure TFhirMedicationDispenseDispenseList.SetItemN(index: Integer; value: TFhirMedicationDispenseDispense);
begin
  assert(value is TFhirMedicationDispenseDispense);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationDispenseDispenseDosage }

constructor TFhirMedicationDispenseDispenseDosage.Create;
begin
  inherited;
end;

destructor TFhirMedicationDispenseDispenseDosage.Destroy;
begin
  FAdditionalInstructions.free;
  FTiming.free;
  FAsNeeded.free;
  FSite.free;
  FRoute.free;
  FMethod.free;
  FQuantity.free;
  FRate.free;
  FMaxDosePerPeriod.free;
  inherited;
end;

procedure TFhirMedicationDispenseDispenseDosage.Assign(oSource : TAdvObject);
begin
  inherited;
  additionalInstructions := TFhirMedicationDispenseDispenseDosage(oSource).additionalInstructions.Clone;
  timing := TFhirMedicationDispenseDispenseDosage(oSource).timing.Clone;
  asNeeded := TFhirMedicationDispenseDispenseDosage(oSource).asNeeded.Clone;
  site := TFhirMedicationDispenseDispenseDosage(oSource).site.Clone;
  route := TFhirMedicationDispenseDispenseDosage(oSource).route.Clone;
  method := TFhirMedicationDispenseDispenseDosage(oSource).method.Clone;
  quantity := TFhirMedicationDispenseDispenseDosage(oSource).quantity.Clone;
  rate := TFhirMedicationDispenseDispenseDosage(oSource).rate.Clone;
  maxDosePerPeriod := TFhirMedicationDispenseDispenseDosage(oSource).maxDosePerPeriod.Clone;
end;

procedure TFhirMedicationDispenseDispenseDosage.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'additionalInstructions') Then
     list.add(AdditionalInstructions.Link);
  if (child_name = 'timing') Then
     list.add(Timing.Link);
  if (child_name = 'asNeeded') Then
     list.add(AsNeeded.Link);
  if (child_name = 'site') Then
     list.add(Site.Link);
  if (child_name = 'route') Then
     list.add(Route.Link);
  if (child_name = 'method') Then
     list.add(Method.Link);
  if (child_name = 'quantity') Then
     list.add(Quantity.Link);
  if (child_name = 'rate') Then
     list.add(Rate.Link);
  if (child_name = 'maxDosePerPeriod') Then
     list.add(MaxDosePerPeriod.Link);
end;

procedure TFhirMedicationDispenseDispenseDosage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'additionalInstructions', 'CodeableConcept', FAdditionalInstructions.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'dateTime|Period|Schedule', FTiming.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'asNeeded[x]', 'boolean|CodeableConcept', FAsNeeded.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'site', 'CodeableConcept', FSite.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', FRoute.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', FMethod.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rate', 'Ratio', FRate.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxDosePerPeriod', 'Ratio', FMaxDosePerPeriod.Link.Link));{2}
end;

function TFhirMedicationDispenseDispenseDosage.Link : TFhirMedicationDispenseDispenseDosage;
begin
  result := TFhirMedicationDispenseDispenseDosage(inherited Link);
end;

function TFhirMedicationDispenseDispenseDosage.Clone : TFhirMedicationDispenseDispenseDosage;
begin
  result := TFhirMedicationDispenseDispenseDosage(inherited Clone);
end;

{ TFhirMedicationDispenseDispenseDosage }

Procedure TFhirMedicationDispenseDispenseDosage.SetAdditionalInstructions(value : TFhirCodeableConcept);
begin
  FAdditionalInstructions.free;
  FAdditionalInstructions := value;
end;

Procedure TFhirMedicationDispenseDispenseDosage.SetTiming(value : TFhirType);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirMedicationDispenseDispenseDosage.SetAsNeeded(value : TFhirType);
begin
  FAsNeeded.free;
  FAsNeeded := value;
end;

Procedure TFhirMedicationDispenseDispenseDosage.SetSite(value : TFhirCodeableConcept);
begin
  FSite.free;
  FSite := value;
end;

Procedure TFhirMedicationDispenseDispenseDosage.SetRoute(value : TFhirCodeableConcept);
begin
  FRoute.free;
  FRoute := value;
end;

Procedure TFhirMedicationDispenseDispenseDosage.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirMedicationDispenseDispenseDosage.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirMedicationDispenseDispenseDosage.SetRate(value : TFhirRatio);
begin
  FRate.free;
  FRate := value;
end;

Procedure TFhirMedicationDispenseDispenseDosage.SetMaxDosePerPeriod(value : TFhirRatio);
begin
  FMaxDosePerPeriod.free;
  FMaxDosePerPeriod := value;
end;


{ TFhirMedicationDispenseDispenseDosageList }
procedure TFhirMedicationDispenseDispenseDosageList.AddItem(value: TFhirMedicationDispenseDispenseDosage);
begin
  assert(value.ClassName = 'TFhirMedicationDispenseDispenseDosage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationDispenseDispenseDosage');
  add(value);
end;


function TFhirMedicationDispenseDispenseDosageList.Append: TFhirMedicationDispenseDispenseDosage;
begin
  result := TFhirMedicationDispenseDispenseDosage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationDispenseDispenseDosageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationDispenseDispenseDosageList.Clone: TFhirMedicationDispenseDispenseDosageList;
begin
  result := TFhirMedicationDispenseDispenseDosageList(inherited Clone);
end;

function TFhirMedicationDispenseDispenseDosageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationDispenseDispenseDosageList.GetItemN(index: Integer): TFhirMedicationDispenseDispenseDosage;
begin
  result := TFhirMedicationDispenseDispenseDosage(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseDispenseDosageList.IndexOf(value: TFhirMedicationDispenseDispenseDosage): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationDispenseDispenseDosageList.Insert(index: Integer): TFhirMedicationDispenseDispenseDosage;
begin
  result := TFhirMedicationDispenseDispenseDosage.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationDispenseDispenseDosageList.InsertItem(index: Integer; value: TFhirMedicationDispenseDispenseDosage);
begin
  assert(value is TFhirMedicationDispenseDispenseDosage);
  Inherited Insert(index, value);
end;

function TFhirMedicationDispenseDispenseDosageList.Item(index: Integer): TFhirMedicationDispenseDispenseDosage;
begin
  result := TFhirMedicationDispenseDispenseDosage(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseDispenseDosageList.Link: TFhirMedicationDispenseDispenseDosageList;
begin
  result := TFhirMedicationDispenseDispenseDosageList(inherited Link);
end;

procedure TFhirMedicationDispenseDispenseDosageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationDispenseDispenseDosageList.SetItemByIndex(index: Integer; value: TFhirMedicationDispenseDispenseDosage);
begin
  assert(value is TFhirMedicationDispenseDispenseDosage);
  FhirMedicationDispenseDispenseDosages[index] := value;
end;

procedure TFhirMedicationDispenseDispenseDosageList.SetItemN(index: Integer; value: TFhirMedicationDispenseDispenseDosage);
begin
  assert(value is TFhirMedicationDispenseDispenseDosage);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationDispenseSubstitution }

constructor TFhirMedicationDispenseSubstitution.Create;
begin
  inherited;
  FReasonList := TFhirCodeableConceptList.Create;
  FResponsiblePartyList := TFhirResourceReferenceList{TFhirPractitioner}.Create;
end;

destructor TFhirMedicationDispenseSubstitution.Destroy;
begin
  FType_.free;
  FReasonList.Free;
  FResponsiblePartyList.Free;
  inherited;
end;

procedure TFhirMedicationDispenseSubstitution.Assign(oSource : TAdvObject);
begin
  inherited;
  type_ := TFhirMedicationDispenseSubstitution(oSource).type_.Clone;
  FReasonList.Assign(TFhirMedicationDispenseSubstitution(oSource).FReasonList);
  FResponsiblePartyList.Assign(TFhirMedicationDispenseSubstitution(oSource).FResponsiblePartyList);
end;

procedure TFhirMedicationDispenseSubstitution.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'reason') Then
     list.addAll(FReasonList);
  if (child_name = 'responsibleParty') Then
     list.addAll(FResponsiblePartyList);
end;

procedure TFhirMedicationDispenseSubstitution.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', FReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'responsibleParty', 'Resource(Practitioner)', FResponsiblePartyList.Link)){3};
end;

function TFhirMedicationDispenseSubstitution.Link : TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(inherited Link);
end;

function TFhirMedicationDispenseSubstitution.Clone : TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(inherited Clone);
end;

{ TFhirMedicationDispenseSubstitution }

Procedure TFhirMedicationDispenseSubstitution.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;


{ TFhirMedicationDispenseSubstitutionList }
procedure TFhirMedicationDispenseSubstitutionList.AddItem(value: TFhirMedicationDispenseSubstitution);
begin
  assert(value.ClassName = 'TFhirMedicationDispenseSubstitution', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationDispenseSubstitution');
  add(value);
end;


function TFhirMedicationDispenseSubstitutionList.Append: TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationDispenseSubstitutionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationDispenseSubstitutionList.Clone: TFhirMedicationDispenseSubstitutionList;
begin
  result := TFhirMedicationDispenseSubstitutionList(inherited Clone);
end;

function TFhirMedicationDispenseSubstitutionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationDispenseSubstitutionList.GetItemN(index: Integer): TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseSubstitutionList.IndexOf(value: TFhirMedicationDispenseSubstitution): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationDispenseSubstitutionList.Insert(index: Integer): TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationDispenseSubstitutionList.InsertItem(index: Integer; value: TFhirMedicationDispenseSubstitution);
begin
  assert(value is TFhirMedicationDispenseSubstitution);
  Inherited Insert(index, value);
end;

function TFhirMedicationDispenseSubstitutionList.Item(index: Integer): TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseSubstitutionList.Link: TFhirMedicationDispenseSubstitutionList;
begin
  result := TFhirMedicationDispenseSubstitutionList(inherited Link);
end;

procedure TFhirMedicationDispenseSubstitutionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationDispenseSubstitutionList.SetItemByIndex(index: Integer; value: TFhirMedicationDispenseSubstitution);
begin
  assert(value is TFhirMedicationDispenseSubstitution);
  FhirMedicationDispenseSubstitutions[index] := value;
end;

procedure TFhirMedicationDispenseSubstitutionList.SetItemN(index: Integer; value: TFhirMedicationDispenseSubstitution);
begin
  assert(value is TFhirMedicationDispenseSubstitution);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationPrescriptionDosageInstruction }

constructor TFhirMedicationPrescriptionDosageInstruction.Create;
begin
  inherited;
end;

destructor TFhirMedicationPrescriptionDosageInstruction.Destroy;
begin
  FText.free;
  FAdditionalInstructions.free;
  FTiming.free;
  FAsNeeded.free;
  FSite.free;
  FRoute.free;
  FMethod.free;
  FDoseQuantity.free;
  FRate.free;
  FMaxDosePerPeriod.free;
  inherited;
end;

procedure TFhirMedicationPrescriptionDosageInstruction.Assign(oSource : TAdvObject);
begin
  inherited;
  text := TFhirMedicationPrescriptionDosageInstruction(oSource).text.Clone;
  additionalInstructions := TFhirMedicationPrescriptionDosageInstruction(oSource).additionalInstructions.Clone;
  timing := TFhirMedicationPrescriptionDosageInstruction(oSource).timing.Clone;
  asNeeded := TFhirMedicationPrescriptionDosageInstruction(oSource).asNeeded.Clone;
  site := TFhirMedicationPrescriptionDosageInstruction(oSource).site.Clone;
  route := TFhirMedicationPrescriptionDosageInstruction(oSource).route.Clone;
  method := TFhirMedicationPrescriptionDosageInstruction(oSource).method.Clone;
  doseQuantity := TFhirMedicationPrescriptionDosageInstruction(oSource).doseQuantity.Clone;
  rate := TFhirMedicationPrescriptionDosageInstruction(oSource).rate.Clone;
  maxDosePerPeriod := TFhirMedicationPrescriptionDosageInstruction(oSource).maxDosePerPeriod.Clone;
end;

procedure TFhirMedicationPrescriptionDosageInstruction.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'text') Then
     list.add(Text.Link);
  if (child_name = 'additionalInstructions') Then
     list.add(AdditionalInstructions.Link);
  if (child_name = 'timing') Then
     list.add(Timing.Link);
  if (child_name = 'asNeeded') Then
     list.add(AsNeeded.Link);
  if (child_name = 'site') Then
     list.add(Site.Link);
  if (child_name = 'route') Then
     list.add(Route.Link);
  if (child_name = 'method') Then
     list.add(Method.Link);
  if (child_name = 'doseQuantity') Then
     list.add(DoseQuantity.Link);
  if (child_name = 'rate') Then
     list.add(Rate.Link);
  if (child_name = 'maxDosePerPeriod') Then
     list.add(MaxDosePerPeriod.Link);
end;

procedure TFhirMedicationPrescriptionDosageInstruction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'text', 'string', FText.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'additionalInstructions', 'CodeableConcept', FAdditionalInstructions.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'dateTime|Period|Schedule', FTiming.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'asNeeded[x]', 'boolean|CodeableConcept', FAsNeeded.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'site', 'CodeableConcept', FSite.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', FRoute.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', FMethod.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'doseQuantity', 'Quantity', FDoseQuantity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rate', 'Ratio', FRate.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxDosePerPeriod', 'Ratio', FMaxDosePerPeriod.Link.Link));{2}
end;

function TFhirMedicationPrescriptionDosageInstruction.Link : TFhirMedicationPrescriptionDosageInstruction;
begin
  result := TFhirMedicationPrescriptionDosageInstruction(inherited Link);
end;

function TFhirMedicationPrescriptionDosageInstruction.Clone : TFhirMedicationPrescriptionDosageInstruction;
begin
  result := TFhirMedicationPrescriptionDosageInstruction(inherited Clone);
end;

{ TFhirMedicationPrescriptionDosageInstruction }

Procedure TFhirMedicationPrescriptionDosageInstruction.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirMedicationPrescriptionDosageInstruction.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := Text.value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetAdditionalInstructions(value : TFhirCodeableConcept);
begin
  FAdditionalInstructions.free;
  FAdditionalInstructions := value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetTiming(value : TFhirType);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetAsNeeded(value : TFhirType);
begin
  FAsNeeded.free;
  FAsNeeded := value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetSite(value : TFhirCodeableConcept);
begin
  FSite.free;
  FSite := value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetRoute(value : TFhirCodeableConcept);
begin
  FRoute.free;
  FRoute := value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetDoseQuantity(value : TFhirQuantity);
begin
  FDoseQuantity.free;
  FDoseQuantity := value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetRate(value : TFhirRatio);
begin
  FRate.free;
  FRate := value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetMaxDosePerPeriod(value : TFhirRatio);
begin
  FMaxDosePerPeriod.free;
  FMaxDosePerPeriod := value;
end;


{ TFhirMedicationPrescriptionDosageInstructionList }
procedure TFhirMedicationPrescriptionDosageInstructionList.AddItem(value: TFhirMedicationPrescriptionDosageInstruction);
begin
  assert(value.ClassName = 'TFhirMedicationPrescriptionDosageInstruction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationPrescriptionDosageInstruction');
  add(value);
end;


function TFhirMedicationPrescriptionDosageInstructionList.Append: TFhirMedicationPrescriptionDosageInstruction;
begin
  result := TFhirMedicationPrescriptionDosageInstruction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPrescriptionDosageInstructionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationPrescriptionDosageInstructionList.Clone: TFhirMedicationPrescriptionDosageInstructionList;
begin
  result := TFhirMedicationPrescriptionDosageInstructionList(inherited Clone);
end;

function TFhirMedicationPrescriptionDosageInstructionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationPrescriptionDosageInstructionList.GetItemN(index: Integer): TFhirMedicationPrescriptionDosageInstruction;
begin
  result := TFhirMedicationPrescriptionDosageInstruction(ObjectByIndex[index]);
end;

function TFhirMedicationPrescriptionDosageInstructionList.IndexOf(value: TFhirMedicationPrescriptionDosageInstruction): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationPrescriptionDosageInstructionList.Insert(index: Integer): TFhirMedicationPrescriptionDosageInstruction;
begin
  result := TFhirMedicationPrescriptionDosageInstruction.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPrescriptionDosageInstructionList.InsertItem(index: Integer; value: TFhirMedicationPrescriptionDosageInstruction);
begin
  assert(value is TFhirMedicationPrescriptionDosageInstruction);
  Inherited Insert(index, value);
end;

function TFhirMedicationPrescriptionDosageInstructionList.Item(index: Integer): TFhirMedicationPrescriptionDosageInstruction;
begin
  result := TFhirMedicationPrescriptionDosageInstruction(ObjectByIndex[index]);
end;

function TFhirMedicationPrescriptionDosageInstructionList.Link: TFhirMedicationPrescriptionDosageInstructionList;
begin
  result := TFhirMedicationPrescriptionDosageInstructionList(inherited Link);
end;

procedure TFhirMedicationPrescriptionDosageInstructionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationPrescriptionDosageInstructionList.SetItemByIndex(index: Integer; value: TFhirMedicationPrescriptionDosageInstruction);
begin
  assert(value is TFhirMedicationPrescriptionDosageInstruction);
  FhirMedicationPrescriptionDosageInstructions[index] := value;
end;

procedure TFhirMedicationPrescriptionDosageInstructionList.SetItemN(index: Integer; value: TFhirMedicationPrescriptionDosageInstruction);
begin
  assert(value is TFhirMedicationPrescriptionDosageInstruction);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationPrescriptionDispense }

constructor TFhirMedicationPrescriptionDispense.Create;
begin
  inherited;
end;

destructor TFhirMedicationPrescriptionDispense.Destroy;
begin
  FMedication.free;
  FValidityPeriod.free;
  FNumberOfRepeatsAllowed.free;
  FQuantity.free;
  FExpectedSupplyDuration.free;
  inherited;
end;

procedure TFhirMedicationPrescriptionDispense.Assign(oSource : TAdvObject);
begin
  inherited;
  medication := TFhirMedicationPrescriptionDispense(oSource).medication.Clone;
  validityPeriod := TFhirMedicationPrescriptionDispense(oSource).validityPeriod.Clone;
  numberOfRepeatsAllowed := TFhirMedicationPrescriptionDispense(oSource).numberOfRepeatsAllowed.Clone;
  quantity := TFhirMedicationPrescriptionDispense(oSource).quantity.Clone;
  expectedSupplyDuration := TFhirMedicationPrescriptionDispense(oSource).expectedSupplyDuration.Clone;
end;

procedure TFhirMedicationPrescriptionDispense.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'medication') Then
     list.add(Medication.Link);
  if (child_name = 'validityPeriod') Then
     list.add(ValidityPeriod.Link);
  if (child_name = 'numberOfRepeatsAllowed') Then
     list.add(NumberOfRepeatsAllowed.Link);
  if (child_name = 'quantity') Then
     list.add(Quantity.Link);
  if (child_name = 'expectedSupplyDuration') Then
     list.add(ExpectedSupplyDuration.Link);
end;

procedure TFhirMedicationPrescriptionDispense.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'medication', 'Resource(Medication)', FMedication.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'validityPeriod', 'Period', FValidityPeriod.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'numberOfRepeatsAllowed', 'integer', FNumberOfRepeatsAllowed.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expectedSupplyDuration', 'Duration', FExpectedSupplyDuration.Link.Link));{2}
end;

function TFhirMedicationPrescriptionDispense.Link : TFhirMedicationPrescriptionDispense;
begin
  result := TFhirMedicationPrescriptionDispense(inherited Link);
end;

function TFhirMedicationPrescriptionDispense.Clone : TFhirMedicationPrescriptionDispense;
begin
  result := TFhirMedicationPrescriptionDispense(inherited Clone);
end;

{ TFhirMedicationPrescriptionDispense }

Procedure TFhirMedicationPrescriptionDispense.SetMedication(value : TFhirResourceReference{TFhirMedication});
begin
  FMedication.free;
  FMedication := value;
end;

Procedure TFhirMedicationPrescriptionDispense.SetValidityPeriod(value : TFhirPeriod);
begin
  FValidityPeriod.free;
  FValidityPeriod := value;
end;

Procedure TFhirMedicationPrescriptionDispense.SetNumberOfRepeatsAllowed(value : TFhirInteger);
begin
  FNumberOfRepeatsAllowed.free;
  FNumberOfRepeatsAllowed := value;
end;

Function TFhirMedicationPrescriptionDispense.GetNumberOfRepeatsAllowedST : String;
begin
  if FNumberOfRepeatsAllowed = nil then
    result := ''
  else
    result := NumberOfRepeatsAllowed.value;
end;

Procedure TFhirMedicationPrescriptionDispense.SetNumberOfRepeatsAllowedST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfRepeatsAllowed = nil then
      FNumberOfRepeatsAllowed := TFhirInteger.create;
    FNumberOfRepeatsAllowed.value := value
  end
  else if FNumberOfRepeatsAllowed <> nil then
    FNumberOfRepeatsAllowed.value := '';
end;

Procedure TFhirMedicationPrescriptionDispense.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirMedicationPrescriptionDispense.SetExpectedSupplyDuration(value : TFhirQuantity);
begin
  FExpectedSupplyDuration.free;
  FExpectedSupplyDuration := value;
end;


{ TFhirMedicationPrescriptionDispenseList }
procedure TFhirMedicationPrescriptionDispenseList.AddItem(value: TFhirMedicationPrescriptionDispense);
begin
  assert(value.ClassName = 'TFhirMedicationPrescriptionDispense', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationPrescriptionDispense');
  add(value);
end;


function TFhirMedicationPrescriptionDispenseList.Append: TFhirMedicationPrescriptionDispense;
begin
  result := TFhirMedicationPrescriptionDispense.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPrescriptionDispenseList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationPrescriptionDispenseList.Clone: TFhirMedicationPrescriptionDispenseList;
begin
  result := TFhirMedicationPrescriptionDispenseList(inherited Clone);
end;

function TFhirMedicationPrescriptionDispenseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationPrescriptionDispenseList.GetItemN(index: Integer): TFhirMedicationPrescriptionDispense;
begin
  result := TFhirMedicationPrescriptionDispense(ObjectByIndex[index]);
end;

function TFhirMedicationPrescriptionDispenseList.IndexOf(value: TFhirMedicationPrescriptionDispense): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationPrescriptionDispenseList.Insert(index: Integer): TFhirMedicationPrescriptionDispense;
begin
  result := TFhirMedicationPrescriptionDispense.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPrescriptionDispenseList.InsertItem(index: Integer; value: TFhirMedicationPrescriptionDispense);
begin
  assert(value is TFhirMedicationPrescriptionDispense);
  Inherited Insert(index, value);
end;

function TFhirMedicationPrescriptionDispenseList.Item(index: Integer): TFhirMedicationPrescriptionDispense;
begin
  result := TFhirMedicationPrescriptionDispense(ObjectByIndex[index]);
end;

function TFhirMedicationPrescriptionDispenseList.Link: TFhirMedicationPrescriptionDispenseList;
begin
  result := TFhirMedicationPrescriptionDispenseList(inherited Link);
end;

procedure TFhirMedicationPrescriptionDispenseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationPrescriptionDispenseList.SetItemByIndex(index: Integer; value: TFhirMedicationPrescriptionDispense);
begin
  assert(value is TFhirMedicationPrescriptionDispense);
  FhirMedicationPrescriptionDispenses[index] := value;
end;

procedure TFhirMedicationPrescriptionDispenseList.SetItemN(index: Integer; value: TFhirMedicationPrescriptionDispense);
begin
  assert(value is TFhirMedicationPrescriptionDispense);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationPrescriptionSubstitution }

constructor TFhirMedicationPrescriptionSubstitution.Create;
begin
  inherited;
end;

destructor TFhirMedicationPrescriptionSubstitution.Destroy;
begin
  FType_.free;
  FReason.free;
  inherited;
end;

procedure TFhirMedicationPrescriptionSubstitution.Assign(oSource : TAdvObject);
begin
  inherited;
  type_ := TFhirMedicationPrescriptionSubstitution(oSource).type_.Clone;
  reason := TFhirMedicationPrescriptionSubstitution(oSource).reason.Clone;
end;

procedure TFhirMedicationPrescriptionSubstitution.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'reason') Then
     list.add(Reason.Link);
end;

procedure TFhirMedicationPrescriptionSubstitution.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', FReason.Link.Link));{2}
end;

function TFhirMedicationPrescriptionSubstitution.Link : TFhirMedicationPrescriptionSubstitution;
begin
  result := TFhirMedicationPrescriptionSubstitution(inherited Link);
end;

function TFhirMedicationPrescriptionSubstitution.Clone : TFhirMedicationPrescriptionSubstitution;
begin
  result := TFhirMedicationPrescriptionSubstitution(inherited Clone);
end;

{ TFhirMedicationPrescriptionSubstitution }

Procedure TFhirMedicationPrescriptionSubstitution.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirMedicationPrescriptionSubstitution.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value;
end;


{ TFhirMedicationPrescriptionSubstitutionList }
procedure TFhirMedicationPrescriptionSubstitutionList.AddItem(value: TFhirMedicationPrescriptionSubstitution);
begin
  assert(value.ClassName = 'TFhirMedicationPrescriptionSubstitution', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationPrescriptionSubstitution');
  add(value);
end;


function TFhirMedicationPrescriptionSubstitutionList.Append: TFhirMedicationPrescriptionSubstitution;
begin
  result := TFhirMedicationPrescriptionSubstitution.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPrescriptionSubstitutionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationPrescriptionSubstitutionList.Clone: TFhirMedicationPrescriptionSubstitutionList;
begin
  result := TFhirMedicationPrescriptionSubstitutionList(inherited Clone);
end;

function TFhirMedicationPrescriptionSubstitutionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationPrescriptionSubstitutionList.GetItemN(index: Integer): TFhirMedicationPrescriptionSubstitution;
begin
  result := TFhirMedicationPrescriptionSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationPrescriptionSubstitutionList.IndexOf(value: TFhirMedicationPrescriptionSubstitution): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationPrescriptionSubstitutionList.Insert(index: Integer): TFhirMedicationPrescriptionSubstitution;
begin
  result := TFhirMedicationPrescriptionSubstitution.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPrescriptionSubstitutionList.InsertItem(index: Integer; value: TFhirMedicationPrescriptionSubstitution);
begin
  assert(value is TFhirMedicationPrescriptionSubstitution);
  Inherited Insert(index, value);
end;

function TFhirMedicationPrescriptionSubstitutionList.Item(index: Integer): TFhirMedicationPrescriptionSubstitution;
begin
  result := TFhirMedicationPrescriptionSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationPrescriptionSubstitutionList.Link: TFhirMedicationPrescriptionSubstitutionList;
begin
  result := TFhirMedicationPrescriptionSubstitutionList(inherited Link);
end;

procedure TFhirMedicationPrescriptionSubstitutionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationPrescriptionSubstitutionList.SetItemByIndex(index: Integer; value: TFhirMedicationPrescriptionSubstitution);
begin
  assert(value is TFhirMedicationPrescriptionSubstitution);
  FhirMedicationPrescriptionSubstitutions[index] := value;
end;

procedure TFhirMedicationPrescriptionSubstitutionList.SetItemN(index: Integer; value: TFhirMedicationPrescriptionSubstitution);
begin
  assert(value is TFhirMedicationPrescriptionSubstitution);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationStatementDosage }

constructor TFhirMedicationStatementDosage.Create;
begin
  inherited;
end;

destructor TFhirMedicationStatementDosage.Destroy;
begin
  FTiming.free;
  FAsNeeded.free;
  FSite.free;
  FRoute.free;
  FMethod.free;
  FQuantity.free;
  FRate.free;
  FMaxDosePerPeriod.free;
  inherited;
end;

procedure TFhirMedicationStatementDosage.Assign(oSource : TAdvObject);
begin
  inherited;
  timing := TFhirMedicationStatementDosage(oSource).timing.Clone;
  asNeeded := TFhirMedicationStatementDosage(oSource).asNeeded.Clone;
  site := TFhirMedicationStatementDosage(oSource).site.Clone;
  route := TFhirMedicationStatementDosage(oSource).route.Clone;
  method := TFhirMedicationStatementDosage(oSource).method.Clone;
  quantity := TFhirMedicationStatementDosage(oSource).quantity.Clone;
  rate := TFhirMedicationStatementDosage(oSource).rate.Clone;
  maxDosePerPeriod := TFhirMedicationStatementDosage(oSource).maxDosePerPeriod.Clone;
end;

procedure TFhirMedicationStatementDosage.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'timing') Then
     list.add(Timing.Link);
  if (child_name = 'asNeeded') Then
     list.add(AsNeeded.Link);
  if (child_name = 'site') Then
     list.add(Site.Link);
  if (child_name = 'route') Then
     list.add(Route.Link);
  if (child_name = 'method') Then
     list.add(Method.Link);
  if (child_name = 'quantity') Then
     list.add(Quantity.Link);
  if (child_name = 'rate') Then
     list.add(Rate.Link);
  if (child_name = 'maxDosePerPeriod') Then
     list.add(MaxDosePerPeriod.Link);
end;

procedure TFhirMedicationStatementDosage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'timing', 'Schedule', FTiming.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'asNeeded[x]', 'boolean|CodeableConcept', FAsNeeded.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'site', 'CodeableConcept', FSite.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', FRoute.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', FMethod.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rate', 'Ratio', FRate.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxDosePerPeriod', 'Ratio', FMaxDosePerPeriod.Link.Link));{2}
end;

function TFhirMedicationStatementDosage.Link : TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage(inherited Link);
end;

function TFhirMedicationStatementDosage.Clone : TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage(inherited Clone);
end;

{ TFhirMedicationStatementDosage }

Procedure TFhirMedicationStatementDosage.SetTiming(value : TFhirSchedule);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirMedicationStatementDosage.SetAsNeeded(value : TFhirType);
begin
  FAsNeeded.free;
  FAsNeeded := value;
end;

Procedure TFhirMedicationStatementDosage.SetSite(value : TFhirCodeableConcept);
begin
  FSite.free;
  FSite := value;
end;

Procedure TFhirMedicationStatementDosage.SetRoute(value : TFhirCodeableConcept);
begin
  FRoute.free;
  FRoute := value;
end;

Procedure TFhirMedicationStatementDosage.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirMedicationStatementDosage.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirMedicationStatementDosage.SetRate(value : TFhirRatio);
begin
  FRate.free;
  FRate := value;
end;

Procedure TFhirMedicationStatementDosage.SetMaxDosePerPeriod(value : TFhirRatio);
begin
  FMaxDosePerPeriod.free;
  FMaxDosePerPeriod := value;
end;


{ TFhirMedicationStatementDosageList }
procedure TFhirMedicationStatementDosageList.AddItem(value: TFhirMedicationStatementDosage);
begin
  assert(value.ClassName = 'TFhirMedicationStatementDosage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationStatementDosage');
  add(value);
end;


function TFhirMedicationStatementDosageList.Append: TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationStatementDosageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationStatementDosageList.Clone: TFhirMedicationStatementDosageList;
begin
  result := TFhirMedicationStatementDosageList(inherited Clone);
end;

function TFhirMedicationStatementDosageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationStatementDosageList.GetItemN(index: Integer): TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage(ObjectByIndex[index]);
end;

function TFhirMedicationStatementDosageList.IndexOf(value: TFhirMedicationStatementDosage): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationStatementDosageList.Insert(index: Integer): TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationStatementDosageList.InsertItem(index: Integer; value: TFhirMedicationStatementDosage);
begin
  assert(value is TFhirMedicationStatementDosage);
  Inherited Insert(index, value);
end;

function TFhirMedicationStatementDosageList.Item(index: Integer): TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage(ObjectByIndex[index]);
end;

function TFhirMedicationStatementDosageList.Link: TFhirMedicationStatementDosageList;
begin
  result := TFhirMedicationStatementDosageList(inherited Link);
end;

procedure TFhirMedicationStatementDosageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationStatementDosageList.SetItemByIndex(index: Integer; value: TFhirMedicationStatementDosage);
begin
  assert(value is TFhirMedicationStatementDosage);
  FhirMedicationStatementDosages[index] := value;
end;

procedure TFhirMedicationStatementDosageList.SetItemN(index: Integer; value: TFhirMedicationStatementDosage);
begin
  assert(value is TFhirMedicationStatementDosage);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageHeaderResponse }

constructor TFhirMessageHeaderResponse.Create;
begin
  inherited;
end;

destructor TFhirMessageHeaderResponse.Destroy;
begin
  FIdentifier.free;
  FCode.free;
  FDetails.free;
  inherited;
end;

procedure TFhirMessageHeaderResponse.Assign(oSource : TAdvObject);
begin
  inherited;
  identifier := TFhirMessageHeaderResponse(oSource).identifier.Clone;
  FCode := TFhirMessageHeaderResponse(oSource).FCode.Link;
  details := TFhirMessageHeaderResponse(oSource).details.Clone;
end;

procedure TFhirMessageHeaderResponse.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(Identifier.Link);
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'details') Then
     list.add(Details.Link);
end;

procedure TFhirMessageHeaderResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'id', FIdentifier.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'details', 'Resource(OperationOutcome)', FDetails.Link.Link));{2}
end;

function TFhirMessageHeaderResponse.Link : TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(inherited Link);
end;

function TFhirMessageHeaderResponse.Clone : TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(inherited Clone);
end;

{ TFhirMessageHeaderResponse }

Procedure TFhirMessageHeaderResponse.SetIdentifier(value : TFhirId);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirMessageHeaderResponse.GetIdentifierST : String;
begin
  if FIdentifier = nil then
    result := ''
  else
    result := Identifier.value;
end;

Procedure TFhirMessageHeaderResponse.SetIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FIdentifier = nil then
      FIdentifier := TFhirId.create;
    FIdentifier.value := value
  end
  else if FIdentifier <> nil then
    FIdentifier.value := '';
end;

Procedure TFhirMessageHeaderResponse.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirMessageHeaderResponse.GetCodeST : TFhirResponseCode;
begin
  if FCode = nil then
    result := TFhirResponseCode(0)
  else
    result := TFhirResponseCode(StringArrayIndexOf(CODES_TFhirResponseCode, Code.value));
end;

Procedure TFhirMessageHeaderResponse.SetCodeST(value : TFhirResponseCode);
begin
  if ord(value) = 0 then
    Code := nil
  else
    Code := TFhirEnum.create(CODES_TFhirResponseCode[value]);
end;

Procedure TFhirMessageHeaderResponse.SetDetails(value : TFhirResourceReference{TFhirOperationOutcome});
begin
  FDetails.free;
  FDetails := value;
end;


{ TFhirMessageHeaderResponseList }
procedure TFhirMessageHeaderResponseList.AddItem(value: TFhirMessageHeaderResponse);
begin
  assert(value.ClassName = 'TFhirMessageHeaderResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeaderResponse');
  add(value);
end;


function TFhirMessageHeaderResponseList.Append: TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMessageHeaderResponseList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderResponseList.Clone: TFhirMessageHeaderResponseList;
begin
  result := TFhirMessageHeaderResponseList(inherited Clone);
end;

function TFhirMessageHeaderResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderResponseList.GetItemN(index: Integer): TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(ObjectByIndex[index]);
end;

function TFhirMessageHeaderResponseList.IndexOf(value: TFhirMessageHeaderResponse): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMessageHeaderResponseList.Insert(index: Integer): TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMessageHeaderResponseList.InsertItem(index: Integer; value: TFhirMessageHeaderResponse);
begin
  assert(value is TFhirMessageHeaderResponse);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderResponseList.Item(index: Integer): TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(ObjectByIndex[index]);
end;

function TFhirMessageHeaderResponseList.Link: TFhirMessageHeaderResponseList;
begin
  result := TFhirMessageHeaderResponseList(inherited Link);
end;

procedure TFhirMessageHeaderResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderResponseList.SetItemByIndex(index: Integer; value: TFhirMessageHeaderResponse);
begin
  assert(value is TFhirMessageHeaderResponse);
  FhirMessageHeaderResponses[index] := value;
end;

procedure TFhirMessageHeaderResponseList.SetItemN(index: Integer; value: TFhirMessageHeaderResponse);
begin
  assert(value is TFhirMessageHeaderResponse);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageHeaderSource }

constructor TFhirMessageHeaderSource.Create;
begin
  inherited;
end;

destructor TFhirMessageHeaderSource.Destroy;
begin
  FName.free;
  FSoftware.free;
  FVersion.free;
  FContact.free;
  FEndpoint.free;
  inherited;
end;

procedure TFhirMessageHeaderSource.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirMessageHeaderSource(oSource).name.Clone;
  software := TFhirMessageHeaderSource(oSource).software.Clone;
  version := TFhirMessageHeaderSource(oSource).version.Clone;
  contact := TFhirMessageHeaderSource(oSource).contact.Clone;
  endpoint := TFhirMessageHeaderSource(oSource).endpoint.Clone;
end;

procedure TFhirMessageHeaderSource.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'software') Then
     list.add(Software.Link);
  if (child_name = 'version') Then
     list.add(Version.Link);
  if (child_name = 'contact') Then
     list.add(Contact.Link);
  if (child_name = 'endpoint') Then
     list.add(Endpoint.Link);
end;

procedure TFhirMessageHeaderSource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'software', 'string', FSoftware.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', FVersion.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contact', 'Contact', FContact.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'endpoint', 'uri', FEndpoint.Link.Link));{2}
end;

function TFhirMessageHeaderSource.Link : TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(inherited Link);
end;

function TFhirMessageHeaderSource.Clone : TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(inherited Clone);
end;

{ TFhirMessageHeaderSource }

Procedure TFhirMessageHeaderSource.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirMessageHeaderSource.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirMessageHeaderSource.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirMessageHeaderSource.SetSoftware(value : TFhirString);
begin
  FSoftware.free;
  FSoftware := value;
end;

Function TFhirMessageHeaderSource.GetSoftwareST : String;
begin
  if FSoftware = nil then
    result := ''
  else
    result := Software.value;
end;

Procedure TFhirMessageHeaderSource.SetSoftwareST(value : String);
begin
  if value <> '' then
  begin
    if FSoftware = nil then
      FSoftware := TFhirString.create;
    FSoftware.value := value
  end
  else if FSoftware <> nil then
    FSoftware.value := '';
end;

Procedure TFhirMessageHeaderSource.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirMessageHeaderSource.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := Version.value;
end;

Procedure TFhirMessageHeaderSource.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirMessageHeaderSource.SetContact(value : TFhirContact);
begin
  FContact.free;
  FContact := value;
end;

Procedure TFhirMessageHeaderSource.SetEndpoint(value : TFhirUri);
begin
  FEndpoint.free;
  FEndpoint := value;
end;

Function TFhirMessageHeaderSource.GetEndpointST : String;
begin
  if FEndpoint = nil then
    result := ''
  else
    result := Endpoint.value;
end;

Procedure TFhirMessageHeaderSource.SetEndpointST(value : String);
begin
  if value <> '' then
  begin
    if FEndpoint = nil then
      FEndpoint := TFhirUri.create;
    FEndpoint.value := value
  end
  else if FEndpoint <> nil then
    FEndpoint.value := '';
end;


{ TFhirMessageHeaderSourceList }
procedure TFhirMessageHeaderSourceList.AddItem(value: TFhirMessageHeaderSource);
begin
  assert(value.ClassName = 'TFhirMessageHeaderSource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeaderSource');
  add(value);
end;


function TFhirMessageHeaderSourceList.Append: TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMessageHeaderSourceList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderSourceList.Clone: TFhirMessageHeaderSourceList;
begin
  result := TFhirMessageHeaderSourceList(inherited Clone);
end;

function TFhirMessageHeaderSourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderSourceList.GetItemN(index: Integer): TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(ObjectByIndex[index]);
end;

function TFhirMessageHeaderSourceList.IndexOf(value: TFhirMessageHeaderSource): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMessageHeaderSourceList.Insert(index: Integer): TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMessageHeaderSourceList.InsertItem(index: Integer; value: TFhirMessageHeaderSource);
begin
  assert(value is TFhirMessageHeaderSource);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderSourceList.Item(index: Integer): TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(ObjectByIndex[index]);
end;

function TFhirMessageHeaderSourceList.Link: TFhirMessageHeaderSourceList;
begin
  result := TFhirMessageHeaderSourceList(inherited Link);
end;

procedure TFhirMessageHeaderSourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderSourceList.SetItemByIndex(index: Integer; value: TFhirMessageHeaderSource);
begin
  assert(value is TFhirMessageHeaderSource);
  FhirMessageHeaderSources[index] := value;
end;

procedure TFhirMessageHeaderSourceList.SetItemN(index: Integer; value: TFhirMessageHeaderSource);
begin
  assert(value is TFhirMessageHeaderSource);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageHeaderDestination }

constructor TFhirMessageHeaderDestination.Create;
begin
  inherited;
end;

destructor TFhirMessageHeaderDestination.Destroy;
begin
  FName.free;
  FTarget.free;
  FEndpoint.free;
  inherited;
end;

procedure TFhirMessageHeaderDestination.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirMessageHeaderDestination(oSource).name.Clone;
  target := TFhirMessageHeaderDestination(oSource).target.Clone;
  endpoint := TFhirMessageHeaderDestination(oSource).endpoint.Clone;
end;

procedure TFhirMessageHeaderDestination.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'target') Then
     list.add(Target.Link);
  if (child_name = 'endpoint') Then
     list.add(Endpoint.Link);
end;

procedure TFhirMessageHeaderDestination.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', 'Resource(Device)', FTarget.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'endpoint', 'uri', FEndpoint.Link.Link));{2}
end;

function TFhirMessageHeaderDestination.Link : TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(inherited Link);
end;

function TFhirMessageHeaderDestination.Clone : TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(inherited Clone);
end;

{ TFhirMessageHeaderDestination }

Procedure TFhirMessageHeaderDestination.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirMessageHeaderDestination.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirMessageHeaderDestination.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirMessageHeaderDestination.SetTarget(value : TFhirResourceReference{TFhirDevice});
begin
  FTarget.free;
  FTarget := value;
end;

Procedure TFhirMessageHeaderDestination.SetEndpoint(value : TFhirUri);
begin
  FEndpoint.free;
  FEndpoint := value;
end;

Function TFhirMessageHeaderDestination.GetEndpointST : String;
begin
  if FEndpoint = nil then
    result := ''
  else
    result := Endpoint.value;
end;

Procedure TFhirMessageHeaderDestination.SetEndpointST(value : String);
begin
  if value <> '' then
  begin
    if FEndpoint = nil then
      FEndpoint := TFhirUri.create;
    FEndpoint.value := value
  end
  else if FEndpoint <> nil then
    FEndpoint.value := '';
end;


{ TFhirMessageHeaderDestinationList }
procedure TFhirMessageHeaderDestinationList.AddItem(value: TFhirMessageHeaderDestination);
begin
  assert(value.ClassName = 'TFhirMessageHeaderDestination', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeaderDestination');
  add(value);
end;


function TFhirMessageHeaderDestinationList.Append: TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMessageHeaderDestinationList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderDestinationList.Clone: TFhirMessageHeaderDestinationList;
begin
  result := TFhirMessageHeaderDestinationList(inherited Clone);
end;

function TFhirMessageHeaderDestinationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderDestinationList.GetItemN(index: Integer): TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(ObjectByIndex[index]);
end;

function TFhirMessageHeaderDestinationList.IndexOf(value: TFhirMessageHeaderDestination): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMessageHeaderDestinationList.Insert(index: Integer): TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMessageHeaderDestinationList.InsertItem(index: Integer; value: TFhirMessageHeaderDestination);
begin
  assert(value is TFhirMessageHeaderDestination);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderDestinationList.Item(index: Integer): TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(ObjectByIndex[index]);
end;

function TFhirMessageHeaderDestinationList.Link: TFhirMessageHeaderDestinationList;
begin
  result := TFhirMessageHeaderDestinationList(inherited Link);
end;

procedure TFhirMessageHeaderDestinationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderDestinationList.SetItemByIndex(index: Integer; value: TFhirMessageHeaderDestination);
begin
  assert(value is TFhirMessageHeaderDestination);
  FhirMessageHeaderDestinations[index] := value;
end;

procedure TFhirMessageHeaderDestinationList.SetItemN(index: Integer; value: TFhirMessageHeaderDestination);
begin
  assert(value is TFhirMessageHeaderDestination);
  ObjectByIndex[index] := value;
end;

{ TFhirObservationReferenceRange }

constructor TFhirObservationReferenceRange.Create;
begin
  inherited;
end;

destructor TFhirObservationReferenceRange.Destroy;
begin
  FLow.free;
  FHigh.free;
  FMeaning.free;
  FAge.free;
  inherited;
end;

procedure TFhirObservationReferenceRange.Assign(oSource : TAdvObject);
begin
  inherited;
  low := TFhirObservationReferenceRange(oSource).low.Clone;
  high := TFhirObservationReferenceRange(oSource).high.Clone;
  meaning := TFhirObservationReferenceRange(oSource).meaning.Clone;
  age := TFhirObservationReferenceRange(oSource).age.Clone;
end;

procedure TFhirObservationReferenceRange.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'low') Then
     list.add(Low.Link);
  if (child_name = 'high') Then
     list.add(High.Link);
  if (child_name = 'meaning') Then
     list.add(Meaning.Link);
  if (child_name = 'age') Then
     list.add(Age.Link);
end;

procedure TFhirObservationReferenceRange.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'low', 'Quantity', FLow.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'high', 'Quantity', FHigh.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'meaning', 'CodeableConcept', FMeaning.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'age', 'Range', FAge.Link.Link));{2}
end;

function TFhirObservationReferenceRange.Link : TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(inherited Link);
end;

function TFhirObservationReferenceRange.Clone : TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(inherited Clone);
end;

{ TFhirObservationReferenceRange }

Procedure TFhirObservationReferenceRange.SetLow(value : TFhirQuantity);
begin
  FLow.free;
  FLow := value;
end;

Procedure TFhirObservationReferenceRange.SetHigh(value : TFhirQuantity);
begin
  FHigh.free;
  FHigh := value;
end;

Procedure TFhirObservationReferenceRange.SetMeaning(value : TFhirCodeableConcept);
begin
  FMeaning.free;
  FMeaning := value;
end;

Procedure TFhirObservationReferenceRange.SetAge(value : TFhirRange);
begin
  FAge.free;
  FAge := value;
end;


{ TFhirObservationReferenceRangeList }
procedure TFhirObservationReferenceRangeList.AddItem(value: TFhirObservationReferenceRange);
begin
  assert(value.ClassName = 'TFhirObservationReferenceRange', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirObservationReferenceRange');
  add(value);
end;


function TFhirObservationReferenceRangeList.Append: TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirObservationReferenceRangeList.ClearItems;
begin
  Clear;
end;

function TFhirObservationReferenceRangeList.Clone: TFhirObservationReferenceRangeList;
begin
  result := TFhirObservationReferenceRangeList(inherited Clone);
end;

function TFhirObservationReferenceRangeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirObservationReferenceRangeList.GetItemN(index: Integer): TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(ObjectByIndex[index]);
end;

function TFhirObservationReferenceRangeList.IndexOf(value: TFhirObservationReferenceRange): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirObservationReferenceRangeList.Insert(index: Integer): TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirObservationReferenceRangeList.InsertItem(index: Integer; value: TFhirObservationReferenceRange);
begin
  assert(value is TFhirObservationReferenceRange);
  Inherited Insert(index, value);
end;

function TFhirObservationReferenceRangeList.Item(index: Integer): TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(ObjectByIndex[index]);
end;

function TFhirObservationReferenceRangeList.Link: TFhirObservationReferenceRangeList;
begin
  result := TFhirObservationReferenceRangeList(inherited Link);
end;

procedure TFhirObservationReferenceRangeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirObservationReferenceRangeList.SetItemByIndex(index: Integer; value: TFhirObservationReferenceRange);
begin
  assert(value is TFhirObservationReferenceRange);
  FhirObservationReferenceRanges[index] := value;
end;

procedure TFhirObservationReferenceRangeList.SetItemN(index: Integer; value: TFhirObservationReferenceRange);
begin
  assert(value is TFhirObservationReferenceRange);
  ObjectByIndex[index] := value;
end;

{ TFhirObservationRelated }

constructor TFhirObservationRelated.Create;
begin
  inherited;
end;

destructor TFhirObservationRelated.Destroy;
begin
  FType_.free;
  FTarget.free;
  inherited;
end;

procedure TFhirObservationRelated.Assign(oSource : TAdvObject);
begin
  inherited;
  FType_ := TFhirObservationRelated(oSource).FType_.Link;
  target := TFhirObservationRelated(oSource).target.Clone;
end;

procedure TFhirObservationRelated.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.add(FType_.Link);
  if (child_name = 'target') Then
     list.add(Target.Link);
end;

procedure TFhirObservationRelated.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'target', 'Resource(Observation)', FTarget.Link.Link));{2}
end;

function TFhirObservationRelated.Link : TFhirObservationRelated;
begin
  result := TFhirObservationRelated(inherited Link);
end;

function TFhirObservationRelated.Clone : TFhirObservationRelated;
begin
  result := TFhirObservationRelated(inherited Clone);
end;

{ TFhirObservationRelated }

Procedure TFhirObservationRelated.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirObservationRelated.GetType_ST : TFhirObservationRelationshiptypes;
begin
  if FType_ = nil then
    result := TFhirObservationRelationshiptypes(0)
  else
    result := TFhirObservationRelationshiptypes(StringArrayIndexOf(CODES_TFhirObservationRelationshiptypes, Type_.value));
end;

Procedure TFhirObservationRelated.SetType_ST(value : TFhirObservationRelationshiptypes);
begin
  if ord(value) = 0 then
    Type_ := nil
  else
    Type_ := TFhirEnum.create(CODES_TFhirObservationRelationshiptypes[value]);
end;

Procedure TFhirObservationRelated.SetTarget(value : TFhirResourceReference{TFhirObservation});
begin
  FTarget.free;
  FTarget := value;
end;


{ TFhirObservationRelatedList }
procedure TFhirObservationRelatedList.AddItem(value: TFhirObservationRelated);
begin
  assert(value.ClassName = 'TFhirObservationRelated', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirObservationRelated');
  add(value);
end;


function TFhirObservationRelatedList.Append: TFhirObservationRelated;
begin
  result := TFhirObservationRelated.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirObservationRelatedList.ClearItems;
begin
  Clear;
end;

function TFhirObservationRelatedList.Clone: TFhirObservationRelatedList;
begin
  result := TFhirObservationRelatedList(inherited Clone);
end;

function TFhirObservationRelatedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirObservationRelatedList.GetItemN(index: Integer): TFhirObservationRelated;
begin
  result := TFhirObservationRelated(ObjectByIndex[index]);
end;

function TFhirObservationRelatedList.IndexOf(value: TFhirObservationRelated): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirObservationRelatedList.Insert(index: Integer): TFhirObservationRelated;
begin
  result := TFhirObservationRelated.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirObservationRelatedList.InsertItem(index: Integer; value: TFhirObservationRelated);
begin
  assert(value is TFhirObservationRelated);
  Inherited Insert(index, value);
end;

function TFhirObservationRelatedList.Item(index: Integer): TFhirObservationRelated;
begin
  result := TFhirObservationRelated(ObjectByIndex[index]);
end;

function TFhirObservationRelatedList.Link: TFhirObservationRelatedList;
begin
  result := TFhirObservationRelatedList(inherited Link);
end;

procedure TFhirObservationRelatedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirObservationRelatedList.SetItemByIndex(index: Integer; value: TFhirObservationRelated);
begin
  assert(value is TFhirObservationRelated);
  FhirObservationRelateds[index] := value;
end;

procedure TFhirObservationRelatedList.SetItemN(index: Integer; value: TFhirObservationRelated);
begin
  assert(value is TFhirObservationRelated);
  ObjectByIndex[index] := value;
end;

{ TFhirOperationOutcomeIssue }

constructor TFhirOperationOutcomeIssue.Create;
begin
  inherited;
  FLocationList := TFhirStringList.Create;
end;

destructor TFhirOperationOutcomeIssue.Destroy;
begin
  FSeverity.free;
  FType_.free;
  FDetails.free;
  FLocationList.Free;
  inherited;
end;

procedure TFhirOperationOutcomeIssue.Assign(oSource : TAdvObject);
begin
  inherited;
  FSeverity := TFhirOperationOutcomeIssue(oSource).FSeverity.Link;
  type_ := TFhirOperationOutcomeIssue(oSource).type_.Clone;
  details := TFhirOperationOutcomeIssue(oSource).details.Clone;
  FLocationList.Assign(TFhirOperationOutcomeIssue(oSource).FLocationList);
end;

procedure TFhirOperationOutcomeIssue.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'severity') Then
     list.add(FSeverity.Link);
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'details') Then
     list.add(Details.Link);
  if (child_name = 'location') Then
     list.addAll(FLocationList);
end;

procedure TFhirOperationOutcomeIssue.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'severity', 'code', FSeverity.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'details', 'string', FDetails.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location', 'string', FLocationList.Link)){3};
end;

function TFhirOperationOutcomeIssue.Link : TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(inherited Link);
end;

function TFhirOperationOutcomeIssue.Clone : TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(inherited Clone);
end;

{ TFhirOperationOutcomeIssue }

Procedure TFhirOperationOutcomeIssue.SetSeverity(value : TFhirEnum);
begin
  FSeverity.free;
  FSeverity := value;
end;

Function TFhirOperationOutcomeIssue.GetSeverityST : TFhirIssueSeverity;
begin
  if FSeverity = nil then
    result := TFhirIssueSeverity(0)
  else
    result := TFhirIssueSeverity(StringArrayIndexOf(CODES_TFhirIssueSeverity, Severity.value));
end;

Procedure TFhirOperationOutcomeIssue.SetSeverityST(value : TFhirIssueSeverity);
begin
  if ord(value) = 0 then
    Severity := nil
  else
    Severity := TFhirEnum.create(CODES_TFhirIssueSeverity[value]);
end;

Procedure TFhirOperationOutcomeIssue.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirOperationOutcomeIssue.SetDetails(value : TFhirString);
begin
  FDetails.free;
  FDetails := value;
end;

Function TFhirOperationOutcomeIssue.GetDetailsST : String;
begin
  if FDetails = nil then
    result := ''
  else
    result := Details.value;
end;

Procedure TFhirOperationOutcomeIssue.SetDetailsST(value : String);
begin
  if value <> '' then
  begin
    if FDetails = nil then
      FDetails := TFhirString.create;
    FDetails.value := value
  end
  else if FDetails <> nil then
    FDetails.value := '';
end;


{ TFhirOperationOutcomeIssueList }
procedure TFhirOperationOutcomeIssueList.AddItem(value: TFhirOperationOutcomeIssue);
begin
  assert(value.ClassName = 'TFhirOperationOutcomeIssue', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationOutcomeIssue');
  add(value);
end;


function TFhirOperationOutcomeIssueList.Append: TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirOperationOutcomeIssueList.ClearItems;
begin
  Clear;
end;

function TFhirOperationOutcomeIssueList.Clone: TFhirOperationOutcomeIssueList;
begin
  result := TFhirOperationOutcomeIssueList(inherited Clone);
end;

function TFhirOperationOutcomeIssueList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationOutcomeIssueList.GetItemN(index: Integer): TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeIssueList.IndexOf(value: TFhirOperationOutcomeIssue): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirOperationOutcomeIssueList.Insert(index: Integer): TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirOperationOutcomeIssueList.InsertItem(index: Integer; value: TFhirOperationOutcomeIssue);
begin
  assert(value is TFhirOperationOutcomeIssue);
  Inherited Insert(index, value);
end;

function TFhirOperationOutcomeIssueList.Item(index: Integer): TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeIssueList.Link: TFhirOperationOutcomeIssueList;
begin
  result := TFhirOperationOutcomeIssueList(inherited Link);
end;

procedure TFhirOperationOutcomeIssueList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationOutcomeIssueList.SetItemByIndex(index: Integer; value: TFhirOperationOutcomeIssue);
begin
  assert(value is TFhirOperationOutcomeIssue);
  FhirOperationOutcomeIssues[index] := value;
end;

procedure TFhirOperationOutcomeIssueList.SetItemN(index: Integer; value: TFhirOperationOutcomeIssue);
begin
  assert(value is TFhirOperationOutcomeIssue);
  ObjectByIndex[index] := value;
end;

{ TFhirOrderWhen }

constructor TFhirOrderWhen.Create;
begin
  inherited;
end;

destructor TFhirOrderWhen.Destroy;
begin
  FCode.free;
  FSchedule.free;
  inherited;
end;

procedure TFhirOrderWhen.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirOrderWhen(oSource).code.Clone;
  schedule := TFhirOrderWhen(oSource).schedule.Clone;
end;

procedure TFhirOrderWhen.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'schedule') Then
     list.add(Schedule.Link);
end;

procedure TFhirOrderWhen.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'schedule', 'Schedule', FSchedule.Link.Link));{2}
end;

function TFhirOrderWhen.Link : TFhirOrderWhen;
begin
  result := TFhirOrderWhen(inherited Link);
end;

function TFhirOrderWhen.Clone : TFhirOrderWhen;
begin
  result := TFhirOrderWhen(inherited Clone);
end;

{ TFhirOrderWhen }

Procedure TFhirOrderWhen.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirOrderWhen.SetSchedule(value : TFhirSchedule);
begin
  FSchedule.free;
  FSchedule := value;
end;


{ TFhirOrderWhenList }
procedure TFhirOrderWhenList.AddItem(value: TFhirOrderWhen);
begin
  assert(value.ClassName = 'TFhirOrderWhen', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOrderWhen');
  add(value);
end;


function TFhirOrderWhenList.Append: TFhirOrderWhen;
begin
  result := TFhirOrderWhen.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirOrderWhenList.ClearItems;
begin
  Clear;
end;

function TFhirOrderWhenList.Clone: TFhirOrderWhenList;
begin
  result := TFhirOrderWhenList(inherited Clone);
end;

function TFhirOrderWhenList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOrderWhenList.GetItemN(index: Integer): TFhirOrderWhen;
begin
  result := TFhirOrderWhen(ObjectByIndex[index]);
end;

function TFhirOrderWhenList.IndexOf(value: TFhirOrderWhen): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirOrderWhenList.Insert(index: Integer): TFhirOrderWhen;
begin
  result := TFhirOrderWhen.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirOrderWhenList.InsertItem(index: Integer; value: TFhirOrderWhen);
begin
  assert(value is TFhirOrderWhen);
  Inherited Insert(index, value);
end;

function TFhirOrderWhenList.Item(index: Integer): TFhirOrderWhen;
begin
  result := TFhirOrderWhen(ObjectByIndex[index]);
end;

function TFhirOrderWhenList.Link: TFhirOrderWhenList;
begin
  result := TFhirOrderWhenList(inherited Link);
end;

procedure TFhirOrderWhenList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOrderWhenList.SetItemByIndex(index: Integer; value: TFhirOrderWhen);
begin
  assert(value is TFhirOrderWhen);
  FhirOrderWhens[index] := value;
end;

procedure TFhirOrderWhenList.SetItemN(index: Integer; value: TFhirOrderWhen);
begin
  assert(value is TFhirOrderWhen);
  ObjectByIndex[index] := value;
end;

{ TFhirOrganizationContact }

constructor TFhirOrganizationContact.Create;
begin
  inherited;
  FTelecomList := TFhirContactList.Create;
end;

destructor TFhirOrganizationContact.Destroy;
begin
  FPurpose.free;
  FName.free;
  FTelecomList.Free;
  FAddress.free;
  FGender.free;
  inherited;
end;

procedure TFhirOrganizationContact.Assign(oSource : TAdvObject);
begin
  inherited;
  purpose := TFhirOrganizationContact(oSource).purpose.Clone;
  name := TFhirOrganizationContact(oSource).name.Clone;
  FTelecomList.Assign(TFhirOrganizationContact(oSource).FTelecomList);
  address := TFhirOrganizationContact(oSource).address.Clone;
  gender := TFhirOrganizationContact(oSource).gender.Clone;
end;

procedure TFhirOrganizationContact.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'purpose') Then
     list.add(Purpose.Link);
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'telecom') Then
     list.addAll(FTelecomList);
  if (child_name = 'address') Then
     list.add(Address.Link);
  if (child_name = 'gender') Then
     list.add(Gender.Link);
end;

procedure TFhirOrganizationContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'purpose', 'CodeableConcept', FPurpose.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'HumanName', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'telecom', 'Contact', FTelecomList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'address', 'Address', FAddress.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'gender', 'CodeableConcept', FGender.Link.Link));{2}
end;

function TFhirOrganizationContact.Link : TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact(inherited Link);
end;

function TFhirOrganizationContact.Clone : TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact(inherited Clone);
end;

{ TFhirOrganizationContact }

Procedure TFhirOrganizationContact.SetPurpose(value : TFhirCodeableConcept);
begin
  FPurpose.free;
  FPurpose := value;
end;

Procedure TFhirOrganizationContact.SetName(value : TFhirHumanName);
begin
  FName.free;
  FName := value;
end;

Procedure TFhirOrganizationContact.SetAddress(value : TFhirAddress);
begin
  FAddress.free;
  FAddress := value;
end;

Procedure TFhirOrganizationContact.SetGender(value : TFhirCodeableConcept);
begin
  FGender.free;
  FGender := value;
end;


{ TFhirOrganizationContactList }
procedure TFhirOrganizationContactList.AddItem(value: TFhirOrganizationContact);
begin
  assert(value.ClassName = 'TFhirOrganizationContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOrganizationContact');
  add(value);
end;


function TFhirOrganizationContactList.Append: TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirOrganizationContactList.ClearItems;
begin
  Clear;
end;

function TFhirOrganizationContactList.Clone: TFhirOrganizationContactList;
begin
  result := TFhirOrganizationContactList(inherited Clone);
end;

function TFhirOrganizationContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOrganizationContactList.GetItemN(index: Integer): TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact(ObjectByIndex[index]);
end;

function TFhirOrganizationContactList.IndexOf(value: TFhirOrganizationContact): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirOrganizationContactList.Insert(index: Integer): TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirOrganizationContactList.InsertItem(index: Integer; value: TFhirOrganizationContact);
begin
  assert(value is TFhirOrganizationContact);
  Inherited Insert(index, value);
end;

function TFhirOrganizationContactList.Item(index: Integer): TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact(ObjectByIndex[index]);
end;

function TFhirOrganizationContactList.Link: TFhirOrganizationContactList;
begin
  result := TFhirOrganizationContactList(inherited Link);
end;

procedure TFhirOrganizationContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOrganizationContactList.SetItemByIndex(index: Integer; value: TFhirOrganizationContact);
begin
  assert(value is TFhirOrganizationContact);
  FhirOrganizationContacts[index] := value;
end;

procedure TFhirOrganizationContactList.SetItemN(index: Integer; value: TFhirOrganizationContact);
begin
  assert(value is TFhirOrganizationContact);
  ObjectByIndex[index] := value;
end;

{ TFhirPatientContact }

constructor TFhirPatientContact.Create;
begin
  inherited;
  FRelationshipList := TFhirCodeableConceptList.Create;
  FTelecomList := TFhirContactList.Create;
end;

destructor TFhirPatientContact.Destroy;
begin
  FRelationshipList.Free;
  FName.free;
  FTelecomList.Free;
  FAddress.free;
  FGender.free;
  FOrganization.free;
  inherited;
end;

procedure TFhirPatientContact.Assign(oSource : TAdvObject);
begin
  inherited;
  FRelationshipList.Assign(TFhirPatientContact(oSource).FRelationshipList);
  name := TFhirPatientContact(oSource).name.Clone;
  FTelecomList.Assign(TFhirPatientContact(oSource).FTelecomList);
  address := TFhirPatientContact(oSource).address.Clone;
  gender := TFhirPatientContact(oSource).gender.Clone;
  organization := TFhirPatientContact(oSource).organization.Clone;
end;

procedure TFhirPatientContact.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'relationship') Then
     list.addAll(FRelationshipList);
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'telecom') Then
     list.addAll(FTelecomList);
  if (child_name = 'address') Then
     list.add(Address.Link);
  if (child_name = 'gender') Then
     list.add(Gender.Link);
  if (child_name = 'organization') Then
     list.add(Organization.Link);
end;

procedure TFhirPatientContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', FRelationshipList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'name', 'HumanName', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'telecom', 'Contact', FTelecomList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'address', 'Address', FAddress.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'gender', 'CodeableConcept', FGender.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organization', 'Resource(Organization)', FOrganization.Link.Link));{2}
end;

function TFhirPatientContact.Link : TFhirPatientContact;
begin
  result := TFhirPatientContact(inherited Link);
end;

function TFhirPatientContact.Clone : TFhirPatientContact;
begin
  result := TFhirPatientContact(inherited Clone);
end;

{ TFhirPatientContact }

Procedure TFhirPatientContact.SetName(value : TFhirHumanName);
begin
  FName.free;
  FName := value;
end;

Procedure TFhirPatientContact.SetAddress(value : TFhirAddress);
begin
  FAddress.free;
  FAddress := value;
end;

Procedure TFhirPatientContact.SetGender(value : TFhirCodeableConcept);
begin
  FGender.free;
  FGender := value;
end;

Procedure TFhirPatientContact.SetOrganization(value : TFhirResourceReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;


{ TFhirPatientContactList }
procedure TFhirPatientContactList.AddItem(value: TFhirPatientContact);
begin
  assert(value.ClassName = 'TFhirPatientContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPatientContact');
  add(value);
end;


function TFhirPatientContactList.Append: TFhirPatientContact;
begin
  result := TFhirPatientContact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirPatientContactList.ClearItems;
begin
  Clear;
end;

function TFhirPatientContactList.Clone: TFhirPatientContactList;
begin
  result := TFhirPatientContactList(inherited Clone);
end;

function TFhirPatientContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPatientContactList.GetItemN(index: Integer): TFhirPatientContact;
begin
  result := TFhirPatientContact(ObjectByIndex[index]);
end;

function TFhirPatientContactList.IndexOf(value: TFhirPatientContact): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirPatientContactList.Insert(index: Integer): TFhirPatientContact;
begin
  result := TFhirPatientContact.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirPatientContactList.InsertItem(index: Integer; value: TFhirPatientContact);
begin
  assert(value is TFhirPatientContact);
  Inherited Insert(index, value);
end;

function TFhirPatientContactList.Item(index: Integer): TFhirPatientContact;
begin
  result := TFhirPatientContact(ObjectByIndex[index]);
end;

function TFhirPatientContactList.Link: TFhirPatientContactList;
begin
  result := TFhirPatientContactList(inherited Link);
end;

procedure TFhirPatientContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPatientContactList.SetItemByIndex(index: Integer; value: TFhirPatientContact);
begin
  assert(value is TFhirPatientContact);
  FhirPatientContacts[index] := value;
end;

procedure TFhirPatientContactList.SetItemN(index: Integer; value: TFhirPatientContact);
begin
  assert(value is TFhirPatientContact);
  ObjectByIndex[index] := value;
end;

{ TFhirPatientAnimal }

constructor TFhirPatientAnimal.Create;
begin
  inherited;
end;

destructor TFhirPatientAnimal.Destroy;
begin
  FSpecies.free;
  FBreed.free;
  FGenderStatus.free;
  inherited;
end;

procedure TFhirPatientAnimal.Assign(oSource : TAdvObject);
begin
  inherited;
  species := TFhirPatientAnimal(oSource).species.Clone;
  breed := TFhirPatientAnimal(oSource).breed.Clone;
  genderStatus := TFhirPatientAnimal(oSource).genderStatus.Clone;
end;

procedure TFhirPatientAnimal.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'species') Then
     list.add(Species.Link);
  if (child_name = 'breed') Then
     list.add(Breed.Link);
  if (child_name = 'genderStatus') Then
     list.add(GenderStatus.Link);
end;

procedure TFhirPatientAnimal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'species', 'CodeableConcept', FSpecies.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'breed', 'CodeableConcept', FBreed.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'genderStatus', 'CodeableConcept', FGenderStatus.Link.Link));{2}
end;

function TFhirPatientAnimal.Link : TFhirPatientAnimal;
begin
  result := TFhirPatientAnimal(inherited Link);
end;

function TFhirPatientAnimal.Clone : TFhirPatientAnimal;
begin
  result := TFhirPatientAnimal(inherited Clone);
end;

{ TFhirPatientAnimal }

Procedure TFhirPatientAnimal.SetSpecies(value : TFhirCodeableConcept);
begin
  FSpecies.free;
  FSpecies := value;
end;

Procedure TFhirPatientAnimal.SetBreed(value : TFhirCodeableConcept);
begin
  FBreed.free;
  FBreed := value;
end;

Procedure TFhirPatientAnimal.SetGenderStatus(value : TFhirCodeableConcept);
begin
  FGenderStatus.free;
  FGenderStatus := value;
end;


{ TFhirPatientAnimalList }
procedure TFhirPatientAnimalList.AddItem(value: TFhirPatientAnimal);
begin
  assert(value.ClassName = 'TFhirPatientAnimal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPatientAnimal');
  add(value);
end;


function TFhirPatientAnimalList.Append: TFhirPatientAnimal;
begin
  result := TFhirPatientAnimal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirPatientAnimalList.ClearItems;
begin
  Clear;
end;

function TFhirPatientAnimalList.Clone: TFhirPatientAnimalList;
begin
  result := TFhirPatientAnimalList(inherited Clone);
end;

function TFhirPatientAnimalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPatientAnimalList.GetItemN(index: Integer): TFhirPatientAnimal;
begin
  result := TFhirPatientAnimal(ObjectByIndex[index]);
end;

function TFhirPatientAnimalList.IndexOf(value: TFhirPatientAnimal): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirPatientAnimalList.Insert(index: Integer): TFhirPatientAnimal;
begin
  result := TFhirPatientAnimal.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirPatientAnimalList.InsertItem(index: Integer; value: TFhirPatientAnimal);
begin
  assert(value is TFhirPatientAnimal);
  Inherited Insert(index, value);
end;

function TFhirPatientAnimalList.Item(index: Integer): TFhirPatientAnimal;
begin
  result := TFhirPatientAnimal(ObjectByIndex[index]);
end;

function TFhirPatientAnimalList.Link: TFhirPatientAnimalList;
begin
  result := TFhirPatientAnimalList(inherited Link);
end;

procedure TFhirPatientAnimalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPatientAnimalList.SetItemByIndex(index: Integer; value: TFhirPatientAnimal);
begin
  assert(value is TFhirPatientAnimal);
  FhirPatientAnimals[index] := value;
end;

procedure TFhirPatientAnimalList.SetItemN(index: Integer; value: TFhirPatientAnimal);
begin
  assert(value is TFhirPatientAnimal);
  ObjectByIndex[index] := value;
end;

{ TFhirPatientLink }

constructor TFhirPatientLink.Create;
begin
  inherited;
end;

destructor TFhirPatientLink.Destroy;
begin
  FOther.free;
  FType_.free;
  inherited;
end;

procedure TFhirPatientLink.Assign(oSource : TAdvObject);
begin
  inherited;
  other := TFhirPatientLink(oSource).other.Clone;
  FType_ := TFhirPatientLink(oSource).FType_.Link;
end;

procedure TFhirPatientLink.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'other') Then
     list.add(Other.Link);
  if (child_name = 'type_') Then
     list.add(FType_.Link);
end;

procedure TFhirPatientLink.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'other', 'Resource(Patient)', FOther.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{1}
end;

function TFhirPatientLink.Link : TFhirPatientLink;
begin
  result := TFhirPatientLink(inherited Link);
end;

function TFhirPatientLink.Clone : TFhirPatientLink;
begin
  result := TFhirPatientLink(inherited Clone);
end;

{ TFhirPatientLink }

Procedure TFhirPatientLink.SetOther(value : TFhirResourceReference{TFhirPatient});
begin
  FOther.free;
  FOther := value;
end;

Procedure TFhirPatientLink.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirPatientLink.GetType_ST : TFhirLinkType;
begin
  if FType_ = nil then
    result := TFhirLinkType(0)
  else
    result := TFhirLinkType(StringArrayIndexOf(CODES_TFhirLinkType, Type_.value));
end;

Procedure TFhirPatientLink.SetType_ST(value : TFhirLinkType);
begin
  if ord(value) = 0 then
    Type_ := nil
  else
    Type_ := TFhirEnum.create(CODES_TFhirLinkType[value]);
end;


{ TFhirPatientLinkList }
procedure TFhirPatientLinkList.AddItem(value: TFhirPatientLink);
begin
  assert(value.ClassName = 'TFhirPatientLink', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPatientLink');
  add(value);
end;


function TFhirPatientLinkList.Append: TFhirPatientLink;
begin
  result := TFhirPatientLink.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirPatientLinkList.ClearItems;
begin
  Clear;
end;

function TFhirPatientLinkList.Clone: TFhirPatientLinkList;
begin
  result := TFhirPatientLinkList(inherited Clone);
end;

function TFhirPatientLinkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPatientLinkList.GetItemN(index: Integer): TFhirPatientLink;
begin
  result := TFhirPatientLink(ObjectByIndex[index]);
end;

function TFhirPatientLinkList.IndexOf(value: TFhirPatientLink): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirPatientLinkList.Insert(index: Integer): TFhirPatientLink;
begin
  result := TFhirPatientLink.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirPatientLinkList.InsertItem(index: Integer; value: TFhirPatientLink);
begin
  assert(value is TFhirPatientLink);
  Inherited Insert(index, value);
end;

function TFhirPatientLinkList.Item(index: Integer): TFhirPatientLink;
begin
  result := TFhirPatientLink(ObjectByIndex[index]);
end;

function TFhirPatientLinkList.Link: TFhirPatientLinkList;
begin
  result := TFhirPatientLinkList(inherited Link);
end;

procedure TFhirPatientLinkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPatientLinkList.SetItemByIndex(index: Integer; value: TFhirPatientLink);
begin
  assert(value is TFhirPatientLink);
  FhirPatientLinks[index] := value;
end;

procedure TFhirPatientLinkList.SetItemN(index: Integer; value: TFhirPatientLink);
begin
  assert(value is TFhirPatientLink);
  ObjectByIndex[index] := value;
end;

{ TFhirPractitionerQualification }

constructor TFhirPractitionerQualification.Create;
begin
  inherited;
end;

destructor TFhirPractitionerQualification.Destroy;
begin
  FCode.free;
  FPeriod.free;
  FIssuer.free;
  inherited;
end;

procedure TFhirPractitionerQualification.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirPractitionerQualification(oSource).code.Clone;
  period := TFhirPractitionerQualification(oSource).period.Clone;
  issuer := TFhirPractitionerQualification(oSource).issuer.Clone;
end;

procedure TFhirPractitionerQualification.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'period') Then
     list.add(Period.Link);
  if (child_name = 'issuer') Then
     list.add(Issuer.Link);
end;

procedure TFhirPractitionerQualification.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', FPeriod.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'issuer', 'Resource(Organization)', FIssuer.Link.Link));{2}
end;

function TFhirPractitionerQualification.Link : TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(inherited Link);
end;

function TFhirPractitionerQualification.Clone : TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(inherited Clone);
end;

{ TFhirPractitionerQualification }

Procedure TFhirPractitionerQualification.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirPractitionerQualification.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirPractitionerQualification.SetIssuer(value : TFhirResourceReference{TFhirOrganization});
begin
  FIssuer.free;
  FIssuer := value;
end;


{ TFhirPractitionerQualificationList }
procedure TFhirPractitionerQualificationList.AddItem(value: TFhirPractitionerQualification);
begin
  assert(value.ClassName = 'TFhirPractitionerQualification', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPractitionerQualification');
  add(value);
end;


function TFhirPractitionerQualificationList.Append: TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirPractitionerQualificationList.ClearItems;
begin
  Clear;
end;

function TFhirPractitionerQualificationList.Clone: TFhirPractitionerQualificationList;
begin
  result := TFhirPractitionerQualificationList(inherited Clone);
end;

function TFhirPractitionerQualificationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPractitionerQualificationList.GetItemN(index: Integer): TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(ObjectByIndex[index]);
end;

function TFhirPractitionerQualificationList.IndexOf(value: TFhirPractitionerQualification): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirPractitionerQualificationList.Insert(index: Integer): TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirPractitionerQualificationList.InsertItem(index: Integer; value: TFhirPractitionerQualification);
begin
  assert(value is TFhirPractitionerQualification);
  Inherited Insert(index, value);
end;

function TFhirPractitionerQualificationList.Item(index: Integer): TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(ObjectByIndex[index]);
end;

function TFhirPractitionerQualificationList.Link: TFhirPractitionerQualificationList;
begin
  result := TFhirPractitionerQualificationList(inherited Link);
end;

procedure TFhirPractitionerQualificationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPractitionerQualificationList.SetItemByIndex(index: Integer; value: TFhirPractitionerQualification);
begin
  assert(value is TFhirPractitionerQualification);
  FhirPractitionerQualifications[index] := value;
end;

procedure TFhirPractitionerQualificationList.SetItemN(index: Integer; value: TFhirPractitionerQualification);
begin
  assert(value is TFhirPractitionerQualification);
  ObjectByIndex[index] := value;
end;

{ TFhirProcedurePerformer }

constructor TFhirProcedurePerformer.Create;
begin
  inherited;
end;

destructor TFhirProcedurePerformer.Destroy;
begin
  FPerson.free;
  FRole.free;
  inherited;
end;

procedure TFhirProcedurePerformer.Assign(oSource : TAdvObject);
begin
  inherited;
  person := TFhirProcedurePerformer(oSource).person.Clone;
  role := TFhirProcedurePerformer(oSource).role.Clone;
end;

procedure TFhirProcedurePerformer.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'person') Then
     list.add(Person.Link);
  if (child_name = 'role') Then
     list.add(Role.Link);
end;

procedure TFhirProcedurePerformer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'person', 'Resource(Practitioner)', FPerson.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', FRole.Link.Link));{2}
end;

function TFhirProcedurePerformer.Link : TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(inherited Link);
end;

function TFhirProcedurePerformer.Clone : TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(inherited Clone);
end;

{ TFhirProcedurePerformer }

Procedure TFhirProcedurePerformer.SetPerson(value : TFhirResourceReference{TFhirPractitioner});
begin
  FPerson.free;
  FPerson := value;
end;

Procedure TFhirProcedurePerformer.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;


{ TFhirProcedurePerformerList }
procedure TFhirProcedurePerformerList.AddItem(value: TFhirProcedurePerformer);
begin
  assert(value.ClassName = 'TFhirProcedurePerformer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcedurePerformer');
  add(value);
end;


function TFhirProcedurePerformerList.Append: TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProcedurePerformerList.ClearItems;
begin
  Clear;
end;

function TFhirProcedurePerformerList.Clone: TFhirProcedurePerformerList;
begin
  result := TFhirProcedurePerformerList(inherited Clone);
end;

function TFhirProcedurePerformerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcedurePerformerList.GetItemN(index: Integer): TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(ObjectByIndex[index]);
end;

function TFhirProcedurePerformerList.IndexOf(value: TFhirProcedurePerformer): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProcedurePerformerList.Insert(index: Integer): TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProcedurePerformerList.InsertItem(index: Integer; value: TFhirProcedurePerformer);
begin
  assert(value is TFhirProcedurePerformer);
  Inherited Insert(index, value);
end;

function TFhirProcedurePerformerList.Item(index: Integer): TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(ObjectByIndex[index]);
end;

function TFhirProcedurePerformerList.Link: TFhirProcedurePerformerList;
begin
  result := TFhirProcedurePerformerList(inherited Link);
end;

procedure TFhirProcedurePerformerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcedurePerformerList.SetItemByIndex(index: Integer; value: TFhirProcedurePerformer);
begin
  assert(value is TFhirProcedurePerformer);
  FhirProcedurePerformers[index] := value;
end;

procedure TFhirProcedurePerformerList.SetItemN(index: Integer; value: TFhirProcedurePerformer);
begin
  assert(value is TFhirProcedurePerformer);
  ObjectByIndex[index] := value;
end;

{ TFhirProcedureRelatedItem }

constructor TFhirProcedureRelatedItem.Create;
begin
  inherited;
end;

destructor TFhirProcedureRelatedItem.Destroy;
begin
  FType_.free;
  FTarget.free;
  inherited;
end;

procedure TFhirProcedureRelatedItem.Assign(oSource : TAdvObject);
begin
  inherited;
  FType_ := TFhirProcedureRelatedItem(oSource).FType_.Link;
  target := TFhirProcedureRelatedItem(oSource).target.Clone;
end;

procedure TFhirProcedureRelatedItem.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.add(FType_.Link);
  if (child_name = 'target') Then
     list.add(Target.Link);
end;

procedure TFhirProcedureRelatedItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'target', 'Resource(AdverseReaction|AllergyIntolerance|CarePlan|Condition|DeviceObservationReport|DiagnosticReport|FamilyHistory|ImagingStudy|Immunization|ImmunizationRecommendation|MedicationAdministration|MedicationDispense|MedicationPrescription|MedicationSt'+'atement|Observation|Procedure)', FTarget.Link.Link));{2}
end;

function TFhirProcedureRelatedItem.Link : TFhirProcedureRelatedItem;
begin
  result := TFhirProcedureRelatedItem(inherited Link);
end;

function TFhirProcedureRelatedItem.Clone : TFhirProcedureRelatedItem;
begin
  result := TFhirProcedureRelatedItem(inherited Clone);
end;

{ TFhirProcedureRelatedItem }

Procedure TFhirProcedureRelatedItem.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirProcedureRelatedItem.GetType_ST : TFhirProcedureRelationshipType;
begin
  if FType_ = nil then
    result := TFhirProcedureRelationshipType(0)
  else
    result := TFhirProcedureRelationshipType(StringArrayIndexOf(CODES_TFhirProcedureRelationshipType, Type_.value));
end;

Procedure TFhirProcedureRelatedItem.SetType_ST(value : TFhirProcedureRelationshipType);
begin
  if ord(value) = 0 then
    Type_ := nil
  else
    Type_ := TFhirEnum.create(CODES_TFhirProcedureRelationshipType[value]);
end;

Procedure TFhirProcedureRelatedItem.SetTarget(value : TFhirResourceReference{Resource});
begin
  FTarget.free;
  FTarget := value;
end;


{ TFhirProcedureRelatedItemList }
procedure TFhirProcedureRelatedItemList.AddItem(value: TFhirProcedureRelatedItem);
begin
  assert(value.ClassName = 'TFhirProcedureRelatedItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcedureRelatedItem');
  add(value);
end;


function TFhirProcedureRelatedItemList.Append: TFhirProcedureRelatedItem;
begin
  result := TFhirProcedureRelatedItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProcedureRelatedItemList.ClearItems;
begin
  Clear;
end;

function TFhirProcedureRelatedItemList.Clone: TFhirProcedureRelatedItemList;
begin
  result := TFhirProcedureRelatedItemList(inherited Clone);
end;

function TFhirProcedureRelatedItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcedureRelatedItemList.GetItemN(index: Integer): TFhirProcedureRelatedItem;
begin
  result := TFhirProcedureRelatedItem(ObjectByIndex[index]);
end;

function TFhirProcedureRelatedItemList.IndexOf(value: TFhirProcedureRelatedItem): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProcedureRelatedItemList.Insert(index: Integer): TFhirProcedureRelatedItem;
begin
  result := TFhirProcedureRelatedItem.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProcedureRelatedItemList.InsertItem(index: Integer; value: TFhirProcedureRelatedItem);
begin
  assert(value is TFhirProcedureRelatedItem);
  Inherited Insert(index, value);
end;

function TFhirProcedureRelatedItemList.Item(index: Integer): TFhirProcedureRelatedItem;
begin
  result := TFhirProcedureRelatedItem(ObjectByIndex[index]);
end;

function TFhirProcedureRelatedItemList.Link: TFhirProcedureRelatedItemList;
begin
  result := TFhirProcedureRelatedItemList(inherited Link);
end;

procedure TFhirProcedureRelatedItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcedureRelatedItemList.SetItemByIndex(index: Integer; value: TFhirProcedureRelatedItem);
begin
  assert(value is TFhirProcedureRelatedItem);
  FhirProcedureRelatedItems[index] := value;
end;

procedure TFhirProcedureRelatedItemList.SetItemN(index: Integer; value: TFhirProcedureRelatedItem);
begin
  assert(value is TFhirProcedureRelatedItem);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileMapping }

constructor TFhirProfileMapping.Create;
begin
  inherited;
end;

destructor TFhirProfileMapping.Destroy;
begin
  FIdentity.free;
  FUri.free;
  FName.free;
  FComments.free;
  inherited;
end;

procedure TFhirProfileMapping.Assign(oSource : TAdvObject);
begin
  inherited;
  identity := TFhirProfileMapping(oSource).identity.Clone;
  uri := TFhirProfileMapping(oSource).uri.Clone;
  name := TFhirProfileMapping(oSource).name.Clone;
  comments := TFhirProfileMapping(oSource).comments.Clone;
end;

procedure TFhirProfileMapping.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identity') Then
     list.add(Identity.Link);
  if (child_name = 'uri') Then
     list.add(Uri.Link);
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'comments') Then
     list.add(Comments.Link);
end;

procedure TFhirProfileMapping.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identity', 'id', FIdentity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'uri', 'uri', FUri.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comments', 'string', FComments.Link.Link));{2}
end;

function TFhirProfileMapping.Link : TFhirProfileMapping;
begin
  result := TFhirProfileMapping(inherited Link);
end;

function TFhirProfileMapping.Clone : TFhirProfileMapping;
begin
  result := TFhirProfileMapping(inherited Clone);
end;

{ TFhirProfileMapping }

Procedure TFhirProfileMapping.SetIdentity(value : TFhirId);
begin
  FIdentity.free;
  FIdentity := value;
end;

Function TFhirProfileMapping.GetIdentityST : String;
begin
  if FIdentity = nil then
    result := ''
  else
    result := Identity.value;
end;

Procedure TFhirProfileMapping.SetIdentityST(value : String);
begin
  if value <> '' then
  begin
    if FIdentity = nil then
      FIdentity := TFhirId.create;
    FIdentity.value := value
  end
  else if FIdentity <> nil then
    FIdentity.value := '';
end;

Procedure TFhirProfileMapping.SetUri(value : TFhirUri);
begin
  FUri.free;
  FUri := value;
end;

Function TFhirProfileMapping.GetUriST : String;
begin
  if FUri = nil then
    result := ''
  else
    result := Uri.value;
end;

Procedure TFhirProfileMapping.SetUriST(value : String);
begin
  if value <> '' then
  begin
    if FUri = nil then
      FUri := TFhirUri.create;
    FUri.value := value
  end
  else if FUri <> nil then
    FUri.value := '';
end;

Procedure TFhirProfileMapping.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirProfileMapping.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirProfileMapping.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirProfileMapping.SetComments(value : TFhirString);
begin
  FComments.free;
  FComments := value;
end;

Function TFhirProfileMapping.GetCommentsST : String;
begin
  if FComments = nil then
    result := ''
  else
    result := Comments.value;
end;

Procedure TFhirProfileMapping.SetCommentsST(value : String);
begin
  if value <> '' then
  begin
    if FComments = nil then
      FComments := TFhirString.create;
    FComments.value := value
  end
  else if FComments <> nil then
    FComments.value := '';
end;


{ TFhirProfileMappingList }
procedure TFhirProfileMappingList.AddItem(value: TFhirProfileMapping);
begin
  assert(value.ClassName = 'TFhirProfileMapping', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileMapping');
  add(value);
end;


function TFhirProfileMappingList.Append: TFhirProfileMapping;
begin
  result := TFhirProfileMapping.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileMappingList.ClearItems;
begin
  Clear;
end;

function TFhirProfileMappingList.Clone: TFhirProfileMappingList;
begin
  result := TFhirProfileMappingList(inherited Clone);
end;

function TFhirProfileMappingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileMappingList.GetItemN(index: Integer): TFhirProfileMapping;
begin
  result := TFhirProfileMapping(ObjectByIndex[index]);
end;

function TFhirProfileMappingList.IndexOf(value: TFhirProfileMapping): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileMappingList.Insert(index: Integer): TFhirProfileMapping;
begin
  result := TFhirProfileMapping.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileMappingList.InsertItem(index: Integer; value: TFhirProfileMapping);
begin
  assert(value is TFhirProfileMapping);
  Inherited Insert(index, value);
end;

function TFhirProfileMappingList.Item(index: Integer): TFhirProfileMapping;
begin
  result := TFhirProfileMapping(ObjectByIndex[index]);
end;

function TFhirProfileMappingList.Link: TFhirProfileMappingList;
begin
  result := TFhirProfileMappingList(inherited Link);
end;

procedure TFhirProfileMappingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileMappingList.SetItemByIndex(index: Integer; value: TFhirProfileMapping);
begin
  assert(value is TFhirProfileMapping);
  FhirProfileMappings[index] := value;
end;

procedure TFhirProfileMappingList.SetItemN(index: Integer; value: TFhirProfileMapping);
begin
  assert(value is TFhirProfileMapping);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileStructure }

constructor TFhirProfileStructure.Create;
begin
  inherited;
  FElementList := TFhirProfileStructureElementList.Create;
  FSearchParamList := TFhirProfileStructureSearchParamList.Create;
end;

destructor TFhirProfileStructure.Destroy;
begin
  FType_.free;
  FName.free;
  FPublish.free;
  FPurpose.free;
  FElementList.Free;
  FSearchParamList.Free;
  inherited;
end;

procedure TFhirProfileStructure.Assign(oSource : TAdvObject);
begin
  inherited;
  type_ := TFhirProfileStructure(oSource).type_.Clone;
  name := TFhirProfileStructure(oSource).name.Clone;
  publish := TFhirProfileStructure(oSource).publish.Clone;
  purpose := TFhirProfileStructure(oSource).purpose.Clone;
  FElementList.Assign(TFhirProfileStructure(oSource).FElementList);
  FSearchParamList.Assign(TFhirProfileStructure(oSource).FSearchParamList);
end;

procedure TFhirProfileStructure.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'publish') Then
     list.add(Publish.Link);
  if (child_name = 'purpose') Then
     list.add(Purpose.Link);
  if (child_name = 'element') Then
     list.addAll(FElementList);
  if (child_name = 'searchParam') Then
     list.addAll(FSearchParamList);
end;

procedure TFhirProfileStructure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'publish', 'boolean', FPublish.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'purpose', 'string', FPurpose.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'element', '', FElementList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'searchParam', '', FSearchParamList.Link)){3};
end;

function TFhirProfileStructure.Link : TFhirProfileStructure;
begin
  result := TFhirProfileStructure(inherited Link);
end;

function TFhirProfileStructure.Clone : TFhirProfileStructure;
begin
  result := TFhirProfileStructure(inherited Clone);
end;

{ TFhirProfileStructure }

Procedure TFhirProfileStructure.SetType_(value : TFhirCode);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirProfileStructure.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := Type_.value;
end;

Procedure TFhirProfileStructure.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirCode.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirProfileStructure.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirProfileStructure.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirProfileStructure.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirProfileStructure.SetPublish(value : TFhirBoolean);
begin
  FPublish.free;
  FPublish := value;
end;

Function TFhirProfileStructure.GetPublishST : Boolean;
begin
  if FPublish = nil then
    result := false
  else
    result := Publish.value;
end;

Procedure TFhirProfileStructure.SetPublishST(value : Boolean);
begin
  if FPublish = nil then
    FPublish := TFhirBoolean.create;
  FPublish.value := value
end;

Procedure TFhirProfileStructure.SetPurpose(value : TFhirString);
begin
  FPurpose.free;
  FPurpose := value;
end;

Function TFhirProfileStructure.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := Purpose.value;
end;

Procedure TFhirProfileStructure.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirString.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;


{ TFhirProfileStructureList }
procedure TFhirProfileStructureList.AddItem(value: TFhirProfileStructure);
begin
  assert(value.ClassName = 'TFhirProfileStructure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileStructure');
  add(value);
end;


function TFhirProfileStructureList.Append: TFhirProfileStructure;
begin
  result := TFhirProfileStructure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureList.ClearItems;
begin
  Clear;
end;

function TFhirProfileStructureList.Clone: TFhirProfileStructureList;
begin
  result := TFhirProfileStructureList(inherited Clone);
end;

function TFhirProfileStructureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileStructureList.GetItemN(index: Integer): TFhirProfileStructure;
begin
  result := TFhirProfileStructure(ObjectByIndex[index]);
end;

function TFhirProfileStructureList.IndexOf(value: TFhirProfileStructure): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileStructureList.Insert(index: Integer): TFhirProfileStructure;
begin
  result := TFhirProfileStructure.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureList.InsertItem(index: Integer; value: TFhirProfileStructure);
begin
  assert(value is TFhirProfileStructure);
  Inherited Insert(index, value);
end;

function TFhirProfileStructureList.Item(index: Integer): TFhirProfileStructure;
begin
  result := TFhirProfileStructure(ObjectByIndex[index]);
end;

function TFhirProfileStructureList.Link: TFhirProfileStructureList;
begin
  result := TFhirProfileStructureList(inherited Link);
end;

procedure TFhirProfileStructureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileStructureList.SetItemByIndex(index: Integer; value: TFhirProfileStructure);
begin
  assert(value is TFhirProfileStructure);
  FhirProfileStructures[index] := value;
end;

procedure TFhirProfileStructureList.SetItemN(index: Integer; value: TFhirProfileStructure);
begin
  assert(value is TFhirProfileStructure);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileStructureElement }

constructor TFhirProfileStructureElement.Create;
begin
  inherited;
  FRepresentation := TFHIREnumList.Create;
end;

destructor TFhirProfileStructureElement.Destroy;
begin
  FPath.free;
  FRepresentation.Free;
  FName.free;
  FSlicing.free;
  FDefinition.free;
  inherited;
end;

procedure TFhirProfileStructureElement.Assign(oSource : TAdvObject);
begin
  inherited;
  path := TFhirProfileStructureElement(oSource).path.Clone;
  FRepresentation.Assign(TFhirProfileStructureElement(oSource).FRepresentation);
  name := TFhirProfileStructureElement(oSource).name.Clone;
  slicing := TFhirProfileStructureElement(oSource).slicing.Clone;
  definition := TFhirProfileStructureElement(oSource).definition.Clone;
end;

procedure TFhirProfileStructureElement.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'path') Then
     list.add(Path.Link);
  if (child_name = 'representation') Then
     list.addAll(FRepresentation);
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'slicing') Then
     list.add(Slicing.Link);
  if (child_name = 'definition') Then
     list.add(Definition.Link);
end;

procedure TFhirProfileStructureElement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'path', 'string', FPath.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'representation', 'code', FRepresentation.Link)){3};
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'slicing', '', FSlicing.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'definition', '', FDefinition.Link.Link));{2}
end;

function TFhirProfileStructureElement.Link : TFhirProfileStructureElement;
begin
  result := TFhirProfileStructureElement(inherited Link);
end;

function TFhirProfileStructureElement.Clone : TFhirProfileStructureElement;
begin
  result := TFhirProfileStructureElement(inherited Clone);
end;

{ TFhirProfileStructureElement }

Procedure TFhirProfileStructureElement.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

Function TFhirProfileStructureElement.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := Path.value;
end;

Procedure TFhirProfileStructureElement.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

Function TFhirProfileStructureElement.GetRepresentationST : TFhirPropertyRepresentationList;
  var i : integer;
begin
  result := [];
  for i := 0 to representation.count - 1 do
    result := result + [TFhirPropertyRepresentation(StringArrayIndexOf(CODES_TFhirPropertyRepresentation, representation[i].value))];
end;

Procedure TFhirProfileStructureElement.SetRepresentationST(value : TFhirPropertyRepresentationList);
var a : TFhirPropertyRepresentation;
begin
  representation.clear;
  for a := low(TFhirPropertyRepresentation) to high(TFhirPropertyRepresentation) do
    if a in value then
      representation.add(TFhirEnum.create(CODES_TFhirPropertyRepresentation[a]));
end;

Procedure TFhirProfileStructureElement.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirProfileStructureElement.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirProfileStructureElement.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirProfileStructureElement.SetSlicing(value : TFhirProfileStructureElementSlicing);
begin
  FSlicing.free;
  FSlicing := value;
end;

Procedure TFhirProfileStructureElement.SetDefinition(value : TFhirProfileStructureElementDefinition);
begin
  FDefinition.free;
  FDefinition := value;
end;


{ TFhirProfileStructureElementList }
procedure TFhirProfileStructureElementList.AddItem(value: TFhirProfileStructureElement);
begin
  assert(value.ClassName = 'TFhirProfileStructureElement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileStructureElement');
  add(value);
end;


function TFhirProfileStructureElementList.Append: TFhirProfileStructureElement;
begin
  result := TFhirProfileStructureElement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementList.ClearItems;
begin
  Clear;
end;

function TFhirProfileStructureElementList.Clone: TFhirProfileStructureElementList;
begin
  result := TFhirProfileStructureElementList(inherited Clone);
end;

function TFhirProfileStructureElementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileStructureElementList.GetItemN(index: Integer): TFhirProfileStructureElement;
begin
  result := TFhirProfileStructureElement(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementList.IndexOf(value: TFhirProfileStructureElement): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileStructureElementList.Insert(index: Integer): TFhirProfileStructureElement;
begin
  result := TFhirProfileStructureElement.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementList.InsertItem(index: Integer; value: TFhirProfileStructureElement);
begin
  assert(value is TFhirProfileStructureElement);
  Inherited Insert(index, value);
end;

function TFhirProfileStructureElementList.Item(index: Integer): TFhirProfileStructureElement;
begin
  result := TFhirProfileStructureElement(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementList.Link: TFhirProfileStructureElementList;
begin
  result := TFhirProfileStructureElementList(inherited Link);
end;

procedure TFhirProfileStructureElementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileStructureElementList.SetItemByIndex(index: Integer; value: TFhirProfileStructureElement);
begin
  assert(value is TFhirProfileStructureElement);
  FhirProfileStructureElements[index] := value;
end;

procedure TFhirProfileStructureElementList.SetItemN(index: Integer; value: TFhirProfileStructureElement);
begin
  assert(value is TFhirProfileStructureElement);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileStructureElementSlicing }

constructor TFhirProfileStructureElementSlicing.Create;
begin
  inherited;
end;

destructor TFhirProfileStructureElementSlicing.Destroy;
begin
  FDiscriminator.free;
  FOrdered.free;
  FRules.free;
  inherited;
end;

procedure TFhirProfileStructureElementSlicing.Assign(oSource : TAdvObject);
begin
  inherited;
  discriminator := TFhirProfileStructureElementSlicing(oSource).discriminator.Clone;
  ordered := TFhirProfileStructureElementSlicing(oSource).ordered.Clone;
  FRules := TFhirProfileStructureElementSlicing(oSource).FRules.Link;
end;

procedure TFhirProfileStructureElementSlicing.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'discriminator') Then
     list.add(Discriminator.Link);
  if (child_name = 'ordered') Then
     list.add(Ordered.Link);
  if (child_name = 'rules') Then
     list.add(FRules.Link);
end;

procedure TFhirProfileStructureElementSlicing.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'discriminator', 'id', FDiscriminator.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ordered', 'boolean', FOrdered.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rules', 'code', FRules.Link));{1}
end;

function TFhirProfileStructureElementSlicing.Link : TFhirProfileStructureElementSlicing;
begin
  result := TFhirProfileStructureElementSlicing(inherited Link);
end;

function TFhirProfileStructureElementSlicing.Clone : TFhirProfileStructureElementSlicing;
begin
  result := TFhirProfileStructureElementSlicing(inherited Clone);
end;

{ TFhirProfileStructureElementSlicing }

Procedure TFhirProfileStructureElementSlicing.SetDiscriminator(value : TFhirId);
begin
  FDiscriminator.free;
  FDiscriminator := value;
end;

Function TFhirProfileStructureElementSlicing.GetDiscriminatorST : String;
begin
  if FDiscriminator = nil then
    result := ''
  else
    result := Discriminator.value;
end;

Procedure TFhirProfileStructureElementSlicing.SetDiscriminatorST(value : String);
begin
  if value <> '' then
  begin
    if FDiscriminator = nil then
      FDiscriminator := TFhirId.create;
    FDiscriminator.value := value
  end
  else if FDiscriminator <> nil then
    FDiscriminator.value := '';
end;

Procedure TFhirProfileStructureElementSlicing.SetOrdered(value : TFhirBoolean);
begin
  FOrdered.free;
  FOrdered := value;
end;

Function TFhirProfileStructureElementSlicing.GetOrderedST : Boolean;
begin
  if FOrdered = nil then
    result := false
  else
    result := Ordered.value;
end;

Procedure TFhirProfileStructureElementSlicing.SetOrderedST(value : Boolean);
begin
  if FOrdered = nil then
    FOrdered := TFhirBoolean.create;
  FOrdered.value := value
end;

Procedure TFhirProfileStructureElementSlicing.SetRules(value : TFhirEnum);
begin
  FRules.free;
  FRules := value;
end;

Function TFhirProfileStructureElementSlicing.GetRulesST : TFhirResourceSlicingRules;
begin
  if FRules = nil then
    result := TFhirResourceSlicingRules(0)
  else
    result := TFhirResourceSlicingRules(StringArrayIndexOf(CODES_TFhirResourceSlicingRules, Rules.value));
end;

Procedure TFhirProfileStructureElementSlicing.SetRulesST(value : TFhirResourceSlicingRules);
begin
  if ord(value) = 0 then
    Rules := nil
  else
    Rules := TFhirEnum.create(CODES_TFhirResourceSlicingRules[value]);
end;


{ TFhirProfileStructureElementSlicingList }
procedure TFhirProfileStructureElementSlicingList.AddItem(value: TFhirProfileStructureElementSlicing);
begin
  assert(value.ClassName = 'TFhirProfileStructureElementSlicing', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileStructureElementSlicing');
  add(value);
end;


function TFhirProfileStructureElementSlicingList.Append: TFhirProfileStructureElementSlicing;
begin
  result := TFhirProfileStructureElementSlicing.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementSlicingList.ClearItems;
begin
  Clear;
end;

function TFhirProfileStructureElementSlicingList.Clone: TFhirProfileStructureElementSlicingList;
begin
  result := TFhirProfileStructureElementSlicingList(inherited Clone);
end;

function TFhirProfileStructureElementSlicingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileStructureElementSlicingList.GetItemN(index: Integer): TFhirProfileStructureElementSlicing;
begin
  result := TFhirProfileStructureElementSlicing(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementSlicingList.IndexOf(value: TFhirProfileStructureElementSlicing): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileStructureElementSlicingList.Insert(index: Integer): TFhirProfileStructureElementSlicing;
begin
  result := TFhirProfileStructureElementSlicing.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementSlicingList.InsertItem(index: Integer; value: TFhirProfileStructureElementSlicing);
begin
  assert(value is TFhirProfileStructureElementSlicing);
  Inherited Insert(index, value);
end;

function TFhirProfileStructureElementSlicingList.Item(index: Integer): TFhirProfileStructureElementSlicing;
begin
  result := TFhirProfileStructureElementSlicing(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementSlicingList.Link: TFhirProfileStructureElementSlicingList;
begin
  result := TFhirProfileStructureElementSlicingList(inherited Link);
end;

procedure TFhirProfileStructureElementSlicingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileStructureElementSlicingList.SetItemByIndex(index: Integer; value: TFhirProfileStructureElementSlicing);
begin
  assert(value is TFhirProfileStructureElementSlicing);
  FhirProfileStructureElementSlicings[index] := value;
end;

procedure TFhirProfileStructureElementSlicingList.SetItemN(index: Integer; value: TFhirProfileStructureElementSlicing);
begin
  assert(value is TFhirProfileStructureElementSlicing);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileStructureElementDefinition }

constructor TFhirProfileStructureElementDefinition.Create;
begin
  inherited;
  FSynonymList := TFhirStringList.Create;
  FType_List := TFhirProfileStructureElementDefinitionTypeList.Create;
  FConditionList := TFhirIdList.Create;
  FConstraintList := TFhirProfileStructureElementDefinitionConstraintList.Create;
  FMappingList := TFhirProfileStructureElementDefinitionMappingList.Create;
end;

destructor TFhirProfileStructureElementDefinition.Destroy;
begin
  FShort.free;
  FFormal.free;
  FComments.free;
  FRequirements.free;
  FSynonymList.Free;
  FMin.free;
  FMax.free;
  FType_List.Free;
  FNameReference.free;
  FValue.free;
  FExample.free;
  FMaxLength.free;
  FConditionList.Free;
  FConstraintList.Free;
  FMustSupport.free;
  FIsModifier.free;
  FBinding.free;
  FMappingList.Free;
  inherited;
end;

procedure TFhirProfileStructureElementDefinition.Assign(oSource : TAdvObject);
begin
  inherited;
  short := TFhirProfileStructureElementDefinition(oSource).short.Clone;
  formal := TFhirProfileStructureElementDefinition(oSource).formal.Clone;
  comments := TFhirProfileStructureElementDefinition(oSource).comments.Clone;
  requirements := TFhirProfileStructureElementDefinition(oSource).requirements.Clone;
  FSynonymList.Assign(TFhirProfileStructureElementDefinition(oSource).FSynonymList);
  min := TFhirProfileStructureElementDefinition(oSource).min.Clone;
  max := TFhirProfileStructureElementDefinition(oSource).max.Clone;
  FType_List.Assign(TFhirProfileStructureElementDefinition(oSource).FType_List);
  nameReference := TFhirProfileStructureElementDefinition(oSource).nameReference.Clone;
  value := TFhirProfileStructureElementDefinition(oSource).value.Clone;
  example := TFhirProfileStructureElementDefinition(oSource).example.Clone;
  maxLength := TFhirProfileStructureElementDefinition(oSource).maxLength.Clone;
  FConditionList.Assign(TFhirProfileStructureElementDefinition(oSource).FConditionList);
  FConstraintList.Assign(TFhirProfileStructureElementDefinition(oSource).FConstraintList);
  mustSupport := TFhirProfileStructureElementDefinition(oSource).mustSupport.Clone;
  isModifier := TFhirProfileStructureElementDefinition(oSource).isModifier.Clone;
  binding := TFhirProfileStructureElementDefinition(oSource).binding.Clone;
  FMappingList.Assign(TFhirProfileStructureElementDefinition(oSource).FMappingList);
end;

procedure TFhirProfileStructureElementDefinition.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'short') Then
     list.add(Short.Link);
  if (child_name = 'formal') Then
     list.add(Formal.Link);
  if (child_name = 'comments') Then
     list.add(Comments.Link);
  if (child_name = 'requirements') Then
     list.add(Requirements.Link);
  if (child_name = 'synonym') Then
     list.addAll(FSynonymList);
  if (child_name = 'min') Then
     list.add(Min.Link);
  if (child_name = 'max') Then
     list.add(Max.Link);
  if (child_name = 'type_') Then
     list.addAll(FType_List);
  if (child_name = 'nameReference') Then
     list.add(NameReference.Link);
  if (child_name = 'value') Then
     list.add(Value.Link);
  if (child_name = 'example') Then
     list.add(Example.Link);
  if (child_name = 'maxLength') Then
     list.add(MaxLength.Link);
  if (child_name = 'condition') Then
     list.addAll(FConditionList);
  if (child_name = 'constraint') Then
     list.addAll(FConstraintList);
  if (child_name = 'mustSupport') Then
     list.add(MustSupport.Link);
  if (child_name = 'isModifier') Then
     list.add(IsModifier.Link);
  if (child_name = 'binding') Then
     list.add(Binding.Link);
  if (child_name = 'mapping') Then
     list.addAll(FMappingList);
end;

procedure TFhirProfileStructureElementDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'short', 'string', FShort.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'formal', 'string', FFormal.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comments', 'string', FComments.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requirements', 'string', FRequirements.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'synonym', 'string', FSynonymList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'min', 'integer', FMin.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'max', 'string', FMax.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', '', FType_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'nameReference', 'string', FNameReference.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', '*', FValue.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'example[x]', '*', FExample.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxLength', 'integer', FMaxLength.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'condition', 'id', FConditionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'constraint', '', FConstraintList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'mustSupport', 'boolean', FMustSupport.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'isModifier', 'boolean', FIsModifier.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'binding', '', FBinding.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'mapping', '', FMappingList.Link)){3};
end;

function TFhirProfileStructureElementDefinition.Link : TFhirProfileStructureElementDefinition;
begin
  result := TFhirProfileStructureElementDefinition(inherited Link);
end;

function TFhirProfileStructureElementDefinition.Clone : TFhirProfileStructureElementDefinition;
begin
  result := TFhirProfileStructureElementDefinition(inherited Clone);
end;

{ TFhirProfileStructureElementDefinition }

Procedure TFhirProfileStructureElementDefinition.SetShort(value : TFhirString);
begin
  FShort.free;
  FShort := value;
end;

Function TFhirProfileStructureElementDefinition.GetShortST : String;
begin
  if FShort = nil then
    result := ''
  else
    result := Short.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetShortST(value : String);
begin
  if value <> '' then
  begin
    if FShort = nil then
      FShort := TFhirString.create;
    FShort.value := value
  end
  else if FShort <> nil then
    FShort.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetFormal(value : TFhirString);
begin
  FFormal.free;
  FFormal := value;
end;

Function TFhirProfileStructureElementDefinition.GetFormalST : String;
begin
  if FFormal = nil then
    result := ''
  else
    result := Formal.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetFormalST(value : String);
begin
  if value <> '' then
  begin
    if FFormal = nil then
      FFormal := TFhirString.create;
    FFormal.value := value
  end
  else if FFormal <> nil then
    FFormal.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetComments(value : TFhirString);
begin
  FComments.free;
  FComments := value;
end;

Function TFhirProfileStructureElementDefinition.GetCommentsST : String;
begin
  if FComments = nil then
    result := ''
  else
    result := Comments.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetCommentsST(value : String);
begin
  if value <> '' then
  begin
    if FComments = nil then
      FComments := TFhirString.create;
    FComments.value := value
  end
  else if FComments <> nil then
    FComments.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetRequirements(value : TFhirString);
begin
  FRequirements.free;
  FRequirements := value;
end;

Function TFhirProfileStructureElementDefinition.GetRequirementsST : String;
begin
  if FRequirements = nil then
    result := ''
  else
    result := Requirements.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetRequirementsST(value : String);
begin
  if value <> '' then
  begin
    if FRequirements = nil then
      FRequirements := TFhirString.create;
    FRequirements.value := value
  end
  else if FRequirements <> nil then
    FRequirements.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetMin(value : TFhirInteger);
begin
  FMin.free;
  FMin := value;
end;

Function TFhirProfileStructureElementDefinition.GetMinST : String;
begin
  if FMin = nil then
    result := ''
  else
    result := Min.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetMinST(value : String);
begin
  if value <> '' then
  begin
    if FMin = nil then
      FMin := TFhirInteger.create;
    FMin.value := value
  end
  else if FMin <> nil then
    FMin.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetMax(value : TFhirString);
begin
  FMax.free;
  FMax := value;
end;

Function TFhirProfileStructureElementDefinition.GetMaxST : String;
begin
  if FMax = nil then
    result := ''
  else
    result := Max.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetMaxST(value : String);
begin
  if value <> '' then
  begin
    if FMax = nil then
      FMax := TFhirString.create;
    FMax.value := value
  end
  else if FMax <> nil then
    FMax.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetNameReference(value : TFhirString);
begin
  FNameReference.free;
  FNameReference := value;
end;

Function TFhirProfileStructureElementDefinition.GetNameReferenceST : String;
begin
  if FNameReference = nil then
    result := ''
  else
    result := NameReference.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetNameReferenceST(value : String);
begin
  if value <> '' then
  begin
    if FNameReference = nil then
      FNameReference := TFhirString.create;
    FNameReference.value := value
  end
  else if FNameReference <> nil then
    FNameReference.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

Procedure TFhirProfileStructureElementDefinition.SetExample(value : TFhirType);
begin
  FExample.free;
  FExample := value;
end;

Procedure TFhirProfileStructureElementDefinition.SetMaxLength(value : TFhirInteger);
begin
  FMaxLength.free;
  FMaxLength := value;
end;

Function TFhirProfileStructureElementDefinition.GetMaxLengthST : String;
begin
  if FMaxLength = nil then
    result := ''
  else
    result := MaxLength.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetMaxLengthST(value : String);
begin
  if value <> '' then
  begin
    if FMaxLength = nil then
      FMaxLength := TFhirInteger.create;
    FMaxLength.value := value
  end
  else if FMaxLength <> nil then
    FMaxLength.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetMustSupport(value : TFhirBoolean);
begin
  FMustSupport.free;
  FMustSupport := value;
end;

Function TFhirProfileStructureElementDefinition.GetMustSupportST : Boolean;
begin
  if FMustSupport = nil then
    result := false
  else
    result := MustSupport.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetMustSupportST(value : Boolean);
begin
  if FMustSupport = nil then
    FMustSupport := TFhirBoolean.create;
  FMustSupport.value := value
end;

Procedure TFhirProfileStructureElementDefinition.SetIsModifier(value : TFhirBoolean);
begin
  FIsModifier.free;
  FIsModifier := value;
end;

Function TFhirProfileStructureElementDefinition.GetIsModifierST : Boolean;
begin
  if FIsModifier = nil then
    result := false
  else
    result := IsModifier.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetIsModifierST(value : Boolean);
begin
  if FIsModifier = nil then
    FIsModifier := TFhirBoolean.create;
  FIsModifier.value := value
end;

Procedure TFhirProfileStructureElementDefinition.SetBinding(value : TFhirProfileStructureElementDefinitionBinding);
begin
  FBinding.free;
  FBinding := value;
end;


{ TFhirProfileStructureElementDefinitionList }
procedure TFhirProfileStructureElementDefinitionList.AddItem(value: TFhirProfileStructureElementDefinition);
begin
  assert(value.ClassName = 'TFhirProfileStructureElementDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileStructureElementDefinition');
  add(value);
end;


function TFhirProfileStructureElementDefinitionList.Append: TFhirProfileStructureElementDefinition;
begin
  result := TFhirProfileStructureElementDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirProfileStructureElementDefinitionList.Clone: TFhirProfileStructureElementDefinitionList;
begin
  result := TFhirProfileStructureElementDefinitionList(inherited Clone);
end;

function TFhirProfileStructureElementDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileStructureElementDefinitionList.GetItemN(index: Integer): TFhirProfileStructureElementDefinition;
begin
  result := TFhirProfileStructureElementDefinition(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionList.IndexOf(value: TFhirProfileStructureElementDefinition): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileStructureElementDefinitionList.Insert(index: Integer): TFhirProfileStructureElementDefinition;
begin
  result := TFhirProfileStructureElementDefinition.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionList.InsertItem(index: Integer; value: TFhirProfileStructureElementDefinition);
begin
  assert(value is TFhirProfileStructureElementDefinition);
  Inherited Insert(index, value);
end;

function TFhirProfileStructureElementDefinitionList.Item(index: Integer): TFhirProfileStructureElementDefinition;
begin
  result := TFhirProfileStructureElementDefinition(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionList.Link: TFhirProfileStructureElementDefinitionList;
begin
  result := TFhirProfileStructureElementDefinitionList(inherited Link);
end;

procedure TFhirProfileStructureElementDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileStructureElementDefinitionList.SetItemByIndex(index: Integer; value: TFhirProfileStructureElementDefinition);
begin
  assert(value is TFhirProfileStructureElementDefinition);
  FhirProfileStructureElementDefinitions[index] := value;
end;

procedure TFhirProfileStructureElementDefinitionList.SetItemN(index: Integer; value: TFhirProfileStructureElementDefinition);
begin
  assert(value is TFhirProfileStructureElementDefinition);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileStructureElementDefinitionType }

constructor TFhirProfileStructureElementDefinitionType.Create;
begin
  inherited;
  FAggregation := TFHIREnumList.Create;
end;

destructor TFhirProfileStructureElementDefinitionType.Destroy;
begin
  FCode.free;
  FProfile.free;
  FAggregation.Free;
  inherited;
end;

procedure TFhirProfileStructureElementDefinitionType.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirProfileStructureElementDefinitionType(oSource).code.Clone;
  profile := TFhirProfileStructureElementDefinitionType(oSource).profile.Clone;
  FAggregation.Assign(TFhirProfileStructureElementDefinitionType(oSource).FAggregation);
end;

procedure TFhirProfileStructureElementDefinitionType.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'profile') Then
     list.add(Profile.Link);
  if (child_name = 'aggregation') Then
     list.addAll(FAggregation);
end;

procedure TFhirProfileStructureElementDefinitionType.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'profile', 'uri', FProfile.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'aggregation', 'code', FAggregation.Link)){3};
end;

function TFhirProfileStructureElementDefinitionType.Link : TFhirProfileStructureElementDefinitionType;
begin
  result := TFhirProfileStructureElementDefinitionType(inherited Link);
end;

function TFhirProfileStructureElementDefinitionType.Clone : TFhirProfileStructureElementDefinitionType;
begin
  result := TFhirProfileStructureElementDefinitionType(inherited Clone);
end;

{ TFhirProfileStructureElementDefinitionType }

Procedure TFhirProfileStructureElementDefinitionType.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirProfileStructureElementDefinitionType.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := Code.value;
end;

Procedure TFhirProfileStructureElementDefinitionType.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirProfileStructureElementDefinitionType.SetProfile(value : TFhirUri);
begin
  FProfile.free;
  FProfile := value;
end;

Function TFhirProfileStructureElementDefinitionType.GetProfileST : String;
begin
  if FProfile = nil then
    result := ''
  else
    result := Profile.value;
end;

Procedure TFhirProfileStructureElementDefinitionType.SetProfileST(value : String);
begin
  if value <> '' then
  begin
    if FProfile = nil then
      FProfile := TFhirUri.create;
    FProfile.value := value
  end
  else if FProfile <> nil then
    FProfile.value := '';
end;

Function TFhirProfileStructureElementDefinitionType.GetAggregationST : TFhirResourceAggregationModeList;
  var i : integer;
begin
  result := [];
  for i := 0 to aggregation.count - 1 do
    result := result + [TFhirResourceAggregationMode(StringArrayIndexOf(CODES_TFhirResourceAggregationMode, aggregation[i].value))];
end;

Procedure TFhirProfileStructureElementDefinitionType.SetAggregationST(value : TFhirResourceAggregationModeList);
var a : TFhirResourceAggregationMode;
begin
  aggregation.clear;
  for a := low(TFhirResourceAggregationMode) to high(TFhirResourceAggregationMode) do
    if a in value then
      aggregation.add(TFhirEnum.create(CODES_TFhirResourceAggregationMode[a]));
end;


{ TFhirProfileStructureElementDefinitionTypeList }
procedure TFhirProfileStructureElementDefinitionTypeList.AddItem(value: TFhirProfileStructureElementDefinitionType);
begin
  assert(value.ClassName = 'TFhirProfileStructureElementDefinitionType', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileStructureElementDefinitionType');
  add(value);
end;


function TFhirProfileStructureElementDefinitionTypeList.Append: TFhirProfileStructureElementDefinitionType;
begin
  result := TFhirProfileStructureElementDefinitionType.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionTypeList.ClearItems;
begin
  Clear;
end;

function TFhirProfileStructureElementDefinitionTypeList.Clone: TFhirProfileStructureElementDefinitionTypeList;
begin
  result := TFhirProfileStructureElementDefinitionTypeList(inherited Clone);
end;

function TFhirProfileStructureElementDefinitionTypeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileStructureElementDefinitionTypeList.GetItemN(index: Integer): TFhirProfileStructureElementDefinitionType;
begin
  result := TFhirProfileStructureElementDefinitionType(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionTypeList.IndexOf(value: TFhirProfileStructureElementDefinitionType): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileStructureElementDefinitionTypeList.Insert(index: Integer): TFhirProfileStructureElementDefinitionType;
begin
  result := TFhirProfileStructureElementDefinitionType.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionTypeList.InsertItem(index: Integer; value: TFhirProfileStructureElementDefinitionType);
begin
  assert(value is TFhirProfileStructureElementDefinitionType);
  Inherited Insert(index, value);
end;

function TFhirProfileStructureElementDefinitionTypeList.Item(index: Integer): TFhirProfileStructureElementDefinitionType;
begin
  result := TFhirProfileStructureElementDefinitionType(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionTypeList.Link: TFhirProfileStructureElementDefinitionTypeList;
begin
  result := TFhirProfileStructureElementDefinitionTypeList(inherited Link);
end;

procedure TFhirProfileStructureElementDefinitionTypeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileStructureElementDefinitionTypeList.SetItemByIndex(index: Integer; value: TFhirProfileStructureElementDefinitionType);
begin
  assert(value is TFhirProfileStructureElementDefinitionType);
  FhirProfileStructureElementDefinitionTypes[index] := value;
end;

procedure TFhirProfileStructureElementDefinitionTypeList.SetItemN(index: Integer; value: TFhirProfileStructureElementDefinitionType);
begin
  assert(value is TFhirProfileStructureElementDefinitionType);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileStructureElementDefinitionConstraint }

constructor TFhirProfileStructureElementDefinitionConstraint.Create;
begin
  inherited;
end;

destructor TFhirProfileStructureElementDefinitionConstraint.Destroy;
begin
  FKey.free;
  FName.free;
  FSeverity.free;
  FHuman.free;
  FXpath.free;
  inherited;
end;

procedure TFhirProfileStructureElementDefinitionConstraint.Assign(oSource : TAdvObject);
begin
  inherited;
  key := TFhirProfileStructureElementDefinitionConstraint(oSource).key.Clone;
  name := TFhirProfileStructureElementDefinitionConstraint(oSource).name.Clone;
  FSeverity := TFhirProfileStructureElementDefinitionConstraint(oSource).FSeverity.Link;
  human := TFhirProfileStructureElementDefinitionConstraint(oSource).human.Clone;
  xpath := TFhirProfileStructureElementDefinitionConstraint(oSource).xpath.Clone;
end;

procedure TFhirProfileStructureElementDefinitionConstraint.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'key') Then
     list.add(Key.Link);
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'severity') Then
     list.add(FSeverity.Link);
  if (child_name = 'human') Then
     list.add(Human.Link);
  if (child_name = 'xpath') Then
     list.add(Xpath.Link);
end;

procedure TFhirProfileStructureElementDefinitionConstraint.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'key', 'id', FKey.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'severity', 'code', FSeverity.Link));{1}
  oList.add(TFHIRProperty.create(self, 'human', 'string', FHuman.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'xpath', 'string', FXpath.Link.Link));{2}
end;

function TFhirProfileStructureElementDefinitionConstraint.Link : TFhirProfileStructureElementDefinitionConstraint;
begin
  result := TFhirProfileStructureElementDefinitionConstraint(inherited Link);
end;

function TFhirProfileStructureElementDefinitionConstraint.Clone : TFhirProfileStructureElementDefinitionConstraint;
begin
  result := TFhirProfileStructureElementDefinitionConstraint(inherited Clone);
end;

{ TFhirProfileStructureElementDefinitionConstraint }

Procedure TFhirProfileStructureElementDefinitionConstraint.SetKey(value : TFhirId);
begin
  FKey.free;
  FKey := value;
end;

Function TFhirProfileStructureElementDefinitionConstraint.GetKeyST : String;
begin
  if FKey = nil then
    result := ''
  else
    result := Key.value;
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetKeyST(value : String);
begin
  if value <> '' then
  begin
    if FKey = nil then
      FKey := TFhirId.create;
    FKey.value := value
  end
  else if FKey <> nil then
    FKey.value := '';
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirProfileStructureElementDefinitionConstraint.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetSeverity(value : TFhirEnum);
begin
  FSeverity.free;
  FSeverity := value;
end;

Function TFhirProfileStructureElementDefinitionConstraint.GetSeverityST : TFhirConstraintSeverity;
begin
  if FSeverity = nil then
    result := TFhirConstraintSeverity(0)
  else
    result := TFhirConstraintSeverity(StringArrayIndexOf(CODES_TFhirConstraintSeverity, Severity.value));
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetSeverityST(value : TFhirConstraintSeverity);
begin
  if ord(value) = 0 then
    Severity := nil
  else
    Severity := TFhirEnum.create(CODES_TFhirConstraintSeverity[value]);
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetHuman(value : TFhirString);
begin
  FHuman.free;
  FHuman := value;
end;

Function TFhirProfileStructureElementDefinitionConstraint.GetHumanST : String;
begin
  if FHuman = nil then
    result := ''
  else
    result := Human.value;
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetHumanST(value : String);
begin
  if value <> '' then
  begin
    if FHuman = nil then
      FHuman := TFhirString.create;
    FHuman.value := value
  end
  else if FHuman <> nil then
    FHuman.value := '';
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetXpath(value : TFhirString);
begin
  FXpath.free;
  FXpath := value;
end;

Function TFhirProfileStructureElementDefinitionConstraint.GetXpathST : String;
begin
  if FXpath = nil then
    result := ''
  else
    result := Xpath.value;
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetXpathST(value : String);
begin
  if value <> '' then
  begin
    if FXpath = nil then
      FXpath := TFhirString.create;
    FXpath.value := value
  end
  else if FXpath <> nil then
    FXpath.value := '';
end;


{ TFhirProfileStructureElementDefinitionConstraintList }
procedure TFhirProfileStructureElementDefinitionConstraintList.AddItem(value: TFhirProfileStructureElementDefinitionConstraint);
begin
  assert(value.ClassName = 'TFhirProfileStructureElementDefinitionConstraint', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileStructureElementDefinitionConstraint');
  add(value);
end;


function TFhirProfileStructureElementDefinitionConstraintList.Append: TFhirProfileStructureElementDefinitionConstraint;
begin
  result := TFhirProfileStructureElementDefinitionConstraint.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionConstraintList.ClearItems;
begin
  Clear;
end;

function TFhirProfileStructureElementDefinitionConstraintList.Clone: TFhirProfileStructureElementDefinitionConstraintList;
begin
  result := TFhirProfileStructureElementDefinitionConstraintList(inherited Clone);
end;

function TFhirProfileStructureElementDefinitionConstraintList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileStructureElementDefinitionConstraintList.GetItemN(index: Integer): TFhirProfileStructureElementDefinitionConstraint;
begin
  result := TFhirProfileStructureElementDefinitionConstraint(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionConstraintList.IndexOf(value: TFhirProfileStructureElementDefinitionConstraint): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileStructureElementDefinitionConstraintList.Insert(index: Integer): TFhirProfileStructureElementDefinitionConstraint;
begin
  result := TFhirProfileStructureElementDefinitionConstraint.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionConstraintList.InsertItem(index: Integer; value: TFhirProfileStructureElementDefinitionConstraint);
begin
  assert(value is TFhirProfileStructureElementDefinitionConstraint);
  Inherited Insert(index, value);
end;

function TFhirProfileStructureElementDefinitionConstraintList.Item(index: Integer): TFhirProfileStructureElementDefinitionConstraint;
begin
  result := TFhirProfileStructureElementDefinitionConstraint(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionConstraintList.Link: TFhirProfileStructureElementDefinitionConstraintList;
begin
  result := TFhirProfileStructureElementDefinitionConstraintList(inherited Link);
end;

procedure TFhirProfileStructureElementDefinitionConstraintList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileStructureElementDefinitionConstraintList.SetItemByIndex(index: Integer; value: TFhirProfileStructureElementDefinitionConstraint);
begin
  assert(value is TFhirProfileStructureElementDefinitionConstraint);
  FhirProfileStructureElementDefinitionConstraints[index] := value;
end;

procedure TFhirProfileStructureElementDefinitionConstraintList.SetItemN(index: Integer; value: TFhirProfileStructureElementDefinitionConstraint);
begin
  assert(value is TFhirProfileStructureElementDefinitionConstraint);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileStructureElementDefinitionBinding }

constructor TFhirProfileStructureElementDefinitionBinding.Create;
begin
  inherited;
end;

destructor TFhirProfileStructureElementDefinitionBinding.Destroy;
begin
  FName.free;
  FIsExtensible.free;
  FConformance.free;
  FDescription.free;
  FReference.free;
  inherited;
end;

procedure TFhirProfileStructureElementDefinitionBinding.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirProfileStructureElementDefinitionBinding(oSource).name.Clone;
  isExtensible := TFhirProfileStructureElementDefinitionBinding(oSource).isExtensible.Clone;
  FConformance := TFhirProfileStructureElementDefinitionBinding(oSource).FConformance.Link;
  description := TFhirProfileStructureElementDefinitionBinding(oSource).description.Clone;
  reference := TFhirProfileStructureElementDefinitionBinding(oSource).reference.Clone;
end;

procedure TFhirProfileStructureElementDefinitionBinding.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'isExtensible') Then
     list.add(IsExtensible.Link);
  if (child_name = 'conformance') Then
     list.add(FConformance.Link);
  if (child_name = 'description') Then
     list.add(Description.Link);
  if (child_name = 'reference') Then
     list.add(Reference.Link);
end;

procedure TFhirProfileStructureElementDefinitionBinding.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'isExtensible', 'boolean', FIsExtensible.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'conformance', 'code', FConformance.Link));{1}
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference[x]', 'uri|Resource(ValueSet)', FReference.Link.Link));{2}
end;

function TFhirProfileStructureElementDefinitionBinding.Link : TFhirProfileStructureElementDefinitionBinding;
begin
  result := TFhirProfileStructureElementDefinitionBinding(inherited Link);
end;

function TFhirProfileStructureElementDefinitionBinding.Clone : TFhirProfileStructureElementDefinitionBinding;
begin
  result := TFhirProfileStructureElementDefinitionBinding(inherited Clone);
end;

{ TFhirProfileStructureElementDefinitionBinding }

Procedure TFhirProfileStructureElementDefinitionBinding.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirProfileStructureElementDefinitionBinding.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirProfileStructureElementDefinitionBinding.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirProfileStructureElementDefinitionBinding.SetIsExtensible(value : TFhirBoolean);
begin
  FIsExtensible.free;
  FIsExtensible := value;
end;

Function TFhirProfileStructureElementDefinitionBinding.GetIsExtensibleST : Boolean;
begin
  if FIsExtensible = nil then
    result := false
  else
    result := IsExtensible.value;
end;

Procedure TFhirProfileStructureElementDefinitionBinding.SetIsExtensibleST(value : Boolean);
begin
  if FIsExtensible = nil then
    FIsExtensible := TFhirBoolean.create;
  FIsExtensible.value := value
end;

Procedure TFhirProfileStructureElementDefinitionBinding.SetConformance(value : TFhirEnum);
begin
  FConformance.free;
  FConformance := value;
end;

Function TFhirProfileStructureElementDefinitionBinding.GetConformanceST : TFhirBindingConformance;
begin
  if FConformance = nil then
    result := TFhirBindingConformance(0)
  else
    result := TFhirBindingConformance(StringArrayIndexOf(CODES_TFhirBindingConformance, Conformance.value));
end;

Procedure TFhirProfileStructureElementDefinitionBinding.SetConformanceST(value : TFhirBindingConformance);
begin
  if ord(value) = 0 then
    Conformance := nil
  else
    Conformance := TFhirEnum.create(CODES_TFhirBindingConformance[value]);
end;

Procedure TFhirProfileStructureElementDefinitionBinding.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirProfileStructureElementDefinitionBinding.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := Description.value;
end;

Procedure TFhirProfileStructureElementDefinitionBinding.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirProfileStructureElementDefinitionBinding.SetReference(value : TFhirType);
begin
  FReference.free;
  FReference := value;
end;


{ TFhirProfileStructureElementDefinitionBindingList }
procedure TFhirProfileStructureElementDefinitionBindingList.AddItem(value: TFhirProfileStructureElementDefinitionBinding);
begin
  assert(value.ClassName = 'TFhirProfileStructureElementDefinitionBinding', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileStructureElementDefinitionBinding');
  add(value);
end;


function TFhirProfileStructureElementDefinitionBindingList.Append: TFhirProfileStructureElementDefinitionBinding;
begin
  result := TFhirProfileStructureElementDefinitionBinding.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionBindingList.ClearItems;
begin
  Clear;
end;

function TFhirProfileStructureElementDefinitionBindingList.Clone: TFhirProfileStructureElementDefinitionBindingList;
begin
  result := TFhirProfileStructureElementDefinitionBindingList(inherited Clone);
end;

function TFhirProfileStructureElementDefinitionBindingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileStructureElementDefinitionBindingList.GetItemN(index: Integer): TFhirProfileStructureElementDefinitionBinding;
begin
  result := TFhirProfileStructureElementDefinitionBinding(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionBindingList.IndexOf(value: TFhirProfileStructureElementDefinitionBinding): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileStructureElementDefinitionBindingList.Insert(index: Integer): TFhirProfileStructureElementDefinitionBinding;
begin
  result := TFhirProfileStructureElementDefinitionBinding.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionBindingList.InsertItem(index: Integer; value: TFhirProfileStructureElementDefinitionBinding);
begin
  assert(value is TFhirProfileStructureElementDefinitionBinding);
  Inherited Insert(index, value);
end;

function TFhirProfileStructureElementDefinitionBindingList.Item(index: Integer): TFhirProfileStructureElementDefinitionBinding;
begin
  result := TFhirProfileStructureElementDefinitionBinding(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionBindingList.Link: TFhirProfileStructureElementDefinitionBindingList;
begin
  result := TFhirProfileStructureElementDefinitionBindingList(inherited Link);
end;

procedure TFhirProfileStructureElementDefinitionBindingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileStructureElementDefinitionBindingList.SetItemByIndex(index: Integer; value: TFhirProfileStructureElementDefinitionBinding);
begin
  assert(value is TFhirProfileStructureElementDefinitionBinding);
  FhirProfileStructureElementDefinitionBindings[index] := value;
end;

procedure TFhirProfileStructureElementDefinitionBindingList.SetItemN(index: Integer; value: TFhirProfileStructureElementDefinitionBinding);
begin
  assert(value is TFhirProfileStructureElementDefinitionBinding);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileStructureElementDefinitionMapping }

constructor TFhirProfileStructureElementDefinitionMapping.Create;
begin
  inherited;
end;

destructor TFhirProfileStructureElementDefinitionMapping.Destroy;
begin
  FIdentity.free;
  FMap.free;
  inherited;
end;

procedure TFhirProfileStructureElementDefinitionMapping.Assign(oSource : TAdvObject);
begin
  inherited;
  identity := TFhirProfileStructureElementDefinitionMapping(oSource).identity.Clone;
  map := TFhirProfileStructureElementDefinitionMapping(oSource).map.Clone;
end;

procedure TFhirProfileStructureElementDefinitionMapping.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identity') Then
     list.add(Identity.Link);
  if (child_name = 'map') Then
     list.add(Map.Link);
end;

procedure TFhirProfileStructureElementDefinitionMapping.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identity', 'id', FIdentity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'map', 'string', FMap.Link.Link));{2}
end;

function TFhirProfileStructureElementDefinitionMapping.Link : TFhirProfileStructureElementDefinitionMapping;
begin
  result := TFhirProfileStructureElementDefinitionMapping(inherited Link);
end;

function TFhirProfileStructureElementDefinitionMapping.Clone : TFhirProfileStructureElementDefinitionMapping;
begin
  result := TFhirProfileStructureElementDefinitionMapping(inherited Clone);
end;

{ TFhirProfileStructureElementDefinitionMapping }

Procedure TFhirProfileStructureElementDefinitionMapping.SetIdentity(value : TFhirId);
begin
  FIdentity.free;
  FIdentity := value;
end;

Function TFhirProfileStructureElementDefinitionMapping.GetIdentityST : String;
begin
  if FIdentity = nil then
    result := ''
  else
    result := Identity.value;
end;

Procedure TFhirProfileStructureElementDefinitionMapping.SetIdentityST(value : String);
begin
  if value <> '' then
  begin
    if FIdentity = nil then
      FIdentity := TFhirId.create;
    FIdentity.value := value
  end
  else if FIdentity <> nil then
    FIdentity.value := '';
end;

Procedure TFhirProfileStructureElementDefinitionMapping.SetMap(value : TFhirString);
begin
  FMap.free;
  FMap := value;
end;

Function TFhirProfileStructureElementDefinitionMapping.GetMapST : String;
begin
  if FMap = nil then
    result := ''
  else
    result := Map.value;
end;

Procedure TFhirProfileStructureElementDefinitionMapping.SetMapST(value : String);
begin
  if value <> '' then
  begin
    if FMap = nil then
      FMap := TFhirString.create;
    FMap.value := value
  end
  else if FMap <> nil then
    FMap.value := '';
end;


{ TFhirProfileStructureElementDefinitionMappingList }
procedure TFhirProfileStructureElementDefinitionMappingList.AddItem(value: TFhirProfileStructureElementDefinitionMapping);
begin
  assert(value.ClassName = 'TFhirProfileStructureElementDefinitionMapping', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileStructureElementDefinitionMapping');
  add(value);
end;


function TFhirProfileStructureElementDefinitionMappingList.Append: TFhirProfileStructureElementDefinitionMapping;
begin
  result := TFhirProfileStructureElementDefinitionMapping.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionMappingList.ClearItems;
begin
  Clear;
end;

function TFhirProfileStructureElementDefinitionMappingList.Clone: TFhirProfileStructureElementDefinitionMappingList;
begin
  result := TFhirProfileStructureElementDefinitionMappingList(inherited Clone);
end;

function TFhirProfileStructureElementDefinitionMappingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileStructureElementDefinitionMappingList.GetItemN(index: Integer): TFhirProfileStructureElementDefinitionMapping;
begin
  result := TFhirProfileStructureElementDefinitionMapping(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionMappingList.IndexOf(value: TFhirProfileStructureElementDefinitionMapping): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileStructureElementDefinitionMappingList.Insert(index: Integer): TFhirProfileStructureElementDefinitionMapping;
begin
  result := TFhirProfileStructureElementDefinitionMapping.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionMappingList.InsertItem(index: Integer; value: TFhirProfileStructureElementDefinitionMapping);
begin
  assert(value is TFhirProfileStructureElementDefinitionMapping);
  Inherited Insert(index, value);
end;

function TFhirProfileStructureElementDefinitionMappingList.Item(index: Integer): TFhirProfileStructureElementDefinitionMapping;
begin
  result := TFhirProfileStructureElementDefinitionMapping(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionMappingList.Link: TFhirProfileStructureElementDefinitionMappingList;
begin
  result := TFhirProfileStructureElementDefinitionMappingList(inherited Link);
end;

procedure TFhirProfileStructureElementDefinitionMappingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileStructureElementDefinitionMappingList.SetItemByIndex(index: Integer; value: TFhirProfileStructureElementDefinitionMapping);
begin
  assert(value is TFhirProfileStructureElementDefinitionMapping);
  FhirProfileStructureElementDefinitionMappings[index] := value;
end;

procedure TFhirProfileStructureElementDefinitionMappingList.SetItemN(index: Integer; value: TFhirProfileStructureElementDefinitionMapping);
begin
  assert(value is TFhirProfileStructureElementDefinitionMapping);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileStructureSearchParam }

constructor TFhirProfileStructureSearchParam.Create;
begin
  inherited;
  FTargetList := TFhirCodeList.Create;
end;

destructor TFhirProfileStructureSearchParam.Destroy;
begin
  FName.free;
  FType_.free;
  FDocumentation.free;
  FXpath.free;
  FTargetList.Free;
  inherited;
end;

procedure TFhirProfileStructureSearchParam.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirProfileStructureSearchParam(oSource).name.Clone;
  FType_ := TFhirProfileStructureSearchParam(oSource).FType_.Link;
  documentation := TFhirProfileStructureSearchParam(oSource).documentation.Clone;
  xpath := TFhirProfileStructureSearchParam(oSource).xpath.Clone;
  FTargetList.Assign(TFhirProfileStructureSearchParam(oSource).FTargetList);
end;

procedure TFhirProfileStructureSearchParam.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'type_') Then
     list.add(FType_.Link);
  if (child_name = 'documentation') Then
     list.add(Documentation.Link);
  if (child_name = 'xpath') Then
     list.add(Xpath.Link);
  if (child_name = 'target') Then
     list.addAll(FTargetList);
end;

procedure TFhirProfileStructureSearchParam.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'xpath', 'string', FXpath.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', 'code', FTargetList.Link)){3};
end;

function TFhirProfileStructureSearchParam.Link : TFhirProfileStructureSearchParam;
begin
  result := TFhirProfileStructureSearchParam(inherited Link);
end;

function TFhirProfileStructureSearchParam.Clone : TFhirProfileStructureSearchParam;
begin
  result := TFhirProfileStructureSearchParam(inherited Clone);
end;

{ TFhirProfileStructureSearchParam }

Procedure TFhirProfileStructureSearchParam.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirProfileStructureSearchParam.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirProfileStructureSearchParam.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirProfileStructureSearchParam.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirProfileStructureSearchParam.GetType_ST : TFhirSearchParamType;
begin
  if FType_ = nil then
    result := TFhirSearchParamType(0)
  else
    result := TFhirSearchParamType(StringArrayIndexOf(CODES_TFhirSearchParamType, Type_.value));
end;

Procedure TFhirProfileStructureSearchParam.SetType_ST(value : TFhirSearchParamType);
begin
  if ord(value) = 0 then
    Type_ := nil
  else
    Type_ := TFhirEnum.create(CODES_TFhirSearchParamType[value]);
end;

Procedure TFhirProfileStructureSearchParam.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirProfileStructureSearchParam.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := Documentation.value;
end;

Procedure TFhirProfileStructureSearchParam.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

Procedure TFhirProfileStructureSearchParam.SetXpath(value : TFhirString);
begin
  FXpath.free;
  FXpath := value;
end;

Function TFhirProfileStructureSearchParam.GetXpathST : String;
begin
  if FXpath = nil then
    result := ''
  else
    result := Xpath.value;
end;

Procedure TFhirProfileStructureSearchParam.SetXpathST(value : String);
begin
  if value <> '' then
  begin
    if FXpath = nil then
      FXpath := TFhirString.create;
    FXpath.value := value
  end
  else if FXpath <> nil then
    FXpath.value := '';
end;


{ TFhirProfileStructureSearchParamList }
procedure TFhirProfileStructureSearchParamList.AddItem(value: TFhirProfileStructureSearchParam);
begin
  assert(value.ClassName = 'TFhirProfileStructureSearchParam', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileStructureSearchParam');
  add(value);
end;


function TFhirProfileStructureSearchParamList.Append: TFhirProfileStructureSearchParam;
begin
  result := TFhirProfileStructureSearchParam.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureSearchParamList.ClearItems;
begin
  Clear;
end;

function TFhirProfileStructureSearchParamList.Clone: TFhirProfileStructureSearchParamList;
begin
  result := TFhirProfileStructureSearchParamList(inherited Clone);
end;

function TFhirProfileStructureSearchParamList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileStructureSearchParamList.GetItemN(index: Integer): TFhirProfileStructureSearchParam;
begin
  result := TFhirProfileStructureSearchParam(ObjectByIndex[index]);
end;

function TFhirProfileStructureSearchParamList.IndexOf(value: TFhirProfileStructureSearchParam): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileStructureSearchParamList.Insert(index: Integer): TFhirProfileStructureSearchParam;
begin
  result := TFhirProfileStructureSearchParam.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureSearchParamList.InsertItem(index: Integer; value: TFhirProfileStructureSearchParam);
begin
  assert(value is TFhirProfileStructureSearchParam);
  Inherited Insert(index, value);
end;

function TFhirProfileStructureSearchParamList.Item(index: Integer): TFhirProfileStructureSearchParam;
begin
  result := TFhirProfileStructureSearchParam(ObjectByIndex[index]);
end;

function TFhirProfileStructureSearchParamList.Link: TFhirProfileStructureSearchParamList;
begin
  result := TFhirProfileStructureSearchParamList(inherited Link);
end;

procedure TFhirProfileStructureSearchParamList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileStructureSearchParamList.SetItemByIndex(index: Integer; value: TFhirProfileStructureSearchParam);
begin
  assert(value is TFhirProfileStructureSearchParam);
  FhirProfileStructureSearchParams[index] := value;
end;

procedure TFhirProfileStructureSearchParamList.SetItemN(index: Integer; value: TFhirProfileStructureSearchParam);
begin
  assert(value is TFhirProfileStructureSearchParam);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileExtensionDefn }

constructor TFhirProfileExtensionDefn.Create;
begin
  inherited;
  FContextList := TFhirStringList.Create;
end;

destructor TFhirProfileExtensionDefn.Destroy;
begin
  FCode.free;
  FDisplay.free;
  FContextType.free;
  FContextList.Free;
  FDefinition.free;
  inherited;
end;

procedure TFhirProfileExtensionDefn.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirProfileExtensionDefn(oSource).code.Clone;
  display := TFhirProfileExtensionDefn(oSource).display.Clone;
  FContextType := TFhirProfileExtensionDefn(oSource).FContextType.Link;
  FContextList.Assign(TFhirProfileExtensionDefn(oSource).FContextList);
  definition := TFhirProfileExtensionDefn(oSource).definition.Clone;
end;

procedure TFhirProfileExtensionDefn.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'display') Then
     list.add(Display.Link);
  if (child_name = 'contextType') Then
     list.add(FContextType.Link);
  if (child_name = 'context') Then
     list.addAll(FContextList);
  if (child_name = 'definition') Then
     list.add(Definition.Link);
end;

procedure TFhirProfileExtensionDefn.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', FDisplay.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contextType', 'code', FContextType.Link));{1}
  oList.add(TFHIRProperty.create(self, 'context', 'string', FContextList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'definition', '@Profile.structure.element.definition', FDefinition.Link.Link));{2}
end;

function TFhirProfileExtensionDefn.Link : TFhirProfileExtensionDefn;
begin
  result := TFhirProfileExtensionDefn(inherited Link);
end;

function TFhirProfileExtensionDefn.Clone : TFhirProfileExtensionDefn;
begin
  result := TFhirProfileExtensionDefn(inherited Clone);
end;

{ TFhirProfileExtensionDefn }

Procedure TFhirProfileExtensionDefn.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirProfileExtensionDefn.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := Code.value;
end;

Procedure TFhirProfileExtensionDefn.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirProfileExtensionDefn.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirProfileExtensionDefn.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := Display.value;
end;

Procedure TFhirProfileExtensionDefn.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

Procedure TFhirProfileExtensionDefn.SetContextType(value : TFhirEnum);
begin
  FContextType.free;
  FContextType := value;
end;

Function TFhirProfileExtensionDefn.GetContextTypeST : TFhirExtensionContext;
begin
  if FContextType = nil then
    result := TFhirExtensionContext(0)
  else
    result := TFhirExtensionContext(StringArrayIndexOf(CODES_TFhirExtensionContext, ContextType.value));
end;

Procedure TFhirProfileExtensionDefn.SetContextTypeST(value : TFhirExtensionContext);
begin
  if ord(value) = 0 then
    ContextType := nil
  else
    ContextType := TFhirEnum.create(CODES_TFhirExtensionContext[value]);
end;

Procedure TFhirProfileExtensionDefn.SetDefinition(value : TFhirProfileStructureElementDefinition);
begin
  FDefinition.free;
  FDefinition := value;
end;


{ TFhirProfileExtensionDefnList }
procedure TFhirProfileExtensionDefnList.AddItem(value: TFhirProfileExtensionDefn);
begin
  assert(value.ClassName = 'TFhirProfileExtensionDefn', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileExtensionDefn');
  add(value);
end;


function TFhirProfileExtensionDefnList.Append: TFhirProfileExtensionDefn;
begin
  result := TFhirProfileExtensionDefn.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileExtensionDefnList.ClearItems;
begin
  Clear;
end;

function TFhirProfileExtensionDefnList.Clone: TFhirProfileExtensionDefnList;
begin
  result := TFhirProfileExtensionDefnList(inherited Clone);
end;

function TFhirProfileExtensionDefnList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileExtensionDefnList.GetItemN(index: Integer): TFhirProfileExtensionDefn;
begin
  result := TFhirProfileExtensionDefn(ObjectByIndex[index]);
end;

function TFhirProfileExtensionDefnList.IndexOf(value: TFhirProfileExtensionDefn): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileExtensionDefnList.Insert(index: Integer): TFhirProfileExtensionDefn;
begin
  result := TFhirProfileExtensionDefn.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileExtensionDefnList.InsertItem(index: Integer; value: TFhirProfileExtensionDefn);
begin
  assert(value is TFhirProfileExtensionDefn);
  Inherited Insert(index, value);
end;

function TFhirProfileExtensionDefnList.Item(index: Integer): TFhirProfileExtensionDefn;
begin
  result := TFhirProfileExtensionDefn(ObjectByIndex[index]);
end;

function TFhirProfileExtensionDefnList.Link: TFhirProfileExtensionDefnList;
begin
  result := TFhirProfileExtensionDefnList(inherited Link);
end;

procedure TFhirProfileExtensionDefnList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileExtensionDefnList.SetItemByIndex(index: Integer; value: TFhirProfileExtensionDefn);
begin
  assert(value is TFhirProfileExtensionDefn);
  FhirProfileExtensionDefns[index] := value;
end;

procedure TFhirProfileExtensionDefnList.SetItemN(index: Integer; value: TFhirProfileExtensionDefn);
begin
  assert(value is TFhirProfileExtensionDefn);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileQuery }

constructor TFhirProfileQuery.Create;
begin
  inherited;
  FParameterList := TFhirProfileStructureSearchParamList.Create;
end;

destructor TFhirProfileQuery.Destroy;
begin
  FName.free;
  FDocumentation.free;
  FParameterList.Free;
  inherited;
end;

procedure TFhirProfileQuery.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirProfileQuery(oSource).name.Clone;
  documentation := TFhirProfileQuery(oSource).documentation.Clone;
  FParameterList.Assign(TFhirProfileQuery(oSource).FParameterList);
end;

procedure TFhirProfileQuery.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'documentation') Then
     list.add(Documentation.Link);
  if (child_name = 'parameter') Then
     list.addAll(FParameterList);
end;

procedure TFhirProfileQuery.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'parameter', '@Profile.structure.searchParam', FParameterList.Link)){3};
end;

function TFhirProfileQuery.Link : TFhirProfileQuery;
begin
  result := TFhirProfileQuery(inherited Link);
end;

function TFhirProfileQuery.Clone : TFhirProfileQuery;
begin
  result := TFhirProfileQuery(inherited Clone);
end;

{ TFhirProfileQuery }

Procedure TFhirProfileQuery.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirProfileQuery.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirProfileQuery.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirProfileQuery.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirProfileQuery.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := Documentation.value;
end;

Procedure TFhirProfileQuery.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;


{ TFhirProfileQueryList }
procedure TFhirProfileQueryList.AddItem(value: TFhirProfileQuery);
begin
  assert(value.ClassName = 'TFhirProfileQuery', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileQuery');
  add(value);
end;


function TFhirProfileQueryList.Append: TFhirProfileQuery;
begin
  result := TFhirProfileQuery.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileQueryList.ClearItems;
begin
  Clear;
end;

function TFhirProfileQueryList.Clone: TFhirProfileQueryList;
begin
  result := TFhirProfileQueryList(inherited Clone);
end;

function TFhirProfileQueryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileQueryList.GetItemN(index: Integer): TFhirProfileQuery;
begin
  result := TFhirProfileQuery(ObjectByIndex[index]);
end;

function TFhirProfileQueryList.IndexOf(value: TFhirProfileQuery): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileQueryList.Insert(index: Integer): TFhirProfileQuery;
begin
  result := TFhirProfileQuery.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileQueryList.InsertItem(index: Integer; value: TFhirProfileQuery);
begin
  assert(value is TFhirProfileQuery);
  Inherited Insert(index, value);
end;

function TFhirProfileQueryList.Item(index: Integer): TFhirProfileQuery;
begin
  result := TFhirProfileQuery(ObjectByIndex[index]);
end;

function TFhirProfileQueryList.Link: TFhirProfileQueryList;
begin
  result := TFhirProfileQueryList(inherited Link);
end;

procedure TFhirProfileQueryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileQueryList.SetItemByIndex(index: Integer; value: TFhirProfileQuery);
begin
  assert(value is TFhirProfileQuery);
  FhirProfileQueries[index] := value;
end;

procedure TFhirProfileQueryList.SetItemN(index: Integer; value: TFhirProfileQuery);
begin
  assert(value is TFhirProfileQuery);
  ObjectByIndex[index] := value;
end;

{ TFhirProvenanceAgent }

constructor TFhirProvenanceAgent.Create;
begin
  inherited;
end;

destructor TFhirProvenanceAgent.Destroy;
begin
  FRole.free;
  FType_.free;
  FReference.free;
  FDisplay.free;
  inherited;
end;

procedure TFhirProvenanceAgent.Assign(oSource : TAdvObject);
begin
  inherited;
  role := TFhirProvenanceAgent(oSource).role.Clone;
  type_ := TFhirProvenanceAgent(oSource).type_.Clone;
  reference := TFhirProvenanceAgent(oSource).reference.Clone;
  display := TFhirProvenanceAgent(oSource).display.Clone;
end;

procedure TFhirProvenanceAgent.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(Role.Link);
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'reference') Then
     list.add(Reference.Link);
  if (child_name = 'display') Then
     list.add(Display.Link);
end;

procedure TFhirProvenanceAgent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'Coding', FRole.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference', 'uri', FReference.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', FDisplay.Link.Link));{2}
end;

function TFhirProvenanceAgent.Link : TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(inherited Link);
end;

function TFhirProvenanceAgent.Clone : TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(inherited Clone);
end;

{ TFhirProvenanceAgent }

Procedure TFhirProvenanceAgent.SetRole(value : TFhirCoding);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirProvenanceAgent.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirProvenanceAgent.SetReference(value : TFhirUri);
begin
  FReference.free;
  FReference := value;
end;

Function TFhirProvenanceAgent.GetReferenceST : String;
begin
  if FReference = nil then
    result := ''
  else
    result := Reference.value;
end;

Procedure TFhirProvenanceAgent.SetReferenceST(value : String);
begin
  if value <> '' then
  begin
    if FReference = nil then
      FReference := TFhirUri.create;
    FReference.value := value
  end
  else if FReference <> nil then
    FReference.value := '';
end;

Procedure TFhirProvenanceAgent.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirProvenanceAgent.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := Display.value;
end;

Procedure TFhirProvenanceAgent.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;


{ TFhirProvenanceAgentList }
procedure TFhirProvenanceAgentList.AddItem(value: TFhirProvenanceAgent);
begin
  assert(value.ClassName = 'TFhirProvenanceAgent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProvenanceAgent');
  add(value);
end;


function TFhirProvenanceAgentList.Append: TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProvenanceAgentList.ClearItems;
begin
  Clear;
end;

function TFhirProvenanceAgentList.Clone: TFhirProvenanceAgentList;
begin
  result := TFhirProvenanceAgentList(inherited Clone);
end;

function TFhirProvenanceAgentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProvenanceAgentList.GetItemN(index: Integer): TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(ObjectByIndex[index]);
end;

function TFhirProvenanceAgentList.IndexOf(value: TFhirProvenanceAgent): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProvenanceAgentList.Insert(index: Integer): TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProvenanceAgentList.InsertItem(index: Integer; value: TFhirProvenanceAgent);
begin
  assert(value is TFhirProvenanceAgent);
  Inherited Insert(index, value);
end;

function TFhirProvenanceAgentList.Item(index: Integer): TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(ObjectByIndex[index]);
end;

function TFhirProvenanceAgentList.Link: TFhirProvenanceAgentList;
begin
  result := TFhirProvenanceAgentList(inherited Link);
end;

procedure TFhirProvenanceAgentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProvenanceAgentList.SetItemByIndex(index: Integer; value: TFhirProvenanceAgent);
begin
  assert(value is TFhirProvenanceAgent);
  FhirProvenanceAgents[index] := value;
end;

procedure TFhirProvenanceAgentList.SetItemN(index: Integer; value: TFhirProvenanceAgent);
begin
  assert(value is TFhirProvenanceAgent);
  ObjectByIndex[index] := value;
end;

{ TFhirProvenanceEntity }

constructor TFhirProvenanceEntity.Create;
begin
  inherited;
end;

destructor TFhirProvenanceEntity.Destroy;
begin
  FRole.free;
  FType_.free;
  FReference.free;
  FDisplay.free;
  FAgent.free;
  inherited;
end;

procedure TFhirProvenanceEntity.Assign(oSource : TAdvObject);
begin
  inherited;
  FRole := TFhirProvenanceEntity(oSource).FRole.Link;
  type_ := TFhirProvenanceEntity(oSource).type_.Clone;
  reference := TFhirProvenanceEntity(oSource).reference.Clone;
  display := TFhirProvenanceEntity(oSource).display.Clone;
  agent := TFhirProvenanceEntity(oSource).agent.Clone;
end;

procedure TFhirProvenanceEntity.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(FRole.Link);
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'reference') Then
     list.add(Reference.Link);
  if (child_name = 'display') Then
     list.add(Display.Link);
  if (child_name = 'agent') Then
     list.add(Agent.Link);
end;

procedure TFhirProvenanceEntity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'code', FRole.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference', 'uri', FReference.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', FDisplay.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'agent', '@Provenance.agent', FAgent.Link.Link));{2}
end;

function TFhirProvenanceEntity.Link : TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(inherited Link);
end;

function TFhirProvenanceEntity.Clone : TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(inherited Clone);
end;

{ TFhirProvenanceEntity }

Procedure TFhirProvenanceEntity.SetRole(value : TFhirEnum);
begin
  FRole.free;
  FRole := value;
end;

Function TFhirProvenanceEntity.GetRoleST : TFhirProvenanceEntityRole;
begin
  if FRole = nil then
    result := TFhirProvenanceEntityRole(0)
  else
    result := TFhirProvenanceEntityRole(StringArrayIndexOf(CODES_TFhirProvenanceEntityRole, Role.value));
end;

Procedure TFhirProvenanceEntity.SetRoleST(value : TFhirProvenanceEntityRole);
begin
  if ord(value) = 0 then
    Role := nil
  else
    Role := TFhirEnum.create(CODES_TFhirProvenanceEntityRole[value]);
end;

Procedure TFhirProvenanceEntity.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirProvenanceEntity.SetReference(value : TFhirUri);
begin
  FReference.free;
  FReference := value;
end;

Function TFhirProvenanceEntity.GetReferenceST : String;
begin
  if FReference = nil then
    result := ''
  else
    result := Reference.value;
end;

Procedure TFhirProvenanceEntity.SetReferenceST(value : String);
begin
  if value <> '' then
  begin
    if FReference = nil then
      FReference := TFhirUri.create;
    FReference.value := value
  end
  else if FReference <> nil then
    FReference.value := '';
end;

Procedure TFhirProvenanceEntity.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirProvenanceEntity.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := Display.value;
end;

Procedure TFhirProvenanceEntity.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

Procedure TFhirProvenanceEntity.SetAgent(value : TFhirProvenanceAgent);
begin
  FAgent.free;
  FAgent := value;
end;


{ TFhirProvenanceEntityList }
procedure TFhirProvenanceEntityList.AddItem(value: TFhirProvenanceEntity);
begin
  assert(value.ClassName = 'TFhirProvenanceEntity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProvenanceEntity');
  add(value);
end;


function TFhirProvenanceEntityList.Append: TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProvenanceEntityList.ClearItems;
begin
  Clear;
end;

function TFhirProvenanceEntityList.Clone: TFhirProvenanceEntityList;
begin
  result := TFhirProvenanceEntityList(inherited Clone);
end;

function TFhirProvenanceEntityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProvenanceEntityList.GetItemN(index: Integer): TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(ObjectByIndex[index]);
end;

function TFhirProvenanceEntityList.IndexOf(value: TFhirProvenanceEntity): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProvenanceEntityList.Insert(index: Integer): TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProvenanceEntityList.InsertItem(index: Integer; value: TFhirProvenanceEntity);
begin
  assert(value is TFhirProvenanceEntity);
  Inherited Insert(index, value);
end;

function TFhirProvenanceEntityList.Item(index: Integer): TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(ObjectByIndex[index]);
end;

function TFhirProvenanceEntityList.Link: TFhirProvenanceEntityList;
begin
  result := TFhirProvenanceEntityList(inherited Link);
end;

procedure TFhirProvenanceEntityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProvenanceEntityList.SetItemByIndex(index: Integer; value: TFhirProvenanceEntity);
begin
  assert(value is TFhirProvenanceEntity);
  FhirProvenanceEntities[index] := value;
end;

procedure TFhirProvenanceEntityList.SetItemN(index: Integer; value: TFhirProvenanceEntity);
begin
  assert(value is TFhirProvenanceEntity);
  ObjectByIndex[index] := value;
end;

{ TFhirQueryResponse }

constructor TFhirQueryResponse.Create;
begin
  inherited;
  FParameterList := TFhirExtensionList.Create;
  FFirstList := TFhirExtensionList.Create;
  FPreviousList := TFhirExtensionList.Create;
  FNextList := TFhirExtensionList.Create;
  FLastList := TFhirExtensionList.Create;
  FReferenceList := TFhirResourceReferenceList{Resource}.Create;
end;

destructor TFhirQueryResponse.Destroy;
begin
  FIdentifier.free;
  FOutcome.free;
  FTotal.free;
  FParameterList.Free;
  FFirstList.Free;
  FPreviousList.Free;
  FNextList.Free;
  FLastList.Free;
  FReferenceList.Free;
  inherited;
end;

procedure TFhirQueryResponse.Assign(oSource : TAdvObject);
begin
  inherited;
  identifier := TFhirQueryResponse(oSource).identifier.Clone;
  FOutcome := TFhirQueryResponse(oSource).FOutcome.Link;
  total := TFhirQueryResponse(oSource).total.Clone;
  FParameterList.Assign(TFhirQueryResponse(oSource).FParameterList);
  FFirstList.Assign(TFhirQueryResponse(oSource).FFirstList);
  FPreviousList.Assign(TFhirQueryResponse(oSource).FPreviousList);
  FNextList.Assign(TFhirQueryResponse(oSource).FNextList);
  FLastList.Assign(TFhirQueryResponse(oSource).FLastList);
  FReferenceList.Assign(TFhirQueryResponse(oSource).FReferenceList);
end;

procedure TFhirQueryResponse.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(Identifier.Link);
  if (child_name = 'outcome') Then
     list.add(FOutcome.Link);
  if (child_name = 'total') Then
     list.add(Total.Link);
  if (child_name = 'parameter') Then
     list.addAll(FParameterList);
  if (child_name = 'first') Then
     list.addAll(FFirstList);
  if (child_name = 'previous') Then
     list.addAll(FPreviousList);
  if (child_name = 'next') Then
     list.addAll(FNextList);
  if (child_name = 'last') Then
     list.addAll(FLastList);
  if (child_name = 'reference') Then
     list.addAll(FReferenceList);
end;

procedure TFhirQueryResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'uri', FIdentifier.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', FOutcome.Link));{1}
  oList.add(TFHIRProperty.create(self, 'total', 'integer', FTotal.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'parameter', 'Extension', FParameterList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'first', 'Extension', FFirstList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'previous', 'Extension', FPreviousList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'next', 'Extension', FNextList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'last', 'Extension', FLastList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reference', 'Resource(Any)', FReferenceList.Link)){3};
end;

function TFhirQueryResponse.Link : TFhirQueryResponse;
begin
  result := TFhirQueryResponse(inherited Link);
end;

function TFhirQueryResponse.Clone : TFhirQueryResponse;
begin
  result := TFhirQueryResponse(inherited Clone);
end;

{ TFhirQueryResponse }

Procedure TFhirQueryResponse.SetIdentifier(value : TFhirUri);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirQueryResponse.GetIdentifierST : String;
begin
  if FIdentifier = nil then
    result := ''
  else
    result := Identifier.value;
end;

Procedure TFhirQueryResponse.SetIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FIdentifier = nil then
      FIdentifier := TFhirUri.create;
    FIdentifier.value := value
  end
  else if FIdentifier <> nil then
    FIdentifier.value := '';
end;

Procedure TFhirQueryResponse.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

Function TFhirQueryResponse.GetOutcomeST : TFhirQueryOutcome;
begin
  if FOutcome = nil then
    result := TFhirQueryOutcome(0)
  else
    result := TFhirQueryOutcome(StringArrayIndexOf(CODES_TFhirQueryOutcome, Outcome.value));
end;

Procedure TFhirQueryResponse.SetOutcomeST(value : TFhirQueryOutcome);
begin
  if ord(value) = 0 then
    Outcome := nil
  else
    Outcome := TFhirEnum.create(CODES_TFhirQueryOutcome[value]);
end;

Procedure TFhirQueryResponse.SetTotal(value : TFhirInteger);
begin
  FTotal.free;
  FTotal := value;
end;

Function TFhirQueryResponse.GetTotalST : String;
begin
  if FTotal = nil then
    result := ''
  else
    result := Total.value;
end;

Procedure TFhirQueryResponse.SetTotalST(value : String);
begin
  if value <> '' then
  begin
    if FTotal = nil then
      FTotal := TFhirInteger.create;
    FTotal.value := value
  end
  else if FTotal <> nil then
    FTotal.value := '';
end;


{ TFhirQueryResponseList }
procedure TFhirQueryResponseList.AddItem(value: TFhirQueryResponse);
begin
  assert(value.ClassName = 'TFhirQueryResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQueryResponse');
  add(value);
end;


function TFhirQueryResponseList.Append: TFhirQueryResponse;
begin
  result := TFhirQueryResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirQueryResponseList.ClearItems;
begin
  Clear;
end;

function TFhirQueryResponseList.Clone: TFhirQueryResponseList;
begin
  result := TFhirQueryResponseList(inherited Clone);
end;

function TFhirQueryResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQueryResponseList.GetItemN(index: Integer): TFhirQueryResponse;
begin
  result := TFhirQueryResponse(ObjectByIndex[index]);
end;

function TFhirQueryResponseList.IndexOf(value: TFhirQueryResponse): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirQueryResponseList.Insert(index: Integer): TFhirQueryResponse;
begin
  result := TFhirQueryResponse.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirQueryResponseList.InsertItem(index: Integer; value: TFhirQueryResponse);
begin
  assert(value is TFhirQueryResponse);
  Inherited Insert(index, value);
end;

function TFhirQueryResponseList.Item(index: Integer): TFhirQueryResponse;
begin
  result := TFhirQueryResponse(ObjectByIndex[index]);
end;

function TFhirQueryResponseList.Link: TFhirQueryResponseList;
begin
  result := TFhirQueryResponseList(inherited Link);
end;

procedure TFhirQueryResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQueryResponseList.SetItemByIndex(index: Integer; value: TFhirQueryResponse);
begin
  assert(value is TFhirQueryResponse);
  FhirQueryResponses[index] := value;
end;

procedure TFhirQueryResponseList.SetItemN(index: Integer; value: TFhirQueryResponse);
begin
  assert(value is TFhirQueryResponse);
  ObjectByIndex[index] := value;
end;

{ TFhirQuestionnaireGroup }

constructor TFhirQuestionnaireGroup.Create;
begin
  inherited;
  FGroupList := TFhirQuestionnaireGroupList.Create;
  FQuestionList := TFhirQuestionnaireGroupQuestionList.Create;
end;

destructor TFhirQuestionnaireGroup.Destroy;
begin
  FName.free;
  FHeader.free;
  FText.free;
  FSubject.free;
  FGroupList.Free;
  FQuestionList.Free;
  inherited;
end;

procedure TFhirQuestionnaireGroup.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirQuestionnaireGroup(oSource).name.Clone;
  header := TFhirQuestionnaireGroup(oSource).header.Clone;
  text := TFhirQuestionnaireGroup(oSource).text.Clone;
  subject := TFhirQuestionnaireGroup(oSource).subject.Clone;
  FGroupList.Assign(TFhirQuestionnaireGroup(oSource).FGroupList);
  FQuestionList.Assign(TFhirQuestionnaireGroup(oSource).FQuestionList);
end;

procedure TFhirQuestionnaireGroup.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'header') Then
     list.add(Header.Link);
  if (child_name = 'text') Then
     list.add(Text.Link);
  if (child_name = 'subject') Then
     list.add(Subject.Link);
  if (child_name = 'group') Then
     list.addAll(FGroupList);
  if (child_name = 'question') Then
     list.addAll(FQuestionList);
end;

procedure TFhirQuestionnaireGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'CodeableConcept', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'header', 'string', FHeader.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'text', 'string', FText.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Resource(Any)', FSubject.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'group', '@Questionnaire.group', FGroupList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'question', '', FQuestionList.Link)){3};
end;

function TFhirQuestionnaireGroup.Link : TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup(inherited Link);
end;

function TFhirQuestionnaireGroup.Clone : TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup(inherited Clone);
end;

{ TFhirQuestionnaireGroup }

Procedure TFhirQuestionnaireGroup.SetName(value : TFhirCodeableConcept);
begin
  FName.free;
  FName := value;
end;

Procedure TFhirQuestionnaireGroup.SetHeader(value : TFhirString);
begin
  FHeader.free;
  FHeader := value;
end;

Function TFhirQuestionnaireGroup.GetHeaderST : String;
begin
  if FHeader = nil then
    result := ''
  else
    result := Header.value;
end;

Procedure TFhirQuestionnaireGroup.SetHeaderST(value : String);
begin
  if value <> '' then
  begin
    if FHeader = nil then
      FHeader := TFhirString.create;
    FHeader.value := value
  end
  else if FHeader <> nil then
    FHeader.value := '';
end;

Procedure TFhirQuestionnaireGroup.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirQuestionnaireGroup.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := Text.value;
end;

Procedure TFhirQuestionnaireGroup.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Procedure TFhirQuestionnaireGroup.SetSubject(value : TFhirResourceReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;


{ TFhirQuestionnaireGroupList }
procedure TFhirQuestionnaireGroupList.AddItem(value: TFhirQuestionnaireGroup);
begin
  assert(value.ClassName = 'TFhirQuestionnaireGroup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireGroup');
  add(value);
end;


function TFhirQuestionnaireGroupList.Append: TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirQuestionnaireGroupList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireGroupList.Clone: TFhirQuestionnaireGroupList;
begin
  result := TFhirQuestionnaireGroupList(inherited Clone);
end;

function TFhirQuestionnaireGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireGroupList.GetItemN(index: Integer): TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup(ObjectByIndex[index]);
end;

function TFhirQuestionnaireGroupList.IndexOf(value: TFhirQuestionnaireGroup): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirQuestionnaireGroupList.Insert(index: Integer): TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirQuestionnaireGroupList.InsertItem(index: Integer; value: TFhirQuestionnaireGroup);
begin
  assert(value is TFhirQuestionnaireGroup);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireGroupList.Item(index: Integer): TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup(ObjectByIndex[index]);
end;

function TFhirQuestionnaireGroupList.Link: TFhirQuestionnaireGroupList;
begin
  result := TFhirQuestionnaireGroupList(inherited Link);
end;

procedure TFhirQuestionnaireGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireGroupList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireGroup);
begin
  assert(value is TFhirQuestionnaireGroup);
  FhirQuestionnaireGroups[index] := value;
end;

procedure TFhirQuestionnaireGroupList.SetItemN(index: Integer; value: TFhirQuestionnaireGroup);
begin
  assert(value is TFhirQuestionnaireGroup);
  ObjectByIndex[index] := value;
end;

{ TFhirQuestionnaireGroupQuestion }

constructor TFhirQuestionnaireGroupQuestion.Create;
begin
  inherited;
  FChoiceList := TFhirCodingList.Create;
  FGroupList := TFhirQuestionnaireGroupList.Create;
end;

destructor TFhirQuestionnaireGroupQuestion.Destroy;
begin
  FName.free;
  FText.free;
  FAnswer.free;
  FChoiceList.Free;
  FOptions.free;
  FData.free;
  FRemarks.free;
  FGroupList.Free;
  inherited;
end;

procedure TFhirQuestionnaireGroupQuestion.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirQuestionnaireGroupQuestion(oSource).name.Clone;
  text := TFhirQuestionnaireGroupQuestion(oSource).text.Clone;
  answer := TFhirQuestionnaireGroupQuestion(oSource).answer.Clone;
  FChoiceList.Assign(TFhirQuestionnaireGroupQuestion(oSource).FChoiceList);
  options := TFhirQuestionnaireGroupQuestion(oSource).options.Clone;
  data := TFhirQuestionnaireGroupQuestion(oSource).data.Clone;
  remarks := TFhirQuestionnaireGroupQuestion(oSource).remarks.Clone;
  FGroupList.Assign(TFhirQuestionnaireGroupQuestion(oSource).FGroupList);
end;

procedure TFhirQuestionnaireGroupQuestion.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'text') Then
     list.add(Text.Link);
  if (child_name = 'answer') Then
     list.add(Answer.Link);
  if (child_name = 'choice') Then
     list.addAll(FChoiceList);
  if (child_name = 'options') Then
     list.add(Options.Link);
  if (child_name = 'data') Then
     list.add(Data.Link);
  if (child_name = 'remarks') Then
     list.add(Remarks.Link);
  if (child_name = 'group') Then
     list.addAll(FGroupList);
end;

procedure TFhirQuestionnaireGroupQuestion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'CodeableConcept', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'text', 'string', FText.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'answer[x]', 'decimal|integer|boolean|date|string|dateTime|instant', FAnswer.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'choice', 'Coding', FChoiceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'options', 'Resource(ValueSet)', FOptions.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'data[x]', '*', FData.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'remarks', 'string', FRemarks.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'group', '@Questionnaire.group', FGroupList.Link)){3};
end;

function TFhirQuestionnaireGroupQuestion.Link : TFhirQuestionnaireGroupQuestion;
begin
  result := TFhirQuestionnaireGroupQuestion(inherited Link);
end;

function TFhirQuestionnaireGroupQuestion.Clone : TFhirQuestionnaireGroupQuestion;
begin
  result := TFhirQuestionnaireGroupQuestion(inherited Clone);
end;

{ TFhirQuestionnaireGroupQuestion }

Procedure TFhirQuestionnaireGroupQuestion.SetName(value : TFhirCodeableConcept);
begin
  FName.free;
  FName := value;
end;

Procedure TFhirQuestionnaireGroupQuestion.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirQuestionnaireGroupQuestion.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := Text.value;
end;

Procedure TFhirQuestionnaireGroupQuestion.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Procedure TFhirQuestionnaireGroupQuestion.SetAnswer(value : TFhirType);
begin
  FAnswer.free;
  FAnswer := value;
end;

Procedure TFhirQuestionnaireGroupQuestion.SetOptions(value : TFhirResourceReference{TFhirValueSet});
begin
  FOptions.free;
  FOptions := value;
end;

Procedure TFhirQuestionnaireGroupQuestion.SetData(value : TFhirType);
begin
  FData.free;
  FData := value;
end;

Procedure TFhirQuestionnaireGroupQuestion.SetRemarks(value : TFhirString);
begin
  FRemarks.free;
  FRemarks := value;
end;

Function TFhirQuestionnaireGroupQuestion.GetRemarksST : String;
begin
  if FRemarks = nil then
    result := ''
  else
    result := Remarks.value;
end;

Procedure TFhirQuestionnaireGroupQuestion.SetRemarksST(value : String);
begin
  if value <> '' then
  begin
    if FRemarks = nil then
      FRemarks := TFhirString.create;
    FRemarks.value := value
  end
  else if FRemarks <> nil then
    FRemarks.value := '';
end;


{ TFhirQuestionnaireGroupQuestionList }
procedure TFhirQuestionnaireGroupQuestionList.AddItem(value: TFhirQuestionnaireGroupQuestion);
begin
  assert(value.ClassName = 'TFhirQuestionnaireGroupQuestion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireGroupQuestion');
  add(value);
end;


function TFhirQuestionnaireGroupQuestionList.Append: TFhirQuestionnaireGroupQuestion;
begin
  result := TFhirQuestionnaireGroupQuestion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirQuestionnaireGroupQuestionList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireGroupQuestionList.Clone: TFhirQuestionnaireGroupQuestionList;
begin
  result := TFhirQuestionnaireGroupQuestionList(inherited Clone);
end;

function TFhirQuestionnaireGroupQuestionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireGroupQuestionList.GetItemN(index: Integer): TFhirQuestionnaireGroupQuestion;
begin
  result := TFhirQuestionnaireGroupQuestion(ObjectByIndex[index]);
end;

function TFhirQuestionnaireGroupQuestionList.IndexOf(value: TFhirQuestionnaireGroupQuestion): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirQuestionnaireGroupQuestionList.Insert(index: Integer): TFhirQuestionnaireGroupQuestion;
begin
  result := TFhirQuestionnaireGroupQuestion.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirQuestionnaireGroupQuestionList.InsertItem(index: Integer; value: TFhirQuestionnaireGroupQuestion);
begin
  assert(value is TFhirQuestionnaireGroupQuestion);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireGroupQuestionList.Item(index: Integer): TFhirQuestionnaireGroupQuestion;
begin
  result := TFhirQuestionnaireGroupQuestion(ObjectByIndex[index]);
end;

function TFhirQuestionnaireGroupQuestionList.Link: TFhirQuestionnaireGroupQuestionList;
begin
  result := TFhirQuestionnaireGroupQuestionList(inherited Link);
end;

procedure TFhirQuestionnaireGroupQuestionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireGroupQuestionList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireGroupQuestion);
begin
  assert(value is TFhirQuestionnaireGroupQuestion);
  FhirQuestionnaireGroupQuestions[index] := value;
end;

procedure TFhirQuestionnaireGroupQuestionList.SetItemN(index: Integer; value: TFhirQuestionnaireGroupQuestion);
begin
  assert(value is TFhirQuestionnaireGroupQuestion);
  ObjectByIndex[index] := value;
end;

{ TFhirSecurityEventEvent }

constructor TFhirSecurityEventEvent.Create;
begin
  inherited;
  FSubtypeList := TFhirCodeableConceptList.Create;
end;

destructor TFhirSecurityEventEvent.Destroy;
begin
  FType_.free;
  FSubtypeList.Free;
  FAction.free;
  FDateTime.free;
  FOutcome.free;
  FOutcomeDesc.free;
  inherited;
end;

procedure TFhirSecurityEventEvent.Assign(oSource : TAdvObject);
begin
  inherited;
  type_ := TFhirSecurityEventEvent(oSource).type_.Clone;
  FSubtypeList.Assign(TFhirSecurityEventEvent(oSource).FSubtypeList);
  FAction := TFhirSecurityEventEvent(oSource).FAction.Link;
  dateTime := TFhirSecurityEventEvent(oSource).dateTime.Clone;
  FOutcome := TFhirSecurityEventEvent(oSource).FOutcome.Link;
  outcomeDesc := TFhirSecurityEventEvent(oSource).outcomeDesc.Clone;
end;

procedure TFhirSecurityEventEvent.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'subtype') Then
     list.addAll(FSubtypeList);
  if (child_name = 'action') Then
     list.add(FAction.Link);
  if (child_name = 'dateTime') Then
     list.add(DateTime.Link);
  if (child_name = 'outcome') Then
     list.add(FOutcome.Link);
  if (child_name = 'outcomeDesc') Then
     list.add(OutcomeDesc.Link);
end;

procedure TFhirSecurityEventEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subtype', 'CodeableConcept', FSubtypeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'action', 'code', FAction.Link));{1}
  oList.add(TFHIRProperty.create(self, 'dateTime', 'instant', FDateTime.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', FOutcome.Link));{1}
  oList.add(TFHIRProperty.create(self, 'outcomeDesc', 'string', FOutcomeDesc.Link.Link));{2}
end;

function TFhirSecurityEventEvent.Link : TFhirSecurityEventEvent;
begin
  result := TFhirSecurityEventEvent(inherited Link);
end;

function TFhirSecurityEventEvent.Clone : TFhirSecurityEventEvent;
begin
  result := TFhirSecurityEventEvent(inherited Clone);
end;

{ TFhirSecurityEventEvent }

Procedure TFhirSecurityEventEvent.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirSecurityEventEvent.SetAction(value : TFhirEnum);
begin
  FAction.free;
  FAction := value;
end;

Function TFhirSecurityEventEvent.GetActionST : TFhirSecurityEventAction;
begin
  if FAction = nil then
    result := TFhirSecurityEventAction(0)
  else
    result := TFhirSecurityEventAction(StringArrayIndexOf(CODES_TFhirSecurityEventAction, Action.value));
end;

Procedure TFhirSecurityEventEvent.SetActionST(value : TFhirSecurityEventAction);
begin
  if ord(value) = 0 then
    Action := nil
  else
    Action := TFhirEnum.create(CODES_TFhirSecurityEventAction[value]);
end;

Procedure TFhirSecurityEventEvent.SetDateTime(value : TFhirInstant);
begin
  FDateTime.free;
  FDateTime := value;
end;

Function TFhirSecurityEventEvent.GetDateTimeST : TDateAndTime;
begin
  if FDateTime = nil then
    result := nil
  else
    result := DateTime.value;
end;

Procedure TFhirSecurityEventEvent.SetDateTimeST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FDateTime = nil then
      FDateTime := TFhirInstant.create;
    FDateTime.value := value
  end
  else if FDateTime <> nil then
    FDateTime.value := nil;
end;

Procedure TFhirSecurityEventEvent.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

Function TFhirSecurityEventEvent.GetOutcomeST : TFhirSecurityEventOutcome;
begin
  if FOutcome = nil then
    result := TFhirSecurityEventOutcome(0)
  else
    result := TFhirSecurityEventOutcome(StringArrayIndexOf(CODES_TFhirSecurityEventOutcome, Outcome.value));
end;

Procedure TFhirSecurityEventEvent.SetOutcomeST(value : TFhirSecurityEventOutcome);
begin
  if ord(value) = 0 then
    Outcome := nil
  else
    Outcome := TFhirEnum.create(CODES_TFhirSecurityEventOutcome[value]);
end;

Procedure TFhirSecurityEventEvent.SetOutcomeDesc(value : TFhirString);
begin
  FOutcomeDesc.free;
  FOutcomeDesc := value;
end;

Function TFhirSecurityEventEvent.GetOutcomeDescST : String;
begin
  if FOutcomeDesc = nil then
    result := ''
  else
    result := OutcomeDesc.value;
end;

Procedure TFhirSecurityEventEvent.SetOutcomeDescST(value : String);
begin
  if value <> '' then
  begin
    if FOutcomeDesc = nil then
      FOutcomeDesc := TFhirString.create;
    FOutcomeDesc.value := value
  end
  else if FOutcomeDesc <> nil then
    FOutcomeDesc.value := '';
end;


{ TFhirSecurityEventEventList }
procedure TFhirSecurityEventEventList.AddItem(value: TFhirSecurityEventEvent);
begin
  assert(value.ClassName = 'TFhirSecurityEventEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSecurityEventEvent');
  add(value);
end;


function TFhirSecurityEventEventList.Append: TFhirSecurityEventEvent;
begin
  result := TFhirSecurityEventEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventEventList.ClearItems;
begin
  Clear;
end;

function TFhirSecurityEventEventList.Clone: TFhirSecurityEventEventList;
begin
  result := TFhirSecurityEventEventList(inherited Clone);
end;

function TFhirSecurityEventEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSecurityEventEventList.GetItemN(index: Integer): TFhirSecurityEventEvent;
begin
  result := TFhirSecurityEventEvent(ObjectByIndex[index]);
end;

function TFhirSecurityEventEventList.IndexOf(value: TFhirSecurityEventEvent): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSecurityEventEventList.Insert(index: Integer): TFhirSecurityEventEvent;
begin
  result := TFhirSecurityEventEvent.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventEventList.InsertItem(index: Integer; value: TFhirSecurityEventEvent);
begin
  assert(value is TFhirSecurityEventEvent);
  Inherited Insert(index, value);
end;

function TFhirSecurityEventEventList.Item(index: Integer): TFhirSecurityEventEvent;
begin
  result := TFhirSecurityEventEvent(ObjectByIndex[index]);
end;

function TFhirSecurityEventEventList.Link: TFhirSecurityEventEventList;
begin
  result := TFhirSecurityEventEventList(inherited Link);
end;

procedure TFhirSecurityEventEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSecurityEventEventList.SetItemByIndex(index: Integer; value: TFhirSecurityEventEvent);
begin
  assert(value is TFhirSecurityEventEvent);
  FhirSecurityEventEvents[index] := value;
end;

procedure TFhirSecurityEventEventList.SetItemN(index: Integer; value: TFhirSecurityEventEvent);
begin
  assert(value is TFhirSecurityEventEvent);
  ObjectByIndex[index] := value;
end;

{ TFhirSecurityEventParticipant }

constructor TFhirSecurityEventParticipant.Create;
begin
  inherited;
  FRoleList := TFhirCodeableConceptList.Create;
end;

destructor TFhirSecurityEventParticipant.Destroy;
begin
  FRoleList.Free;
  FReference.free;
  FUserId.free;
  FAltId.free;
  FName.free;
  FRequestor.free;
  FMedia.free;
  FNetwork.free;
  inherited;
end;

procedure TFhirSecurityEventParticipant.Assign(oSource : TAdvObject);
begin
  inherited;
  FRoleList.Assign(TFhirSecurityEventParticipant(oSource).FRoleList);
  reference := TFhirSecurityEventParticipant(oSource).reference.Clone;
  userId := TFhirSecurityEventParticipant(oSource).userId.Clone;
  altId := TFhirSecurityEventParticipant(oSource).altId.Clone;
  name := TFhirSecurityEventParticipant(oSource).name.Clone;
  requestor := TFhirSecurityEventParticipant(oSource).requestor.Clone;
  media := TFhirSecurityEventParticipant(oSource).media.Clone;
  network := TFhirSecurityEventParticipant(oSource).network.Clone;
end;

procedure TFhirSecurityEventParticipant.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'role') Then
     list.addAll(FRoleList);
  if (child_name = 'reference') Then
     list.add(Reference.Link);
  if (child_name = 'userId') Then
     list.add(UserId.Link);
  if (child_name = 'altId') Then
     list.add(AltId.Link);
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'requestor') Then
     list.add(Requestor.Link);
  if (child_name = 'media') Then
     list.add(Media.Link);
  if (child_name = 'network') Then
     list.add(Network.Link);
end;

procedure TFhirSecurityEventParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', FRoleList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reference', 'Resource(Practitioner|Patient|Device)', FReference.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'userId', 'string', FUserId.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'altId', 'string', FAltId.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestor', 'boolean', FRequestor.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'media', 'Coding', FMedia.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'network', '', FNetwork.Link.Link));{2}
end;

function TFhirSecurityEventParticipant.Link : TFhirSecurityEventParticipant;
begin
  result := TFhirSecurityEventParticipant(inherited Link);
end;

function TFhirSecurityEventParticipant.Clone : TFhirSecurityEventParticipant;
begin
  result := TFhirSecurityEventParticipant(inherited Clone);
end;

{ TFhirSecurityEventParticipant }

Procedure TFhirSecurityEventParticipant.SetReference(value : TFhirResourceReference{Resource});
begin
  FReference.free;
  FReference := value;
end;

Procedure TFhirSecurityEventParticipant.SetUserId(value : TFhirString);
begin
  FUserId.free;
  FUserId := value;
end;

Function TFhirSecurityEventParticipant.GetUserIdST : String;
begin
  if FUserId = nil then
    result := ''
  else
    result := UserId.value;
end;

Procedure TFhirSecurityEventParticipant.SetUserIdST(value : String);
begin
  if value <> '' then
  begin
    if FUserId = nil then
      FUserId := TFhirString.create;
    FUserId.value := value
  end
  else if FUserId <> nil then
    FUserId.value := '';
end;

Procedure TFhirSecurityEventParticipant.SetAltId(value : TFhirString);
begin
  FAltId.free;
  FAltId := value;
end;

Function TFhirSecurityEventParticipant.GetAltIdST : String;
begin
  if FAltId = nil then
    result := ''
  else
    result := AltId.value;
end;

Procedure TFhirSecurityEventParticipant.SetAltIdST(value : String);
begin
  if value <> '' then
  begin
    if FAltId = nil then
      FAltId := TFhirString.create;
    FAltId.value := value
  end
  else if FAltId <> nil then
    FAltId.value := '';
end;

Procedure TFhirSecurityEventParticipant.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirSecurityEventParticipant.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirSecurityEventParticipant.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirSecurityEventParticipant.SetRequestor(value : TFhirBoolean);
begin
  FRequestor.free;
  FRequestor := value;
end;

Function TFhirSecurityEventParticipant.GetRequestorST : Boolean;
begin
  if FRequestor = nil then
    result := false
  else
    result := Requestor.value;
end;

Procedure TFhirSecurityEventParticipant.SetRequestorST(value : Boolean);
begin
  if FRequestor = nil then
    FRequestor := TFhirBoolean.create;
  FRequestor.value := value
end;

Procedure TFhirSecurityEventParticipant.SetMedia(value : TFhirCoding);
begin
  FMedia.free;
  FMedia := value;
end;

Procedure TFhirSecurityEventParticipant.SetNetwork(value : TFhirSecurityEventParticipantNetwork);
begin
  FNetwork.free;
  FNetwork := value;
end;


{ TFhirSecurityEventParticipantList }
procedure TFhirSecurityEventParticipantList.AddItem(value: TFhirSecurityEventParticipant);
begin
  assert(value.ClassName = 'TFhirSecurityEventParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSecurityEventParticipant');
  add(value);
end;


function TFhirSecurityEventParticipantList.Append: TFhirSecurityEventParticipant;
begin
  result := TFhirSecurityEventParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirSecurityEventParticipantList.Clone: TFhirSecurityEventParticipantList;
begin
  result := TFhirSecurityEventParticipantList(inherited Clone);
end;

function TFhirSecurityEventParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSecurityEventParticipantList.GetItemN(index: Integer): TFhirSecurityEventParticipant;
begin
  result := TFhirSecurityEventParticipant(ObjectByIndex[index]);
end;

function TFhirSecurityEventParticipantList.IndexOf(value: TFhirSecurityEventParticipant): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSecurityEventParticipantList.Insert(index: Integer): TFhirSecurityEventParticipant;
begin
  result := TFhirSecurityEventParticipant.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventParticipantList.InsertItem(index: Integer; value: TFhirSecurityEventParticipant);
begin
  assert(value is TFhirSecurityEventParticipant);
  Inherited Insert(index, value);
end;

function TFhirSecurityEventParticipantList.Item(index: Integer): TFhirSecurityEventParticipant;
begin
  result := TFhirSecurityEventParticipant(ObjectByIndex[index]);
end;

function TFhirSecurityEventParticipantList.Link: TFhirSecurityEventParticipantList;
begin
  result := TFhirSecurityEventParticipantList(inherited Link);
end;

procedure TFhirSecurityEventParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSecurityEventParticipantList.SetItemByIndex(index: Integer; value: TFhirSecurityEventParticipant);
begin
  assert(value is TFhirSecurityEventParticipant);
  FhirSecurityEventParticipants[index] := value;
end;

procedure TFhirSecurityEventParticipantList.SetItemN(index: Integer; value: TFhirSecurityEventParticipant);
begin
  assert(value is TFhirSecurityEventParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirSecurityEventParticipantNetwork }

constructor TFhirSecurityEventParticipantNetwork.Create;
begin
  inherited;
end;

destructor TFhirSecurityEventParticipantNetwork.Destroy;
begin
  FIdentifier.free;
  FType_.free;
  inherited;
end;

procedure TFhirSecurityEventParticipantNetwork.Assign(oSource : TAdvObject);
begin
  inherited;
  identifier := TFhirSecurityEventParticipantNetwork(oSource).identifier.Clone;
  FType_ := TFhirSecurityEventParticipantNetwork(oSource).FType_.Link;
end;

procedure TFhirSecurityEventParticipantNetwork.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(Identifier.Link);
  if (child_name = 'type_') Then
     list.add(FType_.Link);
end;

procedure TFhirSecurityEventParticipantNetwork.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'string', FIdentifier.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{1}
end;

function TFhirSecurityEventParticipantNetwork.Link : TFhirSecurityEventParticipantNetwork;
begin
  result := TFhirSecurityEventParticipantNetwork(inherited Link);
end;

function TFhirSecurityEventParticipantNetwork.Clone : TFhirSecurityEventParticipantNetwork;
begin
  result := TFhirSecurityEventParticipantNetwork(inherited Clone);
end;

{ TFhirSecurityEventParticipantNetwork }

Procedure TFhirSecurityEventParticipantNetwork.SetIdentifier(value : TFhirString);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirSecurityEventParticipantNetwork.GetIdentifierST : String;
begin
  if FIdentifier = nil then
    result := ''
  else
    result := Identifier.value;
end;

Procedure TFhirSecurityEventParticipantNetwork.SetIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FIdentifier = nil then
      FIdentifier := TFhirString.create;
    FIdentifier.value := value
  end
  else if FIdentifier <> nil then
    FIdentifier.value := '';
end;

Procedure TFhirSecurityEventParticipantNetwork.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirSecurityEventParticipantNetwork.GetType_ST : TFhirNetworkType;
begin
  if FType_ = nil then
    result := TFhirNetworkType(0)
  else
    result := TFhirNetworkType(StringArrayIndexOf(CODES_TFhirNetworkType, Type_.value));
end;

Procedure TFhirSecurityEventParticipantNetwork.SetType_ST(value : TFhirNetworkType);
begin
  if ord(value) = 0 then
    Type_ := nil
  else
    Type_ := TFhirEnum.create(CODES_TFhirNetworkType[value]);
end;


{ TFhirSecurityEventParticipantNetworkList }
procedure TFhirSecurityEventParticipantNetworkList.AddItem(value: TFhirSecurityEventParticipantNetwork);
begin
  assert(value.ClassName = 'TFhirSecurityEventParticipantNetwork', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSecurityEventParticipantNetwork');
  add(value);
end;


function TFhirSecurityEventParticipantNetworkList.Append: TFhirSecurityEventParticipantNetwork;
begin
  result := TFhirSecurityEventParticipantNetwork.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventParticipantNetworkList.ClearItems;
begin
  Clear;
end;

function TFhirSecurityEventParticipantNetworkList.Clone: TFhirSecurityEventParticipantNetworkList;
begin
  result := TFhirSecurityEventParticipantNetworkList(inherited Clone);
end;

function TFhirSecurityEventParticipantNetworkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSecurityEventParticipantNetworkList.GetItemN(index: Integer): TFhirSecurityEventParticipantNetwork;
begin
  result := TFhirSecurityEventParticipantNetwork(ObjectByIndex[index]);
end;

function TFhirSecurityEventParticipantNetworkList.IndexOf(value: TFhirSecurityEventParticipantNetwork): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSecurityEventParticipantNetworkList.Insert(index: Integer): TFhirSecurityEventParticipantNetwork;
begin
  result := TFhirSecurityEventParticipantNetwork.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventParticipantNetworkList.InsertItem(index: Integer; value: TFhirSecurityEventParticipantNetwork);
begin
  assert(value is TFhirSecurityEventParticipantNetwork);
  Inherited Insert(index, value);
end;

function TFhirSecurityEventParticipantNetworkList.Item(index: Integer): TFhirSecurityEventParticipantNetwork;
begin
  result := TFhirSecurityEventParticipantNetwork(ObjectByIndex[index]);
end;

function TFhirSecurityEventParticipantNetworkList.Link: TFhirSecurityEventParticipantNetworkList;
begin
  result := TFhirSecurityEventParticipantNetworkList(inherited Link);
end;

procedure TFhirSecurityEventParticipantNetworkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSecurityEventParticipantNetworkList.SetItemByIndex(index: Integer; value: TFhirSecurityEventParticipantNetwork);
begin
  assert(value is TFhirSecurityEventParticipantNetwork);
  FhirSecurityEventParticipantNetworks[index] := value;
end;

procedure TFhirSecurityEventParticipantNetworkList.SetItemN(index: Integer; value: TFhirSecurityEventParticipantNetwork);
begin
  assert(value is TFhirSecurityEventParticipantNetwork);
  ObjectByIndex[index] := value;
end;

{ TFhirSecurityEventSource }

constructor TFhirSecurityEventSource.Create;
begin
  inherited;
  FType_List := TFhirCodingList.Create;
end;

destructor TFhirSecurityEventSource.Destroy;
begin
  FSite.free;
  FIdentifier.free;
  FType_List.Free;
  inherited;
end;

procedure TFhirSecurityEventSource.Assign(oSource : TAdvObject);
begin
  inherited;
  site := TFhirSecurityEventSource(oSource).site.Clone;
  identifier := TFhirSecurityEventSource(oSource).identifier.Clone;
  FType_List.Assign(TFhirSecurityEventSource(oSource).FType_List);
end;

procedure TFhirSecurityEventSource.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'site') Then
     list.add(Site.Link);
  if (child_name = 'identifier') Then
     list.add(Identifier.Link);
  if (child_name = 'type_') Then
     list.addAll(FType_List);
end;

procedure TFhirSecurityEventSource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'site', 'string', FSite.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'string', FIdentifier.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', FType_List.Link)){3};
end;

function TFhirSecurityEventSource.Link : TFhirSecurityEventSource;
begin
  result := TFhirSecurityEventSource(inherited Link);
end;

function TFhirSecurityEventSource.Clone : TFhirSecurityEventSource;
begin
  result := TFhirSecurityEventSource(inherited Clone);
end;

{ TFhirSecurityEventSource }

Procedure TFhirSecurityEventSource.SetSite(value : TFhirString);
begin
  FSite.free;
  FSite := value;
end;

Function TFhirSecurityEventSource.GetSiteST : String;
begin
  if FSite = nil then
    result := ''
  else
    result := Site.value;
end;

Procedure TFhirSecurityEventSource.SetSiteST(value : String);
begin
  if value <> '' then
  begin
    if FSite = nil then
      FSite := TFhirString.create;
    FSite.value := value
  end
  else if FSite <> nil then
    FSite.value := '';
end;

Procedure TFhirSecurityEventSource.SetIdentifier(value : TFhirString);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirSecurityEventSource.GetIdentifierST : String;
begin
  if FIdentifier = nil then
    result := ''
  else
    result := Identifier.value;
end;

Procedure TFhirSecurityEventSource.SetIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FIdentifier = nil then
      FIdentifier := TFhirString.create;
    FIdentifier.value := value
  end
  else if FIdentifier <> nil then
    FIdentifier.value := '';
end;


{ TFhirSecurityEventSourceList }
procedure TFhirSecurityEventSourceList.AddItem(value: TFhirSecurityEventSource);
begin
  assert(value.ClassName = 'TFhirSecurityEventSource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSecurityEventSource');
  add(value);
end;


function TFhirSecurityEventSourceList.Append: TFhirSecurityEventSource;
begin
  result := TFhirSecurityEventSource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventSourceList.ClearItems;
begin
  Clear;
end;

function TFhirSecurityEventSourceList.Clone: TFhirSecurityEventSourceList;
begin
  result := TFhirSecurityEventSourceList(inherited Clone);
end;

function TFhirSecurityEventSourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSecurityEventSourceList.GetItemN(index: Integer): TFhirSecurityEventSource;
begin
  result := TFhirSecurityEventSource(ObjectByIndex[index]);
end;

function TFhirSecurityEventSourceList.IndexOf(value: TFhirSecurityEventSource): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSecurityEventSourceList.Insert(index: Integer): TFhirSecurityEventSource;
begin
  result := TFhirSecurityEventSource.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventSourceList.InsertItem(index: Integer; value: TFhirSecurityEventSource);
begin
  assert(value is TFhirSecurityEventSource);
  Inherited Insert(index, value);
end;

function TFhirSecurityEventSourceList.Item(index: Integer): TFhirSecurityEventSource;
begin
  result := TFhirSecurityEventSource(ObjectByIndex[index]);
end;

function TFhirSecurityEventSourceList.Link: TFhirSecurityEventSourceList;
begin
  result := TFhirSecurityEventSourceList(inherited Link);
end;

procedure TFhirSecurityEventSourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSecurityEventSourceList.SetItemByIndex(index: Integer; value: TFhirSecurityEventSource);
begin
  assert(value is TFhirSecurityEventSource);
  FhirSecurityEventSources[index] := value;
end;

procedure TFhirSecurityEventSourceList.SetItemN(index: Integer; value: TFhirSecurityEventSource);
begin
  assert(value is TFhirSecurityEventSource);
  ObjectByIndex[index] := value;
end;

{ TFhirSecurityEventObject }

constructor TFhirSecurityEventObject.Create;
begin
  inherited;
  FDetailList := TFhirSecurityEventObjectDetailList.Create;
end;

destructor TFhirSecurityEventObject.Destroy;
begin
  FIdentifier.free;
  FReference.free;
  FType_.free;
  FRole.free;
  FLifecycle.free;
  FSensitivity.free;
  FName.free;
  FDescription.free;
  FQuery.free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirSecurityEventObject.Assign(oSource : TAdvObject);
begin
  inherited;
  identifier := TFhirSecurityEventObject(oSource).identifier.Clone;
  reference := TFhirSecurityEventObject(oSource).reference.Clone;
  FType_ := TFhirSecurityEventObject(oSource).FType_.Link;
  FRole := TFhirSecurityEventObject(oSource).FRole.Link;
  FLifecycle := TFhirSecurityEventObject(oSource).FLifecycle.Link;
  sensitivity := TFhirSecurityEventObject(oSource).sensitivity.Clone;
  name := TFhirSecurityEventObject(oSource).name.Clone;
  description := TFhirSecurityEventObject(oSource).description.Clone;
  query := TFhirSecurityEventObject(oSource).query.Clone;
  FDetailList.Assign(TFhirSecurityEventObject(oSource).FDetailList);
end;

procedure TFhirSecurityEventObject.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(Identifier.Link);
  if (child_name = 'reference') Then
     list.add(Reference.Link);
  if (child_name = 'type_') Then
     list.add(FType_.Link);
  if (child_name = 'role') Then
     list.add(FRole.Link);
  if (child_name = 'lifecycle') Then
     list.add(FLifecycle.Link);
  if (child_name = 'sensitivity') Then
     list.add(Sensitivity.Link);
  if (child_name = 'name') Then
     list.add(Name.Link);
  if (child_name = 'description') Then
     list.add(Description.Link);
  if (child_name = 'query') Then
     list.add(Query.Link);
  if (child_name = 'detail') Then
     list.addAll(FDetailList);
end;

procedure TFhirSecurityEventObject.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', FIdentifier.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference', 'Resource(Any)', FReference.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'role', 'code', FRole.Link));{1}
  oList.add(TFHIRProperty.create(self, 'lifecycle', 'code', FLifecycle.Link));{1}
  oList.add(TFHIRProperty.create(self, 'sensitivity', 'CodeableConcept', FSensitivity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'query', 'base64Binary', FQuery.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', '', FDetailList.Link)){3};
end;

function TFhirSecurityEventObject.Link : TFhirSecurityEventObject;
begin
  result := TFhirSecurityEventObject(inherited Link);
end;

function TFhirSecurityEventObject.Clone : TFhirSecurityEventObject;
begin
  result := TFhirSecurityEventObject(inherited Clone);
end;

{ TFhirSecurityEventObject }

Procedure TFhirSecurityEventObject.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirSecurityEventObject.SetReference(value : TFhirResourceReference{Resource});
begin
  FReference.free;
  FReference := value;
end;

Procedure TFhirSecurityEventObject.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirSecurityEventObject.GetType_ST : TFhirObjectType;
begin
  if FType_ = nil then
    result := TFhirObjectType(0)
  else
    result := TFhirObjectType(StringArrayIndexOf(CODES_TFhirObjectType, Type_.value));
end;

Procedure TFhirSecurityEventObject.SetType_ST(value : TFhirObjectType);
begin
  if ord(value) = 0 then
    Type_ := nil
  else
    Type_ := TFhirEnum.create(CODES_TFhirObjectType[value]);
end;

Procedure TFhirSecurityEventObject.SetRole(value : TFhirEnum);
begin
  FRole.free;
  FRole := value;
end;

Function TFhirSecurityEventObject.GetRoleST : TFhirObjectRole;
begin
  if FRole = nil then
    result := TFhirObjectRole(0)
  else
    result := TFhirObjectRole(StringArrayIndexOf(CODES_TFhirObjectRole, Role.value));
end;

Procedure TFhirSecurityEventObject.SetRoleST(value : TFhirObjectRole);
begin
  if ord(value) = 0 then
    Role := nil
  else
    Role := TFhirEnum.create(CODES_TFhirObjectRole[value]);
end;

Procedure TFhirSecurityEventObject.SetLifecycle(value : TFhirEnum);
begin
  FLifecycle.free;
  FLifecycle := value;
end;

Function TFhirSecurityEventObject.GetLifecycleST : TFhirObjectLifecycle;
begin
  if FLifecycle = nil then
    result := TFhirObjectLifecycle(0)
  else
    result := TFhirObjectLifecycle(StringArrayIndexOf(CODES_TFhirObjectLifecycle, Lifecycle.value));
end;

Procedure TFhirSecurityEventObject.SetLifecycleST(value : TFhirObjectLifecycle);
begin
  if ord(value) = 0 then
    Lifecycle := nil
  else
    Lifecycle := TFhirEnum.create(CODES_TFhirObjectLifecycle[value]);
end;

Procedure TFhirSecurityEventObject.SetSensitivity(value : TFhirCodeableConcept);
begin
  FSensitivity.free;
  FSensitivity := value;
end;

Procedure TFhirSecurityEventObject.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirSecurityEventObject.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := Name.value;
end;

Procedure TFhirSecurityEventObject.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirSecurityEventObject.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirSecurityEventObject.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := Description.value;
end;

Procedure TFhirSecurityEventObject.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirSecurityEventObject.SetQuery(value : TFhirBase64Binary);
begin
  FQuery.free;
  FQuery := value;
end;

Function TFhirSecurityEventObject.GetQueryST : String;
begin
  if FQuery = nil then
    result := ''
  else
    result := Query.value;
end;

Procedure TFhirSecurityEventObject.SetQueryST(value : String);
begin
  if value <> '' then
  begin
    if FQuery = nil then
      FQuery := TFhirBase64Binary.create;
    FQuery.value := value
  end
  else if FQuery <> nil then
    FQuery.value := '';
end;


{ TFhirSecurityEventObjectList }
procedure TFhirSecurityEventObjectList.AddItem(value: TFhirSecurityEventObject);
begin
  assert(value.ClassName = 'TFhirSecurityEventObject', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSecurityEventObject');
  add(value);
end;


function TFhirSecurityEventObjectList.Append: TFhirSecurityEventObject;
begin
  result := TFhirSecurityEventObject.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventObjectList.ClearItems;
begin
  Clear;
end;

function TFhirSecurityEventObjectList.Clone: TFhirSecurityEventObjectList;
begin
  result := TFhirSecurityEventObjectList(inherited Clone);
end;

function TFhirSecurityEventObjectList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSecurityEventObjectList.GetItemN(index: Integer): TFhirSecurityEventObject;
begin
  result := TFhirSecurityEventObject(ObjectByIndex[index]);
end;

function TFhirSecurityEventObjectList.IndexOf(value: TFhirSecurityEventObject): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSecurityEventObjectList.Insert(index: Integer): TFhirSecurityEventObject;
begin
  result := TFhirSecurityEventObject.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventObjectList.InsertItem(index: Integer; value: TFhirSecurityEventObject);
begin
  assert(value is TFhirSecurityEventObject);
  Inherited Insert(index, value);
end;

function TFhirSecurityEventObjectList.Item(index: Integer): TFhirSecurityEventObject;
begin
  result := TFhirSecurityEventObject(ObjectByIndex[index]);
end;

function TFhirSecurityEventObjectList.Link: TFhirSecurityEventObjectList;
begin
  result := TFhirSecurityEventObjectList(inherited Link);
end;

procedure TFhirSecurityEventObjectList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSecurityEventObjectList.SetItemByIndex(index: Integer; value: TFhirSecurityEventObject);
begin
  assert(value is TFhirSecurityEventObject);
  FhirSecurityEventObjects[index] := value;
end;

procedure TFhirSecurityEventObjectList.SetItemN(index: Integer; value: TFhirSecurityEventObject);
begin
  assert(value is TFhirSecurityEventObject);
  ObjectByIndex[index] := value;
end;

{ TFhirSecurityEventObjectDetail }

constructor TFhirSecurityEventObjectDetail.Create;
begin
  inherited;
end;

destructor TFhirSecurityEventObjectDetail.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirSecurityEventObjectDetail.Assign(oSource : TAdvObject);
begin
  inherited;
  type_ := TFhirSecurityEventObjectDetail(oSource).type_.Clone;
  value := TFhirSecurityEventObjectDetail(oSource).value.Clone;
end;

procedure TFhirSecurityEventObjectDetail.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'value') Then
     list.add(Value.Link);
end;

procedure TFhirSecurityEventObjectDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'string', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'base64Binary', FValue.Link.Link));{2}
end;

function TFhirSecurityEventObjectDetail.Link : TFhirSecurityEventObjectDetail;
begin
  result := TFhirSecurityEventObjectDetail(inherited Link);
end;

function TFhirSecurityEventObjectDetail.Clone : TFhirSecurityEventObjectDetail;
begin
  result := TFhirSecurityEventObjectDetail(inherited Clone);
end;

{ TFhirSecurityEventObjectDetail }

Procedure TFhirSecurityEventObjectDetail.SetType_(value : TFhirString);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirSecurityEventObjectDetail.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := Type_.value;
end;

Procedure TFhirSecurityEventObjectDetail.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirString.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirSecurityEventObjectDetail.SetValue(value : TFhirBase64Binary);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirSecurityEventObjectDetail.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := Value.value;
end;

Procedure TFhirSecurityEventObjectDetail.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirBase64Binary.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;


{ TFhirSecurityEventObjectDetailList }
procedure TFhirSecurityEventObjectDetailList.AddItem(value: TFhirSecurityEventObjectDetail);
begin
  assert(value.ClassName = 'TFhirSecurityEventObjectDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSecurityEventObjectDetail');
  add(value);
end;


function TFhirSecurityEventObjectDetailList.Append: TFhirSecurityEventObjectDetail;
begin
  result := TFhirSecurityEventObjectDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventObjectDetailList.ClearItems;
begin
  Clear;
end;

function TFhirSecurityEventObjectDetailList.Clone: TFhirSecurityEventObjectDetailList;
begin
  result := TFhirSecurityEventObjectDetailList(inherited Clone);
end;

function TFhirSecurityEventObjectDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSecurityEventObjectDetailList.GetItemN(index: Integer): TFhirSecurityEventObjectDetail;
begin
  result := TFhirSecurityEventObjectDetail(ObjectByIndex[index]);
end;

function TFhirSecurityEventObjectDetailList.IndexOf(value: TFhirSecurityEventObjectDetail): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSecurityEventObjectDetailList.Insert(index: Integer): TFhirSecurityEventObjectDetail;
begin
  result := TFhirSecurityEventObjectDetail.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventObjectDetailList.InsertItem(index: Integer; value: TFhirSecurityEventObjectDetail);
begin
  assert(value is TFhirSecurityEventObjectDetail);
  Inherited Insert(index, value);
end;

function TFhirSecurityEventObjectDetailList.Item(index: Integer): TFhirSecurityEventObjectDetail;
begin
  result := TFhirSecurityEventObjectDetail(ObjectByIndex[index]);
end;

function TFhirSecurityEventObjectDetailList.Link: TFhirSecurityEventObjectDetailList;
begin
  result := TFhirSecurityEventObjectDetailList(inherited Link);
end;

procedure TFhirSecurityEventObjectDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSecurityEventObjectDetailList.SetItemByIndex(index: Integer; value: TFhirSecurityEventObjectDetail);
begin
  assert(value is TFhirSecurityEventObjectDetail);
  FhirSecurityEventObjectDetails[index] := value;
end;

procedure TFhirSecurityEventObjectDetailList.SetItemN(index: Integer; value: TFhirSecurityEventObjectDetail);
begin
  assert(value is TFhirSecurityEventObjectDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimenSource }

constructor TFhirSpecimenSource.Create;
begin
  inherited;
  FTargetList := TFhirResourceReferenceList{TFhirSpecimen}.Create;
end;

destructor TFhirSpecimenSource.Destroy;
begin
  FRelationship.free;
  FTargetList.Free;
  inherited;
end;

procedure TFhirSpecimenSource.Assign(oSource : TAdvObject);
begin
  inherited;
  FRelationship := TFhirSpecimenSource(oSource).FRelationship.Link;
  FTargetList.Assign(TFhirSpecimenSource(oSource).FTargetList);
end;

procedure TFhirSpecimenSource.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'relationship') Then
     list.add(FRelationship.Link);
  if (child_name = 'target') Then
     list.addAll(FTargetList);
end;

procedure TFhirSpecimenSource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'relationship', 'code', FRelationship.Link));{1}
  oList.add(TFHIRProperty.create(self, 'target', 'Resource(Specimen)', FTargetList.Link)){3};
end;

function TFhirSpecimenSource.Link : TFhirSpecimenSource;
begin
  result := TFhirSpecimenSource(inherited Link);
end;

function TFhirSpecimenSource.Clone : TFhirSpecimenSource;
begin
  result := TFhirSpecimenSource(inherited Clone);
end;

{ TFhirSpecimenSource }

Procedure TFhirSpecimenSource.SetRelationship(value : TFhirEnum);
begin
  FRelationship.free;
  FRelationship := value;
end;

Function TFhirSpecimenSource.GetRelationshipST : TFhirHierarchicalRelationshipType;
begin
  if FRelationship = nil then
    result := TFhirHierarchicalRelationshipType(0)
  else
    result := TFhirHierarchicalRelationshipType(StringArrayIndexOf(CODES_TFhirHierarchicalRelationshipType, Relationship.value));
end;

Procedure TFhirSpecimenSource.SetRelationshipST(value : TFhirHierarchicalRelationshipType);
begin
  if ord(value) = 0 then
    Relationship := nil
  else
    Relationship := TFhirEnum.create(CODES_TFhirHierarchicalRelationshipType[value]);
end;


{ TFhirSpecimenSourceList }
procedure TFhirSpecimenSourceList.AddItem(value: TFhirSpecimenSource);
begin
  assert(value.ClassName = 'TFhirSpecimenSource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenSource');
  add(value);
end;


function TFhirSpecimenSourceList.Append: TFhirSpecimenSource;
begin
  result := TFhirSpecimenSource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSpecimenSourceList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenSourceList.Clone: TFhirSpecimenSourceList;
begin
  result := TFhirSpecimenSourceList(inherited Clone);
end;

function TFhirSpecimenSourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenSourceList.GetItemN(index: Integer): TFhirSpecimenSource;
begin
  result := TFhirSpecimenSource(ObjectByIndex[index]);
end;

function TFhirSpecimenSourceList.IndexOf(value: TFhirSpecimenSource): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSpecimenSourceList.Insert(index: Integer): TFhirSpecimenSource;
begin
  result := TFhirSpecimenSource.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSpecimenSourceList.InsertItem(index: Integer; value: TFhirSpecimenSource);
begin
  assert(value is TFhirSpecimenSource);
  Inherited Insert(index, value);
end;

function TFhirSpecimenSourceList.Item(index: Integer): TFhirSpecimenSource;
begin
  result := TFhirSpecimenSource(ObjectByIndex[index]);
end;

function TFhirSpecimenSourceList.Link: TFhirSpecimenSourceList;
begin
  result := TFhirSpecimenSourceList(inherited Link);
end;

procedure TFhirSpecimenSourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenSourceList.SetItemByIndex(index: Integer; value: TFhirSpecimenSource);
begin
  assert(value is TFhirSpecimenSource);
  FhirSpecimenSources[index] := value;
end;

procedure TFhirSpecimenSourceList.SetItemN(index: Integer; value: TFhirSpecimenSource);
begin
  assert(value is TFhirSpecimenSource);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimenCollection }

constructor TFhirSpecimenCollection.Create;
begin
  inherited;
  FCommentList := TFhirStringList.Create;
end;

destructor TFhirSpecimenCollection.Destroy;
begin
  FCollector.free;
  FCommentList.Free;
  FCollected.free;
  FQuantity.free;
  FMethod.free;
  FSourceSite.free;
  inherited;
end;

procedure TFhirSpecimenCollection.Assign(oSource : TAdvObject);
begin
  inherited;
  collector := TFhirSpecimenCollection(oSource).collector.Clone;
  FCommentList.Assign(TFhirSpecimenCollection(oSource).FCommentList);
  collected := TFhirSpecimenCollection(oSource).collected.Clone;
  quantity := TFhirSpecimenCollection(oSource).quantity.Clone;
  method := TFhirSpecimenCollection(oSource).method.Clone;
  sourceSite := TFhirSpecimenCollection(oSource).sourceSite.Clone;
end;

procedure TFhirSpecimenCollection.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'collector') Then
     list.add(Collector.Link);
  if (child_name = 'comment') Then
     list.addAll(FCommentList);
  if (child_name = 'collected') Then
     list.add(Collected.Link);
  if (child_name = 'quantity') Then
     list.add(Quantity.Link);
  if (child_name = 'method') Then
     list.add(Method.Link);
  if (child_name = 'sourceSite') Then
     list.add(SourceSite.Link);
end;

procedure TFhirSpecimenCollection.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'collector', 'Resource(Practitioner)', FCollector.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comment', 'string', FCommentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'collected[x]', 'dateTime|Period', FCollected.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', FMethod.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sourceSite', 'CodeableConcept', FSourceSite.Link.Link));{2}
end;

function TFhirSpecimenCollection.Link : TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(inherited Link);
end;

function TFhirSpecimenCollection.Clone : TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(inherited Clone);
end;

{ TFhirSpecimenCollection }

Procedure TFhirSpecimenCollection.SetCollector(value : TFhirResourceReference{TFhirPractitioner});
begin
  FCollector.free;
  FCollector := value;
end;

Procedure TFhirSpecimenCollection.SetCollected(value : TFhirType);
begin
  FCollected.free;
  FCollected := value;
end;

Procedure TFhirSpecimenCollection.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirSpecimenCollection.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirSpecimenCollection.SetSourceSite(value : TFhirCodeableConcept);
begin
  FSourceSite.free;
  FSourceSite := value;
end;


{ TFhirSpecimenCollectionList }
procedure TFhirSpecimenCollectionList.AddItem(value: TFhirSpecimenCollection);
begin
  assert(value.ClassName = 'TFhirSpecimenCollection', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenCollection');
  add(value);
end;


function TFhirSpecimenCollectionList.Append: TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSpecimenCollectionList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenCollectionList.Clone: TFhirSpecimenCollectionList;
begin
  result := TFhirSpecimenCollectionList(inherited Clone);
end;

function TFhirSpecimenCollectionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenCollectionList.GetItemN(index: Integer): TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(ObjectByIndex[index]);
end;

function TFhirSpecimenCollectionList.IndexOf(value: TFhirSpecimenCollection): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSpecimenCollectionList.Insert(index: Integer): TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSpecimenCollectionList.InsertItem(index: Integer; value: TFhirSpecimenCollection);
begin
  assert(value is TFhirSpecimenCollection);
  Inherited Insert(index, value);
end;

function TFhirSpecimenCollectionList.Item(index: Integer): TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(ObjectByIndex[index]);
end;

function TFhirSpecimenCollectionList.Link: TFhirSpecimenCollectionList;
begin
  result := TFhirSpecimenCollectionList(inherited Link);
end;

procedure TFhirSpecimenCollectionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenCollectionList.SetItemByIndex(index: Integer; value: TFhirSpecimenCollection);
begin
  assert(value is TFhirSpecimenCollection);
  FhirSpecimenCollections[index] := value;
end;

procedure TFhirSpecimenCollectionList.SetItemN(index: Integer; value: TFhirSpecimenCollection);
begin
  assert(value is TFhirSpecimenCollection);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimenTreatment }

constructor TFhirSpecimenTreatment.Create;
begin
  inherited;
  FAdditiveList := TFhirResourceReferenceList{TFhirSubstance}.Create;
end;

destructor TFhirSpecimenTreatment.Destroy;
begin
  FDescription.free;
  FProcedure_.free;
  FAdditiveList.Free;
  inherited;
end;

procedure TFhirSpecimenTreatment.Assign(oSource : TAdvObject);
begin
  inherited;
  description := TFhirSpecimenTreatment(oSource).description.Clone;
  procedure_ := TFhirSpecimenTreatment(oSource).procedure_.Clone;
  FAdditiveList.Assign(TFhirSpecimenTreatment(oSource).FAdditiveList);
end;

procedure TFhirSpecimenTreatment.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(Description.Link);
  if (child_name = 'procedure_') Then
     list.add(Procedure_.Link);
  if (child_name = 'additive') Then
     list.addAll(FAdditiveList);
end;

procedure TFhirSpecimenTreatment.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'procedure', 'CodeableConcept', FProcedure_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'additive', 'Resource(Substance)', FAdditiveList.Link)){3};
end;

function TFhirSpecimenTreatment.Link : TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment(inherited Link);
end;

function TFhirSpecimenTreatment.Clone : TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment(inherited Clone);
end;

{ TFhirSpecimenTreatment }

Procedure TFhirSpecimenTreatment.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirSpecimenTreatment.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := Description.value;
end;

Procedure TFhirSpecimenTreatment.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirSpecimenTreatment.SetProcedure_(value : TFhirCodeableConcept);
begin
  FProcedure_.free;
  FProcedure_ := value;
end;


{ TFhirSpecimenTreatmentList }
procedure TFhirSpecimenTreatmentList.AddItem(value: TFhirSpecimenTreatment);
begin
  assert(value.ClassName = 'TFhirSpecimenTreatment', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenTreatment');
  add(value);
end;


function TFhirSpecimenTreatmentList.Append: TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSpecimenTreatmentList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenTreatmentList.Clone: TFhirSpecimenTreatmentList;
begin
  result := TFhirSpecimenTreatmentList(inherited Clone);
end;

function TFhirSpecimenTreatmentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenTreatmentList.GetItemN(index: Integer): TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment(ObjectByIndex[index]);
end;

function TFhirSpecimenTreatmentList.IndexOf(value: TFhirSpecimenTreatment): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSpecimenTreatmentList.Insert(index: Integer): TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSpecimenTreatmentList.InsertItem(index: Integer; value: TFhirSpecimenTreatment);
begin
  assert(value is TFhirSpecimenTreatment);
  Inherited Insert(index, value);
end;

function TFhirSpecimenTreatmentList.Item(index: Integer): TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment(ObjectByIndex[index]);
end;

function TFhirSpecimenTreatmentList.Link: TFhirSpecimenTreatmentList;
begin
  result := TFhirSpecimenTreatmentList(inherited Link);
end;

procedure TFhirSpecimenTreatmentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenTreatmentList.SetItemByIndex(index: Integer; value: TFhirSpecimenTreatment);
begin
  assert(value is TFhirSpecimenTreatment);
  FhirSpecimenTreatments[index] := value;
end;

procedure TFhirSpecimenTreatmentList.SetItemN(index: Integer; value: TFhirSpecimenTreatment);
begin
  assert(value is TFhirSpecimenTreatment);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimenContainer }

constructor TFhirSpecimenContainer.Create;
begin
  inherited;
  FIdentifierList := TFhirIdentifierList.Create;
end;

destructor TFhirSpecimenContainer.Destroy;
begin
  FIdentifierList.Free;
  FDescription.free;
  FType_.free;
  FCapacity.free;
  FSpecimenQuantity.free;
  FAdditive.free;
  inherited;
end;

procedure TFhirSpecimenContainer.Assign(oSource : TAdvObject);
begin
  inherited;
  FIdentifierList.Assign(TFhirSpecimenContainer(oSource).FIdentifierList);
  description := TFhirSpecimenContainer(oSource).description.Clone;
  type_ := TFhirSpecimenContainer(oSource).type_.Clone;
  capacity := TFhirSpecimenContainer(oSource).capacity.Clone;
  specimenQuantity := TFhirSpecimenContainer(oSource).specimenQuantity.Clone;
  additive := TFhirSpecimenContainer(oSource).additive.Clone;
end;

procedure TFhirSpecimenContainer.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.addAll(FIdentifierList);
  if (child_name = 'description') Then
     list.add(Description.Link);
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'capacity') Then
     list.add(Capacity.Link);
  if (child_name = 'specimenQuantity') Then
     list.add(SpecimenQuantity.Link);
  if (child_name = 'additive') Then
     list.add(Additive.Link);
end;

procedure TFhirSpecimenContainer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'capacity', 'Quantity', FCapacity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'specimenQuantity', 'Quantity', FSpecimenQuantity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'additive', 'Resource(Substance)', FAdditive.Link.Link));{2}
end;

function TFhirSpecimenContainer.Link : TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(inherited Link);
end;

function TFhirSpecimenContainer.Clone : TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(inherited Clone);
end;

{ TFhirSpecimenContainer }

Procedure TFhirSpecimenContainer.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirSpecimenContainer.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := Description.value;
end;

Procedure TFhirSpecimenContainer.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirSpecimenContainer.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirSpecimenContainer.SetCapacity(value : TFhirQuantity);
begin
  FCapacity.free;
  FCapacity := value;
end;

Procedure TFhirSpecimenContainer.SetSpecimenQuantity(value : TFhirQuantity);
begin
  FSpecimenQuantity.free;
  FSpecimenQuantity := value;
end;

Procedure TFhirSpecimenContainer.SetAdditive(value : TFhirResourceReference{TFhirSubstance});
begin
  FAdditive.free;
  FAdditive := value;
end;


{ TFhirSpecimenContainerList }
procedure TFhirSpecimenContainerList.AddItem(value: TFhirSpecimenContainer);
begin
  assert(value.ClassName = 'TFhirSpecimenContainer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenContainer');
  add(value);
end;


function TFhirSpecimenContainerList.Append: TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSpecimenContainerList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenContainerList.Clone: TFhirSpecimenContainerList;
begin
  result := TFhirSpecimenContainerList(inherited Clone);
end;

function TFhirSpecimenContainerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenContainerList.GetItemN(index: Integer): TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(ObjectByIndex[index]);
end;

function TFhirSpecimenContainerList.IndexOf(value: TFhirSpecimenContainer): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSpecimenContainerList.Insert(index: Integer): TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSpecimenContainerList.InsertItem(index: Integer; value: TFhirSpecimenContainer);
begin
  assert(value is TFhirSpecimenContainer);
  Inherited Insert(index, value);
end;

function TFhirSpecimenContainerList.Item(index: Integer): TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(ObjectByIndex[index]);
end;

function TFhirSpecimenContainerList.Link: TFhirSpecimenContainerList;
begin
  result := TFhirSpecimenContainerList(inherited Link);
end;

procedure TFhirSpecimenContainerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenContainerList.SetItemByIndex(index: Integer; value: TFhirSpecimenContainer);
begin
  assert(value is TFhirSpecimenContainer);
  FhirSpecimenContainers[index] := value;
end;

procedure TFhirSpecimenContainerList.SetItemN(index: Integer; value: TFhirSpecimenContainer);
begin
  assert(value is TFhirSpecimenContainer);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceInstance }

constructor TFhirSubstanceInstance.Create;
begin
  inherited;
end;

destructor TFhirSubstanceInstance.Destroy;
begin
  FIdentifier.free;
  FExpiry.free;
  FQuantity.free;
  inherited;
end;

procedure TFhirSubstanceInstance.Assign(oSource : TAdvObject);
begin
  inherited;
  identifier := TFhirSubstanceInstance(oSource).identifier.Clone;
  expiry := TFhirSubstanceInstance(oSource).expiry.Clone;
  quantity := TFhirSubstanceInstance(oSource).quantity.Clone;
end;

procedure TFhirSubstanceInstance.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(Identifier.Link);
  if (child_name = 'expiry') Then
     list.add(Expiry.Link);
  if (child_name = 'quantity') Then
     list.add(Quantity.Link);
end;

procedure TFhirSubstanceInstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', FIdentifier.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expiry', 'dateTime', FExpiry.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link.Link));{2}
end;

function TFhirSubstanceInstance.Link : TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance(inherited Link);
end;

function TFhirSubstanceInstance.Clone : TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance(inherited Clone);
end;

{ TFhirSubstanceInstance }

Procedure TFhirSubstanceInstance.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirSubstanceInstance.SetExpiry(value : TFhirDateTime);
begin
  FExpiry.free;
  FExpiry := value;
end;

Function TFhirSubstanceInstance.GetExpiryST : TDateAndTime;
begin
  if FExpiry = nil then
    result := nil
  else
    result := Expiry.value;
end;

Procedure TFhirSubstanceInstance.SetExpiryST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FExpiry = nil then
      FExpiry := TFhirDateTime.create;
    FExpiry.value := value
  end
  else if FExpiry <> nil then
    FExpiry.value := nil;
end;

Procedure TFhirSubstanceInstance.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;


{ TFhirSubstanceInstanceList }
procedure TFhirSubstanceInstanceList.AddItem(value: TFhirSubstanceInstance);
begin
  assert(value.ClassName = 'TFhirSubstanceInstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceInstance');
  add(value);
end;


function TFhirSubstanceInstanceList.Append: TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSubstanceInstanceList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceInstanceList.Clone: TFhirSubstanceInstanceList;
begin
  result := TFhirSubstanceInstanceList(inherited Clone);
end;

function TFhirSubstanceInstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceInstanceList.GetItemN(index: Integer): TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance(ObjectByIndex[index]);
end;

function TFhirSubstanceInstanceList.IndexOf(value: TFhirSubstanceInstance): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSubstanceInstanceList.Insert(index: Integer): TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSubstanceInstanceList.InsertItem(index: Integer; value: TFhirSubstanceInstance);
begin
  assert(value is TFhirSubstanceInstance);
  Inherited Insert(index, value);
end;

function TFhirSubstanceInstanceList.Item(index: Integer): TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance(ObjectByIndex[index]);
end;

function TFhirSubstanceInstanceList.Link: TFhirSubstanceInstanceList;
begin
  result := TFhirSubstanceInstanceList(inherited Link);
end;

procedure TFhirSubstanceInstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceInstanceList.SetItemByIndex(index: Integer; value: TFhirSubstanceInstance);
begin
  assert(value is TFhirSubstanceInstance);
  FhirSubstanceInstances[index] := value;
end;

procedure TFhirSubstanceInstanceList.SetItemN(index: Integer; value: TFhirSubstanceInstance);
begin
  assert(value is TFhirSubstanceInstance);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceIngredient }

constructor TFhirSubstanceIngredient.Create;
begin
  inherited;
end;

destructor TFhirSubstanceIngredient.Destroy;
begin
  FQuantity.free;
  FSubstance.free;
  inherited;
end;

procedure TFhirSubstanceIngredient.Assign(oSource : TAdvObject);
begin
  inherited;
  quantity := TFhirSubstanceIngredient(oSource).quantity.Clone;
  substance := TFhirSubstanceIngredient(oSource).substance.Clone;
end;

procedure TFhirSubstanceIngredient.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'quantity') Then
     list.add(Quantity.Link);
  if (child_name = 'substance') Then
     list.add(Substance.Link);
end;

procedure TFhirSubstanceIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'quantity', 'Ratio', FQuantity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'substance', 'Resource(Substance)', FSubstance.Link.Link));{2}
end;

function TFhirSubstanceIngredient.Link : TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient(inherited Link);
end;

function TFhirSubstanceIngredient.Clone : TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient(inherited Clone);
end;

{ TFhirSubstanceIngredient }

Procedure TFhirSubstanceIngredient.SetQuantity(value : TFhirRatio);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirSubstanceIngredient.SetSubstance(value : TFhirResourceReference{TFhirSubstance});
begin
  FSubstance.free;
  FSubstance := value;
end;


{ TFhirSubstanceIngredientList }
procedure TFhirSubstanceIngredientList.AddItem(value: TFhirSubstanceIngredient);
begin
  assert(value.ClassName = 'TFhirSubstanceIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceIngredient');
  add(value);
end;


function TFhirSubstanceIngredientList.Append: TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSubstanceIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceIngredientList.Clone: TFhirSubstanceIngredientList;
begin
  result := TFhirSubstanceIngredientList(inherited Clone);
end;

function TFhirSubstanceIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceIngredientList.GetItemN(index: Integer): TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient(ObjectByIndex[index]);
end;

function TFhirSubstanceIngredientList.IndexOf(value: TFhirSubstanceIngredient): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSubstanceIngredientList.Insert(index: Integer): TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSubstanceIngredientList.InsertItem(index: Integer; value: TFhirSubstanceIngredient);
begin
  assert(value is TFhirSubstanceIngredient);
  Inherited Insert(index, value);
end;

function TFhirSubstanceIngredientList.Item(index: Integer): TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient(ObjectByIndex[index]);
end;

function TFhirSubstanceIngredientList.Link: TFhirSubstanceIngredientList;
begin
  result := TFhirSubstanceIngredientList(inherited Link);
end;

procedure TFhirSubstanceIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceIngredientList.SetItemByIndex(index: Integer; value: TFhirSubstanceIngredient);
begin
  assert(value is TFhirSubstanceIngredient);
  FhirSubstanceIngredients[index] := value;
end;

procedure TFhirSubstanceIngredientList.SetItemN(index: Integer; value: TFhirSubstanceIngredient);
begin
  assert(value is TFhirSubstanceIngredient);
  ObjectByIndex[index] := value;
end;

{ TFhirSupplyDispense }

constructor TFhirSupplyDispense.Create;
begin
  inherited;
  FReceiverList := TFhirResourceReferenceList{TFhirPractitioner}.Create;
end;

destructor TFhirSupplyDispense.Destroy;
begin
  FIdentifier.free;
  FStatus.free;
  FType_.free;
  FQuantity.free;
  FSuppliedItem.free;
  FSupplier.free;
  FWhenPrepared.free;
  FWhenHandedOver.free;
  FDestination.free;
  FReceiverList.Free;
  inherited;
end;

procedure TFhirSupplyDispense.Assign(oSource : TAdvObject);
begin
  inherited;
  identifier := TFhirSupplyDispense(oSource).identifier.Clone;
  FStatus := TFhirSupplyDispense(oSource).FStatus.Link;
  type_ := TFhirSupplyDispense(oSource).type_.Clone;
  quantity := TFhirSupplyDispense(oSource).quantity.Clone;
  suppliedItem := TFhirSupplyDispense(oSource).suppliedItem.Clone;
  supplier := TFhirSupplyDispense(oSource).supplier.Clone;
  whenPrepared := TFhirSupplyDispense(oSource).whenPrepared.Clone;
  whenHandedOver := TFhirSupplyDispense(oSource).whenHandedOver.Clone;
  destination := TFhirSupplyDispense(oSource).destination.Clone;
  FReceiverList.Assign(TFhirSupplyDispense(oSource).FReceiverList);
end;

procedure TFhirSupplyDispense.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(Identifier.Link);
  if (child_name = 'status') Then
     list.add(FStatus.Link);
  if (child_name = 'type_') Then
     list.add(Type_.Link);
  if (child_name = 'quantity') Then
     list.add(Quantity.Link);
  if (child_name = 'suppliedItem') Then
     list.add(SuppliedItem.Link);
  if (child_name = 'supplier') Then
     list.add(Supplier.Link);
  if (child_name = 'whenPrepared') Then
     list.add(WhenPrepared.Link);
  if (child_name = 'whenHandedOver') Then
     list.add(WhenHandedOver.Link);
  if (child_name = 'destination') Then
     list.add(Destination.Link);
  if (child_name = 'receiver') Then
     list.addAll(FReceiverList);
end;

procedure TFhirSupplyDispense.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', FIdentifier.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'suppliedItem', 'Resource(Medication|Substance|Device)', FSuppliedItem.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'supplier', 'Resource(Practitioner)', FSupplier.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'whenPrepared', 'Period', FWhenPrepared.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'whenHandedOver', 'Period', FWhenHandedOver.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'destination', 'Resource(Location)', FDestination.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'receiver', 'Resource(Practitioner)', FReceiverList.Link)){3};
end;

function TFhirSupplyDispense.Link : TFhirSupplyDispense;
begin
  result := TFhirSupplyDispense(inherited Link);
end;

function TFhirSupplyDispense.Clone : TFhirSupplyDispense;
begin
  result := TFhirSupplyDispense(inherited Clone);
end;

{ TFhirSupplyDispense }

Procedure TFhirSupplyDispense.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirSupplyDispense.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirSupplyDispense.GetStatusST : TFhirValuesetSupplyDispenseStatus;
begin
  if FStatus = nil then
    result := TFhirValuesetSupplyDispenseStatus(0)
  else
    result := TFhirValuesetSupplyDispenseStatus(StringArrayIndexOf(CODES_TFhirValuesetSupplyDispenseStatus, Status.value));
end;

Procedure TFhirSupplyDispense.SetStatusST(value : TFhirValuesetSupplyDispenseStatus);
begin
  if ord(value) = 0 then
    Status := nil
  else
    Status := TFhirEnum.create(CODES_TFhirValuesetSupplyDispenseStatus[value]);
end;

Procedure TFhirSupplyDispense.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirSupplyDispense.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirSupplyDispense.SetSuppliedItem(value : TFhirResourceReference{Resource});
begin
  FSuppliedItem.free;
  FSuppliedItem := value;
end;

Procedure TFhirSupplyDispense.SetSupplier(value : TFhirResourceReference{TFhirPractitioner});
begin
  FSupplier.free;
  FSupplier := value;
end;

Procedure TFhirSupplyDispense.SetWhenPrepared(value : TFhirPeriod);
begin
  FWhenPrepared.free;
  FWhenPrepared := value;
end;

Procedure TFhirSupplyDispense.SetWhenHandedOver(value : TFhirPeriod);
begin
  FWhenHandedOver.free;
  FWhenHandedOver := value;
end;

Procedure TFhirSupplyDispense.SetDestination(value : TFhirResourceReference{TFhirLocation});
begin
  FDestination.free;
  FDestination := value;
end;


{ TFhirSupplyDispenseList }
procedure TFhirSupplyDispenseList.AddItem(value: TFhirSupplyDispense);
begin
  assert(value.ClassName = 'TFhirSupplyDispense', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSupplyDispense');
  add(value);
end;


function TFhirSupplyDispenseList.Append: TFhirSupplyDispense;
begin
  result := TFhirSupplyDispense.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSupplyDispenseList.ClearItems;
begin
  Clear;
end;

function TFhirSupplyDispenseList.Clone: TFhirSupplyDispenseList;
begin
  result := TFhirSupplyDispenseList(inherited Clone);
end;

function TFhirSupplyDispenseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSupplyDispenseList.GetItemN(index: Integer): TFhirSupplyDispense;
begin
  result := TFhirSupplyDispense(ObjectByIndex[index]);
end;

function TFhirSupplyDispenseList.IndexOf(value: TFhirSupplyDispense): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSupplyDispenseList.Insert(index: Integer): TFhirSupplyDispense;
begin
  result := TFhirSupplyDispense.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSupplyDispenseList.InsertItem(index: Integer; value: TFhirSupplyDispense);
begin
  assert(value is TFhirSupplyDispense);
  Inherited Insert(index, value);
end;

function TFhirSupplyDispenseList.Item(index: Integer): TFhirSupplyDispense;
begin
  result := TFhirSupplyDispense(ObjectByIndex[index]);
end;

function TFhirSupplyDispenseList.Link: TFhirSupplyDispenseList;
begin
  result := TFhirSupplyDispenseList(inherited Link);
end;

procedure TFhirSupplyDispenseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSupplyDispenseList.SetItemByIndex(index: Integer; value: TFhirSupplyDispense);
begin
  assert(value is TFhirSupplyDispense);
  FhirSupplyDispenses[index] := value;
end;

procedure TFhirSupplyDispenseList.SetItemN(index: Integer; value: TFhirSupplyDispense);
begin
  assert(value is TFhirSupplyDispense);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetDefine }

constructor TFhirValueSetDefine.Create;
begin
  inherited;
  FConceptList := TFhirValueSetDefineConceptList.Create;
end;

destructor TFhirValueSetDefine.Destroy;
begin
  FSystem.free;
  FVersion.free;
  FCaseSensitive.free;
  FConceptList.Free;
  inherited;
end;

procedure TFhirValueSetDefine.Assign(oSource : TAdvObject);
begin
  inherited;
  system := TFhirValueSetDefine(oSource).system.Clone;
  version := TFhirValueSetDefine(oSource).version.Clone;
  caseSensitive := TFhirValueSetDefine(oSource).caseSensitive.Clone;
  FConceptList.Assign(TFhirValueSetDefine(oSource).FConceptList);
end;

procedure TFhirValueSetDefine.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'system') Then
     list.add(System.Link);
  if (child_name = 'version') Then
     list.add(Version.Link);
  if (child_name = 'caseSensitive') Then
     list.add(CaseSensitive.Link);
  if (child_name = 'concept') Then
     list.addAll(FConceptList);
end;

procedure TFhirValueSetDefine.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'system', 'uri', FSystem.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', FVersion.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'caseSensitive', 'boolean', FCaseSensitive.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'concept', '', FConceptList.Link)){3};
end;

function TFhirValueSetDefine.Link : TFhirValueSetDefine;
begin
  result := TFhirValueSetDefine(inherited Link);
end;

function TFhirValueSetDefine.Clone : TFhirValueSetDefine;
begin
  result := TFhirValueSetDefine(inherited Clone);
end;

{ TFhirValueSetDefine }

Procedure TFhirValueSetDefine.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirValueSetDefine.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := System.value;
end;

Procedure TFhirValueSetDefine.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirValueSetDefine.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirValueSetDefine.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := Version.value;
end;

Procedure TFhirValueSetDefine.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirValueSetDefine.SetCaseSensitive(value : TFhirBoolean);
begin
  FCaseSensitive.free;
  FCaseSensitive := value;
end;

Function TFhirValueSetDefine.GetCaseSensitiveST : Boolean;
begin
  if FCaseSensitive = nil then
    result := false
  else
    result := CaseSensitive.value;
end;

Procedure TFhirValueSetDefine.SetCaseSensitiveST(value : Boolean);
begin
  if FCaseSensitive = nil then
    FCaseSensitive := TFhirBoolean.create;
  FCaseSensitive.value := value
end;


{ TFhirValueSetDefineList }
procedure TFhirValueSetDefineList.AddItem(value: TFhirValueSetDefine);
begin
  assert(value.ClassName = 'TFhirValueSetDefine', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetDefine');
  add(value);
end;


function TFhirValueSetDefineList.Append: TFhirValueSetDefine;
begin
  result := TFhirValueSetDefine.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetDefineList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetDefineList.Clone: TFhirValueSetDefineList;
begin
  result := TFhirValueSetDefineList(inherited Clone);
end;

function TFhirValueSetDefineList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetDefineList.GetItemN(index: Integer): TFhirValueSetDefine;
begin
  result := TFhirValueSetDefine(ObjectByIndex[index]);
end;

function TFhirValueSetDefineList.IndexOf(value: TFhirValueSetDefine): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirValueSetDefineList.Insert(index: Integer): TFhirValueSetDefine;
begin
  result := TFhirValueSetDefine.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetDefineList.InsertItem(index: Integer; value: TFhirValueSetDefine);
begin
  assert(value is TFhirValueSetDefine);
  Inherited Insert(index, value);
end;

function TFhirValueSetDefineList.Item(index: Integer): TFhirValueSetDefine;
begin
  result := TFhirValueSetDefine(ObjectByIndex[index]);
end;

function TFhirValueSetDefineList.Link: TFhirValueSetDefineList;
begin
  result := TFhirValueSetDefineList(inherited Link);
end;

procedure TFhirValueSetDefineList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetDefineList.SetItemByIndex(index: Integer; value: TFhirValueSetDefine);
begin
  assert(value is TFhirValueSetDefine);
  FhirValueSetDefines[index] := value;
end;

procedure TFhirValueSetDefineList.SetItemN(index: Integer; value: TFhirValueSetDefine);
begin
  assert(value is TFhirValueSetDefine);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetDefineConcept }

constructor TFhirValueSetDefineConcept.Create;
begin
  inherited;
  FConceptList := TFhirValueSetDefineConceptList.Create;
end;

destructor TFhirValueSetDefineConcept.Destroy;
begin
  FCode.free;
  FAbstract.free;
  FDisplay.free;
  FDefinition.free;
  FConceptList.Free;
  inherited;
end;

procedure TFhirValueSetDefineConcept.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirValueSetDefineConcept(oSource).code.Clone;
  abstract := TFhirValueSetDefineConcept(oSource).abstract.Clone;
  display := TFhirValueSetDefineConcept(oSource).display.Clone;
  definition := TFhirValueSetDefineConcept(oSource).definition.Clone;
  FConceptList.Assign(TFhirValueSetDefineConcept(oSource).FConceptList);
end;

procedure TFhirValueSetDefineConcept.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'abstract') Then
     list.add(Abstract.Link);
  if (child_name = 'display') Then
     list.add(Display.Link);
  if (child_name = 'definition') Then
     list.add(Definition.Link);
  if (child_name = 'concept') Then
     list.addAll(FConceptList);
end;

procedure TFhirValueSetDefineConcept.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'abstract', 'boolean', FAbstract.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', FDisplay.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'definition', 'string', FDefinition.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'concept', '@ValueSet.define.concept', FConceptList.Link)){3};
end;

function TFhirValueSetDefineConcept.Link : TFhirValueSetDefineConcept;
begin
  result := TFhirValueSetDefineConcept(inherited Link);
end;

function TFhirValueSetDefineConcept.Clone : TFhirValueSetDefineConcept;
begin
  result := TFhirValueSetDefineConcept(inherited Clone);
end;

{ TFhirValueSetDefineConcept }

Procedure TFhirValueSetDefineConcept.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirValueSetDefineConcept.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := Code.value;
end;

Procedure TFhirValueSetDefineConcept.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirValueSetDefineConcept.SetAbstract(value : TFhirBoolean);
begin
  FAbstract.free;
  FAbstract := value;
end;

Function TFhirValueSetDefineConcept.GetAbstractST : Boolean;
begin
  if FAbstract = nil then
    result := false
  else
    result := Abstract.value;
end;

Procedure TFhirValueSetDefineConcept.SetAbstractST(value : Boolean);
begin
  if FAbstract = nil then
    FAbstract := TFhirBoolean.create;
  FAbstract.value := value
end;

Procedure TFhirValueSetDefineConcept.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirValueSetDefineConcept.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := Display.value;
end;

Procedure TFhirValueSetDefineConcept.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

Procedure TFhirValueSetDefineConcept.SetDefinition(value : TFhirString);
begin
  FDefinition.free;
  FDefinition := value;
end;

Function TFhirValueSetDefineConcept.GetDefinitionST : String;
begin
  if FDefinition = nil then
    result := ''
  else
    result := Definition.value;
end;

Procedure TFhirValueSetDefineConcept.SetDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FDefinition = nil then
      FDefinition := TFhirString.create;
    FDefinition.value := value
  end
  else if FDefinition <> nil then
    FDefinition.value := '';
end;


{ TFhirValueSetDefineConceptList }
procedure TFhirValueSetDefineConceptList.AddItem(value: TFhirValueSetDefineConcept);
begin
  assert(value.ClassName = 'TFhirValueSetDefineConcept', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetDefineConcept');
  add(value);
end;


function TFhirValueSetDefineConceptList.Append: TFhirValueSetDefineConcept;
begin
  result := TFhirValueSetDefineConcept.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetDefineConceptList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetDefineConceptList.Clone: TFhirValueSetDefineConceptList;
begin
  result := TFhirValueSetDefineConceptList(inherited Clone);
end;

function TFhirValueSetDefineConceptList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetDefineConceptList.GetItemN(index: Integer): TFhirValueSetDefineConcept;
begin
  result := TFhirValueSetDefineConcept(ObjectByIndex[index]);
end;

function TFhirValueSetDefineConceptList.IndexOf(value: TFhirValueSetDefineConcept): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirValueSetDefineConceptList.Insert(index: Integer): TFhirValueSetDefineConcept;
begin
  result := TFhirValueSetDefineConcept.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetDefineConceptList.InsertItem(index: Integer; value: TFhirValueSetDefineConcept);
begin
  assert(value is TFhirValueSetDefineConcept);
  Inherited Insert(index, value);
end;

function TFhirValueSetDefineConceptList.Item(index: Integer): TFhirValueSetDefineConcept;
begin
  result := TFhirValueSetDefineConcept(ObjectByIndex[index]);
end;

function TFhirValueSetDefineConceptList.Link: TFhirValueSetDefineConceptList;
begin
  result := TFhirValueSetDefineConceptList(inherited Link);
end;

procedure TFhirValueSetDefineConceptList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetDefineConceptList.SetItemByIndex(index: Integer; value: TFhirValueSetDefineConcept);
begin
  assert(value is TFhirValueSetDefineConcept);
  FhirValueSetDefineConcepts[index] := value;
end;

procedure TFhirValueSetDefineConceptList.SetItemN(index: Integer; value: TFhirValueSetDefineConcept);
begin
  assert(value is TFhirValueSetDefineConcept);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetCompose }

constructor TFhirValueSetCompose.Create;
begin
  inherited;
  FImportList := TFhirUriList.Create;
  FIncludeList := TFhirValueSetComposeIncludeList.Create;
  FExcludeList := TFhirValueSetComposeIncludeList.Create;
end;

destructor TFhirValueSetCompose.Destroy;
begin
  FImportList.Free;
  FIncludeList.Free;
  FExcludeList.Free;
  inherited;
end;

procedure TFhirValueSetCompose.Assign(oSource : TAdvObject);
begin
  inherited;
  FImportList.Assign(TFhirValueSetCompose(oSource).FImportList);
  FIncludeList.Assign(TFhirValueSetCompose(oSource).FIncludeList);
  FExcludeList.Assign(TFhirValueSetCompose(oSource).FExcludeList);
end;

procedure TFhirValueSetCompose.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'import') Then
     list.addAll(FImportList);
  if (child_name = 'include') Then
     list.addAll(FIncludeList);
  if (child_name = 'exclude') Then
     list.addAll(FExcludeList);
end;

procedure TFhirValueSetCompose.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'import', 'uri', FImportList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'include', '', FIncludeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'exclude', '@ValueSet.compose.include', FExcludeList.Link)){3};
end;

function TFhirValueSetCompose.Link : TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose(inherited Link);
end;

function TFhirValueSetCompose.Clone : TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose(inherited Clone);
end;

{ TFhirValueSetCompose }


{ TFhirValueSetComposeList }
procedure TFhirValueSetComposeList.AddItem(value: TFhirValueSetCompose);
begin
  assert(value.ClassName = 'TFhirValueSetCompose', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetCompose');
  add(value);
end;


function TFhirValueSetComposeList.Append: TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetComposeList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetComposeList.Clone: TFhirValueSetComposeList;
begin
  result := TFhirValueSetComposeList(inherited Clone);
end;

function TFhirValueSetComposeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetComposeList.GetItemN(index: Integer): TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose(ObjectByIndex[index]);
end;

function TFhirValueSetComposeList.IndexOf(value: TFhirValueSetCompose): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirValueSetComposeList.Insert(index: Integer): TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetComposeList.InsertItem(index: Integer; value: TFhirValueSetCompose);
begin
  assert(value is TFhirValueSetCompose);
  Inherited Insert(index, value);
end;

function TFhirValueSetComposeList.Item(index: Integer): TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose(ObjectByIndex[index]);
end;

function TFhirValueSetComposeList.Link: TFhirValueSetComposeList;
begin
  result := TFhirValueSetComposeList(inherited Link);
end;

procedure TFhirValueSetComposeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetComposeList.SetItemByIndex(index: Integer; value: TFhirValueSetCompose);
begin
  assert(value is TFhirValueSetCompose);
  FhirValueSetComposes[index] := value;
end;

procedure TFhirValueSetComposeList.SetItemN(index: Integer; value: TFhirValueSetCompose);
begin
  assert(value is TFhirValueSetCompose);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetComposeInclude }

constructor TFhirValueSetComposeInclude.Create;
begin
  inherited;
  FCodeList := TFhirCodeList.Create;
  FFilterList := TFhirValueSetComposeIncludeFilterList.Create;
end;

destructor TFhirValueSetComposeInclude.Destroy;
begin
  FSystem.free;
  FVersion.free;
  FCodeList.Free;
  FFilterList.Free;
  inherited;
end;

procedure TFhirValueSetComposeInclude.Assign(oSource : TAdvObject);
begin
  inherited;
  system := TFhirValueSetComposeInclude(oSource).system.Clone;
  version := TFhirValueSetComposeInclude(oSource).version.Clone;
  FCodeList.Assign(TFhirValueSetComposeInclude(oSource).FCodeList);
  FFilterList.Assign(TFhirValueSetComposeInclude(oSource).FFilterList);
end;

procedure TFhirValueSetComposeInclude.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'system') Then
     list.add(System.Link);
  if (child_name = 'version') Then
     list.add(Version.Link);
  if (child_name = 'code') Then
     list.addAll(FCodeList);
  if (child_name = 'filter') Then
     list.addAll(FFilterList);
end;

procedure TFhirValueSetComposeInclude.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'system', 'uri', FSystem.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', FVersion.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'filter', '', FFilterList.Link)){3};
end;

function TFhirValueSetComposeInclude.Link : TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude(inherited Link);
end;

function TFhirValueSetComposeInclude.Clone : TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude(inherited Clone);
end;

{ TFhirValueSetComposeInclude }

Procedure TFhirValueSetComposeInclude.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirValueSetComposeInclude.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := System.value;
end;

Procedure TFhirValueSetComposeInclude.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirValueSetComposeInclude.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirValueSetComposeInclude.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := Version.value;
end;

Procedure TFhirValueSetComposeInclude.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;


{ TFhirValueSetComposeIncludeList }
procedure TFhirValueSetComposeIncludeList.AddItem(value: TFhirValueSetComposeInclude);
begin
  assert(value.ClassName = 'TFhirValueSetComposeInclude', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetComposeInclude');
  add(value);
end;


function TFhirValueSetComposeIncludeList.Append: TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetComposeIncludeList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetComposeIncludeList.Clone: TFhirValueSetComposeIncludeList;
begin
  result := TFhirValueSetComposeIncludeList(inherited Clone);
end;

function TFhirValueSetComposeIncludeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetComposeIncludeList.GetItemN(index: Integer): TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeList.IndexOf(value: TFhirValueSetComposeInclude): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirValueSetComposeIncludeList.Insert(index: Integer): TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetComposeIncludeList.InsertItem(index: Integer; value: TFhirValueSetComposeInclude);
begin
  assert(value is TFhirValueSetComposeInclude);
  Inherited Insert(index, value);
end;

function TFhirValueSetComposeIncludeList.Item(index: Integer): TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeList.Link: TFhirValueSetComposeIncludeList;
begin
  result := TFhirValueSetComposeIncludeList(inherited Link);
end;

procedure TFhirValueSetComposeIncludeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetComposeIncludeList.SetItemByIndex(index: Integer; value: TFhirValueSetComposeInclude);
begin
  assert(value is TFhirValueSetComposeInclude);
  FhirValueSetComposeIncludes[index] := value;
end;

procedure TFhirValueSetComposeIncludeList.SetItemN(index: Integer; value: TFhirValueSetComposeInclude);
begin
  assert(value is TFhirValueSetComposeInclude);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetComposeIncludeFilter }

constructor TFhirValueSetComposeIncludeFilter.Create;
begin
  inherited;
end;

destructor TFhirValueSetComposeIncludeFilter.Destroy;
begin
  FProperty_.free;
  FOp.free;
  FValue.free;
  inherited;
end;

procedure TFhirValueSetComposeIncludeFilter.Assign(oSource : TAdvObject);
begin
  inherited;
  property_ := TFhirValueSetComposeIncludeFilter(oSource).property_.Clone;
  FOp := TFhirValueSetComposeIncludeFilter(oSource).FOp.Link;
  value := TFhirValueSetComposeIncludeFilter(oSource).value.Clone;
end;

procedure TFhirValueSetComposeIncludeFilter.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'property_') Then
     list.add(Property_.Link);
  if (child_name = 'op') Then
     list.add(FOp.Link);
  if (child_name = 'value') Then
     list.add(Value.Link);
end;

procedure TFhirValueSetComposeIncludeFilter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'property', 'code', FProperty_.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'op', 'code', FOp.Link));{1}
  oList.add(TFHIRProperty.create(self, 'value', 'code', FValue.Link.Link));{2}
end;

function TFhirValueSetComposeIncludeFilter.Link : TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter(inherited Link);
end;

function TFhirValueSetComposeIncludeFilter.Clone : TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter(inherited Clone);
end;

{ TFhirValueSetComposeIncludeFilter }

Procedure TFhirValueSetComposeIncludeFilter.SetProperty_(value : TFhirCode);
begin
  FProperty_.free;
  FProperty_ := value;
end;

Function TFhirValueSetComposeIncludeFilter.GetProperty_ST : String;
begin
  if FProperty_ = nil then
    result := ''
  else
    result := Property_.value;
end;

Procedure TFhirValueSetComposeIncludeFilter.SetProperty_ST(value : String);
begin
  if value <> '' then
  begin
    if FProperty_ = nil then
      FProperty_ := TFhirCode.create;
    FProperty_.value := value
  end
  else if FProperty_ <> nil then
    FProperty_.value := '';
end;

Procedure TFhirValueSetComposeIncludeFilter.SetOp(value : TFhirEnum);
begin
  FOp.free;
  FOp := value;
end;

Function TFhirValueSetComposeIncludeFilter.GetOpST : TFhirFilterOperator;
begin
  if FOp = nil then
    result := TFhirFilterOperator(0)
  else
    result := TFhirFilterOperator(StringArrayIndexOf(CODES_TFhirFilterOperator, Op.value));
end;

Procedure TFhirValueSetComposeIncludeFilter.SetOpST(value : TFhirFilterOperator);
begin
  if ord(value) = 0 then
    Op := nil
  else
    Op := TFhirEnum.create(CODES_TFhirFilterOperator[value]);
end;

Procedure TFhirValueSetComposeIncludeFilter.SetValue(value : TFhirCode);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirValueSetComposeIncludeFilter.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := Value.value;
end;

Procedure TFhirValueSetComposeIncludeFilter.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirCode.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;


{ TFhirValueSetComposeIncludeFilterList }
procedure TFhirValueSetComposeIncludeFilterList.AddItem(value: TFhirValueSetComposeIncludeFilter);
begin
  assert(value.ClassName = 'TFhirValueSetComposeIncludeFilter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetComposeIncludeFilter');
  add(value);
end;


function TFhirValueSetComposeIncludeFilterList.Append: TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetComposeIncludeFilterList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetComposeIncludeFilterList.Clone: TFhirValueSetComposeIncludeFilterList;
begin
  result := TFhirValueSetComposeIncludeFilterList(inherited Clone);
end;

function TFhirValueSetComposeIncludeFilterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetComposeIncludeFilterList.GetItemN(index: Integer): TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeFilterList.IndexOf(value: TFhirValueSetComposeIncludeFilter): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirValueSetComposeIncludeFilterList.Insert(index: Integer): TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetComposeIncludeFilterList.InsertItem(index: Integer; value: TFhirValueSetComposeIncludeFilter);
begin
  assert(value is TFhirValueSetComposeIncludeFilter);
  Inherited Insert(index, value);
end;

function TFhirValueSetComposeIncludeFilterList.Item(index: Integer): TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeFilterList.Link: TFhirValueSetComposeIncludeFilterList;
begin
  result := TFhirValueSetComposeIncludeFilterList(inherited Link);
end;

procedure TFhirValueSetComposeIncludeFilterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetComposeIncludeFilterList.SetItemByIndex(index: Integer; value: TFhirValueSetComposeIncludeFilter);
begin
  assert(value is TFhirValueSetComposeIncludeFilter);
  FhirValueSetComposeIncludeFilters[index] := value;
end;

procedure TFhirValueSetComposeIncludeFilterList.SetItemN(index: Integer; value: TFhirValueSetComposeIncludeFilter);
begin
  assert(value is TFhirValueSetComposeIncludeFilter);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetExpansion }

constructor TFhirValueSetExpansion.Create;
begin
  inherited;
  FContainsList := TFhirValueSetExpansionContainsList.Create;
end;

destructor TFhirValueSetExpansion.Destroy;
begin
  FIdentifier.free;
  FTimestamp.free;
  FContainsList.Free;
  inherited;
end;

procedure TFhirValueSetExpansion.Assign(oSource : TAdvObject);
begin
  inherited;
  identifier := TFhirValueSetExpansion(oSource).identifier.Clone;
  timestamp := TFhirValueSetExpansion(oSource).timestamp.Clone;
  FContainsList.Assign(TFhirValueSetExpansion(oSource).FContainsList);
end;

procedure TFhirValueSetExpansion.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(Identifier.Link);
  if (child_name = 'timestamp') Then
     list.add(Timestamp.Link);
  if (child_name = 'contains') Then
     list.addAll(FContainsList);
end;

procedure TFhirValueSetExpansion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', FIdentifier.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timestamp', 'instant', FTimestamp.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contains', '', FContainsList.Link)){3};
end;

function TFhirValueSetExpansion.Link : TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion(inherited Link);
end;

function TFhirValueSetExpansion.Clone : TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion(inherited Clone);
end;

{ TFhirValueSetExpansion }

Procedure TFhirValueSetExpansion.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirValueSetExpansion.SetTimestamp(value : TFhirInstant);
begin
  FTimestamp.free;
  FTimestamp := value;
end;

Function TFhirValueSetExpansion.GetTimestampST : TDateAndTime;
begin
  if FTimestamp = nil then
    result := nil
  else
    result := Timestamp.value;
end;

Procedure TFhirValueSetExpansion.SetTimestampST(value : TDateAndTime);
begin
  if value <> nil then
  begin
    if FTimestamp = nil then
      FTimestamp := TFhirInstant.create;
    FTimestamp.value := value
  end
  else if FTimestamp <> nil then
    FTimestamp.value := nil;
end;


{ TFhirValueSetExpansionList }
procedure TFhirValueSetExpansionList.AddItem(value: TFhirValueSetExpansion);
begin
  assert(value.ClassName = 'TFhirValueSetExpansion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetExpansion');
  add(value);
end;


function TFhirValueSetExpansionList.Append: TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetExpansionList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetExpansionList.Clone: TFhirValueSetExpansionList;
begin
  result := TFhirValueSetExpansionList(inherited Clone);
end;

function TFhirValueSetExpansionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetExpansionList.GetItemN(index: Integer): TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionList.IndexOf(value: TFhirValueSetExpansion): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirValueSetExpansionList.Insert(index: Integer): TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetExpansionList.InsertItem(index: Integer; value: TFhirValueSetExpansion);
begin
  assert(value is TFhirValueSetExpansion);
  Inherited Insert(index, value);
end;

function TFhirValueSetExpansionList.Item(index: Integer): TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionList.Link: TFhirValueSetExpansionList;
begin
  result := TFhirValueSetExpansionList(inherited Link);
end;

procedure TFhirValueSetExpansionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetExpansionList.SetItemByIndex(index: Integer; value: TFhirValueSetExpansion);
begin
  assert(value is TFhirValueSetExpansion);
  FhirValueSetExpansions[index] := value;
end;

procedure TFhirValueSetExpansionList.SetItemN(index: Integer; value: TFhirValueSetExpansion);
begin
  assert(value is TFhirValueSetExpansion);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetExpansionContains }

constructor TFhirValueSetExpansionContains.Create;
begin
  inherited;
  FContainsList := TFhirValueSetExpansionContainsList.Create;
end;

destructor TFhirValueSetExpansionContains.Destroy;
begin
  FSystem.free;
  FCode.free;
  FDisplay.free;
  FContainsList.Free;
  inherited;
end;

procedure TFhirValueSetExpansionContains.Assign(oSource : TAdvObject);
begin
  inherited;
  system := TFhirValueSetExpansionContains(oSource).system.Clone;
  code := TFhirValueSetExpansionContains(oSource).code.Clone;
  display := TFhirValueSetExpansionContains(oSource).display.Clone;
  FContainsList.Assign(TFhirValueSetExpansionContains(oSource).FContainsList);
end;

procedure TFhirValueSetExpansionContains.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'system') Then
     list.add(System.Link);
  if (child_name = 'code') Then
     list.add(Code.Link);
  if (child_name = 'display') Then
     list.add(Display.Link);
  if (child_name = 'contains') Then
     list.addAll(FContainsList);
end;

procedure TFhirValueSetExpansionContains.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'system', 'uri', FSystem.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', FDisplay.Link.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contains', '@ValueSet.expansion.contains', FContainsList.Link)){3};
end;

function TFhirValueSetExpansionContains.Link : TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains(inherited Link);
end;

function TFhirValueSetExpansionContains.Clone : TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains(inherited Clone);
end;

{ TFhirValueSetExpansionContains }

Procedure TFhirValueSetExpansionContains.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirValueSetExpansionContains.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := System.value;
end;

Procedure TFhirValueSetExpansionContains.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirValueSetExpansionContains.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirValueSetExpansionContains.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := Code.value;
end;

Procedure TFhirValueSetExpansionContains.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirValueSetExpansionContains.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirValueSetExpansionContains.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := Display.value;
end;

Procedure TFhirValueSetExpansionContains.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;


{ TFhirValueSetExpansionContainsList }
procedure TFhirValueSetExpansionContainsList.AddItem(value: TFhirValueSetExpansionContains);
begin
  assert(value.ClassName = 'TFhirValueSetExpansionContains', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetExpansionContains');
  add(value);
end;


function TFhirValueSetExpansionContainsList.Append: TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetExpansionContainsList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetExpansionContainsList.Clone: TFhirValueSetExpansionContainsList;
begin
  result := TFhirValueSetExpansionContainsList(inherited Clone);
end;

function TFhirValueSetExpansionContainsList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetExpansionContainsList.GetItemN(index: Integer): TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionContainsList.IndexOf(value: TFhirValueSetExpansionContains): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirValueSetExpansionContainsList.Insert(index: Integer): TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetExpansionContainsList.InsertItem(index: Integer; value: TFhirValueSetExpansionContains);
begin
  assert(value is TFhirValueSetExpansionContains);
  Inherited Insert(index, value);
end;

function TFhirValueSetExpansionContainsList.Item(index: Integer): TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionContainsList.Link: TFhirValueSetExpansionContainsList;
begin
  result := TFhirValueSetExpansionContainsList(inherited Link);
end;

procedure TFhirValueSetExpansionContainsList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetExpansionContainsList.SetItemByIndex(index: Integer; value: TFhirValueSetExpansionContains);
begin
  assert(value is TFhirValueSetExpansionContains);
  FhirValueSetExpansionContains[index] := value;
end;

procedure TFhirValueSetExpansionContainsList.SetItemN(index: Integer; value: TFhirValueSetExpansionContains);
begin
  assert(value is TFhirValueSetExpansionContains);
  ObjectByIndex[index] := value;
end;

end.

